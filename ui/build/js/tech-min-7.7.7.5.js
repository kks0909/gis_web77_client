//Глобальный объект для внешнего взаимодействия (любые интерфейсные взаимодействия для вызова функций)
ExternalInteraction = {};

//константы задач
ExternalInteraction.MAP = "MAP";
ExternalInteraction.MULT_MAIN		= "MULT_MAIN";
ExternalInteraction.GRID 			= "GRID";
ExternalInteraction.CAS 				= "CAS";
ExternalInteraction.PROP 			= "PROP";
ExternalInteraction.EXPORT_EXCEL 	= "EXPORT_EXCEL";
ExternalInteraction.EXPORT_GPX 		= "EXPORT_GPX";
ExternalInteraction.EXPORT_IMG 		= "EXPORT_IMG";
ExternalInteraction.EXPORT_DOC 		= "EXPORT_DOC";
ExternalInteraction.EXPORT_WRL 		= "EXPORT_WRL";

ExternalInteraction.DEFAULT_URL 		= "";
ExternalInteraction.DEFAULT_WINDOW_TEMPLATE 		= "default";

//название функций синхронизации
ExternalInteraction.EXPORT_EXCEL_FUNCTION 			= "exportExcel";
ExternalInteraction.EXPORT_GPX_FUNCTION 				= "exportGPX";
ExternalInteraction.CAS_SHOW_MAP_FUNCTION 			= "showMap";
ExternalInteraction.CAS_SHOW_LINE_FUNCTION 			= "showLine";
ExternalInteraction.FILTER_DATA_FUNCTION 			= "filterData";
ExternalInteraction.FILTER_DATA_FUNCTION_CALLBACK 	= "callbackFilter";
ExternalInteraction.SHOW_OBJECTS_FUNCTION    		= "showObjects";
ExternalInteraction.SHOW_VIDEO_FUNCTION    			= "showVideo";

ExternalInteraction.FUNCTION_ERROR = gis_externalinteraction_1;
ExternalInteraction.FUNCTION_MAP_ERROR = gis_externalinteraction_2;
ExternalInteraction.FUNCTION_ERROR_TITLE = gis_externalinteraction_3;
ExternalInteraction.CALLBACK_FUNCTION_ERROR = gis_externalinteraction_4;
ExternalInteraction.CALLBACK_FUNCTION_ERROR_TITLE = gis_externalinteraction_5;
ExternalInteraction.OPEN_WINDOW_ERROR = gis_externalinteraction_6;
ExternalInteraction.OPEN_WINDOW_ERROR_TITLE = gis_externalinteraction_7;
ExternalInteraction.EXTERNAL_INTERFACE_ERROR = gis_externalinteraction_8;
ExternalInteraction.EXTERNAL_INTERFACE_ERROR_TITLE = gis_externalinteraction_9;

/*Функции для вызова функций взаимодействия (с обработкой результатов вызова)*/

ExternalInteraction.callbackFunction = function (windowId /*String*/, funcName /*String*/, params /*Array*/, showErrorMessage /*Boolean = false*/) {
    /*Сейчас проверки наличия внешнего интерфейса не делаем, однако в будущем нужно проверять наличие интерфейса для функций виджета, если это возможно*/
    if(true /*ExternalInterface.available*/)
    {
        //вызывает открытие окна и результат идентификатор окна или null
        var result = callbackFunction(windowId, funcName, params);
        if(!showErrorMessage)
            return -1;
        if(result == -1)
        {
            App.errorReport(ExternalInteraction.FUNCTION_ERROR_TITLE, ExternalInteraction.FUNCTION_MAP_ERROR, undefined, {filename:gis_filename_118, functionname:'gis_filename_118_1'});
            return -1;
        }
        if(result == 0)
        {
            App.errorReport(ExternalInteraction.FUNCTION_ERROR_TITLE, ExternalInteraction.FUNCTION_ERROR.replace('{0}',funcName), undefined, {filename:gis_filename_118, functionname:'gis_filename_118_2'});
            return 0;
        }
    }
    else
        App.errorReport(ExternalInteraction.EXTERNAL_INTERFACE_ERROR_TITLE, ExternalInteraction.EXTERNAL_INTERFACE_ERROR.replace('{0}',"callbackFunction"), undefined, {filename:gis_filename_118, functionname:'gis_filename_118_3'});
    return -1;
};

//взаимодействие с открытым окном
ExternalInteraction.callFunction = function (windowId /*String*/, funcName /*String*/, params /*Array*/) {
    /*Сейчас проверки наличия внешнего интерфейса не делаем, однако в будущем нужно проверять наличие интерфейса для функций виджета, если это возможно*/
    if(true /*ExternalInterface.available*/)
    {
        //вызывает открытие окна и результат идентификатор окна или null
        //временно перенаправляем вызов на js карту (if widgetMap != undefined или что-то подобное в качестве проверка)
        if(funcName == "showObjects")
            return WidgetMap.showObjects(params);
        if(funcName == "filterData")
            return WidgetMap.filterData(params);
        else if(funcName == "showVideo")
            return WidgetMap.showVideo();
        else if(funcName == "updateCacheLayer")
            return WidgetMap.updateCacheLayer(params);
        else
            return callFunction(windowId, funcName, params);
    }
    App.errorReport(ExternalInteraction.EXTERNAL_INTERFACE_ERROR_TITLE, ExternalInteraction.EXTERNAL_INTERFACE_ERROR.replace('{0}',"callFunction"), undefined, {filename:gis_filename_118, functionname:'gis_filename_118_4'});
    return -1;
};

function BaseDataAdapter(opt_options){
	var options = opt_options !== undefined ? opt_options : {};
	this.updateCompleteHandler = (opt_options.updateCompleteHandler !== undefined)? options.updateCompleteHandler : undefined;
	this.source = (opt_options.source !== undefined || opt_options.source != '')? options.source : 'SYS_SEM.xml';
	this.requestSource = opt_options.requestSource !== undefined ? options.requestSource : '';
	this.sendData = goog.isDef(options.sendData) ? options.sendData : '<data/>';
	this.dataCollection_ = [];
	this.resultHandler_ = opt_options.resultHandler !== undefined ? options.resultHandler : undefined;
	// Запрос на получение данных
	this.selectSQL = opt_options.selectSQL !== undefined ? options.selectSQL : '';
	// Запрос на обновление данных
	this.updateSQL = opt_options.updateSQL !== undefined ? options.updateSQL : '';
	// Запрос на добавление данных
	this.insertSQL = opt_options.insertSQL !== undefined ? options.insertSQL : '';
	// Запрос на удаление данных
	this.deleteSQL = opt_options.deleteSQL !== undefined ? options.deleteSQL : '';


	this.added = opt_options.added !== undefined ? options.added : {};
	this.deleted = opt_options.deleted !== undefined ? options.deleted : {};
	this.modified = opt_options.modified !== undefined ? options.modified : {};
	this.modifiedCnt = 0;

	this.updateInfo = {};
	this.errorsText = '';

	this.currUpdateCnt = 0;
	this.currErrorCnt = 0;

	// Команда на добавление данных
	this.insertProcName = 'insert';
	// Команда на обновление данных
	this.updateProcName = 'update';
	//Команда на удаление данных
	this.deleteProcName = 'delete';


};

BaseDataAdapter.prototype.fill = function(){
	var that = this;
	//Проверяем что requestSource непустой, иначе ничего не запрашиваем.
	if (this.requestSource !== ''){
		BlockingUtil.wait();
		var reqParams = this.getReqParams(this.requestSource,this.sendData,'select',true);
		if(this.requestSource.indexOf('IUST_SEM_DICT.xml') !== -1 || this.requestSource.indexOf('ADM_SEM.xml') !== -1 && requestSource.indexOf('GAZPROM_ADM_SEM.xml') === -1){
			App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,reqParams,function(resultXml){
				BlockingUtil.ready();
				that.result_(resultXml);
			}, function(resultXml){
				BlockingUtil.ready();
				that.fault_(resultXml);
			});
		}
		else {
			App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
				BlockingUtil.ready();
				that.result_(resultXml);
			}, function(resultXml){
				BlockingUtil.ready();
				that.fault_(resultXml);
			});
		}

	}
};

BaseDataAdapter.prototype.getReqParams = function(requestSource, sendData, descrType, schema) {
	if(descrType === undefined)
		descrType = 'select';
	if(schema === undefined)
		schema = false;
	var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
	var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
	var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
	return {
		getSchema: schema,
		descrId: requestSource,
		toElements: false,
		descrType: descrType,
		data:  '<root USER_ID="'+userId.xmlEscape()+
		'" USER_LOGIN="'+userLogin.xmlEscape()+
		'" PODS_USER="'+userLogin.xmlEscape()+
		'" '+ topFiltersStr+''+
		'>'+
		sendData +
		'</root>'
	};
};

BaseDataAdapter.prototype.result_ = function(resultXml){
	var er = HTTPServiceUtil.getError(resultXml);
	this.dataCollection = [];
	this.attrs = [];
	if(er !== ''){
		App.errorReport(gis_basedataadapter_1, er,undefined,{filename:gis_filename_5, functionname:'BaseDataAdapter.prototype.result_'});
		return;
	}
	else{
		var layerGeoXml = ($.parseXML(resultXml)).firstChild;
		var datas = layerGeoXml.getElementsByTagName("data");
		var xsAttrs = $(layerGeoXml).find('xs\\:attribute,attribute');
		var isXsAttrs = false;//была ли схема в запросе
		if(xsAttrs.length>=0){
			isXsAttrs = true;
			for(var a=0; a<xsAttrs.length;a++){
				this.attrs.push(xsAttrs[a].getAttribute('name'));
			}
		}
		//формируем объект с атрибутами и данными
		for (var i = 0; i < datas.length; i++) {
			var obj = {};
			for (var j = 0; j < datas[i].attributes.length; j++) {
				if(i == 0 && isXsAttrs == false)
					this.attrs.push(datas[i].attributes[j].name);
				obj[datas[i].attributes[j].name] = datas[i].attributes[j].value;
			}
			this.dataCollection.push(obj);
		}
	}
	if(this.resultHandler_ !== undefined){
		this.resultHandler_.apply(this,[this.attrs,this.dataCollection]);
	}
};


BaseDataAdapter.prototype.fault_ = function(resultXml){
	var er = HTTPServiceUtil.getError(resultXml);
	if(er !== ''){
		App.errorReport(gis_basedataadapter_1, er,undefined,{filename:gis_filename_5, functionname:'BaseDataAdapter.prototype.fault_'});
	}
};

/** Обновление данных в БД и внешней подсистеме, генерация события с количеством обновленных данных */
BaseDataAdapter.prototype.update = function(){
	this.errorsText = "";
	var uid = '';
	var cnt = 0;
	this.currUpdateCnt = 0;
	this.currErrorCnt = 0;
	this.updateInfo["completed"] = false;
	this.updateInfo["errors"] = 0;
	var hasChanges = false;
	if (this.insertSQL != ""){
		for(uid in this.added){
			this.currUpdateCnt++;
			this.executeCommand_(this.insertProcName, this.insertSQL, this.added[uid]);
			cnt++;
		}
		this.updateInfo["added"] = cnt;

	}
	if(cnt > 0) hasChanges = true;
	cnt = 0;
	if (this.deleteSQL != ""){
		for(uid in this.deleted){
			this.currUpdateCnt++;
			this.executeCommand_(this.deleteProcName, this.deleteSQL, this.deleted[uid]);
			cnt++;
		}
		this.updateInfo["deleted"] = cnt;
	}
	if(cnt > 0) hasChanges = true;
	cnt = 0;
	if (this.updateSQL != ""){
		for(uid in this.modified){
			this.currUpdateCnt++;
			this.executeCommand_(this.updateProcName, this.updateSQL, this.modified[uid]);
			delete this.modified[uid];
			this.modifiedCnt--;
			cnt++;
		}
		this.updateInfo["modified"] = cnt;
	}
	else{
		for(uid in this.modified){
			delete this.modified[uid];
			this.modifiedCnt--;
		}
		delete this.updateInfo["modified"];
	}
	if(cnt > 0) hasChanges = true;
	this.updateInfo["completed"] = true;

};

BaseDataAdapter.prototype.executeCommand_ = function(procName, cmd, item){
	if(cmd !== undefined && cmd.length != 0){
		var fullCmd = this.makeCommand_(cmd, item);
		this.sendCommand_(procName, fullCmd);
	}
};

/**
 * Подстановка в команду параметров вида :xxx,
 * где xxx - имя атирбута узла item
 */
BaseDataAdapter.prototype.makeCommand_ = function(cmd, item){
	var sendData = '<data/>';
	if(cmd !== undefined && cmd.length != 0){
		sendData = '<data ';
		for(var attr in item){
			if(attr == 'uid')
				continue;
			sendData += attr+'="'+item[attr]+'" ';
		}
		sendData += '/>';
	}
	return sendData;
};

/** Отправка команды в БД */
BaseDataAdapter.prototype.sendCommand_ = function(procName, cmd){
	var that = this;
	if(cmd !== undefined && cmd.length != 0  && this.source !== ''){
		switch (procName)
		{
			case this.deleteProcName:
				BlockingUtil.wait();
				var reqParams = this.getReqParams(this.source+"#"+this.deleteSQL, cmd, procName);
				App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
					BlockingUtil.ready();
					that.resultExec_(resultXml);
				}, function(resultXml){
					BlockingUtil.ready();
					that.faultExec_(resultXml);
				},4);
				break;
			case this.insertProcName:
				BlockingUtil.wait();
				var reqParams = this.getReqParams(this.source+"#"+this.insertSQL, cmd, procName);
				App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
					BlockingUtil.ready();
					that.resultExec_(resultXml);
				}, function(resultXml){
					BlockingUtil.ready();
					that.faultExec_(resultXml);
				},4);
				break;
			case this.updateProcName:
				BlockingUtil.wait();
				var reqParams = this.getReqParams(this.source+"#"+this.updateSQL, cmd, procName);
				App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
					BlockingUtil.ready();
					that.resultExec_(resultXml);
				}, function(resultXml){
					BlockingUtil.ready();
					that.faultExec_(resultXml);
				},4);
				break;
			default:
				break;
		}
	}
};

BaseDataAdapter.prototype.resultExec_ = function(resultXml){
	var er = HTTPServiceUtil.getError(resultXml);
	if(er !== ''){
		this.currErrorCnt++;
		this.errorsText += gis_basedataadapter_2+er+"\n";
	}
	this.currUpdateCnt--;
	if (this.currUpdateCnt == 0){
		this.clearAllChanges_();
	}
	if ((this.currUpdateCnt == 0) && (this.updateInfo["completed"] == true)){
		if (this.currErrorCnt>0){
			this.updateInfo["errors"] = this.currErrorCnt;
			if (this.errorsText != ""){
				App.errorReport(gis_basedataadapter_3, er,undefined,{filename:gis_filename_5, functionname:'BaseDataAdapter.prototype.resultExec_'});
			}
		}
		this.dataUpdateComplete_(this.updateInfo);
		this.fill();
	}

};


BaseDataAdapter.prototype.faultExec_ = function(resultXml){
	this.currUpdateCnt--;
	this.currErrorCnt++;
	if (this.currUpdateCnt == 0){
		this.clearAllChanges_();
	}
	if ((this.currUpdateCnt == 0) && (this.updateInfo["completed"] == true)){
		if (this.currErrorCnt>0)
			this.updateInfo["errors"] = this.currErrorCnt;
		this.dataUpdateComplete_(this.updateInfo);
	}
};

//вспомогательная функция для очистки объектов с изменениями
BaseDataAdapter.prototype.clearAllChanges_ = function(resultXml){
	//очищаем список изменений полностью
	var uid;
	for (uid in this.added){
		delete this.added[uid];
	}
	for (uid in this.deleted){
		delete this.deleted[uid];
	}
	for (uid in this.modified){
		delete this.modified[uid];
	}
	this.modifiedCnt = 0;
};


/**
 * Функция обработчки события окончания обновления данных.
 * Отображает информацию об изменениях в данных
 * @param updateInfo
 * @private
 */
BaseDataAdapter.prototype.dataUpdateComplete_ = function(updateInfo){
	if(this.updateCompleteHandler !== undefined){
		this.updateCompleteHandler.apply(this,[updateInfo]);
		return;
	}
};
/**
 * Provider для DataGridWithScript
 */
function GridDataProvider(opt_options){
    var that = this;
    var options = goog.isDef(opt_options) ? opt_options : {};
    var sort_ = goog.isDef(options.sort) ? options.sort : null;
    var type = goog.isDef(options.type) ? options.type : 'sql';
    var requestSource = goog.isDef(options.requestSource) ? options.requestSource : null;
    var sendData = goog.isDef(options.sendData) ? options.sendData : '<data/>';
    this.dataCollection_ = [];
    this.resultHandler_ = goog.isDef(options.resultHandler) ? options.resultHandler : undefined;
    this.currentRequest;
    this.isAborted = false;

    //Проверяем что requestSource непустой, иначе ничего не запрашиваем.
    if (!goog.isNull(requestSource) && requestSource !== ''){
        BlockingUtil.wait();
        var reqParams = this.getReqParams(requestSource,sendData);
        if(requestSource.indexOf('IUST_SEM_DICT.xml') !== -1  || type === 'file'){
            this.currentRequest = App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,reqParams,function(resultXml){
                BlockingUtil.ready();
                that.result_(resultXml);
            }, function(resultXml){
                BlockingUtil.ready();
                if (!that.isAborted)
                    that.fault_(resultXml);
                that.isAborted = false;
            });
        }
        else {
            this.currentRequest = App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXml) {
                BlockingUtil.ready();
                that.result_(resultXml);
            }, function (resultXml) {
                BlockingUtil.ready();
                if (!that.isAborted)
                    that.fault_(resultXml);
                that.isAborted = false;
            });
        }
    }

};


GridDataProvider.prototype.cancelRequest = function(){
    if(this.currentRequest !== undefined){
        try{
            this.isAborted = true;
            this.currentRequest.abort();
        }
        catch(e){}
    }
};

GridDataProvider.prototype.getReqParams = function(requestSource, sendData) {
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
    return {
        getSchema: false,
        descrId: requestSource,
        toElements: false,
        descrType: 'select',
        data:  '<root USER_ID="'+userId.xmlEscape()+
        '" USER_LOGIN="'+userLogin.xmlEscape()+
        '" PODS_USER="'+userLogin.xmlEscape()+
        '" '+ topFiltersStr+''+
        '>'+
        sendData+
        '</root>'
    };
};

GridDataProvider.prototype.result_ = function(resultXml){
    var er = HTTPServiceUtil.getError(resultXml);
    this.dataCollection_ = [];
    if(er !== ''){
        App.errorReport(gis_griddataprovider_1, er,undefined,{filename:gis_filename_6, functionname:'GridDataProvider.prototype.result_'});
        return;
    }
    else{
        try{
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var datas = layerGeoXml.getElementsByTagName("data");
            for (var i = 0; i < datas.length; i++) {
                var wktStr = datas[i].getAttribute("WKT");
                if (!goog.isDefAndNotNull(wktStr) || wktStr== ''){
                    var obj = {};
                    var attrNamesList = datas[i].attributes;
                    for(var j=0; j<attrNamesList.length; j++){
                        var str =  attrNamesList[j].nodeName;
                        obj[str] = attrNamesList[j].nodeValue;
                    }
                    this.dataCollection_.push(obj);
                }
            }
        }
        catch(ex){
            this.dataCollection_ = [];
            App.errorReport(gis_griddataprovider_1, er,undefined,{filename:gis_filename_6, functionname:'gis_filename_6_1'});
        }
        
    }
    if(goog.isDefAndNotNull(this.resultHandler_)){
        this.resultHandler_.apply(this.dataCollection_);
    }
};

GridDataProvider.prototype.fault_ = function(resultXml){
    var er = HTTPServiceUtil.getError(resultXml);
    if(er !== ''){
        App.errorReport(gis_griddataprovider_1, er,undefined,{filename:gis_filename_6, functionname:'GridDataProvider.prototype.fault_'});
    }
};

GridDataProvider.prototype.getCoordsFromWKT = function(WKTString){
    return [];
};
/**
 * Provider для DataGridWithScript
 */
function QueryDataProvider(opt_options){
    var that = this;
    var options = goog.isDef(opt_options) ? opt_options : {};
    var sort_ = goog.isDef(options.sort) ? options.sort : null;
    var requestSource = goog.isDef(options.requestSource) ? options.requestSource : null;
    var sendData = goog.isDef(options.sendData) ? options.sendData : '<data/>';
    this.dataField = goog.isDef(options.dataField) ? options.dataField : 'CODE';
    this.labelField = goog.isDef(options.labelField) ? options.labelField : 'DESCR';
    this.dataCollection_ = [];
    this.resultHandler_ = goog.isDef(options.resultHandler) ? options.resultHandler : undefined;

    //Проверяем что requestSource непустой, иначе ничего не запрашиваем.
    if (!goog.isNull(requestSource) && requestSource !== ''){
        BlockingUtil.wait();
        var reqParams = this.getReqParams(requestSource,sendData);
        if(requestSource.indexOf('IUST_SEM_DICT.xml') !== -1 || requestSource.indexOf('ADM_SEM.xml') !== -1 && requestSource.indexOf('GAZPROM_ADM_SEM.xml') === -1){
            App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,reqParams,function(resultXml){
                that.result_(resultXml);
            }, function(resultXml){
                that.fault_(resultXml);
            });
        }
        else{
            App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
                that.result_(resultXml);
            }, function(resultXml){
                that.fault_(resultXml);
            });
        }
    }
};



QueryDataProvider.prototype.getReqParams = function(requestSource, sendData) {
    //TODO избавится от упоминания в запросах других форм AbstractFormDialog.sendUser
    var userId = Auth.getUserId();
    var userLogin = Auth.getUserName();
    var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
    return {
        getSchema: false,
        descrId: requestSource,
        toElements: false,
        descrType: 'select',
        data:  '<root USER_ID="'+userId.xmlEscape()+
        '" USER_LOGIN="'+userLogin.xmlEscape()+
        '" PODS_USER="'+userLogin.xmlEscape()+
        '" '+ topFiltersStr+''+
        '>'+
        sendData+
        '</root>'
    };
};

QueryDataProvider.prototype.result_ = function(resultXml){
    BlockingUtil.ready();
    var er = HTTPServiceUtil.getError(resultXml);
    this.dataCollection_ = [];
    if(er !== ''){
        App.errorReport(gis_querydataprovider_1, er,undefined,{filename:gis_filename_7, functionname:'QueryDataProvider.prototype.result_'});
        //Результат возвращаем в любом случае
        if(goog.isDefAndNotNull(this.resultHandler_)){
            this.resultHandler_.apply(null);
        }
        return;
    }
    else{
        var resArray = [];
        var unknownElem;
        //Если не будет найдено нулевое числовое значение, подставим минимальное из отрицательных чисел.
        var minNegNumUnknown = {num:0, obj:undefined};
        //var layerGeoXml = ($.parseXML(resultXml)).firstChild;
        //var datas = layerGeoXml.getElementsByTagName("data");
        var datas = $(resultXml).find('data');
        var i = 0;
        for (i; i < datas.length; i++) {
            var obj = {};
            var attrNamesList = datas[i].attributes;
            for(var j=0; j<attrNamesList.length; j++){
                var str =  attrNamesList[j].nodeName.toUpperCase();
                obj[str] = attrNamesList[j].nodeValue;
                if(str == this.dataField){
                    if ((obj[str].indexOf("UNKNOWN") == 0) || (obj[str] == '0')
                        || (obj[str] == gis_querydataprovider_2) || (obj[str]==gis_querydataprovider_3)
                        || (!goog.isNumber(parseFloat(obj[str])) && parseFloat(obj[str]) == 0))
                        unknownElem = obj;
                    //Сохраняем элемент как резервный по-умолчанию только если его CODE числовой и <0
                    if ((!goog.isNumber(parseFloat(obj[str]))
                        && parseFloat(obj[str])<minNegNumUnknown.num )){
                        minNegNumUnknown.num = parseFloat(obj[str]);
                        minNegNumUnknown.obj = obj;
                    }
                }
            }
        	//upd. 14.04.18 если на пришло labelField("DESCR"), то заполняем его ''
            if( ! goog.isDef(obj[this.labelField]))
	            obj[this.labelField] = ' ';
            if (goog.isDef(obj[this.dataField]))
                resArray.push(obj);
            else{//если объект без CODE или DESCR, не включаем его в список
                if (unknownElem == obj)
                    unknownElem = undefined;
            }
            //ставим на первое место элемент со свойством "UNKNOWN"
            if (goog.isDef(unknownElem)){
                resArray.splice(resArray.indexOf(unknownElem),1);
                // ставим явно в начало
                resArray.unshift(unknownElem);
            }
            else{
                //подставляем объект с минимальным из числовых отрицательных CODE (если у него num!=0)
                if (goog.isDef(minNegNumUnknown.obj)){
                    resArray.splice(resArray.indexOf(minNegNumUnknown.obj),1);
                    // ставим явно в начало
                    resArray.unshift(minNegNumUnknown.obj);
                }
            }
        }
        if(unknownElem == undefined) {
            //если после обработки данных нет элемента unknown, то его добавляем
	        resArray.unshift({CODE:'0',DESCR:gis_querydataprovider_4});
        }
        this.dataCollection_ = resArray;
    }
    if(goog.isDefAndNotNull(this.resultHandler_)){
        this.resultHandler_.apply(this.dataCollection_);
    }
};


QueryDataProvider.prototype.fault_ = function(resultXml){
    BlockingUtil.ready();
    var er = HTTPServiceUtil.getError(resultXml);
    if(er !== ''){
        App.errorReport(gis_querydataprovider_1, er,undefined,{filename:gis_filename_7, functionname:'QueryDataProvider.prototype.fault_'});
    }
    //Результат возвращаем в любом случае
    if(goog.isDefAndNotNull(this.resultHandler_)){
        //this.resultHandler_.apply(null);
        this.resultHandler_.apply([]);
    }
};
/**
 * Конструктор главного меню 
 */
function UserSettings() {
    this.container = null;
    this.xml = null;    
    this.structure = null;
    this._tasks = {};
    
    this._defaultItem = null;
    this._defaultCount = [];
    this._onChoice = null;
    this.requestUserWithRole = "ADM_SEM.xml#WEB50_B_USER_PRIVATE";
};

/**
 * Установка контейнера для меню 
 */
UserSettings.prototype.setContainer = function(container) {
    this.container = container;
};

/**
 * Установка XML данных
 */
UserSettings.prototype.setXml = function(xml) {
    this.xml = xml;
    this.initStructure();
};

/**
 * Установка обработчика выбора пункта меню 
 */
UserSettings.prototype.onChoice = function(onChoice) {
    this._onChoice = onChoice;
};

/**
 * Загрузка и подготовка структуры меню
 */
UserSettings.prototype.build = function() {
    if(!this.structure) {
        this.initStructure();                    
    }

    this.getCurrentUserData_();
    this._buildMenuElements();
    this._addPopupEvents();
    this._addChoiceEvents();
    this._menuShowEvent();

};
UserSettings.prototype.setDefaultName = function(){
    var userDefaultName = Auth.getUserName();
    $('.user-name').text(userDefaultName).attr('title',userDefaultName);
    //TODO вынести в отдельную обработку
    if(userDefaultName.length <=16)//кол-ва символов, при которых стоит выводить имя и фамилию в 2 строки
        $('.user-name').css('line-height', '4em');
    $('.user-letter').text(userDefaultName[0]);
};
UserSettings.prototype._setDefaultItem = function(defaultItem) {
    this._defaultItem = defaultItem;
};

/*
 * Возвращает имя пункта меню по умолчанию (в виде строки) 
 */
UserSettings.prototype.getDefaultItemName = function() {
    if(this._defaultItem) {
        return this._defaultItem.name;
    }           
    return null;
};

/*
 * Возвращает имя пункта меню по умолчанию (в виде структуры) 
 */
UserSettings.prototype.getDefaultTask = function() {
    if(this._defaultItem) {
        return this._defaultItem;
    }   
    return null;
};


/**
 * Получение информации о пользователе
 */

UserSettings.prototype.getCurrentUserData_ = function() {
    var that = this;
    function getCurrentUserDataParams( request) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '">'+
            '<data FILTER="'+' d.USER_ID='+userId+'" />'+
            '</root>'
        };
    }

    function getCurrentUserDataResult(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            that.setDefaultName();
            return;
        }
        that.longStr = '';
        //делаем разбор пришедших данных и добавляем их в mailMessage.text
        var userFirstName = '';
        var userLastName = '';
        var userFullName = '';

        var resultXml = ($.parseXML(resultXml)).firstChild;
        var datas = resultXml.getElementsByTagName("data");
        if(datas.length>0){
            var data = datas[0];
            userFirstName = goog.isNull(data.getAttribute("FIRSTNAME"))?'':data.getAttribute("FIRSTNAME")+' ';
            userLastName = goog.isNull(data.getAttribute("LASTNAME"))?'':data.getAttribute("LASTNAME");
            userFullName = userFirstName + userLastName;
            var themeAttr = goog.isNull(data.getAttribute("THEME"))?'':data.getAttribute("THEME")+'';
            //получаем флаги на режим открытия карты и показ обзорной карты
            if(themeAttr !== ''){
                try{
                    var theme = JSON.parse(themeAttr.replace(/&quot;/g,'"'));
                    var mode = MapUtil.getAvailableMapMode(theme.MAP_MODE);
                    if(goog.isDef(WidgetMap)){
                        MapUtil.applyThemeParams({
                            mapMode: mode,
                            showOverviewMap: theme.SHOW_OVERVIEW_MAP === true,
                            showTree: theme.SHOW_TREE === true,
                            sendCadastreEmail: theme.SEND_CADASTRE_EMAIL === true,
                            showCenterMap: theme.SHOW_CENTER_MAP === true,
                            coordMode: theme.COORD_MODE,
                            useSynchronization: theme.USE_SYNCHRONIZATION === true,
                        },true);
                    }
                }
                catch(e){

                }
            }
        }
        if(userFullName) {
            $('.user-name').text(userFullName).attr('title',userFullName);
            //TODO вынести в отдельную обработку
	        if(userFullName.length <=16)//кол-ва символов, при которых стоит выводить имя и фамилию в 2 строки
		        $('.user-name').css('line-height', '4em');
            $('.user-letter').text(userFullName[0]);
        }else{
            that.setDefaultName();
        }

    }
    function getCurrentUserDataFault(resultXml) {
        that.setDefaultName();
    }

    App.serverQueryXML2Node(Services.processQueryNode, getCurrentUserDataParams( this.requestUserWithRole ), getCurrentUserDataResult, getCurrentUserDataFault);

};

/**
 * Построение структуры меню из XML данных
 */
UserSettings.prototype.initStructure = function() {
    var that = this;
    // Рекурсивный пробег по структуре меню
    function walkLevel(nodes) {
        var items = [];                   
        
        // Цикл по текущему уровню        
        nodes.each(function(){
            var node = $(this);
            // Это одиночный пункт
            if(node.is('task')) {
                var item = {                        
                    title:  node.attr('descr'),
                    order:  node.attr('order'),
                    format:  node.attr('format'),
	                mask:  node.attr('mask'),
                    name:   node.attr('name'),
                    type:   node.attr('type'),
                    isDefault: node.attr('default') === 'true',
                    mdl:    node.attr('mdl'),
                    newWindow: (node.attr('newWnd') === undefined)?'false':node.attr('newWnd'),
                    auth: (node.attr('auth') === undefined)?'true':node.attr('auth'),
                    group:  false
                };

                // Для начала помечаем самый первый пункт, который не надо открывать в новом окне, как дефолтный                
//                if(!that._defaultItem) {
//                    that._setDefaultItem(item);
//                }

                //игнорируем флэш задачи
                if(item.mdl !== undefined && (item.mdl.indexOf('.swf') != -1 || item.mdl.indexOf('tech_schema.html') != -1 ))
                    return;
                // Не помечен ли этот пункт явно как дефолтный?
                if(node.attr('default') === 'true') {
                    //заносим в отдельный массив все дефолтные
                    that._defaultCount.push(item);
                }
                if(item.type !== undefined)
                    items.push(item);
            }

            // Это группа
            else if(node.is('group')) {
                var children = walkLevel(node.children('task,group'));

                // Какого типа пункты там внутри
                var type = 'main';
                $.each(children, function(i, e){
                    if(e.type === 'user') {
                        type = 'user';
                    }
                });                    

                var itemGroup = {
                    title:    node.attr('descr'),
                    order:    node.attr('order'),
                    format:  node.attr('format'),
	                mask:  node.attr('mask'),
                    children: children,
                    type:     type,
                    group: true// добавляем элемент, чтобы в следующих проверках не дублировать
                };                     
                items.push(itemGroup);
            }            
        }); 
        return items;
    }

    //
    // Второй рекурсивный пробег (чтобы сделать плоский список пунктов меню)
    //
    function walkStruct2(items) {
        $.each(items, function(i, item){
            if(item.name /*&& item.mdl*/) {
                if(item.mdl === 'main_js.html')
                    item.name = item.name.toLowerCase();
                that._tasks[ item.name ] = item;
            }
            if(item.children) {
                walkStruct2(item.children);
            }
        });
    }

    //Начинаем строить меню
    try {
        // Начало рекурсии
        //this.structure = walkLevel(this.xml.children('data').children('task,group'));
        this.structure = walkLevel(this.xml.find('task,group'));

        this._addHardItems();

        walkStruct2(this.structure);
        //Не помечен ли этот пункт явно как дефолтный?
        var i = 0;
        //проходимся по всем дефолтным. Если первая деволтная и в общем списке задач у неё атрибут default = true, то завершаем цикл
        //и выставляем её дефолтной
        for(i;i < this._defaultCount.length; i++){
            if(this._tasks[this._defaultCount[i].name] !== undefined && this._tasks[this._defaultCount[i].name].isDefault){
                this._setDefaultItem(this._tasks[this._defaultCount[i].name]);
                break;
            }
        }
    }
    catch (e) {
        App.errorReport(gis_usersettings_2, e, undefined, {filename:gis_filename_286, functionname:'gis_filename_286_1'});
    }
};



/**
 * Построение меню по структуре
 */
UserSettings.prototype._buildMenuElements = function() {
    var num = 0;
    var container = this.container;
    // уникальные названия задач
    var uniqTasksName = {};

    // Добавляет выпадающее меню
    function addPopup(root, items) {
        num ++;

        var ul = $('<ul class="popup" />').appendTo(container);            
        root.attr('data-popupId', 'popup'+num);
        ul.attr('id', 'popup'+num);
        $.each(items, function(i, item){
            var uniqueName = (item.group)?item.title:item.name;
            if(uniqueName !== undefined)
                uniqTasksName[uniqueName] = uniqueName;
            var li = $('<li />').text(item.title);
            if(item.name) {                    
                li.wrapInner($('<a/>').attr('href', ''+item.name));
            }
            ul.append(li);
        });        
    }

    try {
        container.append(
            '<div class="user-button">' +
                '<span class="user-letter"></span>' +
            '</div>'
        );
        // Построение контейнеров для главного и пользовательского меню
        container.append(
            '<div class="userMenu">' +
            '<div class="user-profile"><div class="user user-letter"> </div><div class="user-name"></div></div>' +
                '<ul class="top">'+
                    '<li class="tasks"><a>Задачи/Приложения</a></li>' +
                '</ul>' +
            '</div>'
        );

        var tasksLi = $('.userMenu ul.top li.tasks', container);
        var userUl = $('.userMenu ul.top', container);
        var tasksList = []; //Для списка пунктов меню, которые будут в popUp для taskLi

        // Добавляем пункты меню
        $.each(this.structure, function(i, item){
            if(item.type === 'user' || item.type === 'main') {
                var uniqueName = (item.group)?item.title:item.name;
                if(uniqTasksName[uniqueName] !== undefined )
                    return;
                if(uniqueName !== undefined)
                    uniqTasksName[uniqueName] = uniqueName;
                var li = $('<li />').text(item.title);
                if(item.name) {
                    li.wrapInner($('<a/>').attr('href', ''+item.name));
                }
                else {
                    li.wrapInner('<a/>');
                }

                if(item.children) {
                    addPopup(li, item.children);
                }

                if(item.type === 'user') {
                    userUl.append(li);
                }
                else {
                    tasksList.push(item)//добавляем пункты задач в список, для добавления в popUp
                }
            }
        });
        if(tasksList.length)
            addPopup(tasksLi, tasksList);//добавляем список задач в popUp
        else{
            tasksLi.remove();
        }
    }
    catch (e) {
        App.errorReport(gis_usersettings_2, e, undefined, {filename:gis_filename_286, functionname:'gis_filename_286_2'});
    }
};

/**
 * Добавление событий выпадающих попапов
 */
UserSettings.prototype._addPopupEvents = function() {
    var timer;
    // Открывание попапов
    $("ul.top > li", this.container).mouseover(function(){
        var id = $(this).attr('data-popupId');
        $('ul.popup', this.container).hide();
        if(id) {
            //var right = $(this).position().right;
            var top = $(this).position().top;
            var right =$('.userMenu').width();//$('#'+id).width();
            right += 15;
            top +=30;

            $('#'+id).css({right:right, top:top}).show();
        }
    });

    // Если мышка покинула, то закрываем попапы через небольшой интервал
    $("ul", this.container).mouseleave(function(){
        timer = window.setInterval(function(){
           $("ul.popup", this.container).hide();
        }, 200);        
    });        

    // Отмена отложенного закрывания попапа, если мышь вернулась в меню
    $("ul", this.container).mouseenter(function(){
        window.clearInterval(timer);
    });   
};
/**
 * Установка события показа меню
 */
UserSettings.prototype._menuShowEvent = function() {
    $('body').click(function () {
        $('.userMenu').hide();
    });
    $('.user-button').click(function (e) {
        e.stopPropagation();
        $('.userMenu').toggle();
    });
    $(".userMenu", this.container).click(function(e){
        e.stopPropagation();
    });
};

/**
 * Установка события выбора пункта меню
 */
UserSettings.prototype._addChoiceEvents = function() {
    var that = this;
    
    $('a[href]', this.container).click(function(event){
        event.preventDefault();
        $("ul.popup", this.container).hide();
        $('.userMenu').hide();
        var name = $(this).attr('href');          
        if(that._onChoice && name) {
            if(that._tasks[name]) {
                that._onChoice(that._tasks[name]);
            }
        }                            
    });           
};


/**
 * Добавление хардкодных пунктов в меню
 */
UserSettings.prototype._addHardItems = function() {
    this.structure.push({
        mdl:   "builtin",
        name:  "USER_CHANGE",
        order: 1,
        title: gis_usersettings_1 +" '" + Auth.getUserName() + "'",
        type:  "user"        
    });    
};

/**
 * Возвращиет заголовок по переданному taskName. Если передан taskName=='', возвращает заголовок текущей задачи
 */
UserSettings.prototype.getTaskTitleByTaskName = function(taskName) {
    var curTask = /task=([^&#^]+)/.exec(window.location.href);
    if(curTask || (taskName && taskName!='')) {
        //Сначала берем текущую задачу
        var curTaskName = curTask[1];
        //Если нужно получить заголовок для конкретной задачи - выбираем ее
        if(taskName && taskName!=''){
            curTaskName = taskName;
        }

        var task = this._tasks[curTaskName];
        if(task && task.title) {
            return task.title;
        }
    }

    return '';
};

/**
 * Устанавливает заголовок окна в соответсвии с тем, какой task указан в url страницы 
 */
UserSettings.prototype.setTitleByCurrentTask = function() {
    var title = this.getTaskTitleByTaskName('');
    if(title && title !=='') {
        var systemName = "";
        //забираем из конфига параметр System_Name для заголовка страницы
        if(App.config !== null && App.config !== undefined)
        {
            if(App.config.hasOwnProperty('SYSTEM_NAME'))
                systemName = App.config.SYSTEM_NAME +". ";
        }
        originalTitle = systemName+title;
        document.title = systemName+title;
    }
};

/**
 * Возвращает MDL. Его значение берется из URL.
 * Если в меню текущего пользователя нет такого task/mdl, то возвращает null
 */
UserSettings.prototype.getMdlFromUrl = function() {
    var m = /task=([^&#^]+)&mdl=([^&#^]+)/.exec(window.location.href);    
    if(m) {
        var task = m[1];
        var mdl  = m[2];
        //Корректируем, если в полученном из текущего url mdl имеется начальный слеш
        if(mdl.charAt(0) === '/') {
            mdl = mdl.substring(1);
        }
        
        var item = this._tasks[task];
        if(item && (mdl === item.mdl)) {
            return item.mdl;
        }
        //если не нашли, то проверяем, мб задача main_js, тогда в нижний регистр её переводим
        if(!item)
            item = this._tasks[task.toLowerCase()];
            if(item && mdl === item.mdl && (item.mdl === 'main_js.html' || item.mdl === 'tech_schema_js.html') ) {
            return item.mdl;
        }
    }
    return null;
};

/**
 * Возвращает TASK. Его значение берется из URL.
 * Если в меню текущего пользователя нет такого task, то возвращает null
 */
UserSettings.prototype.getTaskFromUrl = function() {
    var m = /task=([^&#^]+)/.exec(window.location.href);
    if(m) {
        var task = m[1];
        return task;
    }
    return null;
};

/*
 * Если для выбранной задачи установлен параметр mask, значит для текущего пользователя в текущей задачи будет происходить
 * ограничение по ЛПУ для тайловой подложки с трубопроводами
 */
UserSettings.prototype.setMask = function(task) {
	if(task){
		var item = this._tasks[task];
		if(!item)
            item = this._tasks[task.toLowerCase()];
		 if(item && item.mask && WidgetMap)
			WidgetMap.LPURestrictZoom = item.mask;
	}
};

/*
 * Возвращает тип элемента в меню
 */
UserSettings.prototype.getTaskType = function(task) {
    if(task){
        var item = this._tasks[task];
        if(!item)
            item = this._tasks[task.toLowerCase()];
        if(item)
            return item.type;
    }
    return undefined;
};

/*
 * Возвращает атрибут mdl
 */
UserSettings.prototype.getTaskMdl = function(task) {
    if(task){
        var item = this._tasks[task];
        if(!item)
            item = this._tasks[task.toLowerCase()];
        if(item)
            return item.mdl;
    }
    return null;
};

/*
 * Возвращает тип элемента в меню
 */
UserSettings.prototype.hasTaskAndMdlInMenu = function(task, mdlName) {
    if(task){
        var item = this._tasks[task];
        if(!item)
            item = this._tasks[task.toLowerCase()];
        if(item && item.mdl === mdlName)
            return true;
    }
    return false;
};
/**
 * Класс всплывающей формы с экспортом в GPX или KML
 */
/* TEXT CONSTANTS */

var GPX_TITLE = gis_exportgpxkmlform_2;
var KML_TITLE = gis_exportgpxkmlform_3;

function ExportGpxKmlForm() {
    this.closable = true;
    this.htmlUrl = 'ui/html/ExportGpxKmlForm.html';
    this.exportArray = [];
    this.elementId = undefined;
    this.dataRequest = '';
	this.dataProvider = '';
    this.layerName = '';
	this.requestParams = '';
	this.projection = null;
};

ExportGpxKmlForm.prototype.build = function() {
    var that = this;
    try {
        //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
        function build() {
            //Создаем диалоговую форму
            dlg.dialog({
                modal: true,
                title: gis_exportgpxkmlform_2,
                dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
                closeOnEscape: that.closable,
	            width: 320,
	            height: 203,
	            close: function(event, ui){
		            try{
			            $(this).dialog('destroy').remove();
		            }catch(e){}
	            }
            });
	        $('#radioGPX', dlg).prop( "checked" , true);
	        //Кнопки выбора опции
            $('#radioGPX',dlg).click(function () {
	            dlg.dialog('option', 'title',gis_exportgpxkmlform_2);
            });
	        $('#radioKML',dlg).click(function () {
		        dlg.dialog('option', 'title',gis_exportgpxkmlform_3);
            });

	        //Кнопки Ок и отмены
	        $("input[name='export']", dlg).click(function () {
		        that.exportGpxKml();
	        });
	        $("input[name='cancel']", dlg).click(function () {
		        App.destroyDialog(that.elementId);
	        });
        }
	    this.elementId = 'exportGPXKmlDialog_'+parseInt(Math.random()*1000000);
		try{
			$('#'+this.elementId).dialog('destroy').remove();
		}
		catch(e){
		}
	    $('#'+this.elementId).remove();
        //Создаем форму экспорта в GPX или KML
        $('body').append('<div id="'+this.elementId+'"></div>');
        var dlg = $('#'+this.elementId);

        dlg.load(this.htmlUrl, build);

    } catch (e) {
        App.errorReport(gis_exportgpxkmlform_4, e.message, undefined, {filename:gis_filename_310, functionname:'gis_filename_310_1'});
        //Закрываем форму
	    App.destroyDialog(that.elementId);
    }
};

ExportGpxKmlForm.prototype.exportGpxKml = function() {
	var that = this;
	try {
		//условие для обработки замечания "Если объекты не выбраны в гриде, то при нажатии групповой кнопки и затем выборе экспорта выдается ошибка при создании файла при экспорте в GPX."
		if (this.requestParams === ''){
			App.confirmDialog(gis_exportgpxkmlform_9);
			return;
		}
		var dlg = $('#'+that.elementId);
		var dataArr = that.exportArray;
		var fileName, exportTo, encoding;
		//если стоит чекбокс GPX
		if($('input[id="radioGPX"]', dlg).is(':checked')) {
			exportTo = ExportUtil.GPX;
			//Имя файла gpx всегда одно и то же в рамках одной сессии
			fileName =  App.generateUUID() + ".gpx";
		}
		else {
			exportTo = ExportUtil.KML;
			//Имя файла kml всегда одно и то же в рамках одной сессии
			fileName =  App.generateUUID() + ".kml";
		}
		if($('input[id="encodingANSI"]', dlg).is(':checked'))
			encoding = 'cp1251';
		else
			encoding = 'utf8';
			
		BlockingUtil.wait();
		App.getJsonNode(Services.exportGdalNode, {
			descrId : this.dataRequest,
			descrType  : 'select',
			data  : this.requestParams,
			path   : fileName,
			driver: exportTo,
			encoding: encoding,
			projection: this.projection,
			spatial: this.dataProvider.spatial,
			semantic: this.dataProvider.semantic
		},
			function result(res) {
				BlockingUtil.ready();
				var uploadPath = App.config["UPLOAD_PATH"];
				var fileUrl = uploadPath + fileName;
				var exportForm = new ExportForm();
				exportForm.link = fileUrl;
				exportForm.build();
				App.destroyDialog(that.elementId);
		},
			function fault(res) {
				BlockingUtil.ready();
				var errorText = exportTo === ExportUtil.GPX ? gis_exportgpxkmlform_5 : gis_exportgpxkmlform_7;
				App.errorReport(errorText, res.message, undefined, {filename:gis_filename_615, functionname:'gis_filename_615_5'});
				App.destroyDialog(that.elementId);
			});
	} catch (e) {
		//Устанавливаем обычный курсор
		App.errorReport(gis_exportgpxkmlform_4, e, undefined, {filename:gis_filename_310, functionname:'gis_filename_310_6'});
		//Закрываем форму
		App.destroyDialog(that.elementId);
	}
};



// Запрос создания на сервере файла GPX в указанной директории (экспорт из грида)
ExportGpxKmlForm.prototype.makeCreateGPXReqParams = function makeLoadDataCountReqParams(fileName, content) {
    return {
        path: fileName,
        data: content
    };
};
/**
 * Класс всплывающей формы с экспортом/импортом GPX или KML
 */
function ImportExportGpxKmlForm() {
	this.semanticAttrs = [];// массив переменных из команды insert
	this.fileAttrs = [];// массив паарметров из файла gpx,kml
	this.processStatusForm = null;
	//массив объектов для вставки данных после парсинга gpx/kml
	this.features = [];
	this.importedIds = [];
	//массив геометрий
	this.wkts = [];
	//массив параметров, которые исключаются из формы сопоставления атрибутов
	this.excludeVars = {
		fromPpanel: ['ID', 'POLICY', 'USER_ID', 'PODS_USER'],
		fromKml: ['styleUrl', 'timespan', 'styleHash', 'stroke', 'stroke-opacity',
			'stroke-width', 'fill', 'fill-opacity', 'visibility', 'coordTimes', 'styleMapHash']
	};
	goog.base(this);
}
goog.inherits(ImportExportGpxKmlForm, ExportGpxKmlForm);

ImportExportGpxKmlForm.prototype.build = function () {
	var that = this;
	try {
		function build() {
			dlg.dialog({//диалоговая форма для выбора экспорт/импорт
				modal: true,
				title: gis_importexportgpxkmlform_1,
				dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
				closeOnEscape: that.closable,
				resizable: false,
				width: 320,
				height: 244,
				close: function () {
					try {
						$(this).dialog('destroy').remove();
					} catch (e) { }
				}
			});
			$('#radioExport', dlg).click(function () {
				$("input[name='export']", dlg).prop('defaultValue', gis_importexportgpxkmlform_4);
			});
			$('#radioImport', dlg).click(function () {
				$("input[name='export']", dlg).prop('defaultValue', gis_importexportgpxkmlform_3);
			});
			//Кнопки Ок и отмены
			$("input[name='export']", dlg).click(function () {
				if ($("input[name='export']", dlg).prop('defaultValue') === gis_importexportgpxkmlform_4)
					that.exportGpxKml();
				else
					that.importGpxKml();
				App.destroyDialog(that.elementId);
			});
			$("input[name='cancel']", dlg).click(function () {
				App.destroyDialog(that.elementId);
			});

		}
		this.elementId = 'importExportGPXKmlDialog_' + parseInt(Math.random() * 1000000);
		try {
			$('#' + this.elementId).dialog('destroy').remove();
		}
		catch (e) {
		}
		$('#' + this.elementId).remove();
		//Создаем форму экспорта/импорта в GPX или KML
		$('body').append('<div id="' + this.elementId + '"></div>');
		var dlg = $('#' + this.elementId);

		dlg.load(this.htmlUrl+'?'+Math.round(), build);

	} catch (e) {
		App.errorReport(gis_exportgpxkmlform_4, e.message, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_1' });
		App.destroyDialog(that.elementId);
	}
};

/**
 * Функция создания формы для выбора файла и загрузки на сервер
 */
ImportExportGpxKmlForm.prototype.importGpxKml = function () {
	var that = this;
	var fileFormat = $('input[id="radioGPX"]', dlg).is(':checked') ? 'GPX' : 'KML';
	var uploadPath = Auth.getUid();
	function importFile() {
		//Проверяем, что поле выбранного файла не пустое
		if ($("#myElement").val() == '')
			return;
		var form = $('#fr_myElement');
		form.attr('action', form.data('action'));//.submit();
		form.submit();
	}

	function cancel() {
		dlg.dialog('destroy').remove();
	}
	var element = $('<div id="baseFileDivTrack" style="display: block;height: 46px !important;">\
                        <div class="importExportLabel">Нажмите кнопку (...) для выбора файла</div>\
                        <div id="divFI_myElement" class="divFileInput importExportFileInput">\
                        <div class="divFileInputNameTree"><input id="myElement" type="text" disabled value="" data-typecontrol="inputfile" class="formControl importExportFileInputName" data-loadvalue=true /></div>\
                        <form method="POST" id="fr_myElement" action="" data-action="./api/files/upload?path=UploadedFiles/'+
						uploadPath + '" enctype="multipart/form-data" class="frmInputFile" target="ifr_myElement">\
                        <input id="iFI_myElement" type="file" class="iFileInput" style="width:20px" data-typecontrol="file" data-filename="" class="iFileInput" accept=".'+ fileFormat.toLowerCase() +'" name="fileinput" />\
                        </form>\
                        <iframe id="ifr_myElement" name="ifr_myElement" class="noVisible" data-checkload=false></iframe>\
                       </div>\
                        </div>');
	$('body').append(element);

	var buttons = [];
	buttons.push({ text: gis_importutil_8, click: importFile, id: 'iFI_import' });
	buttons.push({ text: gis_core_6, click: cancel });
	var dlg = $(element).dialog({
		title: gis_importutil_9,
		width: 340,
		height: 120,
		resizable: false,
		modal: true,
		buttons: buttons
	});
	$('#ifr_myElement').load(function () {
		if ($("#myElement").val() == '') {
			return;
		}
		$("#myElement").val('');
		that.processImport(fileFormat);
		dlg.dialog('destroy').remove();
	});
	$('#iFI_myElement').change(function () {
		var fileName = $("#iFI_myElement").val().split('\\');
		if (fileName.length != 1) fileName = fileName[fileName.length - 1].split('.');
		else fileName = fileName[0].split('.');
		fileName = fileName.join('.');
		$("#myElement").val(fileName);
		$("#iFI_import").prop('disabled', false);
	});
	$("#iFI_import").prop('disabled', true);
}
/**
 * Функция импорта 
 */
ImportExportGpxKmlForm.prototype.processImport = function (driver) {
	var that = this;
	var guid = GridAdmInternal.generateProcessGUID();
	var processGuid = guid;//'78e29bcf';
	var requestOptions = {
		'method': 'GET',
		'dataType': 'text'
	};
	BlockingUtil.wait();
	App.getJsonTextNode(Services.parseGdalNode, {//Отправляем файл на back-end для парсинга
		process_id: processGuid,
		data: {
			USER_ID: Auth.getUserId(),
			STATUS_ID: 1,
		},
		path: Auth.getUid(),
		driver: driver
	}, function onResult(resultJson) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultJson);
		if (er !== "") {
			App.errorReport(gis_importexportgpxkmlform_6, er, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_3' });
			return;
		}
		try {
			var json = JSON.parse(resultJson);
			that.wkts = json.wktGeo || [];
			that.features = json.features || [];
			if (that.wkts.length > 0 && that.features.length > 0 && that.wkts.length === that.features.length) {
				//показываем форму соотнесения параметров
				that.openMergeForm(that.features);
			} else {
				App.errorReport(gis_importexportgpxkmlform_6, gis_importexportgpxkmlform_10, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_7' });
			}
		} catch (ex) {
			App.errorReport(gis_importexportgpxkmlform_6, ex.message, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_10' });
		}
	}, function onFault(resultJson) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultJson);
		if (er !== "") {
			App.errorReport(gis_importexportgpxkmlform_6, er, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_5' });
		}
	}, undefined, requestOptions);
};

/**
 * Открытие формы сопоставления параметров
 */
ImportExportGpxKmlForm.prototype.openMergeForm = function (features){
	var that  = this;
	if(!this.dataProvider && !this.dataProvider.semantic){
		that.openPropertyPanelForm();
	}
	//this.semanticAttrs = ['NAME', 'DESCR', 'TIME_STAMP', 'COMMENTS', 'SYMBOL', 'STATUS_ID'];
	this.fileAttrs = [];
	if(features && features.length > 0){
		features.forEach(function(feature){
			if(feature.properties){
				for(var p in feature.properties){
					if (that.excludeVars.fromKml.indexOf(p) === -1 && that.fileAttrs.indexOf(p) === -1)
						that.fileAttrs.push(p);
				}
			}
		});
	}
	function getParams() {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var request = that.dataProvider.semantic;
		return {
			descrId: 'SYS_SEM.xml#GET_DATA_XML', descrType: 'select',
			data:  '<root USER_ID="'+userId.xmlEscape() + '" USER_LOGIN="'+userLogin.xmlEscape()+ '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
					'<data file="'+request.split("#")[0]+'" dataId="'+request.split("#")[1]+'" />'+
				   '</root>'
		};
	}
	function result(resultXml) {
		try {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') {
				App.errorReport(gis_importexportgpxkmlform_16, er, undefined, {filename:gis_filename_311, functionname:'gis_filename_311_4'});
			}
			else{
				var insert = resultXml.find("insert");
				if (insert.length > 0 && insert[0].getElementsByTagName("dbCommand").length > 0) {
					var vars = insert[0].getElementsByTagName("dbCommand")[0].getElementsByTagName("var");
					var params = insert[0].getElementsByTagName("dbCommand")[0].getElementsByTagName("param");
					var i=0;
					for(; i < vars.length;i++){
						//Получаем переменные команды insert
						var attrName = vars[i].getAttribute('name');
						if(that.excludeVars.fromPpanel.indexOf(attrName) === -1)
							that.semanticAttrs.push(attrName);
					}
					for(i=0; i < params.length;i++){
						//Получаем переменные команды insert
						var attrName = params[i].getAttribute('name');
						if(that.excludeVars.fromPpanel.indexOf(attrName) === -1)
							that.semanticAttrs.push(attrName);
					}
				}
			}
		}
		catch(ex){ }
		var mergeAttributesForm = new MergeAttributesForm({
			features: features,
			fileAttrs: that.fileAttrs,
			semanticAttrs: that.semanticAttrs,
			applyCallback:function(attrs){
				that.openPropertyPanelForm(attrs);
			}});
		mergeAttributesForm.build();
	}
	function fault(resultXml) {
		App.errorReport(gis_importexportgpxkmlform_16, resultXml, undefined, {filename:gis_filename_311, functionname:'gis_filename_311_4'});
		that.openPropertyPanelForm([]);
	}
	App.serverQueryNodeWithTries(Services.processQueryNodeXml, getParams(), result, fault);
}

/**
 * Соотнесенные атрибуты
 * @param attrs
 */
ImportExportGpxKmlForm.prototype.openPropertyPanelForm = function(attrs){
	var that = this;
	var mapPropPanelId = 'mapPPanel';
	$('#' + mapPropPanelId).remove();
	var mapPropPanelDiv = '<div id="' + mapPropPanelId + '"></div>';
	$('body').append(mapPropPanelDiv);
	//Создаем панель свойств по согласованию Бочкова, чтобы пользователь заполнил нужные ему поля для вставки семантики
	$('#' + mapPropPanelId).myPropertiesPanel({
		objects: [{ id: that.layerName, label: '', flag: 'import' }],
		opener: 'body',
		skipValidation: true,
		handlers: {
			applyCallback: function (serializedData) {
				that.features.forEach(function(feature, i){
					feature.serializedData = serializedData;
					feature.mergedData = attrs;
					feature.wkt = that.wkts[i];
				})
				that.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_importexportgpxkmlform_14, that.features, that, that.insertObject, that.endProcess);
			}
		}
	});
}

ImportExportGpxKmlForm.prototype.convertSimpleObjectToXml_ = function (simpleObj) {
	var resXml = '<data ';
	for (var attrName in simpleObj) {
		var attrValue = simpleObj[attrName];
		if(attrValue){
			try{
				attrValue = attrValue.xmlEscape();
			}
			catch (ex){}
			resXml += attrName + '="' + attrValue  + '" ';
		}
	}
	resXml += ' />';
	return resXml;
};

ImportExportGpxKmlForm.prototype.endProcess = function(errorsCount, processedCount){
	//Очищаем форму статуса процесса
	this.processStatusForm = null;
	if (processedCount){
		//обновляем грид
		if(WidgetMap.layerManager){
			var layer = WidgetMap.layerManager.getLayerByName(this.layerName);
			if(layer && layer.layer){
				if(layer.layer.useServerCache){
					App.confirmDialog(gis_importexportgpxkmlform_11.replace('{ROWS_COUNT}', processedCount), null, {title:gis_core_1, html:true});
				}
				else{
					App.confirmDialog(gis_importexportgpxkmlform_11_1.replace('{ROWS_COUNT}', processedCount), null, {title:gis_core_1, html:true});
					layer.layer.loadDataByIds(this.importedIds);
					/*//чистим слой
					layer.layer.clear();
					layer.layer.dataReady_ = false;
					//перезапрашиваем данные для слоя
					layer.layer.canLoadData = true;
					layer.layer.canFirstTimeCentering = false;
					layer.layer.loadData();*/
				}
			}
		}
		if(GridWidget)
			GridWidget.refreshGrid(this.currentGridId);
	}
};


ImportExportGpxKmlForm.prototype.insertObject = function(data){
	this.insertSemanticObject_(data)
};

ImportExportGpxKmlForm.prototype.insertSemanticObject_ = function(data){
	var that = this;
	var wkt = data.wkt;
	var props = data.properties;
	var serializedData = data.serializedData;
	var mergesData = data.mergedData;
	if(mergesData){
		for(var key in mergesData){
			var propsData = props[mergesData[key]];
			if(propsData !== undefined)
				serializedData[key] = propsData;
			else{
				propsData = props[mergesData[key].toLowerCase()];
				if(propsData !== undefined)
					serializedData[key] = propsData;
			}
		}
	}
	var dataXml = this.convertSimpleObjectToXml_(serializedData);
	var requestParams = {
		descrId: that.dataProvider.semantic,
		descrType: 'insert',
		data:'<root USER_ID="' + Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">' +
			dataXml +'</root>'
	};
	App.serverQueryNodeWithTries2(Services.processQueryNode, requestParams,
		function (data) {
			if (data) {
				var er = HTTPServiceUtil.getError(data);
				if (er !== '') {
					if (that.processStatusForm)
						that.processStatusForm.processResultString(er);
					return;
				}
				try {
					var semId = $($.parseXML(data)).find('data').attr('ID');
					if (semId)
						that.insertSpatialObject_(semId, wkt);
				} catch (ex) {
					if (that.processStatusForm)
						that.processStatusForm.processResultString(ex.message);
				}
			}
		},
		function (data) {
			var er = HTTPServiceUtil.getError(data);
			if (that.processStatusForm)
				that.processStatusForm.processResultString(er);
		}
	);
}

ImportExportGpxKmlForm.prototype.insertSpatialObject_ = function(semId, wktGeo){
	var that = this;
	var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
	var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
	var requestParams = {
		descrId: this.dataProvider.spatial,
		descrType: 'insert',
		data: '<root USER_ID="' + userId.xmlEscape() +
			'" USER_LOGIN="' + userLogin.xmlEscape() +
			'" PODS_USER="' + userLogin.xmlEscape() +
			'">' +
			'<data ID="' + semId + '" WKT="' + wktGeo + '" />' +
			'</root>'
	};
	BlockingUtil.wait();
	App.serverQueryXMLNodeWithTries(Services.processQueryNodeGeo, requestParams,
		function insertGeoResult(resultXml) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXml);
			if(er === '')
				that.importedIds.push(semId);
			if (that.processStatusForm)
				that.processStatusForm.processResultString(er);
		}, function insertGeoFault(resultXml) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXml);
			if (that.processStatusForm){
				that.processStatusForm.processResultString(er);
			}
		});
}
/**
 * Класс всплывающей формы с экспортом/импортом GPX или KML
 */
function MergeAttributesForm(opt_options) {
	var options = opt_options ? opt_options : {};
	this.fileAttrs = (options.fileAttrs) ? options.fileAttrs : [];
	this.features = (options.features)? options.features: [];
	this.semanticAttrs = (options.semanticAttrs) ? options.semanticAttrs : [];
	this.applyCallback = options.applyCallback;
	this.htmlUrl = 'ui/html/MergeAttributesForm.html';
	this.elementId = 'mergeAttributesDialog';
}

MergeAttributesForm.prototype.build = function () {
	var that = this;
	try {
		function build() {
			var visibleRowsHeight = 210;//that.semanticAttrs.length <= 10 ? that.semanticAttrs.length * 25: 10 * 25 ;
			dlg.dialog({
				modal: true,
				resizable: true,
				title: gis_mergeattributesform_1,
				dialogClass: 'noCloseButton gsi-zindex__merge-form',
				closeOnEscape: false,
				width: 580,
				height: (150/*базовая высота*/ + visibleRowsHeight),
			});
			//Кнопки Ок и отмены
			$("input[name='apply']", dlg).click(function () {
				var attrs = [];
				attrs = that.formatAttributes();
				if(that.applyCallback)
					that.applyCallback(attrs);
				App.destroyDialog(that.elementId);
			});
			$("input[name='cancel']", dlg).click(function () {
				App.destroyDialog(that.elementId);
			});
			$('#mergeAttributesInfo').text(gis_mergeattributesform_3 + that.features.length);
			that.fillData_();
		}
		App.destroyDialog(that.elementId);
		$('body').append('<div id="' + this.elementId + '"></div>');
		var dlg = $('#' + this.elementId);
		dlg.load(this.htmlUrl+'?'+Math.round(), build);

	} catch (e) {
		App.errorReport(gis_exportgpxkmlform_4, e.message, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_1' });
		App.destroyDialog(that.elementId);
	}
};

MergeAttributesForm.prototype.fillData_ = function() {
	var that = this;
	var mergeTable = $('#mergeAttributesTable');
	this.fileAttrs.unshift(gis_mergeattributesform_2);
	var upperFileAttrs = [];
	this.fileAttrs.forEach(function(fileAttr){
		upperFileAttrs.push(fileAttr.toUpperCase());
	});
	this.semanticAttrs.forEach(function(semanticAttr, i){
		var options = '';
		that.fileAttrs.forEach(function(fileAttr){
			options += '<option value="'+fileAttr.toUpperCase()+'">'+fileAttr.toUpperCase()+'</option>';
		})

		var row = $('<div id="mergeAttributesDiv_' + i + '" class="merge-attributes-div">' +
				'   <div id="mergeAttributesFromSemantic_' + i + '" class="merge-attributes-from-semantic">' + semanticAttr + '</div>' +
				'   <div style="display: inline-block"">' +
					'       <select id="mergeAttributesFromFile_' + i + '" class="merge-attributes-from-file">'  +
							options +
					'       </select>' +
				'   </div>' +
				'</div>');
		mergeTable.append(row);
		if(upperFileAttrs.indexOf(semanticAttr) !== -1){
			$("#mergeAttributesFromFile_" + i).val(semanticAttr).change();
		}
	});

}
MergeAttributesForm.prototype.formatAttributes = function() {
	var attrs = {};
	this.semanticAttrs.forEach(function(semanticAttr, i){
		var selected = $('#mergeAttributesFromFile_' + i).val();
		if(selected !== gis_mergeattributesform_2){
			attrs[semanticAttr] = selected;
		}
	});
	return attrs;
}
var CAROUSEL_DATA_REQUEST = 'SYS_SEM.xml#LIB_DOC_COMMENTS_LIST';
//максимальное количество запрашиваемых данных. upd. 22.03.22 добавили лимит 500, т.к. в казани не хватало 50
var CAROUSEL_DATA_COUNT_LIMIT = 500;

var CAROUSEL_AVAILABLE_IMAGES = ['png', 'jpg', 'gif', 'jpeg'];

/**
 * Класс формы отображения галереии в виде карусели библиотекой flickity
 * @see https://flickity.metafizzy.co/
 */
function CarouselForm(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	// объект с данными(строка грида) из которого забирать параметры для формирования запроса на получения списка картинок
	this.layerName = options.layerName;
	this.data = options.data;
}

CarouselForm.prototype.build = function() {
	this.loadData_();
}

/**
 * Загружаем данные для заполнения
 * @private
 */
CarouselForm.prototype.loadData_ = function () {
	var that = this;
	if(!this.data)
		App.errorReport(gis_carouselform_1, gis_carouselform_2, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_1'})
	else{
		var sysFullId = (this.data.LG_ATTACH) ? this.data.LG_ATTACH : this.layerName + '/' + this.data.ID;
		sysFullId = sysFullId.replace(new RegExp('"','g'),'&quot;')
		var requestData = '<root><data  SYS_FULL_ID="' + sysFullId + '" ' +
						'LOW_LIMIT="0" HIGH_LIMIT="' + CAROUSEL_DATA_COUNT_LIMIT + '"/></root>';
		var requestParams = {
			descrType: 'select', descrId: CAROUSEL_DATA_REQUEST,
			data: requestData
		};
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, requestParams, function (resultXML){
			BlockingUtil.ready();
			if (!resultXML)
				App.errorReport(gis_carouselform_1, gis_carouselform_2, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_2'})
			else {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== '') {
					App.errorReport(gis_carouselform_1, er, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_3'})
				} else {
					that.makeData_(resultXML);
				}
			}
		}, function (resultXML){
			BlockingUtil.ready();
			App.errorReport(gis_carouselform_1, resultXML, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_4'})
		});
	}
}

/**
 * Подготавливаем данные для заполенение карусели
 * @param resultXML результат, полученный из БД, содержащий перечень документов
 * @private
 */
CarouselForm.prototype.makeData_ = function (resultXML) {
	var datas = [];
	try{
		var result = $($.parseXML(resultXML));
		result.find('data').each(function (){
			var curdData = $(this);
			var data = {
				FILE_NAME: curdData.attr('FILE_NAME') || '',
				CTIME: curdData.attr('CTIME') || '',
			};
			if(data.FILE_NAME)
				datas.push(data);
		});
		this.buildCarousel_(datas);
	}
	catch(ex){
		App.errorReport(gis_carouselform_1, ex.message, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_5'})
	}
}

/**
 * Заполнение карусели
 * @param {Object} datas
 * @private
 */
CarouselForm.prototype.buildCarousel_ = function (datas) {
	var that = this;
	if(!datas || datas.length === 0)
		App.confirmDialog(gis_carouselform_3,null,{title:''});
		//App.errorReport(gis_carouselform_1, gis_carouselform_3, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_6'})
	else{
		// main div
		var carouselDiv = '<div class="carousel carousel-docs" data-flickity>';
		//preview div
		var carouselNavDiv = '<div class="carousel carousel-nav-docs" data-flickity>';
		//нужен ли блок навигации
		var needNav = datas.length > 1;
		datas.forEach(function(data, i){
			carouselDiv += that.buildCarouselCell_(data, i, datas.length);
			if(needNav)
				carouselNavDiv += that.buildCarouselNavCell_(data);
		});
		carouselDiv +=   '</div>';
		$('#carouselDocs').remove();
		var divv = '<div id="carouselDocs" class="carousel-dialog">' + carouselDiv + carouselNavDiv +'</div>';
		$('body').append(divv);
		var dlg = $('#carouselDocs');
		dlg.dialog({ title: '', modal: false,
			dialogClass: 'ui-dialog-confirm', closeOnEscape: true,
			width: 618, height: (needNav) ? 543 : 445,
			resizable: true, buttons : []
		});
		$('.carousel-docs').flickity({
			prevNextButtons: true,
			wrapAround: true,
			pageDots: false,
			fullscreen: true
		});

		$('.carousel-nav-docs').flickity({
			asNavFor: '.carousel-docs',
			prevNextButtons: false,
			pageDots: false,
			contain: true,
			fullscreen: false,
			lazyload: 5
		});
	}
}

/**
 * Формирование ячейки для галереи
 * @param data
 * @private
 */
CarouselForm.prototype.buildCarouselCell_ = function (data, index, length) {
	var fileName = data.FILE_NAME;
	var libPath = (App.config !== null && App.config.LIB_PATH) ? App.config.LIB_PATH : '';
	var src = libPath + encodeURI(fileName);
	if (data.FILE_NAME.indexOf('pdf#') !== -1){
		fileName = data.FILE_NAME;
		src = Services.pdfPreview + '?maxWidth=290&maxHeight=412&sourceUrl=' + encodeURI(fileName);
	}else{
		fileName = libPath + encodeURI(data.FILE_NAME);
		src = Services.docPreview + '?maxWidth=290&maxHeight=412&sourceUrl=' + fileName + '&rand=' + Math.random();
	}

	//формирование блока с описанием документа
	var smallFileName =  data.FILE_NAME.replace(/^.*[\\\/]/, '');
	var carouselDescriptionDiv = '<div class="carousel-cell-descr" >' +
		'<label class="carousel-cell-descr__page">' + (index + 1) + gis_carouselform_5 + length + '</label>'+
		'<label class="carousel-cell-descr__time">'+gis_carouselform_4 + data.CTIME + '</label>'+
		'<label class="carousel-cell-descr__filename">'+smallFileName + '</label>'+
		/*'<span class="carousel-cell-descr__filelink"><a href="#" onclick="CarouselForm.getFileLink(\'' + src + '\');return false;">' +
		'         <img src="/ui/images/tag.png" style="height: 16px;">Ссылка на файл' +
		'      </a> | ' +
		'</span>' +*/
		'<span class="carousel-cell-descr__openfile"><a href="#" onclick="HTTPServiceUtil.openFile(\'' + fileName + '\'); return false;">' +
				'<img src="/ui/images/save.png" style="height: 16px;">Скачать файл' +
		'      </a>' +
		'</span>' +
		'<span class="carousel-cell-descr__rotateImg"><a href="#" onclick="CarouselForm.rotateImg(); return false;">' +
		'<img src="/ui/images/rotate_right.png" style="height: 16px;" title="'+ gis_carouselform_6 +'">' +
		'      </a>' +
		'</span>' +
		'</div>';
	var fileExtension = fileName.split('.').pop();
	if (fileExtension.indexOf('#') !== -1) fileExtension = fileExtension.split('#').shift();
	var imgSrc = CAROUSEL_AVAILABLE_IMAGES.indexOf(fileExtension.toLowerCase()) !== -1 ? fileName : '';
	var cellHtml = '<div class="carousel-cell" >' +
		'<img class="carousel-cell-image" src="' + fileName + '" data-rotate="0" />' +
		carouselDescriptionDiv +
		'</div>';
	//если картинка и её нет на сервере, запрашиваем ошибочную картинку от сервиса превьюшек
	if(imgSrc && !HTTPServiceUtil.isUrlExists(imgSrc))
		imgSrc = '';
	if(!imgSrc){// случай документов, pdf, страниц pdf
		cellHtml = '<div class="carousel-cell" >' +
			//'<img class="carousel-cell-image__doc" src="' + src.replace('#','$') + '" data-rotate="0" />' +
			'<div class="carousel-cell-image__doc" style="background: url(' + src.replace('#','$') + ') no-repeat center; " ></div>' +
			carouselDescriptionDiv +
			'</div>';
	}
	//var cellHtml = '<div class="carousel-cell" style="background: url(' + src + ') no-repeat center;" ></div>';
	return cellHtml;
}

/**
 * Формирование ячейки для превью
 * @param data
 * @private
 */
CarouselForm.prototype.buildCarouselNavCell_  = function (data) {
	var libPath = (App.config !== null && App.config.LIB_PATH) ? App.config.LIB_PATH : '';
	var src = '';
	if (data.FILE_NAME.indexOf('pdf#') !== -1){
		src = Services.pdfPreview + '?maxWidth=168&maxHeight=88&sourceUrl=' + encodeURI(data.FILE_NAME.replace('pdf#','pdf$'));
	}else {
		src = Services.docPreview + '?maxWidth=168&maxHeight=88&sourceUrl=' + libPath + encodeURI(data.FILE_NAME) + '&rand=' + Math.random();
	}
	var cellHtml = '<div class="carousel-nav-cell" style="background: url(' + src + ') no-repeat center; " ></div>';
	return cellHtml;
};

CarouselForm.rotateImg = function(){
	var carouselSelectedItem =  $('.carousel-cell-image','.carousel-cell.is-selected');
	var deg = carouselSelectedItem.data('rotate') || 0;
	var newDeg = deg === 360 ? 90 :deg + 90;
	var rotate = 'rotate(' + newDeg  + 'deg)';
	var width = carouselSelectedItem.width();
	var height = carouselSelectedItem.height();
	var coef = height / width;
	var scale = (newDeg === 90 || newDeg === 270) ? ' scale(' + coef.toFixed(2) + ') ' : ' scale(1) ';
	carouselSelectedItem.css({
		'-webkit-transform': rotate + scale,
		'-moz-transform': rotate + scale,
		'-o-transform': rotate + scale,
		'-ms-transform': rotate + scale,
		'transform': rotate + scale,
	});
	carouselSelectedItem.data('rotate', newDeg);
};

CarouselForm.getFileLink = function(fileName){
	var link = window.location.protocol+'//'+window.location.host+'/'+fileName;
	$('#getCurPostDocLinkDialog').remove();
	var divv = '<div id="getCurPostDocLinkDialog">' +
		'<textarea id="getCarouselFileLinkText" style="width:265px;margin: 1px;color: #005d98;height: 55px;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text">' + fileName + '</textarea></div>';
	$('body').append(divv);
	var dlg = $('#getCurPostDocLinkDialog');
	var buttons = [];
	buttons.push({
		text: gis_postsloader_4,
		click: function(){
			$('#getCurPostDocLinkDialog').remove();
		}
	});
	dlg.dialog({
		modal: true,
		title: gis_postsloader_1,
		dialogClass: 'gsi-zindex__dialog',
		closeOnEscape: true,
		width: 274,
		height: 140,
		resizable: false,
		//position: {my: "right bottom", at: "right bottom", of: '#postId_'+curPostId},
		buttons : buttons,
		create: function() {
			$(this).closest('div.ui-dialog')
				.find('.ui-dialog-titlebar-close')
				.click(function(e) {
					$('#getCurPostDocLinkDialog').remove();
					e.preventDefault();
				});
		}
	});
	$('#getCarouselFileLinkText').select();
}


/**
 * Класс всплывающей формы отображения статуса процесса выполнения (груповая обработка)
 */
/* TEXT CONSTANTS */
/**/
var PROCESS_STATUS_FORM_TOTAL_COUNT_TEXT = gis_processstatusform_1;
var PROCESS_STATUS_FORM_PROCESSED_COUNT_TEXT = gis_processstatusform_2;
var PROCESS_STATUS_FORM_ERRORS_COUNT_TEXT = gis_processstatusform_3;

function ProcessStatusForm() {
    this.title = gis_processstatusform_4;
    this.closable = false;
    this.htmlUrl = 'ui/html/ProcessStatusForm.html';

    this.totalCount = 0;
    this.processedCount = 0;
    this.errorsCount = 0;
    this.proceedIds = [];
    this.proceedLayerName = '';

    this.cancelBtnPressed = false;
    //Обрабатываемый массив
    this.objectsArray = [];
    //Объект, от которого выполняются функции (модуль или форма, от которой запустили эту форму)
    this.thisObject;
    //Функция обработки текущего элемента массива и ее аргументы
    this.processFunction = null;
    //Функция, выполняемая при завершении обработки и ее аргументы
    this.endFunction = null;
    //Функция, выполняемая при отмене обработки - обычно в ней будет отменяться текущий выполняемый вызов
    this.cancelFunction = null;

    //Форма выбора действия при возникновении ошибки в операции
    this.actionOnErrorForm;
    //Запомнить ли выбор в форме выбора действия
    this.continueToAll = false;
};

ProcessStatusForm.prototype.build = function(elementId) {
    var that = this;
    //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
    function build() {
        //Функция обновления значения в форме
        that.changeFormValues = function changeFormValues() {
            //Устанавливаем всем элементам формы нужный текст
            $("div[name='totalCountText']").text(PROCESS_STATUS_FORM_TOTAL_COUNT_TEXT + that.totalCount);
            $("div[name='processedCountText']").text(PROCESS_STATUS_FORM_PROCESSED_COUNT_TEXT + that.processedCount);
            $("div[name='errorsCountText']").text(PROCESS_STATUS_FORM_ERRORS_COUNT_TEXT + that.errorsCount);
        };
        //Обновляем значения в полях формы
        that.changeFormValues();
        //Создаем диалоговую форму
        dlg.dialog({
            modal: true,
            title: that.title,
            dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
            closeOnEscape: that.closable,
            width: 410,
            height: 120,
            open: function( event, ui ) {
                that.processArray();
            }
        });

        //Кнопка отмены
        $("input[name='cancel']", dlg).click(function () {
            //that.cancel();
            that.onCancelClick();
        });
    }

    that.elementId = elementId;

    $('#'+elementId).remove();
    //Создаем форму экспорта в GPX или KML
    $('body').append('<div id="'+elementId+'"></div>');
    var dlg = $('#'+elementId);

    dlg.load(this.htmlUrl, build);
};

ProcessStatusForm.prototype.cancel = function() {
    $('#'+this.elementId).remove();
};

ProcessStatusForm.prototype.processArray = function processArray() {
    var that = this;
    //Если в форме статуса нажали кнопку отмены - завершаем операции
    if (that.cancelBtnPressed==true) {
        if (that.endFunction!=null && that.endFunction!=undefined) {
            that.endFunction.apply(that.thisObject,[that.errorsCount,that.processedCount, false, that.proceedLayerName, that.proceedIds]);
            that.endFunction = null; //Результат все равно вернется в callback и сделает processArray(), поэтому убираем функцию чтобы не вызывать дважды
        }
        that.endProcess();
        return;
    }
    if (that.objectsArray && that.objectsArray.length>0) {
        var curObj = that.objectsArray.pop();
        if(curObj){
            that.proceedLayerName = curObj.classId;
            that.proceedIds.push(curObj.objectId);
        }
        if (that.processFunction!=null)
            that.processFunction.apply(that.thisObject,[curObj]);
    } else {
        if (that.endFunction!=null && that.endFunction!=undefined)
            that.endFunction.apply(that.thisObject,[that.errorsCount,that.processedCount, false, that.proceedLayerName, that.proceedIds]);
        that.endProcess();
    }
};
//слушатель результата
ProcessStatusForm.prototype.processResultString = function processResultString(error/*String*/) {
    var that = this;
    if (error != "") {
        that.errorsCount++;
        //Обновляем значения в полях формы
        that.changeFormValues();
        //Если не было формы, реагирующей на ошибку, создаем ее
        if (!that.continueToAll && that.cancelBtnPressed==false) {
            that.actionOnErrorForm = new ActionOnErrorForm();
            that.actionOnErrorForm.parentProcessStatusForm = that;
            that.actionOnErrorForm.fullMessage = error;
            //Создаем форму
            that.actionOnErrorForm.build("actionOnErrorForm");//Форма выбора действия тоже всегда одна!
            //Добавляем слушатель (с дополнительным агрументом, чтобы по завершении иметь возможность вызова функций ProcessStatusForm)
            $("body").on(CloseEvent.CLOSE, that.onActionOnErrorFormClose);
        } else {
            that.processArray();
        }
    } else {
        that.processedCount++;
        //Обновляем значения в полях формы
        that.changeFormValues();
        that.processArray();
    }
};
//Слушатель события закрытия формы - нужно дальше обрабатывать, если detail==1 (продолжили)
ProcessStatusForm.prototype.onActionOnErrorFormClose = function onActionOnErrorFormClose(evt/*CloseEvent*/) {
    var that = this;
    $("body").off(CloseEvent.CLOSE);
    if (evt && evt.eventData) {
        that = evt.eventData.parent;
    }
    if (evt.eventData && evt.eventData['continue']) {
        //Сохраняем ли текущий выбор для следующих ошибок
        that.continueToAll = evt.eventData.saveChoose;
        //Если есть еще объекты для обработки - обрабатываем, иначе заканчиваем обработку
        that.processArray();
    } else {
        if (that.endFunction!=null){
            var isCancel = evt.eventData && evt.eventData['continue'] !== true;
            that.endFunction.apply(that.thisObject,[that.errorsCount,that.processedCount, isCancel, that.proceedLayerName, that.proceedIds]);
        }
        that.endProcess();
    }
};
//По завершении процесса обработки нужно закрывать созданные формы
ProcessStatusForm.prototype.endProcess = function endProcess() {
    var that = this;
    //Убираем форму выбора действия при ошибке
    that.deleteActionOnErrorForm();
    //Убираем форму статуса
    that.onCancel();
};
//Удаляем форму работы с групповыми ошибками, если она есть
ProcessStatusForm.prototype.deleteActionOnErrorForm = function deleteActionOnErrorForm() {
    var that = this;
    if (that.actionOnErrorForm) {
        that.actionOnErrorForm.cancel();
        that.actionOnErrorForm = null;
    }
};

ProcessStatusForm.prototype.onCancelClick = function onCancelClick() {
    var that = this;
    that.cancelBtnPressed = true;
    //2012_12_05 - при нажатии кнопки "Отмена" реально отменяем текущий запрос и заканчиваем работу
    if (that.cancelFunction!=null)
        that.cancelFunction.apply(that.thisObject,[]);
    //Для завершения работы нужно вызвать последнюю обработку - результата текущей операции мы уже не получим
    that.processArray();
};

ProcessStatusForm.prototype.onCancel = function onCancel() {
    var that = this;
    that.removeMe();
};

ProcessStatusForm.prototype.removeMe = function removeMe(hasChanges/*Boolean*/) {
    var that = this;
    /*that.dispatchEvent(new CloseEvent(CloseEvent.CLOSE,false,false,hasChanges ? 1 : -1));*/
    //Закрываем форму
    that.cancel();
    /*PopUpManager.removePopUp(this);*/
};
/**
 * Класс всплывающей формы для выбора действия при прерывании групповой обработки
 */
function ActionOnErrorForm() {
    this.title = gis_actiononerrorform_3;
    this.closable = false;
    this.htmlUrl = 'ui/html/ActionOnErrorForm.html';
    this.shortMessage = gis_actiononerrorform_4;
    this.fullMessage = "";
    this.onChooseFunction = null; //Функция выбора опции. В нее передается 2 аргумента: true/false (продолжать или нет) и true/false (запомнить выбор или нет)
    this.isContinue = false;
    this.parentProcessStatusForm = null;
};

ActionOnErrorForm.prototype.build = function(elementId) {
    var that = this;

    //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
    function build() {
        //Создаем диалоговую форму
        dlg.dialog({
            modal: true,
            resizable: false,
            title: that.title,
            dialogClass: that.closable ? '' : 'noCloseButton',
            closeOnEscape: that.closable,
            width: 370,
            height: 130
        });

        function onChoose() {
            try {
                var closeEvt = new CloseEvent(CloseEvent.CLOSE);
                closeEvt.eventData = {'continue': that.isContinue, saveChoose: $("input[name='inputCheck']")[0].checked, parent:that.parentProcessStatusForm};
                closeEvt.dispatch();
            } catch (e) {
                App.errorReport(gis_actiononerrorform_2, e, undefined, {filename:gis_filename_301, functionname:'gis_filename_301_1'});
            }
        }

        //Добавляем текст детальной информации
        var detailInfoTextArea = $("#actionOnErrorForm_detailInfoText");
        var formattedErrorString = App.formatErrorString(that.fullMessage);
        detailInfoTextArea.text(formattedErrorString);

        //Кнопки выбора опции
        $("input[name='inputCheck']", dlg).click(function () {
            //Ничего не делаем, понадобится при нажатии кнопки
        });
        //Кнопку "Переслать в службу поддержки" создаем через jqxButton (чтобы с картинкой была и подсказкой)
        var sendMailButton = $("#actionOnErrorForm_sendMailButton");
        sendMailButton.jqxButton({ width: '22px', height: '18px'});
        sendMailButton.on('click', function () {
            var text   = gis_actiononerrorform_1;
            var detail = detailInfoTextArea.text();

            var dialog = Object.create(SendErrorReportDialog);
            dialog.setData(
                gis_app_55_10+
                text+"\n\n"+
                gis_app_55_11+
                detail+"\n\n"+
                gis_app_55_12
            );
            dialog.build();
        });
        //sendMailButton.jqxTooltip({position: 'top', content: gis_actiononerrorform_5});
        sendMailButton.attr('title', gis_actiononerrorform_5);
        //Кнопки detailInfo, continue, cancel
        $("input[name='detailInfo']", dlg).click(function () {
            var detailInfoBtnText = detailInfoTextArea.css('display') == 'none' ? gis_actiononerrorform_6 : gis_actiononerrorform_7;
            $("input[name='detailInfo']", dlg)[0].value = detailInfoBtnText;
            var displayTextArea = detailInfoTextArea.css('display') == 'none' ? 'block' : 'none';
            //Расширяем/сжимаем форму на высоту подробной информации
            var dlgHeight = dlg.dialog("option","height");
            var displayTextAreaHeight = displayTextArea == 'none' ? -detailInfoTextArea.outerHeight() : detailInfoTextArea.outerHeight();
            dlg.dialog("option","height", dlgHeight + displayTextAreaHeight);
            //Показываем текст
            detailInfoTextArea.css('display', displayTextArea);
        });
        $("input[name='continue']", dlg).click(function () {
            that.isContinue = true;
            onChoose();
            that.cancel();
        });
        $("input[name='cancel']", dlg).click(function () {
            that.isContinue = false;
            onChoose();
            that.cancel();
        });
    }

    that.elementId = elementId;
    $('#'+elementId).remove();
    //Создаем форму
    $('body').append('<div id="'+elementId+'"></div>');

    var dlg = $('#'+elementId);

    dlg.load(this.htmlUrl, build);
};

ActionOnErrorForm.prototype.cancel = function() {
    $('#'+this.elementId).remove();
};

/**
 * Класс всплывающей формы для выбора подтвердения удаления записей
 */
/* TEXT CONSTANTS */
var DELETE_CONFIRMATION_FORM_ERROR = gis_deleteconfirmationform_1;
/**/

function DeleteConfirmationForm() {
    this.title = gis_deleteconfirmationform_2;
    this.closable = false;
    this.htmlUrl = 'ui/html/DeleteConfirmationForm.html';
    this.isContinue = false;
    this.parent = null;
};

DeleteConfirmationForm.prototype.build = function(elementId, deletingObjCount) {
    var that = this;

    //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
    function build() {
        //Создаем диалоговую форму
        dlg.dialog({
            modal: true,
            title: that.title,
            dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
            closeOnEscape: that.closable,
            width: 300,
            height: 120
        });

        function onChoose(detail) {
            try {
                var closeEvt = new CloseEvent(CloseEvent.CLOSE);
                closeEvt.detail = detail;
                closeEvt.dispatch();
            } catch (e) {
                App.errorReport(DELETE_CONFIRMATION_FORM_ERROR, e, undefined, {filename:gis_filename_309, functionname:'gis_filename_309_1'});
            }
        }

        if (deletingObjCount && deletingObjCount > 0) {
            var deleteMsgDiv = $(".labelField[name='descriptionTextCount']", dlg);
            if (deleteMsgDiv.length > 0) {
                deleteMsgDiv.text( deleteMsgDiv.text().replace("0.", deletingObjCount+".\n") );
            }

        }

        $("input[name='continue']", dlg).click(function () {
            onChoose(1); //Подтверждаем
            that.cancel();
        });
        $("input[name='cancel']", dlg).click(function () {
            that.isContinue = false;
            onChoose(0); //Отменяем
            that.cancel();
        });
    }

    that.elementId = elementId;

    $('#'+elementId).remove();
    //Создаем форму
    $('body').append('<div id="'+elementId+'"></div>');
    var dlg = $('#'+elementId);

    dlg.load(this.htmlUrl, build);
};

DeleteConfirmationForm.prototype.cancel = function() {
    $('#'+this.elementId).remove();
};

/**
 * Класс всплывающей формы для выбора подтверждения
 */

AlertForm.OK = "AlertForm.OK";
AlertForm.CANCEL = "AlertForm.CANCEL";

function AlertForm(opt_options) {
    var options = opt_options || {};
    this.title = gis_alertform_1;
    //Текст внутри формы сообщения
    this.messageText = gis_alertform_2;
    this.closable = false;
    //Путь шаблона для формы (в шаблоне указывается текст сообщения)
    this.htmlUrl = 'ui/html/AlertForm.html';
    this.isContinue = false;
    this.parent = null;
    this.width = 300;
    this.height = 100;
    this.alertOkButtonText = (options.objectType !== undefined)?options.objectType:gis_core_12;
    this.alertCancelButtonText = gis_core_6;
};

AlertForm.prototype.build = function(elementId, message, title, flags) {
    var that = this;
    that.messageText = message;
    that.title = title;

    //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
    function build() {
        //Создаем диалоговую форму
        dlg.dialog({
            modal: true,
            title: that.title,
            dialogClass: that.closable ? '' : 'noCloseButton',
            closeOnEscape: that.closable,
            width: that.width,
            height: that.height,
            create: function(event, ui) {
                dlg.parent('.ui-dialog').css('z-index', 30004)
                    .nextAll('.ui-widget-overlay').css('z-index', 1003);
            }
        });
        function onChoose(detail) {
            try {
                var closeEvt = new CloseEvent(CloseEvent.CLOSE);
                closeEvt.detail = detail;
                closeEvt.parent = that;
                closeEvt.dispatch();
            } catch (e) {
                App.errorReport(e, e, undefined, {filename:gis_filename_304, functionname:'gis_filename_304_1'});
            }
        }

        //Обрабатываем флаги
        if (flags && flags!=undefined && flags!='') {
            if (flags.indexOf(AlertForm.OK)==-1) $("input[name='continue']", dlg).hide();
            if (flags.indexOf(AlertForm.CANCEL)==-1) $("input[name='cancel']", dlg).hide();
        }

        //Устанавливаем в форму текст из messageText
        $("div[name='descriptionText']", dlg)[0].innerHTML = that.messageText;

        //Корректируем высоту по контенту
        var newDlgHeight = 80 + $("div[name='descriptionText']", dlg).height();
        dlg.dialog("option", "height", newDlgHeight);
        //Устанавливаем текст кнопок
        $("input[name='continue']", dlg).attr('value',that.alertOkButtonText);
        $("input[name='cancel']", dlg).attr('value',that.alertCancelButtonText);

        $("input[name='continue']", dlg).click(function () {
            onChoose(1); //Подтверждаем
            that.cancel();
        });
        $("input[name='cancel']", dlg).click(function () {
            that.isContinue = false;
            onChoose(0); //Отменяем
            that.cancel();
        });
    }

    that.elementId = elementId;

    $('#'+elementId).remove();
    //Создаем форму
    $('body').append('<div id="'+elementId+'"></div>');
    var dlg = $('#'+elementId);

    dlg.load(this.htmlUrl, build);
};

AlertForm.prototype.cancel = function() {
    $('#'+this.elementId).remove();
};

/**
 * Класс формы редактирования справочника
 */
function DirectoryEditForm(opt_options) {
    var that = this;
    var tempSource = 'PODS_SEM_DICT.xml#PODS_DIRECTION_GCL';//'PODS_SEM_DICT.xml#PODS_SHEET_NOTE_LINK_TYPE_CL';//'PODS_SEM_DICT.xml#PODS_SOURCE_GCL';
    var tempSQL = 'PODS_DIRECTION_GCL';//'PODS_SHEET_NOTE_LINK_TYPE_CL';
    var options = opt_options !== undefined ? opt_options : {};
    this.source = (options.source !== undefined)?options.source:'PODS_SEM_DICT.xml';
    this.requestSQL = (options.requestSQL !== undefined)?options.requestSQL:tempSQL;
    this.requestSource = (options.requestSource !== undefined)?options.requestSource:tempSource;
    this.htmlUrl = 'ui/html/DirectoryEditForm.html';
    //массивы объектов, которые менялись
    this.added = {};
    this.modified = {};
    this.deleted = {};
    //Поле для исключения из списка на копирование в эксель
    this.excludeVar = 'uid';


    this.baseDataAdapter = new BaseDataAdapter({
        requestSource: this.requestSource,
        source: this.source,
        added: this.added,
        modified: this.modified,
        deleted: this.deleted,
        updateSQL: this.requestSQL,
        insertSQL: this.requestSQL,
        deleteSQL: this.requestSQL,
        updateCompleteHandler:function(updateInfo){
            //массив объектов
            that.dataUpdateComplete_(updateInfo);
            $('#directoryEditForm').remove();
        },
        resultHandler: function(attrs,datas){
            //массив объектов
            that.fillGrid(attrs,datas);
        }
    });
};

DirectoryEditForm.prototype.build = function() {
    var that = this;

    $('#directoryEditForm').remove();
    //Создаем форму
    $('body').append('<div id="directoryEditForm"></div>');
    var dlg = $('#directoryEditForm');

    function build() {
        dlg.dialog({
            modal: true,
            title: gis_directoryeditform_1,
            dialogClass: 'gsi-zindex__dialog',
            closeOnEscape: true,
            width: 800,
            height: 400,
            resizable: false,
            create: function(event, ui) {
                dlg.parent('.ui-dialog').css('zIndex', 999)
            }
        });
        that.setDefaultsControls_();
    }

    dlg.load(this.htmlUrl,build);
};

/**
 * @param
 * @private
 */
DirectoryEditForm.prototype.setDefaultsControls_ = function() {
    var that = this;

    //контролы переводим к jqx
    $('#directoryAdd').on('click',function(){
        $("#directoryGrid").jqxGrid('addrow', null, {});
    });

    //контролы переводим к jqx
    $('#directoryRemove').on('click',function(){
        var selectedRowIndex = $("#directoryGrid").jqxGrid('getselectedrowindex');
        var rowsCount = $("#directoryGrid").jqxGrid('getdatainformation').rowscount;
        if (selectedRowIndex >= 0 && selectedRowIndex < rowsCount) {
            var id = $("#directoryGrid").jqxGrid('getrowid', selectedRowIndex);
            var rowData = $('#directoryGrid').jqxGrid('getrowdata', selectedRowIndex);
            //если ранее мы не добавляли, то будет запрос на update
            that.deleted[rowData.uid] = rowData;
            //если элемент был в modified и его удалили, то он переходит в объект deleted
            if(that.modified[rowData.uid] !== undefined){
                delete that.modified[rowData.uid];
            }
            //если элемент был добавлен и потом удален, то удаляем его из added и deleted
            if(that.added[rowData.uid] !== undefined){
                delete that.added[rowData.uid];
                delete that.deleted[rowData.uid];
            }
            var commit = $("#directoryGrid").jqxGrid('deleterow', id);
        }
    });

    $('#directoryCopyToExcel').on('click',function(){
        var dataObj = $('#directoryGrid').jqxGrid('getrows');
        var resultExcel = '';
        if(dataObj && dataObj.length){
            var colNames = Object.keys(dataObj[0]);
            //добавляем колонки в шапку
            if (colNames.indexOf(that.excludeVar) !== -1){
                colNames.splice(colNames.indexOf(that.excludeVar),1);
            }
            resultExcel += colNames.join('\t') + '\n';
            dataObj.forEach(function(it){
                var resultItem = '';
                colNames.forEach(function(colName){
                    var val = it[colName];
                    if(val)
                        resultItem += val + '\t';
                    else
                        resultItem += '\t';
                });
                resultItem += '\n';
                resultExcel += resultItem;
            });
            GridUtil.copyToExcelDialog(resultExcel);
        }
    });


    $('#directorySave').on('click',function(){
        that.save_();
        $('#directoryEditForm').remove();
    });

    $('#directoryCancel').on('click',function(){
        $('#directoryEditForm').remove();
    });
    var source ={
        localdata: [],
        datatype: "array"
    };
    var dataAdapter = new $.jqx.dataAdapter(source);
    $("#directoryGrid").jqxGrid({
        width: 785,
        height: 310,
        source: dataAdapter,
        localization: getLocalization('ru'),
        editable: true,
        columnsresize: true,
        theme:'gis-blue-grid',
        selectionmode: 'singlerow'
    });
    $("#directoryGrid").on('cellvaluechanged', function (event) {
        //забираем отредактированный ряд и заносим в объект
        var args = event.args;
        var rowData = $('#directoryGrid').jqxGrid('getrowdata', args.rowindex);
        //если ранее мы не добавляли, то будет запрос на update
        if(that.added[rowData.uid] === undefined)
            that.modified[rowData.uid] = rowData;

    });

    //запрос на заполнение
    this.baseDataAdapter.fill();

};


/**
 * Результат запроса на заполнение грида
 * @param datas
 */
DirectoryEditForm.prototype.fillGrid = function(attrs, datas) {
    var that = this;
    var i;
    var columns = [{text: gis_findroutegridform_2, sortable: false, filterable: false, editable: false,
        groupable: false, draggable: true, resizable: false,
        datafield: '', columntype: 'number', width: 20,
        cellsrenderer: function (row, column, value) {
            return "<div style='margin-left: 5px;margin-top: 2px;'>" + (value + 1) + "</div>";
        }}];
    var datafileds = [{name:'id', type: 'number'}];
	//если данные пришли без схемы(вариант со правочниками iust)
    if(attrs == undefined || attrs.length == 0){
        attrs = [];
        if(datas != undefined && datas.length > 0 ){
            var obj = datas[0];
            for(var o in obj){
	            attrs.push(o);
            }
        }
    }

    //общая ширина - 1-я колонка - место под скролл вертикальный, чтоб не появлялся горизонтальный(-20)
    var wp = (785-20)/attrs.length;
    for (i = 0; i < attrs.length; i++) {
        datafileds.push({name:attrs[i],type:'string'});
        columns.push({
            text: attrs[i],
            datafield: attrs[i],
            width: wp,
            groupable: false,
            draggable: true,
            resizable: true,
            sortable: true,
            sortfield: attrs[i]
        });
    }
    //парсим данные и устанавливаем колонки
    var gridAdapter = new $.jqx.dataAdapter({
        datafields: datafileds,
        id: 'uid',
        localdata: datas,
        addrow: function (rowid, rowdata, position, commit) {
            commit(true);
            if(rowid !== undefined){
                that.added[rowdata.uid] = rowdata;
            }
        }
    });
    try{
        $("#directoryGrid").jqxGrid({
            source: gridAdapter,
            columns: columns,
            sortable:true,
            showsortcolumnbackground:false,
            rowsheight: 19,
            altrows:true,
            columnsresize: true
        });
    }
    catch(e){}
    //$("#directoryGrid").jqxGrid('autoresizecolumns');
};


/**
 * Сохранение текущего состояния справочника
 */
DirectoryEditForm.prototype.save_ = function() {
    this.baseDataAdapter.update();
};

DirectoryEditForm.prototype.exportExcel_ = function(dataObj,layerId) {
    //забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
    var limitExportExcel = NaN;
    if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
        limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
    }
    var alertForm = new AlertForm();
    // isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
    if (limitExportExcel && dataObj.length > limitExportExcel && false && isNaN(limitExportExcel)){
        alertForm.build("gridExportLimitAlertForm",gis_directoryeditform_2+dataObj.length+".<br/>"
        +gis_directoryeditform_3+limitExportExcel+".<br/>"
        +gis_directoryeditform_4+limitExportExcel+gis_directoryeditform_5,gis_directoryeditform_6);
    }
    else{
        alertForm.build("gridExportLimitAlertForm",gis_directoryeditform_2+dataObj.length+".<br/>"
        + gis_directoryeditform_7,gis_directoryeditform_8);
    }
    //Добавляем слушатель закрытия формы
    $("body").on(CloseEvent.CLOSE, function (evt) {
        $("body").off(CloseEvent.CLOSE);
        if (evt && evt.detail==1) {
            //TODO переделать описание грида, чтобы в нем явно был указан шаблон для выгрузки в Excel (для PODS_ANODE_LIST.XML он например не указан)
            var fileName = App.generateUUID() + ".xls";
            var newDataObj = [];
            for ( var i = 0; i < dataObj.length; i++) {
                //удаляем колонку с uid, которую грид генерирует
                if (dataObj[i].uid !== undefined){
                    delete dataObj[i].uid;
                }
                var newData = {};
                for(var item in dataObj[i]){
                    var repl = /[^0-9a-zA-Zа-яА-Я_]/gi;
                    var curColItemText = dataObj[i][item];
                    //upd 27.05.20.заменяем \n в колонках на '', чтобы в excel в названиях не было _n
                    var curColHeaderText = item.replace(/(\\r\\n|\\n|\\r)/gm,'');
                    curColHeaderText = item.replace(repl, "_");
                    newData[curColHeaderText] = curColItemText;

                }
                newDataObj.push(newData);
            }
            ExportUtil.exportToExcelFromDirectory(newDataObj, fileName, layerId, 'export');
        }
    });
};


/**
 * Функция обработчки события окончания обновления данных.
 * Отображает информацию об изменениях в данных
 * @param updateInfo
 * @private
 */
DirectoryEditForm.prototype.dataUpdateComplete_ = function(updateInfo){
    var mess = '';
    var info = updateInfo;
    var hasSuccessfulChanges = false;
    if (info["added"] !== undefined && (info["added"] > 0)){
        mess += gis_directoryeditform_9 + info["added"] + "\n";
    }
    if (info["modified"] !== undefined && (info["modified"] > 0)){
        mess += gis_directoryeditform_10 + info["modified"] + "\n";
    }
    if (info["deleted"] !== undefined && (info["deleted"] > 0)){
        mess += gis_directoryeditform_11 + info["deleted"] + "\n";
    }
    if (mess != ''){
        var errorCnt = 0;
        if (info["errors"] !== undefined && parseInt(info["errors"]) > 0){
            errorCnt = parseInt(info["errors"]);
        }
        //Если ошибок нет - ставим hasSuccessfulChanges = true
        if (errorCnt==0)
        mess += gis_directoryeditform_12 + errorCnt + "\n";
        App.confirmDialog(mess);
    }
   // $('#directoryEditForm').remove();
};
/**
 * Класс всплывающей формы с фильтром нижнего уровня
 */
function BottomFilterForm(elementId) {
    this.title = gis_bottomfilterform_1;
    this.closable = true;
    this.htmlUrl = 'ui/html/BottomFilterForm.html';
    //Источник данных для комбобокса операций
    this.scalarFilterOp = ["=",">","<",">=","<=","!=", "likeA", "notLikeA", "likeA%", "like%A", "like%A%", "notLike%A%"]; /*["~=","=",">","&#60;",">=","<=","!="];*/
    //переменные устанавливаются извне при инициализации формы до вызова build()
    this.currentGrid = null;
    this.currentGridDescr = null;
    this.currentGridColumns = [];
    this.currentGridColumns1 = [];
    this.currentFilters = [];
    this.topFilters = [];
    this.roughFilters = [];
    this.hasSpatial = true;
    this.elementId = elementId;
    this.showFirstBottomFilterMessage = false;
}

BottomFilterForm.prototype.build = function(elementId) {
    try {
        var that = this;
        //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
        function build() {
            //Создаем диалоговую форму
            dlg.dialog({
                modal: true,
                resizable: false,
                title: that.title,
                dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
                closeOnEscape: that.closable,
                width: 825,
                height: that.hasSpatial ? 528 : 425
            });

            //Уникальный идентификатор грида формируем на основе идентификатора элемента
            var jqxGridId = "jqxgrid" + that.elementId;
            //Формируем обертку, в которой будем создавать грид
            var widgetContent =
                '<div id="jqxDockPanel' + jqxGridId + '" style="width: 100%; height: 100%">' +
                '<div id="jqxWidget' + jqxGridId + '" dock="right" style="width: 100%; height: 100%;">' +
                '<div id="' + jqxGridId + '" class="bottomFilter-mainGrid">' + //getLocalization('ru').loadtext +
                '</div>' +
                '</div>' +
                '</div>';
            $('#'+that.elementId+' .scalarBottomFilterBox').html(widgetContent)

            if(!that.hasSpatial)
                $('#'+that.elementId+' .topFilterBox').addClass('topFilterBox__no-spatial');
            //Создаем панель с возможностью процентного и фиксированного layout
            $("#jqxDockPanel"+jqxGridId).jqxDockPanel({ width: '100%', height: 170});

            //Создаем панель с динамическими комбобоксами
            var dynamicFilterContent = '<div id="topFilterBox' + jqxGridId + '" style="width: 100%; height: 100%"></div>';
            $('#'+that.elementId+' .topFilterBox').html(dynamicFilterContent);

            //Данные (установленные пользователем фильтры)
            //Добавляем фильтры, если они есть (передаются в форму через this.currentFilters)
            var data = [];

            //Массив div'ов с динамическими фильтрами
            var currentDynFilters = [];

            //Получение из общего массива фильтров динамического фильтра конкретной колонки (идет в списки)
            var getDynColumnFilter = function getDynColumnFilter(allFiltersArr, curColumn) {
                var curFilter;
                for (var i = 0; i < allFiltersArr.length; i++) {
                    curFilter = allFiltersArr[i];
                    if (curFilter && curFilter.hasOwnProperty('fld') && curFilter['fld']==curColumn.datafield) {
                        return curFilter;
                    }
                }
                return null;
            };

            //Фильтрация списка значений нижнего фильтра по переданному массиву значений фильтра верхнего или среднего уровня
            function sliceFiltersByArray(filterArray, dynFilterDivId, innerFilterDivId, dataProvider) {
                //return;
                if (filterArray!=undefined && filterArray && filterArray.length > 0) {
                    for (var jj = 0; jj < filterArray.length; jj++) {
                        var curTopFilterObj = filterArray[jj];
                        var curTopFilterDataProvider = $('.'+curTopFilterObj.name).myFilters('getFilterDataProviderString');
                        //Сравниваем сначала по провайдеру, и только если они не совпадают сравниваем по названию фильтра
                        if (curTopFilterObj && curTopFilterObj.hasOwnProperty('name') &&
                            (curTopFilterDataProvider==dataProvider || curTopFilterDataProvider+'_GRID'==dataProvider || curTopFilterObj.name==innerFilterDivId.toUpperCase()+'_FILTER')) {
                            //Значение фильтра верхнего уровня хранится в виде строки идентификаторов, разделенных запятой в свойстве value
                            //TODO хардкод. Если год обследования из задачи шурфовок, то показываем все годы
                            if(innerFilterDivId === 'YEAR_INSP')
                                $('#'+dynFilterDivId+' .'+innerFilterDivId).myFilters('updateTopFilter',{obj_ids:curTopFilterObj.value});
                            else
                                $('#'+dynFilterDivId+' .'+innerFilterDivId).myFilters('sliceListFilter',{obj_ids:curTopFilterObj.value});
                        }
                    }
                }
            }

            //Формируем массив для фильтрации по колонкам
            if (that.currentGridDescr && that.currentGridDescr.gridColumns && that.currentGridDescr.gridColumns.length > 0) {
                that.currentGridColumns = [];
                that.currentGridColumns1 = [];
                for (var i = 0; i < that.currentGridDescr.gridColumns.length; i++) {
                    var curCol = that.currentGridDescr.gridColumns[i];
                    //Добавляем к фильтрации только если в колонке есть параметр типа фильтрации!
                    if (curCol.filtercomparisiontype!==undefined) {
                        //Если curCol.filtercomparisiontype==='array', то это динамический комбобокс
                        if (curCol.filtercomparisiontype==='array') {
                            //Добавляем контрол динамического фильтра
                            var dynFilterDivId = jqxGridId+'dynFilterBox'+i;
                            var dynFilterDiv = '<div id="'+dynFilterDivId+'" class="dynamicFilterPopupList"/>';
                            var isInfinite = curCol.filterinfinite;
                            var selectAllElements = (!(FilterSourceDataManager && FilterSourceDataManager[curCol.filterrequestid] && FilterSourceDataManager[curCol.filterrequestid].selectAllElements === false));
                            $('#topFilterBox'+jqxGridId).append(dynFilterDiv);
                            //Создаем описание динамического комбобокса по описанию колонки
                            var dynFilterXml = "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'>" +
                                "<components:FilterPopUpButton width='100%' minPopupWidth='610' height='22' title='"+curCol.text.replace(/\\n/g, ' ')+"' selectAllElements='"+selectAllElements+"' minCnt='1' " +
                                "id='"+curCol.datafield+"' dataProvider='"+curCol.filterrequestid+ "' /> </mx:VBox>";
                            if(isInfinite){
                                $('#'+dynFilterDivId).myFilters({
                                    dataXML: dynFilterXml,
                                    infinite: isInfinite,
                                    requestId: curCol.filterrequestid,
                                    handlers:{
                                        infiniteCallback: function(xmlElement, requestId){
                                            var datas = App.convertDataXmlToArray(xmlElement);
                                            FilterSourceDataManager[requestId].datas = datas;
                                        },
                                    }
                                });
                                currentDynFilters.push({'dynFilterDivId':dynFilterDivId, 'curCol':curCol});
                            }
                            else{
                                $('#'+dynFilterDivId).myFilters({dataXML:dynFilterXml});
                                //Фильтруем список значений, если в фильтрах верхнего или среднего уровня есть такие фильтры (сравниваем по ID и по dataProvider)
                                sliceFiltersByArray(that.topFilters, dynFilterDivId, curCol.datafield, curCol.filterrequestid);
                                sliceFiltersByArray(that.roughFilters, dynFilterDivId, curCol.datafield, curCol.filterrequestid);
                                //Сохраняем id div'а с динамическим фильтром (чтобы потом забирать фильтры)
                                currentDynFilters.push({'dynFilterDivId':dynFilterDivId, 'curCol':curCol});
                                //Ищем в массиве that.currentFilters динамический фильтр текущей колонки (для выставления выбранных ранее значений)
                                var curDynFilter = getDynColumnFilter(that.currentFilters, curCol);
                                if (curDynFilter && curDynFilter.hasOwnProperty('val') && curDynFilter.val.length > 0) {
                                    var selFilterIds = [];
                                    for (var j = 0; j < curDynFilter.val.length; j++) {
                                        selFilterIds.push(curDynFilter.val[j]['CODE']);
                                    }
                                    $('#'+dynFilterDivId+' .'+curCol.datafield).myFilters('updateTopFilter',{obj_ids:selFilterIds.join(",")});
                                }
                            }

                        } else {
                            that.currentGridColumns.push(curCol);
                            that.currentGridColumns1.push({
                                text: curCol.text.replace(/\\n/g, ' '),
                                datafield: curCol.datafield,
                                filtercomparisiontype: curCol.filtercomparisiontype,
                                dateformat: curCol.dateformat,
                            });
                            //Ищем в массиве that.currentFilters статические фильтры текущей колонки (для выставления выбранных ранее значений)
                            for (var k = 0; k < that.currentFilters.length; k++) {
                                var curStatFilter = that.currentFilters[k];
                                if (curStatFilter && curStatFilter.hasOwnProperty('fld') && curStatFilter['fld']==curCol.datafield) {
                                    data.push(curStatFilter);
                                }
                            }
                        }
                    }
                }
            }
            var hasDictFilters = currentDynFilters.length !== 0;
            if(!hasDictFilters){
                var dynFilterDivIdFake = jqxGridId + 'dynFilterBox' + 'Fake';
                var dynFilterDivFake = '<div id="'+dynFilterDivIdFake+'" class="dynamicFilterPopupList"/>';
                $('#topFilterBox'+jqxGridId).append(dynFilterDivFake);
                var dynFilterXmlFake = "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'>" +
                    "<components:FilterPopUpButton width='100%' minPopupWidth='610' height='0' title='"+gis_bottomfilterform_4+"' selectAllElements='true' minCnt='1' " +
                    "id='fake_filter' dataProvider='none' /> </mx:VBox>";
                $('#'+dynFilterDivIdFake).myFilters({dataXML:dynFilterXmlFake});
                $('#'+dynFilterDivIdFake).hide();
                $('.dynamicFilterPopupList');
                $('#'+that.elementId+' .topFilterBox').css('width', '0px');
                $('#jqxWidget' + jqxGridId).css('width', '810px');
                $('#'+that.elementId+' .scalarBottomFilterBox').css('width', '810px');
            }
            else{
                $('#'+that.elementId+' .scalarBottomFilterBox').css('width', '430px');
            }
            //Увеличиваем высоту диалога на необходимую величину (динамически были добавлены комбобоксы)
            var dlgHeight = dlg.dialog("option","height");
            var topFilterBoxHeight = $('#topFilterBox'+jqxGridId).outerHeight();
            /*var maxHeight = $('.bottomFilterForm .topFilterBox').css('max-height');
            if(maxHeight){
                maxHeight = Number(maxHeight.replace('px',''));
                if(maxHeight <= topFilterBoxHeight)
                    topFilterBoxHeight = maxHeight;
            }
            if(topFilterBoxHeight !== 0)
                dlg.dialog("option","height", dlgHeight + topFilterBoxHeight);*/
            var currentGridColumnsAdapter = new $.jqx.dataAdapter(that.currentGridColumns1, {
                autoBind: true
            });

            function createEmptyHTML(hasDictFilters){
                var prefix = (!hasDictFilters)? '__nodict': '';
                var descrWidth = 125, valWidth = 160, opWidth = 100, dateClass = 'filter-datepicker_text';
                if(!hasDictFilters){
                    descrWidth = 250;
                    valWidth = 370;
                    opWidth = 140;
                    dateClass= 'filter-datepicker_text-nodict';
                }
                var id = jqxGridId+'_'+new Date().getTime();
                var div = $('<div id="maindiv_'+id+'" class="bottomFilter-scalarFields-row"></div>');
                var descr = $('<div id="descr_'+id+'" style="display:inline-block;" ></div>');
                var valDiv =  $('<div style="display:inline-block;" ></div>');
                var val = $('<input type="text" id="input_'+id+'" class="bottomFilter-scalarFields-row-input"/>');
                var valDate =  $('<div style="display:inline-block; float: left; height: 25px;">' +
                    '<input type="text" id="inputdate1_'+id+'" class="' + dateClass + ' bottomFilter-scalarFields-row-input"/>' +
                    '<input type="text" id="inputdate2_'+id+'" class="' + dateClass + ' bottomFilter-scalarFields-row-input"/>' +
                    '</div>');
                var imageDiv = $('<div class="bottomFilter-scalarFields-row-remove"></div>');
                var imageBtnHtml = $('<input type="button" class="gridButton bottomFilter-scalarFields-row-input"'
                +' style="padding: 0;margin-top: 5px;'+" background-image: url('./Public/assets/delete.png');"+'" value=" " title=""'
                +' id="btn_'+jqxGridId+'_'+id+'" />')
                    .on('click',function(event){
                        event.preventDefault();
                        var baseGridChildren = $("#"+jqxGridId).children();
                        if(baseGridChildren.length >1){
                            //дополнительное условие, если последний ряд пустой с невыбранным descr, то его не удаляем
                            if($('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                                $('#maindiv_'+id).remove();
                        }
                        return false;
                    });
                var useAutoDropDownHeight = that.currentGridColumns1 && that.currentGridColumns1.length <= 10;
                /*$.each(that.currentGridColumns1, function(key, value) {
                    descr.append($("<option></option>")
                            .attr("value",value.datafield)
                            .text(value.text));
                });*/

                descr.jqxDropDownList({source: currentGridColumnsAdapter, width: descrWidth, displayMember: 'text', valueMember: 'datafield', selectedIndex: -1,
                    placeHolder: gis_bottomfilterform_2, autoDropDownHeight: useAutoDropDownHeight, theme: 'gis-blueorange'})
                .on('change', function (event) {
                    if (event.args && event.args.item) {
                        var item = event.args.item;
                        var firstOption = $('#op-base_'+id+' option')[0];
                        //$("#"+jqxGridId).jqxGrid('source').records[curRow]['fld'] = item.value;
                        //Добавляем в hasType тип сравнения колонки - по нему строится строка запроса фильтра
                        if (item.hasOwnProperty('originalItem') && item.originalItem.hasOwnProperty('filtercomparisiontype') && item.originalItem.filtercomparisiontype!=undefined ) {
                            //если тип строковый, то дизейблим
                            val.show();
                            valDate.hide();
                            if(item.originalItem.filtercomparisiontype == 'date'){
                                $('#op-base_'+id).attr ('disabled', 'disabled').css('display','block');
                                $('#op-str_'+id).attr ('disabled', 'disabled').css('display','none');
	                            firstOption.selected = true;
                                val.hide();
                                valDate.show();
                                //устанавливаем формат даты, в которой нужно отправлять фильтр на сервер(миллисекунды или в текстовом виде yyyy.mm....)
                                $('#inputdate1_'+id).data('dateformat', item.originalItem.dateformat);
                                $('#inputdate2_'+id).data('dateformat', item.originalItem.dateformat);
                            }
                            else if (item.originalItem.filtercomparisiontype == 'string'){
                                $('#op-base_'+id).attr ('disabled', 'disabled').css('display','none');
                                $('#op-str_'+id).removeAttr('disabled').css('display','block');
                            }else{
                                $('#op-base_'+id).removeAttr('disabled').css('display','block');
                                $('#op-str_'+id).attr ('disabled', 'disabled').css('display','none');
                            }

                            //$("#"+jqxGridId).jqxGrid('source').records[curRow]['hasType'] = item.originalItem.filtercomparisiontype;
                        }
                    }
                });

                //Создаём 2 селекта для операций с числами и строками, один всегда имеет display: none (для тэга option display: none не работает в IE)
                var operationBase = $('<select id="op-base_'+id+'" class="bottomFilter-scalarFields-row-opselect bottomFilter-operation-base" disabled style="width: ' + opWidth +'px"></div>');
                var operationStr = $('<select id="op-str_'+id+'" class="bottomFilter-scalarFields-row-opselect bottomFilter-operation-str" disabled style="display:none; width: ' + opWidth +'px"></div>');
                var opDiv =  $('<div class="bottomFilter-scalarFields-row-opdiv" ></div>');
                $.each(that.scalarFilterOp, function(key, value) {
                    var text = value;//"likeA", "notLikeA", "like%A", "likeA%", "like%A%", "notLike%A%"
                    if(value === "<")text= "&#60;";
                    if(value === "likeA") value= "равно...";
                    if(value === "notLikeA")value= "не равно...";
                    if(value === "likeA%")value= "начинается с...";
                    if(value === "like%A")value= "заканчивается на...";
                    if(value === "like%A%")value= "содержит...";
                    if(value === "notLike%A%")value= "не содержит...";
                    if(key <= 5) {
                        operationBase.append($('<option class="bottomFilter-base-option"></option>')
                            .attr("value", text)
                            .text(value));
                    }else{
                        operationStr.append($('<option class="bottomFilter-str-option"></option>')
                            .attr("value", text)
                            .text(value));
                    }
                });
                val.jqxInput({height: 25, width: valWidth, theme:'gis-blueorange'})
                    .on('paste', function (evt) {
                        //Сделано специально для IE, на других браузерах вставка из Excel сама преобразует переносы строк в пробелы
                        try {
                            var replacedText = window.clipboardData.getData('text');
                            replacedText = replacedText.replace(/(\r\n|\n|\r)/gm,';'); //Заменяем переносы строк на ';'
                            setTimeout(function (){
                                val[0].value = replacedText;
                            },5);
                        } catch (err) {}
                    })
                    .on('focusout',function(evt){
                        //если поле условия выбрано и ряд последний, то новую создаем
                        //заменяем запятые на точки
                        var baseGridChildren = $("#"+jqxGridId).children();
                        if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                            createEmptyHTML(hasDictFilters);
                    })
                    .on('keyup',function(evt){
                        if (evt.keyCode === 13) {
                            //если поле условия выбрано и ряд последний, то новую создаем
                            var baseGridChildren = $("#"+jqxGridId).children();
                            if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                                createEmptyHTML(hasDictFilters);
                        }
                    });

                opDiv.append(operationBase);
                opDiv.append(operationStr);
                valDiv.append(val);
                valDiv.append(valDate);
                imageDiv.append(imageBtnHtml);
                div.append(descr).append(opDiv).append(valDiv).append(imageDiv);
                $("#"+jqxGridId).append(div);
                $('#inputdate1_'+id).datepicker().on('focusout',function(evt){
                    //если поле условия выбрано и ряд последний, то новую создаем
                    //заменяем запятые на точки
                    var baseGridChildren = $("#"+jqxGridId).children();
                    if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                        createEmptyHTML(hasDictFilters);
                })
                .on('keyup',function(evt){
                    if (evt.keyCode === 13) {
                        //если поле условия выбрано и ряд последний, то новую создаем
                        var baseGridChildren = $("#"+jqxGridId).children();
                        if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                            createEmptyHTML(hasDictFilters);
                    }
                });
                $('#inputdate2_'+id).datepicker().on('focusout',function(evt){
                    //если поле условия выбрано и ряд последний, то новую создаем
                    //заменяем запятые на точки
                    var baseGridChildren = $("#"+jqxGridId).children();
                    if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                        createEmptyHTML(hasDictFilters);
                })
                .on('keyup',function(evt){
                    if (evt.keyCode === 13) {
                        //если поле условия выбрано и ряд последний, то новую создаем
                        var baseGridChildren = $("#"+jqxGridId).children();
                        if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                            createEmptyHTML();
                    }
                });
                //val.hide();
                valDate.hide();
            }
            createEmptyHTML(hasDictFilters);
            if(that.showFirstBottomFilterMessage){
                App.confirmDialog(gis_grid_bottomfilter_2,null,{title:gis_core_1});
            }

	        //Функция проверки корректности введенных данных(пока только тип Date)
	        var checkFilter = function checkFilter(filter){
                var i=0;
                var result = true;
		        for(;i<filter.length;i++){
		            var item = filter[i];
                    if(item.hasType == 'date' && item.startDate != undefined && item.endDate != undefined){
                        var matchStr1 = /^(\d{1,2})[.\/](\d{1,2})[.\/](\d{4})$/;
                        var matchStr2 = /^(\d{1,2})[.\/](\d{4})$/;
                        var matchStr3 = /^(\d{4})$/;
	                    var matches = matchStr1.exec(item.startDate);
	                    if (matches == null) {
		                    matches = matchStr2.exec(item.startDate);
		                    if (matches == null) {
			                    matches = matchStr3.exec(item.startDate);
			                    if (matches == null)
			                        result = false;
			                    else
                                    item.startDate = '01.01.' + item.startDate;//дописываем месяц и день
                            }
		                    else
                                item.startDate = '01.' + item.startDate; //дописываем день
	                    }
                        matches = matchStr1.exec(item.endDate);
                        if (matches == null) {
                            matches = matchStr2.exec(item.endDate);
                            if (matches == null) {
                                matches = matchStr3.exec(item.endDate);
                                if (matches == null)
                                    result = false;
                                else
                                    item.endDate = '31.12.' + item.endDate;//дописываем месяц и день
                            }
                            else{
                                try{
                                    var days = daysInMonth(matches[1],matches[2]);
                                    item.endDate = days + '.' + item.endDate; //дописываем день
                                }
                                catch(ex){
                                    item.endDate = '28.' + item.endDate; //дописываем день. Если ошибка парсинга, то выставляем нижнюю границу 28 дней, чтобы не было ошибки БД
                                }

                            }

                        }
                    }
                }
	            return result;
	        };
            var daysInMonth = function daysInMonth (month, year) {
                return new Date(year, month, 0).getDate();
            }
            //Функция собирает в общий массив фильтры из формы
            var getFilter = function getFilter(){
                var resultFilters = [];
                //Получаем текущий грид со статическими фильтрами
                var gridSource  = $("#"+jqxGridId).children();
                var i;
                for (i = 0; i < gridSource.length; i++) {
                    var newItem = {};
                    //получаем id, начиная с 8, т.к. вначале идёт "maindiv_"
                    var cId = gridSource[i].id.substr(8);
                    //забираем значения полей
                    var descrItem = $('#descr_'+cId).jqxDropDownList('getSelectedItem');
                    if(descrItem!=undefined && descrItem.originalItem != undefined){
                        newItem.hasType = descrItem.originalItem.filtercomparisiontype;
                        newItem.fld = descrItem.originalItem.datafield;
                        newItem.descr = descrItem.originalItem.text;
                        var opItem = $('#op-base_'+cId).is(':visible')? $('#op-base_'+cId).val(): $('#op-str_'+cId).val();
                        if(opItem!=undefined)
                            newItem.op = opItem;//.value;
                        if(descrItem.originalItem.filtercomparisiontype !== 'date')
                            newItem.val = $('#input_'+cId).jqxInput('val');
                        else{
                            var startDate = $('#inputdate1_'+cId).val();
                            var endDate = $('#inputdate2_'+cId).val();
                            if(!startDate) startDate = '01.01.1900';
                            if(!endDate) endDate = '01.01.2121';
                            newItem.startDate = startDate;
                            newItem.endDate = endDate;

                            newItem.dateformat = $('#inputdate1_'+cId).data('dateformat');
                            newItem.val = 'none';//оставляем, чтобы не порушилась функция формирования нижнего фильтра GridWidget.prototype.getBottomFilterString
                        }
                        newItem.del = '';
                        //Перед включением условия в запрос проверяем, что оно заполнено по fld, т.е. что колонка для условия выбрана
                        resultFilters.push(newItem);
                    }
                }
                //Добавляем в фильтр выбранные в динамических комбобоксах значения
                for (i = 0; i < currentDynFilters.length; i++) {
                    var dynFilterDivId = currentDynFilters[i]['dynFilterDivId'];
                    var dynFilterCol = currentDynFilters[i]['curCol'];
                    var curDynFilters = [];
                    //Получаем список выбранных записей
                    var resFilterValues = $('#'+dynFilterDivId).myFilters('getFilterValuesArray');
                    var dotSplitArr = resFilterValues[0].values;
                    //Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию либо тип фильтр не infinite(с большим)
                    var checkAllCheckBox = $($('#'+dynFilterDivId+" .divCheckAll")[0].children[0]);
                    if (dotSplitArr.length<=0 || (checkAllCheckBox && checkAllCheckBox.jqxCheckBox('checked') && !checkAllCheckBox.data('infinite'))) continue;
                    var j;
                    for (j = 0; j < dotSplitArr.length; j++) {
                        var selectedObj = {'CODE':dotSplitArr[j].code};
                        curDynFilters.push(selectedObj);
                    }
                    //Добавляем фильтр по полю, только если в нем что-то выбрано. Если выбраны все записи - условие добавлять не нужно
                    var curDynFilterObj = {'hasType':"", 'del':"", 'descr':dynFilterCol.text, 'fld':dynFilterCol.datafield, 'op':"in", 'val':curDynFilters};
                    resultFilters.push(curDynFilterObj);
                }

                return resultFilters;
            };

            //создаем радиобатоны
            //21.07.2020 Добавлена правка,если приходит false, значит слой не имеет геокоординат
            if (that.hasSpatial){
                $('#'+that.elementId+' .bottomFilterHighlight').jqxRadioButton({width: 20, checked: true,});
                $('#'+that.elementId+' .bottomFilterSlice').jqxRadioButton({width: 20, checked: false });
                //Создаем чекбоксы
                //$("#bottomFilterSelectingCheckbox").jqxCheckBox({width: 120, height: 20, checked: true});
                $('#'+that.elementId+' .bottomFilterCenteringCheckbox').jqxCheckBox({width: 120, height: 20, checked: true});
            }else {
                $('#'+that.elementId+' .bottomFilterHighlight').remove();
                $('#'+that.elementId+' .bottomFilterSlice').remove();
                $('#'+that.elementId+' .bottomFilterCenteringCheckbox').remove();
                $('#'+that.elementId).find('label').last().remove();
            }

            //Кнопки Ок и отмены
            $("input[name='apply']", dlg).click(function () {
                //Собираем фильтр по имеющимся в форме значениям
                var curFilter = getFilter();
                //проверка на корректность ввода типа Даты
                if(checkFilter(curFilter)){
                    //если false - оставялем на карте выбранные объекты
                    var selecting, centering;
                    if (that.hasSpatial){
                        selecting =  $('#'+that.elementId+' .bottomFilterHighlight').jqxRadioButton('checked');
                        centering = $('#'+that.elementId+' .bottomFilterCenteringCheckbox').jqxCheckBox('checked');
                    }
                    that.applyBottomFilter(curFilter, that.currentGrid, selecting, centering);
                }else
                    App.confirmDialog(gis_grid_bottomfilter_1,null,{title:gis_core_1});
            });
            $("input[name='cancel']", dlg).click(function () {
                that.close();
            });
        }

        that.elementId = elementId;

        if($('#'+elementId).length>0){
            that.open();
        }
        else{
            //Создаем форму
            $('body').append('<div id="'+elementId+'"></div>');
            var dlg = $('#'+elementId);
            dlg.load(this.htmlUrl+'?'+Math.random(), build);
        }

        //$('#'+elementId).remove();

    } catch (e) {
        App.errorReport(gis_bottomfilterform_3, e, undefined, {filename:gis_filename_307, functionname:'gis_filename_307_1'});
    }
};

BottomFilterForm.prototype.sendCloseEvent = function sendCloseEvent(detail, curFilter, currentGrid, selecting, centering) {
    var closeEvt = new CloseEvent(CloseEvent.CLOSE);
    closeEvt.detail = detail;
    if (curFilter && curFilter!=undefined) {
        closeEvt.eventData = {filter: curFilter, currentGrid: currentGrid, "selecting": selecting, "centering": centering};
    }
    closeEvt.dispatch();
};

BottomFilterForm.prototype.applyBottomFilter = function applyBottomFilter(curFilter, currentGrid, selecting, centering, highlight) {
    //Генерируем событие закрытия формы с сохранением
    BottomFilterForm.prototype.sendCloseEvent(1, curFilter, currentGrid, selecting, centering, highlight);
    //Удаляем форму (с небольшой задержкой, чтобы успели отработать все функции получения фильтров до закрытия формы)
    var curElemId = this.elementId;
    setTimeout(function(){
        $('#'+curElemId).dialog('close');//.remove();
    },100);
};

BottomFilterForm.prototype.cancel = function() {
    //Генерируем событие закрытия формы без сохранения
    BottomFilterForm.prototype.sendCloseEvent(0);
    //Удаляем форму
    $('#'+this.elementId).remove();
};

BottomFilterForm.prototype.close = function() {
    //Генерируем событие закрытия формы без сохранения
    BottomFilterForm.prototype.sendCloseEvent(0);
    //Удаляем форму
    $('#'+this.elementId).dialog('close');
};

BottomFilterForm.prototype.open = function() {
    $('#'+this.elementId).dialog('open');
};




/**
 * Класс для управления видимостями и положением колонок грида
 * @param opt_options
 * @constructor
 */
function ManageGridColumnsForm(opt_options) {
    var options = opt_options !== undefined ? opt_options : {};
    this.columns = (options.columns !== undefined)?options.columns:[];
    this.htmlUrl = 'ui/html/grid/ManageGridColumnsForm.html';
    this.applyCallback = (options.applyCallback !== undefined)?options.applyCallback:undefined;
};

ManageGridColumnsForm.prototype.build = function() {
    var that = this;
    var currDialog = $('#gridColumnsDialog');
    if(currDialog.length == 0){
        $('body').append('<div id="gridColumnsDialog" style="overflow: hidden;"></div>');
        $('#gridColumnsDialog').hide();
        currDialog = $('#gridColumnsDialog');
    }
    var dlg = currDialog;
    dlg.load(this.htmlUrl, build);
    function build() {
        dlg.dialog({
            modal: true,
            title: gis_managegridcolumnsform_1,
            closeOnEscape: false,
            dialogClass: 'noCloseButton gsi-zindex__dialog',
            width: 500,
            height: 400,
            resizable: false
        });
        //заполняем данными элементы
        that.fillGridColumnsGrid_();
        //кнопки "Применить", "Отмена"
        $('#gridColumnsApply').on('click',function(){
            that.applyColumns_();
            $('#gridColumnsDialog').remove();
        });
        $('#gridColumnsCancel').on('click',function(){
            $('#gridColumnsDialog').remove();
        });
    }
};

/**
 * Заполнение списка колонок
 * @private
 */
ManageGridColumnsForm.prototype.fillGridColumnsGrid_ = function(){
    var that = this;
    var columnsdata = [];
    var selectAll = true;
    for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];
        if(!column.text || column.datafield === 'RWN')
            continue;
        var obj = {
            dataField: column.datafield,
            columnName: column.text.replace(/\\n/g,' '),
            visible: !column.hidden,
        };
        selectAll = selectAll && !column.hidden;
        columnsdata.push(obj);
    }

    var source = {
        localdata: columnsdata,
        datatype: "array",
        datafields:
            [
                { name: 'dataField', type: 'string' },
                { name: 'columnName', type: 'string' }, //название кирилицей
                { name: 'visible', type: 'string' }, // !hidden
            ]
    };
    var layerNameSize = 62;
    $('#gridColumnsApply').css('width', 89);

    var dataAdapter = new $.jqx.dataAdapter(source);
    $("#gridColumnsGrid").jqxGrid({
        width: 490,
        height: 330,
        source: dataAdapter,
        pageable: false,
        altRows: false,
        selectionmode:'singlerow',
        columnsResize: true,
        editable: true,
        theme:'gis-blue-grid',
        localization: getLocalization('ru'),
        columns: [
            {
                text: '',
                sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                datafield: 'visible', columntype: 'string', width: 25,
                cellsrenderer: function (row, column, value) {
                    if(value === 'true'){
                        return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='ManageGridColumnsForm.prototype.setVisible_(this,"+row+")' checked></div>";
                    }
                    else{
                        return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='ManageGridColumnsForm.prototype.setVisible_(this,"+row+")'></div>";
                    }
                },
                renderer: function () {
                    return '<div><input type="checkbox" style="margin-left: 5px;margin-top: 5px;" id="manage_grid_columns_all_checkbox"></div>'
                },
                rendered: function (element) {
                    var checkbox = $(element).last();
                    $(checkbox).on('click', function (event) {
                        event.stopPropagation()
                    }).on('change', function (event) {
                        var checked =  $('#manage_grid_columns_all_checkbox').is(':checked');
                        ManageGridColumnsForm.prototype.setAllVisible(checked)
                    });
                    return true;
                },
            },
            {
                text: '', sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                datafield: 'up', columntype: 'number', width: 25,
                cellsrenderer: function (row, column, value) {
                    return "<div type='submit' class='map-img map-up-img' onclick='ManageGridColumnsForm.prototype.upColumn_(this,"+value+")' title='"+gis_cassettingsform_9+"'></div>";
                }
            },
            {
                text: '', sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                datafield: 'down', columntype: 'number', width: 25,
                cellsrenderer: function (row, column, value) {
                    return "<div type='submit' class='map-img map-down-img' onclick='ManageGridColumnsForm.prototype.downColumn_(this,"+value+")' title='"+gis_cassettingsform_10+"'></div>";
                }
            },
            {   text: gis_managegridcolumnsform_2, datafield: 'columnName',
                sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                columntype: 'string', width: 390
            }
        ]
    });

    $('#manage_grid_columns_all_checkbox').prop('checked', selectAll);
};

/**
 * Передвигаем меняем местами график
 * @param elem
 * @param row
 * @private
 */
ManageGridColumnsForm.prototype.upColumn_ = function (elem, index) {
    //получаем весь список, там переносим в нужные позиции и заполняем грид
    var rows = $("#gridColumnsGrid").jqxGrid('getrows');
    if (index != 0) {
        var temp = rows[index];
        rows[index] = rows[index - 1];
        rows[index - 1] = temp;

        var source = {
            localdata: rows,
            datatype: "array",
            datafields:
                [
                    {name: 'dataField', type: 'string'},
                    {name: 'columnName', type: 'string'}, //название кирилицей
                    {name: 'visible', type: 'string'}, // !hidden
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#gridColumnsGrid").jqxGrid({source: dataAdapter});
        $("#gridColumnsGrid").jqxGrid('selectrow', index - 1);
    }
};
/**
 * Передвигаем меняем местами график
 * @param elem
 * @param row
 * @private
 */
ManageGridColumnsForm.prototype.downColumn_ = function (elem, index) {
    var rows = $("#gridColumnsGrid").jqxGrid('getrows');
    if (index != rows.length - 1) {
        var temp = rows[index];
        rows[index] = rows[index + 1];
        rows[index + 1] = temp;

        var source = {
            localdata: rows,
            datatype: "array",
            datafields:
                [
                    {name: 'dataField', type: 'string'},
                    {name: 'columnName', type: 'string'}, //название кирилицей
                    {name: 'visible', type: 'string'}, // !hidden
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#gridColumnsGrid").jqxGrid({source: dataAdapter});
        $("#gridColumnsGrid").jqxGrid('selectrow', index + 1);
    }
};


/**
 * Функция управления видимостью слоя
 * @param elem
 * @param rowKey
 * @private
 */
ManageGridColumnsForm.prototype.setVisible_ = function(elem, rowKey){
    var isChecked = '' + $(elem).prop('checked');
    $("#gridColumnsGrid").jqxGrid('setcellvalue',rowKey,'visible', ''+ isChecked);
    var keys = $("#gridColumnsGrid").jqxGrid('getrows');
    var selectAll = true;
    keys.forEach(function(item, i){
        selectAll = selectAll && (item.visible === 'true');
    })
    $('#manage_grid_columns_all_checkbox').prop('checked', selectAll);
};

/**
 * Снимает/добавляет видимость у всех колонок
 * @param checked
 * @private
 */
ManageGridColumnsForm.prototype.setAllVisible = function(checked){
    var keys = $("#gridColumnsGrid").jqxGrid('getrows');
    keys.forEach(function(item, i){
        $("#gridColumnsGrid").jqxGrid('setcellvalue', i, 'visible', ''+ checked);
    })
};


/**
 * Применяем видимость и показ подписей к слоям
 * @private
 */
ManageGridColumnsForm.prototype.applyColumns_ = function() {
    var that = this;
    var rows = $("#gridColumnsGrid").jqxGrid('getrows');
    var fakeRows = rows.slice(0);
    var allColumns = that.columns;
    var lastFakeColumn;
    var counterPinned = 0;
    //формируем обновленный список колонок
    var newColumns = [];

    for (var i = 0; i < allColumns.length; i++){
        var column = allColumns[i];
        if (column.text && column.datafield !== 'RWN'){
            var row = fakeRows.shift();
            if (column.pinned) {
                counterPinned++;
                column.pinned = false;
            }
            if (column.datafield === row.dataField){
                column.hidden = !(row.visible === 'true');
                newColumns.push(column);
            }else {
                allColumns.forEach(function (columnI){
                    if (columnI.datafield === row.dataField){
                        columnI.hidden = !(row.visible === 'true');
                        newColumns.push(columnI);
                    }
                });
            }
        }else {
            if (column.width != '20')
                newColumns.push(column);
            else
                lastFakeColumn = column;
        }
    }
    newColumns.forEach(function (column) {
        if (column.text && column.datafield !== 'RWN'){
            if (counterPinned > 0){
                column.pinned =true;
                counterPinned--;
            }
        }
    });
    if (lastFakeColumn)
        newColumns.push(lastFakeColumn);
    if(this.applyCallback)
        this.applyCallback(newColumns);

};
/**
 * Класс всплывающей формы с экспортом в Excel
 */
function ProcessExportExcelForm() {
    this.closable = true;
    this.link='';
	this.elementId = undefined;
	this.inputData='';
	this.templateName = 'DATA_LAY_Exp.xml';
	this.requestId;
	this.isCancelRequest = false;
};

ProcessExportExcelForm.prototype.build = function() {
	var that = this;
	function exportExcel(){
		try {
			//Устанавливаем курсор ожидания
			BlockingUtil.wait();
			//Добавляем полученные данные в файл
			var isServerExport = false;
			//nodejs не корректно обрабатывает шаблон server_export.xlsm, поэтому для него xlsx расширение
			isServerExport = that.inputData.indexOf('template="server_export"') !== -1 || that.inputData.indexOf('template="export"') !== -1;

			var requestParams = ExportUtil.makeUTETaskServiceDataReqParams(that.templateName, that.inputData);
			that.requestId = App.serverQueryXMLNode(Services.exportExcelNode, requestParams
				,function exportToExcelResult(resultXml) {
					BlockingUtil.ready();
					var errorString = HTTPServiceUtil.getError(resultXml);
					if (errorString != "") {
						App.errorReport(gis_exportutil_8, resultXml.toString(), undefined, {filename:gis_filename_614, functionname:'gis_filename_614_1'});
					} else {
						var fileUrl = ExportUtil.exportExcelFileName;
						var extension = (isServerExport)?'xlsx':'xlsm';
						fileUrl = fileUrl.substr(0, fileUrl.indexOf('.xls') + 1); // cut .xls... without dot
						fileUrl += extension;
						var exportForm = new ExportForm();
						exportForm.link = fileUrl;
						exportForm.build();
					}
					ExportUtil.exportExcelFileName = "";
					cancel();
				}
				, function exportToExcelFault(resultXml) {
					BlockingUtil.ready();
					if(!that.isCancelRequest)
						App.errorReport(ExportUtil.EXPORT_EXCEL_ERROR, resultXml.toString(), undefined, {filename:gis_filename_614, functionname:'gis_filename_614_2'});
					that.isCancelRequest = false;
					ExportUtil.exportExcelFileName = "";
					cancel();
				}
			);
		} catch (e) {
			//Устанавливаем обычный курсор
			BlockingUtil.ready();
			App.errorReport(gis_exportutil_8, e.message, undefined, {filename:gis_filename_614, functionname:'gis_filename_614_3'});
			cancel();
		}
	}

	function cancel() {
		dlg.dialog('destroy').remove();
	}
	var element = $('<div><form class="smallExportDialogForm">\
						<div class="labelField" name="descriptionText">'+gis_processexportform_1+'</div>\
					</form></div>');
	$('body').append(element);

	var dlg = $(element).dialog({
		title: gis_core_1,
		dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
		closeOnEscape: that.closable,
		width: 320,
		height: 100,
		resizable: false,
		modal: false,
		close: function(event, ui){
			that.isCancelRequest = true;
			if(that.requestId !== undefined)
				that.requestId.abort();
			try{
				$(this).dialog('destroy').remove();
			}catch(e){}
		}
	});
	exportExcel();
};
/**
 * Класс всплывающей формы с экспортом в Excel
 */
function ExportForm() {
    this.closable = true;
    this.link='';
	this.elementId = undefined;
	this.htmlUrl = 'ui/html/ExportForm.html';
};

ExportForm.prototype.build = function() {
    var that = this;
    try {
        //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
        function build() {
            //Создаем диалоговую форму
            dlg.dialog({
                modal: true,
                title: gis_core_1,
                dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
                closeOnEscape: that.closable,
                width: 320,
                height: 120,
	            close: function(event, ui){
		            try{
			            $(this).dialog('destroy').remove();
		            }catch(e){}
		            $('#'+that.elementId).remove();
	            }
            });
	        $('#linkFile',dlg).attr('href',that.link).on('click',function(){
		        that.cancel();
	        });
        }
	    this.elementId = 'exportDialog_'+parseInt(Math.random()*1000000);

	    try{
		    $('#'+this.elementId).dialog('destroy').remove();
	    }
	    catch(e){}
	    $('#'+this.elementId).remove();
        //Создаем форму экспорта в GPX или KML
        $('body').append('<div id="'+this.elementId+'"></div>');
        var dlg = $('#'+this.elementId);

        dlg.load(this.htmlUrl, build);

    } catch (e) {
        App.errorReport(gis_exportutil_8, e.message, undefined, {filename:gis_filename_613, functionname:'gis_filename_613_1'});
        //Закрываем форму
        that.cancel();
    }
};

ExportForm.prototype.cancel = function() {
	try{
		$('#'+this.elementId).dialog('destroy').remove();
	}
	catch(e){
	}
	try{
		$('#'+this.elementId).remove();
	}
	catch(e){
	}
};

/*Глобальный объект с константами всех сервисов (просто адреса к ним)*/
Services = {};
/*Сервис выполняет запросы к БД или XML-файлам на сервере*/
Services.processQueryNew = './DataService.asmx/ProcessQueryNew';
/*Сервис запрашивает картинку карты по введенным координатам рамки (запрос к растеризатору)*/
Services.mapDrawService = './MapService.asmx/DrawTile';
/*Сервис запрашивает информацию об объектах растровой карты в указанной точке (запрос к растеризатору)*/
Services.mapInfoService = './MapService.asmx/GetObjectsInfo';
Services.mapWmsService = './MapService.asmx/DrawImageWMS';
/*Сервис */
Services.RunUTETaskService = './ServerTaskService.asmx/RunUTETask';

Services.ImportCP = './UTEService.asmx/ImportPI_CP';

Services.processQueryNode = './api/process-query';
Services.processQueryNodeGeo = './api/process-geoquery';
Services.processQueryNodeXml = './api/process-xml';

Services.exportExcelNode = './api/run-ute-task';

/*сервисы 2-й очереди фриланса*/
Services.sendMailNode = './api/send-mail';
/*********сервисы, работающие с геометриями***********/
//Сервис получает буферную зону (строка WKT) для переданной геометрии объекта (тоже строка WKT)
Services.bufferZoneNode =  './api/geo/buffer-zone';
/*********** ********************************************/

/*********сервисы, работающие с файловой системой***********/

Services.getFileNamesFromDirNode    = './api/files/names'; //получение списка файлов и папок в текущей директории
Services.uploadNode                 = './api/files/upload'; //загрузка файлов на сервер
Services.createImageNode            = './api/files/create-image'; //создание изображения
Services.deleteFileNode             = './api/files/delete'; //удаление файла
/*********** ********************************************/

/*Сервис для записи в лог на сервере*/
Services.logNode = './api/log';

/*Сервисы предпросмотра документов*/
Services.docPreview             = './api/doc/preview';
Services.pdfPreview             = './api/pdf/preview';
Services.pdfOriginal            = './api/pdf/original';
Services.pdfConvert             = './api/pdf/convert';
Services.pdfFullScreen         = './api/pdf-preview';// TODO Заменить как будет готов сервис
/* --------------- Конец --------------- сервисы 2-й очереди фриланса*/

/*Сервисы экспорта данных из внешних источников*/
Services.exportGdalNode         = './api/gdal/export';
Services.importGdalNode         = './api/gdal/import';
Services.parseGdalNode          = './api/gdal/parse';

/*Сервисы авторизации*/
Services.loginNode              = './api/auth/login';
Services.logoutNode             = './api/auth/logout';
Services.changePassNode         = './api/auth/change-pass';
Services.userTasksNode          = './api/auth/user-tasks';
Services.userTaskNode          = './api/auth/user-task';
Services.hasTaskNode          = './api/auth/has-task';

/* сервис проверки работоспособности nodejs*/
Services.isNodeReady            = './api/status/is-ready';

/*Сервисы ute*/
Services.uteLrsRouteCalc        = './ute/lrs-route-calc';
Services.uteKmRouteCalc         = './ute/km-route-calc';
Services.uteIliInspCalc         = './ute/ili-insp-calc';
Services.uteIliInspLink         = './ute/ili-insp-link';
Services.uteIliImportXml        = './ute/ili-import-xml';
Services.uteIliCluster          = './ute/ili-cluster';
Services.uteStoEhzInspProc      = './ute/sto-ehz-insp-proc';
Services.uteStoIliInspProc      = './ute/sto-ili-insp-proc';
Services.uteIliPressure         = './ute/ili-pressure';
Services.uteGroupRouteIdx       = './ute/group-route-idx';
Services.uteOfflineRouteIdx     = './ute/offline-line-idx';
Services.uteLineRouteIdx        = './ute/line-route-idx';
Services.uteIntervalDivining    = './ute/interval-divining';

/* Сервисы для дашбордов*/
Services.getDashboards          = './api/dashboards/list';
Services.saveDashboard          = './api/dashboards/dashboard';
Services.dashboard              = './api/dashboards/dashboard';

/*Сервисы работы с задачами*/
Services.task              = './api/task';

Services.updateMonoServices = function(){
	if(App && App.config && App.config.APP_60_SERVER){
		Services.processQueryNew = Services.processQueryNew.replace('./', App.config.APP_60_SERVER);
		Services.mapDrawService = Services.mapDrawService.replace('./', App.config.APP_60_SERVER);
		Services.mapInfoService = Services.mapInfoService.replace('./', App.config.APP_60_SERVER);
		Services.mapWmsService = Services.mapWmsService.replace('./', App.config.APP_60_SERVER);
		Services.RunUTETaskService = Services.RunUTETaskService.replace('./', App.config.APP_60_SERVER);
		Services.ImportCP = Services.ImportCP.replace('./', App.config.APP_60_SERVER);
	}
}
//Глобальный объект
ExportUtil = {};

//константы
ExportUtil.GPX = gis_exportutil_1;
ExportUtil.KML = gis_exportutil_2;
ExportUtil.RESULT_TITLE_TEXT = gis_exportutil_3;
ExportUtil.RESULT_GPX_TEXT = gis_exportutil_4;

ExportUtil.RESULT_KML_TEXT = gis_exportutil_5;

ExportUtil.NO_GEO = gis_exportutil_6;
ExportUtil.INCORRECT_GEO = gis_exportutil_7;

ExportUtil.EXPORT_EXCEL_ERROR = gis_exportutil_8;
ExportUtil.EXPORT_EXCEL_EMPTY_DATA_ERROR = gis_exportutil_9;
ExportUtil.EXPORT_WRL_ERROR = gis_exportutil_10;
ExportUtil.EXPORT_IMG_ERROR = gis_exportutil_11;
ExportUtil.PACK_IMG_ERROR = gis_exportutil_12;
ExportUtil.PACK_FILES_AND_DIRS_ERROR = gis_exportutil_13;

/**
 * Общие функции для экспорта
 * */
//Формирование запроса для вызова UTEService
ExportUtil.makeUTETaskServiceDataReqParams = function makeUTETaskServiceDataReqParams(templateName, inputData) {
    return {
        templateName: templateName,
        input: inputData
    };
};
//Формирование запроса для вызова PackIMG
ExportUtil.makePackIMGServiceDataReqParams = function makePackIMGServiceDataReqParams(fileName, imgRelatePath) {
    return {
        outFile: fileName,
        inList: imgRelatePath
    };
};
//Формирование запроса для вызова PackFiles (упаковка файлов и директорий в один архив)
//Пример строки файлов для выгрузки: "LIB\МГ Миннибаево-Казань\Переезды через газопровод.pdf@LIB\МГ Миннибаево-Казань\Приказы на присвоении клейма сварщикам, списки сварщиков.pdf"
ExportUtil.makePackFilesServiceDataReqParams = function makePackFilesServiceDataReqParams(inFilesOrDirs, outFile) {
    return {
        inFilesOrDirs: inFilesOrDirs,
        outFile: outFile
    };
};
//Получение адреса сайта без html-страницы, т.е. 'http://site_address/'
ExportUtil.getCurrentUrl = function getCurrentUrl() {
    var curUrl = getURL(); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (curUrl.lastIndexOf("#") != -1) curUrl = curUrl.substr(0, curUrl.lastIndexOf("#"));
    //Убираем последнюю ссылку на html-страницу, нам нужен путь, оканчивающийся на /
    curUrl = curUrl.substr(0, curUrl.lastIndexOf("/") + 1);
    return curUrl;
};

/**
 * Функции для экспорта в GPX или KML
 * */
ExportUtil.exportFinalObjectsFromXML = function(objs /*XMLList, но тут наверняка будет array*/, type /*String = ExportUtil.GPX*/) {
    if (objs.length > 0){
        // если получили идентификаторы, то выгружаем их
        var gpx = null;
        var kml = null;
        var boundsObj = {};
        boundsObj.minX = Number.POSITIVE_INFINITY;
        boundsObj.minY = Number.POSITIVE_INFINITY;
        boundsObj.maxX = Number.NEGATIVE_INFINITY;
        boundsObj.maxY = Number.NEGATIVE_INFINITY;

        var today = new Date();
        //Формат даты - 'YYYY-MM-DDT00:00:00Z'
        function pad(number) {
            if ( number < 10 ) {
                return '0' + number;
            }
            return number;
        }
        //Получаем собственно время в нужном формате
        //upd06.06.18 решено выставлять дату всегда одну дату 10:00:00
        var time = today.getUTCFullYear() + '-' + pad( today.getUTCMonth() + 1 ) + '-' + pad( today.getUTCDate() )
            + 'T10:00:00'
            /*+ '.' + (today.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5)*/ /*раскомментировать, если нужно уточнение до 'YYYY-MM-DDT00:00:00.000Z'*/
            + 'Z';

        var ii;
        switch(type)
        {
            case ExportUtil.GPX:
            {
                var finalGpx = '<gpx xmlns="http://www.topografix.com/GPX/1/1" creator="MapSource 6.11.6" version="1.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">';
                for (ii = 0; ii < objs.length; ii++)
                {
                    var xmlObj/*:XML*/ = objs[ii];
                    var wktStr = xmlObj.hasOwnProperty('WKT') ? xmlObj.WKT : "";
                    var format = new ol.format.WKT();
                    try{
                        var geom = format.readGeometry(wktStr);
                    }catch (e) {
                        format = new map.format.WKT({dimension: 3});
                        geom = format.readGeometry(wktStr);
                    }
                            /*'POLYGON((10.689697265625 -25.0927734375, 34.595947265625 ' +
                            '-20.1708984375, 38.814697265625 -35.6396484375, 13.502197265625 ' +
                            '-39.1552734375, 10.689697265625 -25.0927734375))');*/
                    if(!gpx) gpx = "";
                        /*gpx = '<gpx xmlns="http://www.topografix.com/GPX/1/1" creator="MapSource 6.11.6" version="1.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">';*/
                    if (geom){
                        var objName = xmlObj.hasOwnProperty('LABEL') ? xmlObj.LABEL : "";
                        var gType = geom.getType();

                        //Пересчитываем общую рамку
                        var curExtent = geom.getExtent(); //[minx, miny, maxx, maxy]
                        if (curExtent && curExtent.length==4) {
                            boundsObj.minX = Math.min(curExtent[0], boundsObj.minX);
                            boundsObj.minY = Math.min(curExtent[1], boundsObj.minY);
                            boundsObj.maxX = Math.max(curExtent[2], boundsObj.maxX);
                            boundsObj.maxY = Math.max(curExtent[3], boundsObj.maxY);
                        }
                        var i,g;
                        switch (gType){
                            // точечный
                            case "Point":
                                gpx += ExportUtil.addPointGPX(geom, objName, time);
                                break;
                            case "MultiPoint":
                                var points = geom.getPoints();
                                for (i = 0; i<points.length; i++) {
                                    g = points[i];
                                    gpx += ExportUtil.addPointGPX(g, objName+"_"+i.toString(), time);
                                }
                                break;
                            // линейный
                            case "LineString":
                                gpx += ExportUtil.addLineGPX(geom, objName, time);
                                break;
                            case "MultiLineString":
                                var lineStrings = geom.getLineStrings();
                                for (i = 0; i<lineStrings.length; i++) {
                                    g = lineStrings[i];
                                    gpx += ExportUtil.addLineGPX(g, objName+"_"+i.toString(), time);
                                }
                                break;
                            case "Polygon":
                            case "MultiPolygon":
                                // площадной
                                var pix = ol.extent.getCenter(geom.getExtent());
                                var pp = new ol.geom.Point(pix);
                                gpx += ExportUtil.addPointGPX(pp, objName, time);
                                break;
                        }
                    }
                    else{
                        App.errorReport(ExportUtil.INCORRECT_GEO, ExportUtil.INCORRECT_GEO, undefined, {filename:gis_filename_594, functionname:'gis_filename_594_1'});
                    }
                }
                var meta = '<metadata><link href="http://www.garmin.com"><text>Garmin International</text></link><time>'+time+'</time>' +
                            '<bounds maxlat="'+boundsObj.maxY+'" maxlon="'+boundsObj.maxX+'" minlat="'+boundsObj.minY+'" minlon="'+boundsObj.minX+'"/></metadata>';
                /*gpx += meta + '</gpx>';
                var finalContext = '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>' + gpx;*/
                finalGpx += meta + gpx + '</gpx>';
                var finalContext = '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>' + finalGpx;
                return finalContext;
            }
            case ExportUtil.KML:
            {
                kml = '<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2" xmlns:kml="http://www.opengis.net/kml/2.2" xmlns:atom="http://www.w3.org/2005/Atom">';
                //FF00008B - dark red для kml файла. Почему-то не RGB формат, а BGR
                var document = '<Document><Style id="lineStyle"><LineStyle><color>FF00008B</color><width>4</width></LineStyle></Style>';
                var addKml = "";
                for (ii = 0; ii < objs.length; ii++){
                    var xmlObj/*:XML*/ = objs[ii];
                    var wktStr = xmlObj.hasOwnProperty('WKT') ? xmlObj.WKT : "";
                    var format = new ol.format.WKT();
                    try{
                        var geom = format.readGeometry(wktStr);
                    }catch (e) {
                        format = new map.format.WKT({dimension: 3});
                        geom = format.readGeometry(wktStr);
                    }
                    if (geom){
                        var objName = xmlObj.hasOwnProperty('LABEL') ? xmlObj.LABEL : "";
                        var gType = geom.getType();
                        var i,g;
                        switch (gType) {
                            // точечный
                            case "Point":
                                document += ExportUtil.addPointKML(geom, objName);
                                break;
                            case "MultiPoint":
                                var points = geom.getPoints();
                                for (i = 0; i<points.length; i++) {
                                    g = points[i];
                                    document += ExportUtil.addPointKML(g, objName+"_"+i.toString());
                                }
                                break;
                            // линейный
                            case "LineString":
                                document += ExportUtil.addLineKML(geom, objName);
                                break;
                            case "MultiLineString":
                                var lineStrings = geom.getLineStrings();
                                for (i = 0; i<lineStrings.length; i++) {
                                    g = lineStrings[i];
                                    document += ExportUtil.addLineKML(g, objName+"_"+i.toString());
                                }
                                break;
                            case "Polygon":
                            case "MultiPolygon":
                                // площадной
                                var pix = ol.extent.getCenter(geom.getExtent());
                                var pp = new ol.geom.Point(pix);
                                document += ExportUtil.addPointKML(pp, objName);
                                break;
                        }
                    }
                    else{
                        App.errorReport(ExportUtil.INCORRECT_GEO, ExportUtil.INCORRECT_GEO, undefined, {filename:gis_filename_594, functionname:'gis_filename_594_2'});
                    }
                }
                //Закрываем тег документа
                kml += document + '</Document>';
                //Добавляем остальные элементы, которые идут в самом kml
                kml += addKml + '</kml>';

                var finalContextKml = '<?xml version="1.0" encoding="UTF-8" ?>' + kml;
                return finalContextKml;
            }
            default: break;
        }
    }
    else
    {
        App.errorReport(ExportUtil.NO_GEO, ExportUtil.NO_GEO, undefined, {filename:gis_filename_594, functionname:'gis_filename_594_3'});
    }
    return "";
};

//Получение строки из XML
ExportUtil.xmlToString = function(xmlData) { // this functions waits jQuery XML
    var xmlString = undefined;

    if (window.ActiveXObject){
        xmlString = xmlData[0].xml;
    }

    if (xmlString === undefined)
    {
        var oSerializer = new XMLSerializer();
        xmlString = oSerializer.serializeToString(xmlData[0]);
    }
    if (xmlString === undefined)
    {
        xmlString = xmlData[0].outerHTML;
        /*var oSerializer = new XMLSerializer();
         xmlString = oSerializer.serializeToString(xmlData[0]);*/
    }
    return xmlString;

    var xmlString = undefined;
    if (window && window.ActiveXObject){
        /*xmlString = xmlData[0].xml;*/
        xmlString = xmlData[0].outerHTML;
    }
    if (xmlString === undefined)
    {
        xmlString = xmlData[0].outerHTML;
        /*var oSerializer = new XMLSerializer();
        xmlString = oSerializer.serializeToString(xmlData[0]);*/
    }
    return xmlString;
};

//Добавление очередной точки в xml для GPX
ExportUtil.addPointGPX = function(geoObj/*ol.Geom.Point*/, name/*:String*/, time/*:String*/, res/*:XML*/, boundsObj/*:Object*/) {
    if (geoObj == null) return "";
    var p = {x:geoObj.flatCoordinates[0], y:geoObj.flatCoordinates[1]};
    if(App.projection === GeoUtil.PROJS.Pulkovo42)
        p = GeoUtil.P42WGS(p["y"], p["x"]);
    var res = '<wpt lat="' + p.y + '" lon="' + p.x + '"><time>' + time + '</time><name>' + name + '</name><sym>Flag, Blue</sym></wpt>';
    return res;
};

//Добавление очередной линии в xml для GPX
ExportUtil.addLineGPX = function(geoObj/*ol.geom.LineString*/, name/*:String*/, time/*:String*/, res/*:XML*/, boundsObj/*:Object*/) {
    if (geoObj == null)
        return "";
    var trk = '<trk><name>' + name + '</name>' +
    '<extensions><gpxx:TrackExtension xmlns:gpxx="http://www.garmin.com/xmlschemas/GpxExtensions/v3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.garmin.com/xmlschemas/GpxExtensions/v3 http://www.garmin.com/xmlschemas/GpxExtensions/v3/GpxExtensionsv3.xsd">' +
    '<gpxx:DisplayColor>DarkRed</gpxx:DisplayColor></gpxx:TrackExtension></extensions>';
    var trkP = '<trkseg>';
    for (var i = 0; i< geoObj.flatCoordinates.length; i+=geoObj.stride)
    {
        var p = {x:geoObj.flatCoordinates[i], y:geoObj.flatCoordinates[i+1]};
        if(App.projection === GeoUtil.PROJS.Pulkovo42)
            p = GeoUtil.P42WGS(p["y"], p["x"]);
        trkP += '<trkpt lat="' + p.y + '" lon="' + p.x + '"><time>' + time + '</time></trkpt>';
    }
    trkP += '</trkseg>';
    trk += trkP + '</trk>';
    return trk;
};

//Добавление очередной точки в xml для KML
ExportUtil.addPointKML = function(geoObj/*ol.Geom.Point*/, name/*:String*/, res/*:XML*/) {
    if (geoObj == null)
        return "";
    //Проекция геоданных из БД
    var dataProjection = App.projection;
    var p = {x:geoObj.flatCoordinates[0], y:geoObj.flatCoordinates[1]};
    if(dataProjection === GeoUtil.PROJS.Pulkovo42){
        p = GeoUtil.P42WGS(p["y"], p["x"]);
    }
    var placemark = '<Placemark><name>' + name + '</name><description>' + name + '</description><Point><coordinates>' + p.x + ',' + p.y + ',0</coordinates></Point></Placemark>';
    return placemark;
};

//Добавление очередной линии в xml для KML
ExportUtil.addLineKML = function(geoObj/*ol.geom.LineString*/, name/*:String*/, res/*:XML*/) {
    if (geoObj == null)
        return "";
    var placemark = '<Placemark><name>' + name + '</name><description>' + name + '</description>';
    var coords = [];
    var lineString = '<LineString><tessellate>1</tessellate>';
    for (var i = 0; i < geoObj.flatCoordinates.length; i+=geoObj.stride)
    {
        var p = {x:geoObj.flatCoordinates[i], y:geoObj.flatCoordinates[i+1]};
        if(App.projection === GeoUtil.PROJS.Pulkovo42)
            p = GeoUtil.P42WGS(p["y"], p["x"]);
        coords.push(p.x);//longitude долгота
        coords.push(p.y);//latitude широта
        coords.push(0);//altitude  высота
    }
    var coordXml = '<coordinates>' + coords.toString() + '</coordinates>';
    lineString += coordXml + '</LineString>';
    var styleXml = '<styleUrl>#lineStyle</styleUrl>';
    placemark += styleXml + lineString + '</Placemark>';
    return placemark;
};

/**
 * Функции для экспорта в Excel
 * */
//Переменная хранит последнее имя генерируемого файла
ExportUtil.exportExcelFileName = "";


/**
 * Экспорт в Excel пикетаза из административной задачи
 * @param dataArray
 * @param fileName
 * @param excelTemplate
 * @param requestSource
 */
ExportUtil.exportAdmPicketingToExcel = function exportFinalXML(dataArray, excelTemplate, requestSource) {
	var alertForm, requestParams;
	if (dataArray !== undefined && dataArray.length>0) {
        /* Групповой экспорт:
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\8135B2A5-1AF8-805E-E727-2D164400319B.xls" template="server_export" data="&lt;root>&#xA;  &lt;data LINE_ID_FILTER=&quot;1300347,1300064,1300066,1300067,1300069,1300348,1300070,1300350,1300071,1300079,1300080,1300029,1300376,1300351,1300032,1300341,1300035,1300081,1300377,1300082,1300084,1300352,1300085,1300086,1300378,1300088,1300089,1300353,1300342,1300092,1300036,1300037,1300094,1300096,1300097,1300098,1300354,1300379,1300099,1300100,1300102,1300104,1300380,1300381,1300382,1300106,1300028,1300107,1300355,1300109,1300111,1300113,1300356,1300115,1300436,1300357,1300117,1300023,1300119,1300384,1300385,1300120,1300386,1300387,1300388,1300063,1300358,1300389,1300359,1300123,1300344,1300360,1300345,1300441,1300125,1300126,1300128,1300439,1300130,1300132,1300134,1300440,1300034,1300031,1300136,1300138,1300390,1300039,1300139,1300361,1300391,1300141,1300033,1300143,1300145,1300392,1300146,1300026,1300393,1300362,1300030,1300147,1300394,1300395,1300363,1300396,1300149,1300397,1300151,1300398,1300153,1300399,1300364,1300365,1300154,1300156,1300400,1300157,1300366,1300402,1300159,1300060,1300061,1300403,1300162,1300404,1300164,1300167,1300169,1300171,1300405,1300172,1300173,1300174,1300175,1300176,1300178,1300406,1300179,1300181,1300183,1300187,1300199,1300221,1300233,1300237,1300059,1300253,1300257,1300261,1300265,1300277,1300279,1300291,1300370,1300293,1300407,1300018,1300019,1300447,1300375,1300408,1300409,1300410,1300411,1300295,1300412,1300413,1300371,1300414,1300297,1300415,1300299,1300416,1300003,1300004,1300005,1300020,1300027,1300300,1300417,1300302,1300303,1300418,1300419,1300420,1300304,1300421,1300422,1300423,1300424,1300425,1300426,1300346,1300305,1300306,1300434,1300435,1300006,1300007,1300427,1300307,1300308,1300309,1300312,1300313,1300314,1300315,1300428,1300316,1300429,1300317,1300318,1300319,1300320,1300321,1300430,1300431,1300322,1300323,1300324,1300373,1300432,1300325,1300000,1300327,1300433,1300329,1300330,1300331,1300332,1300012,1300017,1300013,1300016,1300014,1300015,1300025,1300024,1300334,1300001,1300021,1300002,1300022,1300008,1300011,1300009,1300010,0&quot; ROUTE_TYPE_FILTER=&quot;'ROUTE_TYPE_12','ROUTE_TYPE_10','ROUTE_TYPE_03','ROUTE_TYPE_04','ROUTE_TYPE_11','ROUTE_TYPE_02','ROUTE_TYPE_01','UNKNOWN'&quot; OLD_LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot; FILTER=&quot;8=8 AND ID IN (1301709,1300249)&quot; LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_GRID.XML#PODS_ROUTE"/>
         * */
        /* Экспорт одного объекта
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\B6CC9B4C-A9EF-8378-02B1-2D1A50BB73CF.xls" template="PODS_ROUTE" data="&lt;root>&#xA;  &lt;data LINE_ID=&quot;1300000&quot; OPERATING_STATUS_GCL=&quot;ACTIVE&quot; SRV_DISTRICT_ID=&quot;13006&quot; ID=&quot;1301709&quot; TYPE_LBL=&quot;Магистральный&quot; ROUTE_TYPE_CL=&quot;ROUTE_TYPE_10&quot; mx_internal_uid=&quot;F6052EAE-5832-1190-E3E5-2D159C634C63&quot; SYS_OBJ_ID=&quot;1301709&quot; RWN=&quot;1&quot; DESCRIPTION=&quot;СРТО-Урал&quot; STATION_BEG=&quot;1690&quot; FILTER=&quot;ID=1301709&quot; STATION_END=&quot;1840&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_EXPORT.xml#PODS_ROUTE"/>
         * */
		//генерируем UID для текущей выгрузки
		var currentUID = App.generateUUID();
		var itemXmlEscaped = '&lt;root>';
		for(var i = 0;i < dataArray.length; i++){
			itemXmlEscaped += ExportUtil.Obj2StrXML(dataArray[i], 'data');
		}
		itemXmlEscaped += '&lt;/root>';

		//формируем  шаблон для задачи AA
		var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
		ExportUtil.exportExcelFileName = resFileName;
		//Формируем команду на выполнение сервису
		var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
		if (requestSource=="export") {
			inputData = '<input file_name="'+resFileName+'" template="export" data="'+itemXmlEscaped+'" keep_files="true"/>';
		}
		alertForm = new AlertForm();
		alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
		//Добавляем слушатель закрытия формы
		$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
			$("body").off(CloseEvent.CLOSE);
			if (evt && evt.detail == 1) {
				var processExportForm = new ProcessExportExcelForm();
				processExportForm.inputData = inputData;
				//Собственно создаем форму
				processExportForm.build();
			}
		});
	}
	else{
		App.confirmDialog(ExportUtil.EXPORT_EXCEL_EMPTY_DATA_ERROR);
	}
};

ExportUtil.exportToExcel = function exportFinalXML(dataArray, fileName, excelTemplate, requestSource, topFilter, extendedExport) {
    var alertForm, requestParams;

    if (dataArray && dataArray.length>0) {
        /* Групповой экспорт:
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\8135B2A5-1AF8-805E-E727-2D164400319B.xls" template="server_export" data="&lt;root>&#xA;  &lt;data LINE_ID_FILTER=&quot;1300347,1300064,1300066,1300067,1300069,1300348,1300070,1300350,1300071,1300079,1300080,1300029,1300376,1300351,1300032,1300341,1300035,1300081,1300377,1300082,1300084,1300352,1300085,1300086,1300378,1300088,1300089,1300353,1300342,1300092,1300036,1300037,1300094,1300096,1300097,1300098,1300354,1300379,1300099,1300100,1300102,1300104,1300380,1300381,1300382,1300106,1300028,1300107,1300355,1300109,1300111,1300113,1300356,1300115,1300436,1300357,1300117,1300023,1300119,1300384,1300385,1300120,1300386,1300387,1300388,1300063,1300358,1300389,1300359,1300123,1300344,1300360,1300345,1300441,1300125,1300126,1300128,1300439,1300130,1300132,1300134,1300440,1300034,1300031,1300136,1300138,1300390,1300039,1300139,1300361,1300391,1300141,1300033,1300143,1300145,1300392,1300146,1300026,1300393,1300362,1300030,1300147,1300394,1300395,1300363,1300396,1300149,1300397,1300151,1300398,1300153,1300399,1300364,1300365,1300154,1300156,1300400,1300157,1300366,1300402,1300159,1300060,1300061,1300403,1300162,1300404,1300164,1300167,1300169,1300171,1300405,1300172,1300173,1300174,1300175,1300176,1300178,1300406,1300179,1300181,1300183,1300187,1300199,1300221,1300233,1300237,1300059,1300253,1300257,1300261,1300265,1300277,1300279,1300291,1300370,1300293,1300407,1300018,1300019,1300447,1300375,1300408,1300409,1300410,1300411,1300295,1300412,1300413,1300371,1300414,1300297,1300415,1300299,1300416,1300003,1300004,1300005,1300020,1300027,1300300,1300417,1300302,1300303,1300418,1300419,1300420,1300304,1300421,1300422,1300423,1300424,1300425,1300426,1300346,1300305,1300306,1300434,1300435,1300006,1300007,1300427,1300307,1300308,1300309,1300312,1300313,1300314,1300315,1300428,1300316,1300429,1300317,1300318,1300319,1300320,1300321,1300430,1300431,1300322,1300323,1300324,1300373,1300432,1300325,1300000,1300327,1300433,1300329,1300330,1300331,1300332,1300012,1300017,1300013,1300016,1300014,1300015,1300025,1300024,1300334,1300001,1300021,1300002,1300022,1300008,1300011,1300009,1300010,0&quot; ROUTE_TYPE_FILTER=&quot;'ROUTE_TYPE_12','ROUTE_TYPE_10','ROUTE_TYPE_03','ROUTE_TYPE_04','ROUTE_TYPE_11','ROUTE_TYPE_02','ROUTE_TYPE_01','UNKNOWN'&quot; OLD_LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot; FILTER=&quot;8=8 AND ID IN (1301709,1300249)&quot; LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_GRID.XML#PODS_ROUTE"/>
         * */
        /* Экспорт одного объекта
        * templateName DATA_LAY_Exp.xml
        * input <input template="PODS_ROUTE" ext_data_id="PODS_EXPORT.xml#PODS_ROUTE" data="&lt;root>&#xA;  &lt;data LINE_ID=&quot;1300000&quot; OPERATING_STATUS_GCL=&quot;ACTIVE&quot; SRV_DISTRICT_ID=&quot;13006&quot; ID=&quot;1301709&quot; TYPE_LBL=&quot;Магистральный&quot; ROUTE_TYPE_CL=&quot;ROUTE_TYPE_10&quot; mx_internal_uid=&quot;F6052EAE-5832-1190-E3E5-2D159C634C63&quot; SYS_OBJ_ID=&quot;1301709&quot; RWN=&quot;1&quot; DESCRIPTION=&quot;СРТО-Урал&quot; STATION_BEG=&quot;1690&quot; FILTER=&quot;ID=1301709&quot; STATION_END=&quot;1840&quot;/>&#xA;&lt;/root>" keep_files="true" file_name="Public\Data\TAB\B6CC9B4C-A9EF-8378-02B1-2D1A50BB73CF.xls" />
        * */
        //генерируем UID для текущей выгрузки
        var currentUID = App.generateUUID();
        var itemXmlEscaped = '&lt;root>';
        var filterStr = "ID IN (";
        var propertiesStr = "";
        for (var i = 0; i < dataArray.length; i++) {
            if(!dataArray[i]["ID"] && requestSource !== "export")
                continue;
            filterStr += dataArray[i]["ID"];
            //К последнему ID сзади запятую не добавляем
            if (i < dataArray.length-1) {
                filterStr += ",";
            }
            //Добавляем остальные атрибуты только при экспорте одиночной записи
            if (excelTemplate !== "server_export") {
                if (requestSource === "export") {
                    //Просто выгрузка строки с русским текстом атрибутов
                    $.each(dataArray[i], function (index, value) {
                        var propValEscaped = value.replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/&/g, '&amp;');
                        propertiesStr += index + '=&quot;' + propValEscaped + '&quot; ';
                    });
                } else {
                    $.each(dataArray[i], function (index, value) {
                        var propValEscaped = value.replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/&/g, '&amp;');
                        propertiesStr += index.toUpperCase() + '=&quot;' + propValEscaped + '&quot; ';
                    });
                    //Добавляем особые атрибуты которые хз зачем нужны но без них не работает
                    propertiesStr += 'SYS_OBJ_ID=&quot;' + dataArray[i]["ID"] + '&quot; ';
                    //propertiesStr += 'mx_internal_uid=&quot;4F019BC1-3901-E875-1249-0C5760BB5B9E&quot ';
                }
            }
        }
        filterStr += ")";
        if(filterStr === 'ID IN ()')// если не нашли ни одного ID, то не экспортируем в excel
            return;
        //Если экспортируем один объект - меняем FILTER="ID IN ()" на FILTER="ID=value"
        if (excelTemplate!="server_export" && !extendedExport)
            filterStr = "ID="+dataArray[0]["ID"];
        if (requestSource=="export") {
            itemXmlEscaped += '&lt;data '+propertiesStr+'/>';
        } else {
            if(extendedExport)propertiesStr = '';// если расширенный экспорт, то не передает доп. атрибуты, только выбранные идентификаторы в фильтре
            itemXmlEscaped += '&lt;data FILTER=&quot;'+filterStr+'&quot; '+propertiesStr+'/>'; //атрибут filter обязательно должен быть в верхнем регистре!!!
        }
        itemXmlEscaped += '&lt;/root>';

        //формируем  шаблон для задачи AA
        var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
        ExportUtil.exportExcelFileName = resFileName;
        //Формируем команду на выполнение сервису
        var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
        if (requestSource=="export") {
            inputData = '<input file_name="'+resFileName+'" template="export" data="'+itemXmlEscaped+'" keep_files="true"/>';
        }

        alertForm = new AlertForm();
        alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
        //Добавляем слушатель закрытия формы
        $("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
            $("body").off(CloseEvent.CLOSE);
            if (evt && evt.detail == 1) {
                var processExportForm = new ProcessExportExcelForm();
                processExportForm.inputData = inputData;
                //Собственно создаем форму
                processExportForm.build();
            }
        });


    }
    else{
        if(topFilter !== undefined || extendedExport !== undefined){
            //генерируем UID для текущей выгрузки
            var currentUID = App.generateUUID();
            var item = $('<root></root>');
            var child = ExportUtil.Obj2XML(topFilter, 'data');
            child.appendTo(item);
            var itemStr = ExportUtil.xmlToString(item);
            //переводим атрибуты в верхний регистр, хардкод
            itemStr = itemStr.replace('lpu_access_filter','LPU_ACCESS_FILTER');
            itemStr = itemStr.replace('ili_insp_filter','ILI_INSP_FILTER');
            itemStr = itemStr.replace('route_type_filter','ROUTE_TYPE_FILTER');
            itemStr = itemStr.replace('line_id_filter','LINE_ID_FILTER');

            var itemXmlEscaped = itemStr.xmlEscape();
            //формируем  шаблон для задачи AA
            var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
            ExportUtil.exportExcelFileName = resFileName;
            //Формируем команду на выполнение сервису
            var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
            //Добавляем слушатель закрытия формы
            alertForm = new AlertForm();
            alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
            $("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
                $("body").off(CloseEvent.CLOSE);
                if (evt && evt.detail == 1) {
                    var processExportForm = new ProcessExportExcelForm();
                    processExportForm.inputData = inputData;
                    //Собственно создаем форму
                    processExportForm.build();
                }
            });
        }
    }
};

ExportUtil.exportShurfToExcel = function (dataArray, fileName, excelTemplate, requestSource, topFilter) {
    var alertForm;
    if (dataArray && dataArray.length>0) {
         //генерируем UID для текущей выгрузки
        var currentUID = App.generateUUID();
        var itemXmlEscaped = '&lt;root>';
        var propertiesStr = "";
        var ids = [];
        for (var i = 0; i < dataArray.length; i++) {
            //добавляем только идентификаторы выбранных объектов
            ids.push(dataArray[i]["ID"]);
        }
        propertiesStr += 'SYS_OBJ_ID=&quot;' + ids.join() + '&quot; ';
        itemXmlEscaped += '&lt;data '+propertiesStr+'/>&lt;/root>';

        //формируем  шаблон для задачи AA
        var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
        ExportUtil.exportExcelFileName = resFileName;
        //Формируем команду на выполнение сервису
        var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
        if (requestSource=="export") {
            inputData = '<input file_name="'+resFileName+'" template="export" data="'+itemXmlEscaped+'" keep_files="true"/>';
        }

	    alertForm = new AlertForm();
	    alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
	    //Добавляем слушатель закрытия формы
	    $("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
		    $("body").off(CloseEvent.CLOSE);
		    if (evt && evt.detail == 1) {
			    var processExportForm = new ProcessExportExcelForm();
			    processExportForm.inputData = inputData;
			    //Собственно создаем форму
			    processExportForm.build();
		    }
	    });
    }
};

/**
 * Экспорт в Excel из справочника
 * @param dataArray
 * @param fileName
 * @param excelTemplate
 * @param requestSource
 */
ExportUtil.exportToExcelFromDirectory = function exportFinalXML(dataArray, fileName, excelTemplate, requestSource) {
    var alertForm, requestParams;
    if (dataArray !== undefined && dataArray.length>0) {
        /* Групповой экспорт:
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\8135B2A5-1AF8-805E-E727-2D164400319B.xls" template="server_export" data="&lt;root>&#xA;  &lt;data LINE_ID_FILTER=&quot;1300347,1300064,1300066,1300067,1300069,1300348,1300070,1300350,1300071,1300079,1300080,1300029,1300376,1300351,1300032,1300341,1300035,1300081,1300377,1300082,1300084,1300352,1300085,1300086,1300378,1300088,1300089,1300353,1300342,1300092,1300036,1300037,1300094,1300096,1300097,1300098,1300354,1300379,1300099,1300100,1300102,1300104,1300380,1300381,1300382,1300106,1300028,1300107,1300355,1300109,1300111,1300113,1300356,1300115,1300436,1300357,1300117,1300023,1300119,1300384,1300385,1300120,1300386,1300387,1300388,1300063,1300358,1300389,1300359,1300123,1300344,1300360,1300345,1300441,1300125,1300126,1300128,1300439,1300130,1300132,1300134,1300440,1300034,1300031,1300136,1300138,1300390,1300039,1300139,1300361,1300391,1300141,1300033,1300143,1300145,1300392,1300146,1300026,1300393,1300362,1300030,1300147,1300394,1300395,1300363,1300396,1300149,1300397,1300151,1300398,1300153,1300399,1300364,1300365,1300154,1300156,1300400,1300157,1300366,1300402,1300159,1300060,1300061,1300403,1300162,1300404,1300164,1300167,1300169,1300171,1300405,1300172,1300173,1300174,1300175,1300176,1300178,1300406,1300179,1300181,1300183,1300187,1300199,1300221,1300233,1300237,1300059,1300253,1300257,1300261,1300265,1300277,1300279,1300291,1300370,1300293,1300407,1300018,1300019,1300447,1300375,1300408,1300409,1300410,1300411,1300295,1300412,1300413,1300371,1300414,1300297,1300415,1300299,1300416,1300003,1300004,1300005,1300020,1300027,1300300,1300417,1300302,1300303,1300418,1300419,1300420,1300304,1300421,1300422,1300423,1300424,1300425,1300426,1300346,1300305,1300306,1300434,1300435,1300006,1300007,1300427,1300307,1300308,1300309,1300312,1300313,1300314,1300315,1300428,1300316,1300429,1300317,1300318,1300319,1300320,1300321,1300430,1300431,1300322,1300323,1300324,1300373,1300432,1300325,1300000,1300327,1300433,1300329,1300330,1300331,1300332,1300012,1300017,1300013,1300016,1300014,1300015,1300025,1300024,1300334,1300001,1300021,1300002,1300022,1300008,1300011,1300009,1300010,0&quot; ROUTE_TYPE_FILTER=&quot;'ROUTE_TYPE_12','ROUTE_TYPE_10','ROUTE_TYPE_03','ROUTE_TYPE_04','ROUTE_TYPE_11','ROUTE_TYPE_02','ROUTE_TYPE_01','UNKNOWN'&quot; OLD_LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot; FILTER=&quot;8=8 AND ID IN (1301709,1300249)&quot; LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_GRID.XML#PODS_ROUTE"/>
         * */
        /* Экспорт одного объекта
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\B6CC9B4C-A9EF-8378-02B1-2D1A50BB73CF.xls" template="PODS_ROUTE" data="&lt;root>&#xA;  &lt;data LINE_ID=&quot;1300000&quot; OPERATING_STATUS_GCL=&quot;ACTIVE&quot; SRV_DISTRICT_ID=&quot;13006&quot; ID=&quot;1301709&quot; TYPE_LBL=&quot;Магистральный&quot; ROUTE_TYPE_CL=&quot;ROUTE_TYPE_10&quot; mx_internal_uid=&quot;F6052EAE-5832-1190-E3E5-2D159C634C63&quot; SYS_OBJ_ID=&quot;1301709&quot; RWN=&quot;1&quot; DESCRIPTION=&quot;СРТО-Урал&quot; STATION_BEG=&quot;1690&quot; FILTER=&quot;ID=1301709&quot; STATION_END=&quot;1840&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_EXPORT.xml#PODS_ROUTE"/>
         * */
        //генерируем UID для текущей выгрузки
        var currentUID = App.generateUUID();
        var itemXmlEscaped = '&lt;root>';
        for(var i = 0;i < dataArray.length; i++){
            itemXmlEscaped += ExportUtil.Obj2StrXML(dataArray[i], 'data');
        }
        itemXmlEscaped += '&lt;/root>';

        //формируем  шаблон для задачи AA
        var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
        ExportUtil.exportExcelFileName = resFileName;
        //Формируем команду на выполнение сервису
        var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
        if (requestSource=="export") {
            inputData = '<input file_name="'+resFileName+'" template="export" data="'+itemXmlEscaped+'" keep_files="true"/>';
        }
	    alertForm = new AlertForm();
	    alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
	    //Добавляем слушатель закрытия формы
	    $("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
		    $("body").off(CloseEvent.CLOSE);
		    if (evt && evt.detail == 1) {
			    var processExportForm = new ProcessExportExcelForm();
			    processExportForm.inputData = inputData;
			    //Собственно создаем форму
			    processExportForm.build();
		    }
	    });
    }
    else{
        App.confirmDialog(ExportUtil.EXPORT_EXCEL_EMPTY_DATA_ERROR);
    }
};


ExportUtil.exportToExcelFault = function exportToExcelFault(resultXml) {
    //Снимаем курсор ожидания
    BlockingUtil.ready();
    //BlockingUtil.unblockApplication();
    App.errorReport(ExportUtil.EXPORT_EXCEL_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_5'});
    ExportUtil.exportExcelFileName = "";
};

/**
 * Функции для экспорта в WRL
 * */
//Переменная хранит последнее имя генерируемого файла (уже с расширением .wrz)
ExportUtil.exportWRLFileName = "";

ExportUtil.exportToWRL = function exportToWRL(wrlId, wrlFileName) {
    //Запоминаем имя файла (русскоязычное) для последующего вызова
    ExportUtil.exportWRLFileName = wrlId;//wrlFileName;
    var templateName = "TAB_BLOB_Exp.xml";
    //var inputData = '<item folder_name="Public/Data/VRML" file_id="'+wrlId+'" keep_files="false" table_name="WEB50.LIB_DOC_VERSION" blob_field="BODY" file_name_field="FILE_NAME" id_field="DOC_VERSION_ID"/>';
	var inputData = '<item folder_name="Public/Data/VRML" file_id="'+wrlId+'" keep_files="false" table_name="WEB50.LIB_DOC_VERSION" blob_field="BODY" file_name_field="DOC_ID" id_field="DOC_VERSION_ID"/>';
    var requestParams = ExportUtil.makeUTETaskServiceDataReqParams(templateName, inputData);
    App.serverQueryXMLWithTries(Services.RunUTETaskService, requestParams
        ,ExportUtil.exportToWRLResult
        ,ExportUtil.exportToWRLFault
        ,4
    );
};

ExportUtil.exportToWRLResult = function exportToWRLResult(resultXml) {
    if (!resultXml || resultXml==undefined || resultXml!="<result>1</result>") {
        App.errorReport(ExportUtil.EXPORT_WRL_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_6'});
    } else {
        var curUrl = ExportUtil.getCurrentUrl();
        /* будет такой запрос : /web55/Public/Modules/VRML/Wrl.htm?wrl=http://192.168.3.244/Public/Data/VRML/FILE_NAME.wrz */
        var fileUrl = curUrl + 'Public/Modules/VRML/Wrl.htm?wrl=' + curUrl + 'Public/Data/VRML/' + ExportUtil.exportWRLFileName;
        //Предоставляем пользователю ссылку на этот файл
        var win = window.open(fileUrl, '_blank');
        win.focus();
    }
    ExportUtil.exportWRLFileName = "";
};

ExportUtil.exportToWRLFault = function exportToWRLFault(resultXml) {
    App.errorReport(ExportUtil.EXPORT_WRL_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_7'});
    ExportUtil.exportWRLFileName = "";
};

/**
 * Функции для экспорта в IMG
 * */
//Переменная хранит последнее имя генерируемого файла (уже с расширением .img)
ExportUtil.exportIMGFileName = "";

ExportUtil.exportToIMG = function exportToIMG(imgId, imgFileName) {
    //Запоминаем имя файла (русскоязычное) для последующего вызова
    ExportUtil.exportIMGFileName = imgFileName;
    var templateName = "TAB_BLOB_Exp.xml";
    var inputData = '<item folder_name="Public/Data/IMG" file_id="'+imgId+'" keep_files="false" table_name="WEB50.LIB_DOC_VERSION" blob_field="BODY" file_name_field="FILE_NAME" id_field="DOC_VERSION_ID"/>';
    var requestParams = ExportUtil.makeUTETaskServiceDataReqParams(templateName, inputData);
    App.serverQueryXMLWithTries(Services.
            RunUTETaskService, requestParams
        ,ExportUtil.exportToIMGResult
        ,ExportUtil.exportToIMGFault
        ,4
    );
};

ExportUtil.exportToIMGResult = function exportToIMGResult(resultXml) {
    if (!resultXml) {
        App.errorReport(ExportUtil.PACK_IMG_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_10'});
    } else {
        var realtivePath = 'Public/Data/IMG/'+ExportUtil.exportIMGFileName;
        var curUrl = ExportUtil.getCurrentUrl();
        /* будет такой запрос : /Public/Data/Temp/IMG/{file_name}.img  */
        var fileUrl = curUrl + realtivePath;
        //Предоставляем пользователю ссылку на этот файл
        var win = window.open(fileUrl, '_blank');
        win.focus();
    }
    ExportUtil.exportIMGFileName = "";
};

ExportUtil.exportToIMGFault = function exportToIMGFault(resultXml) {
    App.errorReport(ExportUtil.EXPORT_IMG_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_9'});
    ExportUtil.exportIMGFileName = "";
};


/* Вспомогательные функции */

ExportUtil.Obj2XML = function(obj, name){
    var item = $('<' + name + '/>');
    for(var prop in obj){
        item.attr(prop.toUpperCase(),obj[prop]);
        //item[0].setAttribute(prop.toUpperCase(),obj[prop]);
    }
    return item;
};

ExportUtil.Obj2StrXML = function(obj, name){
    var item = '&lt;' + name ;
    for(var prop in obj){
        item += ' '+prop+'=&quot;'+obj[prop]+'&quot; ';
    }
    item += ' />';
    return item;
};
//Глобальный объект
ImportUtil = {};
var IMPORT_UTIL_FORM_DIALOG_TRACK_DESCR = gis_importutil_3;
var IMPORT_UTIL_FORM_DIALOG_TRACK_TITLE = gis_importutil_4;
var IMPORT_UTIL_FORM_DIALOG_POINT_DESCR = gis_importutil_5;
var IMPORT_UTIL_FORM_DIALOG_POINT_TITLE = gis_importutil_6;

ImportUtil.buttons = {
    ok              :gis_core_4,
    cancel          :gis_core_6
};


ImportUtil.importPOIPointTrack = function (type) {
    var that = this;
    var descr = (type === 'point')?IMPORT_UTIL_FORM_DIALOG_POINT_DESCR:IMPORT_UTIL_FORM_DIALOG_TRACK_DESCR;
    var title = (type === 'point')?IMPORT_UTIL_FORM_DIALOG_POINT_TITLE:IMPORT_UTIL_FORM_DIALOG_TRACK_TITLE;
    var size = (type === 'point')?250:195;
    $('#importPOIPointTrackDiv').remove();
    $('body').append('<div id="importPOIPointTrackDiv" class="importPOIPointTrack" >'+descr+'</div>');
    var dlg = $('#importPOIPointTrackDiv');
    // Готовим кнопки, и добавляем обработчики
    var buttons = [];
    $.each(that.buttons, function(name, text){
        buttons.push({
            text: text,
            click: function(){
                var funcName = name+type+'Action';
                if(that[funcName]) {
                    that[funcName].apply(that);
                }
            }
        });
    });
    dlg.dialog({
        dialogClass: 'noCloseButton importPOIPointTrackDiv gsi-zindex__dialog',
        closeOnEscape: false,
        resizable: false,
        modal:     true,
        width:     size,
        height: 120,
        buttons: buttons,
        title: title
    });
};


ImportUtil.processImport = function(type){
    //Название серверной задачи, выполняющей экспорт в Excel
    var templateName = (type === 'point')?"POI_PNT_Imp.xml":'POI_TRK_Imp.xml';
    var resultFunc = (type === 'point')?ImportUtil.importPOIPointResult:ImportUtil.importPOITrackResult;
    GridAdmInternal.importPOI({
        templateName: templateName,
        type:type,
        onResult:resultFunc,
        onFault:ImportUtil.importPOIPointFault
    })
};


//Формирование запроса для вызова UTEService
ImportUtil.makeUTETaskServiceDataReqParams = function makeUTETaskServiceDataReqParams(templateName, inputData) {
    return {
        templateName: templateName,
        input: inputData
    };
};

ImportUtil.importPOITrackResult = function (result) {
    BlockingUtil.ready();
    var er = HTTPServiceUtil.getError(result);
    if (er === "") {
        var jsonRes;
        try{
            jsonRes = JSON.parse(result);
        }
        catch(ex){
            App.errorReport(gis_importutil_12, ex.message, undefined, {filename:gis_filename_612, functionname:'gis_filename_612_1'});
            return;
        }
        if(jsonRes && jsonRes.status === 200 && jsonRes.records > 0){
            if(WidgetMap.layerManager){
                var layer = WidgetMap.layerManager.getLayerByName('WEB50_POI_TRACK');
                if(layer && layer.layer){
                    //чистим слой
                    layer.layer.clear();
                    layer.layer.dataReady_ = false;
                    //перезапрашиваем данные для слоя
                    layer.layer.canLoadData = true;
                    layer.layer.canFirstTimeCentering = false;
                    layer.layer.loadData();
                }
            }
            App.confirmDialog(gis_importutil_10 + jsonRes.records + gis_importutil_11,null,{width:310,dialogClass: 'noCloseButton',closeOnEscape: false});
            return;
        }
    }
    App.confirmDialog(gis_importutil_12,null,{width:186,dialogClass: 'noCloseButton',closeOnEscape: false});
};

ImportUtil.importPOIPointResult = function (result) {
    BlockingUtil.ready();
    var er = HTTPServiceUtil.getError(result);
    if (er === "") {
        var jsonRes;
        try{
            jsonRes = JSON.parse(result);
        }
        catch(ex){
            App.errorReport(gis_importutil_14, ex.message, undefined, {filename:gis_filename_612, functionname:'gis_filename_612_1'});
            return;
        }

        if (jsonRes && jsonRes.status === 200 && jsonRes.records > 0) {
            if(WidgetMap.layerManager){
                var layer = WidgetMap.layerManager.getLayerByName('WEB50_POI_POINT');
                if(layer && layer.layer){
                    //чистим слой
                    layer.layer.clear();
                    layer.layer.dataReady_ = false;
                    //перезапрашиваем данные для слоя
                    layer.layer.canLoadData = true;
                    layer.layer.canFirstTimeCentering = false;
                    layer.layer.loadData();
                }
            }
            App.confirmDialog(gis_importutil_13 + jsonRes.records + gis_importutil_11,null,{width:310,dialogClass: 'noCloseButton',closeOnEscape: false});
            return;
        }
    }
    App.confirmDialog(gis_importutil_14,null,{width:186,dialogClass: 'noCloseButton',closeOnEscape: false});
};

ImportUtil.importPOIPointFault = function(resultXml) {
    BlockingUtil.ready();
    App.errorReport(gis_importutil_7, resultXml.toString(), undefined, {filename:gis_filename_612, functionname:'gis_filename_612_1'});
};


ImportUtil.okpointAction = function() {
    $('#importPOIPointTrackDiv').remove();
    $('#baseFileDivTrack').remove();
    var uploadPath = Auth.getUid();
    function importFile() {
        //Проверяем, что поле выбранного файла не пустое
        if($("#myElement").val() == '')
            return;
        var form = $('#fr_myElement');
        form.attr('action',form.data('action'));//.submit();
        form.submit();
    }

    function cancel() {
        dlg.dialog('destroy').remove();
    }
    var element = $('<div id="baseFileDivTrack" style="display: block;height: 46px !important;">\
                        <div class="importPointTrackLabel">Нажмите кнопку (...) для выбора файла</div>\
                        <div id="divFI_myElement" class="divFileInput importPointTrackFileInput">\
                        <div class="divFileInputNameTree"><input id="myElement" type="text" disabled value="" data-typecontrol="inputfile" class="formControl importPointTrackFileInputName" data-loadvalue=true /></div>\
                        <form method="POST" id="fr_myElement" action="" data-action="./api/files/upload?path=UploadedFiles/'+
        uploadPath+'" enctype="multipart/form-data" class="frmInputFile" target="ifr_myElement">\
                         <input id="iFI_myElement" type="file" class="iFileInput" style="width:20px" data-typecontrol="file" data-filename="" class="iFileInput" accept=".gpx" name="fileinput" />\
                        </form>\
                        <iframe id="ifr_myElement" name="ifr_myElement" class="noVisible" data-checkload=false></iframe>\
                       </div>\
                        </div>');
    $('body').append(element);

    var buttons = [];
    buttons.push({text:gis_importutil_8, click:importFile, id:'iFI_import'});
    buttons.push({text:gis_core_6, click:cancel});
    var dlg = $(element).dialog({
        title: gis_importutil_9,
        width: 340,
        height: 120,
        dialogClass: 'gsi-zindex__dialog',
        resizable: false,
        modal: true,
        buttons:buttons
    });
    $('#ifr_myElement').load(function(){
        if($("#myElement").val() == ''){
            return;
        }
        $("#myElement").val('');
        ImportUtil.processImport('point');
        dlg.dialog('destroy').remove();
    });
    $('#iFI_myElement').change(function(){
        var fileName = $("#iFI_myElement").val().split('\\');
        if(fileName.length != 1)fileName = fileName[fileName.length-1].split('.');
        else fileName = fileName[0].split('.');
        fileName = fileName.join('.');
        $("#myElement").val(fileName);
        $("#iFI_import").prop('disabled', false);
    });
    $("#iFI_import").prop('disabled', true);
};

ImportUtil.okpointAction_old = function() {
    $('#importPOIPointTrackDiv').remove();
    $('#importPointTrackInput').remove();
    $('body').append('<input type="file" id="importPointTrackInput" accept=".gpx" style="visibility: hidden;position: absolute;top: 1px;" />');
    $('#importPointTrackInput').change(function(){
        ImportUtil.processImport($(this).prop("files")[0],'point');
    });
    $('#importPointTrackInput').click();
};

ImportUtil.cancelpointAction = function() {
    $('#importPOIPointTrackDiv').remove();
    $('#baseFileDivPoint').remove();
};


ImportUtil.oktrackAction = function() {
    $('#importPOIPointTrackDiv').remove();
    $('#baseFileDivTrack').remove();
    var uploadPath = Auth.getUid();
    function importFile() {
        //Проверяем, что поле выбранного файла не пустое
        if($("#myElement").val() == '')
            return;
        var form = $('#fr_myElement');
        form.attr('action',form.data('action'));//.submit();
        form.submit();
    }

    function cancel() {
        dlg.dialog('destroy').remove();
    }
    var element = $('<div id="baseFileDivTrack" style="display: block; height: 46px !important;">\
                        <div class="importPointTrackLabel">Нажмите кнопку (...) для выбора файла</div>\
                        <div id="divFI_myElement" class="divFileInput importPointTrackFileInput" >\
                        <div class="divFileInputNameTree"><input id="myElement" type="text" disabled value="" data-typecontrol="inputfile" class="formControl importPointTrackFileInputName" data-loadvalue=true /></div>\
                        <form method="POST" id="fr_myElement" action="" data-action="./api/files/upload?path=UploadedFiles/'+
        uploadPath+'" enctype="multipart/form-data" class="frmInputFile" target="ifr_myElement">\
                         <input id="iFI_myElement" type="file" class="iFileInput" style="width:20px" data-typecontrol="file" data-filename="" class="iFileInput" accept=".gpx" name="fileinput" />\
                        </form>\
                        <iframe id="ifr_myElement" name="ifr_myElement" class="noVisible" data-checkload=false></iframe>\
                       </div>\
                        </div>');
    $('body').append(element);

    var buttons = [];
    buttons.push({text:gis_importutil_8, click:importFile, id:'iFI_import'});
    buttons.push({text:gis_core_6, click:cancel});
    var dlg = $(element).dialog({
        //dialogClass: "jqx-tabs-content-myCommon pPanelModalForm-no-close",
        title: gis_importutil_9,
        width: 340,
        height: 120,
        dialogClass: 'gsi-zindex__dialog',
        resizable: false,
        modal: true,
        buttons:buttons
    });
    $('#ifr_myElement').load(function(){
        if($("#myElement").val() == ''){
            return;
        }
        $("#myElement").val('');
        ImportUtil.processImport('track');
        dlg.dialog('destroy').remove();
    });
    $('#iFI_myElement').change(function(){
        var fileName = $("#iFI_myElement").val().split('\\');
        if(fileName.length != 1)fileName = fileName[fileName.length-1].split('.');
        else fileName = fileName[0].split('.');
        fileName = fileName.join('.');
        $("#myElement").val(fileName);
        $("#iFI_import").prop('disabled', false);
    });

    $("#iFI_import").prop('disabled', true);
};

ImportUtil.oktrackAction_old = function() {
    $('#importPOIPointTrackDiv').remove();
    $('body').append('<input type="file" id="importPointTrackInput" accept=".gpx" style="visibility: hidden;position: absolute;top: 1px;" />');

    $('#importPointTrackInput').change(function(event){
        ImportUtil.processImport($(this).prop("files")[0],'track');
    });
    $('#importPointTrackInput').click();
};

ImportUtil.canceltrackAction = function() {
    $('#importPOIPointTrackDiv').remove();
    $('#baseFileDivTrack').remove();
};

//Глобальный объект
GeoUtil = {};
//константы проекций
GeoUtil.PROJS = {
	'EPSG:4284':'EPSG:4284',//Пулково84
	'Pulkovo42':'EPSG:4284',//Пулково84
	'EPSG:4326':'EPSG:4326',//WGS 84
	'WGS84':'EPSG:4326',//WGS 84
	'EPSG:900913':'EPSG:900913',//Google Mercator
	'GoogleMercator':'EPSG:900913',//Google Mercator
	'EPSG:3857':'EPSG:3857',//Google Mercator
	'EPSG:3395':'EPSG:3395',//Проекция Яндекса
	'EPSG:5807':'EPSG:5807'//Проекция тех схемы и пка
};
//Функции
GeoUtil.P42WGS = function(y, x, h1) {
	if (h1===undefined || h1===null) h1 = 0;
	// y - широта
	// x - долгота
	y = y*Math.PI/180;
	x = x*Math.PI/180;

	//Параметры эллипсоида CK-42
	var a1=6378245;
	var e1=0.0066934216;

	//Параметры эллипсоида WGS
	var a2=6378137;
	var e2=0.00669438;
	var N1=a1/Math.sqrt(1-e1*Math.pow(Math.sin(y),2));

	//Геоцентрические прямоугольные координаты в CK-42
	var x1=(N1+h1)*Math.cos(y)*Math.cos(x);
	var y1=(N1+h1)*Math.cos(y)*Math.sin(x);
	var z1=((1-e1)*N1+h1)*Math.sin(y);
	var coeff = 1-0.12E-6;

	//Геоцентрические прямоугольные координаты в WGS
	var x2=coeff*(x1-4.363321062E-6*y1+1.939259378E-6*z1)+26.3;
	var y2=coeff*(4.36332313E-6*x1+y1-1.066581637E-6*z1)-132.6;
	var z2=coeff*(-1.939254724E-6*x1+1.066590098E-6*y1+z1)-76.3;

	var l2=Math.atan(y2/x2);
	if (x2<0)
	{
		if (y2<0)
		{
			l2-=Math.PI;
		}
		else
		{
			l2+= Math.PI;
		}
	}
	var b2=y;

	var N2 = 0;

	for(var i=0; i<3; i++)
	{
		N2=a2/Math.sqrt(1-e2*Math.pow(Math.sin(b2),2));
		b2 = Math.atan((z2+e2*N2*Math.sin(b2))/Math.sqrt(x2*x2+y2*y2));
	}

	var h2=x2/Math.cos(l2)/Math.cos(b2)-N2;
	b2 = b2*180/Math.PI;
	l2 = l2*180/Math.PI;
	//Объект-точка
	return {x:l2, y:b2};
};

GeoUtil.WGSP42 = function(y, x, h1) {
	if (h1===undefined || h1===null) h1 = 0;
	// y - широта
	// x - долгота
	y = y*Math.PI/180;
	x = x*Math.PI/180;

	//Параметры эллипсоида WGS
	var a1=6378137;
	var e1=0.00669438;

	//Параметры эллипсоида CK-42
	var a2=6378245;
	var e2=0.0066934216;
	var N1=a1/Math.sqrt(1-e1*Math.pow(Math.sin(y),2));

	//Геоцентрические прямоугольные координаты в WGS
	var x1=(N1+h1)*Math.cos(y)*Math.cos(x);
	var y1=(N1+h1)*Math.cos(y)*Math.sin(x);
	var z1=((1-e1)*N1+h1)*Math.sin(y);
	var coeff = 1-0.12E-6;

	//Геоцентрические прямоугольные координаты в CK-42
	/*
	 var x2=coeff*(x1+3.849423968E-6*y1-2.3755816253E-6*z1)-26.3;
	 var y2=coeff*(-3.849420628E-6*x1+y1+1.4059688198E-6*z1)+132.6;
	 var z2=coeff*(2.3755870374E-6*x1-1.4059596752E-6*y1+z1)+76.3;
	 */
	var x2=coeff*(x1+4.363321062E-6*y1-1.939259378E-6*z1)-26.3;
	var y2=coeff*(-4.36332313E-6*x1+y1+1.066581637E-6*z1)+132.6;
	var z2=coeff*(1.939254724E-6*x1-1.066590098E-6*y1+z1)+76.3;
	var l2=Math.atan(y2/x2);
	if (x2<0)
	{
		if (y2<0)
		{
			l2-=Math.PI;
		}
		else
		{
			l2+= Math.PI;
		}
	}
	var b2=y;
	var N2 = 0;
	for(var i=0; i<3; i++)
	{
		N2=a2/Math.sqrt(1-e2*Math.pow(Math.sin(b2),2));
		b2 = Math.atan((z2+e2*N2*Math.sin(b2))/Math.sqrt(x2*x2+y2*y2));
	}

	var h2=x2/Math.cos(l2)/Math.cos(b2)-N2;
	b2 = b2*180/Math.PI;
	l2 = l2*180/Math.PI;
	//Объект-точка
	return {x:l2, y:b2};
};

//Прямоугольник из пулково в WGS
GeoUtil.RectP42WGS = function(data) {
	if (data != null)
	{
		var topA = GeoUtil.P42WGS(data.top, data.right);
		var btmA = GeoUtil.P42WGS(data.bottom, data.left);
		var r = {};
		r.top = topA.y;
		r.left = btmA.x;
		r.bottom = btmA.y;
		r.right = topA.x;
		return r;
	}
	return null;
};

//Прямоугольник из WGS в пулково
GeoUtil.RectWGSP42 = function(data) {
	if (data != null)
	{
		var topA = GeoUtil.WGSP42(data.top, data.right);
		var btmA = GeoUtil.WGSP42(data.bottom, data.left);
		var r = {};
		r.top = topA.y;
		r.left = btmA.x;
		r.bottom = btmA.y;
		r.right = topA.x;
		return r;
	}
	return null;
};


/**
 * Конвертация дополнительных слоёв на карте(слой выделения, слой рисования, буферный,..)
 * @param vectorLayers
 * @param source
 * @param dest
 */
GeoUtil.convertAdditionalGeometryFromToDefault = function(vectorLayers,source,dest){
	if(source === GeoUtil.PROJS['EPSG:900913'])
		source = GeoUtil.PROJS['EPSG:3857'];
	if(dest === GeoUtil.PROJS['EPSG:900913'])
		dest = GeoUtil.PROJS['EPSG:3857'];
	if(source === dest)return;
	var i = 0;
	for(;i<vectorLayers.length;i++){
		var layer = vectorLayers[i];
		if(goog.isDef(layer)){
			var layerSource = layer.getSource();
			var features = layerSource.getFeatures();
			var j = 0;
			for(;j<features.length;j++){
				var featureGeometry = features[j].getGeometry();
				GeoUtil.convertGeometry(featureGeometry,source,dest);
			}
			if(features.length>0)
				layer.changed();
		}
	}
};

/**
 * Конвертация проекции при смене режима карты
 * @param source
 * @param dest
 */
GeoUtil.convertGeometryFromToDefault = function(vectorLayers,source,dest){
	if(source === GeoUtil.PROJS['EPSG:900913'])
		source = GeoUtil.PROJS['EPSG:3857'];
	if(dest === GeoUtil.PROJS['EPSG:900913'])
		dest = GeoUtil.PROJS['EPSG:3857'];
	if(source === dest)return;
	if(vectorLayers.length > 0){
		var i = 0;
		for(;i<vectorLayers.length;i++){
			var layer = vectorLayers[i];
			if(goog.isDef(layer.layer) && goog.isDef(layer.layer.featureProjLayer)){
				var layerSource = layer.layer.featureProjLayer.getSource().getSource();
				var features = layerSource.getFeatures();
				var j = 0;
				for(;j<features.length;j++){
					var feature = features[j];
					var labelsObjAll = feature.get('labelsObjAll');
					var k = 0;
					try {
						for (; k < labelsObjAll.length; k++) {
							var geo = labelsObjAll[k].geo;
							GeoUtil.convertGeometry(geo, source, dest);
						}
					}
					catch(ex){
					}
					var featureGeometry = feature.getGeometry();
					GeoUtil.convertGeometry(featureGeometry,source,dest);
				}
				if(features.length>0)
					layer.layer.featureProjLayer.changed();
			}
		}
	}
};

/**
 * Конвертирует массив координат для линии
 * @param coords массив координат  of Array.<ol.Coordinate>
 * @param source По умолчанию pulkovo42
 * @param dest По умолчанию pulkovo42
 * @returns {Array}
 */
GeoUtil.convertCoords1 = function(coords, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	var source_ =  new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
	var dest_= new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
	var pnt;
	var j = 0;
	for (j; j < coords.length; j ++) {
		pnt = new proj4.toPoint(coords[j]);
		if((source === GeoUtil.PROJS.Pulkovo42)){
			var p42WgsPnt = GeoUtil.P42WGS( pnt.y, pnt.x);
			pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
		}
		proj4.transform(source_, dest_, pnt);
		if(isNaN(pnt.x) || isNaN(pnt.y))
			continue;
		if((dest === GeoUtil.PROJS.Pulkovo42)){
			var pWgsP42Pnt = GeoUtil.WGSP42( pnt.y, pnt.x);
			pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
		}
		coords[j] = [pnt.x, pnt.y];
	}
	return coords;
};

/**
 * Конвертирует массив координат для полигона
 * @param coords массив координат  of Array.<ol.Coordinate>
 * @param source По умолчанию pulkovo42
 * @param dest По умолчанию pulkovo42
 * @returns {Array}
 */
GeoUtil.convertCoords2 = function(coords, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	var source_ =  new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
	var dest_= new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
	var pnt;
	var j = 0, i = 0;
	for (i; i < coords.length; i++) {
		for (j; j < coords[i].length; j ++) {
			pnt = new proj4.toPoint(coords[i][j]);
			if((source === GeoUtil.PROJS.Pulkovo42)){
				var p42WgsPnt = GeoUtil.P42WGS( pnt.y, pnt.x);
				pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
			}
			proj4.transform(source_, dest_, pnt);
			if(isNaN(pnt.x) || isNaN(pnt.y))
				continue;
			if((dest === GeoUtil.PROJS.Pulkovo42)){
				var pWgsP42Pnt = GeoUtil.WGSP42( pnt.y, pnt.x);
				pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
			}
			coords[i][j] = [pnt.x, pnt.y];
		}
	}
	return coords;
};
/**
 * Конвертирует массив координат
 * @param coords массив координат  of Array.<ol.Coordinate>
 * @param source По умолчанию pulkovo42
 * @param dest По умолчанию pulkovo42
 * @returns {Array}
 */
GeoUtil.convertCoords = function(coords, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	var newCoords  = [];//of Array.<ol.Coordinate>
	var stride = 2;
	goog.asserts.assert(coords.length % stride === 0);
	var source_ =  new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
	var dest_= new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
	var pnt;
	var j = 0;
	for (j; j < coords.length; j += stride) {
		pnt = new proj4.toPoint([coords[j], coords[j+1]]);
		if((source === GeoUtil.PROJS.Pulkovo42)){
			var p42WgsPnt = GeoUtil.P42WGS( pnt.y, pnt.x);
			pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
		}
		proj4.transform(source_, dest_, pnt);
		if(isNaN(pnt.x) || isNaN(pnt.y))
			continue;
		if((dest === GeoUtil.PROJS.Pulkovo42)){
			var pWgsP42Pnt = GeoUtil.WGSP42( pnt.y, pnt.x);
			pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
		}
		newCoords.push(pnt.x);
		newCoords.push(pnt.y);
	}
	return newCoords;
};

/**
 * Конвертация геометрии
 * @param geometryCollection
 * @param source по умолчанию pulkovo42
 * @param dest по умолчанию google mercator 900913
 */
GeoUtil.convertGeometry = function(geometryCollection, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	if(geometryCollection instanceof ol.geom.GeometryCollection){
		var geoArr = geometryCollection.getGeometriesArray();
		for(var i=0; i<geoArr.length;i++){
			GeoUtil.convertGeometry(geoArr[i], source, dest);
		}
	}
	else{
		var geometry = geometryCollection;
		if(geometry !== undefined){
			var coords = geometry.flatCoordinates;
			var newCoords  = [];//of Array.<ol.Coordinate>
			var stride = geometry.stride;
			var source_ = new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
			var dest_ =  new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
			goog.asserts.assert(coords.length % stride === 0);
			var pnt;
			var j;
			for ( j = 0; j < coords.length; j += stride) {
				//с двойной трансформацей отлет 2 метра пропадает
				pnt= new proj4.toPoint([coords[j], coords[j+1]]);
				if((source === GeoUtil.PROJS.Pulkovo42)){
					var p42WgsPnt = GeoUtil.P42WGS( coords[j+1], coords[j]);
					pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
				}
				proj4.transform(source_, dest_, pnt);
				if((dest === GeoUtil.PROJS.Pulkovo42)){
					var pWgsP42Pnt = GeoUtil.WGSP42( coords[j+1], coords[j]);
					pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
				}
				if(isNaN(pnt.x) || isNaN(pnt.y))
					continue;
				newCoords.push(pnt.x);
				newCoords.push(pnt.y);
				if(stride === 3)
					newCoords.push(coords[j+2]);
			}
			if(geometry.getType() === ol.geom.GeometryType.POLYGON || geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
				geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
			else if(geometry.getType() === ol.geom.GeometryType.MULTI_POLYGON)
				geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
			else
				geometry.setFlatCoordinates(geometry.layout,newCoords);
		}
	}
};

/**
 * Функция перевода спец проекции в базовую.
 * Вынесена отдельно, чтобы наглядно было видно, что спец проекция в месте вызова
 * @param feature
 * @param sourceZone
 * @param destZone
 */
GeoUtil.convertFeature326NN = function (feature, sourceZone, destZone) {
	if (!goog.isDef(sourceZone))sourceZone = 'EPSG:32639';
	if (!goog.isDef(destZone))destZone = 'EPSG:32639';

	GeoUtil.convertFeature(feature, sourceZone, destZone);
};

/**
 * Конвертация фичи
 * TODO, стоит в дальшейшем объекдинить с GeoUtil.convertGeometry
 * @param feature
 * @param source
 * @param dest
 */
GeoUtil.convertFeature = function(feature, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	var geometry = feature.getGeometry();
	if(geometry !== undefined){
		var coords = geometry.flatCoordinates;
		var newCoords  = [];//of Array.<ol.Coordinate>
		var stride = geometry.stride;
		var source_ = new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
		var dest_ =  new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
		goog.asserts.assert(coords.length % stride === 0);
		var pnt;
		var j = 0;
		for (j; j < coords.length; j += stride) {
			pnt= new proj4.toPoint([coords[j], coords[j+1]]);
			if((source === GeoUtil.PROJS.Pulkovo42)){
				var p42WgsPnt = GeoUtil.P42WGS( pnt.y, pnt.x);
				pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
			}
			proj4.transform(source_, dest_, pnt);
			if((dest === GeoUtil.PROJS.Pulkovo42)){
				var pWgsP42Pnt = GeoUtil.WGSP42( pnt.y, pnt.x);
				pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
			}
			if(isNaN(pnt.x) || isNaN(pnt.y))
				continue;
			newCoords.push(pnt.x);
			newCoords.push(pnt.y);
			if(stride === 3)
				newCoords.push(coords[j+2]);
		}
		if(feature.getGeometry().getType() === ol.geom.GeometryType.POLYGON || feature.getGeometry().getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
			feature.getGeometry().setFlatCoordinates(geometry.layout,newCoords,feature.getGeometry().getEnds());
		else if(feature.getGeometry().getType() === ol.geom.GeometryType.MULTI_POLYGON)
			feature.getGeometry().setFlatCoordinates(geometry.layout,newCoords,feature.getGeometry().getEndss());
		else
			feature.getGeometry().setFlatCoordinates(geometry.layout,newCoords);
	}
};

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */
GeoUtil.forEach = function(flatCoordinates, offset, end, stride, callback, opt_this) {
	var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
	var point2 = [];
	var ret;
	for (; (offset + stride) < end; offset += stride) {
		point2[0] = flatCoordinates[offset + stride];
		point2[1] = flatCoordinates[offset + stride + 1];
		ret = callback.call(opt_this, point1, point2);
		if (ret) {
			return ret;
		}
		point1[0] = point2[0];
		point1[1] = point2[1];
	}
	return false;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
GeoUtil.lineString = function(flatCoordinates, offset, end, stride, extent, geoExtent) {
	//убрана проверка координат, т.к. extent уже есть в сохраненной геометрии фичи
	var coordinatesExtent = (geoExtent) ? geoExtent : ol.extent.extendFlatCoordinates(
		ol.extent.createEmpty(), flatCoordinates, offset, end, stride);
	if (!ol.extent.intersects(extent, coordinatesExtent)) {
		return false;
	}
	if (ol.extent.containsExtent(extent, coordinatesExtent)) {
		return true;
	}
	if (coordinatesExtent[0] >= extent[0] &&
		coordinatesExtent[2] <= extent[2]) {
		return true;
	}
	if (coordinatesExtent[1] >= extent[1] &&
		coordinatesExtent[3] <= extent[3]) {
		return true;
	}
	return GeoUtil.forEach(flatCoordinates, offset, end, stride,
		/**
		 * @param {ol.Coordinate} point1 Start point.
		 * @param {ol.Coordinate} point2 End point.
		 * @return {boolean} `true` if the segment and the extent intersect,
		 *     `false` otherwise.
		 */
		function(point1, point2) {
			return ol.extent.intersectsSegment(extent, point1, point2);
		});
};

/**
 *
 * @param feature
 * @param extent
 * @returns {[]|*[]}
 */
GeoUtil.getIntersectedGeometry = function(feature, extent, excudeGeoTypes){
	var result = [];
	var geometry = feature.getGeometry();
	goog.asserts.assert(goog.isDefAndNotNull(geometry),
		'feature geometry is defined and not null');
	if(!goog.isDef(feature.get('labelType')))
		return [];
	if(excudeGeoTypes && excudeGeoTypes.length > 0){
		if(excudeGeoTypes.indexOf(geometry.getType()) !== -1)
			return [];
	}
	switch(geometry.getType()){
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			var i, ii;
			var ends = geometry.ends_;
			var offset = 0;
			for (i = 0, ii = ends.length; i < ii; ++i) {
				if (ol.geom.flat.intersectsextent.lineString(
					geometry.flatCoordinates, offset, ends[i], geometry.stride, extent)) {
					if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
						var obj =  jQuery.extend({}, globalLinesLabels_[feature.get('labelType')][i]);
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getLineString(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его

								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
							}
						}

						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0].clone());
						else{
							var gm = new ol.geom.MultiLineString(null);
							gm.setLineStrings(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}

				}
				offset = ends[i];
			}

			break;
		case ol.geom.GeometryType.LINE_STRING:
			ol.geom.flat.intersectsextent.lineString(
				geometry.flatCoordinates, 0, geometry.ends_, geometry.stride, extent);
			if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
				var obj = globalLinesLabels_[feature.get('labelType')][0];
				obj.geo = new ol.Feature(geometry.getLineString(0).clone());
				obj.feature = feature;
				result.push(obj);
			}
			break;
		case ol.geom.GeometryType.MULTI_POINT:
			var i, ii, x, y;
			for (i = 0, ii = geometry.flatCoordinates.length; i < ii; i += geometry.stride) {
				x = geometry.flatCoordinates[i];
				y = geometry.flatCoordinates[i + 1];
				if (ol.extent.containsXY(extent, x, y)) {
					if(goog.isDef(globalPointsLabels_[feature.get('labelType')]) && goog.isDef(feature.get('labelsObj'))){
						//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
						//, выбираем из этого списка
						var obj;
						if(globalPointsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
							obj = feature.get('labelsObj')[i/2];
							if (obj === undefined)
								obj = globalPointsLabels_[feature.get('labelType')][i/2];
						}
						else{
							obj = globalPointsLabels_[feature.get('labelType')][i/2];
						}

						obj.geo = new ol.Feature(geometry.getPoint(i/2).clone());
						obj.feature = feature;
						result.push(obj);
					}
				}
			}
			break;
		case ol.geom.GeometryType.POINT:
			var x, y;
			x = geometry.flatCoordinates[0];
			y = geometry.flatCoordinates[1];
			if (ol.extent.containsXY(extent, x, y)) {
				if(goog.isDef(globalPointsLabels_[feature.get('labelType')])){
					var obj = globalPointsLabels_[feature.get('labelType')][0];
					obj.geo = new ol.Feature(geometry.clone());
					obj.feature = feature;
					result.push(obj);
				}
			}
			break;
		case ol.geom.GeometryType.MULTI_POLYGON:
			var i, ii;
			var offset = 0;
			var or = geometry.getOrientedFlatCoordinates();
			var endss = geometry.endss_;
			for (i = 0, ii = endss.length; i < ii; ++i) {
				var ends = endss[i];
				if (ol.geom.flat.intersectsextent.linearRings(
					or, offset, ends, geometry.stride, extent)) {
					if(goog.isDef(globalPolygonsLabels_[feature.get('labelType')]) && goog.isDef(feature.get('labelsObj'))){
						//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
						//, выбираем из этого списка
						var obj;
						if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
							obj = feature.get('labelsObj')[i];
						}
						else{
							obj = jQuery.extend({}, globalPolygonsLabels_[feature.get('labelType')][i]);
						}
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getPolygon(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его

								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalPolygonsLabels_[feature.get('labelType')][t];
									}

									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getPolygon(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalPolygonsLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj)&& goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getPolygon(t).clone());
									}
								}
							}
						}
						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0]);
						else{
							var gm = new ol.geom.MultiPolygon(null);
							gm.setPolygons(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}
				}
				offset = ends[ends.length - 1];
			}
			break;
		case ol.geom.GeometryType.POLYGON:
			var or = geometry.getOrientedFlatCoordinates();
			var ends = geometry.ends_;
			if (ol.geom.flat.intersectsextent.linearRings(
				or, 0, ends, geometry.stride, extent)) {
				if(goog.isDef(globalPolygonsLabels_[feature.get('labelType')])){
					var obj = globalPolygonsLabels_[feature.get('labelType')][0];
					obj.geo = new ol.Feature(geometry.clone());
					obj.feature = feature;
					result.push(obj);
				}
			}
			offset = ends[ends.length - 1];
			break;
	}
	return result;
};

GeoUtil.getIntersectedGeometry_old = function(feature, extent){
	var result = [];
	var geometry = feature.getGeometry();
	goog.asserts.assert(goog.isDefAndNotNull(geometry),
		'feature geometry is defined and not null');
	if(!goog.isDef(feature.get('labelType')))
		return [];
	switch(geometry.getType()){
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			var i, ii;
			var ends = geometry.ends_;
			var offset = 0;
			if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
				for (i = 0, ii = ends.length; i < ii; ++i) {
					var geo = globalLinesLabels_[feature.get('labelType')][i].geo;
					if(geo === undefined)
						continue;
					var geoExcent = geo.getExtent();
					if(!ol.extent.intersects(geoExcent, extent))
						continue;
					/*if (GeoUtil.lineString(geometry.flatCoordinates, offset, ends[i], geometry.stride, extent, geoExcent)) {*/
					if (ol.geom.flat.intersectsextent.lineString(
						geometry.flatCoordinates, offset, ends[i], geometry.stride, extent)) {
						var obj =  jQuery.extend({}, globalLinesLabels_[feature.get('labelType')][i]);
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getLineString(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его
								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
							}
						}

						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0].clone());
						else{
							var gm = new ol.geom.MultiLineString(null);
							gm.setLineStrings(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}
				}
			}
			offset = ends[i];
			break;
		case ol.geom.GeometryType.LINE_STRING:
			ol.geom.flat.intersectsextent.lineString(
				geometry.flatCoordinates, 0, geometry.ends_, geometry.stride, extent);
			if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
				var obj = globalLinesLabels_[feature.get('labelType')][0];
				obj.geo = new ol.Feature(geometry.getLineString(0).clone());
				obj.feature = feature;
				result.push(obj);
			}
			break;
		case ol.geom.GeometryType.MULTI_POINT:
			var i, ii, x, y;
			for (i = 0, ii = geometry.flatCoordinates.length; i < ii; i += geometry.stride) {
				x = geometry.flatCoordinates[i];
				y = geometry.flatCoordinates[i + 1];
				if (ol.extent.containsXY(extent, x, y)) {
					if(goog.isDef(globalPointsLabels_[feature.get('labelType')]) && goog.isDef(feature.get('labelsObj'))){
						//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
						//, выбираем из этого списка
						var obj;
						if(globalPointsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
							obj = feature.get('labelsObj')[i/2];
						}
						else{
							obj = globalPointsLabels_[feature.get('labelType')][i/2];
						}

						obj.geo = new ol.Feature(geometry.getPoint(i/2).clone());
						obj.feature = feature;
						result.push(obj);
					}
				}
			}
			break;
		case ol.geom.GeometryType.POINT:
			var x, y;
			x = geometry.flatCoordinates[0];
			y = geometry.flatCoordinates[1];
			if (ol.extent.containsXY(extent, x, y)) {
				if(goog.isDef(globalPointsLabels_[feature.get('labelType')])){
					var obj = globalPointsLabels_[feature.get('labelType')][0];
					obj.geo = new ol.Feature(geometry.clone());
					obj.feature = feature;
					result.push(obj);
				}
			}
			break;
		case ol.geom.GeometryType.MULTI_POLYGON:
			var i, ii;
			var offset = 0;
			var or = geometry.getOrientedFlatCoordinates();
			var endss = geometry.endss_;
			for (i = 0, ii = endss.length; i < ii; ++i) {
				var ends = endss[i];
				if (ol.geom.flat.intersectsextent.linearRings(
					or, offset, ends, geometry.stride, extent)) {
					if(goog.isDef(globalPolygonsLabels_[feature.get('labelType')]) && goog.isDef(feature.get('labelsObj'))){
						//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
						//, выбираем из этого списка
						var obj;
						if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
							obj = feature.get('labelsObj')[i];
						}
						else{
							obj = jQuery.extend({}, globalPolygonsLabels_[feature.get('labelType')][i]);
						}
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getPolygon(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его

								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalPolygonsLabels_[feature.get('labelType')][t];
									}

									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getPolygon(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalPolygonsLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj)&& goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getPolygon(t).clone());
									}
								}
							}
						}
						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0]);
						else{
							var gm = new ol.geom.MultiPolygon(null);
							gm.setPolygons(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}
				}
				offset = ends[ends.length - 1];
			}
			break;
		case ol.geom.GeometryType.POLYGON:
			var or = geometry.getOrientedFlatCoordinates();
			var ends = geometry.ends_;
			if (ol.geom.flat.intersectsextent.linearRings(
				or, 0, ends, geometry.stride, extent)) {
				if(goog.isDef(globalPolygonsLabels_[feature.get('labelType')])){
					var obj = globalPolygonsLabels_[feature.get('labelType')][0];
					obj.geo = new ol.Feature(geometry.clone());
					obj.feature = feature;
					result.push(obj);
				}
			}
			offset = ends[ends.length - 1];
			break;
	}
	return result;
};

//дистанция между двумя точками. Координаты в pulkovo84
GeoUtil.GetDist = function(b1, l1, z1, b2, l2, z2) {
	var dB = (b2-b1)*3600;
	var dL = (l2-l1)*3600;
	if(dB==0 && dL==0)
		return 0;

	var Bm = (b1+b2)/2;
	var ddB = dB/10000;
	var ddL = dL/10000;
	var ddB2 = ddB*ddB;
	var ddL2 = ddL*ddL;
	var ddB2L = ddB2*ddL;
	var ddBL2 = ddB*ddL2;
	var ddB3 = ddB2*ddB;
	var ddL3 = ddL2*ddL;
	var cosB = Math.cos(Bm*Math.PI/180);
	var cosB2 = cosB*cosB;
	var cosB3 = cosB2*cosB;
	var cosB4 = cosB3*cosB;
	var cosB5 = cosB4*cosB;
	var cosB6 = cosB5*cosB;
	var sinB = Math.sin(Bm*Math.PI/180);
	var a1 = 103422.05*cosB;
	var a2 = 9.5144*cosB+0.5525*cosB3-0.0078*cosB5;
	var a3 = -10.1287*cosB+10.1287*cosB3;
	var a4 = 103422.05-696.9116*cosB2+4.6954*cosB4-0.0310*cosB6;
	var a5 = -30.3860+10.3334*cosB2-0.2061*cosB4+0.0014*cosB6;
	var a6 = -0.2048+0.4192*cosB2-0.0124*cosB4;
	var D = (593.602160+cosB2)/(197.867385+cosB2);
	var E1 = a1*ddL+a2*ddB2L+a3*ddL3;
	var E2 = a4*ddB+a5*ddBL2+a6*ddB3;
	var sinA = Math.sin(Math.atan2(E1,E2));
	var dist;
	if(sinA!=0)
		dist = Math.abs(D*E1/sinA);
	else
		dist = Math.abs(D*E2);
	return Math.sqrt(dist*dist+(z2-z1)*(z2-z1));
};

//получение координаты точки по отрезку и длине, на которой она в нём находится от первой точки
GeoUtil.PointByDistanceAndSegment1 = function(distance, segment){
	var d = GeoUtil.Distance(segment[0],segment[1]); //длина сегмента
	var d1 = distance;//от первой точки до искомой
	var coeff = d1/d;//d1/d2;
	var pX = (1-coeff)*segment[0][0]+coeff*segment[1][0];
	var pY = (1-coeff)*segment[0][1]+coeff*segment[1][1];
	return [pX,pY];// segment[1];//[pX,pY];
};

GeoUtil.PointByDistanceAndSegment = function(lat1, long1, lat2, long2, per) {
	return [lat1 + (lat2 - lat1) * per, long1 + (long2 - long1) * per];
};

//получение координаты точки по отрезку и длине, на которой она в нём находится от первой точки
GeoUtil.PointByDistanceAndSegment12 = function(distance, segment){
	var x,y = 0;
	var d = GeoUtil.Distance(segment[0],segment[1]); //длина сегмента
	var d1 = distance;//от первой точки до искомой
	var d2 = d-distance;// от искомой до 2-й точки
	var coeff = d1/d;//d1/d2;
	var aX,aY,bX,bY,pX,pY = 0;
	aX = segment[0][0];
	aY = segment[0][1];
	bX = segment[1][0];
	bY = segment[1][1];
	pX = aX + coeff*(bX-aX);
	pY = aY + coeff*(bY-aY);
	return [pX,pY];// segment[1];//[pX,pY];
};

//Compute the distance from A to B
GeoUtil.Distance =  function (pointA, pointB){
	var d1 = pointA[0] - pointB[0];
	var d2 = pointA[1] - pointB[1];
	return Math.sqrt(d1 * d1 + d2 * d2);
};

/**
 * Calculating distance between line (or line segment) and point 2D
 */
//Compute the dot product AB . AC
GeoUtil.DotProduct = function(pointA, pointB, pointC){
	var AB = [0,0];
	var BC = [0,0];
	AB[0] = pointB[0] - pointA[0];
	AB[1] = pointB[1] - pointA[1];
	BC[0] = pointC[0] - pointB[0];
	BC[1] = pointC[1] - pointB[1];
	var dot = AB[0] * BC[0] + AB[1] * BC[1];

	return dot;
};

//Compute the cross product AB x AC
GeoUtil.CrossProduct = function(pointA, pointB, pointC){
	var AB = [0,0];
	var AC = [0,0];
	AB[0] = pointB[0] - pointA[0];
	AB[1] = pointB[1] - pointA[1];
	AC[0] = pointC[0] - pointA[0];
	AC[1] = pointC[1] - pointA[1];
	var cross = AB[0] * AC[1] - AB[1] * AC[0];

	return cross;
};

//Compute the distance from AB to C
//if isSegment is true, AB is a segment, not a line.
GeoUtil.LineToPointDistance2D = function(pointA, pointB, pointC, isSegment){
	if (isSegment == true){
		var dot1 = GeoUtil.DotProduct(pointA, pointB, pointC);
		if (dot1 > 0)
			return GeoUtil.Distance(pointB, pointC);

		var dot2 = GeoUtil.DotProduct(pointB, pointA, pointC);
		if (dot2 > 0)
			return GeoUtil.Distance(pointA, pointC);
	}
	var dist = GeoUtil.CrossProduct(pointA, pointB, pointC) / GeoUtil.Distance(pointA, pointB);
	return Math.abs(dist);
};


/**
 * Удаление из геометрии объекта по индексу
 * @param geometry
 * @param index
 */
GeoUtil.removeObjectFromGeometry = function(feature, index){
	if(feature === undefined)
		return false;
	var geometry = feature.getGeometry();
	switch(geometry.getType()){
		case ol.geom.GeometryType.MULTI_POINT:
			var n = !geometry.flatCoordinates ?
				0 : geometry.flatCoordinates.length / geometry.stride;
			if (index < 0 || n <= index) {
				geometry.changed();
				return false;
			}
			var coords = geometry.flatCoordinates;
			coords.splice(index * geometry.stride, geometry.stride);
			geometry.setFlatCoordinates(geometry.layout,coords);
			break;
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			if (index < 0 || geometry.ends_.length <= index) {
				return false;
			}
			var ls = geometry.getLineStrings();
			ls.splice(index,1);
			geometry.setLineStrings(ls);
			// geometry.flatCoordinates.splice(index === 0 ? 0 : geometry.ends_[index - 1], geometry.ends_[index]);
			break;
		case ol.geom.GeometryType.MULTI_POLYGON:
			if (index < 0 || geometry.endss_.length <= index) {
				return false;
			}
			var ls = geometry.getPolygons();
			ls.splice(index,1);
			geometry.setPolygons(ls);
			break;
	}
	return true;
};

GeoUtil.segmentIntersect = function(seg1, seg2){
// Check the validity of the segments
	if ((seg1[1]) < (seg1[0])){
		return false;
	}
	if ((seg2[1]) < (seg2[0])){
		return false;
	}

	// Compute some useful oriented length needed later for computing
	//   the cross product of 2D-vectors centered in (0,0).
	// Compute the X-orientedLength and Y-orientedLength of the edge seg1
	var x12_11 = ((seg1[1]) - (seg1[0]));  // seg1.x2 - seg1.x1
	var y12_11 = ((seg1[1]) - (seg1[0]));  // seg1.y2 - seg1.y1
	// Compute the X-orientedLength and Y-orientedLength of the edge seg2
	var x22_21 = ((seg2[1]) - (seg2[0]));  // seg2.x2 - seg2.x1
	var y22_21 = ((seg2[1]) - (seg2[0]));  // seg2.y2 - seg2.y1
	// Compute the X-orientedLength and Y-orientedLength between the first vertex of each edge, named seg3
	var x11_21 = ((seg1[0]) - (seg2[0]));  // seg1.x1 - seg2.x1
	var y11_21 = ((seg1[0]) - (seg2[0]));  // seg1.y1 - seg2.y1

	// Compute the cross product seg1 x seg2
	var d= (x12_11 * y22_21) - (x22_21 * y12_11);
	// Compute the cross product seg2 x seg3
	var n1 = (x22_21 * y11_21) - (x11_21 * y22_21);
	// Compute the cross product seg1 x seg3
	var n2 = (x12_11 * y11_21) - (x11_21 * y12_11);

	// Why do we use cross products ? Let's explain with d = seg1 x seg2
	// d represents the signed area of the parallelogram defined by the
	//   two segments seg1 and seg2 translated to have the same origin.
	// If d==0, then seg1 and seg2 are colinear (same or opposite sense)
	// If d<0, then seg1 is in the direct sense from seg2
	// If d>0, then seg1 is in the indirect sens from seg2

	// Test if the two segments intersect themselves or not
	var intersection = false;
	if (d == 0) {  // seg1 and seg2 are colinear and could be coincident
		if (n1 == 0 && n2 == 0) {  // coincident
			return true;
		}
		// else there is no intersection but the Boolean to return will
		//   depend on the tolerance management.
	} else {  // seg1 and seg2 are not colinear, an intersection could exist
		var along1 = n1 / d;
		var along2 = n2 / d;
		if ((along1 >= 0) && (along1 <= 1) && (along2 >=0) && (along2 <= 1)) {  // intersect
			return true;
		}
		// else there is no intersection but the Boolean to return will
		//   depend on the tolerance management.
	}

	// The tolerance must be managed to test if an approximated
	//   intersection exists or not.
	return false; // TODO
};

GeoUtil.lineIntersect = function(line,lineRing){
	if(lineRing.getType() === ol.geom.GeometryType.LINEAR_RING){
		if(!ol.extent.intersects(line.getExtent(),lineRing.getExtent()))
			return false;
		var segs1 = line.getCoordinates();
		var segs2 = lineRing.getCoordinates();
		var seg1, seg1y0, seg1y1, seg1yMin, seg1yMax;
		var seg2, seg2y0, seg2y1, seg2yMin, seg2yMax;
		var i=0;
		for(i; i<segs1.length; ++i) {
			seg1 = segs1[i];
			// Loop over each segment of the requested geometry
			for(var j=0; j<segs2.length; ++j) {
				// Before to really test the intersection between the two
				//    segments, we will test the intersection between their
				//    respective bounding boxes in four steps.
				seg2 = segs2[j];
				// If the most left vertex of seg2 is at the right of the
				//   most right vertex of seg1, there is no intersection
				if (seg2[0] > seg1[1]) {
					continue;
				}
				// If the most right vertex of seg2 is at the left of the
				//   most left vertex of seg1, there is no intersection
				if (seg2[1] < seg1[0]) {
					// seg2 still left of seg1
					continue;
				}
				// To perform similar tests along Y-axis, it is necessary to
				//   order the vertices of each segment
				seg1y0 = seg1[0];
				seg1y1 = seg1[1];
				seg2y0 = seg2[0];
				seg2y1 = seg2[1];
				seg1yMin = Math.min(seg1y0, seg1y1);
				seg1yMax = Math.max(seg1y0, seg1y1);
				seg2yMin = Math.min(seg2y0, seg2y1);
				seg2yMax = Math.max(seg2y0, seg2y1);
				// If the most bottom vertex of seg2 is above the most top
				//   vertex of seg1, there is no intersection
				if (seg2yMin > seg1yMax) {
					continue;
				}
				// If the most top vertex of seg2 is below the most bottom
				//   vertex of seg1, there is no intersection
				if (seg2yMax < seg1yMin) {
					continue;
				}
				// Now it sure that the bounding box of the two segments
				//   intersect themselves, so we have to perform the real
				//   intersection test of the two segments
				if (GeoUtil.segmentIntersect(seg1, seg2)) {
					// These two segments intersect, there is no need to
					//   continue the tests for all the other couples of
					//   segments
					return true;
				}
			}
		}
	}
	return false;
};

GeoUtil.polygonIntersect = function(polygon,geom){
	if(geom.getType() === ol.geom.GeometryType.LINE_STRING){

		// LinearRing should be tested before LineString if a different
		//   action should be made for each case..
		// Test for the intersection of each LinearRing of tis Polygon
		//   with the geometry (LineString or LinearRing)
		var linearRings = polygon.getLinearRings();
		var i=0;
		for(i; i<linearRings.length; i++) {
			if (GeoUtil.lineIntersect(geom,linearRings[i]))
				return true;
		}
		// None of the LinearRings of this Polygon intersects with the
		//  input geometry. An intersection exists in two cases:
		//  1) if the input geomety is whole contained in the first
		//    LinearRing but not in one of the holes represented by the
		//    others LinearRings.
		//  2) if the input geometry is a LinearRing (not a LineString)
		//    and this polygon is whole contained in it.
		//  Test only one vertex is sufficient in the two cases since
		//  there is no intersection.
		//      return this.containsPoint((geom as LineString).componentByIndex(0) as Point)
		//  || ((geom is LinearRing) && (geom as LinearRing).containsPoint((this.componentByIndex(0) as LinearRing).componentByIndex(0) as Point));
	}
	return false;
};

/**
 * Преобразование пришедшего массива с объектом WKT строки из пулково42 в wgs
 * @param dataArr
 * @returns {*}
 */
GeoUtil.parseP42WKTStringToWGS = function(dataArr){
	if(dataArr !== undefined){
		var i = 0;
		for(;i<dataArr.length;i++){
			var obj = dataArr[i];
			if(obj.WKT !== undefined){
				var format = new ol.format.WKT();
				var geometry = format.readGeometry(obj.WKT);
				var coords = geometry.flatCoordinates;
				var newCoords  = [];//of Array.<ol.Coordinate>
				var stride = geometry.stride;
				var j;
				for ( j = 0; j < coords.length; j += stride) {
					var p42WgsPnt = GeoUtil.P42WGS( coords[j+1], coords[j]);
					newCoords.push(p42WgsPnt.x);
					newCoords.push(p42WgsPnt.y);
					if(stride === 3)
						newCoords.push(coords[j+2]);
				}
				if(geometry.getType() === ol.geom.GeometryType.POLYGON || geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
					geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
				else if(geometry.getType() === ol.geom.GeometryType.MULTI_POLYGON)
					geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
				else
					geometry.setFlatCoordinates(geometry.layout,newCoords);
				//преобразуем в WGS WKT строку
				obj.WKT = format.writeGeometry(geometry)
			}
		}
	}
	return dataArr;
};


/**
 * Проверка, пересекаются ли геометрии
 * @param cadGeo
 * @param bufferGeo
 * @returns {Array}
 */
GeoUtil.checkCadastreInBuffer = function(cadGeo, bufferGeo){
	var polygon1,polygon2,features;
	var result = {geo:undefined, error:''};
	try{
		if(cadGeo instanceof ol.geom.GeometryCollection)
			polygon1 =  new ol.Feature(cadGeo.getGeometries()[0]);
		else
			polygon1 = new ol.Feature(cadGeo);
		polygon2 = new ol.Feature(bufferGeo);
		var format = new ol.format.GeoJSON();
		var fpolygon1 =  format.writeFeatureObject(polygon1);
		var fpolygon2 =  format.writeFeatureObject(polygon2);
		//fpolygon2.geometry.coordinates[0].splice(fpolygon2.geometry.coordinates[0].length-2);
		//fpolygon2.geometry.coordinates[0].push(fpolygon2.geometry.coordinates[0][0]);
		var intersection = turf.intersect(fpolygon1,fpolygon2);
		if(goog.isDef(intersection)){
			features = format.readFeaturesFromObject(intersection);
		}
		result.geo = features;
		return result;
	}
	catch(ex){
		result.error = ex.message;
	}
	return result;
};

/**
 * Перевод тайла в географические координаты
 * @param x долгота
 * @param z масштаб
 * @returns {number}
 * @constructor
 */
GeoUtil.Tile2Longitude = function(x,z) {
	return (x/Math.pow(2,z)*360-180);
};

/**
 * Перевод тайла в географические координаты
 * @param y широта
 * @param z масштаб
 * @returns {number}
 * @constructor
 */
GeoUtil.Tile2Latitude = function(y,z) {
	var n=Math.PI-2*Math.PI*y/Math.pow(2,z);
	return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));
};
/**
 * Вычисление ближайшей точки до прямой
 */
GeoUtil.getClosestPointForGeo = function(objForBind, pointCoord) {
	//рассчитываем ближайшее расстояние до каждого из отрезков прямой
	//Координаты сначала переводятся из проекции базового слоя карты в метровую,
	//затем рассчитывается привязка, а потом полученные координаты привязки переводятся в проекцию базового слоя карты
	if(goog.isDef(objForBind.geo) && (objForBind.geo.getGeometry().getType() === ol.geom.GeometryType.LINE_STRING
		|| objForBind.geo.getGeometry().getType() === ol.geom.GeometryType.POLYGON)) {
		var minDist1 = Number.POSITIVE_INFINITY;
		var closestSegment1 = null;
		var srcPntArr1;
		var coeff1 = 0;
		//дополнительные переменные для привязки линейного EVENT_RANGE
		srcPntArr1 = pointCoord;//текущее положение курсора
		//получаем сегменты линии
		var point1;
		var point2;
		var lineCoordinates = objForBind.geo.getGeometry().getCoordinates();
		var numSegs = lineCoordinates.length;
		if(objForBind.geo.getGeometry().getType() === ol.geom.GeometryType.POLYGON && lineCoordinates.length > 0){
			numSegs = lineCoordinates[0].length;
			lineCoordinates = lineCoordinates[0];
		}

		var pos1 = -1;
		var i = 0;
		//var pp = ol.coordinate.closestOnSegment(lineCoordinates,)
		for (; i < numSegs - 1; ++i) {
			point1 = lineCoordinates[i];
			point2 = lineCoordinates[i + 1];
			//Длина текущего отрезка
			var segmentLength = GeoUtil.Distance(point1, point2);
			//рассчитываем ближайшее расстояние от нашей точки до текущего отрезка
			var calcDist1 = GeoUtil.LineToPointDistance2D(point1, point2, srcPntArr1, true);
			if (calcDist1 < minDist1) {
				var srcPoint1ToPoint1Dist = GeoUtil.Distance(point1, srcPntArr1);
				var srcPoint1ToPoint2Dist = GeoUtil.Distance(point2, srcPntArr1);
				//рассчитываем коэффициент отношения длины от начальной точки до точки проекции на отрезок к длине отрезка
				//Если длина от нашей точки до отрезка равна длине от нашей точки до одной из 2-х точек отрезка coeff1 = 0 если точка первая и coeff1 = 1 если точка последняя
				if (calcDist1 === srcPoint1ToPoint1Dist)
					coeff1 = 0;
				else if (calcDist1 === srcPoint1ToPoint2Dist)
					coeff1 = 1;
				else
					coeff1 = Math.sqrt(Math.pow(srcPoint1ToPoint1Dist, 2) - Math.pow(calcDist1, 2)) / segmentLength;
				//Сохраняем текущую дистанцию как минимальную, текущий отрезок как ближайший
				minDist1 = calcDist1;
				closestSegment1 = [point1, point2];
				//тут ещё можно посчитать координаты точки пересечения
				pos1 = i;
			}
		}
		if (!goog.isNull(closestSegment1)) {
			// closestsegment1 - найти проекцию
			var newPointProj = ol.coordinate.closestOnSegment(srcPntArr1, closestSegment1);
			return {segment: closestSegment1, geo: objForBind.geo, position: pos1, point: newPointProj, coeff: coeff1};
		}
	}
	return undefined;
};

GeoUtil.getIntersectedRouteGeometry = function(geometry, extent, routeId, routeLabel){
	var result = [];
	goog.asserts.assert(goog.isDefAndNotNull(geometry),
		'feature geometry is defined and not null');
	switch(geometry.getType()){
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			var i, ii;
			var ends = geometry.ends_;
			var offset = 0;
			if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
				for (i = 0, ii = ends.length; i < ii; ++i) {
					var geo = globalLinesLabels_[feature.get('labelType')][i].geo;
					if(geo === undefined)
						continue;
					var geoExcent = geo.getExtent();
					if(!ol.extent.intersects(geoExcent, extent))
						continue;
					/*if (GeoUtil.lineString(geometry.flatCoordinates, offset, ends[i], geometry.stride, extent, geoExcent)) {*/
					if (ol.geom.flat.intersectsextent.lineString(
						geometry.flatCoordinates, offset, ends[i], geometry.stride, extent)) {
						var obj =  jQuery.extend({}, globalLinesLabels_[feature.get('labelType')][i]);
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getLineString(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его
								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
							}
						}

						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0].clone());
						else{
							var gm = new ol.geom.MultiLineString(null);
							gm.setLineStrings(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}
				}
			}
			offset = ends[i];
			break;
		case ol.geom.GeometryType.LINE_STRING:
			ol.geom.flat.intersectsextent.lineString(
				geometry.flatCoordinates, 0, geometry.ends_, geometry.stride, extent);
			var obj = {};
			obj.geo = geometry.clone();
			obj.id = routeId;
			obj.label = routeLabel;
			result.push(obj);
			break;
	}
	return result;
};

/**
 * Вычисление ближайшей точки до прямой
 */
GeoUtil.getClosestRoutePointForGeo = function(objForBind, pointCoord) {
	//рассчитываем ближайшее расстояние до каждого из отрезков прямой
	//Координаты сначала переводятся из проекции базового слоя карты в метровую,
	//затем рассчитывается привязка, а потом полученные координаты привязки переводятся в проекцию базового слоя карты
	if(goog.isDef(objForBind.geo) && objForBind.geo.getType() === ol.geom.GeometryType.LINE_STRING) {
		var minDist1 = Number.POSITIVE_INFINITY;
		var closestSegment1 = null;
		var srcPntArr1;
		var coeff1 = 0;
		//дополнительные переменные для привязки линейного EVENT_RANGE
		srcPntArr1 = pointCoord;//текущее положение курсора
		//получаем сегменты линии
		var point1;
		var point2;
		var lineCoordinates = objForBind.geo.getCoordinates();
		var numSegs = lineCoordinates.length;
		var pos1 = -1;
		var i = 0;
		//var pp = ol.coordinate.closestOnSegment(lineCoordinates,)
		for (; i < numSegs - 1; ++i) {
			point1 = lineCoordinates[i];
			point2 = lineCoordinates[i + 1];
			//Длина текущего отрезка
			var segmentLength = GeoUtil.Distance(point1, point2);
			//рассчитываем ближайшее расстояние от нашей точки до текущего отрезка
			var calcDist1 = GeoUtil.LineToPointDistance2D(point1, point2, srcPntArr1, true);
			if (calcDist1 < minDist1) {
				var srcPoint1ToPoint1Dist = GeoUtil.Distance(point1, srcPntArr1);
				var srcPoint1ToPoint2Dist = GeoUtil.Distance(point2, srcPntArr1);
				//рассчитываем коэффициент отношения длины от начальной точки до точки проекции на отрезок к длине отрезка
				//Если длина от нашей точки до отрезка равна длине от нашей точки до одной из 2-х точек отрезка coeff1 = 0 если точка первая и coeff1 = 1 если точка последняя
				if (calcDist1 === srcPoint1ToPoint1Dist)
					coeff1 = 0;
				else if (calcDist1 === srcPoint1ToPoint2Dist)
					coeff1 = 1;
				else
					coeff1 = Math.sqrt(Math.pow(srcPoint1ToPoint1Dist, 2) - Math.pow(calcDist1, 2)) / segmentLength;
				//Сохраняем текущую дистанцию как минимальную, текущий отрезок как ближайший
				minDist1 = calcDist1;
				closestSegment1 = [point1, point2];
				//тут ещё можно посчитать координаты точки пересечения
				pos1 = i;
			}
		}
		if (!goog.isNull(closestSegment1)) {
			// closestsegment1 - найти проекцию
			var newPointProj = ol.coordinate.closestOnSegment(srcPntArr1, closestSegment1);
			return {segment: closestSegment1, geo: objForBind.geo, position: pos1, point: newPointProj, coeff: coeff1};
		}
	}
	return undefined;
};


/**
 * Перевод десятичные градусы в градусы
 */
GeoUtil.convertDecimalIntoDegree = function (text) {
	//ex. 56.530865
	var n = parseFloat(text);
	if(isNaN(n))
		return '';
	var dd = parseInt(text);//градус
	var mm = parseInt((n - dd) * 60);//минуты
	var ss = ((n - dd) * 60 - mm) * 60;
	//ss = parseInt(ss*100);//Math.round(60*(n - dd)*60 - parseInt(n - parseInt(n))*60) ;//секунды
	ss = ss.toFixed(2);
	if (dd < 10)
		dd = '0' + dd;
	dd = dd + '° ';
	if (mm < 10)
		mm = '0' + mm;
	mm = mm + "' ";
	if (ss < 10)
		ss = '0' + ss;
	ss = ss + "''";
	return dd + mm + ss;

	/*var n = parseFloat(text);
	var dd = parseInt(n);
	var ddS = (dd<10)?'0'+dd:dd;
	var mm = parseInt((n-dd)*60);
	var mmS = (mm<10)?'0'+mm:mm;
	var ss = parseInt((n - dd - mm/60)*3600);
	return ""+ddS+"°"+mmS+"\""+ss+'\'';*/
};


/**
 * Перевод градусы в десятичные градусы
 */
GeoUtil.convertDegreeIntoDecimal = function (text) {
	var dd = text.split('°')[0];
	dd = dd.replace('_', '0').replace('_', '0');
	var mm = text.split('°')[1].split("'")[0];
	mm = mm.replace('_', '0').replace('_', '0');
	var ss = text.split('°')[1].split("'")[1];
	ss = ss.replace('_', '0').replace('_', '0').replace('_', '0').replace('_', '0');

	var ddD = parseFloat(dd);
	var mmD = parseFloat(mm);
	var ssD = parseFloat(ss);
	if(isNaN(ddD) || isNaN(mmD) || isNaN(ssD))
		return -1;
	var resDD = Math.round(100000 * (ddD + mmD / 60 + ssD / 3600)) / 100000;
	return resDD;
};

/**
 * Переводим десятичные градусы в градусы в массиве объектов вида {latitude:22, longitude:22}
 */
GeoUtil.convertArrayDecimalIntoDegree = function (array) {
	for (var i = 0; i <= array.length; i++) {
		array[i].longitude = GeoUtil.convertDecimalIntoDegree(array[i].longitude);
		array[i].longitude = GeoUtil.convertDecimalIntoDegree(array[i].latitude);
	}
	return array;
};

/**
 * Переводим градусы в десятичные градусы в массиве объектов вида {latitude:22, longitude:22}
 */
GeoUtil.convertArrayDegreeIntoDecimal = function (array) {
	for (var i = 0; i <= array.length; i++) {
		array[i].longitude = GeoUtil.convertDegreeIntoDecimal(array[i].longitude);
		array[i].longitude = GeoUtil.convertDegreeIntoDecimal(array[i].latitude);
	}
	return array;
};


GeoUtil.getFontSizeByCharWidth = function(charWidth){
	return parseInt(''+(charWidth*20/11));
	if(charWidth < 10)
		return 12;
	if(charWidth < 12)
		return 20;
	if(charWidth < 14)
		return 24;
	if(charWidth < 14)
		return 24;
	/*if(charWidth < 10)
		return 12;
	if(charWidth < 10)
		return 12;*/
	return 12;
};

/**
 * Функция вырезает точки переданной геометрии, которые попали в полигон
 * @param baseGeometry
 * @param polygon
 * @returns {*}
 */
GeoUtil.truncateGeometry = function(baseGeometry, polygonGeometry) {
	var newGeometry = baseGeometry;
	if(baseGeometry){
		var coords = baseGeometry.getCoordinates();
		var newCoords = [];
		if(baseGeometry.getType() === ol.geom.GeometryType.POINT){
			if(!polygonGeometry.containsCoordinate(coords))
				newCoords.push(coords);
			newGeometry.setFlatCoordinates(newGeometry.layout, newCoords);
		}
		else if(baseGeometry.getType() === ol.geom.GeometryType.LINE_STRING){
			coords.forEach(function (coord) {
				if (!polygonGeometry.containsCoordinate(coord))
					newCoords.push(coord);
			})
			if(newCoords.length < 2){
				//обнуляем геометрию, т.к. 2 координаты в полигоне
				newCoords = [];
			}
			newGeometry.setCoordinates(newCoords, newGeometry.layout);
		}
		else {
			if(coords.length > 0){
				coords.forEach(function (pCoords) {
					pCoords.forEach(function (coord) {
						if (!polygonGeometry.containsCoordinate(coord)){
							newCoords.push(coord[0],coord[1]);
						}

					});
				});
			}
			if(newCoords.length >= 6){  //3*2 координаты
				//проверяем, что 1-я и последняя координаты совпадают. Если нет - дописываем
				if(!(newCoords[0] === newCoords[newCoords.length - 2] && newCoords[1] === newCoords[newCoords.length - 1]))
					newCoords.push(newCoords[0], newCoords[1]);
			}else{
				//обнуляем геометрию, т.к. 2 координаты в полигоне
				newCoords = [];
			}
			//newGeometry.setCoordinates(newCoords, newGeometry.layout);
			newGeometry.setFlatCoordinates(newGeometry.layout, newCoords, [newCoords.length]);
		}
	}
	return newGeometry;
}

/**
 * Функция вырезает точки переданной геометрии, которые extent
 * @param baseGeometry
 * @param extent
 * @returns {*}
 */
GeoUtil.truncateGeometryByExtent = function(baseGeometry, extent) {
	var newGeometry = baseGeometry;
	if(baseGeometry){
		var coords = baseGeometry.getCoordinates();
		var newCoords = [];
		if(baseGeometry.getType() === ol.geom.GeometryType.POINT){
			if(!ol.extent.containsCoordinate(extent,coords))
				newCoords = coords;
			newGeometry.setFlatCoordinates(newGeometry.layout, newCoords);
		}
		else if(baseGeometry.getType() === ol.geom.GeometryType.LINE_STRING){
			coords.forEach(function (coord) {
				if (!ol.extent.containsCoordinate(extent, coord))
					newCoords.push(coord);
			})
			if(newCoords.length < 2){
				//обнуляем геометрию, т.к. 2 координаты в полигоне
				newCoords = [];
			}
			newGeometry.setCoordinates(newCoords, newGeometry.layout);
		}
		else {

			if(coords.length > 0){
				coords.forEach(function (pCoords) {
					var firstCoord = pCoords[0], endCoord = pCoords[pCoords.length - 1]; //первая и последняя координаты, совпадают у полигона
					pCoords.forEach(function (coord, i) {
						if (!ol.extent.containsCoordinate(extent, coord)){
							newCoords.push(coord[0],coord[1]);
						}
					});
				});
			}
			if(newCoords.length >= 6){  //3*2 координаты
				//проверяем, что 1-я и последняя координаты совпадают. Если нет - дописываем
				if(!(newCoords[0] === newCoords[newCoords.length - 2] && newCoords[1] === newCoords[newCoords.length - 1]))
					newCoords.push(newCoords[0], newCoords[1]);
			}else{
				//обнуляем геометрию, т.к. 2 координаты в полигоне
				newCoords = [];
			}
			//newGeometry.setCoordinates(newCoords, newGeometry.layout);
			newGeometry.setFlatCoordinates(newGeometry.layout, newCoords, [newCoords.length]);
		}

	}
	return newGeometry;
}

/**
 * Получение координат по введенной строке.
 * Формат координат допускается либо в десятичном виде(57.8527438000 55.0096917000), либо обычном(55°22'15.94'' 57°50'41.10'')
 *
 * @param str
 */
GeoUtil.getCoordsByString = function(str){
	var maskLat = /^(-?[1-8]?\d(?:\.\d{1,18})?|90(?:\.0{1,18})?)$/;
	var maskLon = /^(-?(?:1[0-7]|[1-9])?\d(?:\.\d{1,18})?|180(?:\.0{1,18})?)$/;
	if(str){
		var lat = '', lon = '';
		var coordsSp = str.trim().split(' ');
		coordsSp.forEach(function(item){
			if(item !== '')
				if(lon === '')
					lon = item;
				else
					lat = item;
		});
		if(lat.match(maskLat) && lon.match(maskLon))
			return {y:lon, x:lat};
	}
}

GeoUtil.getFlatGeometry = function(baseFeature){
	if(!baseFeature)
		return;
	var coords = undefined;
	try{
		if (!baseFeature.getGeometry)// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
			baseFeature = new ol.Feature(baseFeature);
		var geometry = baseFeature.getGeometry();
		if(!geometry)
			return;

		switch(geometry.getType()){
			case ol.geom.GeometryType.LINE_STRING :
				coords = geometry;
				break;
			case ol.geom.GeometryType.POINT :
				coords = geometry.flatCoordinates;
				break;
			case ol.geom.GeometryType.POLYGON :
				var pp = new ol.geom.Polygon(null);
				var linearRing = new ol.geom.LinearRing(null);
				linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, geometry.flatCoordinates);
				pp.appendLinearRing(linearRing);
				coords = pp;
				break;
		}
	}
	catch(ex){ }
	return coords;
}

/**
 *
 * @param feature фича для клонирования
 * @param withGeo флаг, нужно ли копировать геометрию
 * @returns {ol.Feature}
 */
GeoUtil.cloneFeature = function (feature, withGeo, recreateGeo) {
	var clone = new ol.Feature(feature.getProperties());
	clone.setGeometryName(feature.getGeometryName());
	if (withGeo) {
		var geometry = feature.getGeometry();
		if (geometry) {
			//если тип полигов
			if(recreateGeo && geometry.getType() === ol.geom.GeometryType.POLYGON){
				var polygon = new ol.geom.Polygon(null);
				polygon.setFlatCoordinates(geometry.layout, geometry.flatCoordinates,
					[geometry.flatCoordinates.length]);
				clone.setGeometry(polygon);
			}
			else
				clone.setGeometry(geometry.clone());
		}
	}
	var style = feature.getStyle();
	if (style) {
		clone.setStyle(style);
	}
	return clone;
};

/**
 * Функция для переподготовки геометрии полигона, который резался, чтобы не сбивались endss при рисовании на карте
 * @param feature
 * @returns {*}
 */
GeoUtil.recreateFeatureGeometry = function (feature) {
	//если тип полигов
	var newFeature = feature;
	var geometry = feature.getGeometry();
	if(geometry.getType() === ol.geom.GeometryType.POLYGON){
		var polygon = new ol.geom.Polygon(null);
		polygon.setFlatCoordinates(geometry.layout, geometry.flatCoordinates,
			[geometry.flatCoordinates.length]);
		newFeature.setGeometry(polygon);
	}
	else
		newFeature.setGeometry(geometry.clone());
	return newFeature;
};



/**
 * Функция корректирует положение подписи на техсхеме для слоя капитальных ремонтов
 *
 * @param {Object} lay Объект слоя LayerManager.getLayerByName
 * @param {ol.Geometry} geometry геометрия рисуемого объекта(линия, точка)
 * @param {number} x базовая координата подписи в пикселах
 * @param {number} y базовая координата подписи в пикселах
 * @param {Object} shift  объект с положением линии и текстом {position:1, text:''}
 * @param {number} textWidth ширина текста
 * @param {number} mapZoom масштаб карты
 * @returns {{x, y}}
 */
GeoUtil.kapRemAdjustment = function(lay, geometry, x, y, shift, textWidth, mapZoom){
	var labelCollisionPercent = 0.3;// 30%
	if(lay && lay.id === 'KAP_REMONT_PLAN' && geometry && mapZoom > 7){
		var extent = geometry.getExtent();
		// в кпг линия с диагональным перепадом, то рисуем подпись в конце линии(трубы идут справо налево)
		var isDiagLine = (1 - extent[1]/extent[3]) > 0.001;
		if(isDiagLine){
			var lastCoord = WidgetMap.map.getPixelFromCoordinate([geometry.flatCoordinates[geometry.flatCoordinates.length - 2],geometry.flatCoordinates[geometry.flatCoordinates.length - 1]]);
			x = lastCoord[0] + textWidth/2;
			y = lastCoord[1];
		}
		else if(shift && shift.position !== 0 && mapZoom < 10){
			var newX, newY;
			var position = shift.position;
			var firstTextPx = x;
			var lastGeoPx = WidgetMap.map.getPixelFromCoordinate([extent[2],extent[3]])[0];
			var firstGeoPx = WidgetMap.map.getPixelFromCoordinate([extent[0],extent[1]])[0];
			newX = x + textWidth * position;
			//если начало подписи выходит за линию, то двигаем её в обратную сторону влево
			if(newX > lastGeoPx){
				newX = x - textWidth/2;
				if(newX > firstGeoPx){
					x = newX;
				}
				else if(position % 2 !== 0) //если и влево выходит за пределы и position четная, тоне рисуем подпись
					x = NaN;
			}
			else if(newX > firstGeoPx){
				x = x + textWidth * position;
			}
		}
	}

	return {x: x, y:y};
}

//TODO перенести данные функции в файл утилит по canvasreplay

/**
 * Функция формирования линии по видимой рамке карты, чтобы подписывания начинались именно с границ видимой области карты
 * @param lineString
 * @param mapExtent
 * @param isPods //TODO upd. 09.02.22 в рамках работы по задаче "карта водного перехода" принято решение
 * пока хардкодить условие отображение(30px) подписи по названию PODS
 * @returns {*}
 */
GeoUtil.composeLineStringByExtent = function(lineString, mapExtent, isPods){
	isPods = isPods === true;
	if(!lineString)
		return;
	//если линия не пересекает рамку карты, не включаем её в выдачу
	if(!lineString.intersectsExtent(mapExtent))
		return;
	var geometryExtent = lineString.getExtent();
	//Обрезаем линии по рамке
	var coordinates = lineString.getCoordinates();
	var intersects = Intersection.lineclip(coordinates, mapExtent);
	var geometry = undefined;
	var geometries = [];
	var resolution = WidgetMap.map.getView().getResolution();
	if(intersects && intersects.length > 0){
		geometry = new ol.geom.LineString(intersects[0], ol.geom.GeometryLayout.XY);
		geometryExtent = geometry.getExtent();
		//проверяем, что если линия меньше допустимого размера, то не выдаем её
		var lineD = Math.sqrt(ol.extent.getWidth(geometryExtent) * ol.extent.getWidth(geometryExtent) + ol.extent.getHeight(geometryExtent) * ol.extent.getHeight(geometryExtent));
		lineD /= resolution;
		//upd. 02.09.21 если длина линии меньше 30px(размер иконки для визуального сравнения), то подпись не выводим(нет смысла для труб выводить такую подпись)
		if (lineD >= 30 || !isPods)
			geometries.push(geometry);
	}
	if(geometries && geometries.length > 0)
		return geometries;
}


GeoUtil.getLineStringsByStartPoint = function(lineString, startPoint, textWidth, findSector){
	if(!lineString)
		return [];
	if(!findSector)findSector = 'right';
	var offset = 10; //увеличиваем у рамки область захвата
	//рамка вокруг точки
	var leftOffset = (findSector === 'left') ? textWidth + offset : 0;
	var rightOffset = (findSector === 'right') ? textWidth + offset : 0;
	var pointExtent = [startPoint[0] - leftOffset, startPoint[1] - textWidth - offset, startPoint[0] + rightOffset, startPoint[1] + textWidth + offset];
	//Обрезаем линии по рамке
	var coordinates = lineString.getCoordinates();
	var geometries = [];
	var intersects = Intersection.lineclip(coordinates, pointExtent);
	var geometry = undefined;

	if(intersects && intersects.length > 0) {
		geometry = new ol.geom.LineString(intersects[0], ol.geom.GeometryLayout.XY);
		geometries.push(geometry);
	}
	return geometries;
}

/**
 * Получение координаты на прямой по двум точкам и дистанции от 1-й точки
 * @param pnt1
 * @param pnt2
 * @param distance
 * @returns {*[]}
 */
GeoUtil.getCoordsByDistance = function(pnt1, pnt2, distance){
	if(!pnt1 || !pnt2) return;
	var theta = Math.atan2(pnt2[1] - pnt1[1], pnt2[0] - pnt1[0]);
	return [pnt1[0] + distance * Math.cos(theta), pnt1[1] + distance * Math.sin(theta)];
}




GeoUtil.rotateLineTextBy2Points = function (p1, p2) {
	var p1,p2, x, y;
	var tempP = p1;
	if (p1[0] > p2[0]) {
		p1 = p2;
		p2 = tempP;
	}
	var rotation = 0;
	if (p1 !== null && p2 !== null) {
		rotation = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) * 180 / Math.PI;
	}
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return [x, y, rotation];
};


/**
 * Разбиваем линию на отрезки, чтобы производить рисование подписи в рамках каждого отрезка.
 * Во время разбития возвращаем вектор подписи с корректным сдвигом по горизонтали.
 * TODO для вертикальных сдвигов пока принято решение не сдвигать
 * Зависимость от map_label_repeatRatio
 * @param {{startPoint: Array<number>, lineString: ol.geom.LineString}} startPointOptions
 * @param textObject
 * @param isCasUnits
 * @return {Array<map.renderer.vector.TextVector>}
 */
GeoUtil.composeTextVectorFromStartPoint = function(startPointOptions, textObject, isCasUnits, needTransform){
	if(!startPointOptions || startPointOptions.startPoint === undefined)
		return;
	var segmentCoords = [], lineString = startPointOptions.lineString, startPoint = startPointOptions.startPoint;
	var coords = lineString.getCoordinates();
	//переводим координаты линии в пикселы
	for(var i = 0; i < coords.length; i++) {
		var pnt = (needTransform !== false)?WidgetMap.map.getPixelFromCoordinate(coords[i]):coords[i];
		segmentCoords.push([pnt[0], pnt[1]]);
	}
	return GeoUtil.createTextVector(startPoint, segmentCoords, textObject, isCasUnits);
}

GeoUtil.getLength = function(coords){
	var length = -1;
	for(var i = 1; i < coords.length; i++) {
		var pnt1 = WidgetMap.map.getPixelFromCoordinate(coords[i - 1]);
		var pnt2 = WidgetMap.map.getPixelFromCoordinate(coords[i]);
		var distanceP1P2 = Math.sqrt(ol.coordinate.squaredDistance(pnt1, pnt2));
		length += distanceP1P2;
	}
	return length;
}

/**
 * Создание объекта вектора текста
 * @param startPoint начальная точка от которой начинать рисовать
 * @param segmentCoords
 * @param textObject
 * @param isCasUnits
 * @returns {map.renderer.vector.TextVector|undefined}
 */
GeoUtil.createTextVector = function(startPoint, segmentCoords, textObject, isCasUnits){
	if(!textObject)
		return;
	var textStyle = textObject.textStyle;
	var textWidth = textObject.textWidth;
	var textHeight = 12;
	var lineString = new ol.geom.LineString(null);
	lineString.setCoordinates(segmentCoords, ol.geom.GeometryLayout.XY);
	//пункт 5. Вращение. Определение второй точки вектора подписи
	var rotation = GeoUtil.rotateLineText(startPoint, lineString, textWidth);
	if(textObject.isTextObject){//если надпись
		rotation = GeoUtil.rotateLineTextObject(startPoint, lineString, textWidth);
	}
	if(isNaN(rotation))
		return;
	var x = startPoint[0];//координаты без смещения
	var y = startPoint[1];
	var bounds = [];//полигон
	var textProp = {
		rotation: rotation,
		textWidth: textWidth,
		textHeight: textHeight,
		text: textObject.text,
		isTextObject: textObject.isTextObject,
	};
	var text = textObject.text;
	var labelDrawType = LABEL_DRAW_TYPE;
	if (isCasUnits) labelDrawType = 'cas_units';
	if (labelDrawType === 'cut' ){
		var cutObj = GeoUtil.cutText(textProp, segmentCoords, x, y);
		if(!cutObj) return;
		text = cutObj.text;
		bounds = cutObj.bounds;
		var coordEnd = cutObj.coordEnd;
	}

	var textVector = new map.renderer.vector.TextVector({
		text: text, x: x, y: y, coordEnd: coordEnd,
		rotation: rotation,
		lineString: lineString,
		textStyle: textStyle,
		textWidth: textWidth,
		textHeight: textHeight,
		bounds: bounds,
	});

	return textVector;
}

/**
 * Функция выссчитывает начальное положение точки
 * @param lineString
 * @param align
 * @param mapWidth
 * @returns {{startPoint: Array<number>, lineString: ol.geom.LineString}}
 */
GeoUtil.alignText = function(lineString, align, mapWidth, textWidth, text){
	//var textAlign = align || 'center';
	var textAlign = 'center';
	var p1;
	var tries = 1;
	if(textAlign === 'center'){
		p1 = lineString.getFlatMidpoint();//GeoUtil.findCenter(lineString, distance);
		p1 = WidgetMap.map.getPixelFromCoordinate(p1);
		//получение начальной точки, чтобы подпись рисовалась ровно по центру
		var startPointObj = GeoUtil.getRealStartPoint(lineString, p1, textWidth, text);
		if(startPointObj && startPointObj.startPoint){
			p1 = startPointObj.startPoint;
			tries = startPointObj.tries;
		}
	}
	return {startPoint: p1, lineString: lineString, tries:tries};
}

GeoUtil.alignTextObject = function(lineString, align){
	var textAlign = align || 'right';
	var p1, p2;
	if(textAlign === 'left'){
		p1 = WidgetMap.map.getPixelFromCoordinate([lineString.flatCoordinates[0], lineString.flatCoordinates[1]]);
		/*p2 =  lineString.flatCoordinates[lineString.flatCoordinates.length - 1];
		if(p1[0] > p2[0])
			p1 = p2;*/
	}
	/*if(textAlign === 'right'){
		p1 = lineString.flatCoordinates[lineString.flatCoordinates.length - 1];
		p2 = lineString.flatCoordinates[0];
		if(p1[0] > p2[0])
			p1 = p2;
	}*/
	return {startPoint: p1, lineString: lineString, tries:1};
}

/**
 * Функция получения реального центра линии, чтобы подпись рисовалась ровно по центру
 * @param fLineString
 * @param center
 * @param radius
 */
GeoUtil.getRealStartPoint = function(fLineString, center, radius, text){
	var coords = fLineString.getCoordinates();
	//переводим координаты линии в пикселы
	var segmentCoords = [];
	for(var i = 0; i < coords.length; i++) {
		var pnt = WidgetMap.map.getPixelFromCoordinate(coords[i])
		segmentCoords.push([pnt[0], pnt[1]]);
	}
	var lineString = new ol.geom.LineString(null);
	lineString.setCoordinates(segmentCoords, ol.geom.GeometryLayout.XY);
	//проводим поиск точек пересечения сначала в левой части
	var textWidth = radius;
	var startPoint = GeoUtil.getPointOnLineByCenterAndRadius(center, lineString, textWidth/2, 'left');
	var tries = 1; //попытки обрезки
	//доп. проверка. если не нашли точку стартовую, то сокращаем размер подписи и пытаемся найти заново
	if(startPoint === undefined){
		for(var i = 0; i < 3; i++){
			textWidth -= textWidth * LABEL_CUT_RATIO;
			startPoint = GeoUtil.getPointOnLineByCenterAndRadius(center, lineString, textWidth/2, 'left');
			tries++;
			if(startPoint !== undefined)
				break;
		}
	}
	if(startPoint === undefined)
		return undefined;
	return {startPoint: startPoint, tries: tries};
	//если не нашли в левой части - ищем внизу
}


/**
 *
 * @param startPoint
 * @param fLineString
 * @param textWidth
 * @param findSector сектор, в котором ищется точки пересечения  left|right|top|bottom
 * @returns {number[]}
 */
GeoUtil.getPointOnLineByCenterAndRadius = function(startPoint, fLineString, textWidth, findSector){
	if(!findSector) findSector = 'right';
	//формируем рамку у начальной точки, как по ширине подписи * 2( 2 * R )
	var subLineStrings = GeoUtil.getLineStringsByStartPoint(fLineString, startPoint, textWidth, findSector);
	//проходимся по сегментам и ищем точки пересечения с отрезками сегментов
	var intersectPoints = [];
	for(var i = 0; i < subLineStrings.length; i++){
		var subLineString = subLineStrings[i];
		var subLineStringCoords = subLineString.getCoordinates();
		for(var j = 0; j < subLineStringCoords.length - 1; j++){
			//получаем отрезок и ищем точки пересечения
			var segment = [subLineStringCoords[j], subLineStringCoords[j + 1]];
			var segmentIntersects  = GeoUtil.intersectCircleAndSegment(segment, startPoint, textWidth)
			if(!segmentIntersects)
				continue;
			var segmentString = new ol.geom.LineString(null);
			segmentString.setCoordinates(segment, ol.geom.GeometryLayout.XY);
			//получили рамку отрезка, чтобы при выборке на те пересечения, которые попадают в рамку
			var segmentExtent = segmentString.getExtent();
			var intersects = GeoUtil.getIntersectionBetweenCircleAndLine(segmentString, startPoint, textWidth);
			if(intersects)
				intersects.forEach(function(point){
					//пункт 5.2 из массива точек убираем точки левее, т.е. оставляем точки только в правом секторе
					if (findSector === 'right' && point[0] >= startPoint[0]){
						var pointExtent = [point[0],point[1],point[0],point[1]];
						if(ol.extent.intersects(pointExtent, segmentExtent))
							intersectPoints.push(point);
					}
					if (findSector === 'left' && point[0] <= startPoint[0]){
						var pointExtent = [point[0],point[1],point[0],point[1]];
						if(ol.extent.intersects(pointExtent, segmentExtent))
							intersectPoints.push(point);
					}
				});
		}
	}
	//пункт 5.3 сортируем оставшиеся точки и выбираем максимальный Y
	var secondPoint = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
	intersectPoints.forEach(function(point){
		if(point[1] >= secondPoint[1])
			secondPoint = point;
	});

	//если не нашли при повороте точку пересечения с отрезком
	if(secondPoint[0] === Number.NEGATIVE_INFINITY || secondPoint[1] === Number.NEGATIVE_INFINITY)
		return;
	return secondPoint;
}

/**
 * Поворот подписи по начальной точке
 * @param startPoint начальная точка
 * @param fLineString линий, на которой подпись рисуется
 * @param textWidth
 * @returns {number}
 */
GeoUtil.rotateLineText = function (startPoint, fLineString, textWidth) {
	var secondPoint = GeoUtil.getPointOnLineByCenterAndRadius(startPoint, fLineString, textWidth);
	if(secondPoint === undefined){
		for(var i = 0; i < 3; i++){
			textWidth -= textWidth * LABEL_CUT_RATIO;
			secondPoint = GeoUtil.getPointOnLineByCenterAndRadius(startPoint, fLineString, textWidth);
			if(secondPoint !== undefined)
				break;
		}
	}
	if(secondPoint === undefined)
		return NaN;

	var rotation = Math.atan2(secondPoint[1] - startPoint[1], secondPoint[0] - startPoint[0]) * 180 / Math.PI;
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return rotation;
};

/**
 * Поворот подписи по начальной точке
 * @param startPoint начальная точка
 * @param fLineString линий, на которой подпись рисуется
 * @param textWidth
 * @returns {number}
 */
GeoUtil.rotateLineTextObject = function (startPoint, fLineString, textWidth) {
	var lineCoords =  fLineString.getCoordinates();
	var secondPoint = lineCoords[lineCoords.length - 1];
	var rotation = Math.atan2(secondPoint[1] - startPoint[1], secondPoint[0] - startPoint[0]) * 180 / Math.PI;
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return rotation;
};

/**
 * Поворот подписи вдоль линии
 * @param segmentCoords
 * @param width
 * @param height
 * @param vAlign
 * @param hAlign
 * @param distance
 * @returns {[number, number, number]}
 */
GeoUtil.rotateLineText1 = function (segmentCoords, width, height, vAlign, hAlign, distance, offset) {
	hAlign = 'center';
	if(!segmentCoords || segmentCoords.length < 2)
		return;
	//меняем порядок координат, чтобы отсчет был слева направо
	if(segmentCoords[0][0] > segmentCoords[segmentCoords.length - 1][0])
		segmentCoords = segmentCoords.reverse();
	var p1,p2, newSegments = segmentCoords;// новый массив сегментов, чтобы начинать пересчет с середины
	//TODO принято решение пока для подписей линий не двигать по вертикали
	//vAlign = 'middle';
	var fObj //найденный объект
	if(hAlign === 'left')
		fObj = GeoUtil.findLeft(segmentCoords, distance);
	if(hAlign === 'center')
		fObj = GeoUtil.findCenter(segmentCoords, distance);
	if(hAlign === 'right')
		fObj = GeoUtil.findRight(segmentCoords, distance);
	if(fObj[0][0] > fObj[1][0]){
		var temp = fObj[1];
		fObj[1] = fObj[0];
		fObj[0] = temp;
	}
	p1 = fObj[0];
	p2 = fObj[1];
	newSegments = fObj[2];
	var rotation = 0;
	if (p1 !== null && p2 !== null) {
		rotation = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) * 180 / Math.PI;
		if(Math.abs(rotation) < 1)
			rotation = 0;
	}
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return [p1[0], p1[1], rotation, newSegments];
};
GeoUtil.findCenter = function(lineString, distance){
	var p1 = lineString.getFlatMidpoint();
	return p1;
	var p2 = lineString.getCoordinateAt(0.51);//ищем след точку с небольшим сдвигом, для поиска поворота
	var newSegments = GeoUtil.splitLinestringAtCoordinate(lineString, p1, distance);
	if(distance){
		p1 = newSegments[0];
		p2 = GeoUtil.getCoordsByDistance(newSegments[0], newSegments[1], 30);//10px
	}
	return [p1, p2, newSegments];
}
/*GeoUtil.findCenter = function(coords, distance){
	var lineString = new ol.geom.LineString(coords, ol.geom.GeometryLayout.XY)//линия их координат в пикселях
	var p1 = lineString.getFlatMidpoint();
	var p2 = lineString.getCoordinateAt(0.51);//ищем след точку с небольшим сдвигом, для поиска поворота
	var newSegments = GeoUtil.splitLinestringAtCoordinate(lineString, p1, distance);
	if(distance){
		p1 = newSegments[0];
		p2 = GeoUtil.getCoordsByDistance(newSegments[0], newSegments[1], 30);//10px
	}
	return [p1, p2, newSegments];
}*/
GeoUtil.findLeft = function(coords, distance){
	var lineString = new ol.geom.LineString(coords, ol.geom.GeometryLayout.XY)//линия их координат в пикселях
	var p1 = coords[0];
	var p2 = lineString.getCoordinateAt(0.01);
	var newSegments = GeoUtil.splitLinestringAtCoordinate(lineString, p1, distance);
	if(distance) {
		p1 = newSegments[0];
		p2 = GeoUtil.getCoordsByDistance(newSegments[0], newSegments[1], 30);//10px
	}
	return [p1, p2, newSegments];
}
GeoUtil.findRight = function(coords, distance){
	var lineString = new ol.geom.LineString(coords, ol.geom.GeometryLayout.XY)//линия их координат в пикселях
	var p1 = lineString.getCoordinateAt(0.99);
	var p2 = coords[coords.length - 1]
	var newSegments = GeoUtil.splitLinestringAtCoordinate(lineString, p1, distance);
	if(distance){
		p1 = newSegments[0];
		p2 = GeoUtil.getCoordsByDistance(newSegments[0], newSegments[1], 30);//10px
	}
	return [p1, p2, newSegments];
}

GeoUtil.splitLinestringAtCoordinate = function(lineString, p1, dist){
	var geometry = /** @type {ol.geom.LineString} */lineString;
	var lineLength = lineString.getLength() / 2;
	var coordinates = geometry.getCoordinates();
	var newLineString = [];
	var distance = 0;
	if(dist){
		//если известна дистанция, то ищем точку
		lineLength = dist;
		for (var i = 1; i < coordinates.length; i++) {
			var pnt1 = coordinates[i - 1];
			var pnt2 = coordinates[i];
			distance += Math.sqrt(ol.coordinate.squaredDistance(pnt1, pnt2));
			if (distance >= dist) {
				p1 = GeoUtil.getCoordsByDistance(pnt1, pnt2, dist);
				break;
			}
		}
	}
	//точка старта найдена, теперь режем линию
	newLineString.push(p1);
	distance = 0;
	for (var i = 1; i < coordinates.length; i++) {
		var pnt1 = coordinates[i - 1];
		var pnt2 = coordinates[i];
		distance += Math.sqrt(ol.coordinate.squaredDistance(pnt1, pnt2));
		if (distance >= lineLength) {
			newLineString.push(pnt2);
		}
	}
	if(newLineString.length < 2)
		newLineString.push(coordinates[coordinates.length - 1]);
	return newLineString;
}


/**
 * Функция обрезки текста вдоль линии, если
 * @param textFeature
 * @param lineCoordinates
 * @param x
 * @param y
 * @returns {Object|*}
 */
GeoUtil.cutText = function (textFeature, lineCoordinates, x, y ) {
	var closestSegment1;
	var rotation = textFeature.rotation;
	var textWidth = textFeature.textWidth;
	var textHeight = textFeature.textHeight;
	var text = textFeature.text;
	var isTextObject = textFeature.isTextObject;
	var charWidth = textWidth / text.length;
	var textInp = '';
	var coordsEndPixel = [x + Math.cos(rotation) * textWidth, y + Math.sin(rotation) * textWidth];
	var closestDistance = Number.MAX_VALUE;
	var coordStart = [x, y];
	var coordEnd = coordsEndPixel;
	for (var j = 0; j < 3; j++) {
		if(isTextObject) break;
		coordsEndPixel = [x + Math.cos(rotation) * textWidth, y + Math.sin(rotation) * textWidth];
		closestDistance = Number.MAX_VALUE;
		for (var i = 0; i < lineCoordinates.length - 1; ++i) {
			closestSegment1 = [lineCoordinates[i], lineCoordinates[i + 1]];
			var coordsClosestPixel = ol.coordinate.closestOnSegment(coordsEndPixel, closestSegment1);
			var dist = GeoUtil.Distance(coordsClosestPixel, coordsEndPixel);
			if (dist < closestDistance)
				closestDistance = dist;
		}
		if (closestDistance < LABEL_CUT_TOLERANCE){
			textInp =  (textInp) ? textInp : text;
			coordEnd = coordsEndPixel;
			var bounds = GeoUtil.calcTextBounds(coordStart, coordEnd, rotation, textHeight, textWidth);
			coordEnd = GeoUtil.getCoordEnd([x, y], textWidth, lineCoordinates, coordEnd);
			return {text: textInp, coordStart: coordStart, coordEnd: coordEnd, bounds: bounds};
		}
		if (j === 2)
			return;
		textWidth -= textFeature.textWidth * LABEL_CUT_RATIO;
		var charCount = (textWidth / charWidth).toFixed(0) - 3;// -3 символа для '...'
		if (charCount > 4) //Выводим подпись, только если вмещается 5 символов
			textInp = text.slice(0, charCount) + '...';
	}
	textInp = text;
	var bounds = GeoUtil.calcTextBounds(coordStart, coordEnd, rotation, textHeight, textWidth);
	coordEnd = GeoUtil.getCoordEnd([x, y], textWidth, lineCoordinates, coordEnd);
	return {text: textInp, coordStart: coordStart, coordEnd: coordEnd, bounds: bounds};
};

//ищем начало следующего сдвинутого вектора на расттроянии половины подписи от начала старого вектора
// корректировка алгоритма. при коллизии берем не последнюю координату подписи, а середину
GeoUtil.getCoordEnd = function(startPoint, textWidth, lineCoordinates, baseCoordEnd){
	var lineString = new ol.geom.LineString(null);
	lineString.setCoordinates(lineCoordinates, ol.geom.GeometryLayout.XY);
	var coordEnd = GeoUtil.getPointOnLineByCenterAndRadius(startPoint, lineString, textWidth/2);
	if(coordEnd !== undefined)
		return coordEnd;
	return baseCoordEnd;
}


GeoUtil.calcTextBounds = function(coordStart, coordEnd, rotation, textHeight, textWidth){
	var leftTop, leftBottom, rightTop, rightBottom;
	leftTop = [Math.round(coordStart[0]), Math.round(coordStart[1] - textHeight/2)];
	leftBottom = [Math.round(coordStart[0]), Math.round(coordStart[1] + textHeight/2)];
	rightTop = [Math.round(leftTop[0] + Math.cos(rotation) * textWidth), Math.round(leftTop[1] + Math.sin(rotation) * textWidth)];
	rightBottom = [Math.round(leftBottom[0] + Math.cos(rotation) * textWidth), Math.round(leftBottom[1] + Math.sin(rotation) * textWidth)];

	var polygon = new ol.geom.Polygon(null);
	var linearRing = new ol.geom.LinearRing(null);
	linearRing.setCoordinates([leftTop, leftBottom, rightBottom, rightTop, leftTop ], ol.geom.GeometryLayout.XY);
	polygon.appendLinearRing(linearRing);
	return polygon;
}


/**
 * Функция фильтрации сегментов, что оставляем самый длинный
 * @param lines
 * @param lay
 * @returns {{}}
 */
GeoUtil.filterSegments = function(lines, lay){
	var filteredLines = {};
	for(var t = 0; t < lines.length; t++){
		var lineObj = lines[t];
		var lineId = lineObj.labelObj.id;
		var realId = (lineId.split('|').length > 1) ? lineId.split('|')[1] : lineId;
		var line = lineObj.lineString;
		var text = lineObj.labelObj.label;
		if(!text){
			if(lay && lay.layer && lay.layer.semanticUniqData && lay.layer.semanticUniqData[realId]) {
				text = lay.layer.semanticUniqData[realId].label;
			}
		}
		if(!text)
			continue;
		filteredLines[lineId + App.generateUUID()] = {
			lineString: line,
			lineStringLength: line.getLength(),
			text: text,
		}
	}
	return filteredLines;
}


/**
 * Продвинутая проверка коллизии. Помимо поиска попадания произвольного прямоугольника(с поворотами) возвращаеются свободные и занятые ячейки
 * @param {map.renderer.vector.TextVector} textVector
 * @returns {{result: boolean, collisionCells: *[], freeCells: *[]}}
 */
GeoUtil.hasComplexTextCollision = function(textVector, force){
	var type = 'label';
	var freeCells = [], collisionCells = [];
	var matrix = _visibleTextMatrix[type];
	if(!textVector || !matrix)
		return {hasCollision: true, freeCells: freeCells, collisionCells: collisionCells};
	var bounds = textVector.bounds; //Polygon
	var intersectMatrix = GeoUtil.findMatrixIntersection(bounds, matrix);
	freeCells = intersectMatrix.freeCells;
	collisionCells = intersectMatrix.collisionCells;
	return {hasCollision: collisionCells.length !== 0, freeCells: freeCells, collisionCells: collisionCells};
};

GeoUtil.addComplexText = function(feature, textVector, freeCells){
	//Считаем координату х смещенной на _matrixAddWidth, а координату y смещенной на _matrixAddHeight,
	//поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
	var layerId = feature.get('labelType');
	var type = 'label';
	var matrix = _visibleTextMatrix[type];
	var coord = WidgetMap.map.getCoordinateFromPixel([textVector.x, textVector.y]);
	var unique = layerId+'_'+coord[0]+'_'+coord[1];
	var sav = {
		priority: 0,
		obj: feature,
		unique: unique,
	};
	if(freeCells && freeCells.length > 0 ){
		freeCells.forEach(function(el){
			var i = el[0], j = el[1];
			matrix[i][j] = sav;
		});
	}
	return unique;
}

/**
 * поиск смещения по матрице коллизий
 * @param collisionCells
 * @returns {number}
 */
GeoUtil.findOffsetDistanceByCollision = function(collisionCells){
	//если нашли коллизии, то начинаем считать сдвиг
	var nxGr = [], nyGr = [];
	for(var col in collisionCells){
		if(nxGr.indexOf(collisionCells[col][0]) === -1)
			nxGr.push(collisionCells[col][0]);
		if(nyGr.indexOf(collisionCells[col][1]) === -1)
			nyGr.push(collisionCells[col][1]);
	}
	var dist = Math.sqrt((nxGr.length * _dx) * (nxGr.length * _dx) + (nyGr.length * _dy) * (nyGr.length * _dy));//гипотенуза
	return dist;
}

/**
 * Поиск пересечений и свободных ячеек в матрице текстовых подписей
 * @param bounds
 * @param matrix
 */
GeoUtil.findMatrixIntersection = function(bounds, matrix){
	var i, j,
		freeCells = [], collisionCells = [];
	var extent = bounds.getExtent();
	//высчитываем min/max от extent полигона
	var min_x = Math.floor(extent[0]/_dx);
	var min_y = Math.floor(extent[1]/_dy);
	var max_y = Math.floor((extent[1] + ol.extent.getHeight(extent))/_dy);
	var max_x = Math.floor((extent[0] + ol.extent.getWidth(extent))/_dx);

	if (min_x < 0 || min_y < 0 || max_x >= matrix.length || max_y >= matrix[0].length)
		return {freeCells: freeCells, collisionCells: collisionCells};
	try{
		for (j = min_y; j <= max_y; j++){
			for (i = min_x; i <= max_x; i++){
				var cellExtent = [i * _dx, j * _dy, i * _dx + _dx,  j * _dy + _dy];
				//если подпись пересекает ячейку, то проверяем, есть ли в ней уже подпись
				if (bounds.intersectsExtent(cellExtent)){
					//если в ячейке ничего нет
					if (matrix[i] && !matrix[i][j]){
						freeCells.push([i, j]);
					}
					else{
						collisionCells.push([i, j]);
					}
				}
			}
		}
	}
	catch(ex){ }
	return {freeCells: freeCells, collisionCells: collisionCells};
}

GeoUtil.findNearestPoint = function(lineCoordinates, point){
	var closestPoint = point;
	var closestSegment, closestDistance = Number.MAX_VALUE;
	var index = -1;
	for (var k = 0; k < lineCoordinates.length - 1; ++k) {
		closestSegment = [lineCoordinates[k], lineCoordinates[k + 1]];
		var closestFirstProj = ol.coordinate.closestOnSegment(point, closestSegment);
		if (GeoUtil.Distance(closestFirstProj, point) < closestDistance){
			closestDistance = GeoUtil.Distance(closestFirstProj, point);
			closestPoint = closestFirstProj;
			index = k;
		}
	}
	return [closestPoint, index];
}


/**
 * Получение текста средствами canvas.context либо попытка посчитать примерную ширигу текста по размеру символа
 * @param text текст
 * @param textStyle стиль текстовой подписи
 * @param context контекст карты
 */
GeoUtil.getTextWidth = function(text, textStyle, context){
	var textWidth = 89;
	if(context){
		context.font = textStyle.getFont();
		textWidth = context.measureText(text).width;
	}
	else{
		var charWidth = 6;
		textWidth = text.length * charWidth;
	}
	return textWidth;
}

GeoUtil.getDefaultTextWidth = function(text, context){
	var textWidth = 89;
	if(context){
		context.font = 'normal 13px Times New Roman';
		textWidth = context.measureText(text).width;
	}
	else{
		var charWidth = 6;
		textWidth = text.length * charWidth;
	}
	return textWidth;
}

/**
 * Проверка, пересекает ли отрезок окружность
 * @param segment
 * @param center
 * @param radius
 */
GeoUtil.intersectCircleAndSegment = function(segment, center, radius){
	var x1 = segment[0][0],
		y1 = segment[0][1],
		x2 = segment[1][0],
		y2 = segment[1][1],
		xC = center[0],
		yC = center[1];

	var r1 = Math.sqrt(Math.pow(xC-x1, 2) + Math.pow(yC-y1, 2));
	var r2 = Math.sqrt(Math.pow(xC-x2, 2) + Math.pow(yC-y2, 2));
	if((r1 >= radius && r2 < radius) || (r1 < radius && r2 >= radius))
		return true;
	return false;

	x1 -= xC;
	y1 -= yC;
	x2 -= xC;
	y2 -= yC;

	var dx = x2 - x1;
	var dy = y2 - y1;
	//составляем коэффициенты квадратного уравнения на пересечение прямой и окружности.
	//если на отрезке [0..1] есть отрицательные значения, значит отрезок пересекает окружность
	var a = dx * dx + dy * dy;
	var b = 2 * (x1 * dx + y1 * dy);
	var c = x1 * x1 + y1 * y1 - radius * radius;

	//а теперь проверяем, есть ли на отрезке [0..1] решения
	if (-b < 0)
		return (c < 0);
	if (-b < (2 * a))
		return ((4 * a * c - b * b) < 0);

	return (a + b + c < 0);
	/*var b, c, d, v1, v2;
	v1 = {};
	v2 = {};
	v1.x = segment[1][0] - segment[0][0];
	v1.y = segment[1][1] - segment[0][1];
	v2.x = segment[0][0] - center[0];
	v2.y = segment[0][1] - center[1];
	b = (v1.x * v2.x + v1.y * v2.y);
	c = 2 * (v1.x * v1.x + v1.y * v1.y);
	b *= -2;
	d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - radius * radius));
	if(isNaN(d)){ // no intercept
		return false
	}
	return true;*/
	/*var x = x1 * (1 - t) + x2 * t;
	var y = y1 * (1 - t) + y2 * t
	var s = (x1 * (1 - t) + x2 * t)^2 + (y1 * (1 - t) + y2 * t) ^2 = R^2;*/
}


/**
 * Получение точки пересечения между линией и окружностью
 * @param lineString
 * @param center
 * @param radius
 * @returns {*}
 */
GeoUtil.getIntersectionBetweenCircleAndLine = function(lineString, center, radius){
	var intersect = function(center, k, b, radius){
		//находим дискрименант квадратного уравнения
		var x = center[0], y = center[1];
		var d = (Math.pow((2 * k * b - 2 * x - 2 * y * k), 2) - (4 + 4 * k * k) * (b * b - radius * radius + x * x + y * y - 2 * y * b));
		//если он меньше 0, уравнение не имеет решения
		if(d < 0)
			return;
		//иначе находим корни квадратного уравнения
		var x1 = ((-(2 * k * b - 2 * x - 2 * y * k) - Math.sqrt(d)) / (2 + 2 * k * k));
		var x2 = ((-(2 * k * b - 2 * x - 2 * y * k) + Math.sqrt(d)) / (2 + 2 * k * k));
		var y1 = k * x1 + b;
		var y2 = k * x2 + b;
		//если абсциссы точек совпадают, то пересечение только в одной точке
		if (x1 === x2)
			return [[x1, y1]];
		return [ [x1, y1], [x2, y2]];
	}
	if(lineString){
		var coords = lineString.getCoordinates();
		for(var i = 1; i < coords.length; i++){
			var p1 = coords[i - 1];
			var p2 = coords[i];
			var x1 = p1[0], x2 = p2[0],
				y1 = p1[1], y2 = p2[1],
				k, b;
			(x1 === x2) ? k = (y1 - y2) / (x1) : k = (y1 - y2) / (x1 - x2);
			b = y1 - k * x1;
			var intersection = intersect(center, k, b, radius);
			if(intersection && intersection.length > 0){
				return intersection;
			}
		}
	}
}
var Intersection = {};
//https://github.com/mapbox/lineclip#lineclippolylinepoints-bbox-result
// Cohen-Sutherland line clippign algorithm, adapted to efficiently
// handle polylines rather than just segments
Intersection.lineclip = function(points, bbox, result) {
	var len = points.length,
		codeA = Intersection.bitCode(points[0], bbox),
		part = [],
		i, a, b, codeB, lastCode;

	if (!result) result = [];

	for (i = 1; i < len; i++) {
		a = [points[i - 1][0],points[i - 1][1]];
		b = [points[i][0], points[i][1]];
		codeB = lastCode = Intersection.bitCode(b, bbox);

		while (true) {

			if (!(codeA | codeB)) { // accept
				part.push(a);

				if (codeB !== lastCode) { // segment went outside
					part.push(b);

					if (i < len - 1) { // start a new line
						result.push(part);
						part = [];
					}
				} else if (i === len - 1) {
					part.push(b);
				}
				break;

			} else if (codeA & codeB) { // trivial reject
				break;

			} else if (codeA) { // a outside, intersect with clip edge
				a = Intersection.intersect(a, b, codeA, bbox);
				codeA = Intersection.bitCode(a, bbox);

			} else { // b outside
				b = Intersection.intersect(a, b, codeB, bbox);
				codeB = Intersection.bitCode(b, bbox);
			}
		}

		codeA = lastCode;
	}

	if (part.length) result.push(part);

	return result;
}

// Sutherland-Hodgeman polygon clipping algorithm

/*function polygonclip(points, bbox) {

	var result, edge, prev, prevInside, i, p, inside;

	// clip against each side of the clip rectangle
	for (edge = 1; edge <= 8; edge *= 2) {
		result = [];
		prev = points[points.length - 1];
		prevInside = !(bitCode(prev, bbox) & edge);

		for (i = 0; i < points.length; i++) {
			p = points[i];
			inside = !(bitCode(p, bbox) & edge);

			// if segment goes through the clip window, add an intersection
			if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));

			if (inside) result.push(p); // add a point if it's inside

			prev = p;
			prevInside = inside;
		}

		points = result;

		if (!points.length) break;
	}

	return result;
}*/

// intersect a segment against one of the 4 lines that make up the bbox

Intersection.intersect = function(a, b, edge, bbox) {
	return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
		edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
			edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
				edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : null; // left
}

// bit code reflects the point position relative to the bbox:
//         left  mid  right
//    top  1001  1000  1010
//    mid  0001  0000  0010
// bottom  0101  0100  0110

Intersection.bitCode = function(p, bbox) {
	var code = 0;

	if (p[0] < bbox[0]) code |= 1; // left
	else if (p[0] > bbox[2]) code |= 2; // right

	if (p[1] < bbox[1]) code |= 4; // bottom
	else if (p[1] > bbox[3]) code |= 8; // top

	return code;
}



GeoUtil.getFontSizeByZoom = function(textWidth){
	var zoom = WidgetMap.map.getView().getZoom();
	//var coeff = 13/11;
	//var coeff = 1.75;
	var coeff = 2;

	/*var f = WidgetMap.DEFALT_FONT_SIZE;
	if(zoom > WidgetMap.DEFALT_ZOOM_FOR_FONT){
		f = Math.abs((WidgetMap.DEFALT_ZOOM_FOR_FONT - zoom) * coeff);
	}
	if(zoom < WidgetMap.DEFALT_ZOOM_FOR_FONT){
		f = Math.abs((WidgetMap.DEFALT_ZOOM_FOR_FONT - zoom) / coeff);
	}
	return f;*/
	var fontObj = {
		21: WidgetMap.DEFALT_FONT_SIZE * (Math.pow(coeff, Math.abs(WidgetMap.DEFALT_ZOOM_FOR_FONT - zoom))),//coeff * coeff * coeff,
		20: WidgetMap.DEFALT_FONT_SIZE * coeff * coeff,
		19: WidgetMap.DEFALT_FONT_SIZE * coeff,
		18: WidgetMap.DEFALT_FONT_SIZE,
		17: WidgetMap.DEFALT_FONT_SIZE / coeff,
		16: WidgetMap.DEFALT_FONT_SIZE / coeff / coeff ,
		15: WidgetMap.DEFALT_FONT_SIZE / coeff / coeff / coeff,
	}
	/*var fontObj = {
		21: 28,
		20: 22,
		19: 16.9,
		18: 13,
		17: 10,
		16: 7,
		15: 6,
		14: 4,
		13: 3,
	}*/
	return fontObj[zoom] || 1;
}
GeoUtil.getOffsetByZoom = function(){
	var zoom = WidgetMap.map.getView().getZoom();
	var offset = 10;
	return 0;
	switch (zoom){
		case 18:
			offset = 10;
			break;
		case 17:
			offset = 5;
			break;
		case 16:
			offset = 2;
			break;
		case 15:
			offset = 0;
			break;
		case 13:
			offset = 5;
			break;
		default:
			offset = 5;
			break;
	}
	return offset;
}
/* Глобальный объект с функциями для ожидания и блокировки */
BlockingUtil = {};

//Признак, что часики крутятся
BlockingUtil._isWaiting = false;
BlockingUtil._waitCount = 0;
//Признак, что грузится геометрия
BlockingUtil._isWaitingGeo = false;
BlockingUtil._waitCountGeo = 0;
//Признак, что приложение заблокировано
BlockingUtil._isBlocked = false;
BlockingUtil._blockCount = 0;

//Добавляем часики
BlockingUtil.wait = function() {
    BlockingUtil._isWaiting = true;
    BlockingUtil._waitCount += 1;
    //Устанавливаем курсор ожидания
    $("body").css("cursor", "progress");
};

BlockingUtil.waitGeo = function() {
	BlockingUtil._isWaitingGeo = true;
	BlockingUtil._waitCountGeo += 1;
	//Устанавливаем показываем лоадер
    if(goog.isDef(WidgetMap) && goog.isDef(WidgetMap.geometryLoaderControl))
	    WidgetMap.geometryLoaderControl.setVisible(true);
};
BlockingUtil.readyGeo = function() {
	BlockingUtil._waitCountGeo -= 1;
	if (BlockingUtil._waitCountGeo <= 0) {
		BlockingUtil._waitCountGeo = 0;
		BlockingUtil._isWaitingGeo = false;
		//прячем лоадер
		if(goog.isDef(WidgetMap) && goog.isDef(WidgetMap.geometryLoaderControl))
			WidgetMap.geometryLoaderControl.setVisible(false);
	}
};

//Убираем часики
BlockingUtil.ready = function() {
    BlockingUtil._waitCount -= 1;
    if (BlockingUtil._waitCount <= 0) {
        BlockingUtil._waitCount = 0;
        BlockingUtil._isWaiting = false;
        //Устанавливаем обычный курсор
        $("body").css("cursor", "default");
        /* Для проверки курсора ожидания делаем задержку перед восстановлением */
        /*setTimeout(function (){
         $("body").css("cursor", "default");
         },5000);*/
    }
};

//Ставим блокировку на приложение
BlockingUtil.blockApplication = function() {
    BlockingUtil._isBlocked = true;
    BlockingUtil._blockCount += 1;
    //Добавляем div, который закрывает собой все приложение (сквозь него не проходят никакие события)
    var overlayDiv = '<div class="applicationBlockOverlay"></div>';
    $("body").append(overlayDiv);
};

//Снимаем блокировку с приложения (если не было других блокировок, мы их накапливаем)
BlockingUtil.unblockApplication = function() {
    BlockingUtil._blockCount -= 1;
    if (BlockingUtil._blockCount <= 0) {
        BlockingUtil._blockCount = 0;
        BlockingUtil._isBlocked = false;
        //Убираем div, который закрывает собой все приложение (сквозь него не проходят никакие события)
        $(".applicationBlockOverlay").remove();
        /* Для проверки блокировки приложения делаем задержку перед восстановлением */
        /*setTimeout(function (){
         $(".applicationBlockOverlay").remove();
         },5000);*/
    }
};


//Глобальный объект
HTTPServiceUtil = {};



HTTPServiceUtil.getLoginError = function (error, login) {
    if(error && error.indexOf(gis_httpserviceutil_2) !== -1)
        return gis_httpserviceutil_3+login;
    return error;
}
HTTPServiceUtil.getError = function getError(result/*Object*/) {
    var innXML;
    var errorObjectStr = '[object Object]';
    var resultErrorString = '';
    try {
        if (typeof result === 'string') {
            var resultStr = result.toString();
            if (resultStr.indexOf("<error") >= 0 || resultStr.indexOf("<critic_errors>") >= 0 ) {
                innXML = $(resultStr);//try to make xml from string
                if (innXML && innXML.length>0 && (innXML[0].nodeName.toLowerCase() === "error" || innXML[0].nodeName.toLowerCase() === "critic_errors")) {
                    resultErrorString = resultStr.replace("<error>", '').replace("</error>", '');
                    //Заменяем в результирующей строке xml-escaped последовательности на корректные читаемые символы
                    resultErrorString = resultErrorString.replace(/&apos;/g, "'").replace(/&quot;/g, '"').replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&amp;/g, '&');
                    if(resultErrorString.indexOf(errorObjectStr) !== -1)
                        return resultStr;
                    return resultErrorString;
                }
                //Иначе ищем в дочерних элементах
                var innChildErr = innXML.find("error, critic_errors");
                if (innChildErr && innChildErr.length > 0) {
                    return resultStr;
                }
            }
            if (resultStr.indexOf("error=") >= 0)
            {
                innXML = $(resultStr);//try to make xml from string
                var innAttrErr = innXML.find("[error]");
                if (innAttrErr && innAttrErr.length>0)
                    return resultStr;
            }
            if(resultStr.indexOf("&lt;error&gt;") >= 0 || resultStr.indexOf("&lt;critic_errors&gt;") >= 0)
                return resultStr;
            if(resultStr.indexOf("503 Service Unavailable") >= 0 || resultStr.indexOf("Service Unavailable") >= 0){
                return App.SERVER_ERRORS['Service Unavailable']+' . details=' + resultStr;
            }
            if(resultStr.indexOf("500 Internal Server Error") >= 0 || resultStr.indexOf("Internal Server Error") >= 0) {
                return App.SERVER_ERRORS['Internal Server Error'] + ' . details=' + resultStr;
            }
        }
        if (result instanceof jQuery) {
            var errorsArr = result.find("error, critic_errors, [error]");
            if (errorsArr !== undefined && errorsArr && errorsArr.length > 0){
                resultErrorString = HTTPServiceUtil.xmlToString(result);
                if(resultErrorString.indexOf(errorObjectStr) !== -1)
                    return resultStr;
                return resultErrorString;
            }
        }
    } catch (e) { }

    return resultErrorString;
};

/* Возвращает объект jQuery (XML)*/
HTTPServiceUtil.getXMLData = function getXMLData(result/*XML*/) {
    var res;
    try
    {
        res = $(result);
    }
    catch(e)
    {
        App.errorReport(gis_httpserviceutil_1+e, result.toString(), undefined, {filename:gis_filename_611, functionname:'gis_filename_611_1'});
        return null;
    }
    return res;
};

HTTPServiceUtil.getStringData = function getStringData(result/*XML*/) {
    return result.toString();
};

HTTPServiceUtil.xmlToString = function(xmlData) { // this functions waits jQuery XML
    var xmlString = undefined;

    if (window.ActiveXObject){
        xmlString = xmlData[0].xml;
    }

    if (xmlString === undefined)
    {
        var oSerializer = new XMLSerializer();
        xmlString = oSerializer.serializeToString(xmlData[0]);
    }
    if (xmlString === undefined)
    {
        xmlString = xmlData[0].outerHTML;
        /*var oSerializer = new XMLSerializer();
         xmlString = oSerializer.serializeToString(xmlData[0]);*/
    }
    return xmlString;

    var xmlString = undefined;
    if (window && window.ActiveXObject){
        /*xmlString = xmlData[0].xml;*/
        xmlString = xmlData[0].outerHTML;
    }
    if (xmlString === undefined)
    {
        xmlString = xmlData[0].outerHTML;
        /*var oSerializer = new XMLSerializer();
         xmlString = oSerializer.serializeToString(xmlData[0]);*/
    }
    return xmlString;
};

/* Функция проверки существования файла на сервере */
HTTPServiceUtil.isUrlExists = function isUrlExists(url) {
    var http = new XMLHttpRequest();
    http.open('HEAD', url, false);
    http.send();
    return http.status !== 404 && http.status !== 403; /* можно доработать, включив проверку статусов вроде 200 (успешно скачан) и других */
};

/**
 * Функция открытия файла
 * @param fileName
 * @param options
 */
HTTPServiceUtil.openFile = function (fileName, options) {
    var target = (options && options.target)? options.target : '_blank';
    var parentDir = (options && options.parentDir)? options.parentDir : '';
    var errMessage = (options && options.errMessage)? options.errMessage : gis_core_error_5;
    //если для разных открытий файлов используются разные имена
    var specificPdfFileName = (options && options.specificPdfFileName)? options.specificPdfFileName : fileName;
    //var link = window.location.protocol+'//'+window.location.host+'/'+fileName;
    if(fileName.indexOf('.pdf#') === -1){//если в url не содержится .pdf#, значит нужно выполнить запрос на генерацию картинки
        //для обычных файлов добавляем возможность указывать родительскую директорию. Например, Public/Data/LIB
        fileName = parentDir + fileName;
        if (HTTPServiceUtil.isUrlExists(fileName))
            window.open(fileName, target);
        else
            App.confirmDialog(errMessage, null, {title: gis_core_1});
    }
    else{
        fileName = specificPdfFileName;
        App.getJsonNode(Services.pdfConvert, {file_name: fileName.replace('#','$')},
            function (result) {
                if (result !== undefined && result.status === 200) {
                    if (result.generated_file !== undefined) {
                        HTTPServiceUtil.openFile(result.generated_file, {errMessage: gis_core_error_6});
                    }
                }
            },
            function (resultXML) {
                //Снимаем курсор ожидания
                var er = HTTPServiceUtil.getError(resultXML);
                App.errorReport(errMessage, er, undefined, {filename:gis_filename_611, functionname:'gis_filename_611_3'});
            }, 'GET');
    }
};
/*Глобальный объект с функциями для работы с базой данных (добавление, изменение, удаление и др.)*/
DBUtil = {};

//константы
DBUtil.DELETE_ALL_ERROR = gis_dbutil_1;
DBUtil.DELETE_GEO_ERROR = gis_dbutil_2;
DBUtil.DELETE_SEM_ERROR = gis_dbutil_3;

DBUtil.NO_GEOMETRY_REQUEST_ERROR = gis_dbutil_4;
DBUtil.NO_SEMANTIC_REQUEST_ERROR = gis_dbutil_5;
DBUtil.NO_LAYER_ERROR = gis_dbutil_6;
//Символ разделителя между перечисленными в одной строке идентификаторами запросов
DBUtil.PROVIDERS_DIVIDER = "$";


//Ссылка на последний выполняющийся запрос удаления
DBUtil.CURRENT_DELETING_MESSAGE_ID = null;
//Идентификатор объекта вида "PODS_ROUTE/130006"
DBUtil.savingEntityId = null;
DBUtil.savingLayer = null;
//Последнее сохраненное имя панели свойств для удаления
DBUtil.propertyPanelName = null;
//Привязка
DBUtil.savingBindData = null;
//Переменная хранит набор провайдеров, которые мы должны выполнить последовательно для удаления объекта
//Если переменная ==null, то мы не выполняем удаление с помощью провайдеров
//Если переменная содержит хотя бы один провайдер - нужно продолжать удалять каждый раз с новым провайдером
DBUtil._providersForDelete /*Array*/ = null;

DBUtil.getReqParams = function(requestId, sendingData, descrType) {
    var userId = Auth.getUserId();
    var userLogin = Auth.getUserName();

    return {
        descrId: requestId,
        descrType: descrType,
        data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+sendingData+'</root>'
    };
};

DBUtil.getDeleteReqParams = function(requestId, sendingData) {
    var userId = Auth.getUserId();
    var userLogin = Auth.getUserName();

    return {
        getSchema: false,
        descrId: requestId,
        toElements: false,
        descrType: 'delete',
        data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+sendingData+'</root>'
    };
};

//Функция удаления геометрии (а затем и семантики) из базы данных. Если завершается успешно - удаляем с карты и из грида
//provider: список провайдеров (если он указан, удаление производится по этим провайдерам без обращения к карте или к панели свойств)
//propertyPanelName: имя панели свойств, если нет ни провайдера, ни карты удалять будем по свойству dataProvider из описания панели свойств
DBUtil.deleteGeometryFromDB = function(idStr, dataType, provider, propertyPanelName) {
    var deleteRequestParams = null;
    if (idStr && idStr!="" && dataType && dataType!="") {
        /* формируем xml с данными геометрии
        @WKT не посылаем, он будет = null */
        var sendingData = '<data ID="'+idStr+'"/>';

        var deletingId = dataType+"/"+idStr;
        DBUtil.savingEntityId = deletingId;
        DBUtil.propertyPanelName = propertyPanelName;
        //Обрабатываем наличие provider - если он непустой и в нем значатся валидные идентификаторы запросов, разделенные знаком PROVIDERS_DIVIDER
        //тогда производим удаление ТОЛЬКО с помощью последовательных вызовов этих провайдеров, не используя ни слой ни propertyPanelName
        if ((DBUtil._providersForDelete && DBUtil._providersForDelete.length>0) || (provider && provider!="")) {
            if (provider && provider!="") {
                var splittedProvArr = provider.split(DBUtil.PROVIDERS_DIVIDER);
                if (splittedProvArr.length>0) {
                    //Разворачиваем массив, чтобы последним элементом был первый, т.к мы извлекаем провайдеры с помощью pop()
                    splittedProvArr = splittedProvArr.reverse();
                    if (!DBUtil._providersForDelete || DBUtil._providersForDelete.length==0)
                        DBUtil._providersForDelete = splittedProvArr;

                    var currentProv = DBUtil._providersForDelete.pop();

                    /*Logger.info("Запуск удаления геометрии объекта с помощью цепочки провайдеров: ID="+savingEntityId+"; request="+sendingData+"; provider="+currentProv);*/
                    /*_model.wait();*/
                    deleteRequestParams = DBUtil.getDeleteReqParams(currentProv, sendingData);
                    //Устанавливаем курсор ожидания
                    BlockingUtil.wait();
                    //BlockingUtil.blockApplication();
                    DBUtil.CURRENT_DELETING_MESSAGE_ID = App.serverQueryXMLNodeWithTries(Services.processQueryNode, deleteRequestParams, DBUtil.deleteGeomResult, DBUtil.deleteFault);
                }
            } else {
                // Отправляем событие успешного завершения операции - мы обработали все провайдеры без ошибок
                //По-хорошему сюда алгоритм заходить не должен, так как при обработке последнего provider из _providersForDelete
                //функция deleteGeometryFromDB снова не вызывается, но на всякий случай обработку оставил
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_DELETED_BY_ID, OperationEvent.DATA_PART_ALL, dataType, idStr, "");
            }
        } else {
            var lay = WidgetMap.layerManager.getLayerByName(dataType);
            if (lay) {
                //сохраняем все данные перед отправкой
                DBUtil.savingLayer = lay;

                if (lay.dataProvider && lay.dataProvider.spatial && lay.dataProvider.spatial!="") {
                    /*Logger.info("Запуск удаления геометрии объекта через provider слоя: ID="+savingEntityId+"; request="+sendingData);*/
                    /*_model.wait();*/
                    deleteRequestParams = DBUtil.getDeleteReqParams(lay.dataProvider.spatial, sendingData);
                    //Устанавливаем курсор ожидания
                    BlockingUtil.wait();
                    //BlockingUtil.blockApplication();
                    DBUtil.CURRENT_DELETING_MESSAGE_ID = App.serverQueryXMLNodeWithTries(Services.processQueryNode, deleteRequestParams, DBUtil.deleteGeomResult, DBUtil.deleteFault);
                } else {
                    // если слой найден но у него нет провайдера - пытаемся удалить семантику!
                    DBUtil.deleteSemanticFromDB(idStr, dataType);
                }
            } else if (propertyPanelName!="") {
                // если слой для объекта не найден - пытаемся удалить по имени панели свойств propertyPanelName
                DBUtil.deleteObjectByPropertyPanelName(idStr, dataType, propertyPanelName);
            } else {
                //Если же нет ни провайдеров, ни слоя, ни имени панели свойств для удаления - показываем сообщение об ошибке и отправляем результат с ошибкой
                //sendOperationResultEvent(OperationEvent.OBJECT_DELETED_BY_ID, OperationEvent.DATA_PART_ALL, dataType, idStr, gis_dbutil_7);
                //2013_03_12 - замечание: "Если слоя нет, то ошибок не должно отображаться." - чтобы у нас был результат и не возникло ошибки
                //отправляем сообщение с успешным результатом (то есть с error="") .
                DBUtil.sendOperationResultEvent((propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
                    , OperationEvent.DATA_PART_ALL, dataType, idStr, "");
            }
        }
    }
    else {
        // если нет ID или типа - показываем сообщение об ошибке и отправляем результат с ошибкой
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent((propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
            , OperationEvent.DATA_PART_ALL, dataType, idStr, gis_dbutil_7);
    }
};

//слушатели результата удаления геометрии
DBUtil.deleteGeomResult = function(data) {
    //Снимаем курсор ожидания
    BlockingUtil.ready();
    //BlockingUtil.unblockApplication();
    /*_model.ready();*/
    if (data) {
        /*var resultXML = HTTPServiceUtil.getXMLData(data);
        var er = HTTPServiceUtil.getError(resultXML);*/
        var er = HTTPServiceUtil.getError(data);
        var classId = "";
        var objectId = "";
        if (DBUtil.savingEntityId && DBUtil.savingEntityId!="" && DBUtil.savingEntityId.indexOf("/")>=0) {
            classId = DBUtil.savingEntityId.split("/")[0];
            objectId = DBUtil.savingEntityId.split("/")[1];
        }
        //
        if (er=="") {
            var objFromGrid = OperationEvent.OBJECT_DELETED_BY_ID;
            if(DBUtil.propertyPanelName=="") objFromGrid = OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID;
            if (DBUtil.savingEntityId && DBUtil.savingEntityId!="") {
                if (DBUtil._providersForDelete) {
                    // Если удаляли через цепочку провайдеров, _providersForDelete будет != null
                    if (DBUtil._providersForDelete.length>0)
                        DBUtil.deleteGeometryFromDB(objectId, classId, DBUtil._providersForDelete.join(DBUtil.PROVIDERS_DIVIDER), "");
                    else // Отправляем событие успешного завершения операции - мы обработали все провайдеры без ошибок
                        DBUtil.sendOperationResultEvent(objFromGrid, OperationEvent.DATA_PART_ALL, classId, objectId, er);
                } else if (DBUtil.savingLayer) {
                    //Отправляем событие завершения операции
                    DBUtil.sendOperationResultEvent(objFromGrid, OperationEvent.DATA_PART_GEO, classId, objectId, er);
                    //Запускаем удаление семантической части после успешного удаления геометрии
                    DBUtil.deleteSemanticFromDB(DBUtil.savingEntityId.split("/")[1],DBUtil.savingEntityId.split("/")[0]);
                    /*
                    //TODO - удаление геометрии из слоя на карте должно производиться в самой карте !!!
                    savingLayer.removeObjectById(savingEntityId.split("/")[1]);
                    //Вместо обновления всего слоя из базы просто обновляем его после удаления конкретного объекта
                    savingLayer.redrawLayer();
                    */
                }
            }
        } else {
            //Отправляем событие завершения операции
            DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
                , OperationEvent.DATA_PART_ALL, classId, objectId, er);
            //_model.ready();
            DBUtil.savingEntityId = "";
        }
    }
    //очищаем вспомогательные переменные и слой, на котором рисовали
    DBUtil.savingGeometry = null;
    DBUtil.savingLayer = null;
    /*closeDrawPanel();*/
};

//Функция удаления семантики из базы данных. Вызывается если успешно удалили из базы геометрию
DBUtil.deleteSemanticFromDB = function(idStr, dataType) {
    if (idStr && idStr!="" && dataType && dataType!="") {
        var deletingId = dataType+"/"+idStr;
        DBUtil.savingEntityId = deletingId;
        var lay = WidgetMap.layerManager.getLayerByName(dataType);
        if (lay) {
            //формируем xml с данными
            var sendingData = '<data ID="'+idStr+'"/>';
            if (lay.dataProvider && lay.dataProvider.semantic && lay.dataProvider.semantic!="") {
                /*_model.wait();*/
                /*Logger.info("Запуск удаления семантики объекта: ID="+savingEntityId+"; request="+sendingData);*/
                var deleteRequestParams = DBUtil.getDeleteReqParams(lay.dataProvider.semantic, sendingData);
                //Устанавливаем курсор ожидания
                BlockingUtil.wait();
                //BlockingUtil.blockApplication();
                DBUtil.CURRENT_DELETING_MESSAGE_ID = App.serverQueryXMLNodeWithTries(Services.processQueryNode, deleteRequestParams, DBUtil.deleteSemResult, DBUtil.deleteFault);
            } else {
                // Отправляем событие завершения операции с ошибкой
                DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
                    , OperationEvent.DATA_PART_SEM, dataType, idStr, DBUtil.NO_SEMANTIC_REQUEST_ERROR);
            }
        } else {
            // Отправляем событие завершения операции с ошибкой
            DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
                , OperationEvent.DATA_PART_SEM, dataType, idStr, DBUtil.NO_LAYER_ERROR/*StringUtil.substitute(NO_LAYER_ERROR,dataType)*/);
        }
    } else {
        // Отправляем событие завершения операции с ошибкой
        DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
            , OperationEvent.DATA_PART_SEM, dataType, idStr, DBUtil.NO_LAYER_ERROR/*StringUtil.substitute(NO_LAYER_ERROR,dataType)*/);
    }
};

//слушатели результата удаления семантики
DBUtil.deleteSemResult = function(data) {
    //Снимаем курсор ожидания
    BlockingUtil.ready();
    if (data) {
        var er = HTTPServiceUtil.getError(data);
        var classId = "";
        var objectId = "";
        if (DBUtil.savingEntityId && DBUtil.savingEntityId!="" && DBUtil.savingEntityId.indexOf("/")>=0) {
            classId = DBUtil.savingEntityId.split("/")[0];
            objectId = DBUtil.savingEntityId.split("/")[1];
        }
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
            , OperationEvent.DATA_PART_SEM, classId, objectId, er);

        DBUtil.savingEntityId = "";
    }
    //очищаем вспомогательные переменные и слой, на котором рисовали
    DBUtil.savingGeometry = null;
    DBUtil.savingLayer = null;
};

//Обработка fault при удалении геометрии или семантики - посылаем сообщение об ошибке
DBUtil.deleteFault = function(info) {
    //Снимаем курсор ожидания
    BlockingUtil.ready();
    //BlockingUtil.unblockApplication();
    DBUtil.fault(info);
    var classId = "";
    var objectId = "";
    if (DBUtil.savingEntityId && DBUtil.savingEntityId!="" && DBUtil.savingEntityId.indexOf("/")>=0) {
        classId = DBUtil.savingEntityId.split("/")[0];
        objectId = DBUtil.savingEntityId.split("/")[1];
    }
    var er = DBUtil.NO_SEMANTIC_REQUEST_ERROR;
    //Отправляем событие завершения операции с ошибкой
    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_DELETED_BY_ID, OperationEvent.DATA_PART_ALL, classId, objectId, er);
};

//Функция удаления объекта по имени панели свойств
//Получает форму по названию панели свойств, и если форму загрузилась удачно - пытаемся получить ее dataProvider
DBUtil.deleteObjectByPropertyPanelName = function(idStr, dataType, propertyPanelName) {
    if (idStr!="" && dataType!="" && propertyPanelName!="") {
        //Заново загружаем форму (даже если есть - нам из описания нужно получить только dataProvider).
        //TODO - Нужно сделать отдельный скрипт для получения только dataProvider'a формы по dataType, но пока что делаем так
        /*var f:DataForm = new DataForm(propertyPanelName);
        if(!f.isReady)
        {
            f.addEventListener(Event.COMPLETE, formComplete);
            f.addEventListener(Event.CLOSE, formClose);
        }*/
    }
};

//Функция отправки сообщения о результате выполнения операции (insert, update, delete)
DBUtil.sendOperationResultEvent = function(type, dataPart, classId, objectId, error, data) {
    var opCompleteEvt = new OperationEvent(type);
    //Указываем, какая часть была удалена
    opCompleteEvt.dataPart = dataPart;
    opCompleteEvt.rowData = data;
    opCompleteEvt.classId = DBUtil.savingEntityId.split("/")[0];
    opCompleteEvt.objectId = DBUtil.savingEntityId.split("/")[1];
    //Обрабатываем тип строки ошибки (если пустая - операция прошла успешно)
    if (error=="") {
        opCompleteEvt.operationSuccess = true;
    } else {
        opCompleteEvt.operationSuccess = false;
        //Если операция не групповая - нужн
    }
    //Сохраняем текст сообщения об ошибке
    opCompleteEvt.operationData = error;
    opCompleteEvt.dispatch();
};

DBUtil.fault = function(info) {
    //очищаем привязку
    DBUtil.savingBindData = null;
};

/**
 * Сериализует объект в xml строку тега <data>
 * @param data
 * @returns {string}
 */
DBUtil.serializeData = function(data) {
    var result = "<data ";
    for(var item in data){
        if(item !== '') {
            result += ' ' + item + '="' + (''+data[item]).xmlEscape() + '" ';
        }
    }
    result += ' />';
    return result;
};

/**
 * Сериализует объект в xml строку тега <data> с атрибутом фильтр
 * @param data
 * @returns {string}
 */
DBUtil.serializeDataWithFilter = function(data) {
    var result = "<data ";
    for(var item in data){
        if(item === 'ID')
            result+=' FILTER="'+item+'='+data[item]+'" ';
        else
            result+=' '+item+'="'+data[item]+'" ';
    }
    result += ' />';
    return result;
};


DBUtil.insertStoIliDataAdvToDB = function(data, dataAdapter, provider) {
    if (data) {
        DBUtil.savingEntityId =  '/';
        var reqParams = DBUtil.getReqParams(provider, DBUtil.serializeData(data), 'insert');
        App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
            if (resultXML) {
                var er = HTTPServiceUtil.getError(resultXML);
                if (er !== "") {
                    /*App.errorReport(title, er, undefined, {
                        filename: gis_filename_243,
                        functionname: 'gis_filename_243_56'
                    });*/
                    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', er);
                    return;
                }
            }
            DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED
                , OperationEvent.DATA_PART_ALL, '', '', '');
            DBUtil.savingEntityId = "";
        },function (resultXML) {
            var er = HTTPServiceUtil.getError(resultXML);
            if (er !== "") {
                /*App.errorReport(title, er, undefined, {
                    filename: gis_filename_243,
                    functionname: 'gis_filename_243_57'
                });*/
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', er);
            }
            else
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', resultXML);
        });
    }
    else {
        // если нет ID или типа - показываем сообщение об ошибке и отправляем результат с ошибкой
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', '');
    }
};

DBUtil.insertObjectToDB = function(data, dataAdapter, colTypes) {
    if (data) {
        var layerId = dataAdapter.currentGridDescr.layerId;
        var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
        var curLayerObj = layerManagerInst.getLayerByName(layerId);
        if (curLayerObj) {
            var dataRequest = curLayerObj.dataProvider.semantic;
            var descrType = (!data.ID) ? 'insert' : 'update';
            //добавляем атрибут SYS_OBJ_ID, т.к. update в панелях свойств использует его
            if (descrType === 'update')
                data.SYS_OBJ_ID = data.ID;
            DBUtil.savingEntityId = layerId+'/';
            var validate = '';
            for(var d in data){
                if(colTypes){
                    //upd. 28.03.22 инц. 2686, при пасте из экселя,  выполнять замену на NULL для тех колонок, которые есть в буфере вставки и отправлять эти null на update;
                    if(colTypes[d] === 'date' && data[d] === ''){
                        data[d] = '';
                        //delete data[d];
                        continue;
                    }
                    validate += GridUtil.validateCell2(data[d], colTypes[d], d);
                }
            }
            if(validate  !== ''){
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', validate);
                return;
            }
            var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(data), descrType);
            App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
                if (resultXML) {
                    var er = HTTPServiceUtil.getError(resultXML);
                    if (er !== "") {
                        DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', er);
                        return;
                    }
                }
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED
                    , OperationEvent.DATA_PART_ALL, '', '', '');
                DBUtil.savingEntityId = "";
            }, function (resultXML) {
                var er = HTTPServiceUtil.getError(resultXML);
                if (er !== "") {
                    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', er);
                } else
                    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', resultXML);
            },4);
        }
    }
    else {
        // если нет ID или типа - показываем сообщение об ошибке и отправляем результат с ошибкой
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', '');
    }
};


DBUtil.reverseObject = function(data, classId) {
    if (data) {
        var dataRequest = 'GAZPROM_ADM_SEM.xml#VTD_CORR_REVERSE';
        var descrType = 'insert';
        DBUtil.savingEntityId = classId+'/'+data.ID;
        var dto = {
            ILI_INSPECTION_ID: data.ILI_INSPECTION_ID,
        }
        var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(dto), descrType);
        App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
            if (resultXML) {
                var er = HTTPServiceUtil.getError(resultXML);
                if (er !== "") {
                    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID, OperationEvent.DATA_PART_ALL, '', '', er);
                    return;
                }
            }
            DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_REVERSED_RESULT_BY_ID
                , OperationEvent.DATA_PART_ALL, '', '', '', data);
            DBUtil.savingEntityId = "";
        }, function (resultXML) {
            var er = HTTPServiceUtil.getError(resultXML);
            if (er === "") er = resultXML;
            DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID, OperationEvent.DATA_PART_ALL, '', '', er);
        });
    }
    else {
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID, OperationEvent.DATA_PART_ALL, '', '', '');
    }
};

/* Глобальный объект с функциями логирования */
LogUtil = {};

/* Константы для логирования */
LogUtil.Severity_CRITICAL = 1; // Фатальная ошибка
LogUtil.Severity_ERROR = 2; // Ошибка
LogUtil.Severity_WARNING = 4; // предупреждение
LogUtil.Severity_INFO = 8; // информационное сообщение

LogUtil.Severity_VERBOSE = 16; // отладка

LogUtil.Severity_START = 256; // начало процесса
LogUtil.Severity_STOP = 512; // остановка процесса
LogUtil.Severity_SUSPEND = 1024; // приостановка процесса
LogUtil.Severity_RESUME = 2048; // возобновление процесса
LogUtil.Severity_TRANSFER = 4096; // передача управления другому процессу

//Запись в лог сервера текста
/**
 *
 * @param {String} message
 * @param {AuditEventType} category
 * @param {int} severity
 * @param {String} context
 * @returns {*}
 */
LogUtil.sendLog = function(message , category , severity , context ) {
    /* Закомментировать return; для отладки */
    /*return;*/
    message = (message) || ' ';
    category = (category) || AuditEventType.DEFAULT;
    severity = (severity) || LogUtil.Severity_CRITICAL;
    context = (context) || ' ';
    var req = $.ajax({
        type: "POST",
        url: Services.logNode,
        data: {
            message: message,
            categories: category,
            severity: severity,
            context: context
        },
        timeout: App && App.clientRequestTimeout !== undefined ? App.clientRequestTimeout : 0,
        dataType: 'json'
    });
    //Возвращаем ссылку на запрос (для возможности отмены запроса)
    return req;
};

/* Типы событий аудита */
AuditEventType = {
    USER_LOGIN: 32,
    USER_LOGOUT: 34,
    TASK_START: 256,
    TASK_STOP: 257,
    MODULE_START: 258,
    MODULE_STOP: 259,
    DEFAULT: 260
};
//Запись в журнал аудита события
//upd 20
/**
 *
 * @param {int} userId
 * @param {AuditEventType} auditType
 * @param {String} success 'true' or 'false'
 * @param {String} details
 */
LogUtil.sendAuditEvent = function (userId, auditType , success, details ) {
    LogUtil.sendLog(logutil_1, auditType, LogUtil.Severity_INFO, logutil_2 + userId + ", " + logutil_3 + success);
};

//проверка, если открыт виджет w=1, и выбран сразу рубрикатор ВТД, то 1-е открытие игнорируем
//предполагается, что извне придет id обследования
//далее работа будет происходить по старой схеме с открытием окна выбора обследования при выборе вкладки
ExternalInteraction.firstCheckHead = true;

/**
 * Функция загрузки описания всех фильтров
 * @param filters
 * @param callback
 */
ExternalInteraction.loadFiltersDescr = function (filters, loadedFilters, callback) {
	var filters = [{title: gis_treeutils_11}, {title: gis_treeutils_10}]
	if (callback) callback(filters);
}

/**
 * Показать перед фильтром форму с выбором, какой из фильтров использовать
 * @param filterType
 * @param topFilterSource
 * @param middleFilterSource
 * @param showLayers
 * @param applyHandler
 */
ExternalInteraction.showSelectableFilter = function (filterType, topFilterSource, middleFilterSource, showLayers, applyHandler) {
	//сначала грузим все
	ExternalInteraction.loadFiltersDescr(middleFilterSource, [], function (filters) {
		$('#selectableFilterFormDialog').remove();
		var divv = '<div id="selectableFilterFormDialog">' +
			'<div class="filter-form-div">';
		divv += '<div>' + gis_treeutils_12 + '</div><br/>';
		var checked = '';
		var height = 160;
		for (var i = 0; i < filters.length; i++) {
			checked = (i === 0) ? 'checked' : '';
			divv += '<div class="filter-form-radio">';
			divv += '   <input name="filterRadio" id="filterRadio_' + i + '" type="radio" ' + checked + ' value="' + i + '"/>';
			divv += '   <label for="filterRadio_' + i + '" style="margin-left: 5px;">' + filters[i].title + '</label>';
			divv += '</div>';
			height += 30;
		}
		divv += '<br/><div>' + gis_treeutils_13 + '</div>';
		divv += '</div></div>';
		$('body').append(divv);
		var dlg = $('#selectableFilterFormDialog');
		var buttons = [{
			text: gis_core_16,
			click: function () {
				var selectedFilterIndex = Number($("input[name='filterRadio']:checked", dlg).val());
				if (applyHandler)
					applyHandler(selectedFilterIndex);
				$('#selectableFilterFormDialog').remove();
			}
		},
			{
				text: gis_treeutils_9,
				click: function () {
					if (applyHandler)
						applyHandler(-1);
					$('#selectableFilterFormDialog').remove();
				}
			}];
		dlg.dialog({
			modal: true,
			title: gis_treeutils_8,
			dialogClass: 'noCloseButton gsi-zindex__dialog',
			closeOnEscape: true,
			width: 470,
			height: height,
			resizable: false,
			buttons: buttons,
		});
	})
};

ExternalInteraction.showFilter = function (filterType, topFilterSource, middleFilterSource, showLayers, applyHandler) {
	var isMiddleFilter = topFilterSource === undefined || topFilterSource === '';
	//если уже был открыт средний фильтр, то игнорируем. Обход ситуации, когда от каждого фильтра рубрикатора вызывается checkHeadRadioHandler
	if ($('#middleFilterDialog').length > 0)
		return;
	$('body').append('<div id="middleFilterDialog"></div>');
	var dlg = $('#middleFilterDialog');
	dlg.append('<div id="middleFilterDiv"></div>');
	var middleFilterDiv = $('#middleFilterDiv');
	middleFilterDiv.myFilters({
		dataSource: middleFilterSource,
		handlers: {
			applyHandler: function (params) {
				//устанавливаем верхний фильтр
				var resFilterValues = middleFilterDiv.myFilters('getFilterValuesArray');
				var dotSplitArr = resFilterValues[0].values;
				//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
				var roughArr = [];
				for (var j = 0; j < dotSplitArr.length; j++) {
					roughArr.push(dotSplitArr[j].code);
				}
				if (dotSplitArr.length == 0) {
					roughArr.push('NULL');
				}
				var showInfo = false;
				$('#middleFilterDialog').remove();
				var idFilter = resFilterValues[0].idFilter;
				if (isMiddleFilter) {
					var rr = [];
					WidgetMap.currentRoughFilter = [];
					for (var k = 0; k < showLayers.length; k++) {
						//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
						var smallLayerId = showLayers[k];
						rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
						WidgetMap.currentFilter[smallLayerId] = [];
						WidgetMap.currentFilter[smallLayerId].push({
							layerName: smallLayerId,
							filter: idFilter,
							value: roughArr.join(",")
						});
						WidgetMap.currentRoughFilter.push({name: idFilter, value: roughArr.join(","), layerName:smallLayerId});
					}

					//WidgetMap.currentRoughFilter = [{name:idFilter, value:}];
					if (applyHandler !== undefined)
						applyHandler();
				}
				//если был объявлен верхний фильтр, то при работе со средним выбранные значения будут заноситься в верхний
				else {
					//если открывался ещё средний фильтр, то выставляем currentRoughFilter для корректного нанесения геометрии на карту
					if (middleFilterSource !== undefined && middleFilterSource !== '' && filterType.indexOf('middle') !== -1) {
						var rr = [];
						WidgetMap.currentRoughFilter = [];
						for (var t = 0; t < showLayers.length; t++) {
							//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
							var smallLayerId = showLayers[t];
							rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
							WidgetMap.currentRoughFilter.push({name: idFilter, value: roughArr.join(","), layerName: smallLayerId});
						}
					}
					var newData = '<data OBJ_IDS="' + roughArr.join(',') + '" TOP_FILTER="' + idFilter + '" ></data>';
					var treeDiv = $('#treeDiv');
					if(treeDiv.length > 0)
						treeDiv.myCategories('updateTopFilter', {params: newData});

					function checkFilter(filter) {
						WidgetMap.updateTopFilter(filter.params);
						var splittedFilter = filter.params[0].value.split('|');
						for (var i = 0; i < splittedFilter.length; i++) {
							if (splittedFilter[i].indexOf(filterName) != -1) {
								var filterValue = splittedFilter[i].split(':')[1];
								for (var k = 0; k < showLayers.length; k++) {
									//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
									var smallLayerId = showLayers[k];
									WidgetMap.currentFilter[smallLayerId] = [];
									WidgetMap.currentFilter[smallLayerId].push({
										layerName: smallLayerId,
										filter: filterName,
										value: filterValue
									});
								}
								if (filterValue == '' || filterValue == 'VOID') {
									showInfo = true;
								}
								if (filterValue !== roughArr.join(',')) {
									return false;
								}
								break;
							}
						}
						return true;
					}

					var filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: {}}) : undefined;
					if (filter && filter.params && filter.params.length > 0) {
						//добавляем проверку на выбранное кол-во записей перед открытием грида
						if (goog.isDef(idFilter)) {
							var filterName = idFilter;
							var start = Date.now();
							var timeout = 0;
							while (!checkFilter(filter) && timeout < 1000) {
								filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: {}}) : undefined;
								timeout = Date.now() - start;
							}
						}
					}
					if (showInfo) {
						var text = gis_treeutils_3;
						var title = gis_treeutils_4;
						var buttons = [
							{text: gis_core_4, click: showGridDialog},
							{text: gis_core_5, click: closeDialog}
						];
						var dlg = App.confirmDialog(text, buttons, {title: title, width: 400});

						function closeDialog() {
							dlg.dialog('destroy');
							dlg.remove();
						}

						function showGridDialog() {
							if (applyHandler !== undefined)
								applyHandler();
							closeDialog();
						}
					} else if (applyHandler !== undefined)
						applyHandler(roughArr);
				}
			},
			cancelHandler: function (params) {
				$('#middleFilterDialog').remove();
			}
		}
	});

	var closeDiv = '<div id="middleFilterCloseDiv" class="middleFilterCloseDiv"></div>';
	middleFilterDiv.append(closeDiv);
	$('#middleFilterCloseDiv').on('click', function (event) {
		$('#middleFilterDialog').remove();
	});
	dlg.dialog({
		resizable: false,
		modal: true,
		dialogClass: 'noCloseButton noTitleBar gsi-zindex__dialog',
		width: 605,
		height: 440,
		title: ''
	});

};


ExternalInteraction.showLayers = function (showLayers, clearFilter) {
	if (showLayers.length > 0) {
		if (WidgetMap.layerManager !== undefined) {
			for (var index = 0; index < showLayers.length; index++) {
				var smallLayerId = showLayers[index];
				var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
				if (goog.isDef(layer)) {

					if (layer.filter !== undefined && layer.filter !== '' && WidgetMap.isModelsVector == true) {
						//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
						WidgetMap.layerManager.clearLayer(smallLayerId, true);
					}
					if(clearFilter === true){
						layer.filter = undefined;
						layer.filters = undefined;
						if(layer.layer){
							layer.layer.filter = undefined;
							layer.layer.filters = undefined;
						}
					}
					if (layer.visible != true)
						WidgetMap.layerManager.updateLayer(smallLayerId);
					WidgetMap.layerManager.enableLayer(smallLayerId);
				}
			}
		}
	}
}

ExternalInteraction.openTables = function (scenarioParams) {
	var timeout = 3000;
	if (scenarioParams !== undefined) {
		if (scenarioParams.openTableInterval !== undefined)
			timeout = scenarioParams.openTableInterval;
		//сначала подгружаем часть стиля для получения title грида
		var openTableTitle = scenarioParams.openTableTitle;
		var openTableGridId = scenarioParams.openTableGridId;
		var openTableLevelParams = scenarioParams.openTableLevelParams;
		var openTableShowDashboard = scenarioParams.openTableShowDashboard;
		var querySource = scenarioParams.querySource;
		var queryLayerId = scenarioParams.queryLayerId;
		var queryFileName = scenarioParams.queryFileName;
		//если есть данные для открытия гридов
		if (openTableTitle !== undefined && openTableGridId !== undefined && openTableLevelParams !== undefined
			&& querySource !== undefined && queryLayerId !== undefined && queryFileName !== undefined) {
			var openTableTitleArr = openTableTitle.replace('undefined|', '').split('|');
			var openTableGridIdArr = openTableGridId.replace('undefined|', '').split('|');
			var openTableLevelParamsArr = openTableLevelParams.replace('undefined|', '').split('|');
			var openTableShowDashboardArr = openTableShowDashboard?openTableShowDashboard.replace('undefined|', '').split('|'): undefined;
			var querySourceArr = querySource.replace('undefined|', '').split('|');
			var queryLayerIdArr = queryLayerId.replace('undefined|', '').split('|');
			var queryFileNameArr = queryFileName.replace('undefined|', '').split('|');
			var gridArr = [];

			function loadStyle() {
				if (gridArr.length > 0) {
					var gridItem = gridArr.pop();
					if (gridItem.title.indexOf('{') == -1) {
						ExternalInteraction.openTable(gridItem.gridId, gridItem.title, gridItem.levelParams, gridItem.showDashboard, scenarioParams.openTableMinimize);
						setTimeout(function () {
							loadStyle();
						}, timeout)
					} else
						App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
							{
								descrId: gridItem.source,
								descrType: 'select',
								getSchema: false,
								toElements: false,
								data: '<root><data LAYER_ID="' + gridItem.layerId + '" FILE_NAME="' + gridItem.fileName + '"/></root>'
							},
							function (xmlElement) {
								var xmlData = ($.parseXML(xmlElement)).firstChild;
								var styles = xmlData.getElementsByTagName("Style");
								var i = 0;
								if (styles.length > 0) {
									var curStyle = styles[0];
									var descr = curStyle.getAttribute('descr');
									//открываем грид
									if (descr !== undefined && descr !== '') {
										ExternalInteraction.openTable(gridItem.gridId, descr, gridItem.levelParams, false, scenarioParams.openTableMinimize);
										setTimeout(function () {
											loadStyle();
										}, timeout)
									}
								}
							},
							function (xmlElement) {
							});
				}
			}

			//если количество данных для открытия гридов совпадает
			if (openTableTitleArr.length == openTableGridIdArr.length && openTableTitleArr.length == openTableLevelParamsArr.length &&
				openTableTitleArr.length == querySourceArr.length && openTableTitleArr.length == queryLayerIdArr.length &&
				openTableTitleArr.length == queryFileNameArr.length) {
				for (var i = 0; i < querySourceArr.length; i++) {
					if(queryLayerIdArr[i])
						gridArr.push({
							title: openTableTitleArr[i],
							source: querySourceArr[i],
							layerId: queryLayerIdArr[i],
							fileName: queryFileNameArr[i],
							gridId: openTableGridIdArr[i],
							levelParams: openTableLevelParamsArr[i],
							showDashboard: (openTableShowDashboardArr)?openTableShowDashboardArr[i]:undefined,
						});
				}
				loadStyle();
			}
		}
	}
}

//открытие грида
ExternalInteraction.openTable = function (gridId, descr, levelParams, showDashboard, minimize) {
	var prms = {
		event_name: 'FULL_GRID_EVENT_ID_MODULE',
		levelParams: levelParams, //"layerId=PODS_INSP_Layers.xml#"PODS_ILI_DATA_FEATURE;",
		vars: {
			functionName: '',
			gridId: gridId,
			layerId: '',
			mdl: 'Public/SWF/Grid_55.swf',
			needTopFilter: 'true',
			task: 'GRID',
			title: descr,
			useSynchCommands: 'false',
			windowTemplateId: 'gridWindow',
			onlyGrid: true,//новое, чтобы дальше не подгружались данные на карте для слоя,
			showDashboard: showDashboard,
			minimize: minimize,//нужно ли минимизировать размер грида, как при клике центровки
		}
	};
	ExternalInteraction.treeCallFunction(prms, 'clickButton');
};

/**
 * Реакция на кнопки в рубрикаторе
 * @param params
 */
ExternalInteraction.treeCallFunction = function (params, funcName) {
	var vars = params.vars;
	//флаг открытия грида в одной вкладке или каждый раз в новой
	//по умолчанию все гриды открываются в одной и той же вкладке, соответствующей данному id грида
	var useExistList = true;
	var useSynchCommands = false;//(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true);
	if (goog.isDefAndNotNull(vars)) {
		if (funcName === 'loadScenario') {
			//забираем флаг открытия среднегно фильтрна, список на открытие гридов и список на включение слоёв
			var middleFilterSource = '';//'MIDDLE_ILI_FILTER';
			var topFilterSource = '';//'ILI_INSP_FILTER;
			var filterType = '';
			if (vars.filterType !== undefined && vars.filterType !== '')
				filterType = vars.filterType;
			if (vars.middleFilterSource !== undefined && vars.middleFilterSource !== '')
				middleFilterSource = vars.middleFilterSource;
			if (vars.topFilterSource !== undefined && vars.topFilterSource !== '')
				topFilterSource = vars.topFilterSource;
			var showLayers = [];//['PODS_ILI_DATA','PODS_ILI_DATA_FEATURE'];
			if (vars.openLayers !== undefined && vars.openLayers !== '')
				showLayers = vars.openLayers;
			if (middleFilterSource !== '') {
				if (Array.isArray(middleFilterSource)) {
					ExternalInteraction.showSelectableFilter(filterType, topFilterSource, middleFilterSource, showLayers, function (selectedFilterIndex) {
						//выбираем тот средний фильтр за основу, который пришел из формы выбора
						vars.middleFilterSource = middleFilterSource[0];
						if (selectedFilterIndex < middleFilterSource.length)
							vars.middleFilterSource = middleFilterSource[selectedFilterIndex];
						if (selectedFilterIndex !== -1) {
							ExternalInteraction.showFilter(filterType, topFilterSource, vars.middleFilterSource, showLayers, function () {
								ExternalInteraction.showLayers(showLayers);
								ExternalInteraction.openTables(vars);
							})
						} else {
							//если selectedFilterIndex = -1 , значит выбрать всё
							ExternalInteraction.showLayers(showLayers, true);//флаг, чтобы удалить фильтр. нужно переработать
							ExternalInteraction.openTables(vars);
						}
					})
				} else {
					ExternalInteraction.showFilter(filterType, topFilterSource, middleFilterSource, showLayers, function () {
						//TODO рефакторинг
						if (WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.fullLayerId){
							var pArr = [],
								fullLayerId = WidgetMap.config.grid.fullLayerId.replace('#', '*');
							for (var key in WidgetMap.config.grid)
								pArr.push({name: key, value: WidgetMap.config.grid[key]});
							ExternalInteraction.openGrid({
									pArr: pArr,
									reload: useExistList,
									fullLayerId: fullLayerId,
									forceTopFilter: true,
								});
							return;
						}
						ExternalInteraction.showLayers(showLayers);
						ExternalInteraction.openTables(vars);
					})
				}
			} else {
				ExternalInteraction.showLayers(showLayers);
				ExternalInteraction.openTables(vars);
			}
		}
		if (funcName === 'clickButton') {
			if (params.event_name === 'FULL_GRID_EVENT_ID_MODULE') {
				var levelParams = params.levelParams;
				var fullLayerId = '';
				var smallLayerId = '';
				if (levelParams != '') {
					fullLayerId = levelParams.split('=')[1].split(';')[0];
					smallLayerId = fullLayerId.split('#')[1];
				}
				//1. Устанавливаем текущий фильтр
				var showInfo = false;
				//получили фильтры
				var treeDiv = $('#treeDiv');
				var filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: params}) : undefined;
				WidgetMap.updateTopFilter(filter.params);
				var mapParams = [];
//                mapParams.push({name:'filter',value: filter.params});
				if (filter && filter.params && filter.params.length > 0) {
					mapParams.push(filter.params[0]);
					//добавляем проверку на выбранное кол-во записей перед открытием грида
					if (goog.isDef(vars.filter)) {
						var filterName = vars.filter;
						var splittedFilter = filter.params[0].value.split('|');
						for (var i = 0; i < splittedFilter.length; i++) {
							if (splittedFilter[i].indexOf(filterName) != -1) {
								var filterValue = splittedFilter[i].split(':')[1];
								WidgetMap.currentFilter[smallLayerId] = [];
								WidgetMap.currentFilter[smallLayerId].push({
									layerName: smallLayerId,
									filter: filterName,
									value: filterValue
								});
								if (filterValue == '' || filterValue == 'VOID') {
									showInfo = true;
								}
								break;
							}
						}
					}
				}

				//2.открываем грид
				var winTemplateId = 'default';
				var task = 'GRID';
				var needTopFilter = false;

				//upd 21.11.19 доавляем параметр, чтобы открывался только грид
				var onlyGrid = false;
				var pArr = [];
				var minimize = false;

				for (var item in vars) {
					switch (item) {
						//общие параметры
						case "gridId":
						case "template": {
							pArr.push({name: "template", value: vars[item]});
							break;
						}
						case "use_exist_list": {
							useExistList = vars[item];
							break;
						}
						case "task": {
							task = vars[item];
							break;
						}
						case "windowTemplateId": {
							winTemplateId = vars[item];
							break;
						}
						case "needTopFilter": {
							needTopFilter = (vars[item] == "true") ? true : false;
							break;
						}
						case "useSynchCommands": {
							useSynchCommands = (vars[item] == "true") ? true : false;
							break;
						}
						case "title": {
							pArr.push({name: item, value: "'" + vars[item] + "'"});
							break;
						}
						case "filter": {
							break;
						}
						case "layerId": {
							//забираем полный идентификатор из уровня дерева
							if (levelParams !== undefined) {
								fullLayerId = fullLayerId.replace("#", "*");
								pArr.push({name: "fullLayerId", value: fullLayerId});
							}
							break;
						}
						case "onlyGrid": {
							onlyGrid = vars[item];
							break;
						}
						case "minimize": {
							minimize = vars[item];
							break;
						}
						default: {/*остальные параметры*/
							pArr.push({name: item, value: vars[item]});
							break;
						}
					}
				}
				if (!onlyGrid)
					WidgetMap.currentRoughFilter = [];
				if (showInfo) {
					var text = gis_treeutils_3;
					var title = gis_treeutils_4;
					var buttons = [
						{text: gis_core_4, click: showGridDialog},
						{text: gis_core_5, click: closeDialog}
					];
					var dlg = App.confirmDialog(text, buttons, {title: title, width: 400});

					function closeDialog() {
						dlg.dialog('destroy');
						dlg.remove();
					}

					function showGridDialog() {
						//временное условие, если типа filteredWkbLayer, у которого есть filter
						var layer = (WidgetMap.layerManager) ? WidgetMap.layerManager.getLayerByName(smallLayerId) : undefined;
						//layer.layer.dataReady_ = false;
						if (goog.isDef(layer) && goog.isDef(layer.filter) && layer.filter != '' && !onlyGrid) {
							mapParams.push({name: 'layerId', value: smallLayerId});
							if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
								if (WidgetMap.isModelsVector == true) {
									//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
									WidgetMap.layerManager.clearLayer(smallLayerId, true);

								}
								if (layer.visible == true)
									WidgetMap.layerManager.enableLayer(smallLayerId);
								else
									WidgetMap.layerManager.updateLayer(smallLayerId);
							}
							if (WidgetMap.isModelsVector == false)
								ExternalInteraction.callFunction('', 'updateCacheLayer', mapParams, true);
						}
						closeDialog();
						if (useExistList) {
							//открываем новое окно
							ExternalInteraction.openGrid({
								pArr: pArr,
								reload: useExistList,
								fullLayerId: fullLayerId,
								forceTopFilter: true,
								minimize: minimize,
								ignoreLabelColumn: true,
							});

						} else {
							//выбираем нулевое окно
							var funcResult = ExternalInteraction.callFunction('', funcName, params);
							//если не предусмотрены сообщения об ошибках на функциях синхронизации
						}
					}
				} else {
					if (useExistList) {
						if (WidgetMap.layerManager != undefined && !onlyGrid) {
							var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
							//if(goog.isDef(layer))
							//  layer.layer.dataReady_ = false;
							if (goog.isDef(layer) && goog.isDef(layer.filter) && layer.filter != '') {
								mapParams.push({name: 'layerId', value: smallLayerId});
								if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
									if (WidgetMap.isModelsVector == true) {
										//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
										WidgetMap.layerManager.clearLayer(smallLayerId, true);
									}
									if (layer.visible == true)
										WidgetMap.layerManager.enableLayer(smallLayerId);
									else
										WidgetMap.layerManager.updateLayer(smallLayerId);
								}
								if (WidgetMap.isModelsVector == false)
									ExternalInteraction.callFunction('', 'updateCacheLayer', mapParams, true);
							}
						}
						ExternalInteraction.openGrid({
							pArr: pArr,
							reload: useExistList,
							fullLayerId: fullLayerId,
							forceTopFilter: true,
							minimize: minimize,
							ignoreLabelColumn: true,
						});
					} else {
						//выбираем нулевое окно
						var funcResult = ExternalInteraction.callFunction('', funcName, params);
						//если не предусмотрены сообщения об ошибках на функциях синхронизации
					}
				}
			}
			//открываем окошко среднего фильтра в попапе
			if (params.event_name === 'FULL_GRID_ROUGH_FILTER_MODULE') {
				WidgetMap.currentRoughFilter = [];
				var levelParams = params.levelParams;
				var fullLayerId = levelParams.split('=')[1].split(';')[0];
				var smallLayerId = fullLayerId.split('#')[1];
				//1. Устанавливаем текущий фильтр
				//получили фильтры
				var treeDiv = $('#treeDiv');
				var filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: params}) : undefined;
				WidgetMap.updateTopFilter(filter.params);
				var mapParams = [];
//                mapParams.push({name:'filter',value: filter.params});
				if (filter && filter.params && filter.params.length > 0)
					mapParams.push(filter.params[0]);
				mapParams.push({name: 'layerId', value: smallLayerId});
				//2.открываем грид
				var winTemplateId = 'default',
					task = 'GRID',
					functionName = 'filterData',
					needTopFilter = false,
					popupTitle = '',
					requestId = '',
					variableName = '',
					addParams = undefined;

				var maxCnt = 1;

				var pArr = [];


				for (var item in vars) {
					switch (item) {
						//общие параметры
						case "gridId":
						case "template": {
							pArr.push({name: "template", value: vars[item]});
							break;
						}
						case "task": {
							task = vars[item];
							break;
						}
						case "windowTemplateId": {
							winTemplateId = vars[item];
							break;
						}
						case "use_exist_list": {
							useExistList = vars[item];
							break;
						}
						case "needTopFilter": {
							needTopFilter = (vars[item] == "true") ? true : false;
							break;
						}
						case "useSynchCommands": {
							useSynchCommands = (vars[item] == "true") ? true : false;
							break;
						}
						case "title": {
							pArr.push({name: item, value: "'" + vars[item] + "'"});
							popupTitle = vars[item];
							break;
						}
						case "winTitle": {
							popupTitle = vars[item];
							break;
						}
						case "maxRecords": {
							maxCnt = vars[item];
							break;
						}
						case "filter": {
							break;
						}
						case "requestId": {
							requestId = vars[item];
							break;
						}
						case "variableName": {
							variableName = vars[item];
							break;
						}
						case "layerId": {
							//забираем полный идентификатор из уровня дерева
							if (levelParams !== undefined) {
								fullLayerId = fullLayerId.replace("#", "*");
								pArr.push({name: "fullLayerId", value: fullLayerId});
							}
							break;
						}
						default: {/*остальные параметры*/
							pArr.push({name: item, value: vars[item]});
							break;
						}
					}
				}

				if (needTopFilter)
					addParams = '<data ' + LayerManager.getTopFiltersString(WidgetMap.currentTopFilter) + ' />';
				$('#roughFilterDialog').remove();

				$('body').append('<div id="roughFilterDialog"></div>');
				var dlg = $('#roughFilterDialog');
				var filterControl = "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'><components:FilterPopUpButton width='100%' isDropDown='false' minPopupWidth='610' height='22' title='" + popupTitle + "' selectAllElements='false' minCnt='0' maxCnt='" + maxCnt + "' id='" + variableName + "' dataProvider='" + requestId + "' /> </mx:VBox>";
				dlg.append('<div id="roughFilterDiv"></div>');
				//upd. 08.08.19 только для ЭХЗ среднего фильтра добавляем курсор ожидания
				var showLoader = false;
				showLoader = variableName == 'PI_CP_EVENT_ID';
				var roughFilterDiv = $('#roughFilterDiv');
				roughFilterDiv.myFilters({
					showLoader: showLoader,
					addParams: addParams,
					dataXML: filterControl, handlers: {
						applyHandler: function (params) {
							var rr = [];
							pArr.push({name: 'roughRequestId', value: requestId});
							var resFilterValues = roughFilterDiv.myFilters('getFilterValuesArray');
							var dotSplitArr = resFilterValues[0].values;
							//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
							var roughArr = [];
							for (var j = 0; j < dotSplitArr.length; j++) {
								roughArr.push(dotSplitArr[j].code);
							}
							//fix для postgres, т.к. пустые кавычки вызывают ошибку синтаксиса
							if (dotSplitArr.length == 0) {
								roughArr.push('NULL');
							}
							$('#roughFilterDialog').remove();
							rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
							pArr.push({
								name: "roughFilter",
								value: variableName + ":" + roughArr.join(","),
								layerName: smallLayerId
							});
							WidgetMap.currentFilter[smallLayerId] = [];
							WidgetMap.currentFilter[smallLayerId].push({
								layerName: smallLayerId,
								filter: variableName,
								value: roughArr.join(",")
							});
							WidgetMap.currentRoughFilter = rr;//{layerId:smallLayerId,roughFilter:rr};
							if (WidgetMap.layerManager != undefined) {
								var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
								if (goog.isDef(layer) && layer.filter != '') {
									pArr.push({name: 'layerId', value: smallLayerId});
									if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
										if (WidgetMap.isModelsVector == true) {
											//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
											WidgetMap.layerManager.clearLayer(smallLayerId, true);

										}
										WidgetMap.layerManager.enableLayer(smallLayerId);
									}
									ExternalInteraction.callFunction('', 'updateCacheLayer', pArr, true);
								}
							}

							ExternalInteraction.openGrid({
								pArr: pArr,
								reload: useExistList,
								fullLayerId: fullLayerId,
								forceTopFilter: true,
							});
						},
						cancelHandler: function (params) {
							$('#roughFilterDialog').remove();
						}
					}
				});
				var closeDiv = '<div id="middleFilterCloseDiv" class="middleFilterCloseDiv"></div>';
				roughFilterDiv.append(closeDiv);
				$('#middleFilterCloseDiv').on('click', function (event) {
					$('#roughFilterDialog').remove();
				});
				dlg.dialog({
					resizable: false,
					modal: true,
					dialogClass: 'noCloseButton noTitleBar gsi-zindex__dialog',
					width: 605,
					height: 440,
					title: ''
				});
			}
			if (params.event_name === 'exportToExcelFromTree') {
				//получили фильтры
				var filter = $('#treeDiv').myCategories('callbackFilter', {params: params});

				var filtersObj = ExternalInteraction.topFilterStrToObject(filter.params);


				ExportUtil.exportToExcel([], 'file', 'server_export', vars['dataRequestId'], filtersObj);
			}

			if (params.event_name === 'importPointGPS') {
				ImportUtil.importPOIPointTrack('point');
			}
			if (params.event_name === 'importTrackGPS') {
				ImportUtil.importPOIPointTrack('track');
			}
			//заглушки для кнопок экспорта
			if (params.event_name === 'exportImgFromTree') {
				App.confirmDialog(gis_treeutils_2, null, {width: 482});
			}
			if (params.event_name === 'exportWrmlFromTree') {
				App.confirmDialog(gis_treeutils_1, null, {width: 467});
			}
			if (params.event_name === 'checkBufferFromTree') {
				if (goog.isDef(vars) && goog.isDef(vars.classId) && vars.classId != '')
					if (goog.isDef(WidgetMap))
						WidgetMap.checkCadastreMDR(vars.classId);
			}
			//заглушка для создания объекта
			if (params.event_name === 'createObjectFromTree') {
				if (goog.isDef(vars) && goog.isDef(vars.classId) && vars.classId != '') {
					if (goog.isDef(WidgetMap) && goog.isDef(WidgetMap.addObjectControl)) {
						widgetMoveWindowToPosition('grid');
						WidgetMap.addObjectControl.handleAddObjectClick_({addFromTree: true, layerName: vars.classId});
					}
				}
			}
		}
		if (funcName === 'enableLayer') {
			var p = vars.layerParams.split('=');
			var obj = [{name: p[0], value: p[1].split(';')[0]}];
			var lName = p[1].split(';')[0];
			var layer = WidgetMap.layerManager.getVectorLayerByName(lName);
			if (goog.isDef(layer)) {
				layer.visible = true;
			} else {
				return;
			}

			if (WidgetMap.isModelsVector == true) {//если слой векторный, то данные подгружаем на карту.
				if (layer.filter === undefined)
					layer.layer.setVisible(layer.visible);
				else {
					layer.layer.setVisible(layer.visible);
					//проверка, есть ли флаг, то эмулируем открытие среднего фильтра
					/*if (goog.isDef(vars.needPreOpenRoughFilter) && vars.needPreOpenRoughFilter == 'true' && layer.layer.needPreOpenRoughFilter == false) {
						layer.layer.needPreOpenRoughFilter = true;
						var p = {};
						if (goog.isDef(params.tree) && goog.isDef(params.tree.invokes) && goog.isDef(vars.invokeName) && vars.invokeName != '') {
							p.event_name = params.tree.invokes[vars.invokeName].event_name;

							var gridVars = params.tree.invokes[vars.invokeName].vars;
							p.vars = gridVars;
							for (var vv in gridVars) {
								if (goog.isDef(vars[vv]))
									p.vars[vv] = vars[vv];
							}
							p.levelParams = vars.levelParams;
							ExternalInteraction.treeCallFunction(p, 'clickButton');
						}
					}*/
				}
			}
		}

		if (funcName === 'disableLayer') {
			var p = vars.layerParams.split('=');
			var obj = [{name: p[0], value: p[1].split(';')[0]}];
			var lName = p[1].split(';')[0];
			var layer = WidgetMap.layerManager.getLayerByName(lName);
			if (goog.isDef(layer)) {
				layer.visible = false;
			} else {
				return;
			}
			if (WidgetMap.isModelsVector == true) {//если слой векторный, то данные подгружаем на карту.
				var params = {windowId: ''};
				/*var filter = $('#treeDiv').myCategories('callbackFilter', {params: params});
				WidgetMap.updateTopFilter(filter.params);*/
				layer.layer.setVisible(layer.visible);
			}
		}

		if (funcName === 'checkHead') {
			//проверка на виджет
			var isWidget = Auth.getParameterByName("w") == '1' && Auth.getParameterByName("task") == 'ILI_WIDGET';
			if (isWidget && ExternalInteraction.firstCheckHead == true) {
				ExternalInteraction.firstCheckHead = false;
				return;
			}
			var maxCnt = vars.maxCnt;
			var popupTitle = vars.title;
			var variableName = vars.variableName;
			var requestId = vars.dataProvider;
			//проверяем , установлено ли что-то в фильтре верхнего уровня. Если да, то добавляем id в фильтра
			var selectedItems = undefined;
			var lastSelected = [];
			if (goog.isDef(variableName) && variableName != '') {
				var filter = $('#treeDiv').myCategories('callbackFilter', {params: params});
				if (filter.params.length > 0) {
					//добавляем проверку на выбранное кол-во записей перед открытием грида
					var filterName = variableName;
					var splittedFilter = filter.params[0].value.split('|');
					for (var ii = 0; ii < splittedFilter.length; ii++) {
						if (splittedFilter[ii].indexOf(filterName) != -1) {
							var filterValue = splittedFilter[ii].split(':')[1];
							var splittedValues = filterValue.split(',');
							for (var sv in splittedValues)
								lastSelected.push({CODE: splittedValues[sv]});
							break;
						}
					}
				}
				if (lastSelected.length > 0) {
					selectedItems = {};
					selectedItems[variableName] = {lastSelected: lastSelected}
				}

			}

			$('#topFilterDialog').remove();
			$('body').append('<div id="topFilterDialog"></div>');
			var dlg = $('#topFilterDialog');
			var filterControl = "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'><components:FilterPopUpButton width='100%' isDropDown='false' minPopupWidth='610' height='22' title='" + popupTitle + "' selectAllElements='false' minCnt='0' maxCnt='" + maxCnt + "' id='" + variableName + "' dataProvider='" + requestId + "' /> </mx:VBox>";
			dlg.append('<div id="topFilterDiv"></div>');
			var topFilterDiv = $('#topFilterDiv');
			topFilterDiv.myFilters({
				selectedItems: selectedItems,
				dataXML: filterControl, handlers: {
					applyHandler: function (params) {
						//устанавливаем верхний фильтр
						var resFilterValues = topFilterDiv.myFilters('getFilterValuesArray');
						var dotSplitArr = resFilterValues[0].values;
						//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
						var roughArr = [];
						for (var j = 0; j < dotSplitArr.length; j++) {
							roughArr.push(dotSplitArr[j].code);
						}
						if (dotSplitArr.length == 0) {
							roughArr.push('NULL');
						}
						$('#topFilterDialog').remove();
						var newData = '<data OBJ_IDS="' + roughArr.join(',') + '" TOP_FILTER="' + resFilterValues[0].idFilter + '" ></data>';
						$('#treeDiv').myCategories('updateTopFilter', {params: newData});
						//эмуляция клика по кнопке "показать список" слоя PODS_ILI_DATA "Данные ВТД. Дефекты"

						var prms = {
							event_name: 'FULL_GRID_EVENT_ID_MODULE',
							levelParams: "layerId=PODS_INSP_Layers.xml#PODS_ILI_DATA;",
							vars: {
								filter: 'ILI_INSP_FILTER',
								functionName: '',
								gridId: 'PODS_ILI_DATA_LIST',
								layerId: '',
								mdl: 'Public/SWF/Grid_55.swf',
								needTopFilter: 'true',
								task: 'GRID',
								title: gis_treeutils_7,
								useSynchCommands: 'false',
								useExistList: 'true',
								windowTemplateId: 'gridWindow'
							}
						};

						var smallLayerId = "PODS_ILI_DATA";
						var filter = $('#treeDiv').myCategories('callbackFilter', {params: {}});

						function checkFilter(filter) {
							WidgetMap.updateTopFilter(filter.params);
							var splittedFilter = filter.params[0].value.split('|');
							for (var i = 0; i < splittedFilter.length; i++) {
								if (splittedFilter[i].indexOf(filterName) != -1) {
									var filterValue = splittedFilter[i].split(':')[1];
									WidgetMap.currentFilter[smallLayerId] = [];
									WidgetMap.currentFilter[smallLayerId].push({
										layerName: smallLayerId,
										filter: filterName,
										value: filterValue
									});
									if (filterValue == '' || filterValue == 'VOID') {
										showInfo = true;
									}
									if (filterValue !== roughArr.join(',')) {
										return false;
									}
									break;
								}
							}
							return true;
						}

						if (filter.params.length > 0) {
							//добавляем проверку на выбранное кол-во записей перед открытием грида
							if (goog.isDef(prms.vars.filter)) {
								var filterName = prms.vars.filter;
								var start = Date.now();
								var timeout = 0;
								while (!checkFilter(filter) && timeout < 1000) {
									filter = $('#treeDiv').myCategories('callbackFilter', {params: {}});
									timeout = Date.now() - start;
								}
							}
						}

						if (WidgetMap.layerManager != undefined) {
							var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
							if (goog.isDef(layer) && goog.isDef(layer.filter) && layer.filter != '') {
								if (WidgetMap.isModelsVector == true) {
									//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
									WidgetMap.layerManager.clearLayer(smallLayerId, true);
								}
								if (layer.visible == true)
									WidgetMap.layerManager.enableLayer(smallLayerId);
								else
									WidgetMap.layerManager.updateLayer(smallLayerId);
							}
						}

					},
					cancelHandler: function (params) {
						$('#topFilterDialog').remove();
					}
				}
			});

			var closeDiv = '<div id="middleFilterCloseDiv" class="middleFilterCloseDiv"></div>';
			topFilterDiv.append(closeDiv);
			$('#middleFilterCloseDiv').on('click', function (event) {
				$('#topFilterDialog').remove();
			});
			dlg.dialog({
				resizable: false,
				modal: true,
				dialogClass: 'noCloseButton noTitleBar gsi-zindex__dialog',
				width: 605,
				height: 440,
				title: ''
			});
		}
	}
};

ExternalInteraction.topFilterStrToObject = function (params) {
	for (var j = 0; j < params.length; j++) {
		var curParam = params[j];
		if (!curParam.hasOwnProperty('name')) continue;

		var newFilters = [];
		var curFilters;
		var newFilterObj = {};
		switch (curParam['name']) {
			case 'filter':
			case 'roughFilter':
				curFilters = curParam['value'].split('|');
				for (var i = 0; i < curFilters.length; i++) {
					var nameValArr = curFilters[i].split(':');
					if (nameValArr && nameValArr.length == 2) {
						//var newFilterObj = { name: nameValArr[0], value: nameValArr[1] };

						var splittedIds = nameValArr[1].split(',');

						for (var t = 0; t < splittedIds.length; t++) {
							var pp = parseInt(splittedIds[t]);
							if (isNaN(pp))
								splittedIds[t] = "'" + splittedIds[t] + "'";
						}
						newFilterObj[nameValArr[0]] = splittedIds.toString();//nameValArr[1] ;
//                        newFilters.push(newFilterObj);
					}
				}

				break;
			case 'layerId':
				break;
		}
		return newFilterObj;
	}
	return null;
};

ExternalInteraction.getLayersVisibility = function (params) {
	if (!goog.isDef(WidgetMap.layerManager)) {
		var res = [];
		for (var i in params) res.push({layerName: params[i].layer, visible: false});
		return res;
	}
	for (var i in params) {
		var isVisible = WidgetMap.layerManager.getLayerVisibility(params[i].layer);
		params[i].visible = isVisible;
		params[i].layerName = params[i].layer;
	}
	return params;
};

//открытие грида
ExternalInteraction.openGrid = function (opt_options, callback) {
	var options = opt_options !== undefined ? opt_options : {};
	var pArr = [];
	var url = options.url || location.href;
	var reload = options.reload !== undefined && options.reload === true;
	//использовать ли в Tab только один грид
	var singleTab = options.singleTab !== undefined && options.singleTab === true;
	var fullLayerId = options.fullLayerId;
	var parentRoughFilter = options.parentRoughFilter;
	var staticParentRoughFilter = options.staticParentRoughFilter;
	var parentRoughParams = options.parentRoughParams;
	var parentGridFilter = options.parentGridFilter;
	var	parentGridRowId = options.parentGridRowId;
	var minimize = options.minimize;
	var ignoreLabelColumn = options.ignoreLabelColumn || false;

	var filterMap = options.filterMap;
	var ignoreLabelColumn = options.ignoreLabelColumn === true;
	try {
		if (options.pArr) {
			pArr = options.pArr;
		} else {
			if (!options.gridId)
				return;
			var gridId = options.gridId;
			var parentGrid = options.parentGrid;
			var childGrid = options.childGrid;
			var position = (options.position !== undefined) ? options.position : -1;
			var showDashboard = options.showDashboard || false;
			if (options.pArr === undefined) {
				pArr.push({name: "fullLayerId", value: fullLayerId.replace("#", "*")});
				pArr.push({name: "template", value: gridId});
				pArr.push({name: "title", value: "'" + options.label + "'"});
				pArr.push({name: "filter", value: options.data});
				pArr.push({name: "parentRoughFilter", value: options.parentRoughFilter});
				pArr.push({name: "parentRoughParams", value: options.parentRoughParams});
				pArr.push({name: "staticParentRoughFilter", value: options.staticParentRoughFilter});
				pArr.push({name: "filterMap", value: options.filterMap});
				pArr.push({name: "parentGrid", value: parentGrid});
				pArr.push({name: "childGrid", value: childGrid});
				pArr.push({name: "position", value: position});
				pArr.push({name: "showDashboard", value: '' + showDashboard});// из-за того, что далее сравнение строковое
				pArr.push({name: "ignoreLabelColumn", value: '' + ignoreLabelColumn});// из-за того, что далее сравнение строковое
				pArr.push({name: "parentGridFilter", value: options.parentGridFilter});
				pArr.push({name: "parentGridRowId", value: options.parentGridRowId});
			}
		}
		if (reload && !singleTab) {
			var gridWidget = GridUtil.findTabByLayerName(fullLayerId.replace("#", "*"));
			if (gridWidget) {
				gridWidget.ignoreLabelColumn = ignoreLabelColumn;
				if(ignoreLabelColumn){
					GridUtil.emulateShowAllClick(gridWidget.id, true, true);
				}
				gridWidget.updateGridContent(options.data, options.forceTopFilter, reload, parentRoughFilter, filterMap, parentRoughParams, staticParentRoughFilter);
				return;
			}
		}
		if(singleTab){
			var tabNav = $('#gridTabNavigator');
			if(tabNav.length){
				var tabCount =  tabNav.jqxTabs('length');
				for(var t = 0; t < tabCount; t++){
					tabNav.jqxTabs('removeAt', t);
				}
			}
		}
		//открываем новое окно
		openNewWindow(url, "gridWindow", "GRID", pArr, callback, minimize);
	} catch (ex) {

	}
};




/**
 * Выполнение сценария для поискового движка
 * @param currentObject  "PODS_ILI_INSPECTION:1302016"
 * @param categoryId "ILI_INSP"
 */
ExternalInteraction.processScenario = function (currentObject, categoryId) {
	if (WidgetMap.config.search_engine && WidgetMap.config.search_engine.templates && WidgetMap.config.search_engine.templates[categoryId]) {
		var scenario = WidgetMap.config.search_engine.templates[categoryId].scenario;
		if (scenario) {
			var showLayers = (scenario.openLayers) ? scenario.openLayers : [];//['PODS_ILI_DATA','PODS_ILI_DATA_FEATURE'];
			//забираем флаг открытия среднегно фильтрна, список на открытие гридов и список на включение слоёв
			var middleFilterSource = '';//'MIDDLE_ILI_FILTER';
			var topFilterSource = '';//'ILI_INSP_FILTER;
			var filterType = '';
			var openTableInterval = (scenario.openTableInterval) ? scenario.openTableInterval : 3000;
			//установить верхний фильтр
			var filterParams = [{name: 'filter', value: 'ILI_INSP_FILTER:' + currentObject.split(':')[1]}]
			WidgetMap.updateTopFilter(filterParams);
			var filterName = 'ILI_INSP_FILTER';
			var splittedFilter = filterParams[0].value.split('|');
			for (var i = 0; i < splittedFilter.length; i++) {
				if (splittedFilter[i].indexOf(filterName) !== -1) {
					var filterValue = splittedFilter[i].split(':')[1];
					for (var k = 0; k < showLayers.length; k++) {
						//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
						var smallLayerId = showLayers[k];
						WidgetMap.currentFilter[smallLayerId] = [];
						WidgetMap.currentFilter[smallLayerId].push({
							layerName: smallLayerId,
							filter: filterName,
							value: filterValue
						});
					}
					break;
				}
			}
			var filter = scenario.filter;
			if (filter) {
				if (filter.type)
					filterType = filter.type;
				if (filter.middleFilterSource)
					middleFilterSource = filter.middleFilterSource;
				if (filter.topFilterSource)
					topFilterSource = filter.topFilterSource;
			}

			if (middleFilterSource !== '') {
				ExternalInteraction.showFilter(filterType, topFilterSource, middleFilterSource, showLayers, function () {
					ExternalInteraction.showLayers(showLayers);
					ExternalInteraction.showTables(scenario.openTables);
				})
			} else {
				ExternalInteraction.showLayers(showLayers);
				ExternalInteraction.showTables(scenario.openTables);
			}
		}
	}
}

ExternalInteraction.showTables = function (tables) {
	if (tables && tables.length === 0)
		return;
	var table = tables.pop();
	ExternalInteraction.openTable(table.gridId, table.title, table.levelParams);
	setTimeout(function () {
		ExternalInteraction.showTables(tables);
	}, 3000);
};

/**
 * Возвращает распарсенные параметры задачи
 * @param {*} taskName
 */
ExternalInteraction.parseTask = function (taskName){
	App.serverQueryJSON('./Core/UITasks/'+taskName.toLowerCase()+'.json', result, fault);
	function fault(res) {
		App.errorReport(gis_main55_2, res, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_12'});
	}
	function result(res) {
		try {
			if (res !== undefined && res.code === 200) {
				var scenario;
				if (res.tree && res.tree.trees && res.tree.trees.length > 0)
					scenario = res.tree.trees[0].startupScenario;
				if (WidgetMap) WidgetMap.config = res;
				if (scenario) {
					//забираем флаг открытия среднегно фильтрна, список на открытие гридов и список на включение слоёв
					var filter = scenario.filter;
					var middleFilterSource = '';//'MIDDLE_ILI_FILTER';
					var topFilterSource = '';//'ILI_INSP_FILTER;
					var filterType = '';
					if (filter.type !== undefined && filter.type !== '')
						filterType = filter.type;
					if (filter.middleDataSource !== undefined && filter.middleDataSource !== '')
						middleFilterSource = filter.middleDataSource;
					if (filter.topDataSource !== undefined && filter.topDataSource !== '')
						topFilterSource = filter.topDataSource;
					var showLayers = [];
					if (middleFilterSource !== '') {
						ExternalInteraction.showFilter(filterType, topFilterSource, middleFilterSource, showLayers, function (ids) {
							var objectFullId = 'PODS_ROUTE:' + ids.join(':');
							App.loadDocuments('#postswrapper', objectFullId, 'objId', true);
						});
					}
				}
			}
		}
		catch(ex) {
			App.errorReport(gis_main55_2, ex, undefined, {filename:gis_filename_110, functionname:'gis_filename_483_6'});
		}
	}
}
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

var dateFormat = function () {
    var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function (val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) val = "0" + val;
            return val;
        };

    // Regexes and supporting functions are cached through closure
    return function (date, mask, utc) {
        var dF = dateFormat;

        // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
        if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
            mask = date;
            date = undefined;
        }

        // Passing date through Date applies Date.parse, if necessary
        date = date ? new Date(date) : new Date;
        if (isNaN(date)) throw SyntaxError("invalid date");

        mask = String(dF.masks[mask] || mask || dF.masks["default"]);

        // Allow setting the utc argument via the mask
        if (mask.slice(0, 4) == "UTC:") {
            mask = mask.slice(4);
            utc = true;
        }

        var	_ = utc ? "getUTC" : "get",
            d = date[_ + "Date"](),
            D = date[_ + "Day"](),
            m = date[_ + "Month"](),
            y = date[_ + "FullYear"](),
            H = date[_ + "Hours"](),
            M = date[_ + "Minutes"](),
            s = date[_ + "Seconds"](),
            L = date[_ + "Milliseconds"](),
            o = utc ? 0 : date.getTimezoneOffset(),
            flags = {
                d:    d,
                dd:   pad(d),
                ddd:  dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m:    m + 1,
                mm:   pad(m + 1),
                mmm:  dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy:   String(y).slice(2),
                yyyy: y,
                h:    H % 12 || 12,
                hh:   pad(H % 12 || 12),
                H:    H,
                HH:   pad(H),
                M:    M,
                MM:   pad(M),
                s:    s,
                ss:   pad(s),
                l:    pad(L, 3),
                L:    pad(L > 99 ? Math.round(L / 10) : L),
                t:    H < 12 ? "a"  : "p",
                tt:   H < 12 ? "am" : "pm",
                T:    H < 12 ? "A"  : "P",
                TT:   H < 12 ? "AM" : "PM",
                Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

        return mask.replace(token, function ($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
        });
    };
}();

// Some common format strings
dateFormat.masks = {
    "default":      "ddd mmm dd yyyy HH:MM:ss",
    shortDate:      "m/d/yy",
    mediumDate:     "mmm d, yyyy",
    longDate:       "mmmm d, yyyy",
    fullDate:       "dddd, mmmm d, yyyy",
    shortTime:      "h:MM TT",
    mediumTime:     "h:MM:ss TT",
    longTime:       "h:MM:ss TT Z",
    isoDate:        "yyyy-mm-dd",
    isoTime:        "HH:MM:ss",
    isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
dateFormat.i18n = {
    dayNames: [
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
    ],
    monthNames: [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
        "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
    ]
};

// For convenience...
Date.prototype.format = function (mask, utc) {
    return dateFormat(this, mask, utc);
};
//Глобальный объект
MapUtil = {};

/**
 * Установка дефолных разрешений карты
 * @returns {number}
 * @constructor
 */
MapUtil.setDefaultResolutions = function() {
	var resolutions=[];
	var DEFAULT_MAX_RESOLUTION = 156543.0339;
	var minZoom = 4;
	var maxZoom = 22;
	var zoom = maxZoom + 1;
	resolutions.push(DEFAULT_MAX_RESOLUTION);
	var i = 1;
	for (; i < zoom; i++) {
		resolutions.push(resolutions[i - 1] / 2);
	}
	resolutions = resolutions.slice(minZoom);
	return resolutions;
};

/**
 * Установка дефолных разрешений карты тех. схемы
 * @returns {number}
 * @constructor
 */
MapUtil.setDefaultTechSchemaResolutions = function(maxZoom) {
	var nominalResolution = 1.40625;
	var resolutions = [];
	var minZoom = 3;
	var maxZoom = (maxZoom) ? maxZoom  : 20;
	resolutions.push(nominalResolution * 20);
	var i = 1;
	for(i; i < maxZoom; i++){
		resolutions.push(resolutions[i - 1] / 2);
	}
	resolutions = resolutions.slice(minZoom);
	return resolutions;
};

/**
 * После открытия формы настроек пользователя устанавливаем параметры
 * @param params
 * @param force - форсирование переустановки в системе
 */
MapUtil.applyThemeParams = function(params, force) {
	//TODO upd. 21.01.20 хардкод. Если виджеты, то всё сворачиваем и растровый режим
	if(getParameterByName('w') === '1'){
		WidgetMap.sendCadastreEmail = false;
		WidgetMap.CURRENT_MODE = WidgetMap.MODES.RASTER;
		WidgetMap.showCenterMap = false;
		WidgetMap.showOverviewMap = false;
		WidgetMap.coordMode = WidgetMap.COORD_MODES.DECIMAL;
		return;
	}
	if(WidgetMap !== undefined){
		if (params.showOverviewMap !== undefined) WidgetMap.showOverviewMap = params.showOverviewMap;
		if (params.showTree !== undefined) WidgetMap.showTree = params.showTree;
		if (params.sendCadastreEmail !== undefined) WidgetMap.sendCadastreEmail = params.sendCadastreEmail;
		if (params.showCenterMap !== undefined) WidgetMap.showCenterMap = params.showCenterMap;
		var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
		if (WidgetMap.MODES !== undefined) {
			if (params.mapMode === WidgetMap.MODES.RASTER)
				WidgetMap.CURRENT_MODE = (mapConfig.block_raster_pipe_mode !== true)?params.mapMode:WidgetMap.MODES.VECTOR;
			else
				WidgetMap.CURRENT_MODE = WidgetMap.MODES.VECTOR;
		}
		if (WidgetMap.COORD_MODES !== undefined) {
			if (params.coordMode === 'decimal')
				WidgetMap.coordMode = WidgetMap.COORD_MODES.DECIMAL;
			else
				WidgetMap.coordMode = WidgetMap.COORD_MODES.GRAD;
		}
		if (params.useSynchronization !== undefined) App.syncEnabled = params.useSynchronization;

		//если сохраняем форму личных настроек, то применяем только нужные,например, режим карты
		if(force === true){
			//changeMode(WidgetMap.CURRENT_MODE)
			//sendCadastreEmail(WidgetMap.sendCadastreEmail)
			//hideTree(WidgetMap.showTree)
		}
		else{
			//changeMode(WidgetMap.CURRENT_MODE)
			//sendCadastreEmail(WidgetMap.sendCadastreEmail)
		}
	}
};

MapUtil.calculateObjectSize = function(object){
	//пробуем забрать текущий выделенный объект и посчитать его длину или площадь
	if(WidgetMap.mapSelectionLayer){
		var features = WidgetMap.mapSelectionLayer.getSource().getFeatures();
		if(features.length > 0 ){
			var feature = features[0];
			var geometry = feature.getGeometry();
			if(geometry){
				switch(geometry.getType()){
					case 'LineString':
						return '(' + map.controls.MeasureControl.prototype.calculateDistance_(feature) + ')';
					case 'Polygon':
						return '(' + map.controls.MeasureControl.prototype.calculateArea_(feature).replace('<br/>',';') + ')';
				}
			}
		}
	}
	return '';
};


/**
 *
 * @param that - локальная переменная that извне
 * @param layerObj
 * @param thatt контекст this извне
 */
MapUtil.showObjectError = function(that, layerObj, thatt){
	if(!layerObj || !that)
		return;
	if(that.ignoreErrors)
		return;
	if (goog.isDef(that.showObjectsErrorHandler)) {
		that.showObjectsErrorHandler.apply(thatt, [layerObj.layer.useServerCache ? gis_bindtolineform_4 : gis_widgetmap_3, that.showObjectError]);
	} else {
		App.confirmDialog(layerObj.layer.useServerCache ? gis_bindtolineform_4 : gis_widgetmap_3, null, {title: gis_core_1});
	}
}

MapUtil.getTopFilterByName = function(name){
	var filter = undefined;
	if(WidgetMap && WidgetMap.currentTopFilter){
		WidgetMap.currentTopFilter.forEach(function(item){
			if(item.name === name)
				filter = item;
		});
	}
	return filter;
}


MapUtil.updateLayerData = function(layerName, ids, needLoadData){
	if(checkMapExisting()){
		var layer = WidgetMap.layerManager.getLayerByName(layerName);
		if(layer && layer.layer){
			if(ids && ids.length === 0){
				layer.layer.refreshLayerData();
				return;
			}
			//сначала удаляем с карты объекты
			layer.layer.deleteObjectsByIds(ids);
			//перезапрашиваем из базы геометрии
			if(needLoadData){
				layer.layer.refreshData(ids);
				//layer.layer.refreshObjectGeometryByIds(ids);
			}

		}
	}
}


/**  Вынесено из WidgetMap */

/**
 * Чистка слоя с выделенными объектами
 */
MapUtil.clearSelectionLayer = function(){
	if(WidgetMap && WidgetMap.mapSelectionLayer)
		WidgetMap.mapSelectionLayer.getSource().clear();
	WidgetMap.mapSelectedObject = undefined;
};

/**
 * Смена сортировки векторных слоёв на основе order и mapOrder
 */
MapUtil.reorderVectorLayers = function(){
	if(WidgetMap && WidgetMap.currentVectorGroupLayer){
		var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
		var layers = tLayers.getArray();
		// generic comparison function
		var cmp = function(x, y){
			return x > y ? 1 : x < y ? -1 : 0;
		};

		//sort name ascending then id descending
		layers.sort(function(a, b){
			//note the minus before -cmp, for descending order
			return cmp(
				[cmp(a.values_.mapOrder, b.values_.mapOrder), -cmp(a.values_.order, b.values_.order)],
				[cmp(b.values_.mapOrder, a.values_.mapOrder), -cmp(b.values_.order, a.values_.order)]
			);
		});

		WidgetMap.currentVectorGroupLayer.setLayers(new ol.Collection(layers));
	}
};

/**
 * Закрыть выпадающий список кнопок на карте
 */
MapUtil.closeButtons = function (sender) {
	if(!WidgetMap) return;
	switch(sender){
		case 'mapView':
			if(WidgetMap.share)WidgetMap.share.setVisible_(false);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(!WidgetMap.viewMap.isVisible);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(false);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(false);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(false);
			break;
		case 'share':
			if(WidgetMap.share)WidgetMap.share.setVisible_(!WidgetMap.share.isVisible);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(false);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(false);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(false);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(false);
			break;
		case 'searchOnMap':
			if(WidgetMap.share)WidgetMap.share.setVisible_(false);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(false);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(false);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(false);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(!WidgetMap.searchOnMap.isVisible);
			break;
		case 'export':
			if(WidgetMap.share)WidgetMap.share.setVisible_(false);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(false);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(false);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(!WidgetMap.exportImageControl.isVisible);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(false);
			break;
		case 'measure':
			if(WidgetMap.share)WidgetMap.share.setVisible_(false);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(false);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(!WidgetMap.measureControl.isVisible);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(false);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(false);
			break;
		default:
			if(WidgetMap.share !== undefined){
				WidgetMap.share.setVisible_(false);
				WidgetMap.share.isVisible = false;
			}
			if(WidgetMap.searchOnMap !== undefined){
				WidgetMap.searchOnMap.setVisible_(false);
				WidgetMap.searchOnMap.isVisible = false;
			}
			if(WidgetMap.viewMap !== undefined){
				WidgetMap.viewMap.setVisible_(false);
				WidgetMap.viewMap.isVisible = false;
			}

			if(WidgetMap.measureControl !== undefined){
				WidgetMap.measureControl.setVisible_(false);
				WidgetMap.measureControl.isVisible = false;
			}

			if(WidgetMap.exportImageControl !== undefined){
				WidgetMap.exportImageControl.setVisible_(false);
				WidgetMap.exportImageControl.isVisible = false;
			}
			break;
	}
	if(WidgetMap.baseLayersControl !== undefined && sender !== undefined && sender !== '')
		WidgetMap.baseLayersControl.close();

};

MapUtil.getAvailableMapMode = function(mode){
	var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
	if (mapConfig.block_raster_pipe_mode === true)
		return WidgetMap.MODES.VECTOR;
	return mode;
}

/**
 * Получение координат и масштаба для объекта
 * @param layerName
 * @param id
 */
MapUtil.getWaterwayGeoById = function(layerName, id, callback){
	function reqParams() {
		var layer = WidgetMap.layerManager.getLayerByName(layerName);
		var request = (layer && layer.dataProvider && layer.dataProvider.spatial) ? layer.dataProvider.spatial: 'WATERWAY_GEO.xml#WATERWAY_CROSS';
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var filterStr = 'ID=' + id;
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" ' + topFiltersStr + '>' +
				'<data FILTER="' + filterStr + '" />' +
				'</root>'
		};
	}
	function result(resultXml) {
		try {
			var coords = null;
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') {
				App.errorReport(gis_core_error_2, er, undefined, {
					filename: gis_filename_626,
					functionname: 'gis_filename_626_68'
				});
				return;
			}
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			var stride = 2;
			if (datas.length > 0) {
				//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
				var format = new ol.format.WKT({dimension: stride});
				var wktStr = datas[0].getAttribute("WKT");//;"POINT(-1 -1)";
				var fGeometry = undefined;
				try {
					fGeometry = format.readGeometry(wktStr);
				} catch (ex) {
					//для случая с видеозаписями, приходит 3 координаты
					stride = 3;
					format = new map.format.WKT({dimension: stride});
					fGeometry = format.readGeometry(wktStr);
				}
				if (fGeometry) {
					var coords = fGeometry.flatCoordinates;
					coords.length = 2;
				}
			}
			if (callback) callback(coords);
		}
		catch(ex){
			App.errorReport(gis_core_error_2, ex.message, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_69'});
		}
	}

	function fault(resultXml) {
		BlockingUtil.ready();
		var dataString = $(resultXml).children('string').text();
		var er = HTTPServiceUtil.getError(dataString);
		if (er === '')
			er = dataString;
		App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_70'});
	}
	BlockingUtil.wait();
	App.serverQueryXML2Node(Services.processQueryNodeGeo, reqParams(), result, fault);
}

//Глобальный объект
GridUtil = {};
//список полей грида, которые будут игнорироваться в проверках и на вставке из excel
GridUtil.IGNORING_PASTE_COLUMNS = ['CTIME', 'MTIME', 'CUSER', 'MUSER', 'CUSER_ID', 'MUSER_ID'];

/**
 * Преобразхования массива [{name="FILTER_NAME", value="FILTER_VALUE"},] в {FILTER_NAME:FILTER_VALUE,}
 * @param topFilter
 */
GridUtil.formatTopFilterToObject = function(topFilter){
	var res = {};
	topFilter.forEach(function (item) {
		res[item.name] = item.value
	});
	return res;
};

/**
 * Копирование данных ячеек в Excel
 * @param text
 */
GridUtil.copyToExcelDialog = function(text) {
	$('#copyToExcelDialog').remove();
	var divv = '<div id="copyToExcelDialog">' +
		'<div style="color: white;">' + gis_gridutil_2+ '<br/><br/>'+gis_gridutil_3 + '</div>' +
		'<div style="display: inline-block;position: absolute;top: 49px;width: 100%;bottom: 10px;">' +
		'<textarea id="copyToExcelText" style="width:100%;margin: 1px;color: #005d98;height: 100%;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text"></textarea></div>' +
		'</div>';
	$('body').append(divv);
	$('#copyToExcelText').val(text);
	var dlg = $('#copyToExcelDialog');
	var bts = [{
		text: gis_core_13,
		click: function(){
			$('#copyToExcelDialog').remove();
		}
	}];
	dlg.dialog({
		modal: true,
		title: gis_gridwidget_86,
		dialogClass: 'ui-dialog-confirm1',
		closeOnEscape: false,
		width: 1100,
		height: 400,
		resizable: true,
		buttons : bts
	});
	$('#copyToExcelText').select();
};


/**
 * Валидация ячейки
 * @param value
 * @param columnType
 * @returns {string}
 */
GridUtil.validateCell = function (value, columnType) {
	if(columnType === 'filter'){
		/*if(gridFilterManager){
			var cols = dataAdapter.currentGridDescr.gridColumns;
			var filterRequestId = '';
			var colName = ''
			cols.forEach(function (it, index) {
				if(it.datafield && it.datafield === dataField){
					filterRequestId = it.filterrequestid;
					colName = it.text;
				}
			});
			var checkedFilterData = gridFilterManager.getDataByDataField(filterRequestId,value);
			if(!checkedFilterData){
				dataAdapter.currentGridDescr.revertFilter = event;
				//App.confirmDialog(gis_gridwidget_114);
				App.errorReport(gis_gridwidget_94, gis_gridwidget_95.replace('{COLUMN_NAME}',dataField).replace('{DICT_NAME}',filterRequestId) , undefined, {filename:gis_filename_243, functionname:'gis_filename_243_62'});
				return ;
			}
		}*/
	}
	else if(columnType === 'stringnumber'){
		if(value){
			if(value.indexOf(',') !== -1)
				value = value.replace(',','.');
			if(isNaN(parseFloat(value)))
				return gis_gridwidget_112;
		}
	}
	else if(columnType === 'date'){
		if (!value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4}) (\d{2}):(\d{2}):(\d{2})$/))
			if (!value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/))
				return gis_gridwidget_113;
	}
	else{//строки

	}
	return '';
}

/**
 * Валидация ячейки
 * @param value
 * @param columnType
 * @returns {string}
 */
GridUtil.validateCell2 = function (value, columnType, columnName) {
	try{
		if(columnType === 'filter'){
			if(!value){
				return gis_gridwidget_133.replace('{COLUMN_NAME}', columnName);
			}
			/*if(gridFilterManager){
				var cols = dataAdapter.currentGridDescr.gridColumns;
				var filterRequestId = '';
				var colName = ''
				cols.forEach(function (it, index) {
					if(it.datafield && it.datafield === dataField){
						filterRequestId = it.filterrequestid;
						colName = it.text;
					}
				});
				var checkedFilterData = gridFilterManager.getDataByDataField(filterRequestId,value);
				if(!checkedFilterData){
					dataAdapter.currentGridDescr.revertFilter = event;
					//App.confirmDialog(gis_gridwidget_114);
					App.errorReport(gis_gridwidget_94, gis_gridwidget_95.replace('{COLUMN_NAME}',dataField).replace('{DICT_NAME}',filterRequestId) , undefined, {filename:gis_filename_243, functionname:'gis_filename_243_62'});
					return ;
				}
			}*/
		}
		else if(columnType === 'stringnumber'){
			if(value){
				if(value.indexOf(',') !== -1)
					value = value.replace(',','.');
				if(isNaN(parseFloat(value)))
					return gis_gridwidget_131.replace('{COLUMN_NAME}', columnName).replace('{VALUE}',value);
			}
		}
		else if(columnType === 'date'){
			if(!value)
				return '';
			if (!value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/) && !value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/) )
				return gis_gridwidget_132.replace('{COLUMN_NAME}', columnName).replace('{VALUE}',value);
		}
		else{//строки

		}
	}
	catch(ex){
	}
	return '';
}


/**
 * Приведение данных ячейки в корректный вид
 * @param value
 * @param columnType
 */
GridUtil.prepareCellValue = function (value, columnType) {
	if(columnType === 'stringnumber'){
		if(value){
			if(value.indexOf(',') !== -1)
				value = value.replace(',','.');
			return parseFloat(value);
		}
	}
	else if(columnType === 'date'){
		//if (!value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4}) (\d{2}):(\d{2}):(\d{2})$/))
		//if (!value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/))
		return value;
	}
	return value;
}


GridUtil.revertCell = function (gridElem, event) {
	if(gridElem){
		// event arguments.
		var args = event.args;
		// column data field.
		var dataField = event.args.datafield;
		// row's bound index.
		var rowBoundIndex = event.args.rowindex;
		// cell value
		var value = args.value;
		// cell old value.
		var oldvalue = args.oldvalue;
		// row's data.
		var rowData = args.row;
		//откатываем значение до прошлого
		gridElem.jqxGrid('setcellvalue', rowBoundIndex, dataField, oldvalue);
	}
}


GridUtil.getDetailDbError = function(error){
	if(error.indexOf('неверный синтаксис для типа numeric') !== -1 )
		return gis_gridwidget_96;
	if(error.indexOf('нарушает ограничение внешнего ключа') !== -1)
		return gis_gridwidget_97;
	return gis_gridwidget_85;
};

/**
 * Форматирование данных в зависимости от типа
 * @param val
 * @param dataType
 */
GridUtil.prepareValueByDataType = function(val, dataType){
	if(dataType === 'Decimal' && val){
		if(val.indexOf(':') !== -1){
			var sp = val.split(':');
			val = sp[0];
			if(sp.length === 2){
				val += '.' + parseInt((sp[1]/6)*10, 10);
			}
		}
		else
			val = val.replace(',','.');
	}

	return val;
}

/**
 * Форматирование данных в зависимости от типа
 * @param val
 * @param dataType
 * @param columnName
 */
GridUtil.prepareValueByDataType2 = function(val, dataType, columnName){
	if(columnName && GridUtil.IGNORING_PASTE_COLUMNS.indexOf(columnName) !== -1)
		return;
	if(dataType === 'stringnumber' ){
		if(val){
			val = val.replace(',','.');
			if(!isNaN(parseFloat(val)))
				val = parseFloat(val);
		}
	}
	if(dataType === 'date'){
	}
	return val;
}

/**
 * Форматирование данных в зависимости от типа для вставки в excel
 * @param val
 * @param dataType
 */
GridUtil.prepareValueByDataTypeToExcel = function(val, dataType){
	if(dataType === 'stringnumber' && val)
		val = val.replace('.',',');
	return val;
}


GridUtil.copyToExcelEvent = function(gridColumns, dataObj, idColumn){
	var colsObj = {};
	var colNames = [];
	idColumn = idColumn || 'ID';
	gridColumns.forEach(function (it, index) {
		if(it.datafield && (!Number.isInteger(it.datafield) && !it.hidden && it.datafield !== 'RWN') || it.datafield === 'ID'){

			colsObj[it.datafield] = {text: it.text, datafield: it.datafield, columntype: it.columntype};
			colNames.push(it.datafield);
		}
	});
	if(colNames.indexOf('ID') === -1){
		colsObj.ID = {text: 'ID', datafield: 'ID', columntype: 'string'};
		colNames.unshift('ID');
	}
	//если ключ первичный не id(справочники. у них code), то id удаляем из копирования
	if(idColumn !== 'ID') {
		colNames.shift();
		delete colsObj.ID;
	}
	var resultExcel = '';
	//добавляем колонки в шапку
	resultExcel += colNames.join('\t') + '\n';
	dataObj.forEach(function(it){
		var resultItem = '';
		colNames.forEach(function(colName, index){
			var val = it[colName];
			if(val){
				val = GridUtil.prepareValueByDataTypeToExcel(val, colsObj[colName].columntype );
				resultItem += val + '\t';
			}
			else
				resultItem += '\t';
		});
		resultItem += '\n';
		resultExcel += resultItem;
	});
	GridUtil.copyToExcelDialog(resultExcel);
};




GridUtil.getProvDataXml = function(source, callback){
	var that = this;
	//Подгружаем все параметры запроса выбранного источника
	if (source&& source.indexOf("#")>0){
		BlockingUtil.wait();
		function getReqParams(source) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			return {
				getSchema: false,
				descrId: 'SYS_SEM.xml#GET_DATA_XML',
				toElements: false,
				descrType: 'select',
				data:  '<root USER_ID="'+userId.xmlEscape()+
					'" USER_LOGIN="'+userLogin.xmlEscape()+
					'" PODS_USER="'+userLogin.xmlEscape()+
					'" >'+
					'<data file="'+source.split("#")[0]+'" dataId="'+source.split("#")[1]+'" />'+
					'</root>'
			};
		}
		function onProvDataResult(resultXml) {
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.ready();
					App.errorReport(gis_gridwidget_127.replace('{COMMAND}',source), resultXml, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_66'});
					return;
				}
				var paramsTypes = {};
				var insert = resultXml.find("insert");
				if (insert.length > 0 && insert[0].getElementsByTagName("dbCommand").length > 0) {
					var vars = insert[0].getElementsByTagName("dbCommand")[0].getElementsByTagName("var");
					var i=0;
					for(; i < vars.length; i++){
						//Получаем переменные запроса select
						var attrName = vars[i].getAttribute('name');
						paramsTypes[attrName] = vars[i].getAttribute('type');
					}
				}
				//переменная, куда заносим типы колонок из файла запросов для данной команды, далее ищем по ключу
				if(callback)
					callback(paramsTypes);
			}
			catch(e){
			}
			finally{
				BlockingUtil.ready();
			}
		}
		function onProvDataFault(resultXml) {
			BlockingUtil.ready();
			App.errorReport(gis_gridwidget_127.replace('{COMMAND}',source), resultXml, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_66'});
		}
		App.serverQueryNodeWithTries(Services.processQueryNodeXml, getReqParams(source), onProvDataResult, onProvDataFault,4);
	}
};


/**
 * Вставка записей из Excel для доп. данных дефектов
 * @param currentGrid текущий грид
 * @param curDataAdapter текущий адаптер грида
 */
GridUtil.pasteStoIliDataAdvCells = function (currentGrid, curDataAdapter, rowData, dataRequest, parametersTypes, that, needConfirmMessage) {
	try{
		if(currentGrid && curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData){
			var layerName = curDataAdapter.currentGridDescr.layerId;
			var jqxGridId = currentGrid.id;
			var currentGridDescr = curDataAdapter.currentGridDescr;
			var iliInspectionId = rowData.ID;
			var rows = GridUtil.convertPlainExcelDataToTable(currentGridDescr.pasteFromExcelData);
			var rows4Insert = [];
			if(rows.length > 0){
				var columns = rows[0];// в служебном режиме 1-я строка - строка с названиями колонок
				rows.forEach(function(row, i){
					if(i !== 0){
						var data = {};
						//имена колонок приводим в upperCase, чтобы совпадали с названиями переменных
						row.forEach(function(val, valIndex){
							var colName = columns[valIndex].toUpperCase();
							var columnType = parametersTypes[colName];
							var preparedVal = GridUtil.prepareValueByDataType(val, columnType);
							data[colName] = preparedVal;// устанавливаем в колонку соответствующее значение. индексы совпадают
						});
						//добавляем идентификатор обследования в команду вставки в БД
						data.ILI_INSPECTION_ID = iliInspectionId;
						rows4Insert.push({rowData: data, classId:layerName, objectId:data.ID, provider: dataRequest, dataAdapter: curDataAdapter});
					}
				});
			}
			var buttons = [
				{
					text: gis_core_4, click: function () {
						App.destroyDialog(undefined, this);
						GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_120, rows4Insert.reverse(), that, that.insertStoILiDataAdvObject,
							function(errorsCount, processedCount, isCancel){
								if(isCancel !== true)
									GridWidget.linkStoDataAdv(iliInspectionId, jqxGridId);
								/*else
									GridWidget.refreshGrid(jqxGridId);*/
							}, function(){
								//GridWidget.refreshGrid(jqxGridId);
							}, true);
					}
				},
				{
					text: gis_core_5, click: function () {
						App.destroyDialog(undefined, this);
					}
				}
			];
			if(needConfirmMessage)
				App.confirmDialog(gis_gridwidget_111.replace('{ROWS_COUNT}', rows4Insert.length), buttons, {title:gis_core_1, html:true});
			else{
				GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_120, rows4Insert.reverse(), that, that.insertStoILiDataAdvObject,
					function(errorsCount, processedCount, isCancel){
						if(isCancel !== true)
							GridWidget.linkStoDataAdv(iliInspectionId, jqxGridId);
						/*else
							GridWidget.refreshGrid(jqxGridId);*/
					}, function(){
						//GridWidget.refreshGrid(jqxGridId);
					}, true);
			}
		}
	}
	catch(ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_64'});
	}
	finally {
		curDataAdapter.currentGridDescr.pasteFromExcelData = undefined;
	}
}

GridUtil.scalarReader = function(source, callback){
	//Подгружаем все параметры запроса выбранного источника
	if (source && source.indexOf("#")>0){
		BlockingUtil.wait();
		function getReqParams(source) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			return {
				getSchema: false,
				descrId: source,
				toElements: false,
				descrType: 'select',
				data:  '<root USER_ID="'+userId.xmlEscape()+
					'" USER_LOGIN="'+userLogin.xmlEscape()+
					'" PODS_USER="'+userLogin.xmlEscape()+
					'" >'+
					'<data  />'+
					'</root>'
			};
		}
		function onProvDataResult(resultXml) {
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.ready();
					App.errorReport(gis_gridwidget_135, resultXml, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_9'});
					return;
				}
				var inspectionId = '';
				$(resultXml).find('data').each(function(){
					if($(this).attr('ID'))
						inspectionId = 	$(this).attr('ID');
				});
				//переменная, куда заносим типы колонок из файла запросов для данной команды, далее ищем по ключу
				if(callback)
					callback(inspectionId);
			}
			catch(e){
			}
			finally{
				BlockingUtil.ready();
			}
		}
		function onProvDataFault(resultXml) {
			BlockingUtil.ready();
			App.errorReport(gis_gridwidget_135, resultXml, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_10'});
		}
		App.serverQueryNodeWithTries(Services.processQueryNode, getReqParams(source), onProvDataResult, onProvDataFault,4);
	}
};


/**
 * Получить количество дефектов, имеющих доп. сведения
 * @param item
 * @param callback
 */
GridUtil.getCountStoIliDataAdv = function(item, callback){
	function reqParams(id) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		return {
			getSchema: false,
			descrId: 'STO_SEM.xml#STO_ILI_DATA_ADV_CHECK',
			toElements: false,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'"><data ILI_INSPECTION_ID="' + id + '"  />' +
				'</root>'
		};
	}
	function result(resultXml) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if (er !== ""){
			App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_620, functionname:'gis_filename_243_65'});
		}
		else{
			var datas = $($.parseXML(resultXml)).find('data');
			//флаг имеются ли рассчетные данные от исполнителя ВТД. количество должно быть > 0
			var hasAdvCalcData = false;
			datas.each(function (i, item) {
				var cnt = $(item).attr("CNT");
				if(cnt !== undefined && parseInt(cnt, 10) > 0 )
					hasAdvCalcData = true;
			});
			if(hasAdvCalcData && callback){
				callback(false, hasAdvCalcData);
				return;
			}

			function okAction() {
				dlg.dialog('destroy').remove();
			}

			function createEmptySheet(){
				if(callback)
					callback(true, hasAdvCalcData);
				dlg.dialog('destroy').remove();
			}
			var buttons = [
				{text: gis_core_12,  click: okAction},
				{text: gis_gridwidget_134,  click: createEmptySheet}
			];

			var dlg = App.confirmDialog(gis_gridwidget_116, buttons, {title: gis_gridwidget_115, width: 400, html:true});
		}
	}

	function fault(resultXml) {
		BlockingUtil.ready();
		var dataString = $(resultXml).children('string').text();
		var er = HTTPServiceUtil.getError(dataString);
		if (er === "")
			er = dataString;
		App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_62'});
	}
	if(item && item.ID && item.ID !== ''){
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams(item.ID), result, fault,4);
	}
	else
		App.errorReport(gis_core_error_2, gis_gridwidget_115, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_63'});

}

/**
 * Получить количество критических дефектов для межкранового участка
 * @param item
 * @param callback
 */
GridUtil.getCountCriticalStoIliDataAdv = function(item, callback){
	function reqParams(data) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		return {
			getSchema: false,
			descrId: 'STO_SEM.xml#STO_ILI_DATA_ADV_CRITICAL_CHECK',
			toElements: false,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'"><data ILI_INSPECTION_ID="' + data.ID + '" ROUTE_ID="' + data.ROUTE_ID + '" BEGIN_MEASURE="' + data.BEGIN_MEASURE + '" END_MEASURE="' + data.END_MEASURE + '" />' +
				'</root>'
		};
	}
	function result(resultXml) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if (er !== ""){
			App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_620, functionname:'gis_filename_243_65'});
		}
		else{
			var datas = $($.parseXML(resultXml)).find('data');
			//флаг имеются ли рассчетные данные от исполнителя ВТД. количество должно быть > 0
			var hasAdvCalcData = false;
			datas.each(function (i, item) {
				var cnt = $(item).attr("CNT");
				if(cnt !== undefined && parseInt(cnt, 10) > 0 )
					hasAdvCalcData = true;
			});
			if(hasAdvCalcData && callback){
				callback();
				return;
			}

			function okAction() {
				if(callback)
					callback(true);
				dlg.dialog('destroy').remove();
			}
			var buttons = [
				{text: gis_core_12,  click: okAction},
			];

			var dlg = App.confirmDialog(gis_gridwidget_116_1, buttons, {title: gis_gridwidget_115, width: 400, html:true});
		}
	}

	function fault(resultXml) {
		BlockingUtil.ready();
		var dataString = $(resultXml).children('string').text();
		var er = HTTPServiceUtil.getError(dataString);
		if (er === "")
			er = dataString;
		App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_62'});
	}
	if(item && item.ID && item.ID !== ''){
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams(item), result, fault,4);
	}
	else
		App.errorReport(gis_core_error_2, gis_gridwidget_115, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_63'});

};

/**
 * Конвертация текста, скопированного из Excel в табличный вид
 * @param plainText
 * @param withHeader
 */
GridUtil.convertPlainExcelDataToTable = function(plainText, withHeader){

	var rows = [];
	try {
		if (plainText) {
			//спец проверка, если есть такие символы в первой колонке, то по ним разделяем.
			//обходим проблему, что в какой-либо ячейке есть разделитель \n
			var rawRows = [];
			if(plainText.indexOf('$$\t') !== -1){
				rawRows = plainText.split('$$\t');
				rawRows.shift();//едаляем 1-й пустой элемент
			}
			else{
				rawRows = plainText.split('\n');
			}
			//разделяем данные
			rawRows.forEach(function (it, index) {
				if(it === '')
					return;
				//удаляем последний перенос строки, если данные пришли со спец символами
				if(it.lastIndexOf('\n') === (it.length - 1))
					it = it.slice(0, -1);
				it = it.replace(/(\r\n|\n|\r)/gm," ");//заменяем в строке переносы на пробелы(в колонке с комментариями)
				it = it.replace(/"/g,"&quot;");
				var rawRow = it.split('\t');
				rows.push(rawRow);
			});
		}
	}
	catch(ex){

	}

	return rows;
};

/**
 * Функция закрытия предпоследней вкладки. Используется в гридах с шурфовками для перехода из одного в другой и обратно
 */
GridUtil.closeTab = function(selectedIndex){
	//закрываем предпоследнюю вкладку грида
	var tabNav = $('#gridTabNavigator');
	if(tabNav.length !== 0){
		tabNav.jqxTabs('removeAt', selectedIndex);
		//tabNav.jqxTabs('select', selectedIndex);
	}
}
GridUtil.getSelectedTab = function(){
	//закрываем предпоследнюю вкладку грида
	var tabNav = $('#gridTabNavigator');
	var selectedIndex = -1;
	if(tabNav.length !== 0){
		selectedIndex = tabNav.jqxTabs('selectedItem');
	}
	return selectedIndex;
}

/**
 * Поиск и влкючение вкладки грида, если найдена по идентификатору грида
 * @param gridId
 * @returns {boolean}
 */
GridUtil.findAndSelectTabById = function(gridId){
	var tabNav = $('#gridTabNavigator');
	if(!tabNav.length)
		return false;
	var tabId = -1;
	var length = tabNav.jqxTabs('length');
	for (var i = 0; i < length; i++) {
		var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
		if('jqxgrid' + selectedContent.id === gridId){
			tabId = i;
			break;
		}
		var selector = $(selectedContent).find('.gridTabContentElement');
		if('jqxgrid' + selector.attr('id') === gridId){
			tabId = i;
			break;
		}
	}
	if(tabId !== -1){
		tabNav.jqxTabs('select', tabId);
		return true;
	}
	return false;
}

/**
 * Поиск и закрытие вкладки грида, если найдена по названию слоя
 * @param layerName
 * @returns {boolean}
 */
GridUtil.findAndCloseTabByLayerName = function(layerName){
	var tabNav = $('#gridTabNavigator');
	if(!tabNav.length)
		return false;
	var tabId = -1;
	var length = tabNav.jqxTabs('length');
	try{
		for (var i = 0; i < length; i++) {
			var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
			var selector = $(selectedContent).find('.mainGrid');
			var lid = selector.data('layerid');
			if(lid && lid.split('*').length > 1)
				if(selector.data('layerid').split('*')[1] === layerName){
					tabId = i;
					break;
				}
		}
		if(tabId !== -1){
			tabNav.jqxTabs('removeAt', tabId);
			return true;
		}
	}
	catch(ex){

	}
	return false;
}

/**
 * Получение всех GridWidget, которые открыты на карте
 * @param fullLayerId
 * @returns {*[]}
 */
GridUtil.findAllGridWidgetByFullLayerId = function(fullLayerId){
	var tabNav = $('#gridTabNavigator');
	if(!tabNav.length)
		return;
	var tabId = -1;
	var length = tabNav.jqxTabs('length');
	try{
		for (var i = 0; i < length; i++) {
			var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
			var selector = $(selectedContent).find('.mainGrid');
			var lid = selector.data('layerid');
			if(lid && lid.split('*').length > 1)
				if(selector.data('layerid') === fullLayerId){
					tabId = i;
					break;
				}
		}
		if(tabId !== -1 && App.GridManager){
			return App.GridManager.getAll(fullLayerId);
		}
	}
	catch(ex){ }
}

GridUtil.findTabByLayerName = function(fullLayerId){
	var tabNav = $('#gridTabNavigator');
	if(!tabNav.length)
		return;
	var tabId = -1;
	var length = tabNav.jqxTabs('length');
	try{
		for (var i = 0; i < length; i++) {
			var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
			var selector = $(selectedContent).find('.mainGrid');
			var lid = selector.data('layerid');
			if(lid && lid.split('*').length > 1)
				if(selector.data('layerid') === fullLayerId){
					tabId = i;
					break;
				}
		}
		if(tabId !== -1){
			tabNav.jqxTabs('select', tabId);
			if(App.GridManager && App.GridManager.has(fullLayerId)){
				var gridWidget = App.GridManager.get(fullLayerId);
				return gridWidget;
			}
		}
	}
	catch(ex){

	}
}

GridUtil.refreshTabByLayerName = function(fullLayerId){
	var tabNav = $('#gridTabNavigator');
	if(!tabNav.length)
		return;
	var tabId = -1;
	var length = tabNav.jqxTabs('length');
	try{
		for (var i = 0; i < length; i++) {
			var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
			var selector = $(selectedContent).find('.mainGrid');
			var lid = selector.data('layerid');
			if(lid && lid.split('*').length > 1)
				if(selector.data('layerid') === fullLayerId){
					tabId = i;
					break;
				}
		}
		if(tabId !== -1){
			tabNav.jqxTabs('select', tabId);
			if(App.GridManager && App.GridManager.has(fullLayerId)){
				var gridWidget = App.GridManager.get(fullLayerId);
				if(gridWidget){
					gridWidget.updateGridContent(options.data, options.forceTopFilter, false);
				}
			}
		}
	}
	catch(ex){

	}
}

GridUtil.findAndSelectTabByLayerName = function(layerName){
	var tabNav = $('#gridTabNavigator');
	if(!tabNav.length)
		return false;
	var tabId = -1;
	var length = tabNav.jqxTabs('length');
	try{
		for (var i = 0; i < length; i++) {
			var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
			var selector = $(selectedContent).find('.mainGrid');
			var lid = selector.data('layerid');
			if(lid === layerName){
				tabId = i;
				break;
			}
			if(lid && lid.split('*').length > 1)
				if(selector.data('layerid').split('*')[1] === layerName){
					tabId = i;
					break;
				}
		}
		if(tabId !== -1){
			tabNav.jqxTabs('select', tabId);
			return true;
		}
	}
	catch(ex){

	}
	return false;
}

/**
 * Поиск и закрытие вкладки грида, если найдена по идентификатору грида
 * @param gridId
 * @returns {boolean}
 */
GridUtil.findAndCloseTabById = function(gridId){
	var tabNav = $('#gridTabNavigator');
	if(!tabNav.length)
		return false;
	var tabId = -1;
	var length = tabNav.jqxTabs('length');
	for (var i = 0; i < length; i++) {
		var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
		if('jqxgrid' + selectedContent.id === gridId){
			tabId = i;
			break;
		}
		var selector = $(selectedContent).find('.gridTabContentElement');
		if('jqxgrid' + selector.attr('id') === gridId){
			tabId = i;
			break;
		}
	}
	if(tabId !== -1){
		tabNav.jqxTabs('removeAt', tabId);
		return true;
	}
	return false;
}

GridUtil.getTabById = function(tabId){
	var tabNavigator = $('#gridTabNavigator');
	return undefined;
}
/**
 * Функция для получения параметров переменных
 * @param request - название файла xml и ID запроса
 * @param descrType - тип операции [select, insert, update, delete]
 * @param callback - функция для продолжения операции
 * @param callbackParams - объект с параметрами
 * @return Array - массив со всеми переменными для запроса
*/
GridUtil.getRequestVariables = function(request, descrType, callback, callbackParams){
	var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
	var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
	var params = {
		descrId: 'SYS_SEM.xml#GET_DATA_XML', descrType: 'select',
		data:  '<root USER_ID="'+userId.xmlEscape() + '" USER_LOGIN="'+userLogin.xmlEscape()+ '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
			'<data file="'+request.split("#")[0]+'" dataId="'+request.split("#")[1]+'" />'+
			'</root>'
	};
	function result(resultXml) {
		try {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') {
				App.errorReport(gis_importexportgpxkmlform_16, er, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_5'});
			}
			else{
				var operations = resultXml.find(descrType);
				var vars = operations[0].getElementsByTagName("dbCommand")[0].getElementsByTagName("var");
				var params = operations[0].getElementsByTagName("dbCommand")[0].getElementsByTagName("param");
				var result = [];
				if(vars && vars.length || params && params.length){
					var i=0;
					for(; i < vars.length;i++) {
						var name =  vars[i].getAttribute('name');
						var type = vars[i].getAttribute('type');
						result.push({name: name, type: type});
					}
					for(i=0; i < params.length;i++) {
						var name =  params[i].getAttribute('name');
						var type = params[i].getAttribute('type');
						result.push({name: name, type: type});
					}
				}
				if (callback)
					callback(result, callbackParams);
			}
		}
		catch(ex){ }
	}
	function fault(resultXml) {
		App.errorReport(gis_importexportgpxkmlform_16, resultXml, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_6'});
	}
	App.serverQueryNodeWithTries(Services.processQueryNodeXml, params, result, fault);
}

GridUtil.selectTabById = function(tabId){
	if(tabId)
		$('#gridTabNavigator').jqxTabs('select', tabId);
}


GridUtil.convertGridDataToIdsArray = function(gridData){
	var result = [];
	try{
		if(gridData && gridData.length > 0){
			gridData.forEach(function(item){
				result.push(item.ID);
			});
		}
	}
	catch(ex){ }
	return result;
}

/**
 * Функция рендеринга статус бара грида
 * @param statusbar контейнер статус бара
 */
GridUtil.renderStatusBar = function (statusbar, gridId, that) {
	// appends buttons to the status bar.
	var container = $('<div class="grid-show-next-div"></div>');
	var reloadButton = $('<button class="grid-show-next-button">' + gis_gridutil_1 + '</button>');
	container.append(reloadButton);
	statusbar.append(container);
	reloadButton.click(function (event) {
		/*if(that)
			that.showNextRecords();*/
		//var gridWidget = App.GridManager.getByGridId(gridId);
		var gridWidget = that;
		if(gridWidget){
			var cachedData = gridWidget.cachedRecords;
			//var rows = $('#'+gridId).jqxGrid('getrows');
			//var lastRowNum = rows[rows.length -1].RWN;
			for(var i=0; i < 1000; i++){
				var it = cachedData[0];//$.extend({}, cachedData[0]);
				$('#'+gridId).jqxGrid('addrow', null, it);
			}

			/*cachedData.forEach(function(item, index){

			})*/
		}
		//$('#'+gridId).jqxGrid('gotonextpage');
		//$("#jqxgrid").jqxGrid({ source: dataAdapter });
	});
}

/**
 * Удаление всех панелей свойств в гридах
 */
GridUtil.removeAllPPanels = function(){
	try{
		$('.gridTabContentElement').each(function () {
			$('#divPPaneljqxgrid' + this.id).each(function () {//divPPaneljqxgridid5161_GRID
				$(this).remove();
			});
		});
	}
	catch(ex){

	}

}

/**
 * Функция оставляем в массиве только те колонки, которые видимые
 * @param datas
 * @param excludeColumns
 */
GridUtil.filterDataFromJson = function (items, excludeColumns) {
	var resArr = [];
	if(!items)
		return;
	for (var i = 0; i < items.length; i++) {
		var curItem = $.extend({}, items[i]);//Object.assign({}, items[i]);
		for (var j = 0; j < excludeColumns.length; j++) {
			var col = excludeColumns[j];
			if(col !== 'ID')// id оставляем всегда, т.к используется при поиске на карту, выборках и прочих операциях, даже если колонка невидима.
				delete curItem[col];
		}
		resArr.push(curItem);
	}

	return resArr;
};


GridUtil.getGridColumns = function (currentGrid){
	try{
		if(currentGrid){
			var gridWidget = App && App.GridManager && App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
			if(gridWidget)
				return gridWidget.columns;
		}
	}
	catch(ex){

	}
	return [];
}

GridUtil.getGridWidget = function (currentGrid){
	try{
		if(currentGrid){
			var gridWidget = App && App.GridManager && App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
			if(gridWidget)
				return gridWidget;
		}
	}
	catch(ex){

	}
	return null;
}
/**
 * Получение полных данных по строке грида
 * @param currentGrid
 * @param curRowData
 */
GridUtil.getFullRowDataById = function(currentGrid, curRowData){
	//т.к. часть данных в скрытых колонках, то из cachedRecords забираем весь набор атрибутов для выбраннй записи
	if(App.GridManager && curRowData && curRowData.ID && currentGrid){
		var grid = App.GridManager.getByGridId(currentGrid.id.replace("jqxgrid",''));
		if(grid && grid.cachedRecords && grid.cachedRecords.length > 0){
			for(var gI = 0; gI < grid.cachedRecords.length; gI++){
				if(grid.cachedRecords[gI].ID === curRowData.ID){
					return grid.cachedRecords[gI];
				}
			}
		}
	}
	return curRowData;
}
/**
 *
 * @param currentGrid
 * @returns {*}
 */
GridUtil.getFullRowsData = function(currentGrid){
	//т.к. часть данных в скрытых колонках, то из cachedRecords забираем весь набор атрибутов для выбраннй записи
	if(App.GridManager && currentGrid){
		var grid = App.GridManager.getByGridId(currentGrid.id.replace("jqxgrid",''));
		if(grid && grid.cachedRecords && grid.cachedRecords.length > 0)
			return grid.cachedRecords;
	}
	return [];
}

GridUtil.convertTopFilterToBottom = function(data){
	var filters = [];
	for(var obj in data){
		fArr.push({op:'=', value:filter[obj]});
	}
}


GridUtil.getBottomFilterString = function (filters/*Array*/, parentRoughFilter/*String*/, sourceType) {
	var _strFilter = "";
	if (filters && filters.length > 0) {
		var res = [];
		var n;
		for (var j = 0; j < filters.length; j++) {
			var f = filters[j];
			if (f.hasOwnProperty("val")) {
				switch (f.op) {
					case 'in': // из списка
						//TODO хардкод если поле YEAR_INSP, то в нижним фильтре игнорируем
						if(f.fld === 'YEAR_INSP')
							break;
						res.push(f.fld + " IN (" + GridWidget.prototype.getArrayDictFilter(f.val)+")");
						break;
					case '=': // число или строка
						//Даты игнорируем (они добавятся в фильтр верхнего уровня как переменные)
						if (f.hasType == 'date') {
							var startDate = f.startDate.toString();
							var endDate = f.endDate.toString();
							if(!startDate) startDate = '01.01.1900';
							if(!endDate) endDate = '01.01.2121';
							startDate += ' 00:00:00';
							endDate += ' 00:00:00';
							if(f.dateformat !== 'number'){
								res.push(f.fld + " BETWEEN '" + startDate + "'::date and '" + endDate + "'::date ");
							}
							else{
								//парсим строку в Date и получаем миллисекунды
								var startDateArr = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(startDate);//DD.MM.YYYY
								var endDateArr = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(endDate);//DD.MM.YYYY
								//new Date(year, month, day)
								startDate = new Date(Number(startDateArr[3]), Number(startDateArr[2]), Number(startDateArr[1])).getTime();
								endDate = new Date(Number(endDateArr[3]), Number(endDateArr[2]), Number(endDateArr[1])).getTime();
								res.push(f.fld + " >= " + startDate + " and "+f.fld+" <=" + endDate + " ");
							}
							break;
						}
						if (f.hasType == 'number') {
							if((f.val.toString()).indexOf(";")>0) { //тогда имеет место массив чисел и нужен оператор in
								var arr = f.val.toString().split(";");
								res.push(f.fld + " IN (" + GridWidget.prototype.getArrayFilter(arr)+")");
							}  else {
								n = GridWidget.prototype.getNumber(f.val.toString().replace(',','.'));
								if (!isNaN(n))
									res.push(f.fld + " = " + n.toString());
							}
						}
						break;
					case 'likeA':
						if((f.val.toString()).indexOf(";")>=0) { //тогда имеет место массив строк и нужен оператор in
							var arrStr = f.val.toString().split(";");
							//проверяем, все ли элементы в кавычка, если нет, то ставим
							for (var i = 0; i < arrStr.length; i++) {
								//replace (';;',';XZY;') заменяем
								if(arrStr[i].length == 0)
									arrStr[i] = "XZY";
								if(arrStr[i].indexOf("'")==-1) { //т.е. строки данного элемента ещё не обрамлены в кавычки
									if(arrStr[i].length>0){
										if(sourceType === 'SQLite')
											arrStr[i] = "'"+arrStr[i]+"'";
										else
											arrStr[i] = "UPPER('"+arrStr[i]+"')";
									}

								}
							}
							if(sourceType === 'SQLite')
								res.push("COALESCE(" + f.fld + ",'XZY')" + " IN (" + GridWidget.prototype.getArrayFilter(arrStr)+")");
							else
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY')" + " IN (" + GridWidget.prototype.getArrayFilter(arrStr)+")");
						} else {
							if(sourceType === 'SQLite'){
								if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
									res.push("COALESCE(" + f.fld + ",'XZY') IN ('XZY')");
								else
									res.push( f.fld + " LIKE '" + GridWidget.prototype.validate(f.val) + "'");
							}
							else{
								if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
									res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
								else
									res.push("UPPER(" + f.fld + ") LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "')");
							}

						}
						break;
					case 'notLikeA':
						if((f.val.toString()).indexOf(";")>=0) { //тогда имеет место массив строк и нужен оператор in
							var arrStr = f.val.toString().split(";");
							//проверяем, все ли элементы в кавычка, если нет, то ставим
							for (var i = 0; i < arrStr.length; i++) {
								//replace (';;',';XZY;') заменяем
								if(arrStr[i].length == 0)
									arrStr[i] = "XZY";
								if(arrStr[i].indexOf("'")==-1) { //т.е. строки данного элемента ещё не обрамлены в кавычки
									if(arrStr[i].length>0){
										if(sourceType === 'SQLite')
											arrStr[i] = "'"+arrStr[i]+"'";
										else
											arrStr[i] = "UPPER('"+arrStr[i]+"')";
									}
								}
							}
							if(sourceType === 'SQLite')
								res.push("COALESCE(" + f.fld + ",'XZY')" + "NOT IN (" + GridWidget.prototype.getArrayFilter(arrStr)+")");
							else
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY')" + "NOT IN (" + GridWidget.prototype.getArrayFilter(arrStr)+")");
						} else {
							if(sourceType === 'SQLite'){
								if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
									res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
								else
									res.push("UPPER(" + f.fld + ") NOT LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "')");
							}
							else{
								if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
									res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
								else
									res.push("UPPER(" + f.fld + ") NOT LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "')");
							}

						}
						break;
					case 'like%A':
						if(sourceType === 'SQLite'){
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(" + f.fld + ",'XZY') IN ('XZY')");
							else
								res.push(f.fld + " LIKE '%" + GridWidget.prototype.validate(f.val) + "'");
						}
						else{
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
							else
								res.push("UPPER(" + f.fld + ") LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "')");
						}

						break;
					case 'likeA%':
						if(sourceType === 'SQLite'){
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(" + f.fld + ",'XZY') IN ('XZY')");
							else
								res.push(f.fld + " LIKE '" + GridWidget.prototype.validate(f.val) + "%'");
							break;
						}
						else{
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
							else
								res.push("UPPER(" + f.fld + ") LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "%')");
							break;
						}
					case 'like%A%':
						if(sourceType === 'SQLite'){
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(" + f.fld + ",'XZY') IN ('XZY')");
							else
								res.push(f.fld + " LIKE '%" + GridWidget.prototype.validate(f.val) + "%'");
							break;
						}
						else{
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
							else
								res.push("UPPER(" + f.fld + ") LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "%')");
							break;
						}

					case 'notLike%A%':
						if(sourceType === 'SQLite'){
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(" + f.fld + ",'XZY') IN ('XZY')");
							else
								res.push(f.fld + " NOT LIKE '%" + GridWidget.prototype.validate(f.val) + "%'");
						}
						else{
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
							else
								res.push("UPPER(" + f.fld + ") NOT LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "%')");
						}
						break;
					default: // только числа
						//тут меняем первую запятую и меняем на точку. Если получится число, то отправляем запрос
						n = GridWidget.prototype.getNumber(f.val.toString().replace(',','.'));
						if (!isNaN(n))
							res.push(f.fld + " " + GridWidget.prototype.validate(f.op) + " " + n.toString());
						break;
				}
			}
		}
		if (res.length > 0) {
			if(parentRoughFilter)
				res.push(parentRoughFilter);
			_strFilter = res.join(" AND ");
		}

	}
	else{
		if(parentRoughFilter)
			_strFilter = parentRoughFilter;
	}
	if (_strFilter == "")
		_strFilter = GridWidget.DEFAULT_FILTER;
	_strFilter =  _strFilter.replace(/&amp;#60;/g, '&amp;lt;');
	return _strFilter;//Фиксим баг #1016 - Если задать условие "<" , то ничего не найдется.
};


// Запрос получения данных геометрии по выбранными ID грида
GridUtil.makeLoadGeoDataReqParams = function (dataRequest, filterStr) {
	var userId = Auth.getUserId();
	var userLogin = Auth.getUserName();

	return {
		getSchema: false,
		descrId: dataRequest,
		toElements: false,
		descrType: 'select',
		data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' +
			'<data FILTER="' + filterStr + '" FILTER_SQLITE="' + filterStr + '" />' +
			'</root>'
	};
};

/**
 * Функция показа формы выбора диаметров, возвращает строку с выбранными диаметрами через запятую
 * @TODO В дальнейшем избавиться от хардкода и возвращать массив, чтобы родительские функции самостоятельно выбирали, что делать с диаметром
 * @param callback
 */
GridUtil.showDiametersDialog = function(callback) {
	var that = this;
	var diags = [1400, 1200, 1000, 700, 500, 400, 300, 200, 150, 100, 80, 50];
	var divv = '<div id="diametersDialog">' +
		'<div id="diametersCheckboxesDiv" style="margin-top:2px; color: #ffffff;" >';

	diags.forEach(function(diag, i){
		divv += '<div style="width: 100%">   ' +
				'   <input id="diameterCheckBox_"' + i + ' type="checkbox" class="diameter__checkbox" value="' + diag + '">' +
				'   <label style="color: #ffffff;" for="diameterCheckBox_' + i + '">' + diag + '</label>' +
				'</div>';
	});
	divv +=	'</div>';
	$('body').append(divv);
	var dlg = $('#diametersDialog');
	var bts = [
		{
			text: gis_core_7,
			click: function(){
				var diams = [];
				$('.diameter__checkbox').each(function(){
					var checkbox = $(this);
					if(checkbox.prop('checked'))
						diams.push(Number(checkbox.val()));
				})
				if(diams.length === 0) diams.push('NULL');
				if(callback)callback(diams.join(','));
				$('#diametersDialog').remove();
			}
		},
		{
			text: gis_core_6,
			click: function(){
				$('#diametersDialog').remove();
			}
		}];
	dlg.dialog({
		modal: true,
		title: gis_gridwidget_145,
		dialogClass: 'ui-dialog-confirm noCloseButton',
		closeOnEscape: true,
		width: 200,
		height: 300,
		resizable: false,
		buttons : bts
	});
};

GridUtil.showLpusDialog = function(callback) {
	var that = this;
	var lpus = ['ЛПУ МГ Абдулинское', 'ЛПУ МГ Альметьевское', 'ЛПУ МГ Константиновское', 'ЛПУ МГ Шеморданское'];
	var divv = '<div id="lpusDialog">' +
		'<div id="lpusCheckboxesDiv" style="margin-top:2px; color: #ffffff;" >';

	lpus.forEach(function(lpu, i){
		divv += '<div style="width: 100%">   ' +
			'   <input id="lpuCheckBox_"' + i + ' type="checkbox" class="lpu__checkbox" value="' + lpu + '">' +
			'   <label style="color: #ffffff;" for="lpuCheckBox_' + i + '">' + lpu + '</label>' +
			'</div>';
	});
	divv +=	'</div>';
	$('body').append(divv);
	var dlg = $('#lpusDialog');
	var bts = [
		{
			text: gis_core_7,
			click: function(){
				var lpus = [];
				$('.lpu__checkbox').each(function(){
					var checkbox = $(this);
					if(checkbox.prop('checked'))
						lpus.push("'" + checkbox.val() + "'");
				})
				if(lpus.length === 0) lpus.push('NULL');
				if(callback)callback(lpus.join(','));
				$('#lpusDialog').remove();
			}
		},
		{
			text: gis_core_6,
			click: function(){
				$('#lpusDialog').remove();
			}
		}];
	dlg.dialog({
		modal: true,
		title: gis_gridwidget_146,
		dialogClass: 'ui-dialog-confirm noCloseButton',
		closeOnEscape: true,
		width: 200,
		height: 150,
		resizable: false,
		buttons : bts
	});
};

/**
 * центровка на карте из грида. Аналог функции применения фильтра нижнего уровня
 */
GridUtil.centerOnMap = function(layerName, parentRoughFilter, dataRequest){
	var windowId = "";
	var funcName = "filterData";
	var params = [{name: "highlight", value: true}, {name: "zoom", value: true},
		{name: "requestId", value: dataRequest},
		{name: "layer", value: layerName},
		{name:'showError', value:false},
		//{name:'filterXML', value:GridWidget.prototype.makeFilterXMLForCentering(curFilter, gridSortStr, topFilter, roughFilter, parentRoughFilter)}];
		{name:'filterXML', value:GridWidget.prototype.makeFilterXMLForCentering(undefined, undefined, undefined, undefined, parentRoughFilter)}];
	//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
	ExternalInteraction.callFunction(windowId, funcName, params);
}


GridUtil.showDashboardsDialog = function(callback) {
	var that = this;
	var dashboards = [
		'КОЛИЧЕСТВО КРАНОВ К ЗАМЕНЕ',
		'КОЛИЧЕСТВО КУ И КРАНОВ',
		'Контроль выявления неисправностей при выполнения ТО и ТР',
		'Контроль за наличием  ТПА с утечками газа во внешнюю среду и негерметичностью по затвору',
		'Контроль своевременности выполнения ТО и ТР',
		'Контроль сроков выполнения программы РСО',
		'Контроль сроков ЭПБ ТПА',
		'СТАТИСТИЧЕСКИЕ ВЫБОРКИ ПО КРАНАМ',
	];
	$('#dashbordsDialog').remove();
	var divv = '<div id="dashbordsDialog">' +
		'<div id="dashboardDiv" style="margin-top:2px; color: #ffffff;" >';

	dashboards.forEach(function(dashboard, i){
		divv += '<div style="width: 100%">   ' +
			'   <button style="width: 100%; height: 30px;" data-buttonnumber="'+ i + '" id="dashboardButton_' + i + '"  class="map-dialog-button dashboard-button " >'+dashboard+'</button>' +
			'</div>';
	});
	divv +=	'</div>';
	$('body').append(divv);
	var dlg = $('#dashbordsDialog');
	dlg.dialog({
		modal: false,
		title: 'Выбор дашборда',
		dialogClass: 'ui-dialog-confirm',
		closeOnEscape: true,
		width: 400,
		height: 280,
		resizable: false,
		buttons : []
	});

	dashboards.forEach(function(dashboard, i){
		$('#dashboardButton_'+i).click(function(){
			callback($(this).data('buttonnumber'), $(this).html());
		})
	});
};


/**
 * Функция форматирования фильтра грида в формат, подходящий для фильтров поискавого движка
 * @param gridColumns фильтры грида
 * @returns {*[]}
 */
GridUtil.formatFilters2SearchFrom = function(gridColumns, filtersLoadedCallback){
	var jsonFilters = [];
	var enumExample = {
		disabled: false,
		id: "top_filter_id",
		name: "Фильтр верхнего уровня",
		source: "search_engine_filter.json",
		type: "enum",
		data: [] //если есть данные, то сразу показываем
	}
	var boolExample = {
		fieldName: "CATEGORY_ID",
		id: "categories",
		name: "Категории",
		type: "boolean",
	}
	var dateExample = {
		beginDateField: "BEGIN_DATE",
		endDateField: "END_DATE",
		id: "search_date_filter",
		name: "Фильтрация по дате",
		type: "date",
	}
	//скалярные фильтры перетягиваются из фильтра нижнего уровня
	if (gridColumns && gridColumns.length > 0) {
		gridColumns.forEach(function(col){
			//прячем из фильтра скрытые поля
			if(col.hidden) return;
			//Добавляем к фильтрации только если в колонке есть параметр типа фильтрации
			//Если curCol.filtercomparisiontype==='array', то это динамический комбобокс
			if (col.filtercomparisiontype === 'array') {
				var enumItem = {
					id: col.datafield,
					name: col.text,
					source: col.filterrequestid,// "search_engine_filter.json",
					type: "enum",
					data: [],
				}
				jsonFilters.push(enumItem);
			}
		});
	}
	if(filtersLoadedCallback)
		filtersLoadedCallback(jsonFilters);
	return jsonFilters
}

/**
 * Переформатирование формата выдачи из фильтра поискового движка в формат фильтра грида
 * @param {Object} filters
 */
GridUtil.reformatFilters = function(filters){
	var gridFilters = [];
	if(filters){
		//объект
		for(var f in filters){
			var filter = {
				fld: '',
				op: 'in',
				val: [],
			}
			if(filters[f].length > 0){
				filters[f].forEach(function(item){
					if(item.paramName === 'TYPE')
						filter.fld = 'TYPE_RANGE';
					else
						filter.fld = item.paramName;
					filter.val.push({CODE: '' + item.code});
				})
			}
			if(filter.val.length > 0){
				gridFilters.push(filter);
			}
		}
	}
	return gridFilters;
}

GridUtil.showOnMap = function(taskName, params){
	if(WidgetMap && WidgetMap.config && WidgetMap.config.map && WidgetMap.config.map.duplicate){
		GridUtil.checkOpenTaskCount('map', function(){
			var guid = App.generateUUID();
			openMapWithinIframe(taskName, params, guid);
		});
		return;
	}

	var mapWidgetDialog = $('#mapWidgetInlineFrameDialog');
	if(mapWidgetDialog.length){
		try{
			switch ( $('#mapWidgetInlineFrame').parent().dialogExtend("state") ) {
				case 'minimized':
					$('#mapWidgetInlineFrame').parent().dialogExtend('restore');
					break;
			}
		}
		catch(ex){}
		try{
			$('#mapWidgetInlineFrame')[0].contentWindow.WidgetMap.showObjects(params);
		}
		catch(ex){}
	}
	else{
		GridUtil.checkOpenTaskCount('map', function(){
			openMapWithinIframe(taskName, params);
		});
	}
}

GridUtil.showOnCas = function(taskName, params){
	GridUtil.checkOpenTaskCount('cas', function(){
		var guid = App.generateUUID();
		openCasWithinIframe(taskName, params, guid);
	});
}
GridUtil.checkOpenTaskCount = function(type, callback){
	function confirm(){
		dlgC.dialog('destroy');
		dlgC.remove();
		if(callback) callback();
	}
	function cancel(){
		dlgC.dialog('destroy');
		dlgC.remove();
	}
	var buttons = [
		{text:gis_core_4,  click:confirm},
		{text:gis_core_5,  click:cancel}
	];
	if(type === 'cas'){
		App.GLOBAL_CAS_OPEN_LIMIT--;
		if(App && App.GLOBAL_CAS_OPEN_LIMIT <= 0){
			var dlgC = App.confirmDialog(gis_head55_1, buttons, {title: gis_core_1, dialogClass: 'ui-dialog-confirm1 noCloseButton ', closeOnEscape: false, html:true});
			return;
		}
	}
	if(type === 'map'){
		App.GLOBAL_MAP_OPEN_LIMIT--;
		if(App && App.GLOBAL_MAP_OPEN_LIMIT <= 0){
			var dlgC = App.confirmDialog(gis_head55_1_1, buttons, {title: gis_core_1, dialogClass: 'ui-dialog-confirm1 noCloseButton', closeOnEscape: false, html:true});
			return;
		}
	}
	if(callback) callback();
}


GridUtil.executeQuery = function(descrId, descrType, ids, callback){
	function reqParams() {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		return {
			descrId: descrId,
			descrType: descrType,
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" '+ topFiltersStr+''+
				'><data ID="' + ids.join() + '"  />' +
				'</root>'
		};
	}
	function result(resultXml) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if (er !== ''){
			App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_65'});
			return;
		}
		if (callback) callback(resultXml);
	}

	function fault(resultXml) {
		BlockingUtil.ready();
		var dataString = $(resultXml).children('string').text();
		var er = HTTPServiceUtil.getError(dataString);
		if (er === '')
			er = dataString;
		App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_7'});
	}
	BlockingUtil.wait();
	App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams(), result, fault);
}

GridUtil.executeExcelQuery = function(descrId, descrType, ids){
	GridUtil.executeQuery(descrId, descrType, ids, function(resultXml){
		var datas = App.convertDataXmlToArray(resultXml, true);
		var resultExcel = '';
		if(datas && datas.length) {
			var colNames = Object.keys(datas[0]);
			resultExcel += colNames.join('\t') + '\n';
			datas.forEach(function (it) {
				var resultItem = '';
				colNames.forEach(function (colName) {
					var val = it[colName] || '';
					resultItem += val + '\t';
				});
				resultItem += '\n';
				resultExcel += resultItem;
			});
		}
		GridUtil.copyToExcelDialog(resultExcel);
	});
}

//форма выбора гридов, когда нажали кнопку в строке грида
GridUtil.showGridListForm = function(params, position, callback){
	var grids = params.split('|');
	$('#gridChooserDialog').remove();

	var divv = '<div id="gridChooserDialog">' +
		'<div id="gridChooserDiv" class="grid-chooser__div">';
	var needIconCol = grids.filter(function(item){
		return (item && item.icon);
	}).length > 0;
	if(grids.length === 1){
		var selectedGrid = grids[0].split(';').reduce(function(acc, cur, i) {
			acc[cur.split('=')[0]] = cur.substr(cur.indexOf('=') + 1);
			return acc;
		}, {});
		if(callback) callback(selectedGrid);
		return;
	}
	grids.forEach(function(grid, i){
		var gridObj = grid.split(';').reduce(function(acc, cur, i) {
			acc[cur.split('=')[0]] = cur.split('=')[1];
			return acc;
		}, {});
		var iconDiv = (needIconCol)? '   <div class="grid-chooser__icon" style="background-image: url(' + gridObj.icon + ');" />': '';
		divv += '<div style="width: 100%" class="grid-chooser-row">   ' +
			iconDiv +
			'   <div data-grid="'+ grid + '" id="gridChooserButton_' + i + '"  class="grid-chooser__button" >' + gridObj.title + '</div>' +
			'</div>';
	});
	divv +=	'</div>';
	$('body').append(divv);
	var dlg = $('#gridChooserDialog');
	dlg.dialog({
		modal: false,
		title: 'Выберите список',
		dialogClass: 'ui-dialog-confirm grid-chooser__dialog',
		closeOnEscape: true,
		width:'auto',
		height: 'auto',
		minHeight : 20,
		position: position,
		resizable: false,
		buttons : []
	})
	grids.forEach(function(dashboard, i){
		$('#gridChooserButton_'+i).click(function(e){
			e.stopPropagation();
			//e.stopPropagation();
			var selectedGrid = $(this).data('grid').split(';').reduce(function(acc, cur, i) {
				acc[cur.split('=')[0]] = cur.substr(cur.indexOf('=') + 1);
				return acc;
			}, {});
			if(callback) callback(selectedGrid);
			App.destroyDialog(null, dlg);
		})
	});
	$("#gridChooserDialog").parent().find('.ui-dialog-titlebar').hide();

	setTimeout(function(){
		dlg.bind('clickoutside', function(e) {
			App.destroyDialog(null, dlg);
		});
		//добавляем скрытие формы по клику вне окошка
		/*document.addEventListener('click', function(event) {
			var specifiedElement = document.getElementById('gridChooserDialog');
			if(!specifiedElement) return;
			var isClickInside = specifiedElement.contains(event.target);
			if (!isClickInside) {
				App.destroyDialog('gridChooserDialog');
			}
		});*/
	}, 1000)
};

GridUtil.composeFilterStrByData = function(filterTemplate, data){
	var filter = '';
	if(filterTemplate && data){
		filter = filterTemplate;
		Object.keys(data).forEach(function (key) {
			filter = filter.replace('{'+key+'}', data[key]);
		});
	}
	return filter;
}
GridUtil.composeFilterVarByColumns = function(data){
	var filter = '';
	if(data){
		filter = FilterUtil.getFilterStringFromObject(data);
	}
	return filter;
}

GridUtil.checkAvailableShowMap = function(zoneId, request, callback){
	function reqParams() {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		return {
			descrId: request || 'M_1_SEM.xml#WEB50_M_1_ZONE',
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" '+ topFiltersStr+''+
				'><data FILTER="ZONE_ID=' + zoneId + '"  />' +
				'</root>'
		};
	}
	function result(resultXml) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if (er !== ''){
			App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_66'});
			return;
		}
		var datasCount = 0;
		try{
			datasCount = $($.parseXML(resultXml)).find('data').length;
		}
		catch(ex){}
		if (callback) callback(datasCount > 0);
	}

	function fault(resultXml) {
		BlockingUtil.ready();
		var dataString = $(resultXml).children('string').text();
		var er = HTTPServiceUtil.getError(dataString);
		if (er === '')
			er = dataString;
		App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_67'});
	}
	BlockingUtil.wait();
	App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams(), result, fault);
}

/**
 *
 * @param gridId
 * @param hideShowAllButton
 * @param hideParentGridButton
 */
GridUtil.emulateShowAllClick = function(gridId, hideShowAllButton, hideParentGridButton){
	var widgetElementId = gridId.replace("jqxgrid",'');
	var gridWidget = App.GridManager.getByGridId(widgetElementId);
	if(gridWidget) {
		//gridWidget.parentRoughFilter = undefined;
		//gridWidget.parentRoughParams = undefined;
		gridWidget.ignoreLabelColumn = true;
		//gridWidget.staticParentRoughFilter = undefined;
	}
	//прячем кнопку "перейти на уровень вверх"
	if(hideParentGridButton){
		var showParentGridButton = $('*[clickevent="showParentGridEvent"]','#'+gridId);
		if(showParentGridButton && showParentGridButton.length)
			showParentGridButton.hide();
	}
	if(hideShowAllButton){
		var showAllGridButton = $('*[clickevent="showAllDataEvent"]','#'+gridId);
		if(showAllGridButton && showAllGridButton.length)
			showAllGridButton.hide();
	}
	GridWidget.refreshGrid(gridId, undefined, undefined, {
		ignoreAllFilter: true,
	});
}
//Глобальный объект
GroupOperationsUtil = {};

GroupOperationsUtil.PROCESS_FORM_DIV = "processStatusForm";
GroupOperationsUtil.GROUP_OPERATION_ERROR_TEXT = gis_groupoperationutil_1;

//Создаем форму статуса процесса групповой последовательной обработки
/**
 * titleStr:String - Заголовок формы
 * array:Array=null - массив обрабатываемых объектов
 * thisObject:Object=null - Объект, от которого выполняются функции (модуль или форма, от которой запустили эту форму)
 * processFunction:Function=null - Функция обработки текущего элемента массива и ее аргументы
 * endFunction:Function=null - Функция, выполняемая при завершении обработки и ее аргументы
 * cancelFunction:Function=null - Функция, выполняемая при отмене обработки - обычно в ней будет отменяться текущий выполняемый вызов
 * */
GroupOperationsUtil.createProcessStatusForm = function createProcessStatusForm(titleStr/*String*/, array/*Array*/, thisObject/*Object*/,
    processFunction/*Function*/,endFunction/*Function*/,cancelFunction/*Function*/, modal/*Boolean*/) {
        var processStatusForm = new ProcessStatusForm();
    processStatusForm.title = titleStr;
    if (array) {
        processStatusForm.totalCount = array.length;
    }
    processStatusForm.objectsArray = array;
    processStatusForm.thisObject = thisObject;
    processStatusForm.processFunction = processFunction;
    processStatusForm.endFunction = endFunction;
    processStatusForm.cancelFunction = cancelFunction;
    processStatusForm.build(GroupOperationsUtil.PROCESS_FORM_DIV);//Форма выполнения групповых операций всегда одна!
    return processStatusForm;
};

//Показываем форму работы с групповыми ошибками, если она есть
GroupOperationsUtil.showActionOnErrorForm = function showActionOnErrorForm(actionOnErrorForm/*ActionOnErrorForm*/, listenerFunc/*Function*/, fullStr/*String*/) {
    if (actionOnErrorForm && listenerFunc!=null) {
        /*PopUpManager.addPopUp(actionOnErrorForm, (Application.application as DisplayObject), true);
        PopUpManager.centerPopUp(actionOnErrorForm);*/
        actionOnErrorForm.shortMessage = GroupOperationsUtil.GROUP_OPERATION_ERROR_TEXT;
        actionOnErrorForm.fullMessage = fullStr;
        actionOnErrorForm.addEventListener(CloseEvent.CLOSE,listenerFunc);
    }
};
/**
 * Менеджер фильтров для грида. Хранит также справочники для рендеринга в гриде не кодов справочников, а соответствующего им текста
 * */

 function FilterManager(opt_options) {
	this.options = goog.isDef(opt_options) ? opt_options : {};
    this.buffer = {};
    this.count = 0;
    this.filterType = "JS";//undefined;// если выставлен в "JS", то данные будут приходить в виде <data CODE="123" DESCR="aaa" />, иначе <data><CODE>123</CODE><DESCR>aaa</DESCR></data>
    //Константы
    this.CODE_NAME = "CODE";
    this.DESCR_NAME = "DESCR";
	if(WidgetMap !== undefined && WidgetMap.getShowErrorInGridDictationary() == false)//если выставлен флаг, то не показываем сообщения в гриде и текст будет другой
		this.EMPTY_NAME = gis_filtermanager_5;
	else
	    this.EMPTY_NAME = gis_filtermanager_1;

}

//Получение данных в виде массива
FilterManager.prototype.getArrayData = function getArrayData(filterRequestId/*String*/,callback) {
    var that = this;
    if (filterRequestId == "")
        return null;

    if (!that.buffer.hasOwnProperty(filterRequestId))
        that.addToBuffer(filterRequestId);

    var item/*FilterManagerItem*/ = that.buffer[filterRequestId];

    if (!item.isLoaded && !item.isLoading)
        that.getListData(filterRequestId,callback);
    //если элемент в процессе подгрузки, то возвращаем null
    if(item.isLoading)
        return 'loading';
    return item.data;
};

FilterManager.prototype.reloadDictationary = function reloadDictationary(filterRequestId/*String*/,callback) {
    var that = this;
    if (filterRequestId == "")
        return null;
    that.removeFromBuffer(filterRequestId);
    this.getArrayData(filterRequestId, callback);
};

//Добавление объекта "filterRequestId", чтобы позже через менеджера забирать данные
FilterManager.prototype.addToBuffer = function addToBuffer(filterRequestId) {
    var that = this;
    if(!that.buffer.hasOwnProperty(filterRequestId) || !that.buffer[filterRequestId]) {
        /*FilterManagerItem*/
        that.buffer[filterRequestId] = {
            filterRequestId: filterRequestId,
            dataAdapters: [],
            data: [],
            isLoading: false,
            isLoaded: false,
            messageId: ""
        };
    }
};

FilterManager.prototype.removeFromBuffer = function removeFromBuffer(filterRequestId) {
    var that = this;
    if(that.buffer.hasOwnProperty(filterRequestId) || that.buffer[filterRequestId]) {
        /*FilterManagerItem*/
        delete that.buffer[filterRequestId];
    }
};

//Добавление объекта dataAdapter, чтобы после загрузки обновить его коллекцию
FilterManager.prototype.addDataAdapterToBuffer = function addDataAdapterToBuffer(filterRequestId, dataAdapter) {
    var that = this;
    if(that.buffer.hasOwnProperty(filterRequestId)) {
        that.buffer[filterRequestId].dataAdapters.push(dataAdapter);
    }
};

//Формирование запроса для получения справочника
FilterManager.prototype.makeLoadFilterReqParams = function makeLoadFilterReqParams(dataRequest) {
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    return {
        getSchema: false,
        descrId: dataRequest,
        toElements: false,
        descrType: 'select',
        data:'<root USER_ID="'+userId.xmlEscape()+
        '" USER_LOGIN="'+userLogin.xmlEscape()+
        '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
        '<data/>'+
        '</root>'
    };
};

//Обновление данных во всех dataAdapter'ах после загрузки данных для визуального обновления
FilterManager.prototype.refreshDataAdapters = function refreshDataAdapters(item) {
    if (item) {
        for (var i = 0; i < item.dataAdapters.length; i++) {
            /*item.dataAdapters[i]._source.localdata = item.data;*/
            item.dataAdapters[i]._source.localdata = item.data;
            item.dataAdapters[i].dataBind();
        }
    }
};

//Менеджер, раздаёт и формирует данные справочника по id запроса
FilterManager.prototype.getListData = function (filterRequestId/*String*/,callback) {
    try {
        var that = this;
        var item/*FilterManagerItem*/ = that.buffer[filterRequestId];
        if (item.isLoaded) {
            //Обновление для визуального отображения
            that.refreshDataAdapters(item);
        } else {
            if (!item.isLoading) {
                /*SpinnerUtils.showDictSpinner();*/
                that.count++;
                //запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
                var filterRequest = FilterManager.prototype.makeLoadFilterReqParams(filterRequestId);
                //Делаем запрос на получение описания грида, сохраняя id для отмены

                var filterResult = function (xmlData) {
                    var er = HTTPServiceUtil.getError(xmlData);
                    if (er !== ''){
                        that.count--;
                        if (item) {
                            item.messageId = "";
                            item.isLoading = false;
                            item.isLoaded = false;
                        }
                        App.errorReport(gis_gridwidget_1, gis_filtermanager_2 + filterRequestId + gis_filtermanager_3 + xmlData, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_5'});
                        return;
                    }
                    //В замыкание должен попасть элемент item (чтобы знать какой filterRequestId запрашивался)
                    var fr = that.formatResponse(xmlData);
                    that.count--;
                    /*if(count==0)SpinnerUtils.hideDictSpinner();*/
                    if(item && item.data.length == 0) {
                        item.messageId = "";
                        if(fr.length > 0) {
                            /*item.data.push.apply(item.data, fr);*/
                            item.data = fr;
                            item.isLoading = false;
                            item.isLoaded = true;
                            //Это непосредственно установка запрошенных значений в источники, для которых был сделан запрос
                            that.refreshDataAdapters(item);
                            if(callback!=undefined){
                                callback({fr:fr});
                            }
                        }
                        else{
                            if(callback!=undefined)
                                callback({fr:fr});
                        }
                    }
                }
                var filterFault = function (xmlData) {
                    that.count--;
                    /*if(count==0)SpinnerUtils.hideDictSpinner();*/
                    if (item) {
                        item.messageId = "";
                        item.isLoading = false;
                        item.isLoaded = false;
                    }
                    App.errorReport(gis_gridwidget_1, gis_filtermanager_2 + filterRequestId + gis_filtermanager_3 + xmlData, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_1'});
                }

                var messageId = undefined;
                if(filterRequestId.indexOf('IUST_SEM_DICT.xml') !== -1 )
                    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, filterRequest, filterResult, filterFault );
                else
                    App.serverQueryXMLNodeWithTries(Services.processQueryNode, filterRequest, filterResult, filterFault,4);
                item.isLoading = true;
                item.messageId = messageId;
            } else {
                //Ничего не делаем - источник в процессе загрузки
            }
        }
    } catch(err) {
        App.errorReport(gis_gridwidget_1, gis_filtermanager_2 + filterRequestId + gis_filtermanager_3+ err, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_2'});
    }
};

//Преобразовывание полученных данных из делегата в массив объектов
FilterManager.prototype.formatResponse =  function formatResponse(xmlData) {
    var that = this;
    if(xmlData == "") {
        App.errorReport(gis_gridwidget_1, gis_filtermanager_4, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_3'});
        return [];
    }

    var str = HTTPServiceUtil.getError(xmlData);
    if(str!="") {
        App.errorReport(gis_gridwidget_1, str, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_4'});
        return [];
    }

    var resXmlData = HTTPServiceUtil.getXMLData(xmlData);
    var formattedObjects = that.formatObject(resXmlData);


    return formattedObjects;
};

/**
 * Форматируем свойство CODE в Number если в схеме оно xs:decimal
 * @param res
 * @return
 *
 */
FilterManager.prototype.formatObject = function formatObject(res) {
    var that = this;
    if(that.filterType == "JS"){
	    var objects = [];
	    //Для удобства получения значения объекта по его коду создаем свойство массива codehash - это объект вида {CODE:DESCR}
	    var codeHash = {};
	    var fObj /*FilterDictObject*/;
	    var resData = res.find("data");
	    for (i = 0; i < resData.length; i++) {
            var it = $(resData[i]);
            var itCode = it.attr("CODE");
            if (!(itCode && itCode.length>0))
                itCode = that.EMPTY_NAME;
            var itDescr = it.attr("DESCR");
            if (!(itDescr && itDescr.length>0))
	            itDescr = that.EMPTY_NAME;
            fObj = {DESCR: itDescr, CODE: itCode};
		    objects.push(fObj);
            //Для удобства получения значения объекта по его коду добавляем хеш кода в объект codeHash
            codeHash[fObj.CODE] = fObj.DESCR;
	    }
	    //Для удобства получения значения объекта по его коду создаем свойство массива codehash - это объект вида {CODE:DESCR}
	    objects.codehash = codeHash;
	    return objects;
    }
    var schema;
    try {
        schema = res.find("xs\\:schema>xs\\:element>xs\\:complexType>xs\\:choice>xs\\:element>xs\\:complexType>xs\\:attribute:empty");
        if (schema && schema.length==0)
            schema = res.find("xs\\:complextype>xs\\:sequence>xs\\:element:empty");
        //schema = res.schema.element.complexType.choice.element.complexType.attribute;
    } catch(e) {
        schema = res.find("xs\\:complextype>xs\\:sequence>xs\\:element:empty");
        //schema = res.schema.element.complexType.choice.element.complexType.sequence.element;
    }
    var codeType;
    var i;
    for (i = 0; i < schema.length; i++) {
        var item = schema[i].attributes;
        if(item.name.value.toLowerCase() == that.CODE_NAME.toLowerCase()) {
            if(item.hasOwnProperty("type"))
                codeType = item.type.value;
            if(item.hasOwnProperty("simpleType") && item.simpleType.hasOwnProperty("restriction"))
                codeType = item.simpleType.restriction.base;
        }
    }


    var objects = [];
    //Для удобства получения значения объекта по его коду создаем свойство массива codehash - это объект вида {CODE:DESCR}
    var codeHash = {};
    var fObj /*FilterDictObject*/;
    var resData = res.find("data");
    for (i = 0; i < resData.length; i++) {
        try {
            var it = $(resData[i]);
            var itCode = it.find("CODE");
            if (itCode && itCode.length>0) {
                itCode = itCode[0].hasOwnProperty('innerText') ? itCode[0].innerText : itCode[0].innerHTML;
            } else {
                itCode = undefined;
            }
            var itDescr = it.find("DESCR");
            if (itDescr && itDescr.length>0) {
                itDescr = itDescr[0].hasOwnProperty('innerText') ? itDescr[0].innerText : itDescr[0].innerHTML;
            } else {
                itDescr = that.EMPTY_NAME;
            }
            fObj = {DESCR: itDescr, CODE: itCode};
            switch(codeType) {
                case "xs:decimal":
                case "xs:double":
                case "xs:long":
                    fObj.CODE = parseFloat(fObj.CODE);
                    objects.push(fObj);
                    break;
                case "xs:string":
                    objects.push(fObj);
                    break;
                default:
                    objects.push(fObj);
                    break;
            }
            //Для удобства получения значения объекта по его коду добавляем хеш кода в объект codeHash
            codeHash[fObj.CODE] = fObj.DESCR;
        } catch (e) {}
    }
    //Для удобства получения значения объекта по его коду создаем свойство массива codehash - это объект вида {CODE:DESCR}
    objects.codehash = codeHash;
    return objects;
};

/**
 * Получение объекта по коду и запросу
 * @param filterRequestId
 * @param code
 * @returns {string}
 */
FilterManager.prototype.getDataByDataField = function (filterRequestId, code) {
    if(filterRequestId && code){
        var item = this.buffer[filterRequestId];
        if(item && item.data && item.data.length > 0) {
            for (var i = 0; i < item.data.length; i++) {
                var it = item.data[i];
                if(it.CODE === code){
                    return it;
                }
            }
        }
    }
    return undefined;
}


//тут складируются результаты загруженных фильтров
FilterSourceDataManager = {};
function CloseEvent(eventType) {
    // Apply the super constructor to get properly wire
    // core event properties.
    jQuery.Event.call(this, eventType);
    // Store the custom attributes. We can store any custom
    // attribute we want so long as we don't override core
    // jQuery Event properties.
    this._eventType = eventType;

    this.detail = 0; //По-умолчанию событие закрытия с отменой
    this.eventData = null; //По-умолчанию дополнительных данных нет
    this.parent = null; //По-умолчанию дополнительных данных нет

    //Функция отправки самого события
    this.dispatch = function dispatch() {
        $("body").trigger(this);
    };
};

// Extend the core jQuery event object.
CloseEvent.prototype = new $.Event("");

CloseEvent.CLOSE = "CloseEvent.close";
function GridEvent(eventType) {
    // Apply the super constructor to get properly wire
    // core event properties.
    jQuery.Event.call(this, eventType);
    // Store the custom attributes. We can store any custom
    // attribute we want so long as we don't override core
    // jQuery Event properties.
    this._eventType = eventType;

    this.detail = 0; //По-умолчанию событие закрытия с отменой
    this.eventData = null; //По-умолчанию дополнительных данных нет
    this.gridId = null; //По-умолчанию нет id конкретного грида
    this.force = false;
    this.refreshGridCallback = undefined;

    //Функция отправки самого события
    this.dispatch = function dispatch() {
        $("body").trigger(this);
    };
};

// Extend the core jQuery event object.
GridEvent.prototype = new $.Event("");

GridEvent.REFRESH_GRID = "GridEvent.refreshGrid";
GridEvent.FILTER_GRID = "GridEvent.filterGrid";
function OperationEvent(eventType) {
    // Apply the super constructor to get properly wire
    // core event properties.
    $.Event.call(this, eventType);
    // Store the custom attributes. We can store any custom
    // attribute we want so long as we don't override core
    // jQuery Event properties.
    this._eventType = eventType;

    //переменные события
    this.objectId = "";
    this.classId = "";
    //Часть данных для операции - DATA_PART_ALL (все), DATA_PART_SEM (семантика), DATA_PART_GEO (геометрия)
    this.dataPart = OperationEvent.DATA_PART_ALL;
    //объект с данными, с которым выполнялись операции
    this.rowData = undefined;
    //Признак, успешно ли было удаление (по-умолчанию - успешно)
    this.operationSuccess = true;
    //Дополнительные данные (это может быть результат или сообщение об ошибке)
    this.operationData = null;
    //Переменные нужны если команду вызываем для выбора и центровки на объекте
    this.withSelecting = true;
    this.withCentering = false;
    this.withEditing = false;
    this.editingMode = 0;

    //Переменная нужна для определения заполнять и показывать панель свойств если она закрыта или нет
    //Переменная введена специально для центровки из грида
    this.showFormIfClosed = true;

    //Функция отправки самого события
    this.dispatch = function dispatch() {
        $("body").trigger(this);
    };
};

// Extend the core jQuery event object.
OperationEvent.prototype = new $.Event("");

OperationEvent.SELECT_OBJECT_BY_ID = "OperationEvent.selectObjectById";

OperationEvent.INSERT_OBJECT_BY_ID = "OperationEvent.insertObjectById";
OperationEvent.UPDATE_OBJECT_BY_ID = "OperationEvent.updateObjectById";
OperationEvent.DELETE_OBJECT_BY_ID = "OperationEvent.deleteObjectById";
OperationEvent.SAVE_ALL_CHANGES_IN_OBJECTS = "OperationEvent.saveAllChangesInObjects";
OperationEvent.DONT_SAVE_CHANGES_IN_OBJECTS = "OperationEvent.dontSaveChangesInObjects";

//Константы событий завершения операций
OperationEvent.OBJECT_SELECTED_BY_ID = "OperationEvent.objectSelectedById";
OperationEvent.OBJECT_INSERTED_BY_ID = "OperationEvent.objectInsertedById";
OperationEvent.OBJECT_UPDATED_BY_ID = "OperationEvent.objectUpdatedById";
OperationEvent.OBJECT_DELETED_BY_ID = "OperationEvent.objectDeletedById";
OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID = "OperationEvent.objectDeletedByIdFromGrid";
OperationEvent.OBJECT_INSERTED = "OperationEvent.objectInserted";

//Константы, показывающие к какой части данных относится событие
OperationEvent.DATA_PART_SEM = "OperationEvent.semantic";
OperationEvent.DATA_PART_GEO = "OperationEvent.geometry";
OperationEvent.DATA_PART_ALL = "OperationEvent.all";

//Константы событий реверса отчета ВТД
OperationEvent.OBJECT_REVERSED_RESULT_BY_ID = "OperationEvent.objectReversedResultById";
OperationEvent.OBJECT_REVERSED_FAULT_BY_ID = "OperationEvent.objectReversedFaultById";
OperationEvent.OBJECT_REVERSED_BY_ID = "OperationEvent.objectReversedById";
function VideoPlayerEvent(eventType) {
    // Apply the super constructor to get properly wire
    // core event properties.
    jQuery.Event.call(this, eventType);
    // Store the custom attributes. We can store any custom
    // attribute we want so long as we don't override core
    // jQuery Event properties.
    this._eventType = eventType;

    this.detail = 0; //По-умолчанию событие закрытия с отменой
    this.eventData = null; //По-умолчанию дополнительных данных нет

    //Функция отправки самого события
    this.dispatch = function dispatch() {
        $("body").trigger(this);
    };
};

// Extend the core jQuery event object.
VideoPlayerEvent.prototype = new $.Event("");

VideoPlayerEvent.CLOSE = "VideoPlayerEvent.close";
VideoPlayerEvent.PAUSE = "VideoPlayerEvent.pause";
VideoPlayerEvent.PLAY = "VideoPlayerEvent.play";
goog.require('ol');
goog.require('ol.Map');
goog.require('ol.View');


goog.require('ol.interaction');
goog.require('ol.interaction.Interaction');
goog.require('ol.interaction.Draw');
goog.require('ol.interaction.DragPan');
goog.require('ol.interaction.MouseWheelZoom');
goog.require('ol.interaction.DragZoom');
goog.require('ol.interaction.Modify');
goog.require('ol.interaction.Translate');

goog.require('ol.control');
goog.require('ol.control.Control');
goog.require('ol.control.ZoomSlider');
goog.require('ol.control.MousePosition');
goog.require('ol.control.ScaleLine');

goog.require('ol.layer.Tile');
goog.require('ol.layer.Vector');
goog.require('ol.source.OSM');
goog.require('ol.source.TileWMS');
goog.require('ol.source.ImageWMS');
goog.require('ol.source.Vector');
goog.require('ol.source.Cluster');
//goog.require('ol.source.GPX');
goog.require('ol.style.Circle');
goog.require('ol.style.RegularShape');
goog.require('ol.style.Fill');
goog.require('ol.style.Stroke');
goog.require('ol.style.Style');

goog.require('ol.layer.Group');
goog.require('ol.Collection');

goog.require('ol.Kinetic');
goog.require('ol.Overlay');

goog.require('ol.Feature');
goog.require('ol.format.WKT');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('ol.css');
goog.provide('map.style.Rectangle');

goog.require('goog.dom');
goog.require('ol.color');
goog.require('ol.render.canvas');
goog.require('ol.style.Fill');
goog.require('ol.style.Image');
goog.require('ol.style.ImageState');
goog.require('ol.style.Stroke');



/**
 * @classdesc
 * Set circle style for vector features.
 *
 * @constructor
 * @extends {ol.style.Image}
 * @api
 */
map.style.Rectangle = function(opt_options) {

    var options = goog.isDef(opt_options) ? opt_options : {};

    /**
    * @private
    * @type {HTMLCanvasElement}
    */
    this.canvas_ = /** @type {HTMLCanvasElement} */
     (goog.dom.createElement('CANVAS'));

     /**
      * @private
      * @type {HTMLCanvasElement}
      */
     this.hitDetectionCanvas_ = null;

     /**
      * @private
      * @type {ol.style.Fill}
      */
     this.fill_ = goog.isDef(options.fill) ? options.fill : null;

     /**
      * @private
      * @type {Array.<number>}
      */
     this.origin_ = [0, 0];

     /**
      * @private
      * @type {number}
      */
     this.radius_ = options.radius;

     /**
      * @private
      * @type {ol.style.Stroke}
      */
     this.stroke_ = goog.isDef(options.stroke) ? options.stroke : null;

     var size = this.render_();

     /**
      * @private
      * @type {Array.<number>}
      */
     this.anchor_ = [size / 2, size / 2];

     /**
      * @private
      * @type {ol.Size}
      */
     this.size_ = [size, size];

     /**
      * @type {boolean}
      */
     var snapToPixel = goog.isDef(options.snapToPixel) ?
         options.snapToPixel : true;

     goog.base(this, {
          opacity: 1,
          rotateWithView: false,
          rotation: 0,
          scale: 1,
          snapToPixel: snapToPixel
     });

};
goog.inherits(map.style.Rectangle, ol.style.Image);


/**
 * @inheritDoc
 * @api
 */
map.style.Rectangle.prototype.getAnchor = function() {
    return this.anchor_;
};


/**
 * @return {ol.style.Fill} Fill style.
 * @api
 */
map.style.Rectangle.prototype.getFill = function() {
    return this.fill_;
};


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.getHitDetectionImage = function(pixelRatio) {
    return this.hitDetectionCanvas_;
};


/**
 * @inheritDoc
 * @api
 */
map.style.Rectangle.prototype.getImage = function(pixelRatio) {
    return this.canvas_;
};


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.getImageState = function() {
    return ol.style.ImageState.LOADED;
};


/**
 * @inheritDoc
 * @api
 */
map.style.Rectangle.prototype.getOrigin = function() {
    return this.origin_;
};


/**
 * @return {number} Radius.
 * @api
 */
map.style.Rectangle.prototype.getRadius = function() {
    return this.radius_;
};


/**
 * @inheritDoc
 * @api
 */
map.style.Rectangle.prototype.getSize = function() {
    return this.size_;
};


/**
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
map.style.Rectangle.prototype.getStroke = function() {
    return this.stroke_;
};


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.listenImageChange = goog.nullFunction;


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.load = goog.nullFunction;


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.unlistenImageChange = goog.nullFunction;


/**
 * @private
 * @return {number} Size.
 */
map.style.Rectangle.prototype.render_ = function() {
    var canvas = this.canvas_;
    var strokeStyle, strokeWidth;

    if (goog.isNull(this.stroke_)) {
        strokeWidth = 0;
    } else {
        strokeStyle = ol.color.asString(this.stroke_.getColor());
        strokeWidth = this.stroke_.getWidth();
        if (!goog.isDef(strokeWidth)) {
            strokeWidth = ol.render.canvas.defaultLineWidth;
        }
    }

    var size = 2 * (this.radius_ + strokeWidth) + 1;
    // draw the circle on the canvas

    canvas.height = size;
    canvas.width = size;

    // canvas.width and height are rounded to the closest integer
    size = canvas.width;

    var context = /** @type {CanvasRenderingContext2D} */
        (canvas.getContext('2d'));
    //context.rect(size / 2 - strokeWidth -1, size / 2 - strokeWidth-2, this.radius_, this.radius_);
    context.rect(this.radius_ / 2, this.radius_ / 2, this.radius_, this.radius_);

    if (!goog.isNull(this.fill_)) {
        context.fillStyle = ol.color.asString(this.fill_.getColor());
        context.fill();
    }
    if (!goog.isNull(this.stroke_)) {
        context.strokeStyle = strokeStyle;
        context.lineWidth = strokeWidth;
        context.stroke();
    }

    // deal with the hit detection canvas

    if (!goog.isNull(this.fill_)) {
        this.hitDetectionCanvas_ = canvas;
    } else {
        this.hitDetectionCanvas_ = /** @type {HTMLCanvasElement} */
            (goog.dom.createElement('CANVAS'));
        canvas = this.hitDetectionCanvas_;

        canvas.height = size;
        canvas.width = size;

        context = /** @type {CanvasRenderingContext2D} */
            (canvas.getContext('2d'));
        context.arc(size / 2, size / 2, this.radius_, 0, 2 * Math.PI, true);

        context.fillStyle = ol.render.canvas.defaultFillStyle;
        context.fill();
        if (!goog.isNull(this.stroke_)) {
            context.strokeStyle = strokeStyle;
            context.lineWidth = strokeWidth;
            context.stroke();
        }
    }

    return size;
};

goog.provide('map.format.WKT');
goog.provide('map.format.WKT.Parser');




/**
 * @constructor
 * @extends {map.format.TextFeature}
 * @param {olx.format.WKTOptions=} opt_options Options.
 * @api stable
 */
map.format.WKT = function(opt_options) {

 var options = goog.isDef(opt_options) ? opt_options : {};

 this.dimension_ = goog.isDef(options.dimension) ?
     options.dimension : 2;

 goog.base(this);

};
goog.inherits(map.format.WKT, ol.format.WKT);


/**
 * Parse a WKT string.
 * @param {string} wkt WKT string.
 * @return {ol.geom.Geometry|ol.geom.GeometryCollection|undefined}
 *     The geometry created.
 * @private
 */
map.format.WKT.prototype.parse_ = function(wkt) {
 var lexer = new ol.format.WKT.Lexer(wkt);
 var parser = new map.format.WKT.Parser(lexer,this.dimension_);
 return parser.parse();
};


/**
 * Class to parse the tokens from the WKT string.
 * @param {map.format.WKT.Lexer} lexer
 * @constructor
 * @protected
 */
map.format.WKT.Parser = function(lexer, dimension) {

 /**
  * @type {map.format.WKT.Lexer}
  * @private
  */
 this.lexer_ = lexer;

 /**
  * @type {map.format.WKT.Token}
  * @private
  */
 this.token_;

 /**
  * @type {number}
  * @private
  */
 this.dimension_ = goog.isDef(dimension)?dimension:2;
};
goog.inherits(map.format.WKT.Parser, ol.format.WKT.Parser);


goog.provide('map.layer.ExtImageVector');

goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.vec.Mat4');
goog.require('ol.dom');
goog.require('ol.extent');
goog.require('ol.render.canvas.ReplayGroup');
goog.require('ol.renderer.vector');
goog.require('ol.source.ImageCanvas');
goog.require('ol.source.Vector');
goog.require('ol.style.Style');
goog.require('ol.vec.Mat4');



/**
 * @classdesc
 * An image source whose images are canvas elements into which vector features
 * read from a vector source (`ol.source.Vector`) are drawn. An
 * `ol.source.ImageVector` object is to be used as the `source` of an image
 * layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,
 * as opposed to being re-rendered, during animations and interactions. So, like
 * any other image layer, an image layer configured with an
 * `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a
 * vector layer, where vector features are re-drawn during animations and
 * interactions.
 *
 * @constructor
 * @extends {ol.source.ImageCanvas}
 * @param {olx.source.ImageVectorOptions} options Options.
 * @api
 */
map.layer.ExtImageVector = function(options) {
  this.id_ = options.id;
  this.hasGeometryInExtent = false;
  goog.base(this, options);

};
goog.inherits(map.layer.ExtImageVector, ol.source.ImageVector);


/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Size} size Size.
 * @param {ol.proj.Projection} projection Projection;
 * @return {HTMLCanvasElement} Canvas element.
 * @private
 */
map.layer.ExtImageVector.prototype.canvasFunctionInternal_ =
    function(extent, resolution, pixelRatio, size, projection) {


  var replayGroup = new ol.render.canvas.ReplayGroup(
      ol.renderer.vector.getTolerance(resolution, pixelRatio), extent,
      resolution);

  //this.source_.loadFeatures(extent, resolution, projection);
  var loading = false;
  if(this.id_!==undefined){
      WidgetMap.regenerateMatrix(this.id_);
      this.hasGeometryInExtent = false;
  }
  _GEO_EXTENTS = {};
  _TEXT_EXTENTS = {};
  this.source_.forEachFeatureInExtent(extent,
      /**
       * @param {ol.Feature} feature Feature.
       */
      function(feature) {

        loading = loading ||
            this.renderFeature_(feature, resolution, pixelRatio, replayGroup);
      }, this);

  replayGroup.finish();

  if (loading) {
    return null;
  }
        //size[0] = 1017;
        //size[1] = 706;
  size[0] = parseInt(size[0]);
  size[1] = parseInt(size[1]);
  //console.log(this.id_+' width='+this.canvasSize_[0]+' height='+this.canvasSize_[1]);
  if (Math.abs(this.canvasSize_[0] - size[0])>=5 || Math.abs(this.canvasSize_[1] - size[1])>=5) {
    this.canvasContext_.canvas.width = size[0];
    this.canvasContext_.canvas.height = size[1];
    this.canvasSize_[0] = size[0];
    this.canvasSize_[1] = size[1];
  } else {
    //если this.hasGeometryInExtent == false - не отрисовало объекты
    this.canvasContext_.clearRect(0, 0, size[0], size[1]);
  }
  //this.canvasContext_.clearRect(0, 0, size[0], size[1]);
  //console.log(this.id_+'width='+size[0]+' height='+size[1]);
  var transform = this.getTransform_(ol.extent.getCenter(extent),
      resolution, pixelRatio, size);
  replayGroup.replay(this.canvasContext_, pixelRatio, transform, 0, {});
  this.replayGroup_ = replayGroup;

  if(!this.hasGeometryInExtent)
    return null;
  return this.canvasContext_.canvas;
};



/**
 * @inheritDoc
 */
map.layer.ExtImageVector.prototype.getImage =
    function(extent, resolution, pixelRatio, projection) {
        resolution = this.findNearestResolution(resolution);

        var canvas = this.canvas_;
        if (canvas &&
            this.renderedRevision_ == this.getRevision() &&
            canvas.getResolution() == resolution &&
            canvas.getPixelRatio() == pixelRatio &&
            ol.extent.containsExtent(canvas.getExtent(), extent) && this.hasGeometryInExtent == true) {
            return canvas;
        }

        extent = extent.slice();
        ol.extent.scaleFromCenter(extent, this.ratio_);
        //!!!! тут считается размер канваса
        var width = ol.extent.getWidth(extent) / resolution;
        var height = ol.extent.getHeight(extent) / resolution;
        var size = [width * pixelRatio, height * pixelRatio];
        //console.time('##'+random);
        //console.log('##'+imageLayer.get('id'));
        var canvasElement = this.canvasFunction_(
            extent, resolution, pixelRatio, size, projection);
        //может возникнуть ситуация, когда в новом экстенте не нашлось фич с объектами видимыми
        //и возвращается null, то в канвасе ничего нет и условие ol.extent.containsExtent(canvas.getExtent(), extent) выполняется -> этот слой отрисовывается, как пустой
        if (canvasElement) {
            canvas = new ol.ImageCanvas(extent, resolution, pixelRatio,
                this.getAttributions(), canvasElement);
        }
        this.canvas_ = canvas;
        this.renderedRevision_ = this.getRevision();

        return canvas;
    };
goog.provide('map.layer.RasterLayer');

map.layer.DATA_TYPE = {
    VECTOR: 'vector',
    RASTER: 'raster'
};
/**
 * @classdesc
 * Растровый слой
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @param  opt_options Options.
 * @api
 */
map.layer.RasterLayer = function(opt_options) {
    var options = goog.isDef(opt_options) ? opt_options : {};
    this.layerSchema = goog.isDef(options.layerSchema) ?
        options.layerSchema : '';

    //флаг указывает, можно ли центроваться по объекту при первичной загрузке
    this.canFirstTimeCentering = goog.isDef(options.canFirstTimeCentering) ?
        options.canFirstTimeCentering : true;

    this.sourceName = goog.isDef(options.sourceName) ?
        options.sourceName : '';

    this.sourceDescr = goog.isDef(options.sourceDescr) ?
        options.sourceDescr : '';

    //массив синонимов слоя. Используется в синхронизации между окнами
    this.layerNameSynonym =  goog.isDef(options.layerNameSynonym) ?
        options.layerNameSynonym : [];

    this.name = goog.isDef(options.name) ?
        options.name : '';

    this.mapName = goog.isDef(options.mapName) ?
        options.mapName : '';


    this.cover = goog.isDef(options.cover) ?
        options.cover : 'false';

    this.type = goog.isDef(options.type) ?
        options.type : 'common';

    this.showInfo = goog.isDef(options.showInfo) ?
        options.showInfo : 'true';

    this.order = goog.isDef(options.order) ?
        options.order : NaN;

    this.mapOrder = goog.isDef(options.mapOrder) ?
        options.mapOrder : NaN;

    this.drawTypes = goog.isDef(options.drawTypes) ?
        options.drawTypes : [];

    this.layerTable = goog.isDef(options.layerTable) ?
        options.layerTable : '';

    this.filterExpression = goog.isDef(options.filterExpression) ?
        options.filterExpression : '';

    this.dataType = goog.isDef(options.dataType) ?
        options.dataType : map.layer.DATA_TYPE.VECTOR;

    this.fieldId = goog.isDef(options.fieldId) ?
        options.fieldId : 'GID';

    this.labelField = goog.isDef(options.labelField) ?
        options.labelField : '';

    this.classField = goog.isDef(options.classField) ?
        options.classField : '';

    this.projection = goog.isDef(options.projection) ?
        options.projection : GeoUtil.PROJS.WGS84;

    //по умолчанию - "GEOLOC". Альтернатива - "WKB_GEOMETRY";
    this.fieldGeodata = goog.isDef(options.fieldGeodata) ?
        options.fieldGeodata : 'WKB_GEOMETRY';
    this.fitMap = goog.isDef(options.fitMap) ?
        options.fitMap : false;

};

map.layer.RasterLayer.prototype.toXML = function() {
    this.setFieldGeodataFromTask_();
    var textStyle = WidgetMap.layerManager.getTextStyle(this.name);
    var requestXML;
    var layerType = (this.dataType == map.layer.DATA_TYPE.VECTOR)?'1':'2';
    if (false && goog.isDefAndNotNull(textStyle)){
        if(this.filterExpression !== ''){
            requestXML = '<LAYER ID="'+this.name+'" NAME="'+this.sourceName+'" TABLE_OWNER="'+this.layerSchema+
            '" TABLE_NAME="'+this.layerTable+'" FILTER_EXPRESSION="'+this.filterExpression+
            '" LAYER_TYPE_ID="' + layerType +'" FIELD_ID="'+this.fieldId+'" FIELD_DESCR="'+this.labelField+
            '" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"'+
            ' LABEL_AUTO="'+textStyle.auto+'" LABEL_COLUMN="'+this.labelField+
            //'" LABEL_FONT="'+textStyle.MIStyle+'" LABEL_PARALLEL="'+textStyle.parallel+
            '" LABEL_OVERLAP="'+textStyle.overlap+'" LABEL_DUPLICATE="'+textStyle.duplicate +'" />';
        }
        else{
            requestXML = '<LAYER ID="'+this.name+'" NAME="'+this.sourceName+'" TABLE_OWNER="'+this.layerSchema+'" TABLE_NAME="'+this.layerTable+
            '" LAYER_TYPE_ID="'+ layerType +'" FIELD_ID="'+this.fieldId+'" FIELD_DESCR="'+this.labelField+
            '" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"'+
            ' LABEL_AUTO="'+textStyle.auto+'" LABEL_COLUMN="'+this.labelField+
            //'" LABEL_FONT="'+textStyle.MIStyle+'" LABEL_PARALLEL="'+textStyle.parallel+
            '" LABEL_OVERLAP="'+textStyle.overlap+'" LABEL_DUPLICATE="'+textStyle.duplicate +'" />';
        }
    }
    else{
        if(this.filterExpression !== ''){
            requestXML = '<LAYER ID="'+this.name+'" NAME="'+this.sourceName+'" TABLE_OWNER="'+this.layerSchema+
            '" TABLE_NAME="'+this.layerTable+'" FILTER_EXPRESSION="'+this.filterExpression+
            '" LAYER_TYPE_ID="'+layerType+'" FIELD_ID="'+this.fieldId+'" FIELD_DESCR="'+this.labelField+
            '" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"'+
            ' LABEL_AUTO="0" LABEL_COLUMN="'+this.labelField+'" />';
        }
        else{
            requestXML = '<LAYER ID="'+this.name+'" NAME="'+this.sourceName+'" TABLE_OWNER="'+this.layerSchema+
            '" TABLE_NAME="'+this.layerTable+
            '" LAYER_TYPE_ID="'+layerType+'" FIELD_ID="'+this.fieldId+'" FIELD_DESCR="'+this.labelField+
            '" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"'+
            ' LABEL_AUTO="0" LABEL_COLUMN="'+this.labelField+'" />';
        }
    }
    return requestXML;
};


map.layer.RasterLayer.prototype.setFieldGeodataFromTask_ = function() {
    this.fieldGeodata = 'GEOLOC';
    this.fieldId = "GID";
    if (true || this.fieldGeodata === "GEOLOC"){
        this.fieldId = "MI_PRINX";
    }
    else{
        if (this.fieldGeodata !== "WKB_GEOMETRY")
            this.fieldGeodata = "WKB_GEOMETRY";
    }
};


/**
 * Добавление геометрии в слой
 * @param feature фича с геометрией
 * @param objectId id объекта
 * @param dataObject
 */
map.layer.RasterLayer.prototype.addGeometry = function(feature,objectId,dataObject){

};


/**
 * Обновление геометрии в слое
 * @param baseFeature фича с геометрией
 * @param semId id объекта
 */
map.layer.RasterLayer.prototype.updateGeometry = function(baseFeature,semId){

};

/**
 * Получение иконки для слоя
 */
map.layer.RasterLayer.prototype.getIcon = function () {
    var topology = this.drawTypes[0];
    var styleArr = WidgetMap.layerManager.getStyleObjByNameAndType(this.name,topology);
    if(styleArr !== undefined && styleArr.length != 0){
        var style = styleArr[0];
        if(style !== undefined){
            if(style.pointObj !== undefined){
                if(style.pointObj.form === 'bitmap')
                    return style.pointObj.href;
                else{

                }
            }
            else if(style.polyObj !== undefined){

            }
            else if(style.lineObj !== undefined){
                //color, size
            }
        }
    }
};

map.layer.RasterLayer.prototype.showAllObjects = function (){

}
goog.provide('map.layer.VectorLayer');

var globalPointsLabels_ = {};
var globalPolygonsLabels_ = {};
var globalLinesLabels_ = {};
var globalLinesGEOs_ = {};
var globalPointsGEOs_ = {};
var globalPolygonsGEOs_ = {};
/**
 * @classdesc
 * Векторный слой слой
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @param  opt_options Options.
 * @api
 */
map.layer.VectorLayer = function (opt_options) {
	var options = goog.isDef(opt_options) ? opt_options : {};
	//уникальное имя слоя, чтобы корректно работало клонирование
	this.uniqueLayerName = goog.isDef(options.uniqueLayerName) ?
		options.uniqueLayerName : '';
	this.layerLoadCallback = undefined;
	this.xmlGeoArr = ['PODS_ANODE', 'PODS_CLOSURE', 'PODS_COMPRESSOR_STATION', 'PODS_CP_FOREIGN_LINE_CROSSING',
		'PODS_DISTRIBUTION_PLANT', 'PODS_JUNCTION_BOX', 'PODS_LAUNCHER_RECEIVER',
		'PODS_METER_STATION', 'PODS_RECTIFIER', 'PODS_ROUTE', 'PODS_TEST_LEAD', 'PODS_VALVE', 'PODS_VENT_PIPE', 'PODS_WATERWAY',
		'PODS_RAILROAD', 'PODS_ROAD', 'PODS_STRUCTURE_CP_BLOCK', 'PODS_STRUCTURE_CP_TRANS', 'PODS_SHEET_NOTE_LINK', 'PODS_FOREIGN_LINE_CROSSING_LINK',
		'PODS_SHEET_NOTE_FUND', 'PODS_MARKER', 'PODS_MARKER_POINT',
		'PODS_MARKER_KM', 'PODS_STRUCTURE', 'PODS_FOREIGN_LINE_CROSSING', 'PODS_METER', 'PODS_ROAD_ENTITY', 'PODS_WATERWAY_ENTITY'];

	//массив синонимов слоя. Используется в синхронизации между окнами
	this.layerNameSynonym =  goog.isDef(options.layerNameSynonym) ?
		options.layerNameSynonym : [];

	this.layerQueryId = goog.isDef(options.layerQueryId) ?
		options.layerQueryId : '';

	//флаг указывает, можно ли центроваться по объекту при первичной загрузке
	this.canFirstTimeCentering = goog.isDef(options.canFirstTimeCentering) ?
		options.canFirstTimeCentering : true;

	this.layerSchema = goog.isDef(options.layerSchema) ?
		options.layerSchema : '';

	//произошло ли отписывание от события. По какой-то причине не происходит отписывание через
	//goog.events.unliste - не находится событие в 
	//  var index = goog.events.ListenerMap.findListenerIndex_(
	//       listenerArray, listener, opt_useCapture, opt_listenerScope);
	//хотя оно там есть. Принято решение использовать доп. флаг
	this.isUnlistenedMoveEnd = false;

	this.layerTable = goog.isDef(options.layerTable) ?
		options.layerTable : '';

	//размерность геометрии.  ol.geom.GeometryLayout.XY или ol.geom.GeometryLayout.XYZ. По умолчанию не определена.
	//используется для функционала копирования вставки геометрии
	this.layout = undefined;

	this.emptyDataExtent = [Infinity, Infinity, -Infinity, -Infinity];

	//будут использоваться для ограничения видимости в текущем масштабе. Из файлов слоёв
	this.maxResolution = goog.isDef(options.maxResolution) ?
		options.maxResolution : Infinity;
	this.minResolution = goog.isDef(options.minResolution) ?
		options.minResolution : 0;

	this.maxLayerZoom = goog.isDef(options.maxLayerZoom) ?
		options.maxLayerZoom : Infinity;
	this.minLayerZoom = goog.isDef(options.minLayerZoom) ?
		options.minLayerZoom : 0;

	this.useServerCache = goog.isDef(options.useServerCache) ?
		options.useServerCache : false;
	this.sourceName = goog.isDef(options.sourceName) ?
		options.sourceName : '';

	this.sourceDescr = goog.isDef(options.sourceDescr) ?
		options.sourceDescr : '';

	this.name = goog.isDef(options.name) ?
		options.name : '';

	this.mapName = goog.isDef(options.mapName) ?
		options.mapName : '';

	this.spacing = goog.isDef(options.spacing) ?
		options.spacing : '';

	this.cover = goog.isDef(options.cover) ?
		options.cover : 'false';

	this.type = goog.isDef(options.type) ?
		options.type : 'common';

	this.showInfo = goog.isDef(options.showInfo) ?
		options.showInfo : 'true';

	this.order = goog.isDef(options.order) ?
		options.order : NaN;

	this.mapOrder = goog.isDef(options.mapOrder) ?
		options.mapOrder : NaN;

	this.zIndex = goog.isDef(options.zIndex) ?
		options.zIndex : 0;

	this.filter = goog.isDef(options.filter) ?
		options.filter : undefined;
	/**
	 * Вариант, когда в layers файле описаны несколько фильтров
	 * @type {*|undefined}
	 */
	this.filters = goog.isDef(options.filters) ?
		options.filters : undefined;

	this.filterExpression = goog.isDef(options.filterExpression) ?
		options.filterExpression : '';

	this.dataType = goog.isDef(options.dataType) ?
		options.dataType : map.layer.DATA_TYPE.VECTOR;

	this.fieldId = goog.isDef(options.fieldId) ?
		options.fieldId : 'GID';

	//уникальная часть идентификатора. Если она есть, то используем её в качестве идентификатора при получении информации
	this.semanticField = 'SEMANTIC_ID';
	this.hasSemanticField = false;

	//массив уникальных значений геометрии, подписей и прочего для составных объктов техсхемы, чтобы корректтирование данные на карте
	//например, чтобы подписи были только для одного сегмента
	this.semanticUniqData = {};
	this.semanticShiftData = {};//position:0 и счетчик по экстенту

	this.labelField = goog.isDef(options.labelField) ?
		options.labelField : '';

	this.classField = goog.isDef(options.classField) ?
		options.classField : '';

	this.projection = goog.isDef(options.projection) ?
		options.projection : GeoUtil.PROJS.WGS84;//по умолчанию проекция WGS84

	//по умолчанию - "GEOLOC". Альтернатива - "WKB_GEOMETRY";
	this.fieldGeodata = goog.isDef(options.fieldGeodata) ?
		options.fieldGeodata : 'WKB_GEOMETRY';
	this.fitMap = goog.isDef(options.fitMap) ?
		options.fitMap : false;

	//upd 12.02.21 из-за того, что пытались грузить замкнутые линии из gpx в слой треков, который
	this.drawTypes = goog.isDef(options.drawTypes) ?
		options.drawTypes : [];

	this.dataReady_ = false;

	this.iustMemoryCorruptCounter = 5;
	//Linux. Счетчик попыток перезапроса данных, если выдается ошибка proxy badgateway в nodejs
	this.nodeErrorCounter = 30;
	//Linux. Счетчик попыток перезапроса данных, если выдается ошибка apache2
	this.internalServerErrorCounter = 5;
	//перезапрос данных в случае ошибки geoloc в техсхеме
	this.geolocErrorCounter = 5;

	//флаг запрещает загрузку данных, например, в случае со сменой режима на растровый
	this.canLoadData = true;

	//локальный кеш, если убираем видимость
	this.cache_ = undefined;

	this.isDataLoading_ = false;

	this.dataProvider = goog.isDef(options.dataProvider) ?
		options.dataProvider : {};

	this.featureProjLayer = undefined;

	this.points_ = {};

	this.lines_ = {};
	this.polygons_ = {};
	this.pointsData_ = {};
	this.linesData_ = {};
	this.polygonsData_ = {};

	this.hasData = false;//есть ли геометрия в слое

	this.showText = true;

	//нужно ли открывать средний фильтр при старте задачи
	this.needPreOpenRoughFilter = false;
	this.hasSplittedData = false;
	this.allSplittedStubDataLoaded = false;
	this.currentXmlLoadIndex = 0;
};
//Чистка глобального массива _LABELS. Для случая, если при отрисовке фичи, она не попала в отрисовки по масштабу и т.д
map.layer.VectorLayer.prototype.clearLabelsOnMap = function(type, topology){
	if(_LABELS && _LABELS.length){
		topology = topology.toLowerCase();
		var i = _LABELS.length - 1;
		for (i; i >= 0; i--) {
			var labelTopoType  = (''+_LABELS[i].type).toLowerCase();
			if (_LABELS[i].unique.indexOf(type + '_') === 0 && topology === labelTopoType)
				_LABELS.splice(i, 1);
		}
	}
}

map.layer.VectorLayer.prototype.bindDataRequest = function (evt) {
	if (goog.isDef(WidgetMap.map)) {
		goog.events.listen(WidgetMap.map,
			'moveend',
			map.layer.VectorLayer.prototype.onMoveEnd, false, this);
	}
};

map.layer.VectorLayer.prototype.onMoveEnd = function (evt) {
	var that = this;
	if(that.isUnlistenedMoveEnd)
		return;
	if (this.dataReady_ == true) {
		goog.events.unlisten(WidgetMap.map,
			'moveend',
			map.layer.VectorLayer.prototype.onMoveEnd, false, this);
		that.isUnlistenedMoveEnd = true;
		return false;
	}
	if (this.isDataLoading_ == true)
		return;
	if (!goog.isDef(this.filter)) {
		var layerObj = WidgetMap.layerManager.getLayerByName(this.name);
		if (goog.isDef(layerObj)) {
			if (layerObj.visible === 'true' || layerObj.visible == true) {
				WidgetMap.layerManager.enableLayer(layerObj.id);
			}
			else {
				WidgetMap.layerManager.disableLayer(layerObj.id);
			}
		}
	}
	else {
		goog.events.unlisten(WidgetMap.map,
			'moveend',
			map.layer.VectorLayer.prototype.onMoveEnd, false, this);
		that.isUnlistenedMoveEnd = true;
	}

};

map.layer.VectorLayer.prototype.toXML = function () {
	this.setFieldGeodataFromTask_();
	var textStyle = WidgetMap.layerManager.getTextStyle(this.name);
	var requestXML;
	var layerType = (this.dataType == map.layer.DATA_TYPE.VECTOR) ? '1' : '2';
	if (false && goog.isDefAndNotNull(textStyle)) {
		if (this.filterExpression !== '') {
			requestXML = '<LAYER ID="' + this.name + '" NAME="' + this.sourceName + '" TABLE_OWNER="' + this.layerSchema +
				'" TABLE_NAME="' + this.layerTable + '" FILTER_EXPRESSION="' + this.filterExpression +
				'" LAYER_TYPE_ID="' + layerType + '" FIELD_ID="' + this.fieldId + '" FIELD_DESCR="' + this.labelField +
				'" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"' +
				' LABEL_AUTO="' + textStyle.auto + '" LABEL_COLUMN="' + this.labelField +
				//'" LABEL_FONT="'+textStyle.MIStyle+'" LABEL_PARALLEL="'+textStyle.parallel+
				'" LABEL_OVERLAP="' + textStyle.overlap + '" LABEL_DUPLICATE="' + textStyle.duplicate + '" />';
		}
		else {
			requestXML = '<LAYER ID="' + this.name + '" NAME="' + this.sourceName + '" TABLE_OWNER="' + this.layerSchema + '" TABLE_NAME="' + this.layerTable +
				'" LAYER_TYPE_ID="' + layerType + '" FIELD_ID="' + this.fieldId + '" FIELD_DESCR="' + this.labelField +
				'" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"' +
				' LABEL_AUTO="' + textStyle.auto + '" LABEL_COLUMN="' + this.labelField +
				//'" LABEL_FONT="'+textStyle.MIStyle+'" LABEL_PARALLEL="'+textStyle.parallel+
				'" LABEL_OVERLAP="' + textStyle.overlap + '" LABEL_DUPLICATE="' + textStyle.duplicate + '" />';
		}
	}
	else {
		if (this.filterExpression !== '') {
			requestXML = '<LAYER ID="' + this.name + '" NAME="' + this.sourceName + '" TABLE_OWNER="' + this.layerSchema +
				'" TABLE_NAME="' + this.layerTable + '" FILTER_EXPRESSION="' + this.filterExpression +
				'" LAYER_TYPE_ID="' + layerType + '" FIELD_ID="' + this.fieldId + '" FIELD_DESCR="' + this.labelField +
				'" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"' +
				' LABEL_AUTO="0" LABEL_COLUMN="' + this.labelField + '" />';
		}
		else {
			requestXML = '<LAYER ID="' + this.name + '" NAME="' + this.sourceName + '" TABLE_OWNER="' + this.layerSchema +
				'" TABLE_NAME="' + this.layerTable +
				'" LAYER_TYPE_ID="' + layerType + '" FIELD_ID="' + this.fieldId + '" FIELD_DESCR="' + this.labelField +
				'" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"' +
				' LABEL_AUTO="0" LABEL_COLUMN="' + this.labelField + '" />';
		}
	}
	return requestXML;
};


map.layer.VectorLayer.prototype.setFieldGeodataFromTask_ = function () {
	this.fieldGeodata = 'GEOLOC';
	this.fieldId = "GID";
	if (true || this.fieldGeodata === "GEOLOC") {
		this.fieldId = "MI_PRINX";
	}
	else {
		if (this.fieldGeodata !== "WKB_GEOMETRY")
			this.fieldGeodata = "WKB_GEOMETRY";
	}
};
map.layer.VectorLayer.prototype.setVisibleText = function (value) {
	this.showText = value;
};

map.layer.VectorLayer.prototype.setVisible = function (value) {
	//выставляем чекбокс в контроле управления слоями
	if(WidgetMap !== undefined && WidgetMap.baseLayersControl !== undefined){
		WidgetMap.baseLayersControl.updateVisibility(this.name, value);
	}

	if (this.dataReady_ == true) {
		if (this.featureProjLayer.getVisible() == value)
			return;
		this.featureProjLayer.setVisible(value);
		if (!value) {//
			//если скрываем слой, то из массива подписей убираем во временный массив для этого слоя
			_IS_CHANGE_LAYER_VISIBILITY[this.name] = {};
			if (_LABELS.length > 0) {
				var i = _LABELS.length - 1;
				for (; i >= 0; i--) {
					if (_LABELS[i].unique.indexOf(this.name) != -1) {
						if (!goog.isDef(_TEMP_LAYERS_LABELS[this.name])) {
							_TEMP_LAYERS_LABELS[this.name] = [];
						}
						_TEMP_LAYERS_LABELS[this.name].push(_LABELS[i]);
						_LABELS.splice(i, 1);
					}
				}
			}
		}
		else {
			//заносим в массив назад подписи, если просто видимость меняем
			if (_IS_FULL_REDRAW == false) {
				if (goog.isDef(_TEMP_LAYERS_LABELS[this.name])) {
					var arr = _TEMP_LAYERS_LABELS[this.name];
					var i = arr.length - 1;
					for (; i >= 0; i--) {
						if (arr[i].unique.indexOf(this.name) != -1) {
							_pointLabels.push(arr[i]);
						}
					}
				}
			}
		}
	}
	else {//подгрузить если слои изначально не подгрузились
		//чистим сначала слой
		this.clear();
		if (value == true) { //подгрузить только, если слой установили видимым
			if (this.checkStyleZoom() == true) {
				if (!goog.isDef(this.filter)) {
					this.loadData();
				}
				else {
					if (goog.isDef(WidgetMap.currentFilter[this.name]) && WidgetMap.currentFilter[this.name].length > 0) {
						var i = 0;
						for (; i < WidgetMap.currentFilter[this.name].length; i++) {
							var curF = WidgetMap.currentFilter[this.name][i];
							if (curF.value != '')
								this.loadData();
						}
					}
				}
			}
		}
	}
};

/**
 * Проверяем стили на попадание в зум карты
 */
map.layer.VectorLayer.prototype.checkStyleZoom = function () {
	var currZoom = WidgetMap.map.getView().getZoom();
	if (currZoom >= this.minLayerZoom && currZoom <= this.maxLayerZoom)
		return true;
	return false;
};

//Полное обновление данных в слоях карты (получаем заново из базы)
map.layer.VectorLayer.prototype.refreshLayerData = function (ignoreCache) {
	if (this.dataReady_) {
		this.dataReady_ = false;
		this.clear();
		this.loadData(true, ignoreCache);
	}
};

/**
 * Подгружаем данные
 */
map.layer.VectorLayer.prototype.loadData = function (force, ignoreCache) {
	if (this.dataReady_ == false) {
		if (this.isDataLoading_ == true) return;
		this.clear();

		//заполняем переменную с дефолтным экстеном без данныхх
		/*try{
			this.emptyDataExtent = this.featureProjLayer.getSource().getSource().getExtent();
		}
		catch (e) {}*/

		//this.requestJsonStubData_();
		//Временная проверка , если не нашли в массиве, то грузим из сервиса, иначе из файла
		//используем запрос для получения флага USE_SERVER_CACHE. Если true, то используем постраничность, иначе геометрия загружается из бд
		if(this.checkStyleZoom() == true || force == true){
			if(ignoreCache){
				this.requestData_();
				return;
			}
			(this.useServerCache)?this.splitData_():this.requestData_();
		}
	}
};

/**
 * Подгружаем данные
 *
 * @param ids
 * @param centeting флаг, нужна ли перецентровка после загрузки данных
 */
map.layer.VectorLayer.prototype.loadDataByIds = function (ids, centeting) {
	if(!this.useServerCache && (this.checkStyleZoom() === true || this.dataReady_)){
		this.requestData_(ids, centeting);
	}
};


/**
 *
 * @private
 */
map.layer.VectorLayer.prototype.splitData_ = function () {
	var that = this;
	if (!that.canLoadData) return;
	if (that.isDataLoading_ == true) return;
	that.isDataLoading_ = true;
	that.currentXmlLoadIndex = 0;
	var dataActualDate = '';
	if (goog.isDef(App.config) && goog.isDef(App.config.DATA_ACTUAL_DATE))// передаем параметр, который будет указывать, нужно ли перенерерирывать данные
		dataActualDate = App.config.DATA_ACTUAL_DATE;
	function getReqParams(request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var roughFiltersStr = LayerManager.getRoughFiltersString(WidgetMap.currentRoughFilter);
		var filter = '';
		if (goog.isDef(that.name) && goog.isDef(that.filter)) {
			if (roughFiltersStr != '') {
				var ff = that.filter.replace('{FILTER}', roughFiltersStr);
				ff = ff.replace('{FILTER}', roughFiltersStr);
				filter = ' AND ' + ff;
			}
		}
		else{
			topFiltersStr = LayerManager.getTopFiltersStringWithBaseLPU(WidgetMap.currentTopFilter);
		}
		var filterStr = '8=8';
		return {
			descrId: request,
			descrType: 'select',
			topology: that.drawTypes.join(),
			data: '<root USER_ID="' + userId.xmlEscape() +
			'" USER_LOGIN="' + userLogin.xmlEscape() +
			'" PODS_USER="' + userLogin.xmlEscape() +
			'" ' + topFiltersStr + '' +
			'>' +
			'<data USE_SERVER_CACHE="'+that.useServerCache+'" FILE_NAME="' + that.name + '"  DATA_ACTUAL_DATE="' + dataActualDate + '" FILTER="' + filterStr + filter + '" />' +
			'</root>'
		};
	}

	function getLayerGeoResult(resultXml) {
		BlockingUtil.readyGeo();
		that.isDataLoading_ = false;
		try {
			var dataArray = [];
			// Иногда ответ в формате XML, а иногда в виде просто строки
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '')
				that.requestData_();
			else
				that.requestSplittedStubData_();
		}
		catch (ex) {
			that.requestData_();
		}
	}

	//ошибка
	function getLayerGeoFault(resultXml) {
		BlockingUtil.readyGeo();
		that.isDataLoading_ = false;
		that.requestData_();
	}
	BlockingUtil.waitGeo();
	App.serverQueryXML2Node(Services.processQueryNodeGeo, getReqParams(that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault, false);
};


map.layer.VectorLayer.prototype.requestSplittedStubData_ = function () {
	var that = this;
	var dataActualDate = '';
	if (goog.isDef(App.config) && goog.isDef(App.config.DATA_ACTUAL_DATE))// передаем параметр, который будет указывать, нужно ли перенерерирывать данные
		dataActualDate = App.config.DATA_ACTUAL_DATE;
	if (!that.canLoadData || that.isDataLoading_ == true)
		return;
	this.hasSplittedData = true;
	if(this.currentXmlLoadIndex == 0) {//если первый запрос, то считаем данных нет. Следующие части файла не должны этот флаг редактировать, т.к. идет сбой на последнем пустом
		this.hasData = false;
		this.dataReady_ = false;
	}
	if (goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.spatial) && that.dataProvider.spatial != '') {
		this.isDataLoading_ = true;
		BlockingUtil.waitGeo();
		function getLayerGeoReqParams(xmlIndex, request) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			return {
				descrId: request,
				xmlIndex: xmlIndex,
				descrType: 'select',
				data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'><data /></root>'
			};
		}

		function getLayerGeoResult(resultXml) {
			if (!that.canLoadData)//если в момент получения данных уже растровый режим, то не обрабатываем
				return;
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.readyGeo();
					if (er.indexOf('Отсутствует корневой элемент.' != -1) || er.indexOf('Root element is missing')!=-1) {//если файла не существует
						that.isDataLoading_ = false;
						that.allSplittedStubDataLoaded = true;
						that.fitMap_();
						return;
					}
					App.errorReport(gis_vectorlayer_1, er, undefined, {
						filename: gis_filename_1,
						functionname: 'requestStubData__getLayerGeoResult'
					});
					return;
				}

				that.nodeErrorCounter = 30;
				that.points_ = {};
				that.pointsLabels_ = {};
				that.lines_ = {};
				that.polygons_ = {};
				that.pointsData_ = {};
				that.linesData_ = {};
				that.polygonData_ = {};
				var i = 0;
				var result = $.parseXML(resultXml);
				var layerGeoXml;
				var datas = [];
				if(result){
					layerGeoXml = result.firstChild;
					datas = layerGeoXml.getElementsByTagName("data");
				}
				var stride = 2;
				for (i; i < datas.length; i++) {
					//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
					var format = new ol.format.WKT({dimension: stride});
					var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
					var type = datas[i].getAttribute("TYPE");
					var label = datas[i].getAttribute("LABEL");
					var idStr = datas[i].getAttribute("ID");
					if (idStr == '' || idStr === null) {
						idStr = datas[i].getAttribute("id");
					}
					var semanticId = undefined;
					var semanticField = datas[i].getAttribute(that.semanticField);
					if(semanticField){
						that.hasSemanticField = true;
						idStr += '|' + semanticField; //делаем комбинированный id, вариант тех схемы, где ID должно совпадать
					}
					if (!goog.isNull(label)) {
						label = label.replace(/""/gm, '"');
						label = label.replace(/Ж(\d)/gm, 'Ø$1');
					}
					var fGeometry = undefined;
					if (goog.isNull(wktStr))
						continue;
					try {
						fGeometry = format.readGeometry(wktStr);
					}
					catch (ex) {
						//для случая с видеозаписями, приходит 3 координаты
						stride = 3;
						format = new map.format.WKT({dimension: stride});
						fGeometry = format.readGeometry(wktStr);
					}
					if (fGeometry.getType() == 'Point' && that.drawTypes.indexOf('point') != -1) {
						if ((fGeometry.flatCoordinates[0] < 0 || fGeometry.flatCoordinates[1] < 0) && that.projection !== 'EPSG:3395' && that.projection !== 'EPSG:5807')
							continue;
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.points_[that.name + ttype]))
							that.points_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsLabels_[that.name + ttype]))
							globalPointsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsGEOs_[that.name + ttype]))
							globalPointsGEOs_[that.name + ttype] = {};
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
								GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						that.points_[that.name + ttype].push(fGeometry.getFlatCoordinates());
						globalPointsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalPointsGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() == 'LineString' && that.drawTypes.indexOf('line') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.lines_[that.name + ttype]))
							that.lines_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesLabels_[that.name + ttype]))
							globalLinesLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesGEOs_[that.name + ttype]))
							globalLinesGEOs_[that.name + ttype] = {};
						that.lines_[that.name + ttype].push(fGeometry);
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						//считаем extent для геометрии
						//fGeometry.getExtent();
						globalLinesLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalLinesGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() == 'Polygon' && that.drawTypes.indexOf('polygon') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.polygons_[that.name + ttype]))
							that.polygons_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsLabels_[that.name + ttype]))
							globalPolygonsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsGEOs_[that.name + ttype]))
							globalPolygonsGEOs_[that.name + ttype] = {};
						that.polygons_[that.name + ttype].push(fGeometry);
						globalPolygonsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalPolygonsGEOs_[that.name + ttype][idStr] = fGeometry;
					}

				}
				var pArr = [];
				var stName;
				var findedFeature = false;
				for (stName in that.polygons_) {
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newPolygonFeature;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newPolygonFeature = sourceFeatures[fea];
							var polygons = newPolygonFeature.getGeometry().getPolygons();
							polygons = polygons.concat(that.polygons_[stName]);
							var geometry1 = new ol.geom.MultiPolygon(null);
							geometry1.setPolygons(polygons);
							newPolygonFeature.setGeometry(geometry1);
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					//если загрузили первый файл, то создаем фичу или если не нашли фичу с типом
					if (that.currentXmlLoadIndex == 1 || findedFeature != true) {
						var geometry = new ol.geom.MultiPolygon(null);
						geometry.setPolygons(that.polygons_[stName]);
						newPolygonFeature = new ol.Feature(geometry);
						newPolygonFeature.set('layerId', that.name);
						newPolygonFeature.set('spacing', that.spacing);
						newPolygonFeature.set('labelType', stName);
						newPolygonFeature.set('zIndex', that.zIndex);
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('labelsObjAll', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);//текущие, которые обрабатываются
						newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);//все объекты
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.POLYGON;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('type'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							styleName = this.get('layerId');
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(styleName);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							styleName = 'DEFAULT';
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newPolygonFeature);
					}
					delete that.polygons_[stName];
					delete that.polygonData_[stName];
				}
				for (stName in that.lines_) {
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newLineFeature;
					findedFeature = false;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newLineFeature = sourceFeatures[fea];
							var lineStrings = newLineFeature.getGeometry().getLineStrings();
							lineStrings = lineStrings.concat(that.lines_[stName]);
							var geometry1 = new ol.geom.MultiLineString(null);
							geometry1.setLineStrings(lineStrings);
							newLineFeature.setGeometry(geometry1);
							//that.featureProjLayer.changed();
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					//если загрузили первый файл, то создаем фичу или если не нашли фичу с типом
					if (that.currentXmlLoadIndex == 1 || findedFeature != true) {
						var geometry = new ol.geom.MultiLineString(null);
						geometry.setLineStrings(that.lines_[stName]);
						newLineFeature = new ol.Feature(geometry);
						newLineFeature.set('layerId', that.name);
						newLineFeature.set('spacing', that.spacing);
						newLineFeature.set('zIndex', that.zIndex);
						newLineFeature.set('labelType', stName);
						newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
						newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);//все объекты
						newLineFeature.set('type', stName.replace('/', '_'));
						newLineFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.LINE_STRING;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							styleName = this.get('layerId');
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							styleName = 'DEFAULT';
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s && !goog.isNull(s.style))) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newLineFeature);
					}
					delete that.lines_[stName];
					delete that.linesData_[stName];
				}
				for (stName in that.points_) {
					that.hasData = true;
					findedFeature = false;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newPointFeature;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newPointFeature = sourceFeatures[fea];
							var points = newPointFeature.getGeometry().getCoordinates();
							points = points.concat(that.points_[stName]);
							var geometry1 = new ol.geom.MultiPoint(null);
							geometry1.setCoordinates(points, ol.geom.GeometryLayout.XY);
							newPointFeature.setGeometry(geometry1);
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					//если загрузили первый файл, то создаем фичу или если не нашли фичу с типом
					if (that.currentXmlLoadIndex == 1 || findedFeature != true) {
						var geometry = new ol.geom.MultiPoint(null);
						geometry.setCoordinates(that.points_[stName], ol.geom.GeometryLayout.XY);
						newPointFeature = new ol.Feature(geometry);
						newPointFeature.set('layerId', that.name);
						newPointFeature.set('spacing', that.spacing);
						newPointFeature.set('zIndex', that.zIndex);
						newPointFeature.set('labelType', stName);
						newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
						newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
						newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);//все объекты
						newPointFeature.set('labelsObjAll', globalPointsLabels_[stName]);
						newPointFeature.set('type', stName.replace('/', '_'));
						newPointFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.POINT;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);

								}
								return [s.style];
							}
							styleName = this.get('layerId');
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							styleName = 'DEFAULT';
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newPointFeature);
					}
					delete that.pointsLabels_[stName];
					delete that.points_[stName];
					delete that.pointsData_[stName];
				}
				if (pArr.length > 0)
					that.featureProjLayer.getSource().getSource().addFeatures(pArr);
				delete pArr;
				//если удачно добавили часть данных, то запрашиваем новую порцию из другого файла
				that.isDataLoading_ = false;
				BlockingUtil.readyGeo();
				//выставляем флаг, что данные есть
				that.dataReady_ = true;
				if(datas.length == 0){
					that.isDataLoading_ = false;
					that.allSplittedStubDataLoaded = true;
					that.fitMap_();
					return;
				}
				that.requestSplittedStubData_();
			}
			catch (ex) {
				if (goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(false);
				that.isDataLoading_ = false;
				BlockingUtil.readyGeo();
				App.errorReport(gis_vectorlayer_1, ex.message+gis_vectorlayer_6+resultXml, undefined, {
					filename: gis_filename_1,
					functionname: 'requestStubData__getLayerGeoResult_1',
					datatext: gis_vectorlayer_5 + that.name + gis_vectorlayer_6 + resultXml
				});
				goog.events.unlisten(WidgetMap.map,
					'moveend',
					map.layer.VectorLayer.prototype.onMoveEnd, false, this);
				that.isUnlistenedMoveEnd = true;
				that.allSplittedStubDataLoaded = true;
				that.fitMap_();
			}
		}

		function getLayerGeoFault(resultXml) {
			BlockingUtil.readyGeo();
			if (that.nodeErrorCounter > 1)
				if (resultXml.indexOf('Bad Gateway') !== -1 || resultXml.indexOf('(Node.js)') !== -1|| resultXml.indexOf('Proxy Error') !== -1) {
					--that.nodeErrorCounter;
					--that.currentXmlLoadIndex;
					that.dataReady_ = false;
					that.isDataLoading_ = false;
					that.allSplittedStubDataLoaded = false;
					that.requestSplittedStubData_();
					return;
				}
			that.internalServerErrorCounter = 0;
			that.dataReady_ = true;
			if (goog.isDef(that.layerLoadCallback))
				that.layerLoadCallback(false);
			that.isDataLoading_ = false;
			App.errorReport(gis_vectorlayer_1, resultXml, undefined, {
				filename: gis_filename_1,
				functionname: 'getLayerGeoFault'
			});
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;

			that.allSplittedStubDataLoaded = true;
			that.fitMap_();
		}
	}

	App.serverQueryXMLSplit1(Services.processQueryNodeXml, getLayerGeoReqParams(that.currentXmlLoadIndex, that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
	++that.currentXmlLoadIndex;
};

/**
 *
 * @param fitTries  попытки перецентровки, если не перецентровалось
 * @private
 */
map.layer.VectorLayer.prototype.fitMap_ = function (fitTries) {
	var that = this;
	if (that.fitMap == true && that.featureProjLayer.getSource().getSource().getFeatures().length > 0) {
		if (that.canFirstTimeCentering == true || (goog.isDef(that.filter) && that.filter != '')/* || fitTries !== undefined*/) {
			var extent = that.featureProjLayer.getSource().getSource().getExtent();
			/*if(ol.extent.equals(extent, that.emptyDataExtent)){
				if(fitTries === undefined) fitTries = 5;
				if(fitTries > 0){
					that.fitMap_(fitTries - 1);
					return;
				}
			}*/
			WidgetMap.centerOnMap(extent);
			that.featureProjLayer.setVisible(true);
		}
		that.canFirstTimeCentering = true;
	}
	if (goog.isDef(that.layerLoadCallback))
		that.layerLoadCallback(true);
};

/**
 * запрос к данным
 * @params ids массив идентификаторов для тонкой загрузки геометрий только по этим объектам
 */
map.layer.VectorLayer.prototype.requestData_ = function (ids, centering) {
	if (!this.canLoadData)
		return;
	var that = this;
	if (that.isDataLoading_ == true)
		return;
	this.hasData = false;
	if (goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.spatial) && that.dataProvider.spatial != '') {
		this.isDataLoading_ = true;
		BlockingUtil.waitGeo();
		function getLayerGeoReqParams(filter, request) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
			var roughFiltersStr = LayerManager.getRoughFiltersString(WidgetMap.currentRoughFilter);
			var roughFilterObj = convertArrayFilterToObject(WidgetMap.currentRoughFilter);

			var filter = '';
			if (goog.isDef(that.name) && goog.isDef(that.filter)) {
				if (roughFiltersStr !== '') {
					if(that.filters){
						for(var f in that.filters){
							var fi = that.filters[f]; //тут хранится pattern. ключ - название переменной
							if(roughFilterObj && roughFilterObj[f]){
								var ff = fi.replace('{FILTER}', roughFiltersStr);
								ff = ff.replace('{FILTER}', roughFiltersStr);
								filter = ' AND ' + ff;
								break;
							}
						}
					}
					else{
						var ff = that.filter.replace('{FILTER}', roughFiltersStr);
						ff = ff.replace('{FILTER}', roughFiltersStr);
						filter = ' AND ' + ff;
					}

				}
			}
			else{
				topFiltersStr = LayerManager.getTopFiltersStringWithBaseLPU(WidgetMap.currentTopFilter);
			}
			var filterIds = '';
			if(ids && ids.length > 0){
				filterIds = ' and ID in ('+ids.join()+') ';
			}
			var zoneId = getParameterByName('ZONE_ID');
			if(zoneId){
				filterIds += ' and zone_id=' + zoneId;
			}
			var filterStr = '8=8';
			return {
				descrId: request,
				topology: that.drawTypes.join(),
				descrType: 'select',
				data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" ' + topFiltersStr + '' +
				'>' +
				'<data FILTER="' + filterStr + filter + filterIds + '" />' +
				'</root>'
			};
		}

		function getLayerGeoResult(resultXml) {
			if (!that.canLoadData)//если в момент получения данных уже растровый режим, то не обрабатываем
				return;
			that.dataReady_ = true;
			that.isDataLoading_ = false;
			//Пытаемся сохранить данные в кеш
			that.saveResultToCache(resultXml);
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.readyGeo();
					if (that.iustMemoryCorruptCounter > 1)
						if (er.indexOf('memory is corrupt.') != -1 || er.indexOf('память повреждена.') != -1/* || er.indexOf('выгруженному объекту AppDomain.') !=-1*/) {
							--that.iustMemoryCorruptCounter;
							that.dataReady_ = false;
							that.isDataLoading_ = false;
							that.requestData_();
							return;
						}
					if (that.geolocErrorCounter > 1)
						if (er.indexOf('Не найдено поле геоданных GEOLOC') != -1) {
							--that.geolocErrorCounter;
							that.dataReady_ = false;
							that.isDataLoading_ = false;
							that.requestData_();
							return;
						}
					App.errorReport(gis_vectorlayer_1, er, undefined, {
						filename: gis_filename_1,
						functionname: 'requestData__getLayerGeoResult'
					});
					return;
				}
				that.iustMemoryCorruptCounter = 0;
				that.internalServerErrorCounter = 0;
				that.geolocErrorCounter = 0;
				var layerGeoXml = ($.parseXML(resultXml)).firstChild;
				var datas = layerGeoXml.getElementsByTagName("data");
				var stride = 2;

				that.points_ = {};
				that.pointsLabels_ = {};
				that.lines_ = {};
				that.polygons_ = {};
				that.pointsData_ = {};
				that.linesData_ = {};
				that.polygonData_ = {};
				var i = 0;
				for (i; i < datas.length; i++) {
					//for (i; i < 1; i++) {
					//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
					var format = new ol.format.WKT({dimension: stride});
					var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
					//wktStr = "POLYGON(( 48.945863 55.994377,48.946621 55.994351,48.946796 55.994342,48.947085 55.99432,48.947175 55.994313,48.947553 55.994488,48.948151 55.994715,48.948434 55.994761,48.949163 55.99505,48.949182 55.995066,48.949572 55.995193,48.950274 55.995425,48.950969 55.995654,48.951667 55.995881,48.951743 55.995906,48.951575 55.995717,48.951684 55.995519,48.951502 55.995321,48.951008 55.995254,48.949904 55.994526,48.949647 55.994255,48.949657 55.994099,48.949347 55.993966,48.948875 55.993888,48.948103 55.993611,48.948275 55.993389,48.948146 55.993341,48.947653 55.993575,48.947126 55.993738,48.94688 55.993672,48.947127 55.993239,48.946967 55.993136,48.947074 55.993022,48.947429 55.992992,48.947397 55.992721,48.947268 55.992691,48.946914 55.992913,48.946431 55.992938,48.946055 55.993107,48.946676 55.993395,48.946677 55.993624,48.946484 55.993672,48.945508 55.993028,48.945132 55.993071,48.945016 55.99316,48.9445 55.992914,48.944265 55.992992,48.944104 55.992667,48.944329 55.992565,48.944137 55.992348,48.945509 55.992071,48.945585 55.991933,48.945746 55.991873,48.945613 55.991723,48.945265 55.991331,48.944458 55.991728,48.944276 55.991939,48.943633 55.992427,48.94356049 55.9925513640001,48.943289 55.993017,48.943023646 55.993200782,48.943019 55.993204,48.9430356410001 55.9932057390001,48.943114822 55.9932140110001,48.94322 55.993225,48.945736432 55.9943218330001,48.945823481 55.9943597750001,48.945845933 55.994369561,48.9458551770001 55.9943735900001,48.945858711 55.99437513,48.945863 55.994377),(48.946783 55.993919,48.946912 55.99384,48.947009 55.993829,48.947308 55.993991,48.947341 55.994045,48.947255 55.9941,48.947169 55.994136,48.947105 55.994141,48.947019 55.994099,48.946847 55.993985,48.946794 55.993955,48.946783 55.993919))";
					//wktStr = "POLYGON(( 48.945863 55.994377,48.946621 55.994351,48.946796 55.994342,48.947085 55.99432,48.947175 55.994313,48.947553 55.994488,48.948151 55.994715,48.948434 55.994761,48.949163 55.99505,48.949182 55.995066,48.949572 55.995193,48.950274 55.995425,48.950969 55.995654,48.951667 55.995881,48.951743 55.995906,48.951575 55.995717,48.951684 55.995519,48.951502 55.995321,48.951008 55.995254,48.949904 55.994526,48.949647 55.994255,48.949657 55.994099,48.949347 55.993966,48.948875 55.993888,48.948103 55.993611,48.948275 55.993389,48.948146 55.993341,48.947653 55.993575,48.947126 55.993738,48.94688 55.993672,48.947127 55.993239,48.946967 55.993136,48.947074 55.993022,48.947429 55.992992,48.947397 55.992721,48.947268 55.992691,48.946914 55.992913,48.946431 55.992938,48.946055 55.993107,48.946676 55.993395,48.946677 55.993624,48.946484 55.993672,48.945508 55.993028,48.945132 55.993071,48.945016 55.99316,48.9445 55.992914,48.944265 55.992992,48.944104 55.992667,48.944329 55.992565,48.944137 55.992348,48.945509 55.992071,48.945585 55.991933,48.945746 55.991873,48.945613 55.991723,48.945265 55.991331,48.944458 55.991728,48.944276 55.991939,48.943633 55.992427,48.94356049 55.9925513640001,48.943289 55.993017,48.943023646 55.993200782,48.943019 55.993204,48.9430356410001 55.9932057390001,48.943114822 55.9932140110001,48.94322 55.993225,48.945736432 55.9943218330001,48.945823481 55.9943597750001,48.945845933 55.994369561,48.9458551770001 55.9943735900001,48.945858711 55.99437513,48.945863 55.994377),(48.946783 55.993919,48.946912 55.99384,48.947009 55.993829,48.947308 55.993991,48.947341 55.994045,48.947255 55.9941,48.947169 55.994136,48.947105 55.994141,48.947019 55.994099,48.946847 55.993985,48.946794 55.993955,48.946783 55.993919)" +
					//	",(48.9483543108 55.9939982769,48.9482041050 55.9943282981,48.9490624104 55.9944543074,48.9483543108 55.9939982769))";
					var type = datas[i].getAttribute("TYPE");
					var label = datas[i].getAttribute("LABEL");
					var idStr = datas[i].getAttribute("ID");
					if (idStr == '' || idStr === null) {
						idStr = datas[i].getAttribute("id");
					}
					var semanticId = undefined;
					var semanticField = datas[i].getAttribute(that.semanticField);
					if(semanticField){
						that.hasSemanticField = true;
						var complexRes = that.updateComplexSemantic(semanticField, label, wktStr);
						if(complexRes && complexRes.ignoreWkt)
							continue;
						if(complexRes && complexRes.ignoreLabel)
							label = null;
						idStr += '|' + semanticField; //делаем комбинированный id, вариант тех схемы, где ID должно совпадать
					}

					if (!goog.isNull(label)) {
						label = label.replace(/""/gm, '"');
						label = label.replace(/Ж(\d)/gm, 'Ø$1');
					}
					var fGeometry = undefined;
					if (goog.isNull(wktStr))
						continue;
					try {
						fGeometry = format.readGeometry(wktStr);
					}
					catch (ex) {
						//для случая с видеозаписями, приходит 3 координаты
						stride = 3;
						format = new map.format.WKT({dimension: stride});
						fGeometry = format.readGeometry(wktStr);
					}

					if(semanticField){
						var geoExtentStr = fGeometry.getExtent().toString();
						if(!that.semanticShiftData[geoExtentStr])
							that.semanticShiftData[geoExtentStr] = {tempPosition: 0, text: label, position: 0 };
						else{
							//если уже есть(по новой схеме двигаем координаты)
							//TODO если экстент одинаковый, то в общий массив заносим position, чтобы
							// на отрисовке текста от position сдвигать вправо и сбрасывать каждые 3 подписи, чтобы подписи рисовалсь лесенкой
							var position = that.semanticShiftData[geoExtentStr].tempPosition + 1;
							that.semanticShiftData[geoExtentStr].tempPosition++;
							if(fGeometry.getType() === ol.geom.GeometryType.POINT)
								fGeometry.translate(0, -position * 3);
							else
								fGeometry.translate(0, -position * 0.5);
							geoExtentStr = fGeometry.getExtent().toString();
							that.semanticShiftData[geoExtentStr] = {tempPosition: 0, position: position, text: label };
						}
						that.semanticUniqData[semanticField].flatCoordinates = that.semanticUniqData[semanticField].flatCoordinates.concat(fGeometry.flatCoordinates);
					}
					if (fGeometry.getType() === ol.geom.GeometryType.POINT && that.drawTypes.indexOf('point') != -1) {
						if ((fGeometry.flatCoordinates[0] < 0 || fGeometry.flatCoordinates[1] < 0) && that.projection !== 'EPSG:3395' && that.projection !== 'EPSG:5807')
							continue;
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.points_[that.name + ttype]))
							that.points_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsLabels_[that.name + ttype]))
							globalPointsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsGEOs_[that.name + ttype]))
							globalPointsGEOs_[that.name + ttype] = {};
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						that.points_[that.name + ttype].push(fGeometry.getFlatCoordinates());
						globalPointsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalPointsGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() === ol.geom.GeometryType.LINE_STRING && that.drawTypes.indexOf('line') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.lines_[that.name + ttype]))
							that.lines_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesLabels_[that.name + ttype]))
							globalLinesLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesGEOs_[that.name + ttype]))
							globalLinesGEOs_[that.name + ttype] = {};
						that.lines_[that.name + ttype].push(fGeometry);
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalLinesLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalLinesGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() === ol.geom.GeometryType.POLYGON && that.drawTypes.indexOf('polygon') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.polygons_[that.name + ttype]))
							that.polygons_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsLabels_[that.name + ttype]))
							globalPolygonsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsGEOs_[that.name + ttype]))
							globalPolygonsGEOs_[that.name + ttype] = {};
						that.polygons_[that.name + ttype].push(fGeometry);
						globalPolygonsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalPolygonsGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					// if(fGeometry.getType() == 'MultiPolygon' && that.drawTypes.indexOf('polygon') != -1){
					// 	var ttype = (goog.isNull(type))?'':'/'+type;
					// 	if(!goog.isDef(that.polygons_[that.name+ttype]))
					// 		that.polygons_[that.name+ttype] = [];
					// 	if(!goog.isDef(globalPolygonsLabels_[that.name+ttype]))
					// 		globalPolygonsLabels_[that.name+ttype] = [];
					// 	if(!goog.isDef(globalPolygonsGEOs_[that.name+ttype]))
					// 		globalPolygonsGEOs_[that.name+ttype] = {};
					// 	that.polygons_[that.name+ttype].push(fGeometry);
					// 	globalPolygonsLabels_[that.name+ttype].push({label:label,id:idStr,geo:fGeometry});
					// 	if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
					//      GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
					// 	globalPolygonsGEOs_[that.name+ttype][idStr] = fGeometry;
					// }

				}
				//console.log('!! '+ that.name+'   length='+datas.length +' time='+new Date().getTime());
				var pArr = [];
				var stName;
				var findedFeature = false;
				for (stName in that.polygons_) {
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newPolygonFeature;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newPolygonFeature = sourceFeatures[fea];
							var polygons = newPolygonFeature.getGeometry().getPolygons();
							polygons = polygons.concat(that.polygons_[stName]);
							var geometry1 = new ol.geom.MultiPolygon(null);
							geometry1.setPolygons(polygons);
							newPolygonFeature.setGeometry(geometry1);
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					if(!findedFeature){
						var geometry = new ol.geom.MultiPolygon(null);
						geometry.setPolygons(that.polygons_[stName]);
						newPolygonFeature = new ol.Feature(geometry);
						newPolygonFeature.set('layerId', that.name);
						newPolygonFeature.set('spacing', that.spacing);
						newPolygonFeature.set('labelType', stName);
						newPolygonFeature.set('zIndex', that.zIndex);
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('labelsObjAll', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);//текущие, которые обрабатываются
						newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);//все объекты
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.POLYGON;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)) {
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('type'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							styleName = this.get('layerId');
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							styleName = 'DEFAULT';
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)) {
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newPolygonFeature);
					}
					delete that.polygons_[stName];
					delete that.polygonData_[stName];
				}

				for (stName in that.lines_) {
					findedFeature = false;
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newLineFeature;
					findedFeature = false;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newLineFeature = sourceFeatures[fea];
							var lineStrings = newLineFeature.getGeometry().getLineStrings();
							lineStrings = lineStrings.concat(that.lines_[stName]);
							var geometry1 = new ol.geom.MultiLineString(null);
							geometry1.setLineStrings(lineStrings);
							newLineFeature.setGeometry(geometry1);
							//that.featureProjLayer.changed();
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					if(!findedFeature){
						var geometry = new ol.geom.MultiLineString(null);
						geometry.setLineStrings(that.lines_[stName]);
						newLineFeature = new ol.Feature(geometry);
						newLineFeature.set('layerId', that.name);
						newLineFeature.set('spacing', that.spacing);
						newLineFeature.set('zIndex', that.zIndex);
						newLineFeature.set('labelType', stName);
						newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
						newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);//все объекты
						newLineFeature.set('type', stName.replace('/', '_'));
						newLineFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.LINE_STRING;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', topology);
							if (!goog.isNull(s && !goog.isNull(s.style))) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newLineFeature);
					}

					delete that.lines_[stName];
					delete that.linesData_[stName];
				}
				for (stName in that.points_) {
					findedFeature = false;
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newPointFeature;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newPointFeature = sourceFeatures[fea];
							var points = newPointFeature.getGeometry().getCoordinates();
							points = points.concat(that.points_[stName]);
							var geometry1 = new ol.geom.MultiPoint(null);
							geometry1.setCoordinates(points, ol.geom.GeometryLayout.XY);
							newPointFeature.setGeometry(geometry1);
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					if(!findedFeature){
						var geometry = new ol.geom.MultiPoint(null);
						geometry.setCoordinates(that.points_[stName], ol.geom.GeometryLayout.XY);
						newPointFeature = new ol.Feature(geometry);
						newPointFeature.set('layerId', that.name);
						newPointFeature.set('spacing', that.spacing);
						newPointFeature.set('zIndex', that.zIndex);
						newPointFeature.set('labelType', stName);
						newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
						newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
						newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);//все объекты
						newPointFeature.set('labelsObjAll', globalPointsLabels_[stName]);
						newPointFeature.set('type', stName.replace('/', '_'));
						newPointFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.POINT;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);

								}
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newPointFeature);
					}


					delete that.pointsLabels_[stName];
					delete that.points_[stName];
					delete that.pointsData_[stName];
				}
				if (pArr.length > 0)
					that.featureProjLayer.getSource().getSource().addFeatures(pArr);
				delete pArr;
				//that.points_ = null;
				//that.lines_ = null;
				//that.polygons_ = null;
				BlockingUtil.readyGeo();
				//при подгрузке отдельных данных, даем возможность не центроваться по всему слою
				if(centering !== false)
					that.fitMap_();
			}
			catch (ex) {
				if (goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(false);
				BlockingUtil.readyGeo();
				that.dataReady_ = true;
				that.isDataLoading_ = false;
				App.errorReport(gis_vectorlayer_1, ex, undefined, {
					filename: gis_filename_1,
					functionname: 'requestData__getLayerGeoResult_1',
					datatext: gis_vectorlayer_5 + that.name + gis_vectorlayer_6 + resultXml
				});
				goog.events.unlisten(WidgetMap.map,
					'moveend',
					map.layer.VectorLayer.prototype.onMoveEnd, false, this);
				that.isUnlistenedMoveEnd = true;
			}
		}

		function getLayerGeoFault(resultXml) {
			if (that.internalServerErrorCounter > 1)
				if (resultXml.indexOf('Internal Server Error') != -1 || resultXml.indexOf('. error. ') != -1 || resultXml.indexOf('. Error. ') != -1 || resultXml.indexOf('. Error ') != -1) {
					--that.internalServerErrorCounter;
					that.dataReady_ = false;
					that.isDataLoading_ = false;
					that.requestData_();
					return;
				}
			that.internalServerErrorCounter = 0;
			that.dataReady_ = true;
			if (goog.isDef(that.layerLoadCallback))
				that.layerLoadCallback(false);
			BlockingUtil.readyGeo();
			that.isDataLoading_ = false;
			App.errorReport(gis_vectorlayer_1, resultXml, undefined, {
				filename: gis_filename_1,
				functionname: 'requestData__getLayerGeoFault'
			});
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;
		}


		//Получаем данные из кеша
		var layerDataCache = this.getDataFromCache();
		if (goog.isDefAndNotNull(layerDataCache)) {
			getLayerGeoResult(layerDataCache.result);
		}
		else
			App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams('', that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
	}
};

map.layer.VectorLayer.prototype.processObject_ = function (feature, dProp) {
	if (!goog.isDef(feature))
		return;
	var geo = feature.getGeometry();
	var geoType = feature.getGeometry().getType();
	var coords = feature.getGeometry().flatCoordinates;
	if (!goog.isDef(dProp.geo))
		dProp.geo = geo;
	var style = undefined;
	switch (geoType) {
		case 'Point': {
			var lName = this.name + '_' + dProp.TYPE;
			var id = dProp.ID;
			style = WidgetMap.layerManager.getPointStyle(lName);
			this.getArrayProperty(this.points_, lName).push(coords);
			this.addObjectPropertyToData_(this.pointsData_, lName, dProp);

			break;
		}
		case 'LineString': {
			break;
		}
		case 'Polygon': {
			break;
		}
		default: {
			style = WidgetMap.layerManager.getStyleByName(this.name + '_' + dProp.TYPE);
		}
	}
};

/**
 * Установка стиля текстовой подписи для стиля фичи
 * @param style
 * @param textstyle
 */
map.layer.VectorLayer.prototype.setTextStyle = function (style, textstyle) {
	if (!goog.isNull(textstyle)) {
		var textAlign = ['left', 'middle'];
		if (goog.isDef(textstyle.align)) {
			if ((textstyle.align.indexOf('|') != -1))
				textAlign = textstyle.align.split('|');
			else {
				if (textstyle.align === 'bottom' || textstyle.align === 'top' || textstyle.align === 'middle')
					textAlign = ['right', textstyle.align];
				else if (textstyle.align === 'left' || textstyle.align === 'right' || textstyle.align === 'left')
					textAlign = [textstyle.align,'top'];
			}
		}
		var align = textAlign[0];

		var baseline = textAlign[1];
		var size = goog.isDef(textstyle.fontSize) ? textstyle.fontSize + 'px' : '';
		var offsetX = 0;//-10;
		var offsetY = 0;
		//если стиль точечный и размеры иконок есть, то учитываем при сдвигах
		var iconOffsetX = 0;
		var iconOffsetY = 0;
		if (!goog.isArray(style) && !goog.isNull(style.image_)) {
			var imageSize = style.getImage().getSize();
			iconOffsetX = imageSize[0] / 2;
			iconOffsetY = imageSize[1] - 3;
		}
		if (align == 'left') {
			align = 'right';
			offsetX = -iconOffsetX;//-10;
		} else if (align == 'right') {

			align = 'left';
			offsetX = iconOffsetX;//3;
		}
		if (baseline == 'top') {
			baseline = 'bottom';
			offsetY = -iconOffsetY;//-7;
		} else if (baseline == 'bottom') {

			baseline = 'top';
			offsetY = iconOffsetY;//10;
		}
		var weight = (textstyle.bold == '1') ? 'bold ' : 'normal ';//убрал в 8.1 версии библиотеки 'normal', т.к. с ним перестал применяться italic
		var italic = (textstyle.italic == '1') ? 'italic ' : '';
		var fontName = goog.isDef(textstyle.fontFamily) ? textstyle.fontFamily : 'Arial';
		var font = italic + '' + weight + '' + size + ' ' + fontName;//font: 'normal 16px Helvetica',
		var fillColor = '#' + textstyle.color.substr(2, 6);
		//прозрачность
		var alpha = parseInt((parseInt('0x0000' + textstyle.color.substr(0, 2), 16) / 255) * 100) / 100;
		//col = '#'+c.substr(2,6); //parseFloat('0x'+c.substr(2,6));
		var col = 'rgba(' + parseInt(textstyle.color.substr(2, 2), 16) + ', ' + parseInt(textstyle.color.substr(4, 2), 16) + ', ' + parseInt(textstyle.color.substr(6, 2), 16) + ', ' + alpha + ')';
		fillColor = col;

		var texttt = undefined;
		if (textstyle.type == 'polygon')
			texttt = '';//'q2';//features[i].get('label');
		if (goog.isDef(style)) {
			if (goog.isArray(style)) {
				var i = 0;
				for (i; i < style.length; i++) {
					style[i].text_ = new ol.style.Text({
						textAlign: align,
						textBaseline: baseline,
						font: font,
						stroke: new ol.style.Stroke({color: '#fff', width: 2}),
						text: texttt,
						offsetX: offsetX,
						offsetY: offsetY,
						fill: new ol.style.Fill({color: fillColor})
					});
				}
			}
			else {
				style.text_ = new ol.style.Text({
					textAlign: align,
					textBaseline: baseline,
					font: font,
					stroke: new ol.style.Stroke({color: '#fff', width: 2}),
					text: texttt,
					offsetX: offsetX,
					offsetY: offsetY,
					fill: new ol.style.Fill({color: fillColor})
				});
			}
		}
	}
	else {
		style.text_ = null;
	}
};


/* проверяет, есть ли такое свойство у объекта и возвращает его, если нет, то создает свойство типа Array */
map.layer.VectorLayer.prototype.getArrayProperty = function (obj, prop) {
	if (!goog.isDef(obj[prop])) {
		obj[prop] = [];
	}
	return obj[prop];
};

map.layer.VectorLayer.prototype.getObjectProperty = function (obj, prop) {
	if (!goog.isDef(obj[prop])) {
		obj[prop] = {};
	}
	return obj[prop];
};

/* Добавляет геометрию в соответствующий объект по ключу ID, учитывая что может быть несколько объектов с одинаковым ключем */
map.layer.VectorLayer.prototype.addObjectPropertyToData_ = function (topologyData, styleName, dProp) {
	if (!goog.isDef(dProp) || !goog.isDef(dProp.ID) || !goog.isDef(dProp.geo))
		return;
	//Проверяем, есть ли уже сохраненный объект с таким id, и если есть - добавляем геометрию к нему, не меняя остальных свойств (это мультиконтур)
	var existProp = this.getObjectProperty(topologyData, styleName);
	if (!goog.isDef(existProp))
		return;

	if (goog.isDef(existProp[dProp.ID]) && goog.isDef(existProp[dProp.ID].geo)) {
		//Если свойство existProp[dProp.ID].geo еще массив, делаем массивом, добавляя в него старую геометрию
		/*if (!(existProp[dProp.ID].geo is Array))
		 existProp[dProp.ID].geo = [existProp[dProp.ID].geo];
		 //Добавляем текущую геометрию уже в массив
		 (existProp[dProp.ID].geo as Array).push(dProp.geo);*/
	}
	else {
		existProp[dProp.ID] = dProp;
	}
};

map.layer.VectorLayer.prototype.getStyle_ = function (styleName, type) {
	//1. если есть атрибут type, то ищем стиль
	//2. если не нашли стиль, то ищем с пустым type
	//3. если не нашли, то устанавливаем дефолтный
	var that = this;
	var s = function (resolution) {
		/*if(this.getId().indexOf('WEB50_POI_POINT')!=-1)
		 console.log('fd');*/
		//TODO добавить условие, чтобы постоянное не получать из менеджера стили, а хранить их
		//сплитим сначала id
		//примененный уже стиль
		var appliedStyle = this.get('appliedStyle');
		if (false && goog.isDef(appliedStyle)) {
			var z = WidgetMap.map.getView().getZoom();
			if (z >= appliedStyle.zoom.zoomMin && z <= appliedStyle.zoom.zoomMax)
				return appliedStyle;
			return null;
		}
		//var idType = this.getId().split(':');//this.get('type');//
		//var idArr =  idType[0].split('/');
		//var styles = WidgetMap.layerManager.getStyleByName(this.getId());
		//return styles;
		var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByName(this.get('layerId') + "_" + this.get('type')/*this.get('layerId')+"_"+this.get('objectId')*/);
		if (!goog.isNull(s))
			return [s];
		s = WidgetMap.layerManager.getStyleByName(this.get('layerId'));
		if (!goog.isNull(s))
			return [s];
		return null;
	};
	return s;
	//TODO добавить получение дефолтного по типу геометрии
};


/**
 * Функция обновления геометрии объекта из базы по его Id
 */
map.layer.VectorLayer.prototype.refreshObjectGeometryById = function (id) {
	var that = this;

	function getLayerGeoReqParams(id, request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var filter = "ID='" + id + "'";
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
			'" USER_LOGIN="' + userLogin.xmlEscape() +
			'" PODS_USER="' + userLogin.xmlEscape() +
			'" ' + topFiltersStr + '' +
			'>' +
			'<data FILTER=" ' + filter + '" />' +
			'</root>'
		};
	}

	function getLayerGeoResult(resultXml) {
		try {
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			for (var i = 0; i < datas.length; i++) {
				var format = new ol.format.WKT({dimension: 2});
				var wktStr = datas[i].getAttribute("WKT");
				var idStr = datas[i].getAttribute("ID");
				if (idStr == '' || idStr === null) {
					idStr = datas[i].getAttribute("id");
				}
				if (wktStr == '' && idStr == '') {
					BlockingUtil.readyGeo();
					return;
				}
				var stride = 2;
				var fGeometry;
				try {
					fGeometry = format.readGeometry(wktStr);
				}
				catch (ex) {
					//для случая с видеозаписями, приходит 3 координаты
					stride = 3;
					format = new map.format.WKT({dimension: stride});
					fGeometry = format.readGeometry(wktStr);
				}
				if (fGeometry.getType() === 'Point' || fGeometry.getType() === 'LineString' || fGeometry.getType() === 'Polygon')
					GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
			}
			var featureProjLayer = that.featureProjLayer;
			//выбираем все features, в которых возможно хранить наш тип геометрии
			var features = featureProjLayer.getSource().getSource().getFeatures();
			var j;
			for (j in features) {
				var index = -1;
				var labels = features[j].get('labelsObj');
				var aa = 0;
				for (; aa < labels.length; aa++) {
					if (labels[aa].id == id) {
						index = aa;
						break;
					}
				}
				if (fGeometry.getType() == ol.geom.GeometryType.LINE_STRING) {
					//заменяем строку на нужную
					if (index != -1) {
						var lineStrings = features[j].getGeometry().getLineStrings();
						lineStrings[index] = fGeometry;
						features[j].get('pointsObj')[id] = fGeometry;
						features[j].get('pointsObjAll')[id] = fGeometry;
						features[j].getGeometry().setLineStrings(lineStrings);
						break;
					}
				}
			}
			BlockingUtil.readyGeo();
		}
		catch (ex) {
			BlockingUtil.readyGeo();
			App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
				filename: gis_filename_1,
				functionname: 'gis_filename_1_1'
			});
		}
	}

	function getLayerGeoFault(resultXml) {
		BlockingUtil.readyGeo();
		App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
			filename: gis_filename_1,
			functionname: 'gis_filename_1_2'
		});
	}

	App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams(id, that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
};


/**
 * Функция обновления геометрии объекта из базы по идентификаторам
 */
map.layer.VectorLayer.prototype.refreshObjectGeometryByIds = function (ids) {
	var that = this;

	function getLayerGeoReqParams(id, request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var filter = "ID in (" + id + ")";
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" ' + topFiltersStr + '' +
				'>' +
				'<data FILTER=" ' + filter + '" />' +
				'</root>'
		};
	}

	function getLayerGeoResult(resultXml) {
		try {
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			for (var i = 0; i < datas.length; i++) {
				var format = new ol.format.WKT({dimension: 2});
				var wktStr = datas[i].getAttribute("WKT");
				var idStr = datas[i].getAttribute("ID");
				if (idStr == '' || idStr === null) {
					idStr = datas[i].getAttribute("id");
				}
				if (wktStr == '' && idStr == '') {
					BlockingUtil.readyGeo();
					return;
				}
				var stride = 2;
				var fGeometry;
				try {
					fGeometry = format.readGeometry(wktStr);
				}
				catch (ex) {
					//для случая с видеозаписями, приходит 3 координаты
					stride = 3;
					format = new map.format.WKT({dimension: stride});
					fGeometry = format.readGeometry(wktStr);
				}
				if (fGeometry.getType() === 'Point' || fGeometry.getType() === 'LineString' || fGeometry.getType() === 'Polygon')
					GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
			}
			var featureProjLayer = that.featureProjLayer;
			//выбираем все features, в которых возможно хранить наш тип геометрии
			var features = featureProjLayer.getSource().getSource().getFeatures();
			var j;
			for (j in features) {
				var index = -1;
				var labels = features[j].get('labelsObj');
				var aa = 0;
				for (; aa < labels.length; aa++) {
					if (labels[aa].id == id) {
						index = aa;
						break;
					}
				}
				if (fGeometry.getType() == ol.geom.GeometryType.LINE_STRING) {
					//заменяем строку на нужную
					if (index != -1) {
						var lineStrings = features[j].getGeometry().getLineStrings();
						lineStrings[index] = fGeometry;
						features[j].get('pointsObj')[id] = fGeometry;
						features[j].get('pointsObjAll')[id] = fGeometry;
						features[j].getGeometry().setLineStrings(lineStrings);
						break;
					}
				}
			}
			BlockingUtil.readyGeo();
		}
		catch (ex) {
			BlockingUtil.readyGeo();
			App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
				filename: gis_filename_1,
				functionname: 'gis_filename_1_1'
			});
		}
	}

	function getLayerGeoFault(resultXml) {
		BlockingUtil.readyGeo();
		App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
			filename: gis_filename_1,
			functionname: 'gis_filename_1_2'
		});
	}

	App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams(id, that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
};





/**
 * Чистим на карте подписи у фичи
 * @param feature
 */
map.layer.VectorLayer.prototype.clearFeatureLabels_ = function (feature) {
	var labelType = feature.get('labelType');
	//перед обработкой чистим массив с подписями и временный массив
	_TEMP_LAYERS_LABELS[labelType] = [];
	if (_LABELS.length > 0) {
		var i = _LABELS.length - 1;
		for (i; i >= 0; i--) {
			if (_LABELS[i].unique.indexOf(labelType + '_') != -1)
				_LABELS.splice(i, 1);
		}
	}
	if (_pointLabels.length > 0) {
		var i = _pointLabels.length - 1;
		for (i; i >= 0; i--) {
			if (_pointLabels[i].unique.indexOf(labelType + '_') != -1)
				_pointLabels.splice(i, 1);
		}
	}
	GLOBAL_REDRAW[labelType] = true;
	GLOBAL_REDRAW_COUNTER[labelType] = 0;
};

/**
 * Функция удаления геометрии объекта из карты по его Id
 */
map.layer.VectorLayer.prototype.deleteObjectById = function (id) {
	if (!goog.isDef(id) || id == '')
		return false;
	//выбираем все features, в которых возможно хранить наш тип геометрии
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	var index = -1;
	var aa = 0;
	for (j; j < features.length; j++) {
		index = -1;
		var labels = features[j].get('labelsObj');
		var labelsAll = features[j].get('labelsObjAll');
		var pointsAll = features[j].get('pointsObjAll');
		var points = features[j].get('pointsObj');
		aa = 0;
		for (aa; aa < labels.length; aa++) {
			if (labels[aa].id == id) {
				try {
					index = aa;
					labels.splice(index, 1);
					if(labelsAll)
						labelsAll.splice(index, 1);
					if(pointsAll)
						delete pointsAll[id];
					if(points)
						delete points[id];
					GeoUtil.removeObjectFromGeometry(features[j], index);
					//если удалили последний объект в фиче, кто он ребудет рендериться, соответственно, не будет чистится _LABELS
					// поэтому чистим _LABELS
					if (labels.length == 0) {
						this.clearFeatureLabels_(features[j]);
					}
				}
				catch (e) {
					
				}
				return true;
			}
		}
	}
	return false;
};

/**
 * Функция удаления геометрии объекта из карты по массиву идентификаторов
 */
map.layer.VectorLayer.prototype.deleteObjectsByIds = function (ids) {
	var that = this;
	if (!goog.isDef(ids))
		return false;
	if(ids.length === 0){// чистим весь слой
		that.refreshLayerData();
		return true;
	}
	ids.forEach(function(id){
		that.deleteObjectById(id)
	});
	WidgetMap.map.renderSync();
	return true;
};




/**
 * Получить рамку для текущего слоя и переместить карту
 */
map.layer.VectorLayer.prototype.getQueryGeoMBR = function (resultHandler) {
	var that = this;
	function getReqLPUParams(request, lpuIds) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		return {
			descrId: request,
			descrType: 'select',
			data:'<root USER_ID="'+userId.xmlEscape()+
				'" USER_LOGIN="'+userLogin.xmlEscape()+
				'" PODS_USER="'+userLogin.xmlEscape()+
				'" '+ topFiltersStr+''+
				'>'+
				'<data LPU_IDS="'+lpuIds+'"/></root>'
		};
	}
	function faultLPU(resultXml) {
		if (goog.isDef(resultHandler))
			resultHandler.apply(this);
	}
	function resultLPU(resultXml) {
		try { // Иногда ответ в формате XML, а иногда в виде просто строки
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') {
				if (goog.isDef(resultHandler))
					resultHandler.apply(this);
				return;
			}
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			var dd = 0;
			for (dd; dd < datas.length; dd++) {
				var maxLat = parseFloat(datas[dd].getAttribute('YMAX'));
				var minLat = parseFloat(datas[dd].getAttribute('YMIN'));
				var minLon = parseFloat(datas[dd].getAttribute('XMIN'));
				var maxLon = parseFloat(datas[dd].getAttribute('XMAX'));
				var pnt1 = new proj4.toPoint([minLon, minLat]);
				var pnt2 = new proj4.toPoint([maxLon, maxLat]);
				var source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
				var dest_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
				if (App.projection === GeoUtil.PROJS.Pulkovo42) {//преобразуем в wgs84
					var p42WgsPnt = GeoUtil.P42WGS(minLat, minLon);
					pnt1 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
					p42WgsPnt = GeoUtil.P42WGS(maxLat, maxLon);
					pnt2 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
				}
				proj4.transform(source_, dest_, pnt1);
				proj4.transform(source_, dest_, pnt2);
				if(isNaN(pnt1.x) || isNaN(pnt1.y) || isNaN(pnt2.x) || isNaN(pnt2.y))
					continue;
				var extent = [pnt1.x, pnt1.y, pnt2.x, pnt2.y]; // of ol.Extent `[minx, miny, maxx, maxy]`.
				if(extent.length == 0)
					extent= [pnt1.x, pnt1.y, pnt2.x, pnt2.y];
				else
					extent = ol.extent.extend(extent,[pnt1.x, pnt1.y, pnt2.x, pnt2.y]);
			}
			if(WidgetMap.canFirstTimeCentering)
				WidgetMap.centerOnMap(extent);
			if (goog.isDef(resultHandler))
				resultHandler.apply(this);
		} catch (ex) {
			if (goog.isDef(resultHandler))
				resultHandler.apply(this);
		}
	}


	if(goog.isDef(WidgetMap.currentTopFilter) &&  WidgetMap.currentTopFilter.length > 0){
		var k=0;
		for(;k<WidgetMap.currentTopFilter.length;k++){
			if(goog.isDef(WidgetMap.currentTopFilter[k].name) && WidgetMap.currentTopFilter[k].name == 'LPU_ACCESS_FILTER'){
				var lpus = WidgetMap.currentTopFilter[k].value;
				App.serverQueryXMLNodeWithTries(Services.processQueryNode, getReqLPUParams('GAZPROM_ADM_SEM.xml#GET_LPU_BOUNDS', lpus), resultLPU, faultLPU,4);
				return;
			}
		}
	}
};

map.layer.VectorLayer.prototype.clear = function () {
	if (goog.isDefAndNotNull(this.featureProjLayer.getSource)) {
		this.featureProjLayer.getSource().getSource().clear();
		//и удаляем из всех мест сохраненные данные об этом слое
		this.semanticUniqData = {};
		this.semanticShiftData = {};
		//var globalPointsLabels_ = {};
		//var globalPolygonsLabels_ = {};
		//var globalLinesLabels_ = {};
		//var globalLinesGEOs_ = {};
		//var globalPointsGEOs_ = {};
		//var globalPolygonsGEOs_ = {};
		var obj;
		for (obj in globalPointsLabels_) {
			if (obj.indexOf(this.name + '/') != -1) {
				delete globalPointsLabels_[obj];
				delete globalPointsGEOs_[obj];
			}
			else if (obj == this.name) {
				delete globalPointsLabels_[obj];
				delete globalPointsGEOs_[obj];
			}
		}
		for (obj in globalLinesLabels_) {
			if (obj.indexOf(this.name + '/') != -1) {
				delete globalLinesLabels_[obj];
				delete globalLinesGEOs_[obj];
			}
			else if (obj == this.name) {
				delete globalLinesLabels_[obj];
				delete globalLinesGEOs_[obj];
			}
		}
		for (obj in globalPolygonsLabels_) {
			if (obj.indexOf(this.name + '/') != -1) {
				delete globalPolygonsLabels_[obj];
				delete globalPolygonsGEOs_[obj];
			}
			else if (obj == this.name) {
				delete globalPolygonsLabels_[obj];
				delete globalPolygonsGEOs_[obj];
			}
		}
	}
};

/**
 * Обновление подписи в слое
 * @param semId
 * @param dataObject
 */
map.layer.VectorLayer.prototype.updateLabel = function (semId, label) {
	var found = false;//если объект не найден в этом слое
	if (goog.isDef(this.featureProjLayer)) {
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		var i = 0, j = 0;
		for (j; j < features.length; j++) {
			if(found) break;
			var labelsObj = features[j].get('labelsObj');
			for (i = 0; i < labelsObj.length; i++) {
				if (labelsObj[i].id == semId) {
					var geoType = features[j].get('pointsObjAll')[semId].getType();
					var labelType = features[j].get('labelType');
					switch (geoType) {
						case 'Point':
							globalPointsLabels_[labelType][i].label = label;
							break;
						case 'LineString':
							globalLinesLabels_[labelType][i].label = label;
							break;
						case 'Polygon':
							globalPolygonsLabels_[labelType][i].label = label;
							break;
					}
					found = true;
					labelsObj[i].label = label;
					this.featureProjLayer.getSource().changed();
					break;
				}
			}
		}
	}
	return found;
};

map.layer.VectorLayer.prototype.getLayerGeoFields = function(callback){
	var that = this;
	that.layout = ol.geom.GeometryLayout.XY;
	function getLayerGeoReqParams(source) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		return {
			descrId: 'SYS_SEM.xml#GET_DATA_XML',
			descrType: 'select',
			data:  '<root USER_ID="'+userId.xmlEscape()+
				'" USER_LOGIN="'+userLogin.xmlEscape()+
				'" PODS_USER="'+userLogin.xmlEscape()+
				'" >'+
				'<data file="'+source.split("#")[0]+'" dataId="'+source.split("#")[1]+'" />'+
				'</root>'
		};
	}
	function onProvDataResult(resultXml) {
		try {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er === '') {
				var select = resultXml.find("select");
				if(select.length>0 && select[0].getElementsByTagName("geoQuery").length>0){
					var geoField = select[0].getElementsByTagName("geoQuery")[0].getAttribute("geoField");
					if(geoField && geoField.split(',').length > 2)
						that.layout = ol.geom.GeometryLayout.XYZ;
				}
			}
		}
		catch(e){
		}
		if(callback) callback();
	}
	function onProvDataFault() {
		if(callback) callback();
	}
	App.serverQueryNodeWithTries(Services.processQueryNodeXml, getLayerGeoReqParams(this.dataProvider.spatial ), onProvDataResult, onProvDataFault,4);
}

/**
 * Добавление геометрии в слой
 * @param baseFeature фича с геометрией
 * @param semId id объекта
 * @param dataObject
 */
map.layer.VectorLayer.prototype.addGeometry = function (baseFeature, semId, dataObject, callback) {
	var that  = this;
	//проверка на размерность слоя XY или XYZ
	if(this.layout === undefined){
		//запрашиваем из select соответствующего гео файла атрибут geoField, после этого вызываем опять addGeometry с уже установленной геометрией
		this.getLayerGeoFields(function(){
			that.addGeometry(baseFeature, semId, dataObject);
			if(callback) callback();
		})
		return false;
	}

	if (goog.isDef(this.featureProjLayer)) {
		//парсим data, забираем из него label и type_cl из атрибутов
		//сохранить координаты и подпись в фичу для этого слоя
		//Обрабатываем classField слоя, если в объекте есть такое свойство, сохраняем его в тип
		var typeStr = '';
		var label = null;
		if (goog.isDef(dataObject) && goog.isDef(dataObject.savingData)) {
			var tableName = this.name.substring(this.name.indexOf("_") + 1);
			var xmlData = $.parseXML(dataObject.savingData);
			var data = xmlData.getElementsByTagName("data");
			if (data.length >= 0) {
				if (!goog.isNull(data[0].getAttribute(tableName + '_' + this.classField)) && data[0].getAttribute(tableName + '_' + this.classField) != 'NULL')
					typeStr = '/' + data[0].getAttribute(tableName + '_' + this.classField);
				if (!goog.isNull(data[0].getAttribute(this.classField)) && data[0].getAttribute(this.classField) != 'NULL')
					typeStr = '/' + data[0].getAttribute(this.classField);
				if (!goog.isNull(data[0].getAttribute(tableName + '_' + this.labelField)) && data[0].getAttribute(tableName + '_' + this.labelField) != 'NULL')
					label = data[0].getAttribute(tableName + '_' + this.labelField);
				if (!goog.isNull(data[0].getAttribute(this.labelField)) && data[0].getAttribute(this.labelField) != 'NULL')
					label = data[0].getAttribute(this.labelField); //TODO  посмотреть откуда во флеше для линий электропередач берется подпись
				if (!goog.isNull(data[0].getAttribute('LABEL')))
					label = data[0].getAttribute('LABEL');
				if (!goog.isNull(data[0].getAttribute('TYPE')))
					typeStr = data[0].getAttribute('TYPE');
			}
		}
		//если косметический слой, то у него нет типа, поэтому выставляем ему фейковый, чтобы при отрисовке не затирались тексты у линий.
		//сначала рисуются линии, потом точки и затирается _LABELS по типу(тип пустой)
		if(that.uniqueLayerName === 'COSMETIC_OBJECT' && typeStr === ''){
			typeStr = '/'+baseFeature.getGeometry().getType();
		}
		if(dataObject && dataObject.label && !label)//случай отката косметики
			label = dataObject.label;
		var found = false;
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		var fGeometry = baseFeature.getGeometry();


		//проводим конвертацию layout геометрии к layout слоя
		if(fGeometry && fGeometry.layout !== this.layout){
			fGeometry = this.transformGeometryLayout(fGeometry);
		}

		if(this.name === "PODS_ROUTE" && fGeometry.stride === 2){
			var lineString = new ol.geom.LineString(null);
			var flatRouteCoords = [];
			var routeCoords = fGeometry.getCoordinates();
			for(var rk = 0; rk < routeCoords.length; rk ++){
				flatRouteCoords = flatRouteCoords.concat([routeCoords[rk][0], routeCoords[rk][1], 0]);
			}
			lineString.setFlatCoordinates( ol.geom.GeometryLayout.XYZ, flatRouteCoords);
			fGeometry = lineString;
		}
		//если слой косметики, то все размерности приводим к двумерным XY
		if(this.name === 'COSMETIC_OBJECT' && fGeometry.stride === 3){
			//TODO пока делаем для линий
			if(fGeometry.getType() === ol.geom.GeometryType.LINE_STRING){
				var lineString = new ol.geom.LineString(null);
				var flatRouteCoords = [];
				var routeCoords = fGeometry.getCoordinates();
				for(var rk = 0; rk < routeCoords.length; rk ++){
					flatRouteCoords = flatRouteCoords.concat([routeCoords[rk][0], routeCoords[rk][1]]);
				}
				lineString.setFlatCoordinates( ol.geom.GeometryLayout.XY, flatRouteCoords);
				fGeometry = lineString;
			}
		}

		var j = 0, feature;
		for (j; j < features.length; j++) {
			feature = features[j];
			if (feature.get('labelType') === this.name + typeStr) {
				if (feature.getGeometry().getType().indexOf(fGeometry.getType()) != -1) {
					/*var stride = feature.getGeometry().stride;
					var baseFeatureStride = fGeometry.stride;
					if(stride !== baseFeatureStride) {//случай, когда ранее вставляли в косметику трубу XYZ, а после этого рисовали линию XY
						typeStr += '_' + fGeometry.layout;// фиктивно подправляем тип отрисовки для случая косметики, иначе общая ссылка на labelsObj у каждой фичи слоя
						break;
					}*/
					switch (fGeometry.getType()) {
						case ol.geom.GeometryType.LINE_STRING:
							globalLinesLabels_[this.name + typeStr].push({
								label: label,
								id: semId,
								geo: fGeometry
							});
							if (!goog.isDef(feature.get('pointsObj')))
								feature.set('pointsObj', {});
							if (!goog.isDef(feature.get('pointsObjAll')))
								feature.set('pointsObjAll', {});
							feature.get('pointsObj')[semId] = fGeometry;
							feature.get('pointsObjAll')[semId] = fGeometry;
							feature.getGeometry().appendLineString(fGeometry);
							found = true;
							break;
						case ol.geom.GeometryType.POINT:
							globalPointsLabels_[this.name + typeStr].push({
								label: label,
								id: semId,
								geo: fGeometry
							});
							feature.getGeometry().appendPoint(fGeometry);
							if (!goog.isDef(feature.get('pointsObj')))
								feature.set('pointsObj', {});
							if (!goog.isDef(feature.get('pointsObjAll')))
								feature.set('pointsObjAll', {});
							feature.get('pointsObj')[semId] = fGeometry;
							feature.get('pointsObjAll')[semId] = fGeometry;
							found = true;
							break;
						case ol.geom.GeometryType.POLYGON:
							globalPolygonsLabels_[this.name + typeStr].push({
								label: label,
								id: semId,
								geo: fGeometry
							});
							feature.getGeometry().appendPolygon(fGeometry);
							if (!goog.isDef(feature.get('pointsObj')))
								feature.set('pointsObj', {});
							if (!goog.isDef(feature.get('pointsObjAll')))
								feature.set('pointsObjAll', {});
							feature.get('pointsObj')[semId] = fGeometry;
							feature.get('pointsObjAll')[semId] = fGeometry;
							found = true;
							break;
					}
				}
				if (found == true)
					break;
			}
		}
		//если не нашли по layerName+typeStr - ищем по layerName
		if (!found) {
			j = 0;
			for (j; j < features.length; j++) {
				feature = features[j];
				//если не нашли по labelType, то ищем по обычному названию слоя и потом заносим объекты в массивы с labelType у выбранной фичи
				if (feature.get('labelType') == this.name) {
					if (feature.getGeometry().getType().indexOf(fGeometry.getType()) != -1) {
						/*var stride = feature.getGeometry().stride;
						var baseFeatureStride = fGeometry.stride;
						if(stride !== baseFeatureStride) {//случай, когда ранее вставляли в косметику трубу XYZ, а после этого рисовали линию XY
							typeStr += '_' + fGeometry.layout;// фиктивно подправляем тип отрисовки для случая косметики, иначе общая ссылка на labelsObj у каждой фичи слоя
							break;
						}*/
						switch (fGeometry.getType()) {
							case ol.geom.GeometryType.LINE_STRING:
								globalLinesLabels_[feature.get('labelType')].push({label: label, id: semId});
								feature.getGeometry().appendLineString(fGeometry);
								if (!goog.isDef(feature.get('pointsObj')))
									feature.set('pointsObj', {});
								if (!goog.isDef(feature.get('pointsObjAll')))
									feature.set('pointsObjAll', {});
								feature.get('pointsObj')[semId] = fGeometry;
								feature.get('pointsObjAll')[semId] = fGeometry;
								found = true;
								break;
							case ol.geom.GeometryType.POINT:
								globalPointsLabels_[feature.get('labelType')].push({label: label, id: semId});
								feature.getGeometry().appendPoint(fGeometry);
								if (!goog.isDef(feature.get('pointsObj')))
									feature.set('pointsObj', {});
								if (!goog.isDef(feature.get('pointsObjAll')))
									feature.set('pointsObjAll', {});
								feature.get('pointsObj')[semId] = fGeometry;
								feature.get('pointsObjAll')[semId] = fGeometry;
								found = true;
								break;
							case ol.geom.GeometryType.POLYGON:
								globalPolygonsLabels_[feature.get('labelType')].push({label: label, id: semId});
								feature.getGeometry().appendPolygon(fGeometry);
								if (!goog.isDef(feature.get('pointsObj')))
									feature.set('pointsObj', {});
								if (!goog.isDef(feature.get('pointsObjAll')))
									feature.set('pointsObjAll', {});
								feature.get('pointsObj')[semId] = fGeometry;
								feature.get('pointsObjAll')[semId] = fGeometry;
								found = true;
								break;
						}
					}
				}
				if (found) break;
			}
		}
		//
		if (!found) {
			//если не добавили(нет объектов или тип не подошел по найденному, например, для блок-боксов была точечная и тип полигона совпадает)
			//значит создаем новую фичу, то создаем мультифичу и туда добавляем
			if (true || features.length == 0) {
				var finalFeature = undefined;
				var stName = this.name + typeStr;
				if (fGeometry.getType() === 'Point' && this.drawTypes.indexOf('point') !== -1) {
					if (!goog.isDef(globalPointsLabels_[stName]))
						globalPointsLabels_[stName] = [];
					globalPointsLabels_[stName].push({label: label, id: semId, geo: fGeometry});
					if (!goog.isDef(globalPointsGEOs_[stName]))
						globalPointsGEOs_[stName] = {};
					globalPointsGEOs_[stName][semId] = fGeometry;
					this.hasData = true;
					var geometry = new ol.geom.MultiPoint(null);
					geometry.appendPoint(fGeometry);
					var newPointFeature = new ol.Feature(geometry);
					newPointFeature.set('layerId', that.name);
					newPointFeature.set('spacing', that.spacing);
					newPointFeature.set('zIndex', that.zIndex);
					newPointFeature.set('labelType', stName);
					newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
					newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
					newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);
					newPointFeature.set('type', stName.replace('/', '_'));
					newPointFeature.setId('DEFAULT_SELECTED_' + map.controls.DrawGeometryControl.generateGeoGUID());
					newPointFeature.setStyle(function (resolution) {
						var mapZoom = WidgetMap.map.getView().getZoom();
						var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'Point');
						var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), 'Point');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
									that.setTextStyle(s.style, textstyle);
								}
								else
									that.setTextStyle(s.style, null);

							}
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'Point');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), 'Point');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
									that.setTextStyle(s.style, textstyle);
								}
								else
									that.setTextStyle(s.style, null);
							}
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'Point');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', 'Point');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
									that.setTextStyle(s.style, textstyle);
								}
								else
									that.setTextStyle(s.style, null);
							}
							return [s.style];
						}
						return null;
					});
					finalFeature = newPointFeature;
				}
				if (fGeometry.getType() === 'LineString' && that.drawTypes.indexOf('line') !== -1) {
					if (!goog.isDef(globalLinesLabels_[stName]))
						globalLinesLabels_[stName] = [];
					if (!goog.isDef(globalLinesGEOs_[stName]))
						globalLinesGEOs_[stName] = {};
					globalLinesLabels_[stName].push({label: label, id: semId, geo: fGeometry});
					globalLinesGEOs_[stName][semId] = fGeometry;
					that.hasData = true;
					var geometry = new ol.geom.MultiLineString(null);
					geometry.setLineStrings([fGeometry]);
					var newLineFeature = new ol.Feature(geometry);
					newLineFeature.set('layerId', that.name);
					newLineFeature.set('spacing', that.spacing);
					newLineFeature.set('labelType', stName);
					newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
					newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
					newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);
					newLineFeature.set('type', stName.replace('/', '_'));
					newLineFeature.setId('DEFAULT_SELECTED_' + map.controls.DrawGeometryControl.generateGeoGUID());
					newLineFeature.setStyle(function (resolution) {
						var mapZoom = WidgetMap.map.getView().getZoom();
						var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'LineString');
						var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), 'LineString');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							if (goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'LineString');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), 'LineString');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							if (goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'LineString');
						if (!goog.isNull(s && !goog.isNull(s.style))) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', 'LineString');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);

							}
							if (goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						return null;
					});
					finalFeature = newLineFeature;
				}
				if (fGeometry.getType() === 'Polygon' && that.drawTypes.indexOf('polygon') !== -1) {
					if (!goog.isDef(globalPolygonsLabels_[stName]))
						globalPolygonsLabels_[stName] = [];
					if (!goog.isDef(globalPolygonsGEOs_[stName]))
						globalPolygonsGEOs_[stName] = {};
					globalPolygonsLabels_[stName].push({label: label, id: semId, geo: fGeometry});
					globalPolygonsGEOs_[stName][semId] = fGeometry;
					that.hasData = true;
					var geometry = new ol.geom.MultiPolygon(null);
					geometry.appendPolygon(fGeometry);
					var newPolygonFeature = new ol.Feature(geometry);
					newPolygonFeature.set('layerId', that.name);
					newPolygonFeature.set('spacing', that.spacing);
					newPolygonFeature.set('labelType', stName);
					newPolygonFeature.set('type', stName.replace('/', '_'));
					newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
					newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);
					newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);
					newPolygonFeature.set('type', stName.replace('/', '_'));
					newPolygonFeature.setId('DEFAULT_SELECTED_' + map.controls.DrawGeometryControl.generateGeoGUID());
					newPolygonFeature.setStyle(function (resolution) {
						var mapZoom = WidgetMap.map.getView().getZoom();
						var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'Polygon');
						var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyle(this.get('type'));
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if (goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'Polygon');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if (goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'Polygon');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if (goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						return null;
					});
					finalFeature = newPolygonFeature;
				}
				if (finalFeature) {
					that.dataReady_ = true;
					that.featureProjLayer.getSource().getSource().addFeature(finalFeature);
				}
			}
		}
		else {
			//если нашли, то центрируемся к нему
			/*if(goog.isDef(baseFeature) && goog.isDef(baseFeature.getGeometry)){
			 var extent = baseFeature.getGeometry().getExtent();
			 WidgetMap.centerOnMap(extent);
			 }*/
		}
	}
	return true;
};


/**
 * Обновление геометрии в слое
 * @param baseFeature фича с геометрией
 * @param semId id объекта
 */
map.layer.VectorLayer.prototype.updateGeometry = function (baseFeature, semId, force) {
	if (goog.isDef(this.featureProjLayer)) {
		var newExtent = undefined;
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		var j;
		for (j in features) {
			if (goog.isDef(newExtent))
				break;
			if (features[j].getGeometry().getType().indexOf(baseFeature.getGeometry().getType()) != -1) {
				var index = -1;
				var labels = features[j].get('labelsObj');
				var aa = 0;
				for (aa; aa < labels.length; aa++) {
					if (labels[aa].id == semId) {
						index = aa;
						break;
					}
				}
				switch (baseFeature.getGeometry().getType()) {
					case ol.geom.GeometryType.LINE_STRING:
						//заменяем строку на нужную
						if (index != -1) {
							if (this.name != 'PODS_ROUTE' || force === true) {
								var lineStrings = features[j].getGeometry().getLineStrings();
								if(baseFeature.getGeometry().flatCoordinates.length === 0) {
									this.deleteObjectById(semId);
									return;
									/*lineStrings.splice(index, 1);
									delete features[j].get('pointsObj')[semId];
									delete features[j].get('pointsObjAll')[semId];*/
								}
								else {
									lineStrings[index] = baseFeature.getGeometry();
									newExtent = baseFeature.getGeometry().getExtent();
									features[j].get('pointsObj')[semId] = baseFeature.getGeometry();
									features[j].get('pointsObjAll')[semId] = baseFeature.getGeometry();
								}
								features[j].getGeometry().setLineStrings(lineStrings);

							}
						}
						break;
					case ol.geom.GeometryType.POINT:
						//заменяем точку на нужную
						if (index !== -1) {
							var points = features[j].getGeometry().getCoordinates();
							if(baseFeature.getGeometry().flatCoordinates.length === 0) {
								this.deleteObjectById(semId);
								return;
								/*points.splice(index, 1);
								delete features[j].get('pointsObj')[semId];
								delete features[j].get('pointsObjAll')[semId];*/
							}
							else {
								points[index] = baseFeature.getGeometry().getCoordinates();
								newExtent = baseFeature.getGeometry().getExtent();
								features[j].get('pointsObj')[semId] = baseFeature.getGeometry();
								features[j].get('pointsObjAll')[semId] = baseFeature.getGeometry();
							}
							features[j].getGeometry().setCoordinates(points, ol.geom.GeometryLayout.XY);
						}
						break;
					case ol.geom.GeometryType.POLYGON:
						//заменяем полигон
						if (index != -1) {
							var polygons = features[j].getGeometry().getPolygons();
							if(baseFeature.getGeometry().flatCoordinates.length === 0) {
								this.deleteObjectById(semId);
								return;
								/*polygons.splice(index, 1);
								delete features[j].get('pointsObj')[semId];
								delete features[j].get('pointsObjAll')[semId];*/
							}
							else {
								polygons[index] = baseFeature.getGeometry();
								newExtent = baseFeature.getGeometry().getExtent();
								features[j].get('pointsObj')[semId] = baseFeature.getGeometry();
								features[j].get('pointsObjAll')[semId] = baseFeature.getGeometry();
							}
							features[j].getGeometry().setPolygons(polygons);
						}
						break;
				}
			}
		}
	}
};

/**
 * Показываем все объекты. Перед каждой фильтрацией
 */
map.layer.VectorLayer.prototype.showAllObjects_old = function () {
	//return;
	if(!this.featureProjLayer)
		return;
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var i = 0, j = 0;
	var findedPointFeatures = {};//найденные фичи
	var findedLineFeatures = {};//найденные фичи
	var findedPolygonFeatures = {};//найденные фичи
	var features4Deletion = [];//фичи на удаление
	try{
		for (i; i < features.length; i++) {
			//ищем только в multiPoint
			var oId;
			var feature = features[i];
			var featureLabelType = feature.get('labelType');
			var labelsObjAll = feature.get('labelsObjAll');
			var pointsObjAll = feature.get('pointsObjAll');
			if(feature.get('labelsObjAllBackup')){
				labelsObjAll = feature.get('labelsObjAllBackup');
				pointsObjAll = feature.get('pointsObjAllBackup');
			}
			if (goog.isDef(labelsObjAll)){
				for(j = 0; j< labelsObjAll.length; j++){
					oId = labelsObjAll[j].id;
					if (goog.isDef(pointsObjAll[oId])) {
						//добавляем фичу найденную
						var type = pointsObjAll[oId].getType();
						if (type == ol.geom.GeometryType.POINT) {
							if (!goog.isDef(findedPointFeatures[featureLabelType])) {
								findedPointFeatures[featureLabelType] = this.cloneFeature(feature, false);
								findedPointFeatures[featureLabelType].set('pointsObj', {});
								findedPointFeatures[featureLabelType].set('labelsObj', []);
								findedPointFeatures[featureLabelType].setId(App.generateUUID());
								features4Deletion.push(feature);
							}
							//установил новый объект с геометрией
							findedPointFeatures[featureLabelType].get('pointsObj')[oId] = pointsObjAll[oId];
							findedPointFeatures[featureLabelType].get('labelsObj').push(labelsObjAll[j])
						}
						else if (type == ol.geom.GeometryType.LINE_STRING) {
							if (!goog.isDef(findedLineFeatures[featureLabelType])) {
								findedLineFeatures[featureLabelType] = this.cloneFeature(feature, false);
								findedLineFeatures[featureLabelType].set('pointsObj', {});
								findedLineFeatures[featureLabelType].set('labelsObj', []);
								findedLineFeatures[featureLabelType].setId(App.generateUUID());
								features4Deletion.push(feature);
							}
							//установил новый объект с геометрией
							findedLineFeatures[featureLabelType].get('pointsObj')[oId] = pointsObjAll[oId];
							findedLineFeatures[featureLabelType].get('labelsObj').push(labelsObjAll[j]);
						}
						else if (type == ol.geom.GeometryType.POLYGON) {
							if (!goog.isDef(findedPolygonFeatures[featureLabelType])) {
								findedPolygonFeatures[featureLabelType] = this.cloneFeature(feature, false);
								findedPolygonFeatures[featureLabelType].set('pointsObj', {});
								findedPolygonFeatures[featureLabelType].set('labelsObj', []);
								findedPolygonFeatures[featureLabelType].setId(App.generateUUID());
								features4Deletion.push(feature);
							}
							//установил новый объект с геометрией
							findedPolygonFeatures[featureLabelType].get('pointsObj')[oId] = pointsObjAll[oId];
							findedPolygonFeatures[featureLabelType].get('labelsObj').push(labelsObjAll[j]);
						}
						this.clearFeatureLabels_(features[i]);
					}
					//если не нашли, то делаем фичу без объектов
					else {
						var lbObj = feature.get('labelsObjAll');
						if (goog.isDef(lbObj) && lbObj.length > 0 && goog.isDef(lbObj[0].geo)) {
							var type = (lbObj[0].geo.getType)?lbObj[0].geo.getType():lbObj[0].geo.getGeometry().getType();
							if (type == ol.geom.GeometryType.POINT) {
								if (!goog.isDef(findedPointFeatures[featureLabelType])) {
									findedPointFeatures[featureLabelType] = this.cloneFeature(feature, false);
									findedPointFeatures[featureLabelType].set('pointsObj', {});
									findedPointFeatures[featureLabelType].set('labelsObj', []);
									features4Deletion.push(features[i]);
								}
							}
							else if (type == ol.geom.GeometryType.LINE_STRING) {
								if (!goog.isDef(findedLineFeatures[featureLabelType])) {
									findedLineFeatures[featureLabelType] = this.cloneFeature(feature, false);
									findedLineFeatures[featureLabelType].set('pointsObj', {});
									findedLineFeatures[featureLabelType].set('labelsObj', []);
									features4Deletion.push(feature);
								}
							}
							else if (type == ol.geom.GeometryType.POLYGON) {
								if (!goog.isDef(findedPolygonFeatures[featureLabelType])) {
									findedPolygonFeatures[featureLabelType] = this.cloneFeature(feature, false);
									findedPolygonFeatures[featureLabelType].set('pointsObj', {});
									findedPolygonFeatures[featureLabelType].set('labelsObj', []);
									features4Deletion.push(feature);
								}
							}
							this.clearFeatureLabels_(feature);
						}
					}
				}
			}
		}
	}
	catch(ex){
		//console.log('1')
	}


	//нашли и сделали все фичи для объектов, добавляем новую копию
	var obj;
	var centeringExtent = ol.extent.createEmpty();
	//проходимся по точечным фичам
	try{
		for (obj in findedPointFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedPointFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				geos.push(lObj[k].geo.flatCoordinates);
			}

			var geometry = new ol.geom.MultiPoint(null);
			geometry.setCoordinates(geos, ol.geom.GeometryLayout.XY);
			findedPointFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedPointFeatures[obj]);
		}

		for (obj in findedLineFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedLineFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				geos.push(lObj[k].geo);
			}
			var geometry = new ol.geom.MultiLineString(null);
			geometry.setLineStrings(geos);
			findedLineFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedLineFeatures[obj]);
		}

		for (obj in findedPolygonFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedPolygonFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				var pp = new ol.geom.Polygon(null);
				var linearRing = new ol.geom.LinearRing(null);
				linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, lObj[k].geo.flatCoordinates);
				pp.appendLinearRing(linearRing);
				geos.push(pp);
			}
			var geometry = new ol.geom.MultiPolygon(null);
			geometry.setPolygons(geos);
			findedPolygonFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedPolygonFeatures[obj]);
		}

		var i = 0;
		for (i; i < features4Deletion.length; i++)
			this.featureProjLayer.getSource().getSource().removeFeature(features4Deletion[i]);
		this.featureProjLayer.changed();
	}
	catch(ex){}

}

/**
 * Показываем все объекты. Перед каждой фильтрацией
 */
map.layer.VectorLayer.prototype.showAllObjects = function () {
	if(!this.featureProjLayer)
		return;
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var i = 0, j = 0, findedFeature;
	var findedPointFeatures = {};//найденные фичи
	var findedLineFeatures = {};//найденные фичи
	var findedPolygonFeatures = {};//найденные фичи
	var features4Deletion = features;//фичи на удаление
	try{
		//первый проход чистка фич
		for (i; i < features.length; i++) {
			var feature = features[i];
			this.clearFeatureLabels_(feature);
			var featureLabelType = feature.get('labelType');
			var lbObj = feature.get('labelsObjAll');
			var labelsObjAll = feature.get('labelsObjAll');
			var pointsObjAll = feature.get('pointsObjAll');
			if(feature.get('labelsObjAllBackup')){
				labelsObjAll = feature.get('labelsObjAllBackup');
				pointsObjAll = feature.get('pointsObjAllBackup');
				lbObj = labelsObjAll;
			}
			if (lbObj && lbObj.length > 0 && lbObj[0].geo) {
				var type = (lbObj[0].geo.getType) ? lbObj[0].geo.getType() : lbObj[0].geo.getGeometry().getType();
				if (type === ol.geom.GeometryType.POINT) {
					findedPointFeatures[featureLabelType] = this.cloneFeature(feature, false);
					globalPointsLabels_[featureLabelType] = labelsObjAll;
					findedFeature = findedPointFeatures[featureLabelType];
					findedFeature.set('labelsObj', goog.array.clone(globalPointsLabels_[featureLabelType]));
					findedFeature.set('labelsObjAll', globalPointsLabels_[featureLabelType]);
					findedFeature.set('pointsObj',  pointsObjAll);// goog.object.clone(feature.get('labelsObjAll'))
					findedFeature.set('pointsObjAll', pointsObjAll);
				}
				else if (type === ol.geom.GeometryType.LINE_STRING) {
					findedLineFeatures[featureLabelType] = this.cloneFeature(feature, false);
					globalLinesLabels_[featureLabelType] = labelsObjAll;
					findedFeature = findedLineFeatures[featureLabelType];
					findedFeature.set('labelsObj', goog.array.clone(globalLinesLabels_[featureLabelType]));
					findedFeature.set('labelsObjAll', globalLinesLabels_[featureLabelType]);
					findedFeature.set('pointsObj',  pointsObjAll);// goog.object.clone(feature.get('labelsObjAll'))
					findedFeature.set('pointsObjAll', pointsObjAll);
				}
				else if (type === ol.geom.GeometryType.POLYGON) {
					findedPolygonFeatures[featureLabelType] = this.cloneFeature(feature, false);
					globalPolygonsLabels_[featureLabelType] = labelsObjAll;
					findedFeature = findedPolygonFeatures[featureLabelType];
					findedFeature.set('labelsObj', goog.array.clone(globalPolygonsLabels_[featureLabelType]));
					findedFeature.set('labelsObjAll', globalPolygonsLabels_[featureLabelType]);
					findedFeature.set('pointsObj',  pointsObjAll);// goog.object.clone(feature.get('labelsObjAll'))
					findedFeature.set('pointsObjAll', pointsObjAll);

				}
				if(findedFeature){
					findedFeature.set('pointsObjAllBackup', undefined);
					findedFeature.set('labelsObjAllBackup', undefined);
					findedFeature.setId(App.generateUUID());
					findedFeature = undefined;
				}
			}
		}
	}
	catch(ex){
		//console.log('1')
	}

	for (i = 0; i < features4Deletion.length; i++)
		this.featureProjLayer.getSource().getSource().removeFeature(features4Deletion[i]);
	//нашли и сделали все фичи для объектов, добавляем новую копию
	var obj;
	var centeringExtent = ol.extent.createEmpty();
	//проходимся по точечным фичам
	try{
		for (obj in findedPointFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedPointFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				var fl = GeoUtil.getFlatGeometry(lObj[k].geo);
				if(fl) geos.push(fl);
			}
			var geometry = new ol.geom.MultiPoint(null);
			geometry.setCoordinates(geos, ol.geom.GeometryLayout.XY);
			findedPointFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedPointFeatures[obj]);
		}

		for (obj in findedLineFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedLineFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				var fl = GeoUtil.getFlatGeometry(lObj[k].geo);
				if(fl) geos.push(fl);
			}
			var geometry = new ol.geom.MultiLineString(null);
			geometry.setLineStrings(geos);
			findedLineFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedLineFeatures[obj]);
		}

		for (obj in findedPolygonFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedPolygonFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				var fl = GeoUtil.getFlatGeometry(lObj[k].geo);
				if(fl) geos.push(fl);
			}
			var geometry = new ol.geom.MultiPolygon(null);
			geometry.setPolygons(geos);
			findedPolygonFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedPolygonFeatures[obj]);
		}
	}
	catch(ex){ }
}


/**
 * Оставляет на карте только выбранные объекты
 * @param objects
 * @param centering - флаг масштабирования
 */
map.layer.VectorLayer.prototype.showObjectById = function (objects, centering) {
	//удаляем фичу и создаём новую с выбранными геометриями
	//проходим по всем фичам и забираем по id Объекта геометрию из _globalPointLabels,
	//TODO добавить обработку @ для гдала
	var findedPointFeatures = {};//найденные фичи
	var findedLineFeatures = {};//найденные фичи
	var findedPolygonFeatures = {};//найденные фичи
	var features4Deletion = [];//фичи на удаление
	try{
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		var i = 0, j = 0;
		for (j; j < objects.length; j++) {
			i = 0;
			for (i; i < features.length; i++) {
				//ищем только в multiPoint
				var oId = objects[j];
				if (goog.isDef(features[i].get('pointsObjAll')) && goog.isDef(features[i].get('pointsObjAll')[oId])) {
					//newPointsObj[oId] = features[i].get('pointsObj')[oId];
					//добавляем фичу найденную
					var type = features[i].get('pointsObjAll')[oId].getType();
					if (type == ol.geom.GeometryType.POINT) {
						if (!goog.isDef(findedPointFeatures[features[i].get('labelType')])) {
							findedPointFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
							findedPointFeatures[features[i].get('labelType')].set('pointsObj', {});
							findedPointFeatures[features[i].get('labelType')].set('labelsObj', []);
							//findedPointFeatures[features[i].get('labelType')].setId(App.generateUUID());
							features4Deletion.push(features[i]);
						}
						//установил новый объект с геометрией
						findedPointFeatures[features[i].get('labelType')].get('pointsObj')[oId] = features[i].get('pointsObjAll')[oId];
					}
					else if (type == ol.geom.GeometryType.LINE_STRING) {
						if (!goog.isDef(findedLineFeatures[features[i].get('labelType')])) {
							findedLineFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
							findedLineFeatures[features[i].get('labelType')].set('pointsObj', {});
							findedLineFeatures[features[i].get('labelType')].set('labelsObj', []);
							//findedLineFeatures[features[i].get('labelType')].setId(App.generateUUID());
							features4Deletion.push(features[i]);
						}
						//установил новый объект с геометрией
						findedLineFeatures[features[i].get('labelType')].get('pointsObj')[oId] = features[i].get('pointsObjAll')[oId];
					}
					else if (type == ol.geom.GeometryType.POLYGON) {
						if (!goog.isDef(findedPolygonFeatures[features[i].get('labelType')])) {
							findedPolygonFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
							findedPolygonFeatures[features[i].get('labelType')].set('pointsObj', {});
							findedPolygonFeatures[features[i].get('labelType')].set('labelsObj', []);
							findedPolygonFeatures[features[i].get('labelType')].setId(App.generateUUID());
							features4Deletion.push(features[i]);
						}
						//установил новый объект с геометрией
						findedPolygonFeatures[features[i].get('labelType')].get('pointsObj')[oId] = features[i].get('pointsObjAll')[oId];
					}
					this.clearFeatureLabels_(features[i]);
				}
				//если не нашли, то делаем фичу без объектов
				else {
					var lbObj = features[i].get('labelsObjAll');
					if (goog.isDef(lbObj) && lbObj.length > 0 && goog.isDef(lbObj[0].geo)) {
						var type = (lbObj[0].geo.getType)?lbObj[0].geo.getType():lbObj[0].geo.getGeometry().getType();
						if (type == ol.geom.GeometryType.POINT) {
							if (!goog.isDef(findedPointFeatures[features[i].get('labelType')])) {
								findedPointFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
								findedPointFeatures[features[i].get('labelType')].set('pointsObj', {});
								findedPointFeatures[features[i].get('labelType')].set('labelsObj', []);
								findedPointFeatures[features[i].get('labelType')].setId(App.generateUUID());
								features4Deletion.push(features[i]);
							}
						}
						else if (type == ol.geom.GeometryType.LINE_STRING) {
							if (!goog.isDef(findedLineFeatures[features[i].get('labelType')])) {
								findedLineFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
								findedLineFeatures[features[i].get('labelType')].set('pointsObj', {});
								findedLineFeatures[features[i].get('labelType')].set('labelsObj', []);
								findedLineFeatures[features[i].get('labelType')].setId(App.generateUUID());
								features4Deletion.push(features[i]);
							}
						}
						else if (type == ol.geom.GeometryType.POLYGON) {
							if (!goog.isDef(findedPolygonFeatures[features[i].get('labelType')])) {
								findedPolygonFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
								findedPolygonFeatures[features[i].get('labelType')].set('pointsObj', {});
								findedPolygonFeatures[features[i].get('labelType')].set('labelsObj', []);
								findedPolygonFeatures[features[i].get('labelType')].setId(App.generateUUID());
								features4Deletion.push(features[i]);
							}
						}
						this.clearFeatureLabels_(features[i]);
					}
				}
			}
		}
	}
	catch(ex){
		//console.log('2')
	}


	//нашли и сделали все фичи для объектов, добавляем новую копию
	var obj;
	//если флаг масштабирования  = true, то его по всем фичам считаем
	var centeringExtent = ol.extent.createEmpty();
	var i = 0;
	for (i; i < features4Deletion.length; i++)
		this.featureProjLayer.getSource().getSource().removeFeature(features4Deletion[i]);

	var featuresToAppend = [];
	var geometry;
	//проходимся по точечным фичам
	for (obj in findedPointFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedPointFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedPointFeatures[obj].get('labelsObjAll');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedPointFeatures[obj].get('labelsObj').push(labels[t]);
					break;
				}
			}
			geos.push(pObj[geo].flatCoordinates);//собираем геометрии
		}
		geometry = new ol.geom.MultiPoint(null);
		geometry.setCoordinates(geos, ol.geom.GeometryLayout.XY);
		findedPointFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedPointFeatures[obj]);
		if(geos.length > 0){
			if (centering == true)
				ol.extent.extend(centeringExtent, findedPointFeatures[obj].getGeometry().getExtent());
		}
	}


	for (obj in findedLineFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedLineFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedLineFeatures[obj].get('labelsObjAll');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedLineFeatures[obj].get('labelsObj').push(labels[t]);
					break;
				}
			}
			geos.push(pObj[geo]);//собираем геометрии
		}
		geometry = new ol.geom.MultiLineString(null);
		geometry.setLineStrings(geos);
		findedLineFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedLineFeatures[obj]);
		if(geos.length > 0){
			if (centering == true)
				ol.extent.extend(centeringExtent, findedLineFeatures[obj].getGeometry().getExtent());
		}
	}

	for (obj in findedPolygonFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedPolygonFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedPolygonFeatures[obj].get('labelsObjAll');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedPolygonFeatures[obj].get('labelsObj').push(labels[t]);
					break;
				}
			}
			var pp = new ol.geom.Polygon(null);
			var linearRing = new ol.geom.LinearRing(null);
			linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, pObj[geo].flatCoordinates);
			pp.appendLinearRing(linearRing);
			geos.push(pp);
		}//собираем геометрии
		geometry = new ol.geom.MultiPolygon(null);
		geometry.setPolygons(geos);
		findedPolygonFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedPolygonFeatures[obj]);
		if(geos.length > 0){
			if (centering == true)
				ol.extent.extend(centeringExtent, findedPolygonFeatures[obj].getGeometry().getExtent());
		}
	}
	if(featuresToAppend.length > 0)
		this.featureProjLayer.getSource().getSource().addFeatures(featuresToAppend);
	this.featureProjLayer.changed();
	if (centering == true) {
		WidgetMap.centerOnMap(centeringExtent);
	}
};

map.layer.VectorLayer.prototype.showObjectsByIds = function (objects, centering) {
	var that = this;
	//удаляем фичу и создаём новую с выбранными геометриями
	//проходим по всем фичам и забираем по id Объекта геометрию из _globalPointLabels,
	var findedPointFeatures = {};//найденные фичи
	var findedLineFeatures = {};//найденные фичи
	var findedPolygonFeatures = {};//найденные фичи
	var features4Deletion = [];//фичи на удаление
	try{
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		features4Deletion = features;
		var i = 0, j = 0, findedFeature;
		//первый проход чистка фич
		for (i; i < features.length; i++) {
			this.clearFeatureLabels_(features[i]);
			var featureLabelType = features[i].get('labelType');
			var lbObj = features[i].get('labelsObjAll');
			if (lbObj && lbObj.length > 0 && lbObj[0].geo) {
				var type = (lbObj[0].geo.getType) ? lbObj[0].geo.getType() : lbObj[0].geo.getGeometry().getType();
				if (type === ol.geom.GeometryType.POINT) {
					findedPointFeatures[featureLabelType] = this.cloneFeature(features[i], false);
					globalPointsLabels_[featureLabelType] = [];
					findedFeature = findedPointFeatures[featureLabelType];
				}
				else if (type === ol.geom.GeometryType.LINE_STRING) {
					findedLineFeatures[featureLabelType] = this.cloneFeature(features[i], false);
					globalLinesLabels_[featureLabelType] = [];
					findedFeature = findedLineFeatures[featureLabelType];
				}
				else if (type === ol.geom.GeometryType.POLYGON) {
					findedPolygonFeatures[featureLabelType] = this.cloneFeature(features[i], false);
					globalPolygonsLabels_[featureLabelType] = [];
					findedFeature = findedPolygonFeatures[featureLabelType];
				}
				if(findedFeature){
					findedFeature.set('pointsObj', {});
					findedFeature.set('pointsObjAll', {});
					findedFeature.set('pointsObjAllBackup', goog.object.clone(features[i].get('pointsObjAll')));
					findedFeature.set('labelsObj', []);
					findedFeature.set('labelsObjAll', []);
					findedFeature.set('labelsObjAllBackup', goog.array.clone(features[i].get('labelsObjAll')));
					findedFeature.setId(App.generateUUID());
					findedFeature = undefined;
				}
			}
		}
		//второй проход установка найденных объектов
		for (i = 0; i < features.length; i++) {
			var featureLabelType = features[i].get('labelType');
			var featurePointsAll = features[i].get('pointsObjAll');
			for (j = 0; j < objects.length; j++) {
				var oId = objects[j];
				if(that.hasSemanticField){
					for(var fp in featurePointsAll){
						if(fp.indexOf('|') !== -1 && fp.split('|')[1] === oId){
							//добавляем фичу найденную
							var type = featurePointsAll[fp].getType();
							if (type === ol.geom.GeometryType.POINT) {
								findedPointFeatures[featureLabelType].get('pointsObj')[fp] = featurePointsAll[fp];
								findedPointFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
							}
							else if (type === ol.geom.GeometryType.LINE_STRING) {
								findedLineFeatures[featureLabelType].get('pointsObj')[fp] = featurePointsAll[fp];
								findedLineFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
							}
							else if (type === ol.geom.GeometryType.POLYGON) {
								findedPolygonFeatures[featureLabelType].get('pointsObj')[fp] = featurePointsAll[fp];
								findedPolygonFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
							}
						}
					}
				}
				else{
					if (featurePointsAll && featurePointsAll[oId]) {
						//добавляем фичу найденную
						var type = featurePointsAll[oId].getType();
						if (type === ol.geom.GeometryType.POINT) {
							findedPointFeatures[featureLabelType].get('pointsObj')[oId] = featurePointsAll[oId];
							findedPointFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
						}
						else if (type === ol.geom.GeometryType.LINE_STRING) {
							findedLineFeatures[featureLabelType].get('pointsObj')[oId] = featurePointsAll[oId];
							findedLineFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
						}
						else if (type === ol.geom.GeometryType.POLYGON) {
							findedPolygonFeatures[featureLabelType].get('pointsObj')[oId] = featurePointsAll[oId];
							findedPolygonFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
						}
					}
				}
			}
		}
	}
	catch(ex){
	}

	//нашли и сделали все фичи для объектов, добавляем новую копию
	var obj;
	//если флаг масштабирования  = true, то его по всем фичам считаем
	var centeringExtent = ol.extent.createEmpty();
	var i = 0;
	for (i; i < features4Deletion.length; i++)
		this.featureProjLayer.getSource().getSource().removeFeature(features4Deletion[i]);

	var featuresToAppend = [];
	var geometry;
	//проходимся по точечным фичам
	for (obj in findedPointFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedPointFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedPointFeatures[obj].get('labelsObjAllBackup');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedPointFeatures[obj].get('labelsObj').push(labels[t]);
					globalPointsLabels_[obj].push(labels[t]);
					break;
				}
			}
			geos.push(pObj[geo].flatCoordinates);//собираем геометрии
		}
		geometry = new ol.geom.MultiPoint(null);
		geometry.setCoordinates(geos, ol.geom.GeometryLayout.XY);
		findedPointFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedPointFeatures[obj]);
		if(geos.length > 0 && centering == true){
			ol.extent.extend(centeringExtent, findedPointFeatures[obj].getGeometry().getExtent());
		}
	}


	for (obj in findedLineFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedLineFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedLineFeatures[obj].get('labelsObjAllBackup');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedLineFeatures[obj].get('labelsObj').push(labels[t]);
					globalLinesLabels_[obj].push(labels[t]);
					break;
				}
			}
			geos.push(pObj[geo]);//собираем геометрии
		}
		geometry = new ol.geom.MultiLineString(null);
		geometry.setLineStrings(geos);
		findedLineFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedLineFeatures[obj]);
		if(geos.length > 0 && centering == true){
			ol.extent.extend(centeringExtent, findedLineFeatures[obj].getGeometry().getExtent());
		}
	}

	for (obj in findedPolygonFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedPolygonFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedPolygonFeatures[obj].get('labelsObjAllBackup');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedPolygonFeatures[obj].get('labelsObj').push(labels[t]);
					globalPolygonsLabels_[obj].push(labels[t]);
					break;
				}
			}
			var pp = new ol.geom.Polygon(null);
			var linearRing = new ol.geom.LinearRing(null);
			linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, pObj[geo].flatCoordinates);
			pp.appendLinearRing(linearRing);
			geos.push(pp);
		}//собираем геометрии
		geometry = new ol.geom.MultiPolygon(null);
		geometry.setPolygons(geos);
		findedPolygonFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedPolygonFeatures[obj]);
		if(geos.length > 0 && centering == true){
			ol.extent.extend(centeringExtent, findedPolygonFeatures[obj].getGeometry().getExtent());
		}
	}
	if(featuresToAppend.length > 0)
		this.featureProjLayer.getSource().getSource().addFeatures(featuresToAppend);
	this.featureProjLayer.changed();
	if (centering == true) {
		WidgetMap.centerOnMap(centeringExtent);
	}
};

/**
 * Получение геометрии по id
 * @param id
 */
map.layer.VectorLayer.prototype.getGeometryById = function (id) {
	if (!goog.isDef(id) || id == '')
		return undefined;
	//выбираем все features, в которых возможно хранить наш тип геометрии
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	for (j; j < features.length; j++) {
		var points = features[j].get('pointsObjAll');
		var aa;
		for (aa in points) {
			if (aa == id) {
				return points[aa];
			}
		}
	}
	return undefined;
};


/**
 * Получение массива геометрий
 */
map.layer.VectorLayer.prototype.getAllGeometries = function () {
	var result = [];
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	for (j; j < features.length; j++) {
		var points = features[j].get('pointsObjAll');
		for (var aa in points) {
			result.push(points[aa])
		}
	}
	return result;
};


/**
 *
 * @param feature фича для клонирования
 * @param withGeo флаг, нужно ли копировать геометрию
 * @returns {ol.Feature}
 */
map.layer.VectorLayer.prototype.cloneFeature = function (feature, withGeo) {
	var clone = new ol.Feature(feature.getProperties());
	clone.setGeometryName(feature.getGeometryName());
	if (withGeo == true) {
		var geometry = feature.getGeometry();
		if (geometry) {
			clone.setGeometry(geometry.clone());
		}
	}
	var style = feature.getStyle();
	if (style) {
		clone.setStyle(style);
	}
	return clone;
};

/**
 * Функция получения данных из кеша (если они там есть и актуальны)
 */
map.layer.VectorLayer.prototype.getDataFromCache = function () {
	if (supports_html5_storage()) {
		var retrievedObject = sessionStorage.getItem(this.name);
		return JSON.parse(retrievedObject);
	}

};

/**
 * Функция принудительной очистки кеша
 * (применяется при добавлении, изменении или удалении объектов слоя)
 */
map.layer.VectorLayer.prototype.clearDataCache = function () {
	if (supports_html5_storage()) {

	}

};

/**
 * Функция сохранения результата геозапроса в кеш
 * @param resultData - данные для кеширования
 */
map.layer.VectorLayer.prototype.saveResultToCache = function (resultData) {
	if (supports_html5_storage()) {
		//Пытаемся получить локальный кеш и сохранить пришедшие данные в него
		if (sessionStorage[this.name] == undefined && this.name != 'PODS_ROUTE') {
			var curDate = new Date();
			var testObject = {CACHE_ACTUAL_DATE: curDate, result: resultData};
			var strItem = JSON.stringify(testObject);
			try {
				sessionStorage.setItem(this.name, strItem);
			}
			catch (ex) {
				//App.errorReport('Ошибка при сохранении данных слоя "'+this.sourceDescr+'" в кеш браузера', ex);
			}
			//Проверяем результат сохранения
		}
	}
};
/**
 * Получение геометрии по id
 * @param id
 */
map.layer.VectorLayer.prototype.updateGeometryById = function (id, geometry) {
	if (!id || !geometry)
		return;
	//выбираем все features, в которых возможно хранить наш тип геометрии
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	for (j; j < features.length; j++) {
		var index = -1;
		var labels = features[j].get('labelsObj');
		var aa = 0;
		for (aa; aa < labels.length; aa++) {
			if (labels[aa].id === id) {
				try {
					index = aa;
					//делаем копию объекта
					var baseFeature = labels[aa].geo;
					if (!baseFeature.getGeometry)// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
						baseFeature = new ol.Feature(baseFeature);
					baseFeature.setGeometry(geometry);
					//обновляем геометрию в слое
					this.updateGeometry(baseFeature, id, true);
					this.featureProjLayer.getSource().changed();
					//this.featureProjLayer.changed();
					return baseFeature;
				}
				catch (e) {
				}
				break;
			}
		}
	}
};

/**
 * Обновление типа отрисовки на карте
 * если у объекта поменялся стиль отрисовки при сохранении семантики TYPE_CL,
 * то перерисовываем его новым стилем и переносим в другую фичу с его типом
 * @param semId идентификатор объекта
 * @param data данные, которые передавались на сохранение, которые содержат тип отрисовки из TYPE_CL
 */
map.layer.VectorLayer.prototype.updateObjectGeoStyle = function (semId, data, dataObject) {
	if (goog.isDef(data)) {
		var that = this;
		var classField = data[0].getAttribute(this.classField);
		if (goog.isDefAndNotNull(classField) && goog.isDef(this.featureProjLayer)) {
			var features = this.featureProjLayer.getSource().getSource().getFeatures();
			var i = 0, j = 0;
			for (j; j < features.length; j++) {
				var labelsObj = features[j].get('labelsObj');
				for (i = 0; i < labelsObj.length; i++) {
					if (labelsObj[i].id == semId) {
						//ищем объект и проверяем менялся ли у него classField. Если да - обновляем геометрию
						//TODO убедиться, что всегда 2 элемента при split у  labelType
						var featureClass = features[j].get('labelType').split('/')[1];
						if (classField == featureClass)
							break;
						var geoType = features[j].get('pointsObjAll')[semId].getType();
						//переносим объект
						this.moveObjectGeoToAnotherFeature(semId, classField, dataObject);
						this.featureProjLayer.getSource().changed();
						break;
					}
				}
			}
		}

	}
};

/**
 * Функция переносит объект в другую фичу
 * Сначала удаляет из старой и потом добавляет в новую
 */
map.layer.VectorLayer.prototype.moveObjectGeoToAnotherFeature = function (id, classField, dataObject) {
	if (!goog.isDef(id) || id == '')
		return;
	//выбираем все features, в которых возможно хранить наш тип геометрии
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	for (j; j < features.length; j++) {
		var index = -1;
		var labels = features[j].get('labelsObj');
		var pointsAll = features[j].get('pointsObjAll');
		var points = features[j].get('pointsObj');
		var aa = 0;
		for (aa; aa < labels.length; aa++) {
			if (labels[aa].id == id) {
				try {
					index = aa;
					//делаем копию объекта
					var currObj = labels[aa];
					var baseFeature = labels[aa].geo;
					if (!goog.isDef(baseFeature.getGeometry))// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
						baseFeature = new ol.Feature(baseFeature);
					labels.splice(index, 1);
					delete pointsAll[id];
					delete points[id];
					//удаляем
					GeoUtil.removeObjectFromGeometry(features[j], index);
					//если удалили последний объект в фиче, кто он ребудет рендериться, соответственно, не будет чистится _LABELS
					// поэтому чистим _LABELS
					if (labels.length == 0) {
						this.clearFeatureLabels_(features[j]);
					}
					//добавляем объект в другую фичу
					this.addGeometry(baseFeature, id, dataObject);

				}
				catch (e) {
				}
				//features[j].changed();
				break;
			}
		}
	}
};

/**
 * Получение иконки для слоя
 */
map.layer.VectorLayer.prototype.getIcon = function () {
	var topology = this.drawTypes[0];
	var styleArr = WidgetMap.layerManager.getStyleObjByNameAndType(this.name,topology);
	if(styleArr !== undefined && styleArr.length != 0){
		var style = styleArr[0];
		if(style !== undefined){
			if(style.pointObj !== undefined){
				if(style.pointObj.form === 'bitmap')
					return style.pointObj.href;
				else{

				}
			}
			else if(style.polyObj !== undefined){

			}
			else if(style.lineObj !== undefined){
				//color, size
			}
		}
	}
};


/**
 * Трансвормация типа геометрии к текущему слою
 * @param fGeometry
 * @returns {*}
 */
map.layer.VectorLayer.prototype.transformGeometryLayout = function(fGeometry){
	try{
		if(fGeometry){
			var newFGeometry = undefined;
			//производим трансформаци из XY в XYZ и наоборот
			if(fGeometry.layout === ol.geom.GeometryLayout.XY){
				//newFGeometry
			}
			else{//ol.geom.GeometryLayout.XYZ

			}
		}
	}
	catch(ex){

	}
	return fGeometry;
};



/**
 * откат геометрии
 */
map.layer.VectorLayer.prototype.revertGeometry = function (data) {
	try{
		if(data && data.labelsObj){
			//выбираем все features, в которых возможно хранить наш тип геометрии
			var features = this.featureProjLayer.getSource().getSource().getFeatures();
			for (var j = 0; j < features.length; j++) {
				var labels = features[j].get('labelsObj');
				var pointsAll = features[j].get('pointsObjAll');
				var points = features[j].get('pointsObj');
				var aa = 0;
				var finded = false;
				for (aa; aa < labels.length; aa++) {
					if (labels[aa].id === data.labelsObj.id) {
						try {
							finded = true;
							//забираем гео сохраненного объекта
							var baseFeature = data.labelsObj.geo;
							if (!baseFeature.getGeometry)// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
								baseFeature = new ol.Feature(baseFeature);
							//обновляем геометрию в слое
							this.updateGeometry(baseFeature, data.labelsObj.id, true);
							this.featureProjLayer.getSource().changed();
							return ;
						}
						catch (e) {
						}
						break;
					}
				}
			}
			//если не нашли, то добавляем геометрию
			if(!finded){
				try {
					finded = true;
					//забираем гео сохраненного объекта
					var baseFeature = data.labelsObj.geo;
					if (!baseFeature.getGeometry)// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
						baseFeature = new ol.Feature(baseFeature);
					//обновляем геометрию в слое
					//var savingData = '<root><data LABEL="' + data.labelsObj.label + '"></root>'
					this.addGeometry(baseFeature, data.labelsObj.id, {label:data.labelsObj.label});
					this.featureProjLayer.getSource().changed();
					return ;
				}
				catch (e) {
				}
			}
		}
	}
	catch(ex){

	}
};

/**
 * Функция обновления геометрий объектов из базы по их идентификаторам
 */
map.layer.VectorLayer.prototype.loadObjectsByIds = function (ids) {
	var that = this;

	function getLayerGeoReqParams(request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var filter = 'ID in ('+ids.join()+')';
		return {
			descrId: request,
			descrType: 'select',
			topology: that.drawTypes.join(),
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" ' + topFiltersStr + '' +
				'>' +
				'<data FILTER=" ' + filter + '" />' +
				'</root>'
		};
	}

	function getLayerGeoResult(resultXml) {
		try {
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			for (var i = 0; i < datas.length; i++) {
				var format = new ol.format.WKT({dimension: 2});
				var wktStr = datas[i].getAttribute("WKT");
				var idStr = datas[i].getAttribute("ID");
				if (idStr == '' || idStr === null) {
					idStr = datas[i].getAttribute("id");
				}
				if (wktStr == '' && idStr == '') {
					BlockingUtil.readyGeo();
					return;
				}
				var stride = 2;
				var fGeometry;
				try {
					fGeometry = format.readGeometry(wktStr);
				}
				catch (ex) {
					//для случая с видеозаписями, приходит 3 координаты
					stride = 3;
					format = new map.format.WKT({dimension: stride});
					fGeometry = format.readGeometry(wktStr);
				}
				if (fGeometry.getType() === 'Point' || fGeometry.getType() === 'LineString' || fGeometry.getType() === 'Polygon')
					GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
			}
			var featureProjLayer = that.featureProjLayer;
			//выбираем все features, в которых возможно хранить наш тип геометрии
			var features = featureProjLayer.getSource().getSource().getFeatures();
			var j;
			for (j in features) {
				var index = -1;
				var labels = features[j].get('labelsObj');
				var aa = 0;
				for (; aa < labels.length; aa++) {
					if (labels[aa].id == idStr) {
						index = aa;
						break;
					}
				}
				if (fGeometry.getType() == ol.geom.GeometryType.LINE_STRING) {
					//заменяем строку на нужную
					if (index != -1) {
						var lineStrings = features[j].getGeometry().getLineStrings();
						lineStrings[index] = fGeometry;
						features[j].get('pointsObj')[idStr] = fGeometry;
						features[j].get('pointsObjAll')[idStr] = fGeometry;
						features[j].getGeometry().setLineStrings(lineStrings);
						break;
					}
				}
			}
			BlockingUtil.readyGeo();
		}
		catch (ex) {
			BlockingUtil.readyGeo();
			App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
				filename: gis_filename_1,
				functionname: 'gis_filename_1_1'
			});
		}
	}

	function getLayerGeoFault(resultXml) {
		BlockingUtil.readyGeo();
		App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
			filename: gis_filename_1,
			functionname: 'gis_filename_1_2'
		});
	}

	App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams(that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
};



/**
 * запрос к данным
 * @params ids массив идентификаторов для тонкой загрузки геометрий только по этим объектам
 */
map.layer.VectorLayer.prototype.refreshData = function (ids) {
	var that = this;
	if (goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.spatial) && that.dataProvider.spatial != '') {
		this.isDataLoading_ = true;
		BlockingUtil.waitGeo();
		function getLayerGeoReqParams(filter, request) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
			var roughFiltersStr = LayerManager.getRoughFiltersString(WidgetMap.currentRoughFilter);
			var filterIds = '';
			if(ids && ids.length > 0){
				filterIds = ' and ID in ('+ids.join()+') ';
			}

			var filterStr = '8=8';
			return {
				descrId: request,
				descrType: 'select',
				topology: that.drawTypes.join(),
				data: '<root USER_ID="' + userId.xmlEscape() +
					'" USER_LOGIN="' + userLogin.xmlEscape() +
					'" PODS_USER="' + userLogin.xmlEscape() +
					'" ' + topFiltersStr + '' +
					'>' +
					'<data FILTER="' + filterStr + filterIds + '" />' +
					'</root>'
			};
		}

		function getLayerGeoResult(resultXml) {
			that.dataReady_ = true;
			that.isDataLoading_ = false;
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.readyGeo();
					if (that.iustMemoryCorruptCounter > 1)
						if (er.indexOf('memory is corrupt.') != -1 || er.indexOf('память повреждена.') != -1/* || er.indexOf('выгруженному объекту AppDomain.') !=-1*/) {
							--that.iustMemoryCorruptCounter;
							that.dataReady_ = false;
							that.isDataLoading_ = false;
							that.refreshData(ids);
							return;
						}
					if (that.geolocErrorCounter > 1)
						if (er.indexOf('Не найдено поле геоданных GEOLOC') != -1) {
							--that.geolocErrorCounter;
							that.dataReady_ = false;
							that.isDataLoading_ = false;
							that.refreshData(ids);
							return;
						}
					App.errorReport(gis_vectorlayer_1, er, undefined, {
						filename: gis_filename_1,
						functionname: 'refreshData__getLayerGeoResult'
					});
					return;
				}
				that.iustMemoryCorruptCounter = 0;
				that.internalServerErrorCounter = 0;
				that.geolocErrorCounter = 0;
				var layerGeoXml = ($.parseXML(resultXml)).firstChild;
				var datas = layerGeoXml.getElementsByTagName("data");
				var stride = 2;

				that.points_ = {};
				that.pointsLabels_ = {};
				that.lines_ = {};
				that.polygons_ = {};
				that.pointsData_ = {};
				that.linesData_ = {};
				that.polygonData_ = {};
				var i = 0;
				for (i; i < datas.length; i++) {
					//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
					var format = new ol.format.WKT({dimension: stride});
					var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
					var type = datas[i].getAttribute("TYPE");
					var label = datas[i].getAttribute("LABEL");
					var idStr = datas[i].getAttribute("ID");
					if (idStr == '' || idStr === null) {
						idStr = datas[i].getAttribute("id");
					}
					if (!goog.isNull(label)) {
						label = label.replace(/""/gm, '"');
						label = label.replace(/Ж(\d)/gm, 'Ø$1');
					}
					var fGeometry = undefined;
					if (goog.isNull(wktStr))
						continue;
					try {
						fGeometry = format.readGeometry(wktStr);
					}
					catch (ex) {
						//для случая с видеозаписями, приходит 3 координаты
						stride = 3;
						format = new map.format.WKT({dimension: stride});
						fGeometry = format.readGeometry(wktStr);
					}
					if (fGeometry.getType() == 'Point' && that.drawTypes.indexOf('point') != -1) {
						if ((fGeometry.flatCoordinates[0] < 0 || fGeometry.flatCoordinates[1] < 0) && that.projection !== 'EPSG:3395' && that.projection !== 'EPSG:5807')
							continue;
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.points_[that.name + ttype]))
							that.points_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsLabels_[that.name + ttype]))
							globalPointsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsGEOs_[that.name + ttype]))
							globalPointsGEOs_[that.name + ttype] = {};
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						that.points_[that.name + ttype].push(fGeometry.getFlatCoordinates());
						globalPointsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalPointsGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() == 'LineString' && that.drawTypes.indexOf('line') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.lines_[that.name + ttype]))
							that.lines_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesLabels_[that.name + ttype]))
							globalLinesLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesGEOs_[that.name + ttype]))
							globalLinesGEOs_[that.name + ttype] = {};
						that.lines_[that.name + ttype].push(fGeometry);
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalLinesLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalLinesGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() == 'Polygon' && that.drawTypes.indexOf('polygon') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.polygons_[that.name + ttype]))
							that.polygons_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsLabels_[that.name + ttype]))
							globalPolygonsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsGEOs_[that.name + ttype]))
							globalPolygonsGEOs_[that.name + ttype] = {};
						that.polygons_[that.name + ttype].push(fGeometry);
						globalPolygonsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalPolygonsGEOs_[that.name + ttype][idStr] = fGeometry;
					}

				}
				var pArr = [];
				var stName;
				var findedFeature = undefined; // если нашли фичу с таким типом
				var features = that.featureProjLayer.getSource().getSource().getFeatures();
				var geometry = undefined;
				for (stName in that.polygons_) {
					that.hasData = true;
					for (var ff in features) {
						var f = features[ff];
						var fG = f.getGeometry();
						if(f.get('labelType') === stName && fG.getType() === ol.geom.GeometryType.MULTI_LINE_STRING){
							findedFeature = f;
						}
					}
					findedFeature = undefined;
					if(findedFeature){
						geometry = findedFeature.getGeometry();
						if(geometry){
							var ls = geometry.getLineStrings();
							ls = ls.concat(that.lines_[stName]);
							geometry.setLineStrings(ls);
						}
					}
					else{
						geometry = new ol.geom.MultiPolygon(null);
						geometry.setPolygons(that.polygons_[stName]);
						var newPolygonFeature = new ol.Feature(geometry);
						newPolygonFeature.set('layerId', that.name);
						newPolygonFeature.set('spacing', that.spacing);
						newPolygonFeature.set('labelType', stName);
						newPolygonFeature.set('zIndex', that.zIndex);
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('labelsObjAll', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);//текущие, которые обрабатываются
						newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);//все объекты
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.setStyle(function (resolution) {
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'Polygon');
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('type'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'Polygon');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'Polygon');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							return null;
						});
						pArr.push(newPolygonFeature);
					}

					delete that.polygons_[stName];
					delete that.polygonData_[stName];
				}
				findedFeature = undefined;
				geometry = undefined;
				for (stName in that.lines_) {
					that.hasData = true;
					for (var ff in features) {
						var f = features[ff];
						var fG = f.getGeometry();
						if(f.get('labelType') === stName && fG.getType() === ol.geom.GeometryType.MULTI_LINE_STRING){
							findedFeature = f;
						}
					}
					if(findedFeature){
						geometry = findedFeature.getGeometry();
						if(geometry){
							var ls = geometry.getLineStrings();
							ls = ls.concat(that.lines_[stName] );
							geometry.setLineStrings(ls);
						}
					}
					else{
						var geometry = new ol.geom.MultiLineString(null);
						geometry.setLineStrings(that.lines_[stName]);

						var newLineFeature = new ol.Feature(geometry);
						newLineFeature.set('layerId', that.name);
						newLineFeature.set('spacing', that.spacing);
						newLineFeature.set('zIndex', that.zIndex);
						newLineFeature.set('labelType', stName);
						newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
						newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);//все объекты
						newLineFeature.set('type', stName.replace('/', '_'));
						newLineFeature.setStyle(function (resolution) {
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'LineString');
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), 'LineString');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'LineString');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), 'LineString');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'LineString');
							if (!goog.isNull(s && !goog.isNull(s.style))) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', 'LineString');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							return null;
						});
						pArr.push(newLineFeature);
					}
					delete that.lines_[stName];
					delete that.linesData_[stName];
				}
				findedFeature = undefined;
				geometry = undefined;
				for (stName in that.points_) {
					that.hasData = true;
					for (var ff in features) {
						var f = features[ff];
						var fG = f.getGeometry();
						if(f.get('labelType') === stName && fG.getType() === ol.geom.GeometryType.MULTI_POINT){
							findedFeature = f;
						}
					}
					if(findedFeature){
						geometry = findedFeature.getGeometry();
						if(geometry){
							var coords = geometry.getCoordinates();
							coords = coords.concat(that.points_[stName])
							geometry.setCoordinates(coords, ol.geom.GeometryLayout.XY);
						}
					}
					else{
						var geometry = new ol.geom.MultiPoint(null);
						geometry.setCoordinates(that.points_[stName], ol.geom.GeometryLayout.XY);
						var newPointFeature = new ol.Feature(geometry);
						newPointFeature.set('layerId', that.name);
						newPointFeature.set('spacing', that.spacing);
						newPointFeature.set('zIndex', that.zIndex);
						newPointFeature.set('labelType', stName);
						newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
						newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
						newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);//все объекты
						newPointFeature.set('labelsObjAll', globalPointsLabels_[stName]);
						newPointFeature.set('type', stName.replace('/', '_'));
						newPointFeature.setStyle(function (resolution) {
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'Point');
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), 'Point');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);

								}
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'Point');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), 'Point');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'Point');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', 'Point');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							return null;
						});
						pArr.push(newPointFeature);
					}
					delete that.pointsLabels_[stName];
					delete that.points_[stName];
					delete that.pointsData_[stName];
				}
				if (pArr.length > 0)
					that.featureProjLayer.getSource().getSource().addFeatures(pArr);
				delete pArr;
				BlockingUtil.readyGeo();
				that.fitMap_();
			}
			catch (ex) {
				if (goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(false);
				BlockingUtil.readyGeo();
				that.dataReady_ = true;
				that.isDataLoading_ = false;
				App.errorReport(gis_vectorlayer_1, ex, undefined, {
					filename: gis_filename_1,
					functionname: 'refreshData__getLayerGeoResult_1',
					datatext: gis_vectorlayer_5 + that.name + gis_vectorlayer_6 + resultXml
				});
			}
		}

		function getLayerGeoFault(resultXml) {
			if (that.internalServerErrorCounter > 1)
				if (resultXml.indexOf('Internal Server Error') != -1 || resultXml.indexOf('. error. ') != -1 || resultXml.indexOf('. Error. ') != -1 || resultXml.indexOf('. Error ') != -1) {
					--that.internalServerErrorCounter;
					that.dataReady_ = false;
					that.isDataLoading_ = false;
					that.requestData_();
					return;
				}
			that.internalServerErrorCounter = 0;
			that.dataReady_ = true;
			if (goog.isDef(that.layerLoadCallback))
				that.layerLoadCallback(false);
			BlockingUtil.readyGeo();
			that.isDataLoading_ = false;
			App.errorReport(gis_vectorlayer_1, resultXml, undefined, {
				filename: gis_filename_1,
				functionname: 'requestData__getLayerGeoFault'
			});
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;
		}
		
		//Получаем данные из кеша
		var layerDataCache = this.getDataFromCache();
		if (goog.isDefAndNotNull(layerDataCache)) {
			getLayerGeoResult(layerDataCache.result);
		}
		else
			App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams('', that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
	}
};

/**
 *
 * Процесс обновление данных по составному объекту для тех схемы
 * @param id
 * @param label
 */
map.layer.VectorLayer.prototype.updateComplexSemantic = function (id, label, wkt) {
	var ignoreWkt = false;
	var ignoreLabel = false;
	if(!this.semanticUniqData)this.semanticUniqData = {};
	//если данных нет, до вписываем сюда подпись линии, массив wkt-строк
	if(!this.semanticUniqData[id]){
		this.semanticUniqData[id] = {
			wkts: [wkt],
			label: label,
			flatCoordinates:[],
		}
	}
	else{
		var wkts = this.semanticUniqData[id].wkts;
		//если такая wkt уже есть - игнорируем
		if(wkts.indexOf(wkt) !== -1)
			ignoreWkt = true;
		else
			this.semanticUniqData[id].wkts.push(wkt);
	}
	return {ignoreWkt: ignoreWkt, ignoreLabel: ignoreLabel}
};
goog.require('ol.style.Text');
goog.require('ol.style.Stroke');

DEFAULT_STYLE_NAME = 'Default_STYLE.xml';

function LayerManager(opt_options) {
    var options = goog.isDef(opt_options) ? opt_options : {};
    //колбек на результат обработки файлов слоёв, стилей
    this.layersReadyCallback = goog.isDef(options.layersReadyCallback) ?
        options.layersReadyCallback : undefined;
    this._layers = [];//new ol.Collection(); of WKBLayer
    this._multiLayers = [];
    //очередь векторных слоёв
    this._layersQuery = 0;

    this._needCenteringLayers = [];//new ol.Collection(); of WKBLayer

    this._events = {};

    this._rasterLayersNames = [];//называния моделей, чтобы при загрузке xml не дублировались
    this._rasterLayers = [];//new ol.Collection(); of RasterLayerp

    //очередь растровых слоёв
    this._rasterLayersQuery = 0;
    //очередь стилей
    this._styleQuery = 0;
    //массив с уникальными именами, чтобы потом удобно было чистить общие стили и оставить векторные/быстрого кеша
    this._rasterUniqueStyleNames = [];

    this._pointStyles = {};
    this._lineStyles = {};
    this._textStyles = {};
    this._zoomStyles = {};// объект с массивом зумов для одинаковых стилей, но разных масштабов
    this._polygonStyles = {};
    this._unknownTopologyStyles = {};
    this._styles = {};  /* of String  */
    //TODO место для массива с order слоев
    //Специально введен объект, в который попадают все стили, у которых не удается определить топологию.
    this._orders = [];
    this._numOrders = [];
    //объект для хранения mapOrder растровых слоев
    this._rasterMapOrders = {};

    //Количество моделей слоев, которые парсились
    this._parsedModelsCount = 0;
    this._modelsLayers = {};
    //объект для хранения mapOrder векторных слоев
    this._vectorMapOrders = {};
    //Соответствия _source.name и lay.name (для получения MapLayer по FeatureLayer.name)
    this._sourceToLayNames = {};

    //очередь на подгрузку стилей после парсинга слоёв
    this.stylesQueue = [];

    this._descrs = {};
}

/**
 *
 * Установка описаний
 *
 * @param name
 */
LayerManager.prototype.setDescr = function(name,descr){
    if(goog.isDef(this._descrs[name]))
        return;
    this._descrs[name] = descr;
};

/**
 * Чистим все данные по растровым слоя,
 */
LayerManager.prototype.clearRasterDatas = function(){
    delete this._rasterMapOrders;
    this._rasterMapOrders = [];
    delete this._rasterLayers;
    this._rasterLayers = [];
    delete this._rasterLayersNames;
    this._rasterLayersNames = [];
};

LayerManager.prototype.clearLayer = function(layerName,isVector){
    if(isVector == true){
        var layObj = this.getLayerByName(layerName);
        if(goog.isDef(layObj) && goog.isDef(layObj.layer) && goog.isDef(layObj.layer.featureProjLayer)){
            layObj.layer.featureProjLayer.getSource().getSource().clear();
            layObj.layer.dataReady_ = false;
        }
    }
};

LayerManager.prototype.isTextAllowedByLayerName = function(layerName) {
    var that = this;
    var curLayer = undefined;
    var i;
    for ( i = 0; i < that._layers.length; i++) {
        curLayer = that._layers[i];
        if (curLayer.id == layerName)
            return curLayer.isTextAllow;
    }
    for (i = 0; i < that._rasterLayers.length; i++) {
        curLayer = that._rasterLayers[i];
        if (curLayer.id == layerName)
            return curLayer.isTextAllow;
    }
    return false;
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllLayers = function() {
    var arr = this.getVectorLayersByMode();
    return arr;
    return  this._layers;
};

LayerManager.prototype.getAllLayersWeak = function() {
    var arr = this.getVectorLayersByModeWeak();
    return arr;
    return  this._layers;
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };


    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });


    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    //return this._rasterLayers.concat(this._layers);
    var vectorArr = this.getVectorLayersByMode();
    var rasterArr =  this.getRasterLayersByMode();
    return rasterArr.concat(vectorArr);
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedRasterLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };
    //sort name ascending then id descending
    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    //return this._rasterLayers.concat(this._layers);
    var rasterArr =  this.getRasterLayersByMode();
    return rasterArr;
};
/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedByNameLayers1 = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapName, b.layer.mapName), cmp(a.layer.sourceDescr, b.layer.sourceDescr)],
            [cmp(b.layer.mapName, a.layer.mapName), cmp(b.layer.sourceDescr, a.layer.sourceDescr)]
        );
    });
    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapName, b.layer.mapName), cmp(a.layer.sourceDescr, b.layer.sourceDescr)],
            [cmp(b.layer.mapName, a.layer.mapName), cmp(b.layer.sourceDescr, a.layer.sourceDescr)]
        );
    });
    return  this._rasterLayers.concat(this._layers);
};
/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedByNameLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(a.layer.mapName+a.layer.sourceDescr, b.layer.mapName+b.layer.sourceDescr);
    });
    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(a.layer.mapName+a.layer.sourceDescr, b.layer.mapName+b.layer.sourceDescr);
    });
    //return  this._rasterLayers.concat(this._layers);

    var vectorArr = this.getVectorLayersByMode();
    var rasterArr = this.getRasterLayersByMode();
    return rasterArr.concat(vectorArr);
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedByNameLayers2 = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(a.layer.mapName+a.layer.sourceDescr, b.layer.mapName+b.layer.sourceDescr);
    });
    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(a.layer.mapName+a.layer.sourceDescr, b.layer.mapName+b.layer.sourceDescr);
    });
    //return  this._rasterLayers.concat(this._layers);

    var vectorArr = this.getVectorLayersByMode();
    var rasterArr = this.getRasterLayersByMode1();
    return rasterArr.concat(vectorArr);
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedVectorLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    //return this._layers;
    var arr = this.getVectorLayersByMode();
    return arr;
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedVectorLayersWOMode = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    return this._layers;
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedByNameVectorLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapName, b.layer.mapName), cmp(a.layer.sourceDescr, b.layer.sourceDescr)],
            [cmp(b.layer.mapName, a.layer.mapName), cmp(b.layer.sourceDescr, a.layer.sourceDescr)]
        );
    });
    var arr = this.getVectorLayersByMode();
    return arr;
    //return this._layers;
};


/**
 * Получаем все слои, видимые в текущем масштабе
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllVisibleInScaleRasterLayers = function() {
    var layers = [];
    var currLayer;
    var zoom;
    var currZoom = WidgetMap.map.getView().getZoom();
    for(var i in this._rasterLayers){
        currLayer = this._rasterLayers[i].layer;
        zoom = this.getZoomForLayer(currLayer.name);
        if(this._rasterLayers[i].visible){
            if(currZoom  >= zoom.zoomMin && currZoom <= zoom.zoomMax ){
                layers.push(this._rasterLayers[i]);
            }
        }
    }

    //return layers;
    var arr = this.getRasterLayersByMode(layers);
    return arr;
};

/**
 * Получаем все слои, видимые в текущем масштабе отсортированные по mapOrder и order
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllVisibleInScaleSortedRasterLayers = function(isAscending) {
    var layers = [];
    var currLayer;
    var zoom;
    var currZoom = WidgetMap.map.getView().getZoom();
    for(var i in this._rasterLayers){
        currLayer = this._rasterLayers[i].layer;
        /*if(currLayer.name === 'PODS_COMPRESSOR_STATION')
            console.log('s');*/
        zoom = this.getZoomForLayer(currLayer.name);
        if(this._rasterLayers[i].visible){
            if(currZoom  >= zoom.zoomMin && currZoom <= zoom.zoomMax ){
                layers.push(this._rasterLayers[i]);
            }
        }
    }
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    if(isAscending == false){
        //sort name ascending then id descending
        layers.sort(function(a, b){
            //note the minus before -cmp, for descending order
            return cmp(
                [cmp(a.layer.mapOrder, b.layer.mapOrder), -cmp(a.layer.order, b.layer.order)],
                [cmp(b.layer.mapOrder, a.layer.mapOrder), -cmp(b.layer.order, a.layer.order)]
            );
        });
    }
    else{
        //sort name ascending then id descending
        layers.sort(function(a, b){
            //note the minus before -cmp, for descending order
            return cmp(
                [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
                [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
            );
        });
    }
    //проверяем тип и cover у слоя, чтобы отбросиль лишние
    /*var newLayers = [];
    for(var j in layers){
        if(layers[j].layer.type != 'system' && layers[j].layer.showInfo != 'false'){
            newLayers.push(layers[j]);
        }
        if(layers[j].layer.cover == 'true'){
            return newLayers;
        }
    }*/
    //var arr = this.getRasterLayersByMode(layers);
    //return arr;
    return layers;
};

/**
 * Получаем все слои, которые рисуются кешем и сортируем
 */
LayerManager.prototype.getAllVisibleInScaleSortedVectorLayers = function() {
    var layers = [];
    var currLayer;
    var zoom;
    var vectorArr = this.getVectorLayersByMode();
    for(var i in vectorArr){
        currLayer = vectorArr[i].layer;
        zoom = this.getZoomForLayer(currLayer.name);
        if(vectorArr[i].visible && WidgetMap.map.getView().getZoom() >= zoom.zoomMin && WidgetMap.map.getView().getZoom() <= zoom.zoomMax )
            layers.push(vectorArr[i]);
    }
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    //проверяем тип и cover у слоя, чтобы отбросиль лишние
    var newLayers = [];
    for(var j in layers){
        if(layers[j].layer.type != 'system' && layers[j].layer.showInfo != 'false'){
            newLayers.push(layers[j]);
        }
        if(layers[j].layer.cover == 'true'){
            return newLayers;
        }
    }

    /*var layers1 = this.getRasterLayersByMode(layers);
    //проверяем тип и cover у слоя, чтобы отбросиль лишние
    var newLayers = [];
    for(var j in layers1){
        if(layers1[j].layer.type != 'system' && layers1[j].layer.showInfo != 'false'){
            newLayers.push(layers1[j]);
        }
        if(layers1[j].layer.cover == 'true'){
            return newLayers;
        }
    }*/

    return newLayers;
};


/**
 * Получаем список слоёв, которые используются для перецентровки
 * @returns {*}
 */
LayerManager.prototype.getNeedCenteringLayers = function() {
    return this._needCenteringLayers;
};

/**
 * Получаем растровые слои
 */
LayerManager.prototype.getRasterLayers = function() {
    //return this.getRasterLayersByMode();
    this._rasterLayers;
};

LayerManager.prototype.getRasterLayersByMode = function(layers) {
    var i = 0;
    return this._rasterLayers;
    if(goog.isDef(layers)){
        var arr = [];
        //если режим векторный, то удаляем из масси
        if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER){
            i = 0;
            for(;i<layers.length;i++){
                if(WidgetMap.MULTI_MODE_LAYERS.indexOf(layers[i].layerQueryId)==-1)
                    arr.push(layers[i]);
            }
            return arr;
        }
        return layers;
    }
    var arr = [];
    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER){
        i = 0;
        for(;i<this._rasterLayers.length;i++){
            if(WidgetMap.MULTI_MODE_LAYERS.indexOf(this._rasterLayers[i].layerQueryId)==-1)
                arr.push(this._rasterLayers[i]);
        }
        return arr;
    }
    return this._rasterLayers;

};

LayerManager.prototype.getRasterLayersByMode1 = function(layers) {
    var i = 0;
    if(goog.isDef(layers)){
        var arr = [];
        //если режим векторный, то удаляем из масси
        if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR){
            i = 0;
            for(;i<layers.length;i++){
                if(WidgetMap.MULTI_MODE_LAYERS.indexOf(layers[i].layerQueryId)==-1)
                    arr.push(layers[i]);
            }
            return arr;
        }
        return layers;
    }
    var arr = [];
    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR){
        i = 0;
        for(;i<this._rasterLayers.length;i++){
            if(WidgetMap.MULTI_MODE_LAYERS.indexOf(this._rasterLayers[i].layerQueryId)==-1)
                arr.push(this._rasterLayers[i]);
        }
        return arr;
    }
    return this._rasterLayers;

};

LayerManager.prototype.getVectorLayersByMode = function() {
    var arr = [];
    //если режим растровый, то из  _layers удаляем растровые слои типа pods_route
    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER){
        var i = 0;
        for(;i<this._layers.length;i++){
            if(WidgetMap.MULTI_MODE_LAYERS.indexOf(this._layers[i].layerQueryId)==-1)
                arr.push(this._layers[i]);
        }
        return arr;
    }
    return this._layers;
};

LayerManager.prototype.getVectorLayersByModeWeak = function() {
    var arr = [];
    var i = 0;
    //если режим растровый, то из  _layers удаляем растровые слои типа pods_route
    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER){
        for(;i<this._layers.length;i++){
            if(WidgetMap.MULTI_MODE_LAYERS.indexOf(this._layers[i].layerQueryId)==-1)
                arr.push(this._layers[i]);
        }
        return arr;
    }
    else{
        for(;i<this._layers.length;i++){
                arr.push(this._layers[i]);
        }
        return arr;
    }

    return this._layers;
};


LayerManager.prototype.getLayersByModel = function(modelName) {
    if (goog.isDef(this._modelsLayers[modelName]))
        return this._modelsLayers[modelName];
    return [];
};

/**
 * Полечение общего слоя по имени(в панели свойств для забора dataProvider при поиске информации)
 * @param layerName
 * @returns {undefined}
 */
LayerManager.prototype.getLayerObjByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var rasterArr = this.getRasterLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    for (i = 0; i < rasterArr.length; i++) {
        curLayer = rasterArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    return undefined;
};

LayerManager.prototype.getLayerByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var rasterArr = this.getRasterLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer;
    }
    for (i = 0; i < rasterArr.length; i++) {
        curLayer = rasterArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    return undefined;
};


LayerManager.prototype.getCasLayerStyleColorByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var vectorArr = this.getVectorLayersByMode();
    var resLayers = [];
    var color = '#000000'
    vectorArr.forEach(function(layer){
        if(layer.layer.uniqueLayerName == layerName){
            try{
                var style = layer.layer.featureProjLayer.getSource().getSource().getFeatures()[0].getStyle();
            }
            catch (e) {  }
        }
    });
};
LayerManager.prototype.getCasLayerByGroupId = function(groupId) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var resLayers = [];
    if(groupId){
        vectorArr.forEach(function(layer){
            if(layer.layer.groupId === groupId)
                resLayers.push(layer);
        });
    }
   return resLayers;
};

LayerManager.prototype.getCasLayerByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.id === layerName)
            return curLayer;
    }
    return undefined;
};

LayerManager.prototype.getCasGeoBoundsByName = function(groupId) {
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var min = Number.MAX_VALUE, max = Number.MIN_VALUE;
    if(groupId){
        vectorArr.forEach(function(layer){
            if(layer.layer.groupId === groupId){
                if(!isNaN(layer.layer.groupMaxGeoBounds) || !isNaN(layer.layer.groupMinGeoBounds)){
                    min = layer.layer.groupMinGeoBounds;
                    max = layer.layer.groupMaxGeoBounds;
                    return;
                }
                var fs = layer.layer.featureProjLayer.getSource().getSource().getFeatures();
                var minGeoBounds = Number.MAX_VALUE, maxGeoBounds = Number.MIN_VALUE;
                if ((layer.layer.layDiagType=='2D' || layer.layer.layDiagType == 'interval')
                    && !isNaN(layer.layer.dataYMin_) && !isNaN(layer.layer.dataYMax_)){
                    minGeoBounds = layer.layer.dataYMin_;
                    maxGeoBounds = layer.layer.dataYMax_;
                }
                else{ //иначе берем границы по данным
                    var i = 0;
                    for (; i < fs.length; i++){
                        var curFtr = fs[i];
                        var ext = curFtr.getGeometry().getExtent();
                        if (maxGeoBounds<ol.extent.getTopLeft(ext)[1]) maxGeoBounds = ol.extent.getTopLeft(ext)[1];
                        if (minGeoBounds>ol.extent.getBottomLeft(ext)[1]) minGeoBounds = ol.extent.getBottomLeft(ext)[1];
                    }
                }
                if(minGeoBounds < min) min = minGeoBounds;
                if(maxGeoBounds > max) max = maxGeoBounds;
            }
        });

        vectorArr.forEach(function(layer) {
            if (layer.layer.groupId === groupId) {
                layer.layer.groupMinGeoBounds = min;
                layer.layer.groupMaxGeoBounds = max;
            }
        });
    }

    return {min: min, max: max};
};

LayerManager.prototype.getLayerByName1 = function(layerName, baseLayers) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var vectorArr = [], rasterArr = [];
    var curLayer = undefined;
    if(baseLayers && baseLayers.length){
        vectorArr = baseLayers;
    }
    else{
        vectorArr = this.getVectorLayersByMode();
        rasterArr = this.getRasterLayersByMode();
    }
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer;
    }
    for (i = 0; i < rasterArr.length; i++) {
        curLayer = rasterArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    return undefined;
};

/**
 * Возвращает список косметических слоёв
 */
LayerManager.prototype.getCosmeticIds = function() {
    var ids = [];
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var vectorArr = this.getVectorLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        if (vectorArr[i].layerQueryId === 'COSMETIC_Layers.xml')
            ids.push(vectorArr[i].id);
    }
    return ids;
};

/**
 * Получение векторного/быстрого кеша слоя
 * @param layerName
 * @returns {undefined}
 */
LayerManager.prototype.getRasterLayerByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var rasterArr = this.getRasterLayersByMode();
    var i;
    for ( i = 0; i < rasterArr.length; i++) {
        curLayer = rasterArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    return undefined;
};

/**
 * Получение векторного/быстрого кеша слоя
 * @param layerName
 * @returns {undefined}
 */
LayerManager.prototype.getVectorLayerByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    if(WidgetMap && WidgetMap.baseLayers && WidgetMap.baseLayers.length){
        vectorArr = WidgetMap.baseLayers;
        for ( i = 0; i < vectorArr.length; i++) {
            curLayer = vectorArr[i];
            if (curLayer.id == layerName)
                return curLayer;
        }
    }
    return undefined;
};


LayerManager.prototype.getLayer = function(name) {
    if (name && name != ""){
        var vectorArr = this.getVectorLayersByMode();
        if (goog.isDef(vectorArr[name]))
            return vectorArr[name];
    }
    return null;
};

var LayerManagerRegisterCount = 0;
LayerManager.prototype.registerLayer = function(wkbLayer) {
    LayerManagerRegisterCount++;
    // получаем групповой слой ииз карты и добавляем туда новый
    if(goog.isDefAndNotNull(WidgetMap.currentVectorGroupLayer)){
        var source = new ol.source.Vector({
        });
        var imageVectorSource = new map.layer.ExtImageVector({
            source:source,
            id: wkbLayer.uniqueLayerName,
            ratio:1
        });
        var clusters = new ol.layer.Image({
            mapOrder: wkbLayer.mapOrder,
            order: wkbLayer.order,
            id: wkbLayer.uniqueLayerName,
            source: imageVectorSource,
            minResolution: wkbLayer.minResolution,
            maxResolution: wkbLayer.maxResolution
        });

        var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
        tLayers.push(clusters);
        WidgetMap.currentVectorGroupLayer.setLayers(tLayers);
        wkbLayer.featureProjLayer = clusters;
    }
};

LayerManager.prototype.getGeometryByLayerNameAndObjId = function(layer,layersIds){
    var newFeature = [];
    //добавляем мультифичи, чтобы туда заносить
    var multiPointGeometry = [];
    var multiLineGeometry = [];
    var multiPolygonGeometry = [];
    var hasSemanticField = layer.hasSemanticField;
    //проходимся по layersIds и добавляем геометрию
    var t;
    for(t in layersIds){
        var semId = layersIds[t];
        var features = layer.featureProjLayer.getSource().getSource().getFeatures();
        var found = false;
        var j;
        for (j in features) {
            var geo = -1;
            var points = features[j].get('pointsObjAll');
            if(!goog.isDef(points))
                break;
            if(hasSemanticField){//проверка, что идентификатор с semantic_id(ремонты кпг)
                for(var so in points){
                    if(so.indexOf('|') !== -1 && so.split('|')[1] === semId){  //1231|333
                        found = true;
                        var siblingGeo = points[so];
                        if(goog.isDef(siblingGeo)) {
                            switch (siblingGeo.getType()) {
                                case ol.geom.GeometryType.LINE_STRING:
                                    multiLineGeometry.push(siblingGeo);
                                    break;
                                case ol.geom.GeometryType.POLYGON:
                                    multiPolygonGeometry.push(siblingGeo);
                                    break;
                                case ol.geom.GeometryType.POINT:
                                    multiPointGeometry.push(siblingGeo.getCoordinates());
                                    break;
                            }
                        }
                    }
                }
            }
            else{
                geo = points[semId];
                if(goog.isDef(geo)){
                    found = true;
                    switch (geo.getType()) {
                        case ol.geom.GeometryType.LINE_STRING:
                            multiLineGeometry.push(geo);
                            break;
                        case ol.geom.GeometryType.POLYGON:
                            multiPolygonGeometry.push(geo);
                            break;
                        case ol.geom.GeometryType.POINT:
                            multiPointGeometry.push(geo.getCoordinates());
                            break;
                    }
                    //проверка на @ из gdal
                    for(var oo in points){
                        if (oo.indexOf(semId + "@") !== -1 && oo.indexOf(semId) === 0) {//проверяем, что нужный id, случай 5@1, 165@1
                            var siblingGeo = points[oo];
                            if(goog.isDef(siblingGeo)) {
                                switch (siblingGeo.getType()) {
                                    case ol.geom.GeometryType.LINE_STRING:
                                        multiLineGeometry.push(siblingGeo);
                                        break;
                                    case ol.geom.GeometryType.POLYGON:
                                        multiPolygonGeometry.push(siblingGeo);
                                        break;
                                    case ol.geom.GeometryType.POINT:
                                        multiPointGeometry.push(siblingGeo.getCoordinates());
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            if(found)
                break;
        }
    }
    var mpg;
    if(multiPointGeometry.length > 0){
        if(multiPointGeometry.length == 1)
            mpg = new ol.geom.Point(multiPointGeometry[0]);
        else
            mpg = new ol.geom.MultiPoint(multiPointGeometry);
        var ff = new ol.Feature(mpg);
        ff.setId('DEFAULT_SELECTED_'+App.generateUUID());
        WidgetMap.layerManager.defaultSelectionStyle(ff);
        newFeature.push(ff);
    }
    if(multiLineGeometry.length > 0){
        if(multiLineGeometry.length == 1)
            mpg = multiLineGeometry[0];
        else{
            mpg = new ol.geom.MultiLineString(null);
            mpg.setLineStrings(multiLineGeometry);
        }
        var ff = new ol.Feature(mpg);
        ff.setId('DEFAULT_SELECTED_'+App.generateUUID());
        WidgetMap.layerManager.defaultSelectionStyle(ff);
        newFeature.push(ff);
    }
    if(multiPolygonGeometry.length > 0){
        if(multiPolygonGeometry.length == 1) {
            //mpg = multiPolygonGeometry[0];
            // убрал такую установку,т.к. если выделить из грида объект,
            // то при нажатии кнопки редактирования возникает ошибка на clone с атрибутом ends(берется из всего мультиполигона)
            var geometry = new ol.geom.Polygon(null);
            var linearRing = new ol.geom.LinearRing(null);
            linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, multiPolygonGeometry[0].flatCoordinates);
            geometry.appendLinearRing(linearRing);
            mpg = geometry;
        }
        else{
            mpg = new ol.geom.MultiPolygon(null);
            for(var k in multiPolygonGeometry){
                var geometry = new ol.geom.Polygon(null);
                var linearRing = new ol.geom.LinearRing(null);
                linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY,multiPolygonGeometry[k].flatCoordinates);
                geometry.appendLinearRing(linearRing);
                mpg.appendPolygon(geometry);
            }
        }

        var ff = new ol.Feature(mpg);
        ff.setId('DEFAULT_SELECTED_'+App.generateUUID());
        WidgetMap.layerManager.defaultSelectionStyle(ff);
        newFeature.push(ff);
    }
    return newFeature;
};



LayerManager.prototype.setGeometryByLayerNameAndObjId = function(layer, semId, geometry){
    try{
        var features = layer.featureProjLayer.getSource().getSource().getFeatures();
        var j;
        for (j in features) {
            var geo = -1;
            var points = features[j].get('pointsObjAll');
            if(points === undefined)
                break;
            geo = points[semId];
            if(geo){
                geo.setCoordinates(geometry.getCoordinates());
                layer.featureProjLayer.changed();
                break;
            }
        }
    }
    catch(ex){

    }
};

LayerManager.prototype.multSelectedData = function(fs, scaleX, startYOffset, yCoeff, yOffset){
    var i = 0;
    var firstCoord = undefined;
    if(yCoeff === 1){
        yOffset = 0;
    }

    for(;i<fs.length;i++){
        var geometry = fs[i].getGeometry();
        if(goog.isDefAndNotNull(geometry)){
            var coords = geometry.flatCoordinates;
            var newCoords  = [];//of Array.<ol.Coordinate>
            var stride = geometry.stride;
            goog.asserts.assert(coords.length % stride === 0);
            var j;
            for ( j = 0; j < coords.length; j += stride) {
                newCoords.push(coords[j]*scaleX);
                //newCoords.push(coords[j+1]);
                newCoords.push((coords[j+1] + startYOffset) * yCoeff + yOffset);
                if(!firstCoord)
                    firstCoord = [newCoords[newCoords.length-2], newCoords[newCoords.length -1]];
            }
            if(geometry.getType() === ol.geom.GeometryType.POLYGON || geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
                geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
            else if(geometry.getType() === ol.geom.GeometryType.MULTI_POLYGON)
                geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
            else
                geometry.setFlatCoordinates(geometry.layout,newCoords);
        }
    }
    return firstCoord;//возвращаем 1-ю координату геометрии, чтобы по ней центроваться

};


LayerManager.prototype.parseRasterLayersDescr = function(layerName, mapOrder) {
    if(layerName === 'PODS_EQUIP_Layers.xml')//TODO помещаем слой труб в начало массива
        mapOrder = 0;
    var that = this;
    function getLayersReqParams(layerName) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: 'SYS_SEM.xml#GET_XML_FILE',
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data FILE="'+layerName+'"/>'+
            '</root>'
        };
    }


    function parseLayersDescrRequest(layerName){
        if(layerName.indexOf('_Layers')>0){
            that._rasterLayersQuery++;
        }
        if(layerName.indexOf("_STYLE") > 0){
            var layerDataCache = that.getDataFromCache(layerName);
            if (goog.isDefAndNotNull(layerDataCache))
                getLayersResult(layerDataCache.result, layerName);
            else
                App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);
        }
        else{
            if(that._rasterLayersNames.indexOf(layerName)==-1)
                that._rasterLayersNames.push(layerName);
            else
                return;
            App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);
        }


        function getLayersResult(resultXml) {
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                var er = HTTPServiceUtil.getError(resultXml);
                if(er !== ''){
                    App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_1'});
                    if(layerName.indexOf('_Layers')>0){
                        that._rasterLayersQuery--;
                    }
                    return;
                }
                var layersDescriptionXml = $.parseXML(resultXml);
                if (layerName.indexOf("_STYLE") > 0) {
                    layersDescriptionXml = layersDescriptionXml.firstChild;
                    that.saveResultToCache(layerName, resultXml);
                    that.parseStyle(layersDescriptionXml, layerName);
                }
                else{
                    layersDescriptionXml = $(layersDescriptionXml).find('root');
                    if(layersDescriptionXml.length > 0)
                        that.parseRasterLayers(layersDescriptionXml[0],layerName);
                    //that.parseRasterLayers(layersDescriptionXml,layerName);
                    var styleName = layerName.replace('_Layers','_STYLE');
                    //that.parseRasterLayersDescr(styleName);
                    if(layerName.indexOf('CADASTRE') == -1)
                        that.parseDefaultStyleDescr(styleName,undefined,true);
                }

            }
            catch(ex) {
                App.errorReport(gis_layermanager_2, ex, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_15'});// Распарсить XML не удалось, видимо это просто строка
            }
            if(layerName.indexOf('_Layers')>0){
                that._rasterLayersQuery--;
                if(that._rasterLayersQuery == 0){
                    if(goog.isDef(that.layersReadyCallback))
                        that.layersReadyCallback();
                }
            }
        }

        function getLayersFault(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== '')
                App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_2'});
            if(layerName.indexOf('_Layers')>0)
                that._rasterLayersQuery--;
        }
    }
    var isFileParsed = false;
    if(!isNaN(mapOrder) && goog.isDef(mapOrder)){
        var name = layerName.replace("_Layers.xml","");
        if(goog.isDef(this._rasterMapOrders[name])){
            isFileParsed = true;
        }
        this._rasterMapOrders[name] = mapOrder;
    }
    if(layerName != '' && !isFileParsed){
        parseLayersDescrRequest(layerName);
    }

};
/**
 * Парсим только дефолтные стили
 * @param layerName
 * @param mapOrder
 */
LayerManager.prototype.parseDefaultStyleDescr = function(layerName, mapOrder, isRasterStyle) {
    var that = this;
    that.isRasterStyle = isRasterStyle;
    function getLayersReqParams(layerName) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: "SYS_SEM.xml#GET_DEFAULT_STYLES_XML",
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
                '<data FILE="'+layerName+'"/>'+
                '</root>'
        };
    }


    function parseLayersDescrRequest(layerName){
        if(layerName.indexOf('_STYLE')>0){
            that._styleQuery++;
        }
        App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);
        var rasterStyle = that.isRasterStyle;
        function getLayersResult(resultXml) {
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                var er = HTTPServiceUtil.getError(resultXml);
                if(er !== ''){
                    App.errorReport(gis_layermanager_2, er);
                    if(layerName.indexOf('_STYLE')>0){
                        that._styleQuery--;
                    }
                    return;
                }
                var layersDescriptionXml = ($.parseXML(resultXml)).firstChild;
                that.parseStyle(layersDescriptionXml,layerName,rasterStyle);
            }
            catch(ex) {
                App.errorReport(gis_layermanager_2, ex);// Распарсить XML не удалось, видимо это просто строка
            }
            if(layerName.indexOf('_STYLE')>0){
                that._styleQuery--;
                if(that._styleQuery == 0){
                    if(goog.isDef(that.layersReadyCallback))
                        that.layersReadyCallback();
                }
            }
        }

        function getLayersFault(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== '')
                App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_9'});
            if(layerName.indexOf('_STYLE')>0){
                that._styleQuery--;
            }
            return;
        }
    }
    if(layerName !== ''){
        parseLayersDescrRequest(layerName);
    }
};


LayerManager.prototype.parseLayersDescr = function(layerName) {
    var that = this;
    if(!goog.isDef(layerName) || layerName == '')
        return;
    function getLayersReqParams(layerName) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: 'SYS_SEM.xml#GET_XML_FILE',
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
                '<data FILE="'+layerName+'"/>'+
                '</root>'
        };
    }


    function parseLayersDescrRequest(layerName){
        if(layerName.indexOf('_Layers')>0){
            that._layersQuery++;
        }
        if(layerName.indexOf("_STYLE") > 0){
            var layerDataCache = that.getDataFromCache(layerName);
            if (goog.isDefAndNotNull(layerDataCache))
                getLayersResult(layerDataCache.result, layerName);
            else
               App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);
        }
        else
            App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);



        function getLayersResult(resultXml) {
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                var er = HTTPServiceUtil.getError(resultXml);
                if (er !== '') {
                    App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_3'});
                    if (layerName.indexOf('_Layers') > 0) {
                        that._layersQuery--;
                    }
                    return;
                }
                //var layersDescriptionXml = ($.parseXML(resultXml)).firstChild;
                var layersDescriptionXml = $.parseXML(resultXml);

                if (layerName.indexOf("_STYLE") > 0) {
                    layersDescriptionXml = layersDescriptionXml.firstChild;
                    that.saveResultToCache(layerName, resultXml);
                    that.parseStyle(layersDescriptionXml, layerName);
                }
                else{
                    layersDescriptionXml = $(layersDescriptionXml).find('root');
                    if(layersDescriptionXml.length > 0)
                        that.parseLayers(layersDescriptionXml[0],layerName);
                    var styleName = layerName.replace('_Layers','_STYLE');
                    //если модель не ПКА, то грузим напрямую стили, иначе забираем их из файла *_layers
                    if(styleName.indexOf('CAS_')!=0)
                        that.parseLayersDescr(styleName);
                }

            }
            catch(ex) {
                App.errorReport(gis_layermanager_2, ex, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_4'});// Распарсить XML не удалось, видимо это просто строка
            }
            if(layerName.indexOf('_Layers')>0){
                that._layersQuery--;
                if(that._layersQuery == 0){
                    if(goog.isDef(that.layersReadyCallback))
                        that.layersReadyCallback();
                }
            }
        }

        function getLayersFault(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') 
                App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_7'});
            if (layerName.indexOf('_Layers') > 0) {
                that._layersQuery--;
            }
        }
    }
    parseLayersDescrRequest(layerName);
};

LayerManager.prototype.parseRasterLayers = function(value, layerName) {/** of XML */
    var that = this;
    var layers = value.getElementsByTagName("layer");
    for (var i = 0; i < layers.length; i++) {
        var curLayer = layers[i];
        var lId = curLayer.getAttribute('id');
        //если слой такой уже ранее парсился, то заново его не регистрируем
        if(goog.isDef(this.getRasterLayerByName(lId)))
            continue;
        var layerObj = {};
        layerObj.id = lId;
        var dataProviders = curLayer.getElementsByTagName("dataProvider");
        layerObj.dataProvider = {};
        layerObj.layerQueryId = layerName;
        layerObj.visible = ('true' == curLayer.getAttribute('visible'));
        //ФЛАГ ПОКАЗА ТЕКСТА
        layerObj.isTextAllow = true;
	    var modelName = layerName.replace('_Layers.xml','');
	    layerObj.modelName = modelName;

        for (var j = 0; j < dataProviders.length; j++) {
            var curDataProvider = dataProviders[j];
            var type = curDataProvider.hasAttribute('type') ? curDataProvider.getAttribute('type') : '';
            if(type == 'semantic')
                layerObj.dataProvider.semantic = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
            if(type == 'spatial')
                layerObj.dataProvider.spatial = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
        }
        var descr = layerName.replace("_Layers.xml","");
        var wkbLayer  = new map.layer.RasterLayer({
            name: curLayer.getAttribute('id'),
	        mapName: value.getAttribute('descr') !== null?value.getAttribute('descr'):layerName,
            layerSchema: curLayer.getAttribute('schema'),
            layerTable: curLayer.getAttribute('table'),
            sourceName: curLayer.getAttribute('id'),//value.getAttribute('name')
            sourceDescr: curLayer.getAttribute('descr'),
            layerNameSynonym: curLayer.getAttribute('synonym')?curLayer.getAttribute('synonym').split(','): [],
            dataType: curLayer.getAttribute('dataType'),
            labelField: curLayer.getAttribute('labelField'),
            classField: curLayer.getAttribute('classField'),
            cover: curLayer.getAttribute('cover'),
            type: curLayer.getAttribute('type'),
            canFirstTimeCentering:WidgetMap.canFirstTimeCentering,
            drawTypes:  (!goog.isNull(curLayer.getAttribute('topology')))?curLayer.getAttribute('topology').toLowerCase().split(','):['point'],
            showInfo: curLayer.getAttribute('showInfo'),
            order: parseFloat(curLayer.getAttribute('order')),
            mapOrder: that._rasterMapOrders[descr],
            fitMap: curLayer.getAttribute('fitMap') === 'true'
        });
        //данные по фильтру
        layerObj.filter = undefined;
        var filter = curLayer.getElementsByTagName("filter");
        if(goog.isDef(filter) && filter.length>0){
            if(filter[0].getElementsByTagName("pattern").length>0 && filter[0].getElementsByTagName("pattern")[0].textContent != ''){
                layerObj.filter = filter[0].getElementsByTagName("pattern")[0].textContent;
            }
        }
        else{
            if(layerObj.visible && wkbLayer.fitMap)
                this._needCenteringLayers.push(wkbLayer)
        }

        layerObj.layer = wkbLayer;
        //if(layerName === 'PODS_EQUIP_Layers.xml')
            that._rasterLayers.push(layerObj);

        //если выставлен флаг, то запрашиваем рамку
        if(wkbLayer.fitMap && wkbLayer.canFirstTimeCentering && !goog.isDef(layerObj.filter)){
            wkbLayer.canFirstTimeCentering = true;
            WidgetMap.canFirstTimeCentering = false;
            //если был выбран растровый режим, то не центрируемся, т.к. уже была центровка по вектору
            //кроме случая, если режим растровый пришел из настроек или из урл
            that.getQueryGeoMBR(layerObj);
        }
    }
};

LayerManager.prototype.parseLayers = function(value, layerName) {/** of XML */
    var that = this;
    var styleDataProviders = $(value).children('dataProvider');
    for (var k = 0; k < styleDataProviders.length; k++) {
        //проходимся по всем и выбираем только файлы стилей, а не запросы
        var curDataProvider = styleDataProviders[k];
        var type = $(curDataProvider).attr('type');
        var source = $(curDataProvider).attr('source');
        if(type == 'style' && goog.isDef(source) && source.indexOf('#') == -1 && this.stylesQueue.indexOf(source)==-1){
            this.stylesQueue.push(source);
        }
    }

    var layers = value.getElementsByTagName("layer");
    var i = 0;
    for (; i < layers.length; i++) {
        var curLayer = layers[i];
        var lId = curLayer.getAttribute('id');
        //если слой такой уже ранее парсился, то заново его не регистрируем
        if(goog.isDef(this.getVectorLayerByName(lId)))
            continue;
        var layerObj = {};
        layerObj.id = lId;
        var dataProviders = curLayer.getElementsByTagName("dataProvider");
        layerObj.dataProvider = {};
        layerObj.layerQueryId = layerName;
        //ФЛАГ ПОКАЗА ТЕКСТА
        layerObj.isTextAllow = true;
        layerObj.visible = ('true' == curLayer.getAttribute('visible'));
        //var filters = curLayer.getElementsByTagName("filters");

        for (var j = 0; j < dataProviders.length; j++) {
            var curDataProvider = dataProviders[j];
            var type = curDataProvider.hasAttribute('type') ? curDataProvider.getAttribute('type') : '';
            if(type == 'semantic')
                layerObj.dataProvider.semantic = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
            if(type == 'spatial')
                layerObj.dataProvider.spatial = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
            if(type == 'style')
                layerObj.dataProvider.style = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
            if(type == 'propertiesPanel')
                layerObj.dataProvider.propertiesPanel = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
        }


        var modelName = layerName.replace('_Layers.xml','');
	    layerObj.modelName = modelName;
        if (!goog.isDef(this._modelsLayers[modelName]))
            that._modelsLayers[modelName] = [];
        that._modelsLayers[modelName].push(layerObj);
        var zMax = parseFloat(curLayer.getAttribute('zoomMin'));
        zMax = that.getZoom(zMax);
        if(isNaN(zMax))zMax = Infinity;
        var zMin =  parseFloat(curLayer.getAttribute('zoomMax'));
        zMin = that.getZoom(zMin);
        if(isNaN(zMin))zMin = 0;

        var spacing =  curLayer.getAttribute('spacing');
        var ress = LayerManager.getResolutionForZoomMinMax(WidgetMap.map,zMin,zMax);
        //console.log(curLayer.getAttribute('id')+' zMin='+zMin+' zMax='+zMax+' ress='+ress[0]+'  '+ress[1]);
        var tempOrder = (!goog.isNull(curLayer.getAttribute('order')))?parseFloat(curLayer.getAttribute('order')):100;
        var wkbLayer;
        if(layerName.indexOf('CAS_')==0){
            wkbLayer = new map.layer.CASLayer({//временно продублировал атрибуты
                name: curLayer.getAttribute('id'),
                uniqueLayerName: curLayer.getAttribute('id'),
                mapName: value.getAttribute('descr') !== null?value.getAttribute('descr'):layerName,
                layerSchema: curLayer.getAttribute('schema'),
                layerTable: curLayer.getAttribute('table'),
                sourceName: curLayer.getAttribute('id'),
                sourceDescr: curLayer.getAttribute('descr'),
                layerNameSynonym: curLayer.getAttribute('synonym')?curLayer.getAttribute('synonym').split(','): [],
                dataType: curLayer.getAttribute('dataType'),
                labelField: curLayer.getAttribute('labelField'),
                classField: curLayer.getAttribute('classField'),
                cover: curLayer.getAttribute('cover'),
                type: curLayer.getAttribute('type'),
                showInfo: curLayer.getAttribute('showInfo'),
                canFirstTimeCentering:WidgetMap.canFirstTimeCentering,
                fitMap: curLayer.getAttribute('fitMap') == 'true',
                drawTypes: (!goog.isNull(curLayer.getAttribute('topology')))?curLayer.getAttribute('topology').toLowerCase().split(','):'point',
                minResolution:ress[1],
                maxResolution:ress[0],
                order: tempOrder,
                mapOrder: that._vectorMapOrders[modelName],
                zIndex: (that._vectorMapOrders[modelName]+1)*10000+parseFloat(tempOrder),
                maxLayerZoom:zMax,
                minLayerZoom:zMin,
                spacing: spacing,
                layerQueryId: layerName,
                dataProvider:layerObj.dataProvider,
                groupIndex: i,
                //filtersXml: filters//upd.02.09.20  новое, сюда перенесены справочники из гридов
            });
        }
        else
            wkbLayer = new map.layer.VectorLayer({
            name: curLayer.getAttribute('id'),
            uniqueLayerName: curLayer.getAttribute('id'),
	        mapName: value.getAttribute('descr') !== null?value.getAttribute('descr'):layerName,
            layerSchema: curLayer.getAttribute('schema'),
            layerTable: curLayer.getAttribute('table'),
            useServerCache: curLayer.getAttribute('useServerCache') == 'true',
            sourceName: curLayer.getAttribute('id'),
            sourceDescr: curLayer.getAttribute('descr'),
            layerNameSynonym: curLayer.getAttribute('synonym')?curLayer.getAttribute('synonym').split(','): [],
            dataType: curLayer.getAttribute('dataType'),
            labelField: curLayer.getAttribute('labelField'),
            classField: curLayer.getAttribute('classField'),
            projection: curLayer.getAttribute('projection'),
            cover: curLayer.getAttribute('cover'),
            type: curLayer.getAttribute('type'),
            showInfo: curLayer.getAttribute('showInfo'),
            canFirstTimeCentering:WidgetMap.canFirstTimeCentering,
            fitMap: curLayer.getAttribute('fitMap') == 'true',
            drawTypes: (!goog.isNull(curLayer.getAttribute('topology')))?curLayer.getAttribute('topology').split(','):['point'],
            minResolution:ress[1],
            maxResolution:ress[0],
            order: tempOrder,
            mapOrder: that._vectorMapOrders[modelName],
            zIndex: (that._vectorMapOrders[modelName]+1)*10000+parseFloat(tempOrder),
            maxLayerZoom:zMax,
            minLayerZoom:zMin,
            spacing: spacing,
            layerQueryId: layerName,
            dataProvider:layerObj.dataProvider
        });


        //данные по фильтру
        layerObj.filter = undefined;
        var filters = $(curLayer).find('filter');

        if(goog.isDef(filters) && filters.length>0){
            filters.each(function(){
                var pattern = $(this).find('pattern').text();
                if(pattern !== ''){
                    layerObj.filter = pattern;
                }
                if(filters.length > 1){
                    var field = $(this).find('field').text();
                    if(!layerObj.filters) layerObj.filters = {};
                    layerObj.filters[field] = pattern;
                }
            })
        }
        else{
            if(layerObj.visible && wkbLayer.fitMap)
                this._needCenteringLayers.push(wkbLayer);
        }
        //дублируем в слой фильтр, используется при биндинге в подгрузке данных при зуме
        wkbLayer.filter = layerObj.filter;
        wkbLayer.filters = layerObj.filters;
        layerObj.layer = wkbLayer;
        //регистрируем слой
        that.registerLayer(wkbLayer);
        that._layers.push(layerObj);
    }
};

LayerManager.prototype.parseStyle = function(valueRes, urlStr, isRasterStyle){/** of XML */
    var that = this;
    if(goog.isDefAndNotNull(valueRes)){
        var styles = valueRes.getElementsByTagName("Style");
        var i = 0;
        for (; i < styles.length; i++) {
            var curStyle = styles[i];
            if(!goog.isDef(that._styles[urlStr]))
                that._styles[urlStr] = urlStr;
            var sId = curStyle.getAttribute('id');
            if (sId == "")
                sId = curStyle.getAttribute('schema') + "_" + curStyle.getAttribute('table');
            if (sId == "_")
                sId = "DEFAULT";
            var value = curStyle.getElementsByTagName("value");//[0].textContent
            if (goog.isDefAndNotNull(value) && value.length>0 && value[0].textContent !== ""){
                sId += "_" + value[0].textContent;
            }

            var descr = curStyle.getAttribute('descr');
            var style = new ol.style.Style();
            //массив стилей, если линии с каймой или т.п.
            var styleArr = [];
            var textStyle = undefined;
            var currZoom = {};
            var styleObj = {};
            styleObj.name = sId;
            styleObj.layerId = curStyle.getAttribute('id');
            styleObj.descr= descr;
            styleObj.style = style;

            var stObj = {"point":null, "line":[], "poly": null, "polyOutline":'1', "label": undefined/*new ol.style.Text()*/,"zoom":{}};
            //Выбираем объект, который определяет тип текущего стиля. По-умолчанию не устанавливаем никакой.
            //Поскольку наличие дочернего IconStyle или PolyStyle однозначно определяет что стиль точечный или полигональный, то:
            //если мы один раз установили stType=_pointStyles, это значит что стиль считаем точечным и сохраняем в точечных (_pointStyles)
            //если мы один раз установили stType=_polygonStyles, это значит что стиль считаем площадным и сохраняем в площадных (_polygonStyles)
            //если ни первое ни второе условия не соблюдены и есть линейный стиль - сохраняем в линейных (_lineStyles)
            var stType = null;/* of Object */
//                var styleElements = curStyle.children;
            var styleElements = curStyle.childNodes;
            var curElement = undefined;
            var j = 0;
            for (; j < styleElements.length; j++) {
                if(styleElements[j].nodeName == '#text')
                    continue;
                curElement = styleElements[j];
                var name = curElement.nodeName;
                var str; /* of ol.style.Stroke */
                var alpha = 1;
                var col;// = 0x000000;
                var c;
                switch (name){
                    case "LineStyle":
                        var lineCap = "round";
                        var lineJoin = "round";
                        var lineDash = null;
                        var width = 0;
                        var colorEl = curElement.getElementsByTagName("color");
                        if(goog.isDefAndNotNull(colorEl) && colorEl.length>0)
                            c = colorEl[0].textContent;
                        var widthEl = curElement.getElementsByTagName("width");
                        if(goog.isDefAndNotNull(widthEl) && widthEl.length>0){
                            width = parseFloat(widthEl[0].textContent);
                            if(!goog.isNumber(width))
                                width = 0;
                        }

                        if(goog.isDefAndNotNull(curElement.getElementsByTagName("caps")) && curElement.getElementsByTagName("caps").length>0)
                            lineCap = curElement.getElementsByTagName("caps")[0].textContent;

                        if(goog.isDefAndNotNull(curElement.getElementsByTagName("join")) && curElement.getElementsByTagName("join").length>0)
                            lineJoin = curElement.getElementsByTagName("join")[0].textContent;

                        if(goog.isDefAndNotNull(curElement.getElementsByTagName("dasharray")) && curElement.getElementsByTagName("dasharray").length>0)
                            lineDash = curElement.getElementsByTagName("dasharray")[0].textContent.split(' ');

                        if (c && c != ""){
                            //прозрачность неправильно обрабатывается
                            //alpha = parseFloat('0x0000' + c.substr(0,2))/255;
                            alpha = parseInt((parseInt('0x0000' + c.substr(0,2),16)/255)*100)/100;
                            //col = '#'+c.substr(2,6); //parseFloat('0x'+c.substr(2,6));
                            col = 'rgba('+parseInt(c.substr(2,2),16)+', '+parseInt(c.substr(4,2),16)+', '+parseInt(c.substr(6,2),16)+', '+alpha+')';
                            var str = new ol.style.Stroke({color: col,
                                    lineCap: lineCap,
                                    lineJoin: lineJoin,
                                    lineDash: lineDash,
                                    width: width});
                            stObj.line.push(str);
                            if(stObj.line.length>1)
                                stObj.lineObjBorder = {color:c,size:width};
                            else
                                stObj.lineObj = {color:c,size:width};
                            //Сохранять стиль будем в _lineStyles только если нет ни PolyStyle, ни IconStyle
                            if (!stType)
                                stType = that._lineStyles;
                        }
                        break;
                    case "LabelStyle":
                        var text = {};//пока использую не ol.style.Text, т.к нигде текстовые подписи не использую
                        //stType = that._textStyles;
                        /* <LabelStyle>
                         <zoomMin>0</zoomMin>
                         <zoomMax>1500</zoomMax>
                         <color>FFFF0000</color>
                         <fontFamily>Arial Cyr</fontFamily>
                         <fontSize>12</fontSize>
                         <duplicate>1</duplicate>
                         <overlap>0</overlap>
                         <bold>0</bold>
                         <italic>0</italic>
                         <underline>0</underline>
                         <auto>0</auto>
                         <scale>1</scale>
                         </LabelStyle> */
                        var overlapEl = curElement.getElementsByTagName("overlap");
                        if(goog.isDefAndNotNull(overlapEl) && overlapEl.length>0)
                            text.overlap = overlapEl[0].textContent;
                        var autoEl = curElement.getElementsByTagName("auto");
                        if(goog.isDefAndNotNull(autoEl) && autoEl.length>0)
                            text.auto = autoEl[0].textContent;
                        var duplicateEl = curElement.getElementsByTagName("duplicate");
                        if(goog.isDefAndNotNull(duplicateEl) && duplicateEl.length>0)
                            text.duplicate = duplicateEl[0].textContent;
                        var colorElement = curElement.getElementsByTagName("color");
                        if(goog.isDefAndNotNull(colorElement) && colorElement.length>0)
                            text.color =  colorElement[0].textContent;
	                    var alignElement = curElement.getElementsByTagName("align");
                        if(goog.isDefAndNotNull(alignElement) && alignElement.length>0)
                            text.align = alignElement[0].textContent;
	                    else
	                        text.align = 'right|top';
                        var fontFamilyEl = curElement.getElementsByTagName("fontFamily");
                        if(goog.isDefAndNotNull(fontFamilyEl) && fontFamilyEl.length>0)
                            text.fontFamily = fontFamilyEl[0].textContent;
                        var fontSizeEl = curElement.getElementsByTagName("fontSize");
                        if(goog.isDefAndNotNull(fontSizeEl) && fontSizeEl.length>0)
                            text.fontSize = fontSizeEl[0].textContent;
                        var scaleEl = curElement.getElementsByTagName("scale");
                        if(goog.isDefAndNotNull(scaleEl) && scaleEl.length>0){
                            var scale = scaleEl[0].textContent;
                            if(scale === '1')
                                text.fontSize = '-3';//флаг, для тех схемы - схемы ВТД, чтобы подписи масштабировались по длине подписи
                        }
                        var boldEl = curElement.getElementsByTagName("bold");
                        if(goog.isDefAndNotNull(boldEl) && boldEl.length>0)
                            text.bold = boldEl[0].textContent;
                        var italicEl = curElement.getElementsByTagName("italic");
                        if(goog.isDefAndNotNull(italicEl) && italicEl.length>0)
                            text.italic = italicEl[0].textContent;
                        var underlineEl = curElement.getElementsByTagName("underline");
                        if(goog.isDefAndNotNull(underlineEl) && underlineEl.length>0)
                            text.underline = underlineEl[0].textContent;
                        var textZoomMax = NaN;
                        var zoomMaxEl = curElement.getElementsByTagName("zoomMin");
                        var zoomMinEl = curElement.getElementsByTagName("zoomMax");
                        if(goog.isDefAndNotNull(zoomMaxEl) && zoomMaxEl.length>0)
                            textZoomMax = parseFloat(zoomMaxEl[0].textContent);
                        textZoomMax = that.getZoom(textZoomMax);
                        if(!isNaN(textZoomMax))
                            text.zoomMax = textZoomMax;
                        else
                            text.zoomMax = Number.POSITIVE_INFINITY;
                        var textZoomMin = NaN;
                        if(goog.isDefAndNotNull(zoomMinEl) && zoomMinEl.length>0)
                            textZoomMin = parseFloat(zoomMinEl[0].textContent);
                        textZoomMin = that.getZoom(textZoomMin);
                        if(!isNaN(textZoomMin))
                            text.zoomMin = that.getZoom(textZoomMin);
                        else
                            text.zoomMin = 0;
                        text.isTextObject = false;
                        var isTextObjectEl = curElement.getElementsByTagName("italic");
                        if(goog.isDefAndNotNull(isTextObjectEl) && isTextObjectEl.length>0)
                            text.isTextObject = isTextObjectEl[0].textContent === '1';
                        stObj.label = text;
                        if(goog.isDef(text.auto) && (text.auto == '0') || text.auto == 0)
	                        stObj.label = 'none';

                        break;
                    case "PolyStyle":
                        //Сохраняем стиль в _polygonStyles, т.к. PolyStyle встречается только на площадных стилях (даже если уже установлен в _lineStyles)
                        stType = that._polygonStyles;
                        var colorEl = curElement.getElementsByTagName("color");
                        if(goog.isDefAndNotNull(colorEl) && colorEl.length>0)
                            c = colorEl[0].textContent;
                        var fill = curElement.getElementsByTagName("fill");
                        if(goog.isDefAndNotNull(fill) && fill.length>0)
                            fill = fill[0].textContent;
                        var outline = curElement.getElementsByTagName("outline");
                        if(goog.isDefAndNotNull(outline) && outline.length>0)
                            outline = outline[0].textContent;
                        stObj.polyOutline = outline;
                        stObj.polyObj = {};
                        //флаг заливки контура
                        if(fill == '1'){
                            alpha = parseInt((parseInt('0x0000' + c.substr(0,2),16)/255)*100)/100;
                            if(c.length == 8){
                                col = 'rgba('+parseInt(c.substr(2,2),16)+', '+parseInt(c.substr(4,2),16)+', '+parseInt(c.substr(6,2),16)+', '+alpha+')';
                                stObj.poly = new ol.style.Fill({
                                    color: col//'rgba( 255,255,255,0.12)' //col
                                });
                            }
                            stObj.polyObj.color = c;
                        }
                        stObj.polyObj.fill = fill == '1';
                        stObj.polyObj.outline = outline == '1';//отрисовка каймы
                        break;
                    case "IconStyle":
                        var iconEl = curElement.getElementsByTagName("Icon");
                        if(!goog.isDefAndNotNull(iconEl[0])
                            || !goog.isDefAndNotNull(iconEl[0].getElementsByTagName("form"))
                            || !goog.isDef(iconEl[0].getElementsByTagName("form")[0]))
                            break;
                        var outline = curElement.getElementsByTagName("outline");
                        if(goog.isDefAndNotNull(outline) && outline.length>0)
                            outline = outline[0].textContent;

                        var form = iconEl[0].getElementsByTagName("form")[0].textContent;

                        //Сохраняем стиль в _pointStyles, т.к. IconStyle встречается только на точечных стилях (даже если уже установлен в _lineStyles)
                        stType = that._pointStyles;
                        var mark; /* of ol.style.Circle */
                        //var rotation = parseDecimalDegrees(Number(t.rotation));
                        var size = parseFloat(iconEl[0].getElementsByTagName("size")[0].textContent);
                        stObj.pointObj = {form:form,size:size};
                        switch (form){
                            case "bitmap":
                                mark = new ol.style.Icon({
                                    src: iconEl[0].getElementsByTagName("href")[0].textContent,
                                    size: [size,size]
                                });
                                stObj.pointObj.href = iconEl[0].getElementsByTagName("href")[0].textContent;
                                break;
                            default :
                                if(goog.isDefAndNotNull(curElement.getElementsByTagName("color")[0])){
                                    c = curElement.getElementsByTagName("color")[0].textContent;
                                    //col = '#'+c.substr(2,6);
                                    col = 'rgba('+parseInt(c.substr(2,2),16)+', '+parseInt(c.substr(4,2),16)+', '+parseInt(c.substr(6,2),16)+', '+alpha+')';
                                }
                                if(form == 'square'){
                                    mark = {form:form,radius: size/2+2,
                                        fill:  new ol.style.Fill({
                                            color: col
                                        }),stroke: new ol.style.Stroke({
                                            color: '#ffffff',
                                            width: 1
                                        })
                                    };
                                }else{
                                    mark = {form:form,radius: size+1,
                                        fill:  new ol.style.Fill({
                                        color: col
                                        }),
                                        stroke: new ol.style.Stroke({
                                            color: '#ffffff',
                                            width: 1
                                        })
                                    };
                                }
                                break;

                        }
                        stObj.point = mark;
                        stObj.pointObj.color = c;
                        stObj.pointObj.outline = outline == '1';//отрисовка каймы
                        break;
                    case "zoomMin":
                        var zoomMax = NaN;
                        if(goog.isDefAndNotNull(curElement.textContent) && curElement.textContent.length>0)
                            zoomMax = parseFloat(curElement.textContent);
                        zoomMax = that.getZoom(zoomMax);
                        if(!isNaN(zoomMax))
                            stObj.zoom.zoomMax = zoomMax;
                        else
                            stObj.zoom.zoomMax = Number.POSITIVE_INFINITY;
                        break;
                    case "zoomMax":
                        var zoomMin = NaN;
                        if(goog.isDefAndNotNull(curElement.textContent) && curElement.textContent.length>0)
                            zoomMin = parseFloat(curElement.textContent);
                        zoomMin = that.getZoom(zoomMin);
                        if(!isNaN(zoomMin))
                            stObj.zoom.zoomMin = that.getZoom(zoomMin);
                        else
                            stObj.zoom.zoomMin = 0;
                        break;
                    default: break;
                }
            }
            var currType = 'point';
            if (stType == that._lineStyles) {
                if (stObj.line.length > 1) {
                    // делаем остальные стили
                    var l = stObj.line.length;

                    for (var tt = l - 1; tt > 0; tt--) {
                        styleArr.push(new ol.style.Style({
                            stroke: stObj.line[tt]
                        }));
                    }
                }
                if(styleArr.length > 0){
                    styleArr.push(new ol.style.Style({
                        stroke:stObj.line[0]
                    }))
                }
                else
                    style = new ol.style.Style({
                        stroke:stObj.line[0]
                    });
	            currType = 'line';
            }
            else if (stType == that._polygonStyles){
	            //TODO 21.01.18 при обсуждении принято решение оставить для полигонов окантовку из одной линии, т.к.
	            // в полигоны с дырками в этом случае не заливались
	            if (stObj.line.length > 1) {
                    // делаем остальные стили
                    var l = stObj.line.length;
                    for (var tt = l - 1; tt > 0; tt--) {
                        styleArr.push(new ol.style.Style({
                            stroke: stObj.line[tt],
                            fill: stObj.poly
                        }));
                    }
                }
                else{
                    style = new ol.style.Style({
                        stroke: stObj.line[0],
                        fill: stObj.poly
                    });
                }
                if(styleArr.length > 0){
                    styleArr.push(new ol.style.Style({
                        stroke:stObj.line[0],
                        fill: stObj.poly
                    }))
                }
	            currType = 'polygon';
            }
            else {//если stType == _pointStyles или не был указан, считаем точечным
                var strk  = new ol.style.Stroke({
                    color: '#ffffff',
                    width: 1
                });
                if (stObj.line.length > 0){
                    if (stObj.point){
                        strk = stObj.line[0];//stObj.point.stroke_ = stObj.line[0];
                    }
                }
                var imgg = null;
                try{
                    if(stObj.point.form === undefined){
                        imgg = stObj.point;
                    }
                    else{
                        if(stObj.point.form == 'square'){
                            imgg = new ol.style.RegularShape({
                                angle: Math.PI / 4,
                                points: 4,
                                radius: stObj.point.radius,
                                fill:  stObj.point.fill,
                                stroke: strk
                            });
                        }
                        else{
                            imgg = new ol.style.Circle({
                                radius: stObj.point.radius,
                                fill: stObj.point.fill,
                                stroke: strk
                            });
                        }
                    }

                    style = new ol.style.Style({
                        stroke: null,
                        image: imgg
                    });
                }
                catch(e){
                }
            }

            if (stObj.label !== 'none'){
                if(goog.isDef(stObj.label)){
                    if(currType == 'polygon'){
                        textStyle = stObj.label;
                        stObj.labelObj = textStyle;
                    }
                    else{
                        textStyle = stObj.label;
                        stObj.labelObj = textStyle;
                    }

                }
                else{//дефолтный для точечного Arial,10px
                    /*if(styleObj.name.indexOf('POI_TRACK') !== -1 )
                        console.log('d')*/
                    /*var style = that.getTextStyle('DEFAULT');
                    if(style){
                        textStyle = {
                            color: style.color,
                            fontSize: style.fontSize,
                            bold: style.bold,
                            align: style.align,
                            overlap: style.overlap,
                            fontFamily: 'Arial',
                            zoomMax: style.zoomMax,
                            zoomMin: style.zoomMin
                        };
                    }
                    else
                        textStyle = {};*/
                    var colorText = 'ff000000';
                    if(currType == 'polygon'){
                        colorText = 'ff000000';
                    }
                    textStyle = {color:colorText,fontSize:'10',bold:'0',align:'right|top',overlap:'0',fontFamily:'Arial',zoomMax:Number.POSITIVE_INFINITY, zoomMin:0, isTextObject: false};
                    stObj.labelObj = textStyle;
                }
	            textStyle.type = currType;
            }
            else{
                //размер -2, т.к. -1 это размер шрифта для тех.схемы, который должен отрисовываться
                textStyle = {};
	            stObj.labelObj = textStyle;
            }
            //в рамках #2503 Стиль подписи по умолчанию необходимо вынести в default_style. Если стиль по умолчанию не задан - подпись не выводить.


            if (goog.isDef(stObj.zoom.zoomMin) && goog.isDef(stObj.zoom.zoomMax)){
                currZoom = stObj.zoom;
            }
            else{//если зумы не определены, то ставим их в мин/макс
                stObj.zoom.zoomMin = 0;
                stObj.zoom.zoomMax = Number.POSITIVE_INFINITY;
                currZoom = stObj.zoom;
            }

            if(goog.isDefAndNotNull(stType)) {
                if(!goog.isDef(stType[urlStr + "#" + styleObj.name])){
                    stType[urlStr + "#" + styleObj.name] = [];
                    if(isRasterStyle == true)
                        this._rasterUniqueStyleNames.push(urlStr + "#" + styleObj.name);
                }
                stType[urlStr + "#" + styleObj.name] = [];
                if(styleArr.length > 0){
                    stType[urlStr + "#" + styleObj.name].push({
                        layerId: styleObj.layerId,
                        sId: styleObj.name,
                        descr: (styleObj.descr)?styleObj.descr:gis_layermanager_6,
                        style: styleArr,
                        zoom: currZoom,
                        text: textStyle,
                        textOverlap: textStyle.overlap,
                        pointObj: stObj.pointObj,
                        lineObj: stObj.lineObj,
                        lineBorderObj: stObj.lineBorderObj,
                        polyObj: stObj.polyObj,
                        labelObj: stObj.labelObj
                    });
                }
                else{
                    stType[urlStr + "#" + styleObj.name].push({
                        layerId: styleObj.layerId,
                        sId: styleObj.name,
                        descr: (styleObj.descr)?styleObj.descr:gis_layermanager_6,
                        style: style,
                        zoom: currZoom,
                        text: textStyle,
                        textOverlap: textStyle.overlap,
                        pointObj: stObj.pointObj,
                        lineObj: stObj.lineObj,
                        lineBorderObj: stObj.lineBorderObj,
                        polyObj: stObj.polyObj,
                        labelObj: stObj.labelObj
                    });
                }
            }
            if(goog.isDef(textStyle))
                that._textStyles[urlStr+"#"+styleObj.name] = textStyle;
            if(goog.isDef(currZoom)){
                that._zoomStyles[urlStr+"#"+styleObj.name] = currZoom;
            }
            //обновляем стили в слое, если данные к нему уже подгружены
            var lay = this.getLayerByName(styleObj.name);
            if(goog.isDef(lay) && goog.isDef(lay.layer) && lay.layer.dataReady_ == true)
                lay.layer.featureProjLayer.getSource().changed();
        }
    }
    //пробуем обновить иконки для контрола с векторными слоями
    try{
        WidgetMap.baseLayersControl.updateVectorIcons(urlStr);
    }
    catch(e){}
};

/**
 * Получение соответствующего зума для карты
 * @param dist в метрах или номерах масштабов
 */
LayerManager.prototype.getZoom = function(dist) {
    try {
        if (goog.isNumber(dist) &&  !isNaN(dist)){
            if (dist <= 0)
                return NaN;
            if (dist <= 50)//передан номер масштаба, а не метры
                return dist;
            var extent = [0, 1, dist, 0]; // 1 для примера, равняемся по ширине
            return WidgetMap.getZoomForExtent(extent);
        }
    }
    catch(ex){
    }
    return NaN;
};


//устанавливаем слою дефолтный стиль
LayerManager.prototype.defaultSelectionStyle = function(feature, featureStyleName) {
    var that = this;
    var styleName = (goog.isDef(featureStyleName))?featureStyleName:"DEFAULT_SELECTED";
    var style;
    //устанавливаем id, чтобы нормально потом искать стиль. Возможно, потом придется по-другому сделать
    if(!goog.isDef(feature.getId()))
        feature.setId(styleName);
    if(goog.isDefAndNotNull(feature.getGeometry())){
        var type = feature.getGeometry().getType();
        switch(type){
            case ol.geom.GeometryType.POINT:
            case ol.geom.GeometryType.MULTI_POINT:
                style = this.getPointStyle(styleName);
                if(!goog.isNull(style))
                    feature.setStyle(style);
                else
                    feature.setStyle(this.getDefaultPointStyle());
                break;
            case ol.geom.GeometryType.LINE_STRING:
            case ol.geom.GeometryType.MULTI_LINE_STRING:
                style = this.getLineStyle(styleName);
                /*feature.setStyle(this.getDefaultLineStyle());
                break;*/
                if(!goog.isNull(style)){
                    var st = function(resolution) {
                        var styles = null;
                        var idd = this.getId();
                        if(goog.isDef(idd)){
                            var lName = idd.split(':')[0];
                            if(lName.indexOf('DEFAULT_SELECTED')!=-1)
                                lName = 'DEFAULT_SELECTED';
                            styles = that.getLineStyle(lName.replace('/','_'));/*this = ol.Feature*/
                        }
                        return styles;
                    };
                    feature.setStyle(st);
                    //feature.setStyle(style);
                }

                else
                    feature.setStyle(this.getDefaultLineStyle());
                break;
            case ol.geom.GeometryType.POLYGON:
            case ol.geom.GeometryType.MULTI_POLYGON:
                style = this.getPolygonStyle(styleName);
                if(!goog.isNull(style))
                    feature.setStyle(style);
                else
                    feature.setStyle(this.getDefaultPolygonStyle());
                break;
            default: break;
        }
    }
};

//устанавливаем слою дефолтный стиль
LayerManager.prototype.setDefaultSelectionStyle = function(feature, featureStyleName) {
    var that = this;
    var styleName = (goog.isDef(featureStyleName))?featureStyleName:"DEFAULT_SELECTED";
    var style;
    //устанавливаем id, чтобы нормально потом искать стиль. Возможно, потом придется по-другому сделать
    if(goog.isDefAndNotNull(feature.getGeometry())){
        var type = feature.getGeometry().getType();
        switch(type){
            case ol.geom.GeometryType.POINT:
            case ol.geom.GeometryType.MULTI_POINT:
                style = this.getPointStyle(styleName);
                if(!goog.isNull(style))
                    feature.setStyle(style);
                else
                    feature.setStyle(this.getDefaultPointStyle());
                break;
            case ol.geom.GeometryType.LINE_STRING:
            case ol.geom.GeometryType.MULTI_LINE_STRING:
                style = this.getLineStyle(styleName);
                if(!goog.isNull(style)){
                    feature.setStyle(style);
                }
                else
                    feature.setStyle(this.getDefaultLineStyle());
                break;
            case ol.geom.GeometryType.POLYGON:
            case ol.geom.GeometryType.MULTI_POLYGON:
                style = this.getPolygonStyle(styleName);
                if(!goog.isNull(style))
                    feature.setStyle(style);
                else
                    feature.setStyle(this.getDefaultPolygonStyle());
                break;
            default: break;
        }
    }
};


//получить текстовый стиль у слоя
LayerManager.prototype.getTextStyle = function(name) {
    for(var sty in this._styles){
        if (goog.isDef(this._textStyles[sty+"#"+name])){
            return this._textStyles[sty+"#"+name];
        }
    }
    if (goog.isDef(this._textStyles[name])){
        return this._textStyles[name];
    }

    return null;
};

//получить текстовый стиль у слоя
LayerManager.prototype.getTextStyleWithLabel = function(name,text) {
    if(!goog.isDefAndNotNull(text))
        return null;
    for(var sty in this._styles){
        if (goog.isDef(this._textStyles[sty+"#"+name])){
            return this._textStyles[sty+"#"+name];
        }
    }
    if (goog.isDef(this._textStyles[name])){
        return this._textStyles[name];
    }

    return null;
};

//получить текстовый стиль у слоя
LayerManager.prototype.getZoomForLayer = function(name) {
    for(var sty in this._styles){
        if (goog.isDef(this._zoomStyles[sty+"#"+name])){
            return this._zoomStyles[sty+"#"+name];
        }
    }
    if (goog.isDef(this._zoomStyles[name])){
        return this._zoomStyles[name];
    }

    return {zoomMin:0, zoomMax:Number.POSITIVE_INFINITY};
};

/**
 * Получение стиля по типу геометрии, который попадает в зум карты
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getStyleByNameAndType = function(name,type) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
        if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
        if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (type == 'Point' && goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};

/**
 * Получение стиля по типу геометрии без учитывания зума карты
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getStyleByNameAndTypeWOZoom = function(name,type) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    for(var sty in this._styles){
        if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
        if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
        if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
    }
    if (type == 'Point' && goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            return currStyles[i];
        }
    }
    if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            return currStyles[i];
        }
    }
    if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            return currStyles[i];
        }
    }
    return null;
}

/**
 * Получение оригинального стиля точки для использования на ПКА при совмещении графиков
 * @param names массив названий стилей
 * @param type
 * @returns {null|*}
 */
LayerManager.prototype.getOrigPointStyleByNameAndType = function(names) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map) || !names)
        return null;
    for(var n = 0; n < names.length; n++){
        var name = names[n];
        for(var sty in this._styles){
            if (goog.isDef(this._pointStyles[sty+"#"+name])){
                //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
                currStyles = this._pointStyles[sty+"#"+name];
                for(var i in currStyles){
                    return currStyles[i];
                }
            }
        }
        if (goog.isDef(this._pointStyles[name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
    }
    return null;
};

LayerManager.prototype.getOrigStyleByNameAndType = function(names, type ) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map) || !names)
        return null;
    for(var n = 0; n < names.length; n++){
        var name = names[n];
        for(var sty in this._styles){
            if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
                //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
                currStyles = this._pointStyles[sty+"#"+name];
                for(var i in currStyles){
                    return currStyles[i];
                }
            }
            if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
                //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
                currStyles = this._lineStyles[sty+"#"+name];
                for(var i in currStyles){
                    return currStyles[i];
                }
            }
            if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
                //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
                currStyles = this._polygonStyles[sty+"#"+name];
                for(var i in currStyles){
                    return currStyles[i];
                }
            }
        }
        if (type == 'Point' && goog.isDef(this._pointStyles[name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
        if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
        if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
    }
    return null;
};

/**
 * Получение стиля по типу фичи ex. ROUTE_TYPE_02
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getStyleByNameWOZoomAndType = function(name,type) {
    var currStyles;
    for(var sty in this._styles){
        if (type === 'point'&& goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].style;
            }
        }
        if (type === 'line'&& goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].style;
            }
        }
        if (type === 'polygon'&& goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].style;
            }
        }
    }
    if (type === 'point'&& goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            return currStyles[i].style;
        }
    }
    if (type === 'line'&& goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            return currStyles[i].style;
        }
    }
    if (type === 'polygon'&& goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            return currStyles[i].style;
        }
    }
};

/**
 * Получение полного объекта со стилем по названию слоя и типу топологии
 * @param name
 * @param topology
 * @returns {*}
 */
LayerManager.prototype.getStyleObjByNameAndType = function(name,topology) {
    for(var sty in this._styles){
        if (topology === 'point'&& goog.isDef(this._pointStyles[sty+"#"+name]))
            return this._pointStyles[sty+"#"+name];
        if (topology === 'line'&& goog.isDef(this._lineStyles[sty+"#"+name]))
            return this._lineStyles[sty+"#"+name];
        if (topology === 'polygon'&& goog.isDef(this._polygonStyles[sty+"#"+name]))
            return this._polygonStyles[sty+"#"+name];
    }
    if (topology === 'point'&& goog.isDef(this._pointStyles[name]))
        return this._pointStyles[name];
    if (topology === 'line'&& goog.isDef(this._lineStyles[name]))
        return this._lineStyles[name];
    if (topology === 'polygon'&& goog.isDef(this._polygonStyles[name]))
        return this._polygonStyles[name];
};


LayerManager.prototype.getStyleByName = function(name) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
        if (goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
        if (goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    if (goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    if (goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};


LayerManager.prototype.getTextOverlapByNameAndType = function(name,type) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return '0';
    for(var sty in this._styles){
        if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].textOverlap;
            }
        }
        if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].textOverlap;
            }
        }
        if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].textOverlap;
            }
        }
    }
    if (type == 'Point' && goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            return currStyles[i].textOverlap;
        }
    }
    if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            return currStyles[i].textOverlap;
        }
    }
    if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            return currStyles[i].textOverlap;
        }
    }
    return '0';
};



LayerManager.prototype.getTextStyleByNameAndType = function(name,type) {
	var currStyles;
	if(!goog.isDefAndNotNull(WidgetMap.map))
		return null;
	for(var sty in this._styles){
		if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
			//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
			currStyles = this._pointStyles[sty+"#"+name];
			for(var i in currStyles){
					return currStyles[i].text;
			}
		}
		if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
			//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
			currStyles = this._lineStyles[sty+"#"+name];
			for(var i in currStyles){
					return currStyles[i].text;
			}
		}
		if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
			//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
			currStyles = this._polygonStyles[sty+"#"+name];
			for(var i in currStyles){
					return currStyles[i].text;
			}
		}
	}
	if (type == 'Point' && goog.isDef(this._pointStyles[name])){
		//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
		currStyles = this._pointStyles[name];
		for(var i in currStyles){
				return currStyles[i].text;
		}
	}
	if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
		//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
		currStyles = this._lineStyles[name];
		for(var i in currStyles){
				return currStyles[i].text;
		}
	}
	if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
		//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
		currStyles = this._polygonStyles[name];
		for(var i in currStyles){
				return currStyles[i].text;
		}
	}
	return null;
};




LayerManager.prototype.getPointStyle = function(name) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        var z = WidgetMap.map.getView().getZoom();
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};
LayerManager.prototype.getLineStyle = function(name) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};

LayerManager.prototype.getPolygonStyle = function(name) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};

/**
 * Дефолтные стили для примитивов
 * @returns {ol.style.Style}
 */
LayerManager.prototype.getDefaultPointStyle = function(){
    return new ol.style.Style({
          image: new map.style.Rectangle({
              radius: 7,
              fill: new ol.style.Fill({
                  color: 'rgba(242, 98, 15, 0.7)'
              }),
              stroke: new ol.style.Stroke({
                  color: '#A6430A',
                  width: 1
              })
          })
  })
};

/**
 * Цвет иконок для легенды пка из карусели
 * @param index
 * @returns {ol.style.Style}
 */
LayerManager.prototype.getDefaultCASCarouselStyle = function(index){
    return new ol.style.Style({
        image: new map.style.Rectangle({
            radius: 200,
            fill: new ol.style.Fill({
                color: CHART_COLORS[index]
            }),
            stroke: new ol.style.Stroke({
                color: CHART_COLORS[index],
                width: 2
            })
        })
    })
};

/**
 * Дефолтные стили для точечного объекта ПКА
 * @returns {ol.style.Style}
 */
LayerManager.prototype.getDefaultCASPointStyle = function(){
    return new ol.style.Style({
        image: new map.style.Rectangle({
            radius: 1,
            fill: new ol.style.Fill({
                color: 'rgba(242, 98, 15, 0.7)'
            }),
            stroke: new ol.style.Stroke({
                color: '#A6430A',
                width: 0
            })
        })
    })
};

LayerManager.prototype.getDefaultCircleStyle = function(){
    return new ol.style.Style({
        image: new ol.style.Circle({
            radius: 7,
            fill: new ol.style.Fill({
                color: 'rgba(242, 98, 15, 0.7)'
            }),
            stroke: new ol.style.Stroke({
                color: '#A6430A',
                width: 1
            })
        })
    })
};

LayerManager.prototype.getDefaultLineStyle = function(){
    return new ol.style.Style({
        stroke: new ol.style.Stroke({
            color: '#000000',//'#ffcc33',
            width: 3
        })
    })
};
LayerManager.prototype.getDefaultPolygonStyle = function(){
    return new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
        }),
        stroke: new ol.style.Stroke({
            color: '#ffcc33',
            width: 2
        })
    })
};


LayerManager.prototype.getDrawSurfaceStyle = function(){
    return new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(228, 237, 242, 0.4)'
        }),
        stroke: new ol.style.Stroke({
            color: '#E7FF33',
            width: 3
        })
    })
};



//об6новляем только фильтры у слоя, если он выключен
LayerManager.prototype.updateLayer = function(layerId){
    var layerObj = this.getVectorLayerByName(layerId);
    if(goog.isDefAndNotNull(layerObj))
        layerObj.visible = true;
    var filter = $('#treeDiv').myCategories('callbackFilter',{params:{}});
    WidgetMap.updateTopFilter(filter.params);
};

//включаем видимость слоя
LayerManager.prototype.enableLayer = function(layerId){
    var layerObj = this.getVectorLayerByName(layerId);
    if(goog.isDefAndNotNull(layerObj))
        layerObj.visible = true;
    var obj = {"params":[{
        name:"layerId",
        value:layerId
    }]};

    //если вернулось false, то не нашло в рубрикаторе(возможно, не открыт был ешё)
    var finded = $('#treeDiv').myCategories('enableLayer', obj);
    if(finded === false && layerId !== 'COSMETIC_OBJECT' && layerId !== 'FIND_PATH_OBJECT'
        && layerId !== 'LIB_DOC_GEO_VIDEO_OBJECT' && layerId !=='BUFFER_OBJECT'){
        var vars = {layerParams:'layerId='+layerId+';'};
        var params = {vars:vars};
        ExternalInteraction.treeCallFunction(params,'enableLayer');
    }
};

//включаем видимость слоя
LayerManager.prototype.disableLayer = function(layerId){
    var layerObj = this.getLayerByName(layerId);
    if(goog.isDefAndNotNull(layerObj))
        layerObj.visible = false;
    $('#treeDiv').myCategories('disableLayer',{"params":[{"name":"layerId","value":layerId}]});
};

//Получение видимости для слоя
LayerManager.prototype.getLayerVisibility = function(layerId){
    var layerObj = this.getLayerByName(layerId);
    if(goog.isDefAndNotNull(layerObj))
        return layerObj.visible;
    return false;
};



/**
 * Получить рамку для текущего слоя и переместить карту
 * @param layerObj
 *  * @param layerObj
 */
LayerManager.prototype.getQueryGeoMBR = function(layerObj, resultHandler){
    var that = this;
    function getReqLPUParams(request, lpuIds) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:'<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+
                '" '+ topFiltersStr+''+
                '>'+
                '<data LPU_IDS="'+lpuIds+'"/></root>'
        };
    }

    function resultLPU(resultXml) {
        try { // Иногда ответ в формате XML, а иногда в виде просто строки
            BlockingUtil.ready();
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') {
                if (goog.isDef(resultHandler))
                    resultHandler.apply(this);
                return;
            }
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var datas = layerGeoXml.getElementsByTagName("data");
            var dd = 0;
            for (dd; dd < datas.length; dd++) {
                var maxLat = parseFloat(datas[dd].getAttribute('YMAX'));
                var minLat = parseFloat(datas[dd].getAttribute('YMIN'));
                var minLon = parseFloat(datas[dd].getAttribute('XMIN'));
                var maxLon = parseFloat(datas[dd].getAttribute('XMAX'));
                var pnt1 = new proj4.toPoint([minLon, minLat]);
                var pnt2 = new proj4.toPoint([maxLon, maxLat]);
                var source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
                var dest_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
                if (App.projection === GeoUtil.PROJS.Pulkovo42) {//преобразуем в wgs84
                    var p42WgsPnt = GeoUtil.P42WGS(minLat, minLon);
                    pnt1 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
                    p42WgsPnt = GeoUtil.P42WGS(maxLat, maxLon);
                    pnt2 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
                }
                proj4.transform(source_, dest_, pnt1);
                proj4.transform(source_, dest_, pnt2);
                if(isNaN(pnt1.x) || isNaN(pnt1.y) || isNaN(pnt2.x) || isNaN(pnt2.y))
                    continue;
                var extent = [pnt1.x, pnt1.y, pnt2.x, pnt2.y]; // of ol.Extent `[minx, miny, maxx, maxy]`.
                if(extent.length == 0)
                    extent= [pnt1.x, pnt1.y, pnt2.x, pnt2.y];
                else
                    extent = ol.extent.extend(extent,[pnt1.x, pnt1.y, pnt2.x, pnt2.y]);
            }
            if(WidgetMap.canFirstTimeCentering || layerObj.layer.canFirstTimeCentering)
                WidgetMap.centerOnMap(extent);
            WidgetMap.canFirstTimeCentering = true;
            if (goog.isDef(resultHandler))
                resultHandler.apply(this);
        }
        catch(ex) {
            if(goog.isDef(resultHandler))
                resultHandler.apply(this);
        }
        finally {
            // WidgetMap.baseLayersControl.changeListByMode();
        }
    }
    function faultLPU(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== '') 
            App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_14'})
        if (goog.isDef(resultHandler))
            resultHandler.apply(this);
    }

    if(goog.isDef(WidgetMap.currentTopFilter) &&  WidgetMap.currentTopFilter.length > 0){
        var k=0;
        for(;k<WidgetMap.currentTopFilter.length;k++){
            if(goog.isDef(WidgetMap.currentTopFilter[k].name) && WidgetMap.currentTopFilter[k].name == 'LPU_ACCESS_FILTER'){
                var lpus = WidgetMap.currentTopFilter[k].value;
                App.serverQueryXMLNodeWithTries(Services.processQueryNode, getReqLPUParams('GAZPROM_ADM_SEM.xml#GET_LPU_BOUNDS', lpus), resultLPU, faultLPU,4);
                WidgetMap.canFirstTimeCentering = true;
                return;
            }
        }
    }
    WidgetMap.canFirstTimeCentering = true;
};




//Получение из массива фильтров строки со всеми фильтрами верхнего уровня (передаются в тег root, разделяются пробелами)
LayerManager.getTopFiltersString = function(filtersArr) {
    /******* FILTER ******/
        //Получение по значению данных его обертки для отправки в запрос (для строк добавляет кавычки)
    function getStrOrNumVal(val) {
        var valueStr = '';
        if($.isNumeric(val))
            valueStr += val;
        else if(val === "NULL")
            valueStr += val;
        else if(val === "")
            valueStr += 'NULL';
        else
            valueStr += "'"+val+"'";
        valueStr = valueStr.replace(/''/g, "'");//случай, если пришел уже в одинарных кавычках
        return valueStr;
    }
    var resultStr = '';
    if (filtersArr) {
        for (var i = 0; i < filtersArr.length; i++) {
            var curObj = filtersArr[i];
            var curObjName = curObj['name'];
            var curObjValue = curObj['value'];
            var curObjValArr = curObjValue.split(',');
            var valuesStr = '';
            for (var j=0; j < curObjValArr.length; j++) {
                valuesStr += getStrOrNumVal(curObjValArr[j]) + ",";
            }
            //убираем последнюю ","
            valuesStr = valuesStr.substr(0, valuesStr.length-1);
            //Формируем общую строку со всеми фильтрами
            resultStr = resultStr + curObjName + '="' + valuesStr + '" '; //Сзади добавляем пробел для разделения с последующими значениями
        }
    }

    return resultStr;
};
LayerManager.getTopFiltersStringWithBaseLPU = function(filtersArr) {
    /******* FILTER ******/
    //Получение по значению данных его обертки для отправки в запрос (для строк добавляет кавычки)
    function getStrOrNumVal(val) {
        var valueStr = '';
        if($.isNumeric(val))
            valueStr += val;
        else if(val === "NULL")
            valueStr += val;
        else if(val === "")
            valueStr += 'NULL';
        else
            valueStr += "'"+val+"'";
        valueStr = valueStr.replace(/''/g, "'");//случай, если пришел уже в одинарных кавычках
        return valueStr;
    }
    function getPreloadLpuValues(){
        var resArr = [];
        if(WidgetMap.preloadLpuValues && WidgetMap.preloadLpuValues.length > 0){
            WidgetMap.preloadLpuValues.forEach(function(lpu){
                if(lpu)resArr.push(lpu.CODE);
            });
        }
        return resArr;
    }
    var resultStr = '';
    if (filtersArr) {
        for (var i = 0; i < filtersArr.length; i++) {
            var curObj = filtersArr[i];
            var curObjName = curObj['name'];
            var curObjValue = curObj['value'];
            var curObjValArr = curObjValue.split(',');
            var valuesStr = '';
            if(curObjName === 'LPU_ACCESS_FILTER'){
                curObjValArr = getPreloadLpuValues();
            }
            for (var j=0; j < curObjValArr.length; j++) {
                valuesStr += getStrOrNumVal(curObjValArr[j]) + ",";
            }
            //убираем последнюю ","
            valuesStr = valuesStr.substr(0, valuesStr.length-1);
            //Формируем общую строку со всеми фильтрами
            resultStr = resultStr + curObjName + '="' + valuesStr + '" '; //Сзади добавляем пробел для разделения с последующими значениями
        }
    }

    return resultStr;
};
//Получение из массива фильтров строки со всеми фильтрами среднего уровня (передаются в тег data в атрибут FILTER, разделяются словом ' AND ')
LayerManager.getRoughFiltersString = function(filtersArr) {
    /******* FILTER ******/
        //Получение по значению данных его обертки для отправки в запрос (для строк добавляет кавычки)
    function getStrOrNumVal(val) {
        var valueStr = '';
        if($.isNumeric(val))
            valueStr += val;
        else if(val === "NULL")
            valueStr += val;
        else if(val === "")
            valueStr += 'NULL';
        else
            valueStr += "'"+val+"'";
	    valueStr = valueStr.replace(/''/g, "'");//случай, если пришел уже в одинарных кавычках
        return valueStr;
    }

    var resultStr = '';
    if (filtersArr && filtersArr.length > 0) {
        var curObj = filtersArr[0];
        var curObjValue = curObj['value'];
        var curObjValArr = curObjValue.split(',');
        var valuesStr = '';
        for (var j=0; j < curObjValArr.length; j++) {
            valuesStr += getStrOrNumVal(curObjValArr[j]) + ",";
        }
        //убираем последнюю ","
        valuesStr = valuesStr.substr(0, valuesStr.length-1);
        //Формируем общую строку со всеми фильтрами
        resultStr = valuesStr;
    }

    return resultStr;
};



/**
 *
 * @returns {number}
 */
LayerManager.getResolutionForZoomMinMax = function(map, zoomMin, zoomMax){
    var resolutions = [0, Infinity];
    if(goog.isDefAndNotNull(map) && goog.isDefAndNotNull(map.getView())){
        var view = map.getView();
        var res, z = 0;
        //опускаем zoomMin до 0, если zoomMin<=4, т.к. у нас начинаются масштабы с 4, а maxResolution_ для z=0 соответствует масштабу 4
        if(zoomMin <= view.minZoom_)
            zoomMin = view.minZoom_;
        resolutions = [view.maxResolution_ ,view.minResolution_];
        var mapResolutions = [];
        do {
            res = view.constrainResolution(view.maxResolution_, z);
            mapResolutions[view.minZoom_+z] = res;
            ++z;
        } while (res > view.minResolution_);

        resolutions[0] = mapResolutions[zoomMin]*2;
        if(zoomMax>=mapResolutions.length)
            resolutions[1] = mapResolutions[mapResolutions.length-1];
        else
            resolutions[1] = mapResolutions[zoomMax];
        return resolutions;//view.maxResolution_ соответствует minZoom, поэтому добавляем. И отнимаем 1, как во флеш
    }
    return resolutions;
};

LayerManager.styleCache = {};

LayerManager.prototype.createCustomClusterStyle = function(feature){
    return this.getStyleByName(feature.id_);
};


/**
 * Получения массива всех стилей для слоя
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getAllStylesForLayer = function(styleFileName,layerId) {
    var styles = [];
    var styleName = styleFileName+'#'+layerId;
    var i;
    for(i in this._pointStyles){
        if(i.indexOf(styleName) !=-1 && this._pointStyles[i][0].layerId == layerId )
            styles.push(this._pointStyles[i][0]);
    }
    for(i in this._lineStyles){
        if(i.indexOf(styleName) !=-1 && this._lineStyles[i][0].layerId == layerId )
            styles.push(this._lineStyles[i][0]);
    }
    for(i in this._polygonStyles) {
        if (i.indexOf(styleName) != -1 && this._polygonStyles[i][0].layerId == layerId)
            styles.push(this._polygonStyles[i][0]);
    }
    return styles;
};

/**
 * Получения всех стилей для слоя в виде объекта
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getAllStylesForLayerObj = function(styleFileName,layerId) {
    var styles = {};
    var styleName = styleFileName+'#'+layerId;
    var i;
    styles['point'] = {};
    styles['line'] = {};
    styles['polygon'] = {};
    for(i in this._pointStyles){
        if(i.indexOf(styleName) !=-1 && this._pointStyles[i][0].layerId == layerId )
            styles['point'][this._pointStyles[i][0].sId] = this._pointStyles[i][0];
    }
    for(i in this._lineStyles){
        if(i.indexOf(styleName) !=-1 && this._lineStyles[i][0].layerId == layerId )
            styles['line'][this._lineStyles[i][0].sId] = this._lineStyles[i][0];
    }
    for(i in this._polygonStyles) {
        if (i.indexOf(styleName) != -1 && this._polygonStyles[i][0].layerId == layerId)
            styles['polygon'][this._polygonStyles[i][0].sId] = this._polygonStyles[i][0];
    }
    return styles;
};

/**
 * Получения стилей для косметического слоя в виде объекта
 * @param styleFileName
 * @param layerId
 * @returns {*}
 */
LayerManager.prototype.getAllCosmeticStylesForLayerObj = function(styleFileName, layerId) {
    var styles = {};
    var styleName = styleFileName+'#'+layerId;
    var i;
    styles['point'] = undefined;
    styles['line'] = undefined;
    styles['polygon'] = undefined;
    for(i in this._pointStyles){
        if(i.indexOf(styleName) !== -1 && this._pointStyles[i][0].layerId === layerId ){
            if(!styles['point'])
                styles['point'] = {};
            styles['point'][this._pointStyles[i][0].sId] = this._pointStyles[i][0];
            styles['point'][this._pointStyles[i][0].sId].layerId = layerId;
        }

    }
    for(i in this._lineStyles){
        if(i.indexOf(styleName) !== -1 && this._lineStyles[i][0].layerId === layerId ){
            if(!styles['line'])
                styles['line'] = {};
            styles['line'][this._lineStyles[i][0].sId] = this._lineStyles[i][0];
            styles['line'][this._lineStyles[i][0].sId].layerId = layerId;
        }
    }
    for(i in this._polygonStyles) {
        if (i.indexOf(styleName) !== -1 && this._polygonStyles[i][0].layerId === layerId){
            if(!styles['polygon'])
                styles['polygon'] = {};
            styles['polygon'][this._polygonStyles[i][0].sId] = this._polygonStyles[i][0];
            styles['polygon'][this._polygonStyles[i][0].sId].layerId = layerId;
        }
    }
    //если какого-то стиля не нашли, берем из дефолтного

    if(!styles['point']){
        styles['point'] = {};
        styles['point'][this._pointStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId] = this._pointStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0];
        styles['point'][this._pointStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId].layerId = layerId;
    }
    if(!styles['line']){
        styles['line'] = {};
        styles['line'][this._lineStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId] = this._lineStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0];
        styles['line'][this._lineStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId].layerId = layerId;
    }
    if(!styles['polygon']){
        styles['polygon'] = {};
        styles['polygon'][this._polygonStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId] = this._polygonStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0];
        styles['polygon'][this._polygonStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId].layerId = layerId;
    }
    return styles;
};


/**
 * Функция получения данных из кеша (если они там есть и актуальны)
 */
LayerManager.prototype.getDataFromCache = function(requestId) {
    if(supports_html5_storage()){
        var retrievedObject = localStorage.getItem(requestId);
        return JSON.parse(retrievedObject);
    }

};

/**
 * Функция принудительной очистки кеша
 * (применяется при добавлении, изменении или удалении объектов слоя)
 */
LayerManager.prototype.clearDataCache = function(requestId) {
    if(supports_html5_storage()){
        localStorage.removeItem(requestId)
    }

};

/**
 * Функция сохранения результата геозапроса в кеш
 * @param resultData - данные для кеширования
 */
LayerManager.prototype.saveResultToCache = function(requestId, resultData) {
    if(supports_html5_storage()){
        //Пытаемся получить локальный кеш и сохранить пришедшие данные в него
        if(localStorage[requestId] == undefined){
            var curDate  = new Date();
            var testObject = { CACHE_ACTUAL_DATE: curDate, result: resultData };
            var strItem = JSON.stringify(testObject);
            try{
                localStorage.setItem(requestId, strItem );
            }
            catch(ex){
                App.errorReport(gis_layermanager_4+requestId+gis_layermanager_5, ex);
            }
        }
    }
};


/**
 * Прячем выбранные векторные слои
 * @param models - массив моделей
 */
LayerManager.prototype.hideVectorLayers = function(models){
    var i = 0;
    for(; i < models.length; i++){
        var m = models[i];
        var layers = this.getLayersByModel(m.replace('_Layers.xml',''));
        var j = 0;
        for(; j < layers.length; j++){
            var layer = layers[j];
            if(goog.isDef(layer) && goog.isDef(layer.layer)){
                layer.layer.clear();
	            layer.layer.isDataLoading_ = false;
                layer.layer.canLoadData = false;
                layer.layer.dataReady_ = false;
            }
        }
    }
};

/**
 * Показываем выбранные векторные слои
 * @param models - массив моделей
 */
LayerManager.prototype.showVectorLayers = function(models){
    var i = 0;
    for(; i < models.length; i++){
        var m = models[i];
        var layers = this.getLayersByModel(m.replace('_Layers.xml',''));
        var j = 0;
        for(; j < layers.length; j++){
            var layer = layers[j];
            if(goog.isDef(layer) && goog.isDef(layer.layer)){
                layer.layer.canLoadData = true;
	            layer.layer.isDataLoading_ = false;
	            layer.layer.dataReady_ = false;
                layer.layer.canFirstTimeCentering = false;
                layer.layer.loadData();
            }
        }
    }
};


/****************  ПКА  ***************/


/**
 * Удаление неиспользуемых слоёв с карты
 * @param [array.<Object>] layers слои, которые должны остаться
 */
LayerManager.prototype.removeUnusedCASLayers = function(layers){
    var newCASLayers = [];
    var mapLayers = new ol.Collection();
    var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
    for(var i in layers){
        for(var k in this._layers){
            if(this._layers[k].layer.uniqueLayerName==layers[i]){
                newCASLayers.push(this._layers[k]);
                break;
            }
        }
        for(var j=0;j<tLayers.getLength();j++){
            if(tLayers.item(j).get('id') == layers[i]){
                mapLayers.push(tLayers.item(j));
                break;
            }
        }
    }
    this._layers = newCASLayers;
    WidgetMap.currentVectorGroupLayer.setLayers(mapLayers);
};

/**
 * Удаление неиспользуемых слоёв с карты
 */
LayerManager.prototype.removeAllCASLayers = function(){
    WidgetMap.prevScaleXCoeff = 1;
    WidgetMap.mapScaleXCoeff = 1;
    WidgetMap.casScaleCoeff = 1;
    WidgetMap.curStartX = 0;
    WidgetMap.curEndX = 0;
    WidgetMap.positionsArr = [];
    WidgetMap.yScaleData = {};
    cashelper.clearAllCosmeticElements();
    WidgetMap.map.removeLayer(WidgetMap.currentVectorLayer);
    WidgetMap.currentVectorLayer = undefined;
    this._layers = [];
    WidgetMap.currentVectorGroupLayer.setLayers(new ol.Collection());
};

/**
 * Копирование casLayer, featuresProjLayer и добавление их в карту
 * @param [array.<Object>]layers
 * @param groupId идентификатор группы слоёв
 */
LayerManager.prototype.copyCASLayers = function(layers, groupId, group){
    //var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
    for(var i in layers){
        //если слой клонированный
        if(layers[i].LayerId.indexOf('#')!=-1){
            var layer = this.getVectorLayerByName(layers[i].layer);
            var copy = this.copyCASLayer(layer, layers[i].LayerId, layers[i].filter, layers[i].LayerDescr || layers[i].LayerName, layers[i].filterAsParam, layers[i].groupId, group, layers[i].selectedLineObj);
            this._layers.push(copy);
            this.registerLayer(copy.layer);
        }
    }
};

/**
 * Копирование слоя
 * @param layer
 */
LayerManager.prototype.copyCASLayer = function (layer, uniqueLayerName, filter, descr, filterAsParam, groupId, group, selectedLineObj) {
    var layerObj = {};
    layerObj.id = layer.id;
    layerObj.dataProvider = layer.dataProvider;
    layerObj.layerQueryId = layer.layerQueryId;
    layerObj.isTextAllow = layer.isTextAllow;
    layerObj.visible = layer.visible;
    layerObj.groupId = groupId; // идентификатор группы
    layerObj.group = group; // группы
    var wkbLayer = new map.layer.CASLayer({//временно продублировал атрибуты
        name: layer.layer.name,
        uniqueLayerName: uniqueLayerName,
        mapName: layer.layer.mapName,
        layerSchema: layer.layer.layerSchema,
        layerTable: layer.layer.layerTable,
        sourceName: layer.layer.sourceName,
        filter: filter,
        filterAsParam: filterAsParam,
        selectedLineObj: selectedLineObj,
        legendDescr: descr,
        layerNameSynonym: layer.layer.layerNameSynonym,
        sourceDescr: layer.layer.sourceDescr,
        dataType: layer.layer.dataType,
        labelField: layer.layer.labelField,
        requestFilterData: layer.layer.requestFilterData,
        classField: layer.layer.classField,
        cover: layer.layer.cover,
        type: layer.layer.type,
        showInfo: layer.layer.showInfo,
        canFirstTimeCentering:layer.layer.canFirstTimeCentering,
        fitMap: layer.layer.fitMap,
        drawTypes: layer.layer.drawTypes,
        minResolution:layer.layer.minResolution,
        maxResolution:layer.layer.maxResolution,
        order: layer.layer.order,
        mapOrder: layer.layer.mapOrder,
        zIndex: layer.layer.zIndex,
        maxLayerZoom:layer.layer.maxLayerZoom,
        minLayerZoom:layer.layer.minLayerZoom,
        spacing: layer.layer.spacing,
        layerQueryId: layer.layer.layerQueryId,
        dataProvider:layer.layer.dataProvider,
        groupId: groupId, // идентификатор группы
        group: group, //объект группы со ссылками на дочерние диаграммы
    });
    layerObj.filter = layer.filter;
    layerObj.layer = wkbLayer;
    return layerObj;
};


/**
 * Получение векторного слоя
 * @param layerName
 * @returns {undefined}
 */
LayerManager.prototype.getVectorLayerByUniqueName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this._layers;
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer;
    }
    return undefined;
};



LayerManager.prototype.isTextAllowedByCASLayerName = function(layerName) {
    var that = this;
    var curLayer = undefined;
    var i;
    for ( i = 0; i < that._layers.length; i++) {
        curLayer = that._layers[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer.isTextAllow;
    }
    for (i = 0; i < that._rasterLayers.length; i++) {
        curLayer = that._rasterLayers[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer.isTextAllow;
    }
    return false;
};

/**
 * Функция возвращает перечень слоёв, у которых есть синоним layerName
 * @param layerName
 * @returns {[]}
 */
LayerManager.prototype.getLayersBySynonym = function(layerName){
	var layers = [layerName];
	var curLayer = undefined;
	var vectorArr = this.getVectorLayersByMode();
	var rasterArr = this.getRasterLayersByMode();
	var i;
	for ( i = 0; i < vectorArr.length; i++) {
		curLayer = vectorArr[i];
		//не добавляем слой дубль слоя базового
		if (curLayer.layer.layerNameSynonym.indexOf(layerName) !== -1 && layerName !== curLayer.layer.uniqueLayerName)
            layers.push(curLayer.layer.uniqueLayerName);
	}
	for (i = 0; i < rasterArr.length; i++) {
		curLayer = rasterArr[i];
        if (curLayer.layer.layerNameSynonym.indexOf(layerName) !== -1 && layerName !== curLayer.layer.uniqueLayerName)
            layers.push(curLayer.layer.uniqueLayerName);
	}
	/*if(layers.length === 0)
        layers.push(layerName);*/
	return layers;
}


LayerManager.getFileRequestParams = function(fileName){
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

    return {
        getSchema: false,
        descrId: 'SYS_SEM.xml#GET_XML_FILE',
        toElements: false,
        descrType: 'select',
        data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '">' +
            '<data FILE="' + fileName + '"/>' +
            '</root>'
    };
}

/**
 * Функция загрузки файлов стилей
 * @param baseStyleName самые базовые стили (Default_STYLE.xml)
 * @param [customStyleName]  доп стили, уникальные для типа карты(карта, пка, техсхема)
 */
LayerManager.prototype.loadDefaultStyles = function(baseStyleName, customStyleName) {
    var that = this;
    baseStyleName = baseStyleName || customStyleName;
    if(!baseStyleName) return;
    function getLayersResult(resultXml) {
        try {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') {
                App.errorReport(gis_layermanager_7, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_5'});
                return;
            }
            var layersDescriptionXml = $.parseXML(resultXml);
            layersDescriptionXml = layersDescriptionXml.firstChild;
            that.parseStyle(layersDescriptionXml, baseStyleName);
            if(customStyleName){
                App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, LayerManager.getFileRequestParams(customStyleName), getLayersResult, getLayersFault);
                customStyleName = undefined;
            }
        }
        catch(ex) {
            App.errorReport(gis_layermanager_7, ex.message, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_6'});// Распарсить XML не удалось, видимо это просто строка
        }
    }
    function getLayersFault(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== '') 
            App.errorReport(gis_layermanager_7, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_8'});
    }
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, LayerManager.getFileRequestParams(baseStyleName), getLayersResult, getLayersFault);
};

LayerManager.prototype.setExpandValueToGroupLayers = function(expandValue, groupId){
    if(expandValue && groupId){
        this._layers.forEach(function(layer){
            if(layer && layer.layer && layer.layer.groupId === groupId){
                layer.layer.expandValue = expandValue;
            }
        })
    }
}
// FIXME add option to apply snapToPixel to all coordinates?
// FIXME can eliminate empty set styles and strokes (when all geoms skipped)
goog.provide('map.render.canvas.Replay');

/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.Replay = function(tolerance, maxExtent, resolution) {
    goog.base(this);

    /**
     * @protected
     * @type {number}
     */
    this.tolerance = tolerance;

    /**
     * @protected
     * @const
     * @type {ol.Extent}
     */
    this.maxExtent = maxExtent;

    /**
     * @private
     * @type {ol.Extent}
     */
    this.bufferedMaxExtent_ = null;

    /**
     * @protected
     * @type {number}
     */
    this.maxLineWidth = 0;

    /**
     * @protected
     * @const
     * @type {number}
     */
    this.resolution = resolution;

    /**
     * @private
     * @type {Array.<*>}
     */
    this.beginGeometryInstruction1_ = null;

    /**
     * @private
     * @type {Array.<*>}
     */
    this.beginGeometryInstruction2_ = null;

    /**
     * @protected
     * @type {Array.<*>}
     */
    this.instructions = [];

    /**
     * @protected
     * @type {Array.<number>}
     */
    this.coordinates = [];

    /**
     * @protected
     * @type {Array.<number>}
     */
    this.labels = [];

    /**
     * @private
     * @type {goog.vec.Mat4.Number}
     */
    this.renderedTransform_ = goog.vec.Mat4.createNumber();

    /**
     * @protected
     * @type {Array.<*>}
     */
    this.hitDetectionInstructions = [];

    /**
     * @private
     * @type {Array.<number>}
     */
    this.pixelCoordinates_ = [];

    /**
     * @private
     * @type {!goog.vec.Mat4.Number}
     */
    this.tmpLocalTransform_ = goog.vec.Mat4.createNumber();
};
goog.inherits(map.render.canvas.Replay, ol.render.VectorContext);


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} close Close.
 * @protected
 * @return {number} My end.
 */
map.render.canvas.Replay.prototype.appendFlatCoordinates =
    function(flatCoordinates, offset, end, stride, close) {

        var myEnd = this.coordinates.length;
        //var extent = this.getBufferedMaxExtent();
        var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
        var nextCoord = [NaN, NaN];
        var skipped = true;

        var i, lastRel, nextRel;
        for (i = offset + stride; i < end; i += stride) {
            nextCoord[0] = flatCoordinates[i];
            nextCoord[1] = flatCoordinates[i + 1];
            nextRel = ol.extent.Relationship.INTERSECTING;//ol.extent.coordinateRelationship(extent, nextCoord);
            if (nextRel !== lastRel) {
                if (skipped) {
                    this.coordinates[myEnd++] = lastCoord[0];
                    this.coordinates[myEnd++] = lastCoord[1];
                }
                this.coordinates[myEnd++] = nextCoord[0];
                this.coordinates[myEnd++] = nextCoord[1];
                skipped = false;
            } else if (nextRel === ol.extent.Relationship.INTERSECTING) {
                this.coordinates[myEnd++] = nextCoord[0];
                this.coordinates[myEnd++] = nextCoord[1];
                skipped = false;
            } else {
                skipped = true;
            }
            lastCoord[0] = nextCoord[0];
            lastCoord[1] = nextCoord[1];
            lastRel = nextRel;
        }

        // handle case where there is only one point to append
        if (i === offset + stride) {
            this.coordinates[myEnd++] = lastCoord[0];
            this.coordinates[myEnd++] = lastCoord[1];
        }

        if (close) {
            this.coordinates[myEnd++] = flatCoordinates[offset];
            this.coordinates[myEnd++] = flatCoordinates[offset + 1];
        }
        return myEnd;
    };

map.render.canvas.Replay.prototype.appendNewFlatCoordinates =
    function(flatCoordinates, offset, end, stride, close) {

        /*this.coordinates = flatCoordinates;
        var myEnd = this.coordinates.length;
        return myEnd;*/
        var myEnd = this.coordinates.length;
        //var extent = this.getBufferedMaxExtent();
        var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
        var nextCoord = [NaN, NaN];
        var skipped = true;

        var i, lastRel, nextRel;
        for (i = offset + stride; i < end; i += stride) {
            nextCoord[0] = flatCoordinates[i];
            nextCoord[1] = flatCoordinates[i + 1];
            nextRel = ol.extent.Relationship.INTERSECTING;//ol.extent.coordinateRelationship(extent, nextCoord);//ol.extent.Relationship.INTERSECTING
            if (nextRel !== lastRel) {
                if (skipped) {
                    this.coordinates[myEnd++] = lastCoord[0];
                    this.coordinates[myEnd++] = lastCoord[1];
                }
                this.coordinates[myEnd++] = nextCoord[0];
                this.coordinates[myEnd++] = nextCoord[1];
                //_labels[labelType].push(globalPointsLabels_[labelType][i/2]);
                skipped = false;
            } else if (nextRel === ol.extent.Relationship.INTERSECTING) {
                this.coordinates[myEnd++] = nextCoord[0];
                this.coordinates[myEnd++] = nextCoord[1];
                //_labels[labelType].push(globalPointsLabels_[labelType][i/2]);
                skipped = false;
            } else {
                skipped = true;
            }
            lastCoord[0] = nextCoord[0];
            lastCoord[1] = nextCoord[1];
            lastRel = nextRel;
        }
        // handle case where there is only one point to append
        if (i === offset + stride) {
            this.coordinates[myEnd++] = lastCoord[0];
            this.coordinates[myEnd++] = lastCoord[1];
        }

        if (close) {
            this.coordinates[myEnd++] = flatCoordinates[offset];
            this.coordinates[myEnd++] = flatCoordinates[offset + 1];
        }
        return myEnd;
    };

// чем меньше приоритет, тем лучше
map.render.canvas.Replay.prototype.hasCollision_ = function(feature, width, height, x, y, priority, type){
    //Считаем координату х смещенной на _matrixAddWidth, а координату y смещенной на _matrixAddHeight,
    //поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
    //если пришел шаг матрицы 1, то убираем разрядку
    if(_dx == 1 || _dy == 1)
        return false;
    var layerId = feature.get('layerId');//feature.get('labelType');
    if(layerId === undefined){
        return true;
    }
    if(type === undefined)
        type = 'label';
    x += _dx;
    y += _dy;

    var min_x = Math.floor(x/_dx);
    var min_y = Math.floor(y/_dy);
    var max_y = min_y;
    var max_x = min_x;
    if (feature){
        max_x = Math.floor((x + width)/_dx);
        max_y = Math.floor((y + height)/_dy);
    }
    var i,j;

    if (min_x < 0 || min_y < 0)
        return true;
    if(_visibleMatrix[layerId] === undefined)
        return true;
    if (max_x >= _visibleMatrix[layerId].length)
        return true;
    if (max_y >= _visibleMatrix[layerId][0].length)
        return true;

    try{
        for (i = min_x; i<= max_x; i++){
            for (j = min_y; j<= max_y; j++){
                if (_visibleMatrix[layerId] !== undefined && _visibleMatrix[layerId][i][j][type] !== undefined){
                    // кто-то уже есть
                    var t = _visibleMatrix[layerId][i][j][type];
                    if ((priority > t.priority)){
                        // тут должен быть новый объект
                        //deleteBlockObject(t.obj, i*_dx, j*_dy, type);
                    }
                    else
                        return true;
                }
            }
        }
    }
    catch(ex){
        //console.log('sssd');
    }

    return false;
};

// чем меньше приоритет, тем лучше
map.render.canvas.Replay.prototype.hasTextCollision_ = function(feature, width, height, x, y, priority, type){
    //поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
    var layerId = feature.get('labelType');
    if(!goog.isDef(layerId))
        return false;
    if(!goog.isDef(type))
        type = 'label';
    x += _dx;
    y += _dy;
    //feature = null;
    var min_x = Math.floor(x/(_dx));
    var min_y = Math.floor(y/(_dy));
    var max_y = min_y;
    var max_x = min_x;
    if (feature){
        max_x = Math.floor((x + width)/(_dx));
        max_y = Math.floor((y + height)/(_dy));
    }

    var i;
    var j;

    if (min_x < 0 || min_y < 0)
        return true;
    if (max_x >= _visibleMatrix[layerId][0].length)
        return true;
    if (max_y >= _visibleMatrix[layerId][0].length)
        return true;

    try{
        for (i = min_x; i<= max_x; i++){
            for (j = min_y; j<= max_y; j++){
                if (goog.isDefAndNotNull(_visibleMatrix[layerId]) && goog.isDef(_visibleMatrix[layerId][i]) && goog.isDef(_visibleMatrix[layerId][i][j]) && goog.isDef(_visibleMatrix[layerId][i][j][type])){
                    // кто-то уже есть
                    var t = _visibleMatrix[layerId][i][j][type];
                    if ((priority > t.priority)){
                        // тут должен быть новый объект
                        //deleteBlockObject(t.obj, i*_dx, j*_dy, type);
                    }
                    else
                        return true;
                }
            }
        }
    }
    catch(ex){
        //console.log('sd');
    }


    return false;
};

map.render.canvas.Replay.prototype.addLineTextObject_ = function(feature, width, height, coordX, coordY, x, y, priority, type, lock, text, objId){
    if(!this.hasTextCollision_(feature,width, 13, x, y, priority)){
        //this.addTextObject_(feature, width, 13, this.coordinates[g], this.coordinates[g + 1], x, y, feature.get('zIndex'));
        //Считаем координату х смещенной на _matrixAddWidth, а координату y смещенной на _matrixAddHeight,
        //поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
        var layerId = feature.get('labelType');
        if(!goog.isDef(lock))
            lock = true;
        if(!goog.isDef(type))
            type = 'label';
        x += _dx;
        y += _dy;

        var min_x = Math.floor(x/_dx);
        var max_x = min_x;
        var min_y = Math.floor(y/_dy);
        var max_y = min_y;
        if (goog.isDef(feature)){
            max_x = Math.floor((x + width)/_dx);
            max_y = Math.floor((y + height)/_dy);
        }
        var i;
        var j;
        if (min_x < 0 || min_y < 0)
            return;
        if (max_x >= _visibleMatrix[layerId].length)
            return;
        var added = false;
        if (lock == true){
            for (i = min_x; i<= max_x; i++){
                for (j = min_y; j<= max_y; j++){
                    var sav;
                    if (!goog.isDef(_visibleMatrix[layerId][i][j])){
                        _visibleMatrix[layerId][i][j] = {};
                        if(!goog.isDef(_visibleMatrix[layerId][i][j][type]))
                            _visibleMatrix[layerId][i][j][type] = {};
                        sav = _visibleMatrix[layerId][i][j][type];
                        sav.priority = priority;
                        sav.obj = feature;
                        sav.text = text;
                        _visibleMatrix[layerId][i][j][type] = sav;
                        added = true;
                    }
                    else if(!goog.isDef(_visibleMatrix[layerId][i][j][type])){
                        if(!goog.isDef(_visibleMatrix[layerId][i][j]))
                            _visibleMatrix[layerId][i][j] = {};
                        if(!goog.isDef(_visibleMatrix[layerId][i][j][type]))
                            _visibleMatrix[layerId][i][j][type] = {};
                        sav = _visibleMatrix[layerId][i][j][type];
                        sav.priority = priority;
                        sav.obj = feature;
                        sav.text = text;
                        //sav.unique = layerId+'_'+coordX+'_'+coordY;
                        _visibleMatrix[layerId][i][j][type] = sav;
                        added = true;

                    }
                }
            }
        }
        if(added = true){
            if(!goog.isDef(_lineLabels[feature.get('labelType')][objId]))
                _lineLabels[feature.get('labelType')][objId] = [];
            _lineLabels[feature.get('labelType')][objId].push({rotation:0, x:coordX, y:coordY, text:text, objId:objId});
            return _lineLabels[feature.get('labelType')][objId].length-1;
        }
    }
    else{
        return null;
    }

};


map.render.canvas.Replay.prototype.addTextObject_ = function(feature, width, height, coordX, coordY, x, y, add, priority, type, lock){
    //Считаем координату х смещенной на _matrixAddWidth, а координату y смещенной на _matrixAddHeight,
    //поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
    var layerId = feature.get('labelType');
    if(!goog.isDef(lock))
        lock = true;
    if(!goog.isDef(type))
        type = 'label';
    x += _dx;
    y += _dy;

    var min_x = Math.floor(x/_dx);
    var max_x = min_x;
    var min_y = Math.floor(y/_dy);
    var max_y = min_y;
    if (goog.isDef(feature)){
        max_x = Math.floor((x + width)/_dx);
        max_y = Math.floor((y + height)/_dy);
    }
    var i;
    var j;
    if (min_x < 0 || min_y < 0)
        return;
    if (max_x >= _visibleMatrix[layerId].length)
        return;
    /*if(type == 'common'){
     console.log('ddd '+priority);
     }*/
    if (lock == true){
        for (i = min_x; i<= max_x; i++){
            for (j = min_y; j<= max_y; j++){
                var sav;
                if (!goog.isDef(_visibleMatrix[layerId][i][j])){
                    _visibleMatrix[layerId][i][j] = {};
                    if(!goog.isDef(_visibleMatrix[layerId][i][j][type]))
                        _visibleMatrix[layerId][i][j][type] = {};
                    sav = _visibleMatrix[layerId][i][j][type];
                    sav.priority = priority;
                    sav.obj = feature;
                    _visibleMatrix[layerId][i][j][type] = sav;
                }
                else if(!goog.isDef(_visibleMatrix[layerId][i][j][type])){
                    if(!goog.isDef(_visibleMatrix[layerId][i][j]))
                        _visibleMatrix[layerId][i][j] = {};
                    if(!goog.isDef(_visibleMatrix[layerId][i][j][type]))
                        _visibleMatrix[layerId][i][j][type] = {};
                    sav = _visibleMatrix[layerId][i][j][type];
                    sav.priority = priority;
                    sav.obj = feature;
                    sav.unique = layerId+'_'+coordX+'_'+coordY;
                    _visibleMatrix[layerId][i][j][type] = sav;
                    _pointLabels[layerId][sav.unique] = true;
                }
            }
        }
    }
};


map.render.canvas.Replay.prototype.hasTextPointCollision_ = function(feature, width, height, x, y, priority, type){
    //Считаем координату х смещенной на _matrixAddWidth, а координату y смещенной на _matrixAddHeight,
    //поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
    var layerId = feature.get('layerId');
    if(layerId === undefined)
        return false;
    if(type === undefined)
        type = 'label';
    x += _dx;
    y += _dy;
    //feature = null;
    var min_x = Math.floor(x/_dx);
    var min_y = Math.floor(y/_dy);
    var max_y = min_y;
    var max_x = min_x;
    if (feature){
        max_x = Math.floor((x + width)/_dx);
        max_y = Math.floor((y + height)/_dy);
    }
    var i,j;
    if (min_x < 0 || min_y < 0)
        return true;

    if (max_x >= _visibleTextMatrix[type].length)
        return true;
    if (max_y >= _visibleTextMatrix[type][0].length)
        return true;

    try{
        for (i = min_x; i<= max_x; i++){
            for (j = min_y; j<= max_y; j++){
                if (_visibleTextMatrix[type] !== undefined && _visibleTextMatrix[type][i] !== undefined && _visibleTextMatrix[type][i][j] !== undefined){
                    // кто-то уже есть
                    var t = _visibleTextMatrix[type][i][j];
                    if ((priority < t.priority)){
                        //удаляем с матрице всё, связанное с этим объектом и даем разрешение на добавление нового элемента в матрицу
                        this.deleteTextPointObject_(t);
                        return false;
                    }
                    else
                        return true;
                }
            }
        }
    }
    catch(ex){
        //console.log('sd');
    }
    return false;
};

map.render.canvas.Replay.prototype.deleteTextPointObject_ = function(t){
    if( t === undefined) return;
    var min_x = t.minX;
    var min_y = t.minY;
    var max_x = t.maxX;
    var max_y = t.maxY;

    if (min_x < 0 || min_y < 0)
        return;
    if (max_x >= _visibleTextMatrix['label'].length)
        return;
    if (max_y >= _visibleTextMatrix['label'][0].length)
        return true;
    var i,j;
    //удаляем из матрицы
    for (i = min_x; i <= max_x; i++){
        for (j = min_y; j <= max_y; j++){
            if (_visibleTextMatrix['label'][i] && _visibleTextMatrix['label'][i][j] !== undefined)
                _visibleTextMatrix['label'][i][j] = undefined;
        }
    }
    //удаляем из объектов
    var k;
    for(k=_LABELS.length-1; k>=0;k--){
        if(_LABELS[k].unique == t.unique) {
            _LABELS.splice(k,1);
            break;
        }
    }
};

map.render.canvas.Replay.prototype.addTextPointObject_ = function(feature, width, height, coordX, coordY, x, y, priority, type, lock, label){
    //Считаем координату х смещенной на _matrixAddWidth, а координату y смещенной на _matrixAddHeight,
    //поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
    if(!goog.isDef(coordX) || !goog.isDef(coordY))
        return '';
    var layerId = feature.get('labelType');
    if(!goog.isDef(lock))
        lock = true;
    if(!goog.isDef(type))
        type = 'label';
    x += _dx;
    y += _dy;
    var min_x = Math.floor(x/_dx);
    var max_x = min_x;
    var min_y = Math.floor(y/_dy);
    var max_y = min_y;
    if (goog.isDef(feature)){
        max_x = Math.floor((x + width)/_dx);
        max_y = Math.floor((y + height)/_dy);
    }
    var i;
    var j;
    var unique = layerId+'_'+coordX+'_'+coordY;
    if (min_x < 0 || min_y < 0)
        return unique;
    if (max_x >= _visibleTextMatrix[type].length)
        return unique;
    if (lock == true){
        for (i = min_x; i<= max_x; i++){
            for (j = min_y; j<= max_y; j++){
                var sav;
                if (!goog.isDef(_visibleTextMatrix[type][i][j])){
                    _visibleTextMatrix[type][i][j] = {};
                    if(!goog.isDef(_visibleTextMatrix[type][i][j]))
                        _visibleTextMatrix[type][i][j] = {};
                    sav = _visibleTextMatrix[type][i][j];
                    sav.priority = priority;
                    sav.obj = feature;
                    sav.minX = min_x;
                    sav.maxX = max_x;
                    sav.minY = min_y;
                    sav.maxY = max_y;
                    sav.unique = layerId+'_'+coordX+'_'+coordY;
                    unique = sav.unique;
                    _visibleTextMatrix[type][i][j] = sav;
                }
                else if(!goog.isDef(_visibleTextMatrix[type][i][j])){
                    if(!goog.isDef(_visibleTextMatrix[type][i][j]))
                        _visibleTextMatrix[type][i][j] = {};
                    if(!goog.isDef(_visibleMatrix[layerId][i][j][type]))
                        _visibleMatrix[layerId][i][j][type] = {};
                    sav = _visibleTextMatrix[type][i][j];
                    sav.priority = priority;
                    sav.obj = feature;
                    sav.minX = min_x;
                    sav.maxX = max_x;
                    sav.minY = min_y;
                    sav.maxY = max_y;
                    sav.label = label;
                    sav.unique = layerId+'_'+coordX+'_'+coordY;
                    unique = sav.unique;
                    _visibleTextMatrix[type][i][j]= sav;
                }
            }
        }
    }
    else{
        unique = layerId+'_'+coordX+'_'+coordY;
    }
    return unique;
}



//Добавляем точки в мультиполигоне
map.render.canvas.Replay.prototype.addObject_ = function(feature, width, height, x, y, add, priority, type, lock){
    //Считаем координату х смещенной на _matrixAddWidth, а координату y смещенной на _matrixAddHeight,
    //поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
    var layerId = feature.get('layerId');
    if(lock === undefined)
        lock = true;
    x += _dx;
    y += _dy;

    var min_x = Math.floor(x/_dx);
    var max_x = min_x;
    var min_y = Math.floor(y/_dy);
    var max_y = min_y;
    if (feature !== undefined){
        max_x = Math.floor((x + width)/_dx);
        max_y = Math.floor((y + height)/_dy);
    }
    var i;
    var j;
    if (min_x < 0 || min_y < 0)
        return;
    if (max_x >= _visibleMatrix[layerId].length)
        return;
    if (max_y >= _visibleMatrix[layerId][0].length)
        return;
    if (lock == true){
        for (i = min_x; i<= max_x; i++){
            for (j = min_y; j<= max_y; j++){
                var sav;
                if (_visibleMatrix[layerId][i][j] === undefined){
                    _visibleMatrix[layerId][i][j] = {};
                    if(_visibleMatrix[layerId][i][j][type] === undefined)
                        _visibleMatrix[layerId][i][j][type] = {};
                    sav = _visibleMatrix[layerId][i][j][type];
                    sav.priority = priority;
                    sav.obj = feature;
                    _visibleMatrix[layerId][i][j][type] = sav;
                }
                else if(_visibleMatrix[layerId][i][j][type] === undefined){
                    if(_visibleMatrix[layerId][i][j] === undefined)
                        _visibleMatrix[layerId][i][j] = {};
                    if(_visibleMatrix[layerId][i][j][type] === undefined)
                        _visibleMatrix[layerId][i][j][type] = {};
                    sav = _visibleMatrix[layerId][i][j][type];
                    sav.priority = priority;
                    sav.obj = feature;
                    _visibleMatrix[layerId][i][j][type] = sav;
                }
            }
        }
    }
};


map.render.canvas.Replay.prototype.getLineWidth = function(layerName){
    if(layerName !== 'KAP_REMONT_PLAN')
        return 0;
    var zoom = WidgetMap.map.getView().getZoom();
    var kapWidth = 0;
    switch (zoom){
        case 9:
            kapWidth = 1;
            break;
        case 10:
            kapWidth = 6;
            break;
        case 11:
            kapWidth = 15;
            break;
        case 12:
            kapWidth = 33;
            break;
        case 13:
            kapWidth = 70;
            break;
        default:
            kapWidth = 0;
            break;
    }
    return kapWidth;
}

map.render.canvas.Replay.prototype.getPointWidth = function(layerName){
    //решено убрать иконки svg, т.к. ie11 выдает ошибку security error при экспорте картинки и печати
    return 0;
    if(layerName !== 'KAP_REMONT_PLAN')
        return 0;
    var zoom = WidgetMap.map.getView().getZoom();
    var kapWidth = 0;
    switch (zoom){
        case 9:
            kapWidth = 2;
            break;
        case 10:
            kapWidth = 32;
            break;
        case 11:
            kapWidth = 88;
            break;
        case 12:
            kapWidth = 197;
            break;
        case 13:
            kapWidth = 418;
            break;
        default:
            kapWidth = 0;
            break;
    }
    return kapWidth;
}



map.render.canvas.Replay.prototype.rotateText_ = function (p1, p2, width, height, vAlign, hAlign, mode, dX, dY, resolution, x, y, isKapRemont) {
    //меняем vAlign,hAlign,mode
    var baseHAlign = hAlign;
    vAlign = 'middle';
    hAlign = 'right';
    var rotation = 0;
    var tempRotation = rotation;//используем её, чтобы не запортить, которая в return пойдет
    //x = 509;
    //y = 307;
    //width = 95;
    if (p1 != null && p2 != null){
        rotation = -Math.atan2(p2.y - p1.y, p2.x - p1.x)*180/Math.PI;
    }
    //upd. 04.03.21 принято решение в тех. схеме не показывать подписи, которые не рисуются строго вертикально или горизонтально
    var absRotation = Math.abs(rotation);
    if(!((absRotation >= 0 && absRotation <= 2) || (absRotation >= 88 && absRotation <= 92) || (absRotation >= 178 && absRotation <= 182) || (absRotation >= 258 && absRotation <= 362)))
        return;

    width = this.transformPoint(rotation,width);
    //return [x, y, rotation];
    var w = width;
    var h = height;
    var kh = 1;
    var kx = 0;
    var ky = 0;
    //2 новых режима - расположение подписи над центром объекта и под центром объекта
    if (vAlign == "middleTop")
        kh = 1;
    if (vAlign == "middleBottom")
        kh = 0;
    if (vAlign == "middle")
        kh = 0.5;
    if (vAlign == "bottom"){
        kh = 0;
        ky = -1;
    }
    if (vAlign == "top")
        ky = 1;

    var kw = 0;
    if (hAlign == "left"){
        kw = 1;
        if (vAlign == "middle"){
            kx = 1;
        }
    }
    if (hAlign == "right")
        if (vAlign == "middle")
            kx = -1;
    if (hAlign == 'center')
        kw = 0.5;

    if (false && mode != "normal" && (!goog.isNull(p1) && !goog.isNull(p2))){
        var l = Math.sqrt(Math.pow(p2.y - p1.y, 2)+Math.pow(p2.x - p1.x, 2));
        x = dX + p1.x/resolution - 2;
        y = dY -(p1.y + l)/resolution;
    }
    else{
        if ((rotation > 90) || (rotation < -90)){
            // добавляем смещение
            rotation = rotation + 180;
            tempRotation = rotation;
            if(rotation>180)
                tempRotation = rotation-360;
            x -= w*Math.cos(tempRotation*Math.PI/180); //- h*kh*Math.sin(lbl.rotation*Math.PI/180);
            y -= w*Math.sin(tempRotation*Math.PI/180); //+ h*kh*Math.cos(lbl.rotation*Math.PI/180);
        }
        x += (ky*dY + h*kh)*Math.sin(tempRotation*Math.PI/180);
        y -= (ky*dY + h*kh)*Math.cos(tempRotation*Math.PI/180);
        x -= (kx*dX + w*kw)*Math.cos(tempRotation*Math.PI/180);
        y += (kx*dX + w*kw)*Math.sin(tempRotation*Math.PI/180);
    }
    //переводим в радианы
    rotation = rotation*Math.PI/180;
    //доп проверка. если по горизонтали center и поворот 0, тьо возвращаем центр линии. Дальше, если слова с переносами,
    //то для них высчитываем новое начало подписи дл якаждого перноса
    if(isKapRemont){
        rotation = 0;
        baseHAlign = 'center';
    }
    if(rotation == 0 && baseHAlign === 'center'){
        var tempP = p1;
        var xf,yf,xm,ym;
        if(p1.x > p2.x){
            p1 = p2;
            p2 = tempP;
        }
        var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p1.x, p1.y]);
        x = pixelCoord[0];
        y = pixelCoord[1];
        var pixelCoordf = WidgetMap.map.getPixelFromCoordinate([p2.x, p2.y]);
        xf = pixelCoordf[0];
        yf = pixelCoordf[1];
        xm = (xf + x)/2;
        ym = (y + yf)/2;
        x = xm;
    }
    return [x, y, rotation];
};


map.render.canvas.Replay.prototype.moveTextToCenter_ = function (p1, p2, width, height, x, y, extent, duplicate) {
    var tempP = p1;
    var xf,yf,xm,ym;
    //var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p1.x, p1.y]);
    var pixelCoordLT = WidgetMap.map.getPixelFromCoordinate([extent[0], extent[1]]);
    x = pixelCoordLT[0];
    y = pixelCoordLT[1];
    //var pixelCoordF = WidgetMap.map.getPixelFromCoordinate([p2.x, p2.y]);
    var pixelCoordRB = WidgetMap.map.getPixelFromCoordinate([extent[2], extent[3]]);
    xf = pixelCoordRB[0];
    yf = pixelCoordRB[1];
    xm = (xf + x)/2;
    ym = (y + yf)/2;
    x = xm;
    y = ym;
    //если экстент по ширине меньше высоты , то поворачиваем подпись на 90 градусов
    if(Math.abs(extent[0]-extent[2]) < Math.abs(extent[1]-extent[3])){
        //width = this.transformPoint(90, width);
        var kh = 0.5;
        var ky = 0;
        var kx = 1;
        var kw = 0.5;
        var tempRotation = 90;
        x += (duplicate - 1) * 8;
        /*x += (ky + height * kh) * Math.sin(tempRotation * Math.PI / 180);
        x += (kx + width * kw) * Math.cos(tempRotation * Math.PI / 180);
        y -= (ky + height * kh) * Math.cos(tempRotation * Math.PI / 180);
        y += (kx + width * kw) * Math.sin(tempRotation * Math.PI / 180);*/
        //return [x, y, 4.71239];
        //upd 31.08. капремонты все горизонтально делаем
        return [x, y, 0];
    }


    return [x, y, 0];
};
map.render.canvas.Replay.prototype.transformPoint = function(angel, width) {
    //переводим в радианы
    angel = angel*Math.PI/180;
    var can = document.createElement('canvas');
    can.width  = width  ;
    can.height = 11 ;
    var ctx = can.getContext('2d');
    var t = new Transform();
    ctx.translate(0,0);
    ctx.rotate(angel);
    t.translate(0, 0);
    t.rotate(angel);
    var pt = t.transformPoint(width,0);
    return Math.abs(pt[0]);
}



map.render.canvas.Replay.prototype.rotateTextVtd_ = function(p1, p2, width, height, vAlign, hAlign, mode, dX, dY, resolution,x,y){
    //меняем vAlign,hAlign,mode
    var baseHAlign = hAlign;
    //vAlign = 'middle';
    //hAlign = 'right';
    var rotation = 0;
    var tempRotation = rotation;//используем её, чтобы не запортить, которая в return пойдет
    if (p1 != null && p2 != null){
        rotation = -Math.atan2(p2.y - p1.y, p2.x - p1.x)*180/Math.PI;
    }
    width = this.transformPoint(rotation, width);
    //upd. 04.03.21 принято решение в тех. схеме не показывать подписи, которые не рисуются строго вертикально или горизонтально
    var absRotation = Math.abs(rotation);
    if(!((absRotation >= 0 && absRotation <= 2) || (absRotation >= 88 && absRotation <= 92) || (absRotation >= 178 && absRotation <= 182) || (absRotation >= 258 && absRotation <= 362)))
        return;
    var w = width;
    var h = height;
    var kh = 1;
    var kx = 0;
    var ky = 0;
    if (vAlign === "middle") kh = 0.5;
    if (vAlign === "bottom"){
        kh = 0;
        ky = -1;
    }
    if (vAlign === "top") ky = 1;

    var kw = 0;
    if (hAlign === "left"){
        kw = 1;
        if (vAlign === "middle"){
            kx = 1;
        }
    }
    if (hAlign === "right")
        if (vAlign === "middle")
            kx = -1;
    if (hAlign === 'center') kw = 0.5;

    if ((rotation > 90) || (rotation < -90)){
        // добавляем смещение
        rotation = rotation + 180;
        tempRotation = rotation;
        if(rotation>180)
            tempRotation = rotation-360;
        x -= w*Math.cos(tempRotation*Math.PI/180); //- h*kh*Math.sin(lbl.rotation*Math.PI/180);
        y -= w*Math.sin(tempRotation*Math.PI/180); //+ h*kh*Math.cos(lbl.rotation*Math.PI/180);
    }
    /*if(Math.abs(rotation) < 1)
		rotation = 0;*/
    x += (ky + h * kh) * Math.sin(tempRotation * Math.PI / 180);
    y -= (ky + h * kh) * Math.cos(tempRotation * Math.PI / 180);
    x += (kx + w * kw) * Math.cos(tempRotation * Math.PI / 180);
    y += (kx + w * kw) * Math.sin(tempRotation * Math.PI / 180);

    /*if(Math.abs(rotation) < 1){
		rotation = 0;
		x = WidgetMap.map.getPixelFromCoordinate([p1.x, p1.y])[0];
	}*/
    //переводим в радианы
    rotation = rotation * Math.PI/180;
    //доп проверка. если по горизонтали center и поворот 0, тьо возвращаем центр линии. Дальше, если слова с переносами,
    //то для них высчитываем новое начало подписи дл якаждого перноса
    if(rotation == 0 && baseHAlign === 'center'){
        var tempP = p1;
        var xf,yf,xm,ym;
        if(p1.x > p2.x){
            p1 = p2;
            p2 = tempP;
        }
        var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p1.x, p1.y]);
        x = pixelCoord[0];
        y = pixelCoord[1];
        var pixelCoordf = WidgetMap.map.getPixelFromCoordinate([p2.x, p2.y]);
        xf = pixelCoordf[0];
        yf = pixelCoordf[1];
        xm = (xf + x)/2;
        ym = (y + yf)/2;
        x = xm;
        //x = xm+(width/2)-width/2;
        //x = pixelCoord[0];
    }
    return [x, y, rotation];
};


map.render.canvas.Replay.prototype.rotateLineText_ = function (p1, p2, width, height, vAlign, hAlign, mode, dX, dY, resolution, x, y) {
    dY = height * LABEL_FONT_RATIO;
    var tempP = p1;
    var xf, yf, xm, ym;
    if (p1.x > p2.x) {
        p1 = p2;
        p2 = tempP;
    }
    var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p1.x, p1.y]);
    x = pixelCoord[0];
    y = pixelCoord[1];
    var pixelCoordf = WidgetMap.map.getPixelFromCoordinate([p2.x, p2.y]);
    xf = pixelCoordf[0];
    yf = pixelCoordf[1];
    xm = (xf + x) / 2;
    ym = (y + yf) / 2;
    var rotation = 0;
    if (p1 !== null && p2 !== null) {
        rotation = -Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
    }
    var tempRotation = -rotation;
    var offsetRotation = tempRotation;
    if (tempRotation < 0) {
        tempRotation += 180;
    }
    if (tempRotation == 0) {
        tempRotation = 90;
    }
    if (tempRotation == 90) {
        tempRotation = 0;
    }
    //top/bottom меняются месятами в textStyle.baseline, textStyle.align
    width /= 1.1;
    if (vAlign === "top") {
        x = xm - width * Math.cos(offsetRotation * Math.PI / 180) + dY * Math.cos((90 - offsetRotation) * Math.PI / 180);
        y = ym + width * Math.sin(offsetRotation * Math.PI / 180) + dY * Math.sin((90 - offsetRotation) * Math.PI / 180);
    }
    if (vAlign === "middle") {
        x = xm;
        y = ym;
    }
    if (vAlign === "bottom") {
        x = xm - width * Math.cos(offsetRotation * Math.PI / 180) - dY * Math.sin((90 - tempRotation) * Math.PI / 180);
        y = ym + width * Math.sin(offsetRotation * Math.PI / 180) - dY * Math.cos((90 - tempRotation) * Math.PI / 180);
    }
    //переводим в радианы
    rotation = rotation * Math.PI / 180;
    return [x, y, rotation];
};




map.render.canvas.Replay.prototype.rotateLineText_old = function(p1, p2, width, height, vAlign, hAlign, mode, dX, dY, resolution, x, y){
    dY = height * LABEL_FONT_RATIO;
    var tempP = p1;
    var xf,yf,xm,ym;
    if(p1.x > p2.x){
        p1 = p2;
        p2 = tempP;
    }
    var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p1.x, p1.y]);
    x = pixelCoord[0];
    y = pixelCoord[1];
    var pixelCoordf = WidgetMap.map.getPixelFromCoordinate([p2.x, p2.y]);
    xf = pixelCoordf[0];
    yf = pixelCoordf[1];
    xm = (xf + x)/2;
    ym = (y + yf)/2;
    var rotation = 0;
    if (p1 !== null && p2 !== null){
        rotation = -Math.atan2(p2.y - p1.y, p2.x - p1.x)*180/Math.PI;
    }
    var tempRotation = -rotation;
    var offsetRotation = tempRotation;
    if(tempRotation < 0){
        tempRotation+=180;
    }
    if(tempRotation == 0){
        tempRotation = 90;
    }
    if(tempRotation == 90){
        tempRotation = 0;
    }
    //top/bottom меняются месятами в textStyle.baseline, textStyle.align
    width /= 1.1;
    if (vAlign === "top")
    {
        x = xm - width*Math.cos(offsetRotation*Math.PI/180) + dY * Math.cos((90-offsetRotation)*Math.PI/180);
        y = ym + width*Math.sin(offsetRotation*Math.PI/180) + dY * Math.sin((90-offsetRotation)*Math.PI/180);
    }
    if (vAlign === "middle")
    {
        x = xm;
        y = ym;
    }
    if (vAlign === "bottom")
    {
        x = xm - width*Math.cos(offsetRotation*Math.PI/180) - dY * Math.sin((90-tempRotation)*Math.PI/180);
        y = ym + width*Math.sin(offsetRotation*Math.PI/180) - dY * Math.cos((90-tempRotation)*Math.PI/180);

    }
    //доп проверка. если по горизонтали center и поворот 0, тьо возвращаем центр линии. Дальше, если слова с переносами,
    //то для них высчитываем новое начало подписи дл якаждого перноса
    if(tempRotation == 0 && hAlign === 'center'){
        x = xm;
    }

    //переводим в радианы
    rotation = rotation*Math.PI/180;
    return [x, y, rotation];
};

map.render.canvas.Replay.prototype.isPlaceFree = function(feature, width, height, x, y, isSpreaded){
    if(isSpreaded)
        return true;
    var lSpacing = feature.get('spacing');
    if (lSpacing == '')
        lSpacing = 'point';
    if (!this.hasCollision_(feature,width, height, x, y, feature.get('zIndex'), lSpacing))
        return true;
    return false;
};

map.render.canvas.Replay.prototype.takePlace = function(feature, width, height, x, y){
    var lSpacing = feature.get('spacing');
    if (lSpacing == '')
        lSpacing = 'point';
    try{
        this.addObject_(feature, width, height, x, y, false, feature.get('zIndex'), lSpacing);
    }
    catch(err){
        //console.log(err);
    }
};


/**
 * @protected
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.Feature} feature Feature.
 */
map.render.canvas.Replay.prototype.beginGeometry = function(geometry, feature) {
    this.beginGeometryInstruction1_ =
        [ol.render.canvas.Instruction.BEGIN_GEOMETRY, feature, 0];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ =
        [ol.render.canvas.Instruction.BEGIN_GEOMETRY, feature, 0];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
};


/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {goog.vec.Mat4.Number} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 * @param {Array.<*>} instructions Instructions array.
 * @param {function(ol.Feature): T|undefined} featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
map.render.canvas.Replay.prototype.replay_ = function(
    context, pixelRatio, transform, viewRotation, skippedFeaturesHash,
    instructions, featureCallback, opt_hitExtent) {
    /** @type {Array.<number>} */
    var pixelCoordinates;
    if (ol.vec.Mat4.equals2D(transform, this.renderedTransform_)) {
        pixelCoordinates = this.pixelCoordinates_;
    } else {
        pixelCoordinates = ol.geom.flat.transform.transform2D(
            this.coordinates, 0, this.coordinates.length, 2,
            transform, this.pixelCoordinates_);
        goog.vec.Mat4.setFromArray(this.renderedTransform_, transform);
        goog.asserts.assert(pixelCoordinates === this.pixelCoordinates_,
            'pixelCoordinates should be the same as this.pixelCoordinates_');
    }

    var i = 0; // instruction index
    var ii = instructions.length; // end of instructions
    var d = 0; // data index
    var dd; // end of per-instruction data
    var styleArr = [];
    var shiftParams = {lineWidth: 1, duplicate: 1};
    var localTransform = this.tmpLocalTransform_;
    _TRANSFORM =localTransform;
    while (i < ii) {
        var instruction = instructions[i];
        var type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);
        var feature, fill, stroke, text, x, y, geometry, lineStringId,textStyle,lLen,coords, lLenPixel;
        switch (type) {
            case ol.render.canvas.Instruction.BEGIN_GEOMETRY:

                feature = /** @type {ol.Feature} */ (instruction[1]);
                if(_CURRENT_RENDERED_LAYERS.indexOf(feature.get('layerId'))==-1)
                    _CURRENT_RENDERED_LAYERS.push(feature.get('layerId'));//закидываем в массив текущие отрендеренные слои
                var featureUid = goog.getUid(feature).toString();
                if (goog.isDef(skippedFeaturesHash[featureUid])) {
                    i = /** @type {number} */ (instruction[2]);
                } else if (goog.isDef(opt_hitExtent) && !ol.extent.intersects(
                    opt_hitExtent, feature.getGeometry().getExtent())) {
                    i = /** @type {number} */ (instruction[2]);
                } else {
                    ++i;
                }
                break;
            case ol.render.canvas.Instruction.BEGIN_PATH:
                context.beginPath();
                ++i;
                break;
            case ol.render.canvas.Instruction.CIRCLE:
                goog.asserts.assert(goog.isNumber(instruction[1]),
                    'second instruction should be a number');
                d = /** @type {number} */ (instruction[1]);
                var x1 = pixelCoordinates[d];
                var y1 = pixelCoordinates[d + 1];
                var x2 = pixelCoordinates[d + 2];
                var y2 = pixelCoordinates[d + 3];
                var dx = x2 - x1;
                var dy = y2 - y1;
                var r = Math.sqrt(dx * dx + dy * dy);
                context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                ++i;
                break;
            case ol.render.canvas.Instruction.CLOSE_PATH:
                context.closePath();
                ++i;
                break;
            case ol.render.canvas.Instruction.DRAW_IMAGE:
                goog.asserts.assert(goog.isNumber(instruction[1]),
                    'second instruction should be a number');
                d = /** @type {number} */ (instruction[1]);
                goog.asserts.assert(goog.isNumber(instruction[2]),
                    'third instruction should be a number');
                dd = /** @type {number} */ (instruction[2]);
                var image =  /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */
                    (instruction[3]);
                // Remaining arguments in DRAW_IMAGE are in alphabetical order
                var anchorX = /** @type {number} */ (instruction[4]) * pixelRatio;
                var anchorY = /** @type {number} */ (instruction[5]) * pixelRatio;
                var height = /** @type {number} */ (instruction[6]);
                var opacity = /** @type {number} */ (instruction[7]);
                var originX = /** @type {number} */ (instruction[8]);
                var originY = /** @type {number} */ (instruction[9]);
                var rotateWithView = /** @type {boolean} */ (instruction[10]);
                var rotation = /** @type {number} */ (instruction[11]);
                var scale = /** @type {number} */ (instruction[12]);
                var snapToPixel = /** @type {boolean} */ (instruction[13]);
                var width = /** @type {number} */ (instruction[14]);
                if (rotateWithView) {
                    rotation += viewRotation;
                }
                var lId = feature.get('layerId');
                var lay = WidgetMap.layerManager.getLayerByName(lId);
                var mapZoom = WidgetMap.map.getView().getZoom();
                var layerId = feature.get('labelType');
                var g = 0;
                var baseD = d;
                var kapWidth = this.getPointWidth(lay.id);
                width += kapWidth;
                height += kapWidth;

                if(GLOBAL_REDRAW[layerId] == false && goog.isDef(layerId)){
                    for (g; g < GLOBAL_REDRAW_ARR[layerId].length; g++) {
                        x = pixelCoordinates[GLOBAL_REDRAW_ARR[layerId][g]] - anchorX;
                        y = pixelCoordinates[GLOBAL_REDRAW_ARR[layerId][g] + 1] - anchorY;
                        x -= kapWidth/2;
                        y -= kapWidth/2;
                        if (snapToPixel) {
                            x = (x + 0.5) | 0;
                            y = (y + 0.5) | 0;
                        }
                        if (scale != 1 || rotation !== 0) {
                            var centerX = x + anchorX;
                            var centerY = y + anchorY;
                            ol.vec.Mat4.makeTransform2D(
                                localTransform, centerX, centerY, scale, scale,
                                rotation, -centerX, -centerY);
                            context.setTransform(
                                goog.vec.Mat4.getElement(localTransform, 0, 0),
                                goog.vec.Mat4.getElement(localTransform, 1, 0),
                                goog.vec.Mat4.getElement(localTransform, 0, 1),
                                goog.vec.Mat4.getElement(localTransform, 1, 1),
                                goog.vec.Mat4.getElement(localTransform, 0, 3),
                                goog.vec.Mat4.getElement(localTransform, 1, 3));
                        }
                        var alpha = context.globalAlpha;
                        if (opacity != 1) {
                            context.globalAlpha = alpha * opacity;
                        }
                        context.drawImage(image, x, y, width, height);

                        if (opacity != 1) {
                            context.globalAlpha = alpha;
                        }
                        if (scale != 1 || rotation !== 0) {
                            context.setTransform(1, 0, 0, 1, 0, 0);
                        }
                    }
                }
                else{
                    for (; d < dd; d += 2) {
                        x = pixelCoordinates[d] - anchorX;
                        y = pixelCoordinates[d + 1] - anchorY;
                        x -= kapWidth/2;
                        y -= kapWidth/2;
                        if (snapToPixel) {
                            x = (x + 0.5) | 0;
                            y = (y + 0.5) | 0;
                        }
                        //является ли точка смещенной относительно базовой
                        var isSpreaded = false;

                        if(goog.isDef(layerId) && GLOBAL_REDRAW[layerId] == true){
                            if(lay && lay.id === 'KAP_REMONT_PLAN' && mapZoom >= 8){
                                var geoExtent = [x, y, x + width, y + height];
                                var geoExtentStr = ''+geoExtent[0]+','+geoExtent[1]+','+geoExtent[2]+','+geoExtent[3]; // используем для ключа и поиска
                                if(!_GEO_EXTENTS[geoExtentStr]) {
                                    _GEO_EXTENTS[geoExtentStr] = {duplicate: 1}
                                }
                                else{ // нашли ключ, то увеличиваем счетчик
                                    _GEO_EXTENTS[geoExtentStr].duplicate++;
                                }
                                duplicate = _GEO_EXTENTS[geoExtentStr].duplicate;
                                isSpreaded = duplicate > 1;
                                y += (duplicate - 1) * height;
                            }
                            else{
                                if(!this.isPlaceFree(feature, width, height, x ,y, isSpreaded)){
                                    continue;
                                }
                            }

                            if (scale != 1 || rotation !== 0) {
                                var centerX = x + anchorX;
                                var centerY = y + anchorY;
                                ol.vec.Mat4.makeTransform2D(
                                    localTransform, centerX, centerY, scale, scale,
                                    rotation, -centerX, -centerY);
                                context.setTransform(
                                    goog.vec.Mat4.getElement(localTransform, 0, 0),
                                    goog.vec.Mat4.getElement(localTransform, 1, 0),
                                    goog.vec.Mat4.getElement(localTransform, 0, 1),
                                    goog.vec.Mat4.getElement(localTransform, 1, 1),
                                    goog.vec.Mat4.getElement(localTransform, 0, 3),
                                    goog.vec.Mat4.getElement(localTransform, 1, 3));
                            }
                            var alpha = context.globalAlpha;
                            if (opacity != 1) {
                                context.globalAlpha = alpha * opacity;
                            }
                            this.takePlace(feature, width, height, x ,y);
                            if(goog.isDef(layerId)) {
                                //GLOBAL_REDRAW_ARR[layerId].push({x:this.coordinates[d],y:this.coordinates[d+1]});
                                if(lay && lay.id === 'KAP_REMONT_PLAN' && mapZoom >= 8){
                                    GLOBAL_REDRAW_ARR[layerId].push(d - baseD);
                                }
                                else{
                                    GLOBAL_REDRAW_ARR[layerId].push(d);
                                }

                            }
                            if(goog.isDef(lay))
                                lay.layer.featureProjLayer.getSource().hasGeometryInExtent = true;


                            context.drawImage(image, x, y, width, height);
                            if (opacity != 1) {
                                context.globalAlpha = alpha;
                            }
                            if (scale != 1 || rotation !== 0) {
                                context.setTransform(1, 0, 0, 1, 0, 0);
                            }
                        }
                        else{
                            if (scale != 1 || rotation !== 0) {
                                var centerX = x + anchorX;
                                var centerY = y + anchorY;
                                ol.vec.Mat4.makeTransform2D(
                                    localTransform, centerX, centerY, scale, scale,
                                    rotation, -centerX, -centerY);
                                context.setTransform(
                                    goog.vec.Mat4.getElement(localTransform, 0, 0),
                                    goog.vec.Mat4.getElement(localTransform, 1, 0),
                                    goog.vec.Mat4.getElement(localTransform, 0, 1),
                                    goog.vec.Mat4.getElement(localTransform, 1, 1),
                                    goog.vec.Mat4.getElement(localTransform, 0, 3),
                                    goog.vec.Mat4.getElement(localTransform, 1, 3));
                            }
                            var alpha = context.globalAlpha;
                            if (opacity != 1) {
                                context.globalAlpha = alpha * opacity;
                            }
                            //console.log('#lId='+ lId+' width='+width+' height='+height);
                            context.drawImage(image, x, y, width, height);
                            if (opacity != 1) {
                                context.globalAlpha = alpha;
                            }
                            if (scale != 1 || rotation !== 0) {
                                context.setTransform(1, 0, 0, 1, 0, 0);
                            }
                        }
                    }
                }
                GLOBAL_REDRAW[feature.get('labelType')] = false;
                ++i;
                break;
            case ol.render.canvas.Instruction.DRAW_TEXT:
                goog.asserts.assert(goog.isNumber(instruction[1]),
                    '2nd instruction should be a number');
                d = /** @type {number} */ (instruction[1]);
                goog.asserts.assert(goog.isNumber(instruction[2]),
                    '3rd instruction should be a number');
                dd = /** @type {number} */ (instruction[2]);
                goog.asserts.assert(goog.isString(instruction[3]),
                    '4th instruction should be a number');
                text = /** @type {string} */ (instruction[3]);
                goog.asserts.assert(goog.isNumber(instruction[4]),
                    '5th instruction should be a number');
                var offsetX = /** @type {number} */ (instruction[4]) * pixelRatio;
                goog.asserts.assert(goog.isNumber(instruction[5]),
                    '6th instruction should be a number');
                var offsetY = /** @type {number} */ (instruction[5]) * pixelRatio;
                goog.asserts.assert(goog.isNumber(instruction[6]),
                    '7th instruction should be a number');
                rotation = /** @type {number} */ (instruction[6]);
                goog.asserts.assert(goog.isNumber(instruction[7]),
                    '8th instruction should be a number');
                scale = /** @type {number} */ (instruction[7]) * pixelRatio;
                goog.asserts.assert(goog.isBoolean(instruction[8]),
                    '9th instruction should be a boolean');
                fill = /** @type {boolean} */ (instruction[8]);
                goog.asserts.assert(goog.isBoolean(instruction[9]),
                    '10th instruction should be a boolean');
                stroke = /** @type {boolean} */ (instruction[9]);

                geometry = /** @type {MultiLineString|LineString} */ (instruction[10]);
                lineStringId = /** @type {MultiLineString|LineString} */ (instruction[11]);
                textStyle = /** @type {MultiLineString|LineString} */ (instruction[12]);
                lLen = /** @type {MultiLineString|LineString} */ (instruction[13]);
                coords = /** @type {MultiLineString|LineString} */ (instruction[14]);

                lLenPixel = /** @type {MultiLineString|LineString} */ (instruction[15]);
                var duplicate = /** @type {number} */ (instruction[16]);
                var isKapRemont = /** @type {boolean} */ (instruction[17] === true);
                if(lLenPixel === undefined)
                    lLenPixel = lLen;
                var mapZoom = WidgetMap.map.getView().getZoom();
                var lId = feature.get('layerId');
                var lay = WidgetMap.layerManager.getLayerByName(lId);
                isKapRemont = (lay && lay.id === 'KAP_REMONT_PLAN')
                var layerId = feature.get('labelType');
                var overlap = '0';
                var layerGeoType = geometry.getType();
                var shift = undefined;
                var strokeColor = "#fff";
                try{
                    if(isKapRemont){
                        strokeColor = "rgba(0,0,0,0.75)";
                        shift = lay.layer.semanticShiftData[geometry.extent_.toString()];
                    }
                }
                catch(ex){ }
                if(layerGeoType == 'MultiPolygon'){
                    for (; d < dd; d += 2) {
                        x = pixelCoordinates[d] + offsetX;
                        y = pixelCoordinates[d + 1] + offsetY;
                        if (scale != 1 || rotation !== 0) {
                            ol.vec.Mat4.makeTransform2D(
                                localTransform, x, y, scale, scale, rotation, -x, -y);
                            context.setTransform(
                                goog.vec.Mat4.getElement(localTransform, 0, 0),
                                goog.vec.Mat4.getElement(localTransform, 1, 0),
                                goog.vec.Mat4.getElement(localTransform, 0, 1),
                                goog.vec.Mat4.getElement(localTransform, 1, 1),
                                goog.vec.Mat4.getElement(localTransform, 0, 3),
                                goog.vec.Mat4.getElement(localTransform, 1, 3));
                        }
                        if (stroke) {
                            context.strokeText(text, x, y);
                        }
                        if (fill) {
                            context.fillText(text, x, y);
                        }
                        if (scale != 1 || rotation !== 0) {
                            context.setTransform(1, 0, 0, 1, 0, 0);
                        }
                    }
                }
                else if(layerGeoType == 'LineString'){
                    var MAX_FONT_SIZE = 38;
                    var MIN_FONT_SIZE = 4;
                    var tf = textStyle.getFont();
                    var splittedText = [text];
                    var tHeight = 13;
                    var ccr = [];
                    ccr = ol.geom.flat.transform.transform2D(
                        coords, 0,coords.length, 2,
                        transform, ccr);
                    x = ccr[0];
                    y = ccr[1];
                    var defaultZoom = 11;
                    if(WidgetMap.DEFALT_ZOOM_FOR_FONT !== undefined)
                        defaultZoom = WidgetMap.DEFALT_ZOOM_FOR_FONT;
                    if(tf.indexOf(' -1px ')!=-1 && goog.isDef(lLen )){
                        // нужно расчитать высоту шрифта
                        splittedText = text.split('\\n');
                        //удаляем последнимй элемент, есди \n в конце стоит
                        if(splittedText[splittedText.length-1]=='')
                            splittedText.splice(splittedText.length-1);
                        //upd. 17.08.21 принято решение убрать учитывание переносов при расчете размера шрифта
                        //в рамках инцидента от Габасовой "Надписи наименований цехов не читаемы" на техсхеме
                        //делаем это для всех техсхем
                        var fs = lLen * LABEL_FONT_RATIO;///splittedText.length;
                        if (fs < MIN_FONT_SIZE){
                            text = '';
                            splittedText = [text];
                            fs = MIN_FONT_SIZE;
                        }

                        fs = parseInt(fs);
                        tHeight = fs*13/11;
                        tf = tf.replace(' -1px ',' '+fs+'px ');
                        //TODO разбить по элементам, вычислить шрифт и вычислить отступы
                    }
                    if(tf.indexOf(' -3px ')!=-1 && goog.isDef(lLen )){
                        // нужно расчитать высоту шрифта
                        var charCount = text.length;
                        var lineLength = lLenPixel;
                        var charSize = lineLength/charCount;
                        var fontSize = GeoUtil.getFontSizeByCharWidth(charSize);
                        tf = tf.replace(' -3px ',' '+fontSize+'px ');
                    }

                    if(splittedText.length==1){
                        text = text.replace('\\n','');
                        var textWidth = context.measureText(text).width - 5;
                        context.font = tf;
                        if (scale != 1 || rotation !== 0) {
                            ol.vec.Mat4.makeTransform2D(
                                localTransform, x, y, scale, scale, rotation, -x, -y);
                            context.setTransform(
                                goog.vec.Mat4.getElement(localTransform, 0, 0),
                                goog.vec.Mat4.getElement(localTransform, 1, 0),
                                goog.vec.Mat4.getElement(localTransform, 0, 1),
                                goog.vec.Mat4.getElement(localTransform, 1, 1),
                                goog.vec.Mat4.getElement(localTransform, 0, 3),
                                goog.vec.Mat4.getElement(localTransform, 1, 3));
                        }
                        if (stroke) {
                            //context.lineWidth = 2;
                            context.strokeStyle = strokeColor;//obj.textStyle.getStroke().getColor();
                            context.strokeText(text, x, y);
                        }
                        if (fill) {
                            context.fillStyle = textStyle.getFill().getColor();
                            context.fillText(text, x, y);
                        }
                        if (scale != 1 || rotation !== 0) {
                            context.setTransform(1, 0, 0, 1, 0, 0);
                        }
                    }
                    else{
                        var sp = splittedText.length-1;
                        context.font = tf;
                        var coeff = 0;
                        for(sp;sp>=0;sp--){
                            var newY = y-(tHeight)*coeff++;
                            var newX = x;
                            var spText = splittedText[sp];
                            if(spText == ''){
                                coeff--;
                                continue;
                            }
                            if (scale != 1 || rotation !== 0) {
                                ol.vec.Mat4.makeTransform2D(
                                    localTransform, x, y, scale, scale, rotation, -x, -y);
                                context.setTransform(
                                    goog.vec.Mat4.getElement(localTransform, 0, 0),
                                    goog.vec.Mat4.getElement(localTransform, 1, 0),
                                    goog.vec.Mat4.getElement(localTransform, 0, 1),
                                    goog.vec.Mat4.getElement(localTransform, 1, 1),
                                    goog.vec.Mat4.getElement(localTransform, 0, 3),
                                    goog.vec.Mat4.getElement(localTransform, 1, 3));
                            }
                            if (stroke) {
                                //context.lineWidth = 2;
                                //context.strokeStyle = strokeColor//obj.textStyle.getStroke().getColor();
                                context.strokeText(spText, newX, newY);
                            }
                            if (fill) {
                                context.fillStyle = textStyle.getFill().getColor();
                                context.fillText(spText, newX, newY);
                            }
                            if (scale != 1 || rotation !== 0) {
                                context.setTransform(1, 0, 0, 1, 0, 0);
                            }
                        }
                    }
                }
                //если подпись для точечного объекта
                else{
                    var lay = WidgetMap.layerManager.getLayerByName(feature.get('layerId'));
                    var featureStyle = WidgetMap.layerManager.getStyleByNameAndType(feature.get('type'),'Point');
                    var pointWidth = (featureStyle)? featureStyle.getImage().getSize()[0]:16;
                    var pointHeight = (featureStyle)? featureStyle.getImage().getSize()[1]:16;
                    if(goog.isDef(lay) && lay.isTextAllow == false){
                        ++i;
                        break;
                    }
                    overlap = WidgetMap.layerManager.getTextOverlapByNameAndType(feature.get('type'),'Point');
                    var g = 0;
                    //необходимо из общего массива zindex слоёв забирать те, которые выше, без оверлапа. Остальные подписи у слоёв игнорируем
                    //сначала пройтис по матрице и выставить всё в корректном порядке
                    if(GLOBAL_REDRAW[layerId] == false && goog.isDef(layerId)){
                        //иначе забираем из матрицы подпись
                        for (g; g < GLOBAL_REDRAW_ARR[layerId].length; g++) {
                            //text = _labels[feature.get('labelType')][GLOBAL_REDRAW_ARR[layerId][g]/2];
                            //делаем поправку на d и dd, т.е. в мультифиче все геометрии в одном массиве со смещением для каждой фиче
                            var position = (GLOBAL_REDRAW_ARR[layerId][g])/2;
                            //поправил, т.к. некоторые слои типа водных переходов имеют фичи и точки и полигоны и не находит корректно позицию
                            var newpos = (position-d/2)<0?position:(position-d/2);
                            if(isKapRemont){
                                position = (GLOBAL_REDRAW_ARR[layerId][g])/2;// позиция в списке
                                //var newpos = (position-d/2)<0?position:(position-d/2);
                                newpos = g;
                            }
                            text = feature.get('labelsObj')[newpos]; //globalPointsLabels_[feature.get('labelType')][newpos];//-d/2
                            //text = globalPointsLabels_[feature.get('labelType')][GLOBAL_REDRAW_ARR[layerId][g]/2];
                            //text = globalPointsLabels_[feature.get('labelType')][GLOBAL_REDRAW_ARR[layerId][g].x+'_'+GLOBAL_REDRAW_ARR[layerId][g].y];
                            if(!goog.isDefAndNotNull(text))
                                continue;
                            if(goog.isNull(text.label))
                                continue;
                            var offs = (position-d/2)<0?d:0;
                            if(isKapRemont){
                                var p = (text && text.geo)?text.geo.flatCoordinates:null;
                                if(p === null )
                                    text.label = ''
                                try{
                                    if(!p){
                                        //значит имеем дело с фичей и объект выделили на карте
                                        p = text.geo.getGeometry().flatCoordinates;
                                    }
                                    var pixelCoordinate = WidgetMap.map.getPixelFromCoordinate(p);
                                    x = pixelCoordinate[0] + offsetX;
                                    y = pixelCoordinate[1] + offsetY;
                                }
                                catch(ex){
                                }
                            }
                            else{
                                x = pixelCoordinates[GLOBAL_REDRAW_ARR[layerId][g]+offs] + offsetX;
                                y = pixelCoordinates[GLOBAL_REDRAW_ARR[layerId][g]+offs+1] + offsetY;
                            }
                            text = text.label;
                            var isSpreaded = false;
                            if(isKapRemont && mapZoom >= 8){
                                isSpreaded = true; //для капремонтов рисуем всегда подписи
                                overlap = '1';
                                var geoExtent = [x, y, x + pointWidth, y + pointHeight];
                                var geoExtentStr = ''+geoExtent[0]+','+geoExtent[1]+','+geoExtent[2]+','+geoExtent[3];
                                if(!_TEXT_EXTENTS[geoExtentStr])
                                    _TEXT_EXTENTS[geoExtentStr] = 1;
                                else{ // нашли ключ, то увеличиваем счетчик
                                    _TEXT_EXTENTS[geoExtentStr]++;
                                }
                                duplicate = _TEXT_EXTENTS[geoExtentStr];
                                y += (duplicate - 1) * pointHeight;
                            }
                            //если только начали двигать, то закидываем в матрицу и рисуем
                            if(GLOBAL_LABEL_REDRAW[feature.get('labelType')] == true){
                                //если overlap=true, то подпись рисуется без разрядки всегда
                                var canAdd = false;
                                var addedObj = undefined;//объект с добавленными данными
                                if(overlap == '1'){
                                    addedObj = this.addTextPointObject_(feature,context.measureText(text).width, 13,this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]], this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]+1], x, y, feature.get('zIndex'),'label',false,text);
                                    canAdd = true;
                                }
                                else{
                                    //заносим в матрицу
                                    //предварительно корректируем x,y в зависимости от align и baseline
                                    var textWidth = context.measureText(text).width-10;
                                    var collX = x;
                                    var collY = y;
                                    if(!this.hasTextPointCollision_(feature,textWidth, 12, collX, collY, feature.get('zIndex'))){
                                        addedObj = this.addTextPointObject_(feature,textWidth, 12, this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]], this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]+1],x,y, feature.get('zIndex'));
                                        canAdd = true;
                                    }
                                }
                                if(canAdd == true){
                                    //сохраняем в _LABELS
                                    _LABELS.push({type:'point',unique:addedObj,text:text,textStyle:textStyle,coordX:this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]],coordY:this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]+1],x:x,y:y,scale:scale,rotation:0, context:context, localTransform:localTransform, fill:fill, stroke:stroke});
                                    if(textStyle.getTextAlign() == 'right'){
                                        collX = x - textWidth;
                                    }
                                    if(textStyle.getTextBaseline() == 'bottom'){
                                        collY = y - 13;
                                    }
                                    if (stroke) {
                                        context.strokeStyle = strokeColor;
                                        context.strokeText(text, x, y);
                                    }
                                    if (fill) {
                                        context.fillText(text, x, y);
                                    }
                                }
                            }
                        }
                        GLOBAL_LABEL_REDRAW[feature.get('labelType')] = false;
                    }
                    else{
                        for (; d < dd; d += 2) {
                            x = pixelCoordinates[d] + offsetX;
                            y = pixelCoordinates[d + 1] + offsetY;
                            if (scale != 1 || rotation !== 0) {
                                ol.vec.Mat4.makeTransform2D(
                                    localTransform, x, y, scale, scale, rotation, -x, -y);
                                context.setTransform(
                                    goog.vec.Mat4.getElement(localTransform, 0, 0),
                                    goog.vec.Mat4.getElement(localTransform, 1, 0),
                                    goog.vec.Mat4.getElement(localTransform, 0, 1),
                                    goog.vec.Mat4.getElement(localTransform, 1, 1),
                                    goog.vec.Mat4.getElement(localTransform, 0, 3),
                                    goog.vec.Mat4.getElement(localTransform, 1, 3));
                            }

                            if (stroke) {
                                context.strokeStyle = strokeColor;
                                context.strokeText(text, x, y);
                            }
                            if (fill) {
                                context.fillText(text, x, y);
                            }
                            if (scale != 1 || rotation !== 0) {
                                context.setTransform(1, 0, 0, 1, 0, 0);
                            }
                        }
                    }
                }
                ++i;
                break;
            case ol.render.canvas.Instruction.END_GEOMETRY:
                if (goog.isDef(featureCallback)) {
                    feature = /** @type {ol.Feature} */ (instruction[1]);
                    var result = featureCallback(feature);
                    if (result) {
                        return result;
                    }
                }
                ++i;
                break;
            case ol.render.canvas.Instruction.FILL:
                context.fill();
                ++i;
                break;
            case ol.render.canvas.Instruction.MOVE_TO_LINE_TO:
                goog.asserts.assert(goog.isNumber(instruction[1]),
                    '2nd instruction should be a number');
                d = /** @type {number} */ (instruction[1]);
                goog.asserts.assert(goog.isNumber(instruction[2]),
                    '3rd instruction should be a number');
                dd = /** @type {number} */ (instruction[2]);
                styleArr = (instruction[3]);
                shiftParams = (instruction[4]);
                var td = d;
                var duplicate = (shiftParams && shiftParams.duplicate) ? shiftParams.duplicate : 1;
                var lineWidth = (shiftParams && shiftParams.duplicate) ? shiftParams.lineWidth : 1;
                var layName = duplicate > 0 ? 'KAP_REMONT_PLAN' : '';
                var kapWidth = this.getLineWidth(layName);

                context.beginPath();
                //забираем стиль у первого элемента массива,
                if(goog.isDef(styleArr) && styleArr.length>1){
                    context.strokeStyle = styleArr[0].getStroke().getColor();
                    context.lineWidth = styleArr[0].getStroke().getWidth() + kapWidth;
                }
                var yPixel = pixelCoordinates[d + 1];
                yPixel = yPixel + (duplicate - 1) * lineWidth;
                context.moveTo(pixelCoordinates[d], yPixel);
                for (d += 2; d < dd; d += 2) {
                    yPixel = pixelCoordinates[d + 1];
                    yPixel = yPixel + (duplicate - 1) * lineWidth;
                    context.lineTo(pixelCoordinates[d], yPixel);
                }
                context.stroke();

                if(goog.isDef(styleArr) && styleArr.length>1){
                    var sa = 1;
                    for(sa;sa<styleArr.length;sa++){
                        //stub
                        context.beginPath();
                        var ted = td;
                        context.strokeStyle = styleArr[sa].getStroke().getColor();
                        context.lineWidth = styleArr[sa].getStroke().getWidth() + kapWidth;
                        var subYPixel = pixelCoordinates[ted + 1];
                        subYPixel = subYPixel + (duplicate - 1) * lineWidth;
                        context.moveTo(pixelCoordinates[ted], subYPixel);
                        for (ted += 2; ted < dd; ted += 2) {
                            subYPixel = pixelCoordinates[ted + 1];
                            subYPixel = subYPixel + (duplicate - 1) * lineWidth;
                            context.lineTo(pixelCoordinates[ted],  subYPixel);
                        }
                        context.stroke();
                        //end stub
                    }
                }
                ++i;
                break;
            case ol.render.canvas.Instruction.SET_FILL_STYLE:
                goog.asserts.assert(goog.isString(instruction[1]),
                    '2nd instruction should be a string');
                context.fillStyle = /** @type {string} */ (instruction[1]);
                ++i;
                break;
            case ol.render.canvas.Instruction.SET_STROKE_STYLE:
                goog.asserts.assert(goog.isString(instruction[1]),
                    '2nd instruction should be a string');
                goog.asserts.assert(goog.isNumber(instruction[2]),
                    '3rd instruction should be a number');
                goog.asserts.assert(goog.isString(instruction[3]),
                    '4rd instruction should be a string');
                goog.asserts.assert(goog.isString(instruction[4]),
                    '5th instruction should be a string');
                goog.asserts.assert(goog.isNumber(instruction[5]),
                    '6th instruction should be a number');
                goog.asserts.assert(!goog.isNull(instruction[6]),
                    '7th instruction should not be null');
                var usePixelRatio = goog.isDef(instruction[7]) ? instruction[7] : true;
                var lineWidth = /** @type {number} */ (instruction[2]);
                context.strokeStyle = /** @type {string} */ (instruction[1]);
                context.lineWidth = usePixelRatio ? lineWidth * pixelRatio : lineWidth;
                context.lineCap = /** @type {string} */ (instruction[3]);
                context.lineJoin = /** @type {string} */ (instruction[4]);
                context.miterLimit = /** @type {number} */ (instruction[5]);
                if (ol.has.CANVAS_LINE_DASH) {//http://jsfiddle.net/MPg5X/1/
                    context.setLineDash(/** @type {Array.<number>} */ (instruction[6]));
                }
                ++i;
                break;
            case ol.render.canvas.Instruction.SET_TEXT_STYLE:
                goog.asserts.assert(goog.isString(instruction[1]),
                    '2nd instruction should be a string');
                goog.asserts.assert(goog.isString(instruction[2]),
                    '3rd instruction should be a string');
                goog.asserts.assert(goog.isString(instruction[3]),
                    '4th instruction should be a string');
                context.font = /** @type {string} */ (instruction[1]);
                context.textAlign = /** @type {string} */ (instruction[2]);


                context.textBaseline = /** @type {string} */ (instruction[3]);
                ++i;
                break;
            case ol.render.canvas.Instruction.STROKE:
                context.stroke();
                ++i;
                break;
            default:
                goog.asserts.fail('Unknown canvas render instruction');
                ++i; // consume the instruction anyway, to avoid an infinite loop
                break;
        }
    }
    // assert that all instructions were consumed
    goog.asserts.assert(i == instructions.length,
        'all instructions should be consumed');
    return undefined;
};


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {goog.vec.Mat4.Number} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object} skippedFeaturesHash Ids of features to skip
 */
map.render.canvas.Replay.prototype.replay = function(
    context, pixelRatio, transform, viewRotation, skippedFeaturesHash) {
    var instructions = this.instructions;
    this.replay_(context, pixelRatio, transform, viewRotation,
        skippedFeaturesHash, instructions, undefined);
};


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {goog.vec.Mat4.Number} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object} skippedFeaturesHash Ids of features to skip
 * @param {function(ol.Feature): T=} opt_featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
map.render.canvas.Replay.prototype.replayHitDetection = function(
    context, transform, viewRotation, skippedFeaturesHash,
    opt_featureCallback, opt_hitExtent) {
    var instructions = this.hitDetectionInstructions;
    return this.replay_(context, 1, transform, viewRotation,
        skippedFeaturesHash, instructions, opt_featureCallback, opt_hitExtent);
};


/**
 * @private
 */
map.render.canvas.Replay.prototype.reverseHitDetectionInstructions_ =
    function() {
        var hitDetectionInstructions = this.hitDetectionInstructions;
        // step 1 - reverse array
        hitDetectionInstructions.reverse();
        // step 2 - reverse instructions within geometry blocks
        var i;
        var n = hitDetectionInstructions.length;
        var instruction;
        var type;
        var begin = -1;
        for (i = 0; i < n; ++i) {
            instruction = hitDetectionInstructions[i];
            type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);
            if (type == ol.render.canvas.Instruction.END_GEOMETRY) {
                goog.asserts.assert(begin == -1, 'begin should be -1');
                begin = i;
            } else if (type == ol.render.canvas.Instruction.BEGIN_GEOMETRY) {
                instruction[2] = i;
                goog.asserts.assert(begin >= 0,
                    'begin should be larger than or equal to 0');
                ol.array.reverseSubArray(this.hitDetectionInstructions, begin, i);
                begin = -1;
            }
        }
    };


/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.Feature} feature Feature.
 */
map.render.canvas.Replay.prototype.endGeometry = function(geometry, feature) {
    goog.asserts.assert(!goog.isNull(this.beginGeometryInstruction1_),
        'this.beginGeometryInstruction1_ should not be null');
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    goog.asserts.assert(!goog.isNull(this.beginGeometryInstruction2_),
        'this.beginGeometryInstruction2_ should not be null');
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    var endGeometryInstruction =
        [ol.render.canvas.Instruction.END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
};


/**
 * FIXME empty description for jsdoc
 */
map.render.canvas.Replay.prototype.finish = goog.nullFunction;


/**
 * Get the buffered rendering extent.  Rendering will be clipped to the extent
 * provided to the constructor.  To account for symbolizers that may intersect
 * this extent, we calculate a buffered extent (e.g. based on stroke width).
 * @return {ol.Extent} The buffered rendering extent.
 * @protected
 */
map.render.canvas.Replay.prototype.getBufferedMaxExtent = function() {
    return this.maxExtent;
};



/**
 * @constructor
 * @extends {map.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.ImageReplay = function(tolerance, maxExtent, resolution) {
    goog.base(this, tolerance, maxExtent, resolution);

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|Image}
     */
    this.hitDetectionImage_ = null;

    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|Image}
     */
    this.image_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.anchorY_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.height_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.opacity_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originX_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.originY_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.scale_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.snapToPixel_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.width_ = undefined;

};
goog.inherits(map.render.canvas.ImageReplay, map.render.canvas.Replay);


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} My end.
 */
map.render.canvas.ImageReplay.prototype.drawCoordinates_ =
    function(flatCoordinates, offset, end, stride) {
        return this.appendFlatCoordinates(
            flatCoordinates, offset, end, stride, false);
    };
map.render.canvas.ImageReplay.prototype.drawCoordinates1_ =
    function(flatCoordinates, offset, end, stride, labelType) {
        return this.appendNewFlatCoordinates(
            flatCoordinates, offset, end, stride, false);
    };


/**
 * @inheritDoc
 */
map.render.canvas.ImageReplay.prototype.drawPointGeometry =
    function(pointGeometry, feature) {
        if (goog.isNull(this.image_)) {
            return;
        }
        goog.asserts.assert(goog.isDef(this.anchorX_),
            'this.anchorX_ should be defined');
        goog.asserts.assert(goog.isDef(this.anchorY_),
            'this.anchorY_ should be defined');
        goog.asserts.assert(goog.isDef(this.height_),
            'this.height_ should be defined');
        goog.asserts.assert(goog.isDef(this.opacity_),
            'this.opacity_ should be defined');
        goog.asserts.assert(goog.isDef(this.originX_),
            'this.originX_ should be defined');
        goog.asserts.assert(goog.isDef(this.originY_),
            'this.originY_ should be defined');
        goog.asserts.assert(goog.isDef(this.rotateWithView_),
            'this.rotateWithView_ should be defined');
        goog.asserts.assert(goog.isDef(this.rotation_),
            'this.rotation_ should be defined');
        goog.asserts.assert(goog.isDef(this.scale_),
            'this.scale_ should be defined');
        goog.asserts.assert(goog.isDef(this.width_),
            'this.width_ should be defined');
        this.beginGeometry(pointGeometry, feature);
        var flatCoordinates = pointGeometry.getFlatCoordinates();
        var stride = pointGeometry.getStride();
        var myBegin = this.coordinates.length;
        var myEnd = this.drawCoordinates_(
            flatCoordinates, 0, flatCoordinates.length, stride);
        this.instructions.push([
            ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_, this.anchorY_, this.height_, this.opacity_,
            this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
            this.scale_, this.snapToPixel_, this.width_
        ]);
        this.hitDetectionInstructions.push([
            ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_, this.anchorY_, this.height_, this.opacity_,
            this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
            this.scale_, this.snapToPixel_, this.width_
        ]);
        this.endGeometry(pointGeometry, feature);
    };


/**
 * @inheritDoc
 */
map.render.canvas.ImageReplay.prototype.drawMultiPointGeometry =
    function(multiPointGeometry, feature, labelType) {
        if (goog.isNull(this.image_)) {
            return;
        }
        goog.asserts.assert(goog.isDef(this.anchorX_),
            'this.anchorX_ should be defined');
        goog.asserts.assert(goog.isDef(this.anchorY_),
            'this.anchorY_ should be defined');
        goog.asserts.assert(goog.isDef(this.height_),
            'this.height_ should be defined');
        goog.asserts.assert(goog.isDef(this.opacity_),
            'this.opacity_ should be defined');
        goog.asserts.assert(goog.isDef(this.originX_),
            'this.originX_ should be defined');
        goog.asserts.assert(goog.isDef(this.originY_),
            'this.originY_ should be defined');
        goog.asserts.assert(goog.isDef(this.rotateWithView_),
            'this.rotateWithView_ should be defined');
        goog.asserts.assert(goog.isDef(this.rotation_),
            'this.rotation_ should be defined');
        goog.asserts.assert(goog.isDef(this.scale_),
            'this.scale_ should be defined');
        goog.asserts.assert(goog.isDef(this.width_),
            'this.width_ should be defined');

        multiPointGeometry = feature.getGeometry();
        this.beginGeometry(multiPointGeometry, feature);
        var stride = multiPointGeometry.getStride();
        var flatCoordinates = multiPointGeometry.getFlatCoordinates();

        var myBegin = this.coordinates.length;
        var myEnd = this.drawCoordinates1_(
            flatCoordinates, 0, flatCoordinates.length, stride, labelType);
        this.instructions.push([
            ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_, this.anchorY_, this.height_, this.opacity_,
            this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
            this.scale_, this.snapToPixel_, this.width_
        ]);
        this.hitDetectionInstructions.push([
            ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd,
            this.hitDetectionImage_,
            // Remaining arguments to DRAW_IMAGE are in alphabetical order
            this.anchorX_, this.anchorY_, this.height_, this.opacity_,
            this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
            this.scale_, this.snapToPixel_, this.width_
        ]);
        this.endGeometry(multiPointGeometry, feature);
    };


/**
 * @inheritDoc
 */
map.render.canvas.ImageReplay.prototype.finish = function() {
    this.reverseHitDetectionInstructions_();
    // FIXME this doesn't really protect us against further calls to draw*Geometry
    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.snapToPixel_ = undefined;
    this.width_ = undefined;
};


/**
 * @inheritDoc
 */
map.render.canvas.ImageReplay.prototype.setImageStyle = function(imageStyle) {
    goog.asserts.assert(!goog.isNull(imageStyle),
        'imageStyle should not be null');
    var anchor = imageStyle.getAnchor();
    goog.asserts.assert(!goog.isNull(anchor), 'anchor should not be null');
    var size = imageStyle.getSize();
    goog.asserts.assert(!goog.isNull(size), 'size should not be null');
    var hitDetectionImage = imageStyle.getHitDetectionImage(1);
    goog.asserts.assert(!goog.isNull(hitDetectionImage),
        'hitDetectionImage should not be null');
    var image = imageStyle.getImage(1);
    goog.asserts.assert(!goog.isNull(image), 'image should not be null');
    var origin = imageStyle.getOrigin();
    goog.asserts.assert(!goog.isNull(origin), 'origin should not be null');
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = hitDetectionImage;
    this.image_ = image;
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScale();
    this.snapToPixel_ = imageStyle.getSnapToPixel();
    this.width_ = size[0];
};



/**
 * @constructor
 * @extends {map.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.LineStringReplay = function(tolerance, maxExtent, resolution) {

    goog.base(this, tolerance, maxExtent, resolution);

    /**
     * @private
     * @type {{currentStrokeStyle: (string|undefined),
     *         currentLineCap: (string|undefined),
     *         currentLineDash: Array.<number>,
     *         currentLineJoin: (string|undefined),
     *         currentLineWidth: (number|undefined),
     *         currentMiterLimit: (number|undefined),
     *         lastStroke: number,
     *         strokeStyle: (string|undefined),
     *         lineCap: (string|undefined),
     *         lineDash: Array.<number>,
     *         lineJoin: (string|undefined),
     *         lineWidth: (number|undefined),
     *         miterLimit: (number|undefined)}|null}
     */
    this.state_ = {
        currentStrokeStyle: undefined,
        currentLineCap: undefined,
        currentLineDash: null,
        currentLineJoin: undefined,
        currentLineWidth: undefined,
        currentMiterLimit: undefined,
        lastStroke: 0,
        strokeStyle: undefined,
        lineCap: undefined,
        lineDash: null,
        lineJoin: undefined,
        lineWidth: undefined,
        miterLimit: undefined
    };

};
goog.inherits(map.render.canvas.LineStringReplay, map.render.canvas.Replay);


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} end.
 */
map.render.canvas.LineStringReplay.prototype.drawFlatCoordinates_ =
    function(flatCoordinates, offset, end, stride) {
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatCoordinates(
            flatCoordinates, offset, end, stride, false);
        var moveToLineToInstruction =
            [ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
    };


map.render.canvas.LineStringReplay.prototype.drawLineFlatCoordinates_ =
    function(flatCoordinates, offset, end, stride, styleArr, offsetParams) {
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatCoordinates(
            flatCoordinates, offset, end, stride, false);
        var moveToLineToInstruction =
            [ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd, styleArr, offsetParams];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
    };


/**
 * @inheritDoc
 */
map.render.canvas.LineStringReplay.prototype.getBufferedMaxExtent = function() {
    if (goog.isNull(this.bufferedMaxExtent_)) {
        this.bufferedMaxExtent_ = ol.extent.clone(this.maxExtent);
        if (this.maxLineWidth > 0) {
            var width = this.resolution * (this.maxLineWidth + 1) / 2;
            ol.extent.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
        }
    }
    return this.bufferedMaxExtent_;
};


/**
 * @private
 */
map.render.canvas.LineStringReplay.prototype.setStrokeStyle_ = function() {
    var state = this.state_;
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;
    goog.asserts.assert(goog.isDef(strokeStyle),
        'strokeStyle should be defined');
    goog.asserts.assert(goog.isDef(lineCap), 'lineCap should be defined');
    goog.asserts.assert(!goog.isNull(lineDash), 'lineDash should not be null');
    goog.asserts.assert(goog.isDef(lineJoin), 'lineJoin should be defined');
    goog.asserts.assert(goog.isDef(lineWidth), 'lineWidth should be defined');
    goog.asserts.assert(goog.isDef(miterLimit), 'miterLimit should be defined');
    if (state.currentStrokeStyle != strokeStyle ||
        state.currentLineCap != lineCap ||
        !goog.array.equals(state.currentLineDash, lineDash) ||
        state.currentLineJoin != lineJoin ||
        state.currentLineWidth != lineWidth ||
        state.currentMiterLimit != miterLimit) {
        if (state.lastStroke != this.coordinates.length) {
            this.instructions.push(
                [ol.render.canvas.Instruction.STROKE]);
            state.lastStroke = this.coordinates.length;
        }
        this.instructions.push(
            [ol.render.canvas.Instruction.SET_STROKE_STYLE,
                strokeStyle, lineWidth, lineCap, lineJoin, miterLimit, lineDash],
            [ol.render.canvas.Instruction.BEGIN_PATH]);
        state.currentStrokeStyle = strokeStyle;
        state.currentLineCap = lineCap;
        state.currentLineDash = lineDash;
        state.currentLineJoin = lineJoin;
        state.currentLineWidth = lineWidth;
        state.currentMiterLimit = miterLimit;
    }
};


/**
 * @inheritDoc
 */
map.render.canvas.LineStringReplay.prototype.drawLineStringGeometry =
    function(lineStringGeometry, feature) {
        var state = this.state_;
        goog.asserts.assert(state, 'state should not be null');
        var strokeStyle = state.strokeStyle;
        var lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) {
            return;
        }
        this.setStrokeStyle_();
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push(
            [ol.render.canvas.Instruction.SET_STROKE_STYLE,
                state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
                state.miterLimit, state.lineDash],
            [ol.render.canvas.Instruction.BEGIN_PATH]);
        var flatCoordinates = lineStringGeometry.getFlatCoordinates();
        var stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(
            flatCoordinates, 0, flatCoordinates.length, stride);
        this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);
        this.endGeometry(lineStringGeometry, feature);
    };

//`[minx, miny, maxx, maxy]`.
//bottom - 1, top -3, left - 0, rigth -2
//left:Number = NaN, bottom:Number = NaN, right:Number = NaN, top:Number = NaN
map.render.canvas.LineStringReplay.prototype.hasCommonPart = function(mapExtent, extent){
    //добавил умножение по правой части, чтобю линии раньше границ карты не обрезались
    if ((extent[0] <= mapExtent[2]*2) && (extent[2] >= mapExtent[0]) ){
        if ((extent[3] >= mapExtent[1]) && (extent[1] <= mapExtent[3]))
            return true;
    }
    return false;
};


_GEO_EXTENTS = {};
/**
 *
 * @param multiLineStringGeometry
 * @param feature
 * @param style
 * @param replayGroup
 * @param textStyle
 * @param styleArr массив стилей, чтобы потом корректно отрисовать канву
 */
map.render.canvas.LineStringReplay.prototype.drawMultiLineStringGeometry =
    function(multiLineStringGeometry, feature, style, replayGroup,textStyle, styleArr) {
        var state = this.state_;
        goog.asserts.assert(state, 'state should not be null');
        var strokeStyle = state.strokeStyle;
        var lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) {
            return;
        }

        multiLineStringGeometry = feature.getGeometry();
        this.setStrokeStyle_();
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push(
            [ol.render.canvas.Instruction.SET_STROKE_STYLE,
                state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
                state.miterLimit, state.lineDash],
            [ol.render.canvas.Instruction.BEGIN_PATH]);
        var ends = multiLineStringGeometry.getEnds();
        var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        var stride = multiLineStringGeometry.getStride();
        var offset = 0;
        var i, ii;
        /*if(feature.get('type') == 'PODS_ROUTE_ROUTE_TYPE_10')*/
        //console.log(feature.get('type'));
        var fGeo = feature.getGeometry();
        var lay = WidgetMap.layerManager.getLayerByName(feature.get('layerId'));
        var mapExtent = WidgetMap.map.getView().calculateExtent(WidgetMap.map.getSize());
        var isTextAllow = true;
        if(goog.isDef(lay) && lay.isTextAllow == false)
            isTextAllow = false;
        var linesForTextDrawing = []; //массив порезанных линий

        for (i = 0, ii = ends.length; i < ii; ++i) {
            var fLineString = fGeo.getLineString(i);
            var geoExtent = fLineString.getExtent();//ol.extent.boundingExtent(fLineString.getCoordinates());
            var extWidth = ol.extent.getWidth(geoExtent);
            var extHeight = ol.extent.getHeight(geoExtent);
            var lineD = Math.sqrt(extWidth * extWidth + extHeight * extHeight);
            if (lineD < ol.extent.getWidth(mapExtent) * MIN_VISIBLE_RATIO){
                offset += fLineString.flatCoordinates.length;
                //Линия меньше минимального размера
                continue;
            }
            if (!(this.hasCommonPart(mapExtent,geoExtent))){
                offset += fLineString.flatCoordinates.length;
                //Линия не попадает в отрисовку
                continue;
            }
            //Установка флага, что геометрия наносится в данном экстенте
            var duplicate = 1;
            var isKapRemont = false;
            if(goog.isDef(lay))
                lay.layer.featureProjLayer.getSource().hasGeometryInExtent = true;
            //upd. 07.07.21 добавлено условие разрежения линий начиная с 8-го масштаба
            if(lay && lay.id === 'KAP_REMONT_PLAN'/* && WidgetMap.map.getView().getZoom() >= 8*/){
                isKapRemont = true;
            }
            offset = this.drawLineFlatCoordinates_(
                flatCoordinates, offset, ends[i], stride, styleArr, {lineWidth: lineWidth, duplicate: duplicate});
            //TODO добавить сюда рисование подписи
            // закинуть в drawtext getLineString(i) и уже по всем её объектам рисовать
            //textStyle = null;
            if(isTextAllow){
                textStyle = styleArr[0].getText();
                if(!goog.isNull(textStyle)){
                    var gLines = globalLinesLabels_[feature.get('labelType')];
                    var labelObj = (gLines)?gLines[i]: undefined;
                    if(labelObj){
                        //режем линии по рамке
                        var newLineStrings = GeoUtil.composeLineStringByExtent(fLineString, mapExtent);
                        if (newLineStrings && newLineStrings.length > 0){
                            newLineStrings.forEach(function(newLineString){
                                linesForTextDrawing.push({
                                    lineString: newLineString,
                                    labelObj: labelObj,
                                });
                            })
                        }
                        //TODO подумать, мб сделать здесь формирование для капремонтов массива геометрий с semantic_uniq_data
                        if(!(goog.isNull(labelObj.label) || labelObj.label == '') && !isKapRemont){
                            //рисуем текстовую подпись
                            //this.drawText(textStyle,labelObj, feature, fLineString);
                            //TODO использовать флаг needScale
                            if(textStyle.getFont().indexOf(' -3px ') !== -1)
                                this.drawTextVtd(replayGroup,style,textStyle,labelObj, feature, fLineString, isKapRemont);
                            else
                                this.drawTextNew(replayGroup,style,textStyle,labelObj, feature, fLineString, isKapRemont, duplicate);
                        }
                    }
                }
            }
        }


        if(linesForTextDrawing && linesForTextDrawing.length > 0 && isTextAllow && isKapRemont){
            if(WidgetMap.stubTextLayer)
                WidgetMap.stubTextLayer.getSource().clear();
            var that = this;
            var resolution = WidgetMap.map.getView().getResolution();
            LABEL_REPEAT_RATIO = 1;
            var mapWidth = WidgetMap.map.getSize()[0] * LABEL_REPEAT_RATIO;
            var textReplay = replayGroup.getReplay(
                style.getZIndex(), ol.render.ReplayType.TEXT);
            textStyle.setTextAlign('start');
            var isCasUnits = (feature.get('layerId') !== undefined && feature.get('layerId').indexOf('labelScale') !== -1);
            linesForTextDrawing.forEach(function(obj){
                var text = obj.labelObj.label;
                if(!text) return;
                var geometryExtent = obj.lineString.getExtent();
                //высчитываем длину линии, как диагональ экстента линии
                var lineD = Math.sqrt(ol.extent.getWidth(geometryExtent) * ol.extent.getWidth(geometryExtent) + ol.extent.getHeight(geometryExtent) * ol.extent.getHeight(geometryExtent));
                lineD /= resolution;
                var textWidth = GeoUtil.getTextWidth(text, textStyle, _CONTEXT);
                //upd. 26.10.21 меняем устаревшее условие на модифицированное, чтобы включить в него условия обрезки подписей за 3 попытки
                //if (textWidth > lineD * MAX_LABEL_RATIO )
                if (textWidth > lineD * MAX_LABEL_RATIO * (1 + LABEL_CUT_RATIO * 3 + 0.01) )
                    return;
                // получаем все начальные точки(на 04.10.21 используем только align=center)
                var lineStartPoint = GeoUtil.alignText(obj.lineString, textStyle.getTextAlign(), mapWidth, textWidth, text);
                var textVector = GeoUtil.composeTextVectorFromStartPoint(lineStartPoint, {text: text, textStyle:textStyle, textWidth:textWidth}, isCasUnits);
                if(textVector)
                    that.drawTextVector(textReplay, textStyle, textVector, feature, isCasUnits);
            });
        }

        this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);
        this.endGeometry(multiLineStringGeometry, feature);
    };

/**
 *
 *
 * var textStyle = style.getText();
 if (!goog.isNull(textStyle)) {
        var flatCoordinates = geometry.getFlatCoordinates();
        var textReplay;
        textReplay = replayGroup.getReplay(
            style.getZIndex(), ol.render.ReplayType.TEXT);
        textStyle.setText('ff');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(flatCoordinates, 0, flatCoordinates.length,
            geometry.getStride(), geometry, feature,'', textStyle);
      }
 * @param textStyle
 * @param labelObj
 * @param feature
 * @param lineString
 */
map.render.canvas.LineStringReplay.prototype.drawTextVtd = function(replayGroup,style, textStyle, labelObj, feature, lineString,isKapRemont){
    var geometry = lineString;
    var text = labelObj.label;
    var textReplay = replayGroup.getReplay(
        style.getZIndex(), ol.render.ReplayType.TEXT);
    var p = {};
    var p2 = {};
    var mapWidth = 0;
    var textWidth = goog.isDef(_CONTEXT)?_CONTEXT.measureText(text).width-5:89;//context.measureText(text).width+5;
    var resolution = WidgetMap.map.getView().getResolution();
    var mapExtent = WidgetMap.map.getView().calculateExtent(WidgetMap.map.getSize());
    mapWidth = ol.extent.getWidth(mapExtent)*LABEL_REPEAT_RATIO;
    var lineLen = lineString.getLength();
    var lineD = Math.sqrt(ol.extent.getWidth(geometry.getExtent())*ol.extent.getWidth(geometry.getExtent()) + ol.extent.getHeight(geometry.getExtent())*ol.extent.getHeight(geometry.getExtent()));
    if (lineD < ol.extent.getWidth(mapExtent)*MIN_VISIBLE_RATIO){
        //Logger.info("Линия меньше минимального размера " + this.layer.name + " " + lineD.toString() + " < " + (this.layer.map.extent.width*LineStringFeature.MIN_VISIBLE_RATIO).toString());
        return;
    }
    var fCoords = lineString.flatCoordinates;
    var coords = lineString.getCoordinates();
    var di = 1;
    var n = 0;
    var x, y;
    if(lineString.intersectsExtent(mapExtent)){
        if(coords.length>3)
            n = 2;
        //p = {x:coords[n][0],y:coords[n][1]};
        p = {x:coords[0][0],y:coords[0][1]};
        lineD /= resolution;
        var txtRes = 6; // px в символе
        if(textStyle.getFont().indexOf(' -3px ') === -1)
            if (text.length*txtRes > lineD*MAX_LABEL_RATIO){
                return;
            }
        var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p.x, p.y]);
        x = pixelCoord[0];
        y = pixelCoord[1];
        var addedObj = '';
        addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[n][0], coords[n][1], x, y, feature.get('zIndex'),'label',false);
        //наклон
        var rotation = 0;
        var rotateResult = [];
        var pLast = {x:coords[coords.length-1][0],y:coords[coords.length-1][1]};
        var pixelCoordLast = WidgetMap.map.getPixelFromCoordinate([pLast.x, pLast.y]);
        var lLenPixel = Math.sqrt((pixelCoord[0] - pixelCoordLast[0])*(pixelCoord[0] - pixelCoordLast[0]) +( pixelCoord[1] - pixelCoordLast[1])*( pixelCoord[1] - pixelCoordLast[1]));
        if (addedObj !== '' && coords.length > 1){
            if (coords.length > 5)
                di = 2;
            p2 =  {x:coords[coords.length-1][0],y:coords[coords.length-1][1]};
            rotateResult = this.rotateTextVtd_(p,p2,lLenPixel,13,textStyle.getTextBaseline(),textStyle.getTextAlign(),'normal',_dx,_dy,resolution,x,y);
            if(!rotateResult)
                return;
            rotation = rotateResult[2];
            x = rotateResult[0];
            y = rotateResult[1];
            //rotation = 0;
        }
        var fill = textStyle.getFill() !== undefined;
        var stroke = textStyle.getStroke() !== undefined;
        if(addedObj !== ''){
            var lLen = lineLen/resolution;
            var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
            _LABELS.push({
                type: 'LineString',
                unique:addedObj,text:text,textStyle:textStyle,
                coordX:coordsXY[0],coordY:coordsXY[1],x:x,y:y,scale:1,rotation:rotation,
                localTransform:undefined, fill:fill, stroke:stroke,lLen:lLen, lLenPixel:lLenPixel});
            textStyle.setRotation(rotation);
            textStyle.setScale(1);
            textStyle.setText(text);
            textReplay.setTextStyle(textStyle);
            textReplay.drawText(coordsXY, 0, 1,
                geometry.getStride(), geometry, feature,'', textStyle,lLen, lLenPixel);
        }
        n++;
    }
};

/**
 *
 *
 * var textStyle = style.getText();
 if (!goog.isNull(textStyle)) {
        var flatCoordinates = geometry.getFlatCoordinates();
        var textReplay;
        textReplay = replayGroup.getReplay(
            style.getZIndex(), ol.render.ReplayType.TEXT);
        textStyle.setText('ff');
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(flatCoordinates, 0, flatCoordinates.length,
            geometry.getStride(), geometry, feature,'', textStyle);
      }
 * @param textStyle
 * @param labelObj
 * @param feature
 * @param lineString
 */
map.render.canvas.LineStringReplay.prototype.drawTextNew = function(replayGroup,style, textStyle, labelObj, feature, lineString, isKapRemont, dupl){
    var geometry = lineString;
    var text = labelObj.label;
    var textReplay = replayGroup.getReplay(
        style.getZIndex(), ol.render.ReplayType.TEXT);
    var overlap = '0';
    overlap = WidgetMap.layerManager.getTextOverlapByNameAndType(feature.get('type'),'LineString');
    var p = {};
    var p2 = {};
    var mapWidth = 0;
    var textWidth = goog.isDef(_CONTEXT)?_CONTEXT.measureText(text).width-5:89;//context.measureText(text).width+5;
    var duplicate = true;
    var resolution = WidgetMap.map.getView().getResolution();
    var j = 0;
    var mapExtent = WidgetMap.map.getView().calculateExtent(WidgetMap.map.getSize());
    mapWidth = ol.extent.getWidth(mapExtent)*LABEL_REPEAT_RATIO;
    var lineLen = lineString.getLength();
    var lineD = Math.sqrt(ol.extent.getWidth(geometry.getExtent())*ol.extent.getWidth(geometry.getExtent()) + ol.extent.getHeight(geometry.getExtent())*ol.extent.getHeight(geometry.getExtent()));
    if (lineD < ol.extent.getWidth(mapExtent)*MIN_VISIBLE_RATIO){
        //Logger.info("Линия меньше минимального размера " + this.layer.name + " " + lineD.toString() + " < " + (this.layer.map.extent.width*LineStringFeature.MIN_VISIBLE_RATIO).toString());
        return;
    }
    var fCoords = lineString.flatCoordinates;
    var coords = lineString.getCoordinates();
    var di = 1;
    var n = 0;
    var x, y;
    if(lineString.intersectsExtent(mapExtent)){
        if(coords.length>3)
            n = 2;
        p = {x:coords[n][0],y:coords[n][1]};
        lineD /= resolution;
        var txtRes = 6; // px в символе
        if(textStyle.getFont().indexOf(' -1px ')==-1)
            if (text.length*txtRes > lineD*MAX_LABEL_RATIO){
                return;
            }
        var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p.x, p.y]);
        x = pixelCoord[0]+10;//pixelCoordinates[n+d] + offsetX;
        y = pixelCoord[1]+10;//pixelCoordinates[n+d+1] + offsetY;
        //получаем индекс добавленного текста
        var addedObj = '';
        if(overlap == '1'){
            addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[n][0], coords[n][1], x, y, feature.get('zIndex'),'label',false);
        }
        else{
            //заносим в матрицу
            if(!this.hasTextPointCollision_(feature,textWidth, 13, x, y, feature.get('zIndex'))){
                addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[n][0], coords[n][1],x,y, feature.get('zIndex'));
            }
        }

        //наклон
        var rotation = 0;
        var rotateResult = [];
        //если слой капремонтов, то расчитываем подпись по центру линии
        if(isKapRemont){
            p2 = {x: fCoords[fCoords.length - 2], y: fCoords[fCoords.length - 1]};
            var lineExtent = lineString.getExtent();
            rotateResult = this.moveTextToCenter_(p, p2, textWidth, 13, x, y, lineExtent, dupl);
            //fCoords.length = 1;// выставляем заведомо ложное условие для дальнейшей отрисовки подписей
            x = rotateResult[0];
            y = rotateResult[1];
            rotation = rotateResult[2];
        }
        else if (addedObj != '' && coords.length > 1){
            if (coords.length > 5)
                di = 2;
            p2 = {x:fCoords[(n+di)*2],y:fCoords[(n+di)*2+1]};//lineString.componentByIndex(n+di) as org.openscales.core.geometry.Point;
            rotateResult = this.rotateText_(p, p2, textWidth, 13, textStyle.getTextBaseline(), textStyle.getTextAlign(), 'normal', _dx, _dy, resolution, x, y, isKapRemont);
            if(rotateResult){
                rotation = rotateResult[2];
                x = rotateResult[0];
                y = rotateResult[1];
            }
            else{
                addedObj = '';
            }

        }
        var fill = goog.isDef(textStyle.getFill());
        var stroke = goog.isDef(textStyle.getStroke());
        if(addedObj != ''){
            var lLen = lineLen/resolution;
            var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
            if(rotateResult){
                _LABELS.push({
                    type: 'LineString',
                    unique:addedObj,text:text,textStyle:textStyle,
                    coordX:coordsXY[0],coordY:coordsXY[1],x:x,y:y,scale:1,rotation:rotation,
                    localTransform:undefined, fill:fill, stroke:stroke,lLen:lLen});
                textStyle.setRotation(rotation);
                textStyle.setScale(1);
                textStyle.setText(text);
                textReplay.setTextStyle(textStyle);
                textReplay.drawText(coordsXY, 0, 1,
                    geometry.getStride(), geometry, feature,'', textStyle, lLen, lLen, dupl);
            }
        }
        n++;
        var limit = mapWidth;
        var bM;
        var intersectLineString;
        var intersectMapBounds = mapExtent;
        var lengthP1P2 = 0;
        addedObj = '';
        if ((lineLen > mapWidth) && (fCoords.length > 6) || !isKapRemont) {
            bM = 0;
            p2 = {x: coords[n][0], y: coords[n][1]};//lineString.componentByIndex(n) as org.openscales.core.geometry.Point;
            for (j = n + 1; j < coords.length; j++) {
                p = {x: coords[j][0], y: coords[j][1]}; //lineString.componentByIndex(j) as org.openscales.core.geometry.Point;
                lengthP1P2 = Math.sqrt((p2.x - p.x)*(p2.x - p.x) + (p2.y - p.y)*(p2.y - p.y));
                bM += lengthP1P2;
                intersectLineString = new ol.geom.LineString(null);
                intersectLineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, [p2.x, p2.y, p.x, p.y]);
                if (bM > limit && intersectLineString.intersectsExtent(intersectMapBounds)) {
                    //Лимит увеличиваем до тех пор, пока он не станет больше текущей длины
                    limit += mapWidth * Math.ceil((bM - limit) / mapWidth);
                    pixelCoord = WidgetMap.map.getPixelFromCoordinate([p.x, p.y]);
                    x = pixelCoord[0]+10;
                    y = pixelCoord[1]+10;
                    addedObj = '';
                    if(overlap == '1'){
                        addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[j*2], coords[j*2+1], x, y, feature.get('zIndex'),'label',false);
                    }
                    else{
                        //заносим в матрицу
                        if(!this.hasTextPointCollision_(feature,textWidth, 13, x, y, feature.get('zIndex'))){
                            addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[j*2], coords[j*2+1],x,y, feature.get('zIndex'));
                        }
                    }
                    if (addedObj!='') {
                        var pp;
                        var rotateResult = [];
                        if (j + di < coords.length) {
                            pp = {
                                x: coords[(j + di)][0],
                                y: coords[(j + di)][1]
                            };
                            rotateResult = this.rotateText_(p, pp, textWidth, 13, 'middle', 'right', 'normal', 0, 0, resolution, x, y, isKapRemont);//rotateLabel(lbl, p, lineString.componentByIndex(j+di) as org.openscales.core.geometry.Point, symbolizer.labelSymbolyzer ? symbolizer.labelSymbolyzer.vAlign : "top");
                        }
                        else {
                            pp = {
                                x: coords[j - di][0],
                                y: coords[j - di][1]
                            };
                            rotateResult = this.rotateText_(p, pp, textWidth, 13, 'middle', 'right', 'normal', 0, 0, resolution, x, y, isKapRemont);
                        }
                        if(rotateResult){
                            rotation = rotateResult[2];
                            x = rotateResult[0];
                            y = rotateResult[1];
                            var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
                            _LABELS.push({
                                type: 'LineString',
                                unique:addedObj,text:text,textStyle:textStyle,
                                coordX:coordsXY[0],coordY:coordsXY[1],x:x,y:y,scale:1,rotation:rotation,
                                localTransform:undefined, fill:fill, stroke:stroke});
                            textStyle.setText(text);
                            textStyle.setRotation(rotation);
                            textStyle.setScale(1);
                            textReplay.setTextStyle(textStyle);
                            textReplay.drawText(coordsXY, 0, 1,
                                geometry.getStride(), geometry, feature, '', textStyle, lLen, lLen, dupl, isKapRemont);
                        }
                    }
                    if (lineLen < limit)
                        j = coords.length;
                    if (duplicate == false)
                        j = coords.length;
                }
                p2 = p;
            }
        }
    }
};

/**
 *
 * @param textReplay
 * @param textStyle
 * @param textVector
 * @param feature
 */
map.render.canvas.LineStringReplay.prototype.drawTextVector = function (textReplay, textStyle, textVector, feature, isCasUnits) {
    if (!textVector)
        return;
    //upd. 23.09.21 Принято решение для линейных объектов вообще игнорировать параметр overlap, чтобы они всегда разряжались
    var collision = GeoUtil.hasComplexTextCollision(textVector);
    var freeCells = collision.freeCells;
    //пункт 6. Проверка по матрице.
    if (!collision.hasCollision) {
        addTextExtent(textVector.bounds);
        var addedObj = GeoUtil.addComplexText(feature, textVector, freeCells);
        var text = textVector.text;
        var lineString = textVector.lineString;
        var geometry = lineString;
        var lLen = lineString.getLength();
        var rotation = textVector.rotation;
        var x = textVector.x;
        var y = textVector.y;
        var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
        //проверить, нужно ли в тех схеме подобная вставка в массив
        _LABELS.push({
            type: 'LineString',
            unique: addedObj, text: text, textStyle: textStyle,
            coordX: coordsXY[0], coordY: coordsXY[1], x: x, y: y, scale: 1, rotation: rotation,
            localTransform: undefined, fill: textStyle.getFill(), stroke: textStyle.getStroke(), lLen: lLen
        });
        textStyle.setRotation(rotation);
        //для нового варианта подписывания линий убираем выравнивание ядра карты
        //textStyle.setTextAlign('start');
        textStyle.setScale(1);
        textStyle.setText(text);
        textReplay.setTextStyle(textStyle);
        textReplay.drawText(coordsXY, 0, 1,
            geometry.getStride(), geometry, feature,'', textStyle, lLen, lLen);
    }
    else {//пункт 6. Сдвиг
        var startPoint = {startPoint: textVector.coordEnd, lineString:textVector.lineString };
        textVector = GeoUtil.composeTextVectorFromStartPoint(startPoint, {text: textVector.baseText, textStyle:textStyle, textWidth:textVector.textWidth}, isCasUnits, false);
        if(textVector)
            this.drawTextVector(textReplay, textStyle, textVector, feature);
    }
};

var addTextExtent = function(bounds){
    if(!WidgetMap.stubTextLayer)
        return;
    var textExtent = bounds.getExtent();
    var min = WidgetMap.map.getCoordinateFromPixel([textExtent[0],textExtent[1]]);
    var max = WidgetMap.map.getCoordinateFromPixel([textExtent[2],textExtent[3]]);
    var newExtent = [min[0], min[1], max[0], max[1]];
    var polygon = new ol.geom.Polygon.fromExtent(newExtent);
    var lineMatrixGeo = new ol.geom.MultiLineString(null);
    var lineAddGeo = new ol.geom.LineString(polygon.getCoordinates()[0],ol.geom.GeometryLayout.XY);
    lineMatrixGeo.appendLineString(lineAddGeo)

    var lineMatrixGeoFtr = new ol.Feature(lineMatrixGeo);
    lineMatrixGeoFtr.setStyle(function(){ //стили ПКА берем за основу полувидимых линий
            var s = WidgetMap.layerManager.getStyleByNameAndType('CAS_LIGHT_AXES_1', 'LineString');
            if(!goog.isNull(s)) {
                if (goog.isArray(s))
                    return [s];
                return [s];
            }
        }
    );
    WidgetMap.stubTextLayer.getSource().addFeature(lineMatrixGeoFtr);
}

map.render.canvas.Replay.prototype.findTextPointObject_ = function (unique) {
    if(unique && _visibleTextMatrix && _visibleTextMatrix['label'] && _visibleTextMatrix['label'].length > 0){
        var vtm = _visibleTextMatrix['label'];
        var i = 0, j = 0;
        for (; i < vtm.length; i++) {
            if(vtm[i].length > 0){
                for (j = 0; j < vtm[i].length; j++) {
                    if(vtm[i][j] && vtm[i][j].unique === unique)
                        return vtm[i][j];
                }
            }
        }
    }
}


map.render.canvas.LineStringReplay.prototype.getCutText = function (textFeature, lineCoordinates, x, y) { //txtFeature:rotation, width, text
    var closestSegment1;
    var rotation = textFeature.rotation;
    var textWidth = textFeature.width;
    var text = textFeature.text;
    //return text;
    var charWidth = (textFeature.width) / textFeature.text.length;
    var textInp = '';
    //корректируем x,y, т.к. приходит средняя точка
    x = x - Math.cos(rotation) * (textWidth / 2);
    y = y - Math.sin(rotation) * (textWidth / 2);
    var coordsStartPixel = [x, y];
    var coordsStart = WidgetMap.map.getCoordinateFromPixel(coordsStartPixel);
    var coordsEndPixel = [x + Math.cos(rotation) * (textWidth), y + Math.sin(rotation) * (textWidth)];
    var coordsEnd = WidgetMap.map.getCoordinateFromPixel(coordsEndPixel);
    var coordMiddlePixel = [(coordsStartPixel[0] + coordsEndPixel[0]) / 2, (coordsStartPixel[1] + coordsEndPixel[1]) / 2];
    var coordMiddle = WidgetMap.map.getCoordinateFromPixel(coordMiddlePixel);
    var closestDistance = Number.MAX_VALUE;
    //первый прогон массива, если дистанция от начала подписи больше лимита, подпись не рисуем
    for (var k = 0; k < lineCoordinates.length - 1; ++k) {
        closestSegment1 = [lineCoordinates[k], lineCoordinates[k + 1]];
        var closestFirstProj = ol.coordinate.closestOnSegment(coordMiddle, closestSegment1);
        var coordsFirstClosestPixel = WidgetMap.map.getPixelFromCoordinate(closestFirstProj);
        if (GeoUtil.Distance(coordsFirstClosestPixel, coordMiddlePixel) < closestDistance)
            closestDistance = GeoUtil.Distance(coordsFirstClosestPixel, coordMiddlePixel);
    }
    if (closestDistance > LABEL_CUT_TOLERANCE)
        return;
    for (var j = 0; j < 3; j++) {
        coordsEndPixel = [x + Math.cos(rotation) * (textWidth), y + Math.sin(rotation) * (textWidth)];
        coordsEnd = WidgetMap.map.getCoordinateFromPixel(coordsEndPixel);
        closestDistance = Number.MAX_VALUE;
        for (var i = 0; i < lineCoordinates.length - 1; ++i) {
            closestSegment1 = [lineCoordinates[i], lineCoordinates[i + 1]];
            var newPointProj = ol.coordinate.closestOnSegment(coordsEnd, closestSegment1);
            var coordsClosestPixel = WidgetMap.map.getPixelFromCoordinate(newPointProj);
            if (GeoUtil.Distance(coordsClosestPixel, coordsEndPixel) < closestDistance)
                closestDistance = GeoUtil.Distance(coordsClosestPixel, coordsEndPixel);
        }
        if (closestDistance < LABEL_CUT_TOLERANCE)
            return (textInp) ? textInp : text;
        if (j == 2)
            return;
        textWidth -= textFeature.width * LABEL_CUT_RATIO;

        var charCount = ((textWidth - 10) / charWidth).toFixed(0) - 3;// Из длины линии -10 т.к. текст начинается с отступом в 10 пикселей от начала, -3 символа для '...'
        if (charCount > 4) //Выводим подпись, только если вмещается 5 символов
            textInp = text.slice(0, charCount) + '...';
    }
    return textInp;
};



map.render.canvas.LineStringReplay.prototype.drawText = function(textStyle, labelObj, feature, lineString){
    var geometry = lineString;
    var text = labelObj.label;
    var overlap = '0';
    overlap = WidgetMap.layerManager.getTextOverlapByNameAndType(feature.get('type'),'LineString');
    var p = {}, p2 = {};
    var mapWidth = 0;
    var textWidth = goog.isDef(_CONTEXT)?_CONTEXT.measureText(text).width-5:89;//context.measureText(text).width+5;
    var resolution = WidgetMap.map.getView().getResolution();
    var j = 0;
    var mapExtent = WidgetMap.map.getView().calculateExtent(WidgetMap.map.getSize());
    mapWidth = ol.extent.getWidth(mapExtent)*LABEL_REPEAT_RATIO;
    var lineLen = lineString.getLength();
    var lineD = Math.sqrt(ol.extent.getWidth(geometry.getExtent())*ol.extent.getWidth(geometry.getExtent()) + ol.extent.getHeight(geometry.getExtent())*ol.extent.getHeight(geometry.getExtent()));
    if (lineD < ol.extent.getWidth(mapExtent)*MIN_VISIBLE_RATIO){
        //Logger.info("Линия меньше минимального размера " + this.layer.name + " " + lineD.toString() + " < " + (this.layer.map.extent.width*LineStringFeature.MIN_VISIBLE_RATIO).toString());
        return;
    }
    var fCoords = lineString.flatCoordinates;
    var coords = lineString.getCoordinates();
    var di = 1;
    var n = 0;
    var x, y;
    if(lineString.intersectsExtent(mapExtent)){
        if(coords.length>3)
            n = 2;
        p = {x:coords[n][0],y:coords[n][1]};
        lineD /= resolution;
        var txtRes = 6; // px в символе
        /*if(textStyle.getFont().indexOf('-1px')==-1)
            if (text.length*txtRes > lineD*MAX_LABEL_RATIO){
                return;
            }*/
        var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p.x, p.y]);
        x = pixelCoord[0]+10;//pixelCoordinates[n+d] + offsetX;
        y = pixelCoord[1]+10;//pixelCoordinates[n+d+1] + offsetY;
        //получаем индекс добавленного текста
        var addedObj = '';
        if(overlap == '1'){
            addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[n][0], coords[n][1], x, y, feature.get('zIndex'),'label',false);
        }
        else{
            //заносим в матрицу
            if(!this.hasTextPointCollision_(feature,textWidth, 13, x, y, feature.get('zIndex'))){
                addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[n][0], coords[n][1],x,y, feature.get('zIndex'));
            }
        }
        //наклон
        var rotation = 0;
        var rotateResult = [];
        if (addedObj != '' && coords.length > 1){
            if (coords.length > 5)
                di = 2;
            p2 = {x:fCoords[(n+di)*2],y:fCoords[(n+di)*2+1]};//lineString.componentByIndex(n+di) as org.openscales.core.geometry.Point;
            rotateResult = this.rotateText_(p,p2,textWidth,13,textStyle.getTextBaseline(),textStyle.getTextAlign(),'normal',0,0,resolution,x,y);
            if(!rotateResult){
                addedObj = '';
            }
            else{
                rotation = rotateResult[2];
                x = rotateResult[0];
                y = rotateResult[1];
            }
        }
        var fill = goog.isDef(textStyle.getFill());
        var stroke = goog.isDef(textStyle.getStroke());
        if(addedObj != ''){
            var lLen = lineLen/resolution;
            var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
            if(rotateResult)
                _LABELS.push({
                    type: 'LineString',
                    unique:addedObj,text:text,textStyle:textStyle,
                    coordX:coordsXY[0],coordY:coordsXY[1],x:x,y:y,scale:1,rotation:rotation,
                    localTransform:undefined, fill:fill, stroke:stroke,lLen:lLen});
        }
        n++;
        var limit = mapWidth;
        var bM;
        var intersectLineString;
        var intersectMapBounds = mapExtent;
        var lengthP1P2 = 0;
        addedObj = '';
        if ((lineLen > mapWidth) && (fCoords.length > 6)) {
            bM = 0;
            p2 = {x: coords[n][0], y: coords[n][1]};//lineString.componentByIndex(n) as org.openscales.core.geometry.Point;
            for (j = n + 1; j < coords.length; j++) {
                p = {x: coords[j][0], y: coords[j][1]}; //lineString.componentByIndex(j) as org.openscales.core.geometry.Point;
                lengthP1P2 = Math.sqrt((p2.x - p.x)*(p2.x - p.x) + (p2.y - p.y)*(p2.y - p.y));
                bM += lengthP1P2;
                intersectLineString = new ol.geom.LineString(null);
                intersectLineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, [p2.x, p2.y, p.x, p.y]);
                if (bM > limit && intersectLineString.intersectsExtent(intersectMapBounds)) {
                    //Лимит увеличиваем до тех пор, пока он не станет больше текущей длины
                    limit += mapWidth * Math.ceil((bM - limit) / mapWidth);
                    pixelCoord = WidgetMap.map.getPixelFromCoordinate([p.x, p.y]);
                    x = pixelCoord[0]+10;
                    y = pixelCoord[1]+10;
                    addedObj = '';
                    if(overlap == '1'){
                        addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[j][0], coords[j][1], x, y, feature.get('zIndex'),'label',false);
                    }
                    else{
                        //заносим в матрицу
                        if(!this.hasTextPointCollision_(feature,textWidth, 13, x, y, feature.get('zIndex'))){
                            addedObj = this.addTextPointObject_(feature,textWidth, 13, coords[j][0], coords[j][1],x,y, feature.get('zIndex'));
                        }
                    }
                    if (addedObj!='') {
                        var pp;
                        var rotateResult = [];
                        if (j + di < coords.length) {
                            pp = {
                                x: coords[(j + di)][0],
                                y: coords[(j + di)][1]
                            };
                            rotateResult = this.rotateText_(p, pp, textWidth,13,'middle','right','normal',0,0,resolution,x,y);//rotateLabel(lbl, p, lineString.componentByIndex(j+di) as org.openscales.core.geometry.Point, symbolizer.labelSymbolyzer ? symbolizer.labelSymbolyzer.vAlign : "top");
                        }
                        else {
                            pp = {
                                x: coords[j - di][0],
                                y: coords[j - di][1]
                            };
                            rotateResult = this.rotateText_(p, pp, textWidth,13,'middle','right','normal',0,0,resolution,x,y);
                        }
                        if(rotateResult){
                            rotation = rotateResult[2];
                            x = rotateResult[0];
                            y = rotateResult[1];
                            var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
                            _LABELS.push({
                                type: 'LineString',
                                unique:addedObj,text:text,textStyle:textStyle,
                                coordX:coordsXY[0],coordY:coordsXY[1],x:x,y:y,scale:1,rotation:rotation,
                                localTransform:undefined, fill:fill, stroke:stroke});
                        }
                    }
                    if (lineLen < limit)
                        j = coords.length;
                }
                p2 = p;
            }
        }
    }
};



/**
 * @inheritDoc
 */
map.render.canvas.LineStringReplay.prototype.finish = function() {
    var state = this.state_;
    goog.asserts.assert(!goog.isNull(state), 'state should not be null');
    if (state.lastStroke != this.coordinates.length) {
        this.instructions.push([ol.render.canvas.Instruction.STROKE]);
    }
    this.reverseHitDetectionInstructions_();
    this.state_ = null;
};


/**
 * @inheritDoc
 */
map.render.canvas.LineStringReplay.prototype.setFillStrokeStyle =
    function(fillStyle, strokeStyle) {
        goog.asserts.assert(!goog.isNull(this.state_),
            'this.state_ should not be null');
        goog.asserts.assert(goog.isNull(fillStyle), 'fillStyle should be null');
        goog.asserts.assert(!goog.isNull(strokeStyle),
            'strokeStyle should not be null');
        var strokeStyleColor = strokeStyle.getColor();
        this.state_.strokeStyle = ol.color.asString(!goog.isNull(strokeStyleColor) ?
            strokeStyleColor : ol.render.canvas.defaultStrokeStyle);
        var strokeStyleLineCap = strokeStyle.getLineCap();
        this.state_.lineCap = goog.isDef(strokeStyleLineCap) ?
            strokeStyleLineCap : ol.render.canvas.defaultLineCap;
        var strokeStyleLineDash = strokeStyle.getLineDash();
        this.state_.lineDash = !goog.isNull(strokeStyleLineDash) ?
            strokeStyleLineDash : ol.render.canvas.defaultLineDash;
        var strokeStyleLineJoin = strokeStyle.getLineJoin();
        this.state_.lineJoin = goog.isDef(strokeStyleLineJoin) ?
            strokeStyleLineJoin : ol.render.canvas.defaultLineJoin;
        var strokeStyleWidth = strokeStyle.getWidth();
        this.state_.lineWidth = goog.isDef(strokeStyleWidth) ?
            strokeStyleWidth : ol.render.canvas.defaultLineWidth;
        var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
        this.state_.miterLimit = goog.isDef(strokeStyleMiterLimit) ?
            strokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit;

        if (this.state_.lineWidth > this.maxLineWidth) {
            this.maxLineWidth = this.state_.lineWidth;
            // invalidate the buffered max extent cache
            this.bufferedMaxExtent_ = null;
        }
    };



/**
 * @constructor
 * @extends {map.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.PolygonReplay = function(tolerance, maxExtent, resolution) {

    goog.base(this, tolerance, maxExtent, resolution);

    /**
     * @private
     * @type {{currentFillStyle: (string|undefined),
     *         currentStrokeStyle: (string|undefined),
     *         currentLineCap: (string|undefined),
     *         currentLineDash: Array.<number>,
     *         currentLineJoin: (string|undefined),
     *         currentLineWidth: (number|undefined),
     *         currentMiterLimit: (number|undefined),
     *         fillStyle: (string|undefined),
     *         strokeStyle: (string|undefined),
     *         lineCap: (string|undefined),
     *         lineDash: Array.<number>,
     *         lineJoin: (string|undefined),
     *         lineWidth: (number|undefined),
     *         miterLimit: (number|undefined)}|null}
     */
    this.state_ = {
        currentFillStyle: undefined,
        currentStrokeStyle: undefined,
        currentLineCap: undefined,
        currentLineDash: null,
        currentLineJoin: undefined,
        currentLineWidth: undefined,
        currentMiterLimit: undefined,
        fillStyle: undefined,
        strokeStyle: undefined,
        lineCap: undefined,
        lineDash: null,
        lineJoin: undefined,
        lineWidth: undefined,
        miterLimit: undefined
    };

};
goog.inherits(map.render.canvas.PolygonReplay, map.render.canvas.Replay);


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */
map.render.canvas.PolygonReplay.prototype.drawFlatCoordinatess_ =
    function(flatCoordinates, offset, ends, stride) {
        var state = this.state_;
        var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];
        this.instructions.push(beginPathInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction);
        var i, ii;
        for (i = 0, ii = ends.length; i < ii; ++i) {
            var end = ends[i];
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatCoordinates(
                flatCoordinates, offset, end, stride, true);
            var moveToLineToInstruction =
                [ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
            var closePathInstruction = [ol.render.canvas.Instruction.CLOSE_PATH];
            this.instructions.push(moveToLineToInstruction, closePathInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction,
                closePathInstruction);
            offset = end;
        }
        // FIXME is it quicker to fill and stroke each polygon individually,
        // FIXME or all polygons together?
        var fillInstruction = [ol.render.canvas.Instruction.FILL];
        this.hitDetectionInstructions.push(fillInstruction);
        if (goog.isDef(state.fillStyle)) {
            this.instructions.push(fillInstruction);
        }
        if (goog.isDef(state.strokeStyle)) {
            goog.asserts.assert(goog.isDef(state.lineWidth),
                'state.lineWidth should be defined');
            var strokeInstruction = [ol.render.canvas.Instruction.STROKE];
            this.instructions.push(strokeInstruction);
            this.hitDetectionInstructions.push(strokeInstruction);
        }
        return offset;
    };

map.render.canvas.PolygonReplay.prototype.drawPolygonFlatCoordinatess_ =
    function(flatCoordinates, offset, ends, stride, styleArr) {


        var state = this.state_;
        var fill = state.fillStyle !== undefined;
        var stroke = state.strokeStyle != undefined;
        var numEnds = ends.length;
        if (!fill && !stroke) {
            return ends[numEnds - 1];
        }
        var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];
        this.instructions.push(beginPathInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction);
        for (var i = 0; i < numEnds; ++i) {
            var end = ends[i];
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride,
                // Performance optimization: only close the ring when we do not have a
                // stroke. Otherwise closePath() will take care of that.
                !stroke);
            var moveToLineToInstruction =
                [ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd, styleArr];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            if (stroke) {
                // Performance optimization: only call closePath() when we have a stroke.
                // Otherwise the ring is closed already (see appendFlatCoordinates above).
                var closePathInstruction = [ol.render.canvas.Instruction.CLOSE_PATH];
                this.instructions.push(closePathInstruction);
                this.hitDetectionInstructions.push(closePathInstruction);
            }
            offset = end;
        }
        var fillInstruction = [ol.render.canvas.Instruction.FILL];
        this.hitDetectionInstructions.push(fillInstruction);
        if (fill) {
            this.instructions.push(fillInstruction);
        }
        if (stroke) {
            var strokeInstruction = [ol.render.canvas.Instruction.STROKE];
            this.instructions.push(strokeInstruction);
            this.hitDetectionInstructions.push(strokeInstruction);
        }
        return offset;
    };


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.drawCircleGeometry =
    function(circleGeometry, feature) {
        var state = this.state_;
        goog.asserts.assert(!goog.isNull(state), 'state should not be null');
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (!goog.isDef(fillStyle) && !goog.isDef(strokeStyle)) {
            return;
        }
        if (goog.isDef(strokeStyle)) {
            goog.asserts.assert(goog.isDef(state.lineWidth),
                'state.lineWidth should be defined');
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature);
        // always fill the circle for hit detection
        this.hitDetectionInstructions.push(
            [ol.render.canvas.Instruction.SET_FILL_STYLE,
                ol.color.asString(ol.render.canvas.defaultFillStyle)]);
        if (goog.isDef(state.strokeStyle)) {
            this.hitDetectionInstructions.push(
                [ol.render.canvas.Instruction.SET_STROKE_STYLE,
                    state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
                    state.miterLimit, state.lineDash]);
        }
        var flatCoordinates = circleGeometry.getFlatCoordinates();
        var stride = circleGeometry.getStride();
        var myBegin = this.coordinates.length;
        this.appendFlatCoordinates(
            flatCoordinates, 0, flatCoordinates.length, stride, false);
        var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];
        var circleInstruction = [ol.render.canvas.Instruction.CIRCLE, myBegin];
        this.instructions.push(beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
        var fillInstruction = [ol.render.canvas.Instruction.FILL];
        this.hitDetectionInstructions.push(fillInstruction);
        if (goog.isDef(state.fillStyle)) {
            this.instructions.push(fillInstruction);
        }
        if (goog.isDef(state.strokeStyle)) {
            goog.asserts.assert(goog.isDef(state.lineWidth),
                'state.lineWidth should be defined');
            var strokeInstruction = [ol.render.canvas.Instruction.STROKE];
            this.instructions.push(strokeInstruction);
            this.hitDetectionInstructions.push(strokeInstruction);
        }
        this.endGeometry(circleGeometry, feature);
    };


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.drawPolygonGeometry =
    function(polygonGeometry, feature) {
        var state = this.state_;
        goog.asserts.assert(!goog.isNull(state), 'state should not be null');
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (!goog.isDef(fillStyle) && !goog.isDef(strokeStyle)) {
            return;
        }
        if (goog.isDef(strokeStyle)) {
            goog.asserts.assert(goog.isDef(state.lineWidth),
                'state.lineWidth should be defined');
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature);
        // always fill the polygon for hit detection
        this.hitDetectionInstructions.push(
            [ol.render.canvas.Instruction.SET_FILL_STYLE,
                ol.color.asString(ol.render.canvas.defaultFillStyle)]);
        if (goog.isDef(state.strokeStyle)) {
            this.hitDetectionInstructions.push(
                [ol.render.canvas.Instruction.SET_STROKE_STYLE,
                    state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
                    state.miterLimit, state.lineDash]);
        }
        var ends = polygonGeometry.getEnds();
        var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        var stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
        this.endGeometry(polygonGeometry, feature);
    };


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.drawMultiPolygonGeometry =
    function(multiPolygonGeometry, feature, style, replayGroup,textStyle,styleArr) {
        var state = this.state_;
        goog.asserts.assert(!goog.isNull(state), 'state should not be null');
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) {
            return;
        }
        if (goog.isDef(strokeStyle)) {
            goog.asserts.assert(goog.isDef(state.lineWidth),
                'state.lineWidth should be defined');
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature);
        // always fill the multi-polygon for hit detection
        this.hitDetectionInstructions.push(
            [ol.render.canvas.Instruction.SET_FILL_STYLE,
                ol.color.asString(ol.render.canvas.defaultFillStyle)]);
        if (state.strokeStyle !== undefined) {
            this.hitDetectionInstructions.push(
                [ol.render.canvas.Instruction.SET_STROKE_STYLE,
                    state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
                    state.miterLimit, state.lineDash]);
        }
        var endss = multiPolygonGeometry.getEndss();
        var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        var stride = multiPolygonGeometry.getStride();
        var offset = 0;
        var i, ii;
        var lay = WidgetMap.layerManager.getVectorLayerByUniqueName(feature.get('layerId'));
        var isTextAllow = true;
        var fGeo = feature.getGeometry();
        if(goog.isDef(lay) && lay.isTextAllow == false)
            isTextAllow = false;
        for (i = 0, ii = endss.length; i < ii; ++i) {
            var fPolygon = fGeo.getPolygon(i);
            if(goog.isDef(lay))
                lay.layer.featureProjLayer.getSource().hasGeometryInExtent = true;
            offset = this.drawPolygonFlatCoordinatess_(
                flatCoordinates, offset, endss[i], stride, styleArr);
            if(isTextAllow && goog.isDef(feature.get('labelType'))){
                textStyle = styleArr[0].getText();
                if(!goog.isNull(textStyle)){
                    var gLines = globalPolygonsLabels_[feature.get('labelType')];
                    var labelObj = gLines[i];
                    if(!(goog.isNull(labelObj.label) || labelObj.label == '')){
                        //рисуем текстовую подпись
                        this.drawPolygonText(textStyle,labelObj, feature, fPolygon);
                    }
                }
            }
        }
        this.endGeometry(multiPolygonGeometry, feature);

    };


map.render.canvas.PolygonReplay.prototype.drawPolygonText = function(textStyle, labelObj, feature, fPolygon){
    var geometry = fPolygon;
    var text = labelObj.label;
    if(!goog.isDef(text))
        return;
    var bounds = geometry.getExtent();
    var resolution = WidgetMap.map.getView().getResolution();
    var MIN_BOUNDS = 6*resolution;
    var fill = goog.isDef(textStyle.getFill());
    var stroke = goog.isDef(textStyle.getStroke());
    var pCenter = ol.extent.getCenter(bounds);
    var textWidth =goog.isDef(_CONTEXT)?_CONTEXT.measureText(text).width*LABEL_FONT_RATIO:89;
    var pixelCoord = WidgetMap.map.getPixelFromCoordinate(pCenter);
    if(ol.extent.getWidth(bounds)>1000 || ol.extent.getHeight(bounds)>MIN_BOUNDS){
        if(!this.hasTextPointCollision_(feature,textWidth, 18, pixelCoord[0], pixelCoord[1], feature.get('zIndex'))){
            var addedObj = this.addTextPointObject_(feature,textWidth, 18, pCenter[0], pCenter[1],pixelCoord[0], pixelCoord[1], feature.get('zIndex'));
            _LABELS.push({
                type: 'Polygon',
                unique:addedObj,text:text,textStyle:textStyle,
                coordX:pCenter[0],coordY:pCenter[1],x:pixelCoord[0],y:pixelCoord[1],scale:1,rotation:0,
                localTransform:undefined, fill:fill, stroke:stroke});
        }
    }
};
/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.finish = function() {
    goog.asserts.assert(!goog.isNull(this.state_),
        'this.state_ should not be null');
    this.reverseHitDetectionInstructions_();
    this.state_ = null;
    // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.
    var tolerance = this.tolerance;
    if (tolerance !== 0) {
        var coordinates = this.coordinates;
        var i, ii;
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
            coordinates[i] = ol.geom.flat.simplify.snap(coordinates[i], tolerance);
        }
    }
};


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.getBufferedMaxExtent = function() {
    if (goog.isNull(this.bufferedMaxExtent_)) {
        this.bufferedMaxExtent_ = ol.extent.clone(this.maxExtent);
        if (this.maxLineWidth > 0) {
            var width = this.resolution * (this.maxLineWidth + 1) / 2;
            ol.extent.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
        }
    }
    return this.bufferedMaxExtent_;
};


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.setFillStrokeStyle =
    function(fillStyle, strokeStyle) {
        goog.asserts.assert(!goog.isNull(this.state_),
            'this.state_ should not be null');
        goog.asserts.assert(!goog.isNull(fillStyle) || !goog.isNull(strokeStyle),
            'fillStyle or strokeStyle should not be null');
        var state = this.state_;
        if (!goog.isNull(fillStyle)) {
            var fillStyleColor = fillStyle.getColor();
            state.fillStyle = ol.color.asString(!goog.isNull(fillStyleColor) ?
                fillStyleColor : ol.render.canvas.defaultFillStyle);
        } else {
            state.fillStyle = undefined;
        }
        if (!goog.isNull(strokeStyle)) {
            var strokeStyleColor = strokeStyle.getColor();
            state.strokeStyle = ol.color.asString(!goog.isNull(strokeStyleColor) ?
                strokeStyleColor : ol.render.canvas.defaultStrokeStyle);
            var strokeStyleLineCap = strokeStyle.getLineCap();
            state.lineCap = goog.isDef(strokeStyleLineCap) ?
                strokeStyleLineCap : ol.render.canvas.defaultLineCap;
            var strokeStyleLineDash = strokeStyle.getLineDash();
            state.lineDash = !goog.isNull(strokeStyleLineDash) ?
                strokeStyleLineDash.slice() : ol.render.canvas.defaultLineDash;
            var strokeStyleLineJoin = strokeStyle.getLineJoin();
            state.lineJoin = goog.isDef(strokeStyleLineJoin) ?
                strokeStyleLineJoin : ol.render.canvas.defaultLineJoin;
            var strokeStyleWidth = strokeStyle.getWidth();
            state.lineWidth = goog.isDef(strokeStyleWidth) ?
                strokeStyleWidth : ol.render.canvas.defaultLineWidth;
            var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
            state.miterLimit = goog.isDef(strokeStyleMiterLimit) ?
                strokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit;

            if (state.lineWidth > this.maxLineWidth) {
                this.maxLineWidth = state.lineWidth;
                // invalidate the buffered max extent cache
                this.bufferedMaxExtent_ = null;
            }
        } else {
            state.strokeStyle = undefined;
            state.lineCap = undefined;
            state.lineDash = null;
            state.lineJoin = undefined;
            state.lineWidth = undefined;
            state.miterLimit = undefined;
        }
    };


/**
 * @private
 */
map.render.canvas.PolygonReplay.prototype.setFillStrokeStyles_ = function() {
    var state = this.state_;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;
    if (goog.isDef(fillStyle) && state.currentFillStyle != fillStyle) {
        this.instructions.push(
            [ol.render.canvas.Instruction.SET_FILL_STYLE, fillStyle]);
        state.currentFillStyle = state.fillStyle;
    }
    if (goog.isDef(strokeStyle)) {
        goog.asserts.assert(goog.isDef(lineCap), 'lineCap should be defined');
        goog.asserts.assert(!goog.isNull(lineDash), 'lineDash should not be null');
        goog.asserts.assert(goog.isDef(lineJoin), 'lineJoin should be defined');
        goog.asserts.assert(goog.isDef(lineWidth), 'lineWidth should be defined');
        goog.asserts.assert(goog.isDef(miterLimit), 'miterLimit should be defined');
        if (state.currentStrokeStyle != strokeStyle ||
            state.currentLineCap != lineCap ||
            state.currentLineDash != lineDash ||
            state.currentLineJoin != lineJoin ||
            state.currentLineWidth != lineWidth ||
            state.currentMiterLimit != miterLimit) {
            this.instructions.push(
                [ol.render.canvas.Instruction.SET_STROKE_STYLE,
                    strokeStyle, lineWidth, lineCap, lineJoin, miterLimit, lineDash]);
            state.currentStrokeStyle = strokeStyle;
            state.currentLineCap = lineCap;
            state.currentLineDash = lineDash;
            state.currentLineJoin = lineJoin;
            state.currentLineWidth = lineWidth;
            state.currentMiterLimit = miterLimit;
        }
    }
};



/**
 * @constructor
 * @extends {map.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.TextReplay = function(tolerance, maxExtent, resolution) {

    goog.base(this, tolerance, maxExtent, resolution);

    /**
     * @private
     * @type {?ol.render.canvas.FillState}
     */
    this.replayFillState_ = null;

    /**
     * @private
     * @type {?ol.render.canvas.StrokeState}
     */
    this.replayStrokeState_ = null;

    /**
     * @private
     * @type {?ol.render.canvas.TextState}
     */
    this.replayTextState_ = null;

    /**
     * @private
     * @type {string}
     */
    this.text_ = '';

    /**
     * @private
     * @type {number}
     */
    this.textOffsetX_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textOffsetY_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textRotation_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.textScale_ = 0;

    /**
     * @private
     * @type {?ol.render.canvas.FillState}
     */
    this.textFillState_ = null;

    /**
     * @private
     * @type {?ol.render.canvas.StrokeState}
     */
    this.textStrokeState_ = null;

    /**
     * @private
     * @type {?ol.render.canvas.TextState}
     */
    this.textState_ = null;

};
goog.inherits(map.render.canvas.TextReplay, map.render.canvas.Replay);


/**
 * @inheritDoc
 */
map.render.canvas.TextReplay.prototype.drawText =
    function(flatCoordinates, offset, end, stride, geometry, feature, objId, textStyle, lLen, lLenPixel, duplicate, isKapRemont) {
        if (this.text_ === '' ||
            goog.isNull(this.textState_) ||
            (goog.isNull(this.textFillState_) &&
                goog.isNull(this.textStrokeState_))) {
            return;
        }
        if (!goog.isNull(this.textFillState_)) {
            this.setReplayFillState_(this.textFillState_);
        }
        if (!goog.isNull(this.textStrokeState_)) {
            this.setReplayStrokeState_(this.textStrokeState_);
        }

        this.setReplayTextState_(this.textState_);
        this.beginGeometry(geometry, feature);
        var myBegin = this.coordinates.length;
        var layerGeoType = geometry.getType();//feature.getGeometry().getType();
        if(layerGeoType == 'MultiLineString'){
            var myEnd = this.appendFlatCoordinates(
                flatCoordinates, 0, flatCoordinates.length, stride,false)/2;
        }
        else
        if(layerGeoType == 'LineString'){
            myBegin = this.coordinates.length;
            //var myEnd = /*flatCoordinates.length;*/this.appendNewFlatCoordinates(
            //        flatCoordinates, 0, flatCoordinates.length, stride,false);
            var myEnd = this.appendFlatCoordinates(
                flatCoordinates, 0, flatCoordinates.length, stride,false);
        }
        else{
            var myEnd =
                this.appendNewFlatCoordinates(flatCoordinates, offset, end, stride, false);
        }

        //console.log(feature.get('layerId')+'  myEnd='+myEnd+'  myEnd1='+myEnd1);
        var fill = !goog.isNull(this.textFillState_);
        var stroke = !goog.isNull(this.textStrokeState_);
        var drawTextInstruction = [
            ol.render.canvas.Instruction.DRAW_TEXT, myBegin, myEnd, this.text_,
            this.textOffsetX_, this.textOffsetY_, this.textRotation_, this.textScale_,
            fill, stroke, geometry, objId, textStyle, lLen, flatCoordinates, lLenPixel, duplicate || 1, isKapRemont];
        this.instructions.push(drawTextInstruction);
        this.hitDetectionInstructions.push(drawTextInstruction);
        this.endGeometry(geometry, feature);
    };


/**
 * @param {ol.render.canvas.FillState} fillState Fill state.
 * @private
 */
map.render.canvas.TextReplay.prototype.setReplayFillState_ =
    function(fillState) {
        var replayFillState = this.replayFillState_;
        if (!goog.isNull(replayFillState) &&
            replayFillState.fillStyle == fillState.fillStyle) {
            return;
        }
        var setFillStyleInstruction =
            [ol.render.canvas.Instruction.SET_FILL_STYLE, fillState.fillStyle];
        this.instructions.push(setFillStyleInstruction);
        this.hitDetectionInstructions.push(setFillStyleInstruction);
        if (goog.isNull(replayFillState)) {
            this.replayFillState_ = {
                fillStyle: fillState.fillStyle
            };
        } else {
            replayFillState.fillStyle = fillState.fillStyle;
        }
    };


/**
 * @param {ol.render.canvas.StrokeState} strokeState Stroke state.
 * @private
 */
map.render.canvas.TextReplay.prototype.setReplayStrokeState_ =
    function(strokeState) {
        var replayStrokeState = this.replayStrokeState_;
        if (!goog.isNull(replayStrokeState) &&
            replayStrokeState.lineCap == strokeState.lineCap &&
            replayStrokeState.lineDash == strokeState.lineDash &&
            replayStrokeState.lineJoin == strokeState.lineJoin &&
            replayStrokeState.lineWidth == strokeState.lineWidth &&
            replayStrokeState.miterLimit == strokeState.miterLimit &&
            replayStrokeState.strokeStyle == strokeState.strokeStyle) {
            return;
        }
        var setStrokeStyleInstruction = [
            ol.render.canvas.Instruction.SET_STROKE_STYLE, strokeState.strokeStyle,
            strokeState.lineWidth, strokeState.lineCap, strokeState.lineJoin,
            strokeState.miterLimit, strokeState.lineDash, false
        ];
        this.instructions.push(setStrokeStyleInstruction);
        this.hitDetectionInstructions.push(setStrokeStyleInstruction);
        if (goog.isNull(replayStrokeState)) {
            this.replayStrokeState_ = {
                lineCap: strokeState.lineCap,
                lineDash: strokeState.lineDash,
                lineJoin: strokeState.lineJoin,
                lineWidth: strokeState.lineWidth,
                miterLimit: strokeState.miterLimit,
                strokeStyle: strokeState.strokeStyle
            };
        } else {
            replayStrokeState.lineCap = strokeState.lineCap;
            replayStrokeState.lineDash = strokeState.lineDash;
            replayStrokeState.lineJoin = strokeState.lineJoin;
            replayStrokeState.lineWidth = strokeState.lineWidth;
            replayStrokeState.miterLimit = strokeState.miterLimit;
            replayStrokeState.strokeStyle = strokeState.strokeStyle;
        }
    };


/**
 * @param {ol.render.canvas.TextState} textState Text state.
 * @private
 */
map.render.canvas.TextReplay.prototype.setReplayTextState_ =
    function(textState) {
        var replayTextState = this.replayTextState_;
        if (!goog.isNull(replayTextState) &&
            replayTextState.font == textState.font &&
            replayTextState.textAlign == textState.textAlign &&
            replayTextState.textBaseline == textState.textBaseline) {
            return;
        }
        var setTextStyleInstruction = [ol.render.canvas.Instruction.SET_TEXT_STYLE,
            textState.font, textState.textAlign, textState.textBaseline];
        this.instructions.push(setTextStyleInstruction);
        this.hitDetectionInstructions.push(setTextStyleInstruction);
        if (goog.isNull(replayTextState)) {
            this.replayTextState_ = {
                font: textState.font,
                textAlign: textState.textAlign,
                textBaseline: textState.textBaseline
            };
        } else {
            replayTextState.font = textState.font;
            replayTextState.textAlign = textState.textAlign;
            replayTextState.textBaseline = textState.textBaseline;
        }
    };


/**
 * @inheritDoc
 */
map.render.canvas.TextReplay.prototype.setTextStyle = function(textStyle) {
    if (goog.isNull(textStyle)) {
        this.text_ = '';
    } else {
        var textFillStyle = textStyle.getFill();
        if (goog.isNull(textFillStyle)) {
            this.textFillState_ = null;
        } else {
            var textFillStyleColor = textFillStyle.getColor();
            var fillStyle = ol.color.asString(!goog.isNull(textFillStyleColor) ?
                textFillStyleColor : ol.render.canvas.defaultFillStyle);
            if (goog.isNull(this.textFillState_)) {
                this.textFillState_ = {
                    fillStyle: fillStyle
                };
            } else {
                var textFillState = this.textFillState_;
                textFillState.fillStyle = fillStyle;
            }
        }
        var textStrokeStyle = textStyle.getStroke();
        if (goog.isNull(textStrokeStyle)) {
            this.textStrokeState_ = null;
        } else {
            var textStrokeStyleColor = textStrokeStyle.getColor();
            var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
            var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
            var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
            var textStrokeStyleWidth = textStrokeStyle.getWidth();
            var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
            var lineCap = goog.isDef(textStrokeStyleLineCap) ?
                textStrokeStyleLineCap : ol.render.canvas.defaultLineCap;
            var lineDash = goog.isDefAndNotNull(textStrokeStyleLineDash) ?
                textStrokeStyleLineDash.slice() : ol.render.canvas.defaultLineDash;
            var lineJoin = goog.isDef(textStrokeStyleLineJoin) ?
                textStrokeStyleLineJoin : ol.render.canvas.defaultLineJoin;
            var lineWidth = goog.isDef(textStrokeStyleWidth) ?
                textStrokeStyleWidth : ol.render.canvas.defaultLineWidth;
            var miterLimit = goog.isDef(textStrokeStyleMiterLimit) ?
                textStrokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit;
            var strokeStyle = ol.color.asString(!goog.isNull(textStrokeStyleColor) ?
                textStrokeStyleColor : ol.render.canvas.defaultStrokeStyle);
            if (goog.isNull(this.textStrokeState_)) {
                this.textStrokeState_ = {
                    lineCap: lineCap,
                    lineDash: lineDash,
                    lineJoin: lineJoin,
                    lineWidth: lineWidth,
                    miterLimit: miterLimit,
                    strokeStyle: strokeStyle
                };
            } else {
                var textStrokeState = this.textStrokeState_;
                textStrokeState.lineCap = lineCap;
                textStrokeState.lineDash = lineDash;
                textStrokeState.lineJoin = lineJoin;
                textStrokeState.lineWidth = lineWidth;
                textStrokeState.miterLimit = miterLimit;
                textStrokeState.strokeStyle = strokeStyle;
            }
        }
        var textFont = textStyle.getFont();
        var textOffsetX = textStyle.getOffsetX();
        var textOffsetY = textStyle.getOffsetY();
        var textRotation = textStyle.getRotation();
        var textScale = textStyle.getScale();
        var textText = textStyle.getText();
        var textTextAlign = textStyle.getTextAlign();
        var textTextBaseline = textStyle.getTextBaseline();
        var font = goog.isDef(textFont) ?
            textFont : ol.render.canvas.defaultFont;
        var textAlign = goog.isDef(textTextAlign) ?
            textTextAlign : ol.render.canvas.defaultTextAlign;
        var textBaseline = goog.isDef(textTextBaseline) ?
            textTextBaseline : ol.render.canvas.defaultTextBaseline;
        if (goog.isNull(this.textState_)) {
            this.textState_ = {
                font: font,
                textAlign: textAlign,
                textBaseline: textBaseline
            };
        } else {
            var textState = this.textState_;
            textState.font = font;
            textState.textAlign = textAlign;
            textState.textBaseline = textBaseline;
        }
        this.text_ = goog.isDef(textText) ? textText : '';
        this.textOffsetX_ = goog.isDef(textOffsetX) ? textOffsetX : 0;
        this.textOffsetY_ = goog.isDef(textOffsetY) ? textOffsetY : 0;
        this.textRotation_ = goog.isDef(textRotation) ? textRotation : 0;
        this.textScale_ = goog.isDef(textScale) ? textScale : 1;
    }
};



// LIBRARY from:
// https://github.com/simonsarris/Canvas-tutorials/blob/master/transform.js
// code below

function Transform() {
    this.reset();
}

Transform.prototype.reset = function() {
    this.m = [1,0,0,1,0,0];
};

Transform.prototype.multiply = function(matrix) {
    var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
    var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

    var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
    var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

    var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
    var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy;
};

Transform.prototype.invert = function() {
    var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
    var m0 = this.m[3] * d;
    var m1 = -this.m[1] * d;
    var m2 = -this.m[2] * d;
    var m3 = this.m[0] * d;
    var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
    var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
    this.m[0] = m0;
    this.m[1] = m1;
    this.m[2] = m2;
    this.m[3] = m3;
    this.m[4] = m4;
    this.m[5] = m5;
};

Transform.prototype.rotate = function(rad) {
    var c = Math.cos(rad);
    var s = Math.sin(rad);
    var m11 = this.m[0] * c + this.m[2] * s;
    var m12 = this.m[1] * c + this.m[3] * s;
    var m21 = this.m[0] * -s + this.m[2] * c;
    var m22 = this.m[1] * -s + this.m[3] * c;
    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
};

Transform.prototype.translate = function(x, y) {
    this.m[4] += this.m[0] * x + this.m[2] * y;
    this.m[5] += this.m[1] * x + this.m[3] * y;
};

Transform.prototype.scale = function(sx, sy) {
    this.m[0] *= sx;
    this.m[1] *= sx;
    this.m[2] *= sy;
    this.m[3] *= sy;
};

Transform.prototype.transformPoint = function(px, py) {
    var x = px;
    var y = py;
    px = x * this.m[0] + y * this.m[2] + this.m[4];
    py = x * this.m[1] + y * this.m[3] + this.m[5];
    return [px, py];
};

goog.provide('map.renderer.vector');

goog.require('goog.asserts');
goog.require('ol.geom.Circle');
goog.require('ol.geom.GeometryCollection');
goog.require('ol.geom.LineString');
goog.require('ol.geom.MultiLineString');
goog.require('ol.geom.MultiPoint');
goog.require('ol.geom.MultiPolygon');
goog.require('ol.geom.Point');
goog.require('ol.geom.Polygon');
goog.require('ol.render.IReplayGroup');
goog.require('ol.style.ImageState');
goog.require('ol.style.Style');



/**
 * @param {ol.render.IReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
map.renderer.vector.renderPointGeometry_ =
    function(replayGroup, geometry, style, feature) {
  goog.asserts.assertInstanceof(geometry, ol.geom.Point,
      'geometry should be an ol.geom.Point');
  var imageStyle = style.getImage();
  if (!goog.isNull(imageStyle)) {
    if (imageStyle.getImageState() != ol.style.ImageState.LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(
        style.getZIndex(), ol.render.ReplayType.IMAGE);
    imageReplay.setImageStyle(imageStyle);
    imageReplay.drawPointGeometry(geometry, feature);
  }
  var textStyle = style.getText();
  if (!goog.isNull(textStyle)) {
    var textReplay = replayGroup.getReplay(
        style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry.getCoordinates(), 0, 2, 2, geometry, feature);
  }
};

var GLOBAL_REDRAW = {};
var GLOBAL_REDRAW_COUNTER = {};
var GLOBAL_LABEL_REDRAW = {};
var GLOBAL_REDRAW_ARR = {};
var GLOBAL_REDRAW_LABEL_ARR = {};
var _labels = {};//все подписи, актуальные для данного масштаба
var _pointLabels = [];//подписи, которые попали в матрицу
var _lineLabels = [];

/**
 * @param {ol.render.IReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
map.renderer.vector.renderMultiPointGeometry_ =
    function(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != ol.style.ImageState.LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(
        style.getZIndex(), ol.render.ReplayType.IMAGE);
    imageReplay.setImageStyle(imageStyle);
      //if(feature.get('layerId')=="PODS_SHEET_NOTE_FUND")
      //console.log("WW point+"+feature.get('layerId')+'  '+feature.get('labelType'));
      var labelType = feature.get('labelType');
      //console.time(labelType);
      var layerId = feature.get('layerId');
      GLOBAL_REDRAW[labelType] = true;
      GLOBAL_LABEL_REDRAW[labelType] = true;// успловие, что лейблы можно заносить в матрицу, а потом их использовать
      GLOBAL_REDRAW_ARR[labelType] = [];
      GLOBAL_REDRAW_LABEL_ARR[labelType] = [];
      //общая разрядка подписей, если у них не установлен overlap
      if(!goog.isDef(GLOBAL_REDRAW_LABEL_ARR['common']))
        GLOBAL_REDRAW_LABEL_ARR['common'] = {};
      _labels[labelType] = [];
      //_pointLabels[feature.get('labelType')] = {};
      //WidgetMap.regenerateMatrix(_dx,_dy,10,10,feature.get('labelType'));
      if(goog.isDef(_IS_CHANGE_LAYER_VISIBILITY[layerId])){
        _IS_CHANGE_LAYER_VISIBILITY[layerId] = {};
      }
    //перед обработкой чистим массив с подписями и временный массив
    _TEMP_LAYERS_LABELS[labelType] = [];
    if(_LABELS.length>0){
      var i=_LABELS.length-1;
      for(i; i >= 0;i--){
        if(_LABELS[i].unique.indexOf(labelType+'_') != -1)
          _LABELS.splice(i,1);
      }
    }
    //console.log('renderMultiLineStringGeometry_   '+_LABELS.length+'  name='+name);
    if(_pointLabels.length>0){
      var i=_pointLabels.length-1;
      for(i; i >= 0;i--){
        if(_pointLabels[i].unique.indexOf(labelType+'_') != -1)
          _pointLabels.splice(i,1);
      }
    }
    imageReplay.drawMultiPointGeometry(geometry, feature,labelType);
    //GLOBAL_REDRAW[feature.get('layerId')] = false;
    //GLOBAL_REDRAW_ARR[feature.get('layerId')] = {};
  }
  //console.log('Point  '+feature.get('labelType'));
  var textStyle = style.getText();
      //textStyle = null;
  if (!goog.isNull(textStyle)) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var textReplay;
    //var labels = geometry.get('labels');
    //var labels = globalPointsLabels_[feature.get('labelType')];
    //for(var f=0;f < flatCoordinates.length; f++) {
      textReplay = replayGroup.getReplay(
          style.getZIndex(), ol.render.ReplayType.TEXT);
      //textStyle.setText(labels[f/2]);
      textStyle.setText('ff');
    //console.log('coords='+flatCoordinates.length);
      textReplay.setTextStyle(textStyle);
      //textReplay.drawText([flatCoordinates[f],flatCoordinates[f+1]], 0, 2,
      //    geometry.getStride(), geometry, feature);
    //  f++;
    //}

    textReplay.drawText(flatCoordinates, 0, flatCoordinates.length,
        geometry.getStride(), geometry, feature,'', textStyle);
  }
  //console.timeEnd(labelType);
};


/**
 * @param {ol.render.IReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
map.renderer.vector.renderMultiLineStringGeometry_ =
    function(replayGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
        var lineStringReplay = replayGroup.getReplay(
            style.getZIndex(), ol.render.ReplayType.LINE_STRING);
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        var layerId = feature.get('layerId');
        var labelType = feature.get('labelType');
        if(goog.isDef(_IS_CHANGE_LAYER_VISIBILITY[layerId])){
          _IS_CHANGE_LAYER_VISIBILITY[layerId] = {};
        }
        //перед обработкой чистим массив с подписями и временный массив
        _TEMP_LAYERS_LABELS[labelType] = [];
        if(_LABELS.length>0){
          var i=_LABELS.length-1;
          for(i; i >= 0;i--){
            if(_LABELS[i].unique.indexOf(labelType+'_') != -1)
              _LABELS.splice(i,1);
           }
        }
        if(_pointLabels.length>0){
          var i=_pointLabels.length-1;
          for(i; i >= 0;i--){
            if(_pointLabels[i].unique.indexOf(labelType+'_') != -1)
              _pointLabels.splice(i,1);
          }
        }
        GLOBAL_REDRAW[labelType] = true;
        GLOBAL_REDRAW_COUNTER[labelType] = 0;
        var styleArr = map.renderer.vector.getStyleMultiTypeFeature_(feature,'LineString');
        lineStringReplay.drawMultiLineStringGeometry(geometry, feature, style, replayGroup, style.getText(), styleArr);
      }
};

/**
 * Получение массива стилей для фичи
 * @param feature
 * @param type - Тип геометрии
 * @returns {*}
 * @private
 */
map.renderer.vector.getStyleMultiTypeFeature_ = function(feature,type){
  var mapZoom = WidgetMap.map.getView().getZoom();
  //если в id слоя есть "#", то это пка и клонированный слой
  //из типа надо вычленить уникальный id: от # до первого _
  var lType = undefined;
  if(goog.isDef(feature.get('type'))){
    var splitted = feature.get('type').split('#');
    lType = splitted[0];
    var typeStr = '';
    if(splitted.length>1){
      var sp = splitted[1].split('_');
      if(sp.length>1){
        //удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
        sp.splice(0,1);
        typeStr ='_'+sp.join('_');
        lType += typeStr;
      }
    }
  }
  var s;
  //отдельно обрабатываем тип фичи косметики с горизонтальными линиями
  var featureType = feature.get('featureType');
  if(featureType !== undefined && featureType === 'cosmetic'){
    try{

      lType = feature.get('labelType').split('/')[1];
      s = (goog.isNull(feature.get('layerId')))?null:WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lType,'LineString');
      if(!goog.isNull(s) && !goog.isNull(s.style)){
        if(goog.isArray(s.style))
          return [s.style[0]];
        return [s.style];
      }
    }
    catch(e){}
  }


  //если установлен стиль в _layers в <dataProvider>
  var dps = feature.get('dataProviderStyle');
  if(goog.isDef(dps)){
    s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(dps+typeStr,type);
    if(!goog.isNull(s) && !goog.isNull(s.style)){
      if(!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
        return [];
      if(goog.isArray(s.style))
        return s.style;
      return [s.style];
    }
    else{
      s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(dps,type);
      if(!goog.isNull(s) && !goog.isNull(s.style)){
        if(!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
          return [];
        if(goog.isArray(s.style))
          return s.style;
        return [s.style];
      }
    }

  }


  var lId = undefined;
  if(goog.isDef(feature.get('layerId')))
    lId = feature.get('layerId').split('#')[0];
  s = (goog.isNull(lId))?null:WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lType,type);
  if(!goog.isNull(s) && !goog.isNull(s.style)){
    if(!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
      return [];
    if(goog.isArray(s.style))
      return s.style;
    return [s.style];
  }

  s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lId,type);
  if(!goog.isNull(s) && !goog.isNull(s.style)){
    if(!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
      return [];
    if(goog.isArray(s.style))
      return s.style;
    return [s.style];
  }
  s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT',type);
  if(!goog.isNull(s && !goog.isNull(s.style))) {
    if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
      return [];
    if(goog.isArray(s.style))
      return s.style;
    return [s.style];
  }
};


/**
 * @param {ol.render.IReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
map.renderer.vector.renderMultiPolygonGeometry_ =
    function(replayGroup, geometry, style, feature) {
      goog.asserts.assertInstanceof(geometry, ol.geom.MultiPolygon,
          'geometry should be an ol.geom.MultiPolygon');
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      //strokeStyle = new ol.style.Stroke({color: '#ff0000',width: 3});
      if (strokeStyle || fillStyle) {
        var polygonReplay = replayGroup.getReplay(
            style.getZIndex(), ol.render.ReplayType.POLYGON);
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);


        var layerId = feature.get('layerId');
        var labelType = feature.get('labelType');
        if(goog.isDef(_IS_CHANGE_LAYER_VISIBILITY[layerId])){
          _IS_CHANGE_LAYER_VISIBILITY[layerId] = {};
        }
        //перед обработкой чистим массив с подписями и временный массив
        _TEMP_LAYERS_LABELS[labelType] = [];
        if(_LABELS.length>0){
          var i=_LABELS.length-1;
          for(i; i >= 0;i--){
            if(_LABELS[i].unique.indexOf(labelType+'_') != -1)
              _LABELS.splice(i,1);
          }
        }
        if(_pointLabels.length>0){
          var i=_pointLabels.length-1;
          for(i; i >= 0;i--){
            if(_pointLabels[i].unique.indexOf(labelType+'_') != -1)
              _pointLabels.splice(i,1);
          }
        }
        GLOBAL_REDRAW[labelType] = true;
        GLOBAL_REDRAW_COUNTER[labelType] = 0;
        var styleArr = map.renderer.vector.getStyleMultiTypeFeature_(feature,'Polygon');

        polygonReplay.drawMultiPolygonGeometry(geometry, feature, style, replayGroup, style.getText(), styleArr);
      }
    };
/**
 * Класс, который содержит данные по вектору подписи
 * @param opt_option
 * @constructor
 */
map.renderer.vector.TextVector = function(opt_option){
  var options = opt_option || {};
  this.text = options.text;
  this.baseText = options.text;
  this.x = options.x;
  this.y = options.y;
  this.coordEnd = options.coordEnd;
  this.rotation = options.rotation;
  this.lineString = options.lineString;
  this.textStyle = options.textStyle;
  this.textWidth = options.textWidth;
  this.textHeight = options.textHeight;
  this.bounds = options.bounds;
}
goog.provide('map.interaction.DragZoomInOut');

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * @constructor
 * @extends {ol.interaction.DragBox}
 * @param {olx.interaction.DragZoomOptions=} opt_options Options.
 * @api stable
 */
map.interaction.DragZoomInOut = function(opt_options) {
    var options = goog.isDef(opt_options) ? opt_options : {};
    ol.DRAG_BOX_HYSTERESIS_PIXELS_SQUARED = 0;
    var condition = goog.isDef(options.condition) ?
        options.condition : ol.events.condition.mouseOnly;

    this.endHandler = goog.isDef(options.endHandler) ?
        options.endHandler : undefined;
    this.isZoomIn_ = goog.isDef(options.isZoomIn) ?
        options.isZoomIn : true;
    goog.base(this, {
        condition: condition
    });

};
goog.inherits(map.interaction.DragZoomInOut, ol.interaction.DragZoom);


/**
 * @inheritDoc
 */
map.interaction.DragZoomInOut.prototype.onBoxEnd = function(event) {
    var map = this.getMap();
    var view = map.getView();
    goog.asserts.assert(goog.isDef(view));
    var extent = this.getGeometry().getExtent();
    if(this.endHandler) {
        this.endHandler(extent, event);
        return;
    }
    var extentSize = ol.extent.getSize(extent);
    var center = ol.extent.getCenter(extent);
    //если просто кликнули, то зуммируемся на уровень вверх/низ в зависимости от выбранного режима
    if(extentSize[0] == 0 && extentSize[1] == 0){
        var currentZoom = view.getZoom();
        view.setCenter(center);
        if(this.isZoomIn_) {
            view.setZoom(currentZoom + 1);
        }
        else {
            view.setZoom(currentZoom - 1);
        }
        return;
    }
    var size = map.getSize();
    goog.asserts.assert(goog.isDef(size));
    if(this.isZoomIn_){
        view.fit(extent, size);
    } else {
        var mapLeftTop = map.getCoordinateFromPixel([0,0]);
        var mapRightBottom = map.getCoordinateFromPixel(size);
        var cntr = [extent[0] + extentSize[0]/2, extent[3] + extentSize[1]/2];
        var zoom = Math.max(extentSize[0]/Math.abs(mapRightBottom[0]-mapLeftTop[0]), extentSize[1]/Math.abs(mapLeftTop[0]-mapRightBottom[0]));
        var bnd = [cntr[0] + (mapLeftTop[0] - cntr[0])/zoom,
                cntr[1] + (mapRightBottom[1] - cntr[1])/zoom,
                cntr[0] + (mapLeftTop[0] - cntr[0])/zoom + (mapRightBottom[0] - mapLeftTop[0])/zoom,
                cntr[1] + (mapRightBottom[1] - cntr[1])/zoom + (mapLeftTop[1] - mapRightBottom[1])/zoom];
        view.fit(bnd, size);
    }

};
goog.provide('map.interaction.DrawMeasure');

map.interaction.DrawMeasure = function(options) {
    goog.base(this,options);
};

goog.inherits(map.interaction.DrawMeasure, ol.interaction.Draw);

/**
 * Handle move events.
 * @param {ol.MapBrowserEvent} event A move event.
 * @return {boolean} Pass the event to other interactions.
 * @private
 */
map.interaction.DrawMeasure.prototype.handlePointerMove_ = function(event) {
    if (this.mode_ === ol.interaction.DrawMode.POINT &&
        goog.isNull(this.finishCoordinate_)) {
        this.startDrawing_(event);
    }
    else if (this.finishCoordinate_) {
        this.modifyDrawing_(event);
    } else {
        this.createOrUpdateSketchPoint_(event);
    }
    this.dispatchEvent(new ol.interaction.DrawEvent('calculatedistance',
        this.sketchFeature_, event));
    return true;
};

/**
 * Redraw the skecth features.
 * @private
 */
map.interaction.DrawMeasure.prototype.updateSketchFeatures_ = function() {
    var sketchFeatures = [];
    if (this.sketchFeature_) {
        sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
        sketchFeatures.push(this.sketchLine_);// рисуются линии для полигона
    }
    //без отображения стартовой точки
    if (this.sketchPoint_) {
        //sketchFeatures.push(this.sketchPoint_);
    }
    var overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);

};


/**

 /**
 * Add a new coordinate to the drawing.
 * @param {ol.MapBrowserEvent} event Event.
 * @private
 */
map.interaction.DrawMeasure.prototype.addToDrawing_ = function(event) {
    var coordinate = event.coordinate;
    var geometry = this.sketchFeature_.getGeometry();
    goog.asserts.assertInstanceof(geometry, ol.geom.SimpleGeometry,
        'geometry must be an ol.geom.SimpleGeometry');
    var done;
    var coordinates;
    if (this.mode_ === ol.interaction.DrawMode.LINE_STRING) {
        this.finishCoordinate_ = coordinate.slice();
        coordinates = this.sketchCoords_;
        coordinates.push(coordinate.slice());
        done = coordinates.length > this.maxPoints_;
        this.geometryFunction_(coordinates, geometry);
    } else if (this.mode_ === ol.interaction.DrawMode.POLYGON) {
        coordinates = this.sketchCoords_[0];
        coordinates.push(coordinate.slice());
        done = coordinates.length > this.maxPoints_;
        if (done) {
            this.finishCoordinate_ = coordinates[0];
        }
        this.geometryFunction_(this.sketchCoords_, geometry);
    }
    this.updateSketchFeatures_();
    //вызываем событие для пересчета длин
    this.dispatchEvent(new ol.interaction.DrawEvent('calculatedistance',
        this.sketchFeature_, event));
    if (done) {
        this.finishDrawing();
    }

};
goog.provide('map.interaction.DrawGeometry');



/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @fires map.interaction.DrawGeometryEvent
 * @param {olx.interaction.DrawOptions} options Options.
 * @api stable
 */
map.interaction.DrawGeometry = function(options) {
	goog.base(this,options);
};
goog.inherits(map.interaction.DrawGeometry, ol.interaction.Draw);

/**
 * Add a new coordinate to the drawing.
 * @param {ol.MapBrowserEvent} event Event.
 * @private
 */
map.interaction.DrawGeometry.prototype.addToDrawing_ = function(event) {
	var coordinate = event.coordinate;
	var geometry = this.sketchFeature_.getGeometry();
	goog.asserts.assertInstanceof(geometry, ol.geom.SimpleGeometry,
		'geometry must be an ol.geom.SimpleGeometry');
	var done;
	var coordinates;
	if (this.mode_ === ol.interaction.DrawMode.LINE_STRING) {
		this.finishCoordinate_ = coordinate.slice();
		coordinates = this.sketchCoords_;
		coordinates.push(coordinate.slice());
		done = coordinates.length > this.maxPoints_;
		this.geometryFunction_(coordinates, geometry);
	} else if (this.mode_ === ol.interaction.DrawMode.POLYGON) {
		coordinates = this.sketchCoords_[0];
		coordinates.push(coordinate.slice());
		done = coordinates.length > this.maxPoints_;
		if (done) {
			this.finishCoordinate_ = coordinates[0];
		}
		this.geometryFunction_(this.sketchCoords_, geometry);
	}
	this.updateSketchFeatures_();

	if (done) {
		this.finishDrawing();
	}
	//вызываем событие для пересчета длин
	this.dispatchEvent(new ol.interaction.DrawEvent('calculatedistance',
		this.sketchFeature_));
};
goog.provide('map.controls.GeometryLoaderControl');



/**
 * Контрол для поиска маршрута
 * @constructor
 */
map.controls.GeometryLoaderControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	this.loadingText = goog.isDef(options.loadingText) ?
		options.loadingText : '';
	this.descrText = goog.isDef(options.descrText) ?
		options.descrText : gis_loadercontrol_2;
	this.loadingElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
		className : 'map-geometry-loader'

	}, null, this.loadingText);
	this.descrElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
		className : 'map-geometry-loader__descr'
	}, null, this.descrText);
	this.innerElement = goog.dom.createDom(goog.dom.TagName.DIV, null, this.loadingElement, this.descrElement);
	goog.base(this, {
		element: this.innerElement,
		target: options.target
	});
};
goog.inherits(map.controls.GeometryLoaderControl, ol.control.Control);

map.controls.GeometryLoaderControl.prototype.setVisible = function (renderVisible) {
	if(renderVisible) {
		if (!goog.isNull(this.map_)) {
			var target = !goog.isNull(this.target_) ?
				this.target_ : this.map_.getOverlayContainerStopEvent();
			goog.dom.appendChild(target, this.innerElement);
		}
		else
			goog.dom.removeNode(this.innerElement);
	}
	else
		goog.dom.removeNode(this.innerElement);
};
goog.provide('map.controls.BaseLayerMenuControl');
/**
 * @constructor
 * @extends {ol.control.Control}
 * @param {Object=} opt_options Control options.
 */
map.controls.BaseLayerMenuControl = function(opt_options){
    var options = opt_options || {};
    //var comboBox = document.createElement('select');
    var className = goog.isDef(options.className) ?
        options.className : 'map-baselayers';
    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;


    var radioVector = goog.dom.createDom(goog.dom.TagName.DIV);//,null,'Векторный режим');
    var radioRaster = goog.dom.createDom(goog.dom.TagName.DIV);
    var radioVectorLabel = goog.dom.createDom(goog.dom.TagName.LABEL, {
        className : 'map-baselayer-label',
        title:gis_baselayermenucontrol_1

    }, null,gis_baselayermenucontrol_2);
    var radioRasterLabel = goog.dom.createDom(goog.dom.TagName.LABEL, {
        className : 'map-baselayer-modeslabel',
        title:gis_baselayermenucontrol_3
    }, null,gis_baselayermenucontrol_4);
    $(radioVector).jqxRadioButton({ width: 20, groupName:'radioMode', checked:WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR, theme:'gis-radio'}).css('display','inline-block')
        .bind('change', function (event) {
        var checked = event.args.checked;
        WidgetMap.changeMode(checked);
    });
    $(radioRaster).jqxRadioButton({ width: 20, groupName:'radioMode', checked:WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER, theme:'gis-radio' }).css('display','inline-block')
        .css('margin-left','20px');

    //var radioVectorDiv = goog.dom.createDom(goog.dom.TagName.DIV,'', radioVector,radioVectorLabel);
    //var radioRasterDiv = goog.dom.createDom(goog.dom.TagName.DIV,'', radioRaster,radioRasterLabel);

    var modesDiv = goog.dom.createDom(goog.dom.TagName.DIV,'', radioVector,radioVectorLabel, radioRaster,radioRasterLabel);
    $(modesDiv).addClass('map-baselayer-modesdiv');
    var source = {
        localdata: [],
        datatype: "array"
    };
    var dataAdapter = new $.jqx.dataAdapter(source);
    this.combobox = goog.dom.createDom(goog.dom.TagName.DIV);
    $(this.combobox).jqxBaseLayersList({ source: dataAdapter, selectedIndex: 0,
        placeHolder:gis_baselayermenucontrol_5,
        theme:'gis-blue',
        displayMember: "label",
        valueMember: "id",
        width: 200, height: 20,
        dropDownWidth: 380,
        autoDropDownHeight: true
    });
    $(this.combobox).addClass('map-baselayers-inner');
    this.isFirstLoad = false;
    var that = this;
    $(this.combobox).on('select', function (event) {
        if(that.isFirstLoad == true){
            that.isFirstLoad = false;
            return false;
        }
        var args = event.args;
        if (goog.isDef(args)) {
            var item = event.args.item;
            WidgetMap.baseLayer = item;
	        WidgetMap.currentMapId = item.value;
            //если выставлен флаг для дизейблинга кнопок и выбран режим интернет подложки, то дизейблим кнопки
	        if(goog.isDef(WidgetMap) && WidgetMap.isPrintDisabled_()){
		        WidgetMap.exportImageChooserControl.disableButtons();
	        }
            WidgetMap.layerManager.clearRasterDatas();
            var baseLayerGroup = WidgetMap.BaseLayersParser.getLayer(item.value);

            if(goog.isDef(WidgetMap.map)){
                var coll = new ol.Collection(baseLayerGroup);
                WidgetMap.BaseLayersParser.currentBaseLayers.setLayers(coll);
                WidgetMap.changeMapView(WidgetMap.BaseLayersParser.getMaxZoom(),item.value,item.originalItem.projection);
            }
        }
        return false;
    });

    if(goog.isDefAndNotNull(WidgetMap.BaseLayersParser.dataProvider) && goog.isArray(WidgetMap.BaseLayersParser.dataProvider)) {
	    this.changeListByMode();
    }

    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, modesDiv, this.combobox );
    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.BaseLayerMenuControl, ol.control.Control);


//фильтруем данные в списке, чтобы там были только для текущего режима
map.controls.BaseLayerMenuControl.prototype.getListByMode = function(){
    var newArr = [];
    var i = 0;
    for(;i<WidgetMap.BaseLayersParser.dataProvider.length;i++){
        var el = WidgetMap.BaseLayersParser.dataProvider[i];
        if(el.isRaster == true && WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER ){
            newArr.push(el);
        }
        if(el.isRaster != true && WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR){
            newArr.push(el);
        }
    }
    return newArr;
};

//устанавливаем в комбобокс новые данные
map.controls.BaseLayerMenuControl.prototype.changeListByMode = function(){
    this.isFirstLoad = true;
    var arr = this.getListByMode();
    var source = {
        localdata: [],
        datatype: "array"
    };
    source.localdata = arr;
    var dataAdapter = new $.jqx.dataAdapter(source);
    var selectedIndex = 0;
	var i=0;
    if(goog.isDef(WidgetMap) && goog.isDef(WidgetMap.currentMapId)){
	    var mapIdWithMode = WidgetMap.currentMapId;
	    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER) {
            if(mapIdWithMode.indexOf('_RASTERMODE') == -1)
                mapIdWithMode +='_RASTERMODE';
        }
	    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR) mapIdWithMode = mapIdWithMode.replace('_RASTERMODE','');
        for(; i<arr.length;i++){
            if(arr[i].id == mapIdWithMode){
	            selectedIndex = i;
                break;
            }
        }
    }
    $(this.combobox).jqxBaseLayersList({source: dataAdapter,selectedIndex:selectedIndex});
};

goog.provide('map.controls.ClearCosmeticControl');
goog.provide('map.controls.PanControl');
goog.provide('map.controls.ZoomBoxControl');
goog.provide('map.controls.ZoomSliderControl');


goog.provide('map.controls.FullMapControl');

goog.provide('map.controls.ExportImageChooserControl');
goog.provide('map.controls.ExportImageControl');
goog.provide('map.controls.CASExportImageControl');

goog.require('map.interaction.DragZoomInOut');



map.controls.CLASS_CONTROL = 'map-control';

map.controls.PRINT_TYPE = {
    PRINT: 'print',
    EXPORT: 'export'
};

/**
 * Контрол для перемещения руков на карте
 * @constructor
 */
map.controls.PanControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-pan';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_basecontrols_1;

    this.panElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-button  selectedMapButton',
        'type' : 'button',
        'title' : tooltipLabel
    });
    //устанавливаем дефолтную выбранную кнопку
    WidgetMap.selectedMapButton = this.panElement;


    goog.events.listen(this.panElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.PanControl.prototype.handlePanClick_), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.panElement);

    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.PanControl, ol.control.Control);

/**
 * Реация на нажатие кнопки перемещения по карте
 * @private
 */
map.controls.PanControl.prototype.handlePanClick_ = function() {
    if(goog.isDef(WidgetMap.panControl))
        WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.PAN,WidgetMap.panControl.panElement);
    else if(goog.isDef(this.panElement)){
        WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.PAN,this.panElement);
    }
    //удаляем сначала перемещение мышью
    WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
    WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);

    WidgetMap.baseInteraction = new ol.interaction.DragPan({
        kinetic: (goog.isDef(WidgetMap.kinetic))?WidgetMap.kinetic:null
    });
    WidgetMap.map.addInteraction(WidgetMap.baseInteraction);
};

map.controls.PanControl.handleEvent = function(mapBrowserEvent) {
    var stopEvent = false;
    var browserEvent = mapBrowserEvent.browserEvent;
    if (mapBrowserEvent.type == ol.MapBrowserEvent.EventType.DBLCLICK) {
        var map = mapBrowserEvent.map;
        mapBrowserEvent.preventDefault();
        stopEvent = true;
    }
    return !stopEvent;
};

map.controls.PanControl.reset = function(){
};

/**
 * Контрол для кнопок увеличения/уменьшения в виде лупы
 * @constructor
 */
map.controls.ZoomBoxControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-zoombox';

    var tooltipLabelIn = goog.isDef(options.tooltipLabelZoomIn) ?
        options.tooltipLabelZoomIn : gis_basecontrols_2;
    this.inElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-in',
        'type' : 'button',
        'title' : tooltipLabelIn
    });


    this.inElement.style.display = 'inline';

    goog.events.listen(this.inElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ZoomBoxControl.prototype.handleZoomBoxClick_,'zoomIn'), false, this);

    var tooltipLabelOut = goog.isDef(options.tooltipLabelZoomOut) ?
        options.tooltipLabelZoomOut : gis_basecontrols_3;
    this.outElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-out',
        'type' : 'button',
        'title' : tooltipLabelOut
    });
    this.outElement.style.display = 'inline';

    goog.events.listen(this.outElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ZoomBoxControl.prototype.handleZoomBoxClick_,'zoomOut'), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.inElement,
        this.outElement);

    goog.base(this, {
        element: element,
        target: options.target
    });

};
goog.inherits(map.controls.ZoomBoxControl, ol.control.Control);


/**
 * Реация на нажатие кнопок зуммирования
 * @param type тип нажатой кнопки(zoomIn или zoomOut)
 * @private
 */
map.controls.ZoomBoxControl.prototype.handleZoomBoxClick_ = function(type) {
    var currB = (type === "zoomIn")?this.inElement:this.outElement;
    WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.ZOOM, currB);
    //удаляем сначала перемещение мышью
    WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
    WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);
    // вкл/выкл режим дополнительно, если нажали 2-й раз ту же кнопку
    if(WidgetMap.baseInteraction && WidgetMap.baseInteraction.isZoomIn_  !== undefined){
        if((type === "zoomIn" && WidgetMap.baseInteraction.isZoomIn_ === true) || (type === "zoomOut" && WidgetMap.baseInteraction.isZoomIn_ === false)){
                this.reset();
                return;
            }
    }

    var isZoomIn = type === "zoomIn";
    WidgetMap.baseInteraction =
        new map.interaction.DragZoomInOut({
            isZoomIn: isZoomIn,
            //endHandler: map.controls.ZoomBoxControl.endHandler
        });
    WidgetMap.map.addInteraction(WidgetMap.baseInteraction);
};

map.controls.ZoomBoxControl.prototype.reset = function(){
    WidgetMap.handleEscClick_();
};

map.controls.ZoomBoxControl.endHandler = function(){
    //WidgetMap.handleEscClick_();
};

map.controls.ZoomBoxControl.reset = function(){
    //WidgetMap.handleEscClick_();
};



/**
 * Контрол "показать всю карту"
 * @constructor
 */
map.controls.FullMapControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-fullmap';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_basecontrols_4;
    var panElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });


    goog.events.listen(panElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.FullMapControl.prototype.handleFullMapClick_), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, panElement);
    }
    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.FullMapControl, ol.control.Control);


/**
 * Реация на нажатие кнопки перемещения по карте
 * @private
 */
map.controls.FullMapControl.prototype.handleFullMapClick_ = function() {
    //забираем координаты и зум из конфига
    var zoom = WidgetMap.START_ZOOM;
    var centerX = WidgetMap.START_X;
    var centerY = WidgetMap.START_Y;
   
    if(WidgetMap.DEFAULT_PROJECTION == 'EPSG:5807'){
        this.centerOn_([centerX,centerY], zoom);
    }
    else{
         //переводим координаты в проекцию базового слоя
        var coords = GeoUtil.convertCoords([centerX, centerY],GeoUtil.PROJS.WGS84, WidgetMap.DEFAULT_PROJECTION);
        this.centerOn_(coords, zoom);
    }
};

/**
 * Центрирование карты по координатам и зуму
 *
 * @param center - массив [centerX, centerY]
 * @param zoom
 * @private
 */
map.controls.FullMapControl.prototype.centerOn_ = function(center, zoom) {
    var map = WidgetMap.map;
    if(!goog.isDefAndNotNull(map))
        return;
    var view = map.getView();
    var currentResolution = view.getResolution();
    if (goog.isDef(currentResolution)) {
        if (this.duration_ > 0) {
            map.beforeRender(ol.animation.zoom({
                resolution: currentResolution,
                duration: 250,
                easing: ol.easing.easeOut
            }));
        }

        var resolution = view.constrainResolution(
            view.maxResolution_, zoom - view.minZoom_, 0);

        view.setResolution(resolution);
        view.setCenter([center[0], center[1]]);
    }
};

/**
 * Контрол для выбора вариантов экспорта/печати карты
 * @param opt_options
 * @constructor
 */
map.controls.ExportImageChooserControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-choose-image';

    this.currentExportImage = map.controls.PRINT_TYPE.PRINT;
	this.isVisible = false;

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_basecontrols_5;
    this.innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-current map-image-print',
        'type' : 'button',
        'title' : tooltipLabel
    });
    this.innerElement.style.display = 'inline';

    this.arrowElement = goog.dom.createDom(goog.dom.TagName.DIV, {
        'class': className + '-arrow',
        'type' : 'button',
        'title' : tooltipLabel
    });
	this.arrowElement.style.display = 'inline';
    goog.events.listen( this.innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageClick_), false, this);

    goog.events.listen( this.innerElement,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseover'), false, this);
    goog.events.listen( this.innerElement,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen( this.innerElement,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseenter'), false, this);
    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.arrowElement, this.innerElement);

    /*$('.map-image').mouseup(function (e) {
        e.stopPropagation();
    });
    $('.map-choose-image').mouseup(function (e) {
        e.stopPropagation();
    });*/
    goog.base(this, {
        element: element,
        target: options.target
    });

};
goog.inherits(map.controls.ExportImageChooserControl, ol.control.Control);

/**
 * Реакция на нажатия стрелки выбора кнопки. Старая версия. Используется в ПКА
 * @private
 */
map.controls.ExportImageChooserControl.prototype.handleExportImageChooseClick_ = function(type) {
    if(WidgetMap.exportImageControl !== undefined)
        WidgetMap.exportImageControl.setVisible_(!WidgetMap.exportImageControl.isVisible);
};
/**
 * Реация на нажатие кнопки поиска
 * @private
 */
map.controls.ExportImageChooserControl.prototype.handleExportImageClick_ = function() {
    MapUtil.closeButtons('export');
	return;
    if(goog.isDef(WidgetMap.exportImageControl) && WidgetMap.exportImageControl.innerElementPrint.className.indexOf('map-image-print-disable')!=-1)
        return;
    WidgetMap.exportImageControl.handleExportImageClick_(this.currentExportImage);
};

/**
 * Дизейблим кнопки при смене режима карты на интернет режим, чтобы при экс
 * @private
 */
map.controls.ExportImageChooserControl.prototype.disableButtons = function() {
    if(goog.isDef(WidgetMap.exportImageControl)){//дизеблим кнопки
	    $(WidgetMap.exportImageControl.innerElementExport).removeClass('map-image-export');
	    $(WidgetMap.exportImageControl.innerElementExport).addClass('map-image-export-disable');
	    $(WidgetMap.exportImageControl.innerElementPrint).removeClass('map-image-print');
	    $(WidgetMap.exportImageControl.innerElementPrint).addClass('map-image-print-disable');
    }
    if(this.innerElement.className.indexOf('map-image-export')!=-1){
	    $(this.innerElement).removeClass('map-image-export');
	    $(this.innerElement).addClass('map-image-export-disable');
    }
    else{
	    $(this.innerElement).removeClass('map-image-print');
	    $(this.innerElement).addClass('map-image-print-disable');
    }
};
/**
 * Реация на нажатие кнопки выбора режима поиска
 * @private
 */
map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_ = function(eventType) {
	return;
    if(eventType === 'mouseover') {
        WidgetMap.exportImageControl.setVisible_(true);
        if(WidgetMap.baseLayersControl !== undefined)
            WidgetMap.baseLayersControl.close();
    }
    if(eventType === 'mouseleave'){
        setTimeout(function(){
            WidgetMap.exportImageControl.setVisible_(false);
        },2000);
    }
};


/**
 * Смена типа экспорта/печати по клику на кнопки из map.controls.ExportImageControl
 * @private
 */
map.controls.ExportImageChooserControl.prototype.changeExportImageType = function(type) {
    this.currentExportImage = type;
    if(type == map.controls.PRINT_TYPE.PRINT){
        $(this.innerElement).addClass('map-image-print');
        $(this.innerElement).removeClass('map-image-export');
    }
    if(type == map.controls.PRINT_TYPE.EXPORT){
        $(this.innerElement).removeClass('map-image-print');
        $(this.innerElement).addClass('map-image-export');
    }
};

/**
 * Контрол "Экспорт в png"
 * @constructor
 */
map.controls.ExportImageControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-image';

    var needExport = goog.isDef(options.needExport) ?
        options.needExport : true;
    var needPrint = goog.isDef(options.needPrint) ?
        options.needPrint : true;

    this.isVisible = false;

    var tooltipLabelPrint = goog.isDef(options.tooltipLabelPrint) ?
        options.tooltipLabelPrint : gis_basecontrols_6;
    this.innerElementPrint = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-print',
        'type' : 'button',
        'title' : tooltipLabelPrint
    });
    //innerElementPrint.style.display = 'inline';

    goog.events.listen(this.innerElementPrint,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ExportImageControl.prototype.handleExportImageClick_,map.controls.PRINT_TYPE.PRINT), false, this);


    var tooltipLabelExport = goog.isDef(options.tooltipLabelExport) ?
        options.tooltipLabelExport : gis_basecontrols_7;
    this.innerElementExport = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-export',
        'type' : 'button',
        'title' : tooltipLabelExport
    });
    //innerElementExport.style.display = 'inline';

    goog.events.listen(this.innerElementExport,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ExportImageControl.prototype.handleExportImageClick_,map.controls.PRINT_TYPE.EXPORT), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element;
    if(!needExport) this.innerElementExport = undefined;
    if(!needPrint) this.innerElementPrint = undefined;
    if(!needExport && !needPrint) options.noElement = true;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.innerElementPrint, this.innerElementExport);
    goog.events.listen(element,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseover'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseenter'), false, this);
    goog.base(this, {
        element: element,
        target: options.target
    });
};
goog.inherits(map.controls.ExportImageControl, ol.control.Control);

/**
 * Скрыть/показать список кнопок
 * @param visible
 * @private
 */
map.controls.ExportImageControl.prototype.setVisible_ = function(visible) {
    if(visible)
        $('.map-image').css('visibility','visible');
    else
        $('.map-image').css('visibility','hidden');
    this.isVisible = visible;
};

/**
 * Реакция на нажатие кнопки экспорта изображения
 * @private
 */
map.controls.ExportImageControl.prototype.handleExportImageClick_ = function(type) {
    if(goog.isDef(WidgetMap.exportImageControl) && WidgetMap.exportImageControl.innerElementPrint.className.indexOf('map-image-print-disable')!=-1)
        return;
    var that = this;
    if(goog.isDef(WidgetMap.exportImageChooserControl)){
		this.setVisible_(false);
		WidgetMap.exportImageChooserControl.changeExportImageType(type);
    }
    if(goog.isDefAndNotNull(WidgetMap.map)){
        WidgetMap.map.once('postcompose', function(event) {
            var canvas = event.context.canvas;
            switch(type){
                case map.controls.PRINT_TYPE.EXPORT:{
                    try{
                        that.exportImage(canvas);
                    }
                    catch(ex){
                        BlockingUtil.ready();
                        App.errorReport(gis_basecontrols_8, ex, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_1'});
                    }

                    break;
                }
                case map.controls.PRINT_TYPE.PRINT:{
                    try{
	                    var img = canvas.toDataURL("image/png");
	                    //получаем элемент с линейкой масштаба
	                    var scaleLine = $('.ol-scale-line');
	                    var outerScaleHtml = '';
	                    if(scaleLine.length > 0)
		                    outerScaleHtml = scaleLine[0].outerHTML;
	                    var dsp = $('.map-dsp-label');
	                    var dspHtml = '';
	                    if(dsp.length > 0)
		                    dspHtml = dsp[0].outerHTML;
	                    //ie9 кидает ошибку,
	                    var ww = window.open('','','toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes');
	                    var resultHTML = '<head><meta http-equiv="X-UA-Compatible" content="IE=9" />' +
		                    '<link href="./css/print.css" rel="stylesheet"></head>' +
		                    '<body><input type="Button" onclick="window.print()" value="Печать"><br/>' +
		                    '<div style="position: relative;height:'+canvas.height+'px; width:'+canvas.width+'px;">'+
		                    outerScaleHtml+
		                    dspHtml+
		                    '<img style="height:'+canvas.height+'px; width:'+canvas.width+'px;" src="'+ img +'"/>'+
		                    '</div><br/>' +
		                    '<input type="Button" onclick="window.print()" value="Печать"></body>';
	                    ww.document.write(resultHTML);
	                    ww.document.close();//добавляем эту строку, чтобы в ie9 окошко для печати появлялось
	                    ww.focus();
                    }
                    catch(ex){
	                    BlockingUtil.ready();
	                    App.errorReport(gis_basecontrols_8, ex, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_2'});
                    }

                    break;
                }
            }

//            document.location.href = strData;//.replace("image/png", strDownloadMime);
        });
        WidgetMap.map.renderSync();
    }
};


map.controls.ExportImageControl.prototype.exportImage = function(canvas){
    var that = this;
    var currDialog = $('#exportImageDialog');
    if(currDialog.length >0){
        $('#exportImageDialog').dialog('open');
        return;
    }
    $('body').append('<div id="exportImageDialog" style="overflow: hidden"></div>');
    currDialog = $('#exportImageDialog');
    var dlg = currDialog;
    dlg.load('ui/html/map/ExportImageWithRotate.html', build);
    function build() {
        dlg.dialog({
            modal: false,
            title: gis_basecontrols_9,
            dialogClass: 'noCloseButton gsi-zindex__dialog',
            closeOnEscape: false,
            width: 325,
            height: 105,
            resizable: false
        });
        $('#exportImageRotateAngle').jqxNumberInput({ promptChar: "0", textAlign: "left",inputMode: 'simple',
            decimalDigits: 0, groupSeparator: "", disabled:false,spinButtons: false, min:0, max:360,spinButtonsStep:1,height: 22, width: 60});
        //кнопки "Сохранить", "Отмена"
        $('#exportImageSave').on('click',function(){
            try{
                var myImage = document.createElement("img");
                var elem = that.cloneContext_(canvas);
                myImage.onload = function () {
                    that.rotateImage_(elem,canvas,parseInt($('#exportImageRotateAngle').jqxNumberInput('val')));
                    myImage = null;
                    var strData =  elem.toDataURL('image/png');
                    strData = strData.replace("data:image/png;base64,",'');
                    var fileName = App.generateUUID() + ".png";
                    BlockingUtil.wait();
                    var requestCreateFileParams = map.controls.ExportImageControl.prototype.makeCreateImageReqParams(fileName, strData);
                    App.getJsonNode(Services.createImageNode, requestCreateFileParams
                        , function reqCreateFileResult(createResultXML) {
                            BlockingUtil.ready();
                            var er = HTTPServiceUtil.getError(createResultXML);
                            if(er !== ''){
                                App.errorReport(gis_basecontrols_8, er, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_3'});
                                return;
                            }
                            //открываем урл с изображением
                            //location.href = App.config.UPLOAD_PATH+that.screenUid_+".png";
                            BlockingUtil.ready();
                            var win = window.open(App.config.UPLOAD_PATH + fileName ,'_blank');
                            win.focus();
                        }
                        , function reqCreateFileFault(createFaultXML) {
                            BlockingUtil.ready();
                            var er = HTTPServiceUtil.getError(createFaultXML);
                            if(er !== ''){
                                App.errorReport(gis_basecontrols_8, er, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_4'});
                            }
                        });
                    $('#exportImageDialog').dialog('close');
                };
                myImage.src = canvas.toDataURL();
            }
            catch (ex){
                App.errorReport(gis_basecontrols_8, ex, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_7'});
            }

        });
        $('#exportImageCancel').on('click',function(){
            $('#exportImageDialog').dialog('close');
        });
    }

};

// Запрос создания на сервере файла GPX в указанной директории (экспорт из грида)
map.controls.ExportImageControl.prototype.makeCreateImageReqParams = function(fileName, content) {
    return {
        path: fileName,
        data: content
    };
};

// поворот на угол
map.controls.ExportImageControl.prototype.rotateImage_ = function(newCanvas, oldCanvas, degrees) {
    var context = newCanvas.getContext('2d');
    var radian = degrees*Math.PI/180;
    var newWidth= Math.sin(radian) * newCanvas.height + Math.cos(radian) * newCanvas.width;
    var newHeight = Math.sin(radian) * newCanvas.width + Math.cos(radian) * newCanvas.height;
    newCanvas.width = Math.abs(newWidth);
    newCanvas.height = Math.abs(newHeight);
    context.clearRect(0,0,newCanvas.width,newCanvas.height);
    context.save();
    context.translate(oldCanvas.width/2,oldCanvas.height/2);
    context.rotate(degrees*Math.PI/180);
    context.drawImage(oldCanvas,-oldCanvas.width/2,-oldCanvas.height/2);
    context.restore();
};

// поворот на угол
map.controls.ExportImageControl.prototype.cloneContext_ = function(canvas) {
    //create a new canvas
    var newCanvas = document.createElement('canvas');
    var context = newCanvas.getContext('2d');
    //set dimensions
    newCanvas.width = canvas.width;
    newCanvas.height = canvas.height;
    //apply the old canvas to the new one
    context.drawImage(canvas, 0, 0);
    return newCanvas;
};



/************CAS**************/
/**
 * Контрол "Экспорт в png"
 * @constructor
 */
map.controls.CASExportImageControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-image';

    var needExport = goog.isDef(options.needExport) ?
        options.needExport : true;
    var needPrint = goog.isDef(options.needPrint) ?
        options.needPrint : true;

    this.canvas1 = undefined;
    this.canvas2 = undefined;


    this.isVisible = false;



    var tooltipLabelPrint = goog.isDef(options.tooltipLabelPrint) ?
        options.tooltipLabelPrint : gis_basecontrols_10;
    this.innerElementPrint = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-print',
        'type' : 'button',
        'title' : tooltipLabelPrint
    });

    goog.events.listen(this.innerElementPrint,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASExportImageControl.prototype.handleExportImageClick_,map.controls.PRINT_TYPE.PRINT), false, this);


    var tooltipLabelExport = goog.isDef(options.tooltipLabelExport) ?
        options.tooltipLabelExport : gis_basecontrols_11;
    this.innerElementExport = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-export',
        'type' : 'button',
        'title' : tooltipLabelExport
    });

    goog.events.listen(this.innerElementExport,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASExportImageControl.prototype.handleExportImageClick_,map.controls.PRINT_TYPE.EXPORT), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element;
    if(!needExport) this.innerElementExport = undefined;
    if(!needPrint) this.innerElementPrint = undefined;
    if(!needExport && !needPrint) options.noElement = true;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.innerElementPrint, this.innerElementExport);
    goog.base(this, {
        element: element,
        target: options.target
    });


    goog.base(this, {
        element: element,
        target: options.target
    });
};
goog.inherits(map.controls.CASExportImageControl, ol.control.Control);

/**
 * Скрыть/показать список кнопок
 * @param visible
 * @private
 */
map.controls.CASExportImageControl.prototype.setVisible_ = function(visible) {
    if(visible)
        $('.map-image').css('visibility','visible');
    else
        $('.map-image').css('visibility','hidden');
    this.isVisible = visible;
};

/**
 * Реакция на нажатие кнопки экспорта изображения
 * @private
 */
map.controls.CASExportImageControl.prototype.handleExportImageClick_ = function(type) {
    var that = this;
    this.canvas1 = undefined;
    this.canvas2 = undefined;
    if(goog.isDef(WidgetMap.exportImageChooserControl)){
		this.setVisible_(false);
		WidgetMap.exportImageChooserControl.changeExportImageType(type);
    }
    if(goog.isDefAndNotNull(WidgetMap.map) && goog.isDefAndNotNull(WidgetMap.lmap)){
        WidgetMap.map.once('postcompose', function(event) {
            that.canvas1 = event.context.canvas;
            switch(type){
                case map.controls.PRINT_TYPE.EXPORT:{
                    that.mergeCanvasesAndExport_();
                    break;
                }
                case map.controls.PRINT_TYPE.PRINT:{
                    that.mergeCanvasesAndPrint_();
                    break;
                }
            }
        });
        WidgetMap.lmap.once('postcompose', function(event) {
            that.canvas2  = event.context.canvas;
            switch(type){
                case map.controls.PRINT_TYPE.EXPORT:{
                    that.mergeCanvasesAndExport_();
                    break;
                }
                case map.controls.PRINT_TYPE.PRINT:{
                    that.mergeCanvasesAndPrint_();
                    break;
                }
            }
        });
        WidgetMap.map.renderSync();
        WidgetMap.lmap.renderSync();
    }
};


/**
 * Объединяем легенду с графиками для печати
 * @param canvas1 графики
 * @param canvas2 легенда
 * @private
 */
map.controls.CASExportImageControl.prototype.mergeCanvasesAndPrint_ = function(){
    if(goog.isDef(this.canvas1) && goog.isDef(this.canvas2)){
        var canvas1 = this.canvas1;
        var canvas2 = this.canvas2;
        // create new canvas
        var newCanvas = document.createElement('canvas');
        newCanvas.width = canvas1.width+canvas2.width ;
        newCanvas.height = canvas1.height ;
        var newCanvasCtx = newCanvas.getContext('2d');
        newCanvasCtx.drawImage(canvas2,0,0);
        newCanvasCtx.drawImage(canvas1,canvas2.width,0);
        var img = newCanvas.toDataURL("image/png");
        //получаем элемент с линейкой масштаба
        var dsp = $('.map-dsp-label');
        var casRouteName = $('#casRouteNameDiv');
        var casHtml = '';
        if(casRouteName.length > 0)
            casHtml = casRouteName[0].outerHTML;
        var dspHtml = '';
        if(dsp.length > 0)
            dspHtml = dsp[0].outerHTML;
        //ie9 кидает ошибку,
        var ww = window.open('','','toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes');
        var resultHTML = '<head><meta http-equiv="X-UA-Compatible" content="IE=9" />' +
            '<link href="./css/print.css" rel="stylesheet"></head>' +
            '<body><input type="Button" onclick="window.print()" value="Печать"><br/>' +
            //'<div style="position: relative;height:'+newCanvasCtx.height+'px; width:'+newCanvasCtx.width+'px;">'+
            '<div style="position: relative;height:100% width:100%">'+
            dspHtml+
            casHtml+
            '<img style="height:'+newCanvas.height+'px; width:'+newCanvas.width+'px;" src="'+ img +'"/>'+
            '</div><br/>' +
            '<input type="Button" onclick="window.print()" value="Печать"></body>';
        ww.document.write(resultHTML);
        ww.document.close();//добавляем эту строку, чтобы в ie9 окошко для печати появлялось
        ww.focus();
    }
};

/**
 * Объединяем легенду с графиками для печати
 * @param canvas1 графики
 * @param canvas2 легенда
 * @private
 */
map.controls.CASExportImageControl.prototype.mergeCanvasesAndExport_ = function(){
    if(goog.isDef(this.canvas1) && goog.isDef(this.canvas2)){
        var canvas1 = this.canvas1;
        var canvas2 = this.canvas2;
        // create new canvas
        var newCanvas = document.createElement('canvas');
        newCanvas.width = canvas1.width+canvas2.width ;
        newCanvas.height = canvas1.height ;
        var newCanvasCtx = newCanvas.getContext('2d');

        var casRouteName = $('#casRouteNameDiv');
        var casText = casRouteName.text();
        var yOffset = 0;
        if(casText.length > 0){
            newCanvasCtx.font="13px Arial";
            newCanvasCtx.fillText(casText,2,15);
            yOffset = 20;
        }
        newCanvasCtx.drawImage(canvas2,0,yOffset);
        newCanvasCtx.drawImage(canvas1,canvas2.width,yOffset);

        var strData =  newCanvas.toDataURL('image/png');
        strData = strData.replace("data:image/png;base64,",'');
        var fileName = App.generateUUID() + ".png";
        BlockingUtil.wait();
        var requestCreateFileParams = map.controls.ExportImageControl.prototype.makeCreateImageReqParams(fileName, strData);
        App.getJsonNode(Services.createImageNode, requestCreateFileParams
            , function reqCreateFileResult(createResultXML) {
                BlockingUtil.ready();
                var er = HTTPServiceUtil.getError(createResultXML);
                if(er !== ''){
                    App.errorReport(gis_basecontrols_8, er, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_5'});
                    return;
                }
                //открываем урл с изображением
                BlockingUtil.ready();
                var win = window.open(App.config.UPLOAD_PATH + fileName ,'_blank');
                win.focus();
            },
            function reqCreateFileFault(createFaultXML) {
                BlockingUtil.ready();
                var er = HTTPServiceUtil.getError(createFaultXML);
                if(er !== ''){
                    App.errorReport(gis_basecontrols_8, er, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_6'});
                }
            });



        //получаем элемент с линейкой масштаба
        /*var dsp = $('.map-dsp-label');
        var casRouteName = $('#casRouteNameDiv');
        var casHtml = '';
        if(casRouteName.length > 0)
            casHtml = casRouteName[0].outerHTML;
        var dspHtml = '';
        if(dsp.length > 0)
            dspHtml = dsp[0].outerHTML;
        //ie9 кидает ошибку,
        var ww = window.open('','','toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes');
        var resultHTML = '<head><meta http-equiv="X-UA-Compatible" content="IE=9" />' +
            '<link href="./ui/print.css" rel="stylesheet"></head>' +
            '<body><input type="Button" onclick="window.print()" value="Печать"><br/>' +
            '<div style="position: relative;height:'+newCanvasCtx.height+'px; width:'+newCanvasCtx.width+'px;">'+
            dspHtml+
            casHtml+
            '<img style="height:'+newCanvas.height+'px; width:'+newCanvas.width+'px;" src="'+ img +'"/>'+
            '</div><br/>' +
            '<input type="Button" onclick="window.print()" value="Печать"></body>';
        ww.document.write(resultHTML);
        ww.document.close();//добавляем эту строку, чтобы в ie9 окошко для печати появлялось
        ww.focus();*/
    }
};

map.controls.CASExportImageControl.prototype.cloneContext_ = function(canvas) {
    //create a new canvas
    var newCanvas = document.createElement('canvas');
    var context = newCanvas.getContext('2d');
    //set dimensions
    newCanvas.width = canvas.width;
    newCanvas.height = canvas.height;
    //apply the old canvas to the new one
    context.drawImage(canvas, 0, 0);
    return newCanvas;
};
/***************END_CAS******************/

/**
 * Контрол слайдер для зуммирования
 * @constructor
 */
map.controls.ZoomSliderControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    var className = options.className ? options.className : 'ol-zoomslider';
    this.minElement = goog.dom.createDom('DIV', {
        'type': 'div',
        'class': className + '-min '
    });
    this.isMin = true;
    goog.base(this, {
        target: options.target
    });

};

goog.inherits(map.controls.ZoomSliderControl, ol.control.ZoomSlider);

/**
 * Handle dragger drag events.
 *
 * @param {goog.fx.DragEvent} event The drag event.
 * @private
 */
map.controls.ZoomSliderControl.prototype.handleDraggerDrag_ = function(event) {
	var relativePosition = this.getRelativePosition_(event.left, event.top);
	this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
};


/**
 * Handle dragger end events.
 * @param {goog.fx.DragEvent} event The drag event.
 * @private
 */
map.controls.ZoomSliderControl.prototype.handleDraggerEnd_ = function(event) {
	var map = this.getMap();
	var view = map.getView();
	view.setHint(ol.ViewHint.INTERACTING, -1);
	goog.asserts.assert(this.currentResolution_,
		'this.currentResolution_ should be defined');
	var resolution = view.constrainResolution(this.currentResolution_);
	view.setResolution(resolution);
};

/**
 * Форсируем смену позиции полунка при смене режимов карты
 * @private
 */
map.controls.ZoomSliderControl.prototype.forceSetThumbPosition = function() {
    try{
	    this.setThumbPosition_(this.currentResolution_);
    }
    catch(ex){}
};


map.controls.ZoomSliderControl.prototype.setMap = function(map) {
    if (this.map_) {
        goog.dom.removeNode(this.element);
    }
    if (this.listenerKeys.length > 0) {
        this.listenerKeys.forEach(goog.events.unlistenByKey);
        this.listenerKeys.length = 0;
    }
    this.map_ = map;
    if (this.map_) {
        var target = this.target_ ?
            this.target_ : map.getOverlayContainerStopEvent();
        goog.events.listen(this.minElement, goog.events.EventType.DBLCLICK,
            this.handleContainerDblClick_, false, this);
        target.appendChild(this.minElement);

        goog.events.listen(this.element, goog.events.EventType.DBLCLICK,
            this.handleContainerDblClick_, false, this);
        target.appendChild(this.element);

        if (this.render !== ol.nullFunction) {
            this.listenerKeys.push(goog.events.listen(map,
                ol.MapEventType.POSTRENDER, this.render, false, this));
        }
        map.render();
    }
};

map.controls.ZoomSliderControl.prototype.handleContainerDblClick_ = function () {
    if(this.isMin){
        $('.ol-zoomslider').show();
        $('.ol-zoomslider-min').hide();
        $('.ol-zoom-out').css('margin-top','212px');
    }else {
        $('.ol-zoom-out').css('margin-top','10px');
        $('.ol-zoomslider').hide();
        $('.ol-zoomslider-min').show();
    }
    this.isMin = !this.isMin;
};/**
 * Контрол для перемещения руков на карте
 * @constructor
 */
map.controls.ClearCosmeticControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-cosmetic';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_basecontrols_12;
    var panElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });


    goog.events.listen(panElement,
        goog.events.EventType.CLICK, this.handleCosmeticClick_, false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, panElement);
    }
    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.ClearCosmeticControl, ol.control.Control);


/**
 * Реация на нажатие кнопки "Очистить косметический слой"
 * @private
 */
map.controls.ClearCosmeticControl.prototype.handleCosmeticClick_ = function() {
    BlockingUtil.wait();
    try{
        var cosmeticLayer = WidgetMap.layerManager.getLayerByName('COSMETIC_OBJECT');
        if(goog.isDef(cosmeticLayer) && goog.isDef(cosmeticLayer.layer)){
            cosmeticLayer.layer.featureProjLayer.getSource().getSource().clear();
        }
        if(goog.isDefAndNotNull(WidgetMap.currentVectorLayer))
            WidgetMap.currentVectorLayer.getSource().clear();
        MapUtil.clearSelectionLayer();
        if(goog.isDefAndNotNull(WidgetMap.findPathLayer))
            WidgetMap.findPathLayer.getSource().clear();
        if(goog.isDefAndNotNull(WidgetMap.findPathLineLayer))
            WidgetMap.findPathLineLayer.getSource().clear();
        if(goog.isDefAndNotNull(WidgetMap.bufferLayer))
            WidgetMap.bufferLayer.getSource().clear();

        if(goog.isDefAndNotNull(WidgetMap.pipeLengthLayer))
            WidgetMap.pipeLengthLayer.getSource().clear();
        //удалить interaction и выставить ладошку
        map.controls.PanControl.prototype.handlePanClick_();
    }
    catch(ex){

    }
    finally{
	    //обнуляем массив подписей, который прятали при выделении объектов
	    if (goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0) {
		    WidgetMap.map.render();
		    WidgetMap.hideLabelsArr = [];
	    }
        BlockingUtil.ready();
    }
};






goog.provide('map.controls.DSPControl');
/**
 * Контрол для отображения надписи ДСП
 * @constructor
 */
map.controls.DSPControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var dsp = undefined;
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    if(mapConfig){
        dsp = mapConfig.label;
    }
    var position = '';
    var dspLabel = '';
    if(dsp !== undefined){
        var top = (dsp.top !== undefined && dsp.top !== '')? 'top:'+dsp.top+'px;': '';
        var bottom = (dsp.bottom !== undefined && dsp.bottom !== '')? 'bottom:'+dsp.bottom+'px;': '';
        var left = (dsp.left !== undefined && dsp.left !== '')? 'left:'+dsp.left+'px;': '';
        var right = (dsp.right !== undefined && dsp.right !== '')? 'right:'+dsp.right+'px;': '';
        var fontSize = (dsp.font_size !== undefined && dsp.font_size !== '')? 'font-size:'+dsp.font_size+'px;': '11px;';
        var fontFamily = (dsp.font !== undefined && dsp.font !== '')? 'font-family:'+dsp.font+';': 'Verdana,Arial,sans-serif;';
        position = top+bottom+left+right+fontSize+fontFamily;
        dspLabel = dsp.text;
    }

    var innerElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
        'style' : position,
        className : 'map-dsp-label'

    }, null, dspLabel);
    dspLabel = dspLabel.replace(/\\n/g, "<br />");
    $(innerElement).html(dspLabel);

    goog.base(this, {
        element: innerElement,
        target: options.target
    });
};
goog.inherits(map.controls.DSPControl, ol.control.Control);


goog.provide('map.controls.LinkMapControl');

/**
 * Контрол для поиска маршрута
 * @constructor
 */
map.controls.LinkMapControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};


    var className = goog.isDef(options.className) ?
        options.className : 'map-link';


    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_linkmapcontrol_1;
    var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });

    this.buttons = {
        close           :gis_linkmapcontrol_3
    };

    goog.events.listen(innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.LinkMapControl.prototype.handleLinkMapClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);
    }
    goog.base(this, {
        element: element,
        target: options.target
    });
};
goog.inherits(map.controls.LinkMapControl, ol.control.Control);


/**
 * Реация на нажатие "ссылка на карту"
 * @private
 */
map.controls.LinkMapControl.prototype.handleLinkMapClick_ = function() {
    //открываем попап с выбором центра
    var that = this;
    $('#mapLinkDialog').remove();
    var className = 'map-link';

    var innerElement = goog.dom.createDom(goog.dom.TagName.INPUT, {
        'class': className + '-text',
        'type' : 'text'
    });

    var currUrl = document.URL;
    var splittedUrl  = currUrl.split('#')[0].split('?');
    var smallurl = splittedUrl[0];
    var urlParams = splittedUrl[1];
    var splittedParams = urlParams.split('&');
    //отсекаем из url параметры ненужные
    for(var i=splittedParams.length-1; i>=0;i--){
        if(!(splittedParams[i].indexOf('task=') != -1 || splittedParams[i].indexOf('mdl=') != -1 )){
            splittedParams.splice(i,1);
        }
    }
    urlParams = splittedParams.join('&');


    var zz = WidgetMap.map.getView().getZoom();

    var centerArr = WidgetMap.map.getView().getCenter();
    this.dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
    this.source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
    var cp = new proj4.toPoint([centerArr[0], centerArr[1]] );
    proj4.transform(this.source_, this.dest_, cp);
    // получаем список видимых слоёв в порядке следования
    var baseLayers = (WidgetMap.baseLayersControl !==  undefined)?'&mapId='+WidgetMap.baseLayersControl.getVisibleLayers():'';

    var selObjects = (goog.isDef(WidgetMap.mapSelectedObject))?'&objects='+WidgetMap.mapSelectedObject:'';

    var resultUrl = smallurl+'?'+urlParams+'&ll='+cp.x+','+cp.y+'&z='+zz+baseLayers+selObjects;

    var element = goog.dom.createDom(goog.dom.TagName.DIV, className, innerElement);
    var divv = '<div id="mapLinkDialog"><textarea id="mapLinkText" style="width:465px;margin: 1px;color: #005d98;height: 55px;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text">' + resultUrl + '</textarea></div>';
    $(divv).append(element);
    $('body').append(divv);


    var dlg = $('#mapLinkDialog');
    // Готовим кнопки, и добавляем обработчики
    var buttons = [];
    $.each(that.buttons, function(name, text){
        buttons.push({
            text: text,
            click: function(){
                $('#mapLinkDialog').remove();
            }
        });
    });
    dlg.dialog({
        modal: false,
        title: gis_linkmapcontrol_2,
        dialogClass: 'gsi-zindex__dialog',
        closeOnEscape: true,
        width: 474,
        height: 160,
        resizable: false,
        buttons : buttons
    });
    $('#mapLinkText').select();//(0,$('#mapLinkText').val().length);

};
goog.provide('map.controls.ZoomControl');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('ol.animation');
goog.require('ol.control.Control');
goog.require('ol.css');
goog.require('ol.easing');
goog.require('ol.pointer.PointerEventHandler');



/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ZoomOptions=} opt_options Zoom options.
 * @api stable
 */
map.controls.ZoomControl = function(opt_options) {
    this.currTime = new Date().getTime();
    this.timer;
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ? options.className : 'ol-zoom';

    var delta = goog.isDef(options.delta) ? options.delta : 1;

    var zoomInLabel = goog.isDef(options.zoomInLabel) ?
        options.zoomInLabel : '+';
    var zoomOutLabel = goog.isDef(options.zoomOutLabel) ?
        options.zoomOutLabel : '\u2212';


    var inElement = goog.dom.createDom('BUTTON', {
        'class': className + '-in  ol-has-tooltip',
        'type' : 'button'
    }, zoomInLabel);
    inElement.style.backgroundColor = 'white';
    inElement.style.color = '#4C93C2';
    inElement.style.border = 'solid 1px';

    goog.events.listen(inElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ZoomControl.prototype.handleClick_, delta), false, this);


    var outElement = goog.dom.createDom('BUTTON', {
        'class': className + '-out  ol-has-tooltip',
        'type' : 'button'
    }, zoomOutLabel);

    outElement.style.backgroundColor = 'white';
    outElement.style.color = '#4C93C2';
    outElement.style.border = 'solid 1px';

    goog.events.listen(outElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ZoomControl.prototype.handleClick_, -delta), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL +' mytable';
    var element = goog.dom.createDom('DIV', cssClasses, inElement,
        outElement);
    element.style.backgroundColor = '4C93C2';

    goog.base(this, {
        element: element,
        target: options.target
    });

    /**
     * @type {number}
     * @private
     */
    this.duration_ = goog.isDef(options.duration) ? options.duration : 200;

};
goog.inherits(map.controls.ZoomControl, ol.control.Control);


/**
 * @param {number} delta Zoom delta.
 * @param {goog.events.BrowserEvent} event The event to handle
 * @private
 */
map.controls.ZoomControl.prototype.handleClick_ = function(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
};



/**
 * @param {number} delta Zoom delta.
 * @private
 */
map.controls.ZoomControl.prototype.zoomByDelta_ = function(delta) {
    var map = this.getMap();
    var view = map.getView();
    if (goog.isNull(view)) {
        // the map does not have a view, so we can't act
        // upon it
        return;
    }
    var currentResolution = view.getResolution();
    if (goog.isDef(currentResolution)) {
        if (this.duration_ > 0) {
            if(goog.isDefAndNotNull(WidgetMap.kinetic))
            map.beforeRender(ol.animation.zoom({
                resolution: currentResolution,
                duration: this.duration_,
                easing: ol.easing.easeIn
            }));
        }
        var newResolution = view.constrainResolution(currentResolution, delta);
        view.setResolution(newResolution);
    }
    //WidgetMap.map.renderSync();
    //this.getMap().getView().setHint(ol.ViewHint.INTERACTING, -1);
};

goog.provide('map.control.ScaleTextControl');
goog.provide('map.control.ScaleLineControl');
goog.provide('map.control.ScaleLineProperty');
goog.provide('map.control.ScaleLineUnits');

goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.math');
goog.require('goog.style');
goog.require('ol.Object');
goog.require('ol.TransformFunction');
goog.require('ol.control.Control');
goog.require('ol.css');
goog.require('ol.proj');
goog.require('ol.proj.Units');
goog.require('ol.sphere.NORMAL');


/**
 * @enum {string}
 */
map.control.ScaleLineProperty = {
    UNITS: 'units'
};


/**
 * Units for the scale text. Supported values are ``'metric'`.
 * @enum {string}
 * @api stable
 */
map.control.ScaleLineUnits = {
    METRIC: 'metric'
};


map.control.PIXELS_IN_SM = 43;


/**
 * @classdesc
 * A control displaying rough x-axis distances, calculated for the center of the
 * viewport.
 * No scale line will be shown when the x-axis distance cannot be calculated in
 * the view projection (e.g. at or beyond the poles in EPSG:4326).
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ScaleLineOptions=} opt_options Scale line options.
 * @api stable
 */
map.control.ScaleTextControl = function(opt_options) {

    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-scale-line';

    /**
     * @private
     * @type {Element}
     */
    this.innerElement_ = goog.dom.createDom('DIV', {
        'class': className + '-inner'
    });

    /**
     * @private
     * @type {Element}
     */
    this.element_ = goog.dom.createDom('DIV', {
        'class': className + ' ' + ol.css.CLASS_UNSELECTABLE
    }, this.innerElement_);

    /**
     * @private
     * @type {?olx.ViewState}
     */
    this.viewState_ = null;

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = false;

    /**
     * @private
     * @type {string}
     */
    this.renderedHTML_ = '';


    goog.base(this, {
        element: this.element_,
        target: options.target,
        render: map.control.ScaleTextControl.prototype.handleMapPostrender
    });

    this.setUnits(/** @type {ol.control.ScaleLineUnits} */ (options.units) ||
    map.control.ScaleLineUnits.METRIC);

};
goog.inherits(map.control.ScaleTextControl, ol.control.Control);



/**
 * @return {ol.control.ScaleLineUnits|undefined} The units to use in the scale
 *     line.
 * @observable
 * @api stable
 */
map.control.ScaleTextControl.prototype.getUnits = function() {
    return /** @type {ol.control.ScaleLineUnits|undefined} */ (
        this.get(map.control.ScaleLineProperty.UNITS));
};
goog.exportProperty(
    map.control.ScaleTextControl.prototype,
    'getUnits',
    map.control.ScaleTextControl.prototype.getUnits);


/**
 * @inheritDoc
 */
map.control.ScaleTextControl.prototype.handleMapPostrender = function(mapEvent) {
    var frameState = mapEvent.frameState;
    if (goog.isNull(frameState)) {
        this.viewState_ = null;
    } else {
        this.viewState_ = frameState.viewState;
    }
    this.updateElement_();
};



/**
 * @param {ol.control.ScaleLineUnits} units The units to use in the scale line.
 * @observable
 * @api stable
 */
map.control.ScaleTextControl.prototype.setUnits = function(units) {
    this.set(map.control.ScaleLineProperty.UNITS, units);
};
goog.exportProperty(
    map.control.ScaleTextControl.prototype,
    'setUnits',
    map.control.ScaleTextControl.prototype.setUnits);


/**
 * @private
 */
map.control.ScaleTextControl.prototype.updateElement_ = function() {
    var viewState = this.viewState_;

    if (goog.isNull(viewState)) {
        if (this.renderedVisible_) {
            goog.style.setElementShown(this.element_, false);
            this.renderedVisible_ = false;
        }
        return;
    }

    var resolution = viewState.resolution;
    var distance= Math.abs((map.control.PIXELS_IN_SM / 2) * resolution);
    var distString = '';
    var units = this.getUnits();

    var suffix = '';
    if (units == map.control.ScaleLineUnits.METRIC)
        if (distance >= 1000) {
            suffix = gis_scalecontrol_5;
            distString = Math.ceil(distance / 1000).toFixed(0);
        } else {
            suffix = gis_mapcenteringcontrol_5;
            if (distance < 1)
                distString = distance.toFixed(2);
            else
                distString = Math.ceil(distance).toFixed(0);
        }
    else
        goog.asserts.fail();

    var html = gis_scalecontrol_1+distString + ' ' + suffix+ gis_scalecontrol_2;
    if (this.renderedHTML_ != html) {
        this.innerElement_.innerHTML = html;
        this.renderedHTML_ = html;
    }

    if (!this.renderedVisible_) {
        goog.style.setElementShown(this.element_, true);
        this.renderedVisible_ = true;
    }

};


/**
 * Компонент для отображения масштабной шкалы линией
 * @param opt_options
 * @constructor
 */
map.control.ScaleLineControl = function(opt_options) {
    goog.base(this, opt_options);
};
goog.inherits(map.control.ScaleLineControl, ol.control.ScaleLine);


/**
 * @private
 */
map.control.ScaleLineControl.prototype.updateElement_ = function() {
    var viewState = this.viewState_;

    if (goog.isNull(viewState)) {
        if (this.renderedVisible_) {
            goog.style.setElementShown(this.element_, false);
            this.renderedVisible_ = false;
        }
        return;
    }

    var center = viewState.center;
    var projection = viewState.projection;
    var pointResolution =
        projection.getPointResolution(viewState.resolution, center);
    var projectionUnits = projection.getUnits();

    var cosLatitude;
    var units = this.getUnits();
    if (projectionUnits == ol.proj.Units.DEGREES &&
        (units == ol.control.ScaleLineUnits.METRIC ||
        units == ol.control.ScaleLineUnits.IMPERIAL ||
        units == ol.control.ScaleLineUnits.US ||
        units == ol.control.ScaleLineUnits.NAUTICAL)) {

        // Convert pointResolution from degrees to meters
        this.toEPSG4326_ = null;
        cosLatitude = Math.cos(goog.math.toRadians(center[1]));
        pointResolution *= Math.PI * cosLatitude * ol.sphere.NORMAL.radius / 180;
        projectionUnits = ol.proj.Units.METERS;

    } else if ((projectionUnits == ol.proj.Units.FEET ||
        projectionUnits == ol.proj.Units.METERS) &&
        units == ol.control.ScaleLineUnits.DEGREES) {

        // Convert pointResolution from meters or feet to degrees
        if (goog.isNull(this.toEPSG4326_)) {
            this.toEPSG4326_ = ol.proj.getTransformFromProjections(
                projection, ol.proj.get(GeoUtil.PROJS.WGS84));
        }
        cosLatitude = Math.cos(goog.math.toRadians(this.toEPSG4326_(center)[1]));
        var radius = ol.sphere.NORMAL.radius;
        if (projectionUnits == ol.proj.Units.FEET) {
            radius /= 0.3048;
        }
        pointResolution *= 180 / (Math.PI * cosLatitude * radius);
        projectionUnits = ol.proj.Units.DEGREES;

    } else {
        this.toEPSG4326_ = null;
    }

    goog.asserts.assert(
        ((units == ol.control.ScaleLineUnits.METRIC ) &&
        projectionUnits == ol.proj.Units.METERS) ||
        (units == ol.control.ScaleLineUnits.DEGREES &&
        projectionUnits == ol.proj.Units.DEGREES));

    var nominalCount = this.minWidth_ * pointResolution;
    var suffix = '';
    if (units == ol.control.ScaleLineUnits.METRIC) {
        if (nominalCount < 1) {
            suffix = gis_scalecontrol_3;
            pointResolution *= 1000;
        } else if (nominalCount < 1000) {
            suffix = gis_scalecontrol_4;
        } else {
            suffix = gis_scalecontrol_5;
            pointResolution /= 1000;
        }
    }

    var i = 3 * Math.floor(
            Math.log(this.minWidth_ * pointResolution) / Math.log(10));
    var count, width;
    while (true) {
        count = ol.control.ScaleLine.LEADING_DIGITS[i % 3] *
        Math.pow(10, Math.floor(i / 3));
        width = Math.round(count / pointResolution);
        if (isNaN(width)) {
            goog.style.setElementShown(this.element_, false);
            this.renderedVisible_ = false;
            return;
        } else if (width >= this.minWidth_) {
            break;
        }
        ++i;
    }

    var html = count + suffix;
    if (this.renderedHTML_ != html) {
        this.innerElement_.innerHTML = html;
        this.renderedHTML_ = html;
    }

    if (this.renderedWidth_ != width) {
        this.innerElement_.style.width = width + 'px';
        this.renderedWidth_ = width;
    }

    if (!this.renderedVisible_) {
        goog.style.setElementShown(this.element_, true);
        this.renderedVisible_ = true;
    }

};
goog.provide('map.controls.HistoryControl');

/**
 * Контрол для копирования вставки геометрии
 * @constructor
 */
map.controls.HistoryControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	var className = goog.isDef(options.className) ?
		options.className : 'map-history';

	this.mapHistory = options.mapHistory;

	var prevTooltip = goog.isDef(options.prevTooltip) ?
		options.prevTooltip : gis_historycontrol_1;
	this.inElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-prev',
		'type' : 'button',
		'title' : prevTooltip
	});

	this.clonedSelectedFeature = undefined;

	this.inElement.style.display = 'inline';

	goog.events.listen(this.inElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.HistoryControl.prototype.handleHistoryClick_, -1), false, this);

	var nextTooltip = goog.isDef(options.nextTooltip) ?
		options.nextTooltip : gis_historycontrol_2;
	this.outElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-next map-disabled-button',
		'type' : 'button',
		'title' : nextTooltip
	});
	this.outElement.style.display = 'inline';

	goog.events.listen(this.outElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.HistoryControl.prototype.handleHistoryClick_, 1), false, this);

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;
    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.inElement,
            this.outElement);
    }

	if(goog.isDef(this.mapHistory)){
		this.mapHistory.historyControl = this;
	}

	goog.base(this, {
		element: element,
		target: options.target
	});

};
goog.inherits(map.controls.HistoryControl, ol.control.Control);


/**
 * Реация на нажатие кнопок копирования/вставки геометрии
 * @param type тип нажатой кнопки(copy или paste)
 * @private
 */
map.controls.HistoryControl.prototype.handleHistoryClick_ = function(type) {
	this.mapHistory.justChanged = true;
	this.mapHistory.setState(type);
};


goog.provide('map.controls.SendMailControl');




/**
 * Контрол для поиска маршрута
 * @constructor
 */
map.controls.SendMailControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    //запрос для получения данных о пользователе и его ролях
    this.requestUserWithRole = "ADM_SEM.xml#WEB50_B_USER_PRIVATE";

    var className = goog.isDef(options.className) ?
        options.className : 'map-sendmail';

    //строка, которую подставляем в общий текст при закрытии формы.
    this.longStr = '';
    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_sendmailcontrol_19;
    var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });

    goog.events.listen(innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.SendMailControl.prototype.handleSendMailClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);
    }
        goog.base(this, {
            element: element,
            target: options.target
    });
};
goog.inherits(map.controls.SendMailControl, ol.control.Control);


/**
 * Реация на нажатие "ссылка на карту"
 * @private
 */
map.controls.SendMailControl.prototype.handleSendMailClick_ = function() {
    var that = this;
    this.longStr = '';
    if(goog.isDefAndNotNull(WidgetMap.map)){
        //14.08.17 сообщение об ошибке во время генерации изображения не показываем,
        //к письму прикрепляем режим карты и ошибку по экспорту
        WidgetMap.map.once('postcompose', function(event) {
            var canvas = event.context.canvas;
            BlockingUtil.wait();
            try{
                var strData =  canvas.toDataURL('image/png');
                strData = strData.replace("data:image/png;base64,",'');
                var screenUid =  App.generateUUID();
                var fileName = screenUid + ".png";
                var requestCreateFileParams = map.controls.ExportImageControl.prototype.makeCreateImageReqParams(fileName, strData);
                App.getJsonNode(Services.createImageNode, requestCreateFileParams
                    , function reqCreateFileResult(createResultXML) {
                        var er = HTTPServiceUtil.getError(createResultXML);
		                var errorText = undefined;
                        if(er !== ''){
	                        screenUid = '';
	                        errorText = er;
                        }
                        BlockingUtil.ready();
                        that.showSendMailForm_(screenUid, errorText);
                    }
                    , function reqCreateFileFault(createFaultXML) {
		                var er = HTTPServiceUtil.getError(createFaultXML);
		                var errorText = undefined;
		                if(er !== ''){
			                errorText = er;
		                }
                        BlockingUtil.ready();
		                screenUid = '';
		                that.showSendMailForm_(screenUid, errorText);

                    });
            }
            catch(ex){
                BlockingUtil.ready();
	            that.showSendMailForm_('', ex);
               // App.errorReport("Не удалось экспортировать изображение", ex);
            }
        });
        WidgetMap.map.renderSync();
    }
};

/**
 * Показ формы составления письма с ошибкой
 * @param screenUid
 * @private
 */
map.controls.SendMailControl.prototype.showSendMailForm_ = function(screenUid, errorText) {
    var that = this;
    var currDialog = $('#sendMailDialog');
    if(currDialog.length == 0){
        $('body').append('<div id="sendMailDialog" style="overflow: hidden;"></div>');
        $('#sendMailDialog').hide();
        currDialog = $('#sendMailDialog');
    }

    var dlg = currDialog;
    dlg.load('ui/html/map/SendMailForm.html', build);

    function build() {
        dlg.dialog({
            modal: true,
            dialogClass: 'noCloseButton gsi-zindex__dialog',
            title: gis_sendmailcontrol_20,
            closeOnEscape: true,
            width: 365,
            height: 297,
            resizable: false
        });
        //заполняем данными элементы
        that.getCurrentUserData_();
        //кнопки "Отправить", "Отмена"
        $('#sendMailSend').on('click',function(){
            that.sendMail_(screenUid, errorText);
            $('#sendMailDialog').remove();
        });
        $('#sendMailCancel').on('click',function(){
            $('#sendMailDialog').remove();
        });
    }
};

//Получаем данные о текущем пользователе (вместе с его ролями)
map.controls.SendMailControl.prototype.getCurrentUserData_ = function() {
    var that = this;
    function getCurrentUserDataParams( request) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '">'+
            '<data FILTER="'+' d.USER_ID='+userId+'" />'+
            '</root>'
        };
    }

    function getCurrentUserDataResult(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.errorReport(gis_sendmailcontrol_11, resultXml, undefined, {filename:gis_filename_476, functionname:'gis_filename_476_1'});
            return;
        }
        that.longStr = '';
        //делаем разбор пришедших данных и добавляем их в mailMessage.text
        var userId = '';
        var userLogin = '';
        var userFIO = '';
        var userMail = '';
        var userStatus = '';
        var userRoles = '';
        var serverAddr = '';//URLResolver.getFullUrl("");
        var d = new Date();
        var curDateTimeStr = d.getDate()+'.'
            + d.getMonth()+'.'
            + d.getFullYear()+'  '
            + d.getHours()+':'
            + d.getMinutes()+':'
            + d.getSeconds();
        var resultXml = ($.parseXML(resultXml)).firstChild;
        var datas = resultXml.getElementsByTagName("data");
        if(datas.length>0){
            var data = datas[0];
            userId = data.getAttribute("USER_ID");
            userLogin = data.getAttribute("LOGIN");
            userFIO = goog.isNull(data.getAttribute("LASTNAME"))?'':data.getAttribute("LASTNAME")+' '+goog.isNull(data.getAttribute("FIRSTNAME"))?'':data.getAttribute("FIRSTNAME")+' '+goog.isNull(data.getAttribute("SECONDNAME"))?'':data.getAttribute("SECONDNAME");
            userMail = data.getAttribute("MAIL");
            userStatus = data.getAttribute("STATUS");
            if(!goog.isNull(data.getAttribute("ROLE_DESCR")))
                userRoles = data.getAttribute("ROLE_DESCR");
        }
        that.longStr = gis_sendmailcontrol_1;
        that.longStr += gis_sendmailcontrol_2+userId+"<br/>"+gis_sendmailcontrol_3+userLogin+"<br/>"+gis_sendmailcontrol_4+userFIO+"<br/>"
        +gis_sendmailcontrol_5+userMail+"<br/>"+gis_sendmailcontrol_6+userStatus+"<br/>";
        that.longStr += gis_sendmailcontrol_7+userRoles+"<br/>"+gis_sendmailcontrol_8+serverAddr+"<br/>"+gis_sendmailcontrol_9+curDateTimeStr+"<br/>";
        that.longStr += gis_sendmailcontrol_10;


        //сохраняем полученные данные в контролы формы
        $('#sendMailName').val(userLogin);
        $('#sendMailFIO').val(userFIO);

    }
    function getCurrentUserDataFault(resultXml) {
        BlockingUtil.ready();
        App.errorReport(gis_sendmailcontrol_11, resultXml, undefined, {filename:gis_filename_476, functionname:'gis_filename_476_2'});
    }

    BlockingUtil.wait();
    App.serverQueryXML2Node(Services.processQueryNode, getCurrentUserDataParams( this.requestUserWithRole ), getCurrentUserDataResult, getCurrentUserDataFault);

};

/**
 * Отправка письма
 * @private
 */
map.controls.SendMailControl.prototype.sendMail_ = function(screenUid, errorText) {
    //при закрытии добавляем данные в начало письма
    this.longStr = this.longStr +  $('#sendMailMessage').val();
    if(goog.isDef(WidgetMap.map))
    var center = WidgetMap.map.getView().getCenter();

    var cp = new proj4.toPoint([center[0], center[1]] );
    //случай ПКА
    if(WidgetMap.DEFAULT_PROJECTION !== GeoUtil.PROJS['EPSG:5807']){
        this.dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
        this.source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
        proj4.transform(this.source_, this.dest_, cp);
    }
    var detail = gis_sendmailcontrol_12+cp.x+gis_sendmailcontrol_21+cp.y+gis_sendmailcontrol_23;
    if(goog.isDef(WidgetMap.baseLayer))
	    detail += gis_sendmailcontrol_13+WidgetMap.baseLayer.label+gis_sendmailcontrol_22+WidgetMap.baseLayer.value+gis_sendmailcontrol_24+gis_sendmailcontrol_23;
    if(goog.isDef(errorText) && errorText != '')
	    detail += gis_sendmailcontrol_14+errorText+gis_sendmailcontrol_15;
    //Посылаем событие отправки E-mail
    function sendMailResult(result) {
        var er = HTTPServiceUtil.getError(result);
        if (er !== '') {
            App.errorReport( gis_sendmailcontrol_16+gis_sendmailcontrol_25, result, undefined, {filename:gis_filename_476, functionname:'gis_filename_476_3'});
        }
    }
    function sendMailFault(result) {
        App.errorReport(gis_sendmailcontrol_16+gis_sendmailcontrol_25, result, undefined, {filename:gis_filename_476, functionname:'gis_filename_476_4'});
    }
    var sendMailMessage =  this.longStr;
    sendMailMessage += gis_sendmailcontrol_17+"<br/><br/>"+detail+gis_sendmailcontrol_18;

    App.getJsonTextNode(Services.sendMailNode, {
        addMailTo : $('#sendMailAddress').val(),
        subject   : $('#sendMailErrorType option:selected').text(),
        fileName1  : (screenUid === '' || !goog.isDef(screenUid))?'':App.config.UPLOAD_PATH + screenUid+'.png',
        message   : sendMailMessage
    }, sendMailResult, sendMailFault);
};
goog.provide('map.controls.ManageLayersControl');


/**
 * Контрол для привязки геометрии
 * @constructor
 */
map.controls.ManageLayersControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	var className = goog.isDef(options.className) ?
		options.className : 'map-managelayers';

	this.needStyle = goog.isDef(options.needStyle) ?
		options.needStyle : true;

	this.changedStyles = [];
	var tooltip = goog.isDef(options.tooltip) ?
		options.tooltip : gis_managelayerscontrol_1;
	var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className+'-button',
		'type' : 'button',
		'title' : tooltip
	});

	goog.events.listen(innerElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.ManageLayersControl.prototype.handleManageLayersClick_), false, this);

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;

	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);

	goog.base(this, {
		element: element,
		target: options.target
	});
};
goog.inherits(map.controls.ManageLayersControl, ol.control.Control);

/**
 * Реация на нажатие кнопок редактиварония стиля
 * @private
 */
map.controls.ManageLayersControl.prototype.handleManageLayersClick_ = function() {
	var that = this;
	var currDialog = $('#manageLayersDialog');
	if(currDialog.length == 0){
		$('body').append('<div id="manageLayersDialog" style="overflow: hidden;"></div>');
		$('#manageLayersDialog').hide();
		currDialog = $('#manageLayersDialog');
	}

	var dlg = currDialog;
	dlg.load('ui/html/map/ManageLayersForm.html', build);
	var width = 396;
	if(!this.needStyle)
		width = 360;
	function build() {
		dlg.dialog({
			modal: true,
			title: gis_managelayerscontrol_2,
			closeOnEscape: true,
			dialogClass: 'gsi-zindex__dialog',
			width: width,
			height: 396,
			resizable: false
		});
		//заполняем данными элементы
		that.fillGrid_();
		//кнопки "Отправить", "Отмена"
		$('#manageLayersApply').on('click',function(){
			that.applyLayers_();
			$('#manageLayersDialog').remove();
		});
		$('#manageLayersCancel').on('click',function(){
			$('#manageLayersDialog').remove();
		});
	}
};

/**
 * Заполняем грид данными
 * @private
 */
map.controls.ManageLayersControl.prototype.fillGrid_ = function() {
	if(goog.isDef(WidgetMap.layerManager)){
		var layers = WidgetMap.layerManager.getAllSortedLayers();
		var treeGridLayers = [];
		for(var i=0; i<layers.length; i++){
			var obj = {LayerId:i, LayerName:layers[i].layer.sourceDescr, MapName:layers[i].layer.mapName, layer:layers[i].layer.name,visible:''+layers[i].visible,allowtext:''+layers[i].isTextAllow};
			treeGridLayers.push(obj);
		}
		var source = {
			dataType: "array",
			dataFields: [
				{ name: 'LayerID', type: 'number' },
				{ name: 'LayerName', type: 'string' },
				{ name: 'MapName', type: 'string' },
				{ name: 'layer', type: 'string'},
				{ name: "visible", type: "string" },
				{ name: 'icon', type: 'string' },
				{ name: "style", type: "string" },
				{ name: "allowtext", type: "string" }
			],
			hierarchy:{groupingDataFields:[{name: "MapName"}]},
			id: 'LayerID',
			localData: treeGridLayers
		};
		var dataAdapter = new $.jqx.dataAdapter(source, {
			loadComplete: function () {
			}
		});
		var columns = [
			{ text: gis_managelayerscontrol_3, dataField: 'LayerName', width: 295 },
			//{ text: "Name", align: "left", dataField: "name", width: 320 },
			{
				text: '', dataField: 'visible', width: 25,sortable:false,
				renderer: function (text, align, height) {
					return "<div><img id='manageLayersGridEyeHeaderImg' class='manageLayersGridEyeOn' style='margin-left: 2px;margin-top: 1px;' src='/ui/images/eye.png'/></div>";
				},
				cellsRenderer: function (rowKey, dataField, value, data) {
					if(value == 'true'){
						return "<div><input type='checkbox' style='margin-left: 5px;' onchange='map.controls.ManageLayersControl.prototype.setVisible(this,"+rowKey+")' checked></div>";
					}
					else{
						return "<div><input type='checkbox' style='margin-left: 5px;' onchange='map.controls.ManageLayersControl.prototype.setVisible(this,"+rowKey+")'></div>";
					}
				}
			},
			{
				text: '', dataField: 'allowtext', width: 25,sortable:false,
				renderer: function (text, align, height) {
					return "<div><img id='manageLayersAllowTextImg' class='manageLayersAllowTextImg' style='margin-left: 3px;margin-top: 1px;' src='/ui/images/font_icon.png'/></div>";
				},
				cellsRenderer: function (rowKey, dataField, value, data) {
					if(value == 'true'){
						return "<div><img style='width:20px;height:20px;' onclick='map.controls.ManageLayersControl.prototype.allowText(this,"+rowKey+")' src='/ui/images/font_icon.png' title='Скрыть подпись' /></div>";
					}
					else{
						return "<div><img style='opacity: 0.3;width:20px;height:20px;' onclick='map.controls.ManageLayersControl.prototype.allowText(this,"+rowKey+")' src='/ui/images/font_icon.png' title='Показать подпись' /></div>";
					}
				}
			}
		];
		if(this.needStyle){
			columns.push(
				{
					text: '', dataField: 'style', width: 25,sortable:false,
					renderer: function (text, align, height) {
						return "<div><img id='manageLayersEditStyleImg' class='manageLayersEditStyleImg' style='margin-left: 5px;margin-top: 2px;' src='/ui/images/editStyle.png'/></div>";
					},
					cellsRenderer: function (rowKey, dataField, value, data) {
						return "<div><img style='width:16px;height:16px;' onclick='map.controls.ManageLayersControl.prototype.editStyle(this,"+rowKey+")' src='/ui/images/editStyle.png' title='Редактировать стиль' /></div>";
					}
				})
		}
		$("#manageLayersGrid").jqxTreeGrid(
			{
				source: dataAdapter,
				altRows: true,
				sortable: true,
				width: 393,
				height: 332,
				columnsResize: false,
				localization: getLocalization('ru'),
				theme:'gis-blue-treegrid',
				icons: function (rowKey, rowData) {
					var level = rowData.level;
					if (level == 0) {
						return "/ui/images/folder_icon.png";
					}
					return false;
				},
				checkboxes: false,
				ready: function () {
					//$("#manageLayersGrid").jqxTreeGrid('expandRow', '1');
					//$("#manageLayersGrid").jqxTreeGrid('expandRow', '2');
				},
				columns: columns
			});
		$("#manageLayersGridEyeHeaderImg").click(function() {
			map.controls.ManageLayersControl.prototype.setAllVisible();
		});


		$("#manageLayersGrid .iconscontainer").remove();
	}
};

/**
 * Смена стиля для слоя с выбором топологии
 */
map.controls.ManageLayersControl.prototype.editStyle = function(img, rowKey){
	var that = this;
	//если видимость слоя выключили, то никаких реакций на кнопки не будет
	var item = $("#manageLayersGrid").jqxTreeGrid('getRow',rowKey);
	var errText = gis_managelayerscontrol_4;
	if(item.visible=='false'){
		App.confirmDialog(errText,null,{title:gis_core_1});
		return;
	}
	else{
		//если слой видимый, но данные ещё загружаются, то игнорируем
		var layer = WidgetMap.layerManager.getLayerByName(item.layer);
		if(goog.isDef(layer) && goog.isDef(layer.layer) && layer.layer.dataReady_==false){
			App.confirmDialog(errText,null,{title:gis_core_1});
			return;
		}

	}

	var row = $("#manageLayersGrid").jqxTreeGrid('getRow',rowKey);
	var layer = WidgetMap.layerManager.getLayerByName(row.layer);
	var layerStyleQuery = layer.layerQueryId.replace('_Layers.xml','_STYLE.xml');
	var dataRequest="ADM_SEM.xml#EDIT_STYLE_XML";
	//Получение описания всех слоев карты

	//Запрос получения описания стилей по имени файла стилей и ID стиля слоя (иначе попадут стили не от этого слоя)
	function getLayerStylesReqParams(styleFileName, styleId) {
		return {
			getSchema: false,
			descrId: dataRequest,
			toElements: false,
			descrType: 'select',
			data: '<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">'+
			'<data file="'+styleFileName+'" dataId="'+styleId+'"/>'+
			'</root>'
		};
	}
	//забираем все стили, которые связаны со слоем
	var styles = WidgetMap.layerManager.getAllStylesForLayerObj(layerStyleQuery,row.layer);
	//TODO надо теперь по этому массиву отсеить те, геометрий для которых нет
	var newStyles = this.getAllStylesForLayerWithGeo(row.layer, styles);

	var i = 0;
	for (i = 0; i < newStyles.length; i++) {
		newStyles[i].iconHtml = this.formatHref(newStyles[i]);
	}
	this.openForm(newStyles,layer.layer.drawTypes);
};
map.controls.ManageLayersControl.prototype.getAllStylesForLayerWithGeo = function(layerName, styles){
	var lay = WidgetMap.layerManager.getLayerByName(layerName);
	var resArr = [];
	var o;
	for(o in globalPointsLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['point'][sId])){
			resArr.push(styles['point'][sId]);
			styles['point'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['point'][layerName])){
				resArr.push(styles['point'][layerName]);
				delete styles['point'][layerName];
				continue;
			}

		}
	}
	for(o in globalLinesLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['line'][sId])){
			resArr.push(styles['line'][sId]);
			delete styles['line'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['line'][layerName])){
				resArr.push(styles['line'][layerName]);
				delete styles['line'][layerName];
				continue;
			}

		}
	}
	for(o in globalPolygonsLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['polygon'][sId])){
			resArr.push(styles['polygon'][sId]);
			delete styles['polygon'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['polygon'][layerName])){
				resArr.push(styles['polygon'][layerName]);
				delete styles['polygon'][layerName];
				continue;
			}
		}
	}
	return resArr;
	//lay.layer
	//globalPointsLabels_
};

map.controls.ManageLayersControl.prototype.openForm = function(dataArrr,drawTypes){
	var that = this;
	var dataArr = dataArrr;
	var selectedTopology = '';

	var currDialog = $('#editStyleTypeDialog');
	var source ={
		localdata: dataArr,
		datatype: "array"
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	if(true || currDialog.length == 0){
		$('body').append('<div id="editStyleTypeDialog" style="overflow: hidden;"></div>');
		currDialog = $('#editStyleTypeDialog');
		var dlg = currDialog;
		dlg.load('ui/html/map/EditStyleTypeForm.html', build);

		function build() {
			dlg.dialog({
				modal: true,
				dialogClass: 'noCloseButton gsi-zindex__dialog',
				title: gis_managelayerscontrol_7,
				closeOnEscape: false,
				width: 290,
				height: 195,
				resizable: false
			});
			$('#editStyleTypeDrop').jqxDropDownList({ source: dataAdapter, theme:'gis-blue-slider',
				selectedIndex: -1,
				placeHolder:gis_managelayerscontrol_8,
				disabled:false,
				displayMember: "descr",
				valueMember: "sId",
				width: 287, height: 20,
				enableBrowserBoundsDetection: true,
				dropDownWidth: 287,
				dropDownHeight: 187,
				renderer: function (index, label, value) {
					//var item = $('#editStyleTypeDrop').jqxDropDownList('getItem',index).originalItem;
					var datarecord = dataArr[index];
					var table = '<div>'+datarecord.iconHtml+label+'</div>';
					return table;
				}
			}).on('select', function (event) {
				var args = event.args;
				if (goog.isDef(args)) {
					var item = event.args.item;
					if(!goog.isNull(item))
						$('#editStyleTypeApply').prop('disabled', false).removeClass('disableButtonState');
				}
			});
			//var isPoint = drawTypes.indexOf('point')!=-1;
			//var isLine = drawTypes.indexOf('line')!=-1;
			//var isPolygon = drawTypes.indexOf('polygon')!=-1;
			var isPoint = drawTypes.indexOf('point')!=-1;
			var isLine = drawTypes.indexOf('line')!=-1;
			var isPolygon = drawTypes.indexOf('polygon')!=-1;
			$('#editStyleTypeTopologyPoint').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isPoint})
				.bind('change', function (event) {
					var checked = event.args.checked;
					if(checked){
						selectedTopology = 'Point';
						that.updateEditStyleTypeDrop_('point',dataArrr);
					}

				});
			$('#editStyleTypeTopologyLine').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isLine})
				.bind('change', function (event) {
					var checked = event.args.checked;
					if(checked){
						selectedTopology = 'LineString';
						that.updateEditStyleTypeDrop_('line',dataArrr);
					}
				});
			$('#editStyleTypeTopologyPolygon').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isPolygon})
				.bind('change', function (event) {
					var checked = event.args.checked;
					if(checked){
						selectedTopology = 'Polygon';
						that.updateEditStyleTypeDrop_('polygon',dataArrr);
					}
				});
			$('#editStyleTypeApply').on('click',function(){
				that.applyStyle_(selectedTopology);
				$('#editStyleTypeDialog').remove();
			});
			$('#editStyleTypeApply').prop('disabled', true).addClass('disableButtonState');


			$('#editStyleTypeCancel').on('click',function(){
				$('#editStyleTypeDialog').remove();
			});
			if(isPolygon)
				$('#editStyleTypeTopologyPolygon').jqxRadioButton('check');
			if(isLine)
				$('#editStyleTypeTopologyLine').jqxRadioButton('check');
			if(isPoint)
				$('#editStyleTypeTopologyPoint').jqxRadioButton('check');
		}
	}
	else{
		$('#editStyleTypeDrop').jqxDropDownList({ source: dataAdapter});
		$('#editStyleTypeDialog').dialog('open');
	}


};

/**
 * Обновляем список в зависимости от топологии
 * @param topologyType
 * @private
 */
map.controls.ManageLayersControl.prototype.updateEditStyleTypeDrop_ = function(topologyType,originalArray){
	var newArr = [];
	var i = 0;
	switch(topologyType){
		case 'point':
			for(i; i<originalArray.length;i++){
				if(goog.isDef(originalArray[i].pointObj))
					newArr.push(originalArray[i]);
			}
			break;
		case 'line':
			for(i; i<originalArray.length;i++){
				if(!goog.isDef(originalArray[i].polyObj))
					newArr.push(originalArray[i]);
			}
			break;
		case 'polygon':
			for(i; i<originalArray.length;i++){
				if(goog.isDef(originalArray[i].polyObj))
					newArr.push(originalArray[i]);
			}
			break;
	}
	var source ={
		localdata: newArr,
		datatype: "array"
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#editStyleTypeDrop").jqxDropDownList('clear');
	$('#editStyleTypeDrop').jqxDropDownList({ source: dataAdapter});
};


map.controls.ManageLayersControl.prototype.applyStyle_ = function(topologyType){
	if(topologyType=='')return;
	var that = this;
	var objectType = $('#editStyleTypeDrop').jqxDropDownList('getSelectedItem').originalItem;

	WidgetMap.editStyleForm = new EditStyleForm({
		topologyType:topologyType,
		objectType:objectType,
		applyCallback:function(style){
			WidgetMap.managelayersControl.changedStyles.push(style);
		}
	});
	WidgetMap.editStyleForm.build();
};


//Функция сохранения атрибутов в объект
map.controls.ManageLayersControl.prototype.getObjectWithElementAttrs = function getObjectWithElementAttrs(elem) {
	var resultObj = {};
	if (elem!=undefined && elem!=null && elem.attributes!=undefined) {
		for (var ii = 0; ii < elem.attributes.length; ii++) {
			var attr = elem.attributes[ii];
			if (attr.specified == true) {
				resultObj[attr.name] = attr.value;
			}
		}
	}
	return resultObj;
};


//Функция предпросмотра стиля в иконке аналогично рубрикатору
map.controls.ManageLayersControl.prototype.parseTreeData = function parseTreeData(xmlElement,params,parent) {
	switch(xmlElement[0].tagName){
		case 'Style':
			if(!params.first)return;
			xmlElement.children().each(function(){parseTreeData($(this),params,xmlElement);});
			return;
			break;
		case 'LineStyle':
			if(!params.first)return;
			//условие, если у парента есть polyStyle, то продолжаем парсить, чтобы найти polystyle
			if(parent!=undefined && parent.children('PolyStyle').length>0){
				params.first = true;
			} else {
				params.first = false;
				xmlElement.children().each(function(){parseTreeData($(this),params);});
				params.iconHtml = '<div class="divIcon divIconLineStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: '+params.color+'"></div>';
			}
			break;
		case 'PolyStyle':
			if(!params.first)return;
			params.first = false;
			xmlElement.children().each(function(){parseTreeData($(this),params);});
			if(params.fill == '1')
				params.iconHtml = '<div class="divIcon divIconPolyStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: '+params.color+'"></div>';
			else
				params.iconHtml = '<div class="divIcon divIconPolyStyle divIconPolyStyleBorder gridButton" style="margin-right: 3px; display: inline-block;"></div>';
			break;
		case 'Icon':
			if(!params.first)return;
			params.first = false;
			xmlElement.children().each(function(){parseTreeData($(this),params);});
			if(params.href != undefined)
				params.iconHtml = '<div style="height: 20px; float: left;"><img src="./'+params.href+'" alt="'+params.alt+'" style="margin-right: 3px;"/></div>';
			break;
		case 'IconStyle':
			if(!params.first)return;
			xmlElement.children().each(function(){parseTreeData($(this),params);});
			if((params.form != undefined)&&(params.form != 'bitmap')) {
				var styleText = 'margin-right: 3px; display: inline-block; background-color: '+params.color+'; ';
				if (params.size != undefined) styleText += 'width:'+params.size+'px; height:'+params.size+'px;';
				params.iconHtml = '<div class="divIcon divIconStyle'+params.form+' gridButton" style="'+styleText+'"></div>';
			}
			break;
		case 'color':params['color'] = '#'+xmlElement.text().substr(2);break;
		case 'fill':params['fill'] = xmlElement.text();break;
		case 'width':params['width'] = xmlElement.text();break;
		case 'href':params['href'] = xmlElement.text();break;
		case 'form':params['form'] = xmlElement.text();break;
		case 'size':params['size'] = xmlElement.text();break;
	}
};

//Функция предпросмотра стиля в иконке аналогично рубрикатору
map.controls.ManageLayersControl.prototype.formatHref = function (object) {
	var topology = 'none';
	if(goog.isDef(object.pointObj))
		topology = 'point';
	if(goog.isDef(object.lineObj))
		topology = 'line';
	if(goog.isDef(object.polyObj))
		topology = 'polygon';

	switch(topology){
		case 'line':
			return '<div class="divIcon divIconLineStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: #'+object.lineObj.color.substring(2)+'"></div>';
			break;
		case 'polygon':
			if(object.fill == '1')
				return '<div class="divIcon divIconPolyStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: #'+object.polyObj.color.substring(2)+'"></div>';
			else
				return '<div class="divIcon divIconPolyStyle divIconPolyStyleBorder gridButton" style="margin-right: 3px; display: inline-block;"></div>';
			break;
		case 'point':
			if((object.pointObj.form != undefined)&&(object.pointObj.form != 'bitmap')) {
				var styleText = 'margin-right: 3px; display: inline-block; background-color: #'+object.pointObj.color.substring(2)+'; ';
				if (object.size != undefined) styleText += 'width:'+object.pointObj.size+'px; height:'+object.pointObj.size+'px;';
				return '<div class="divIcon divIconStyle'+object.pointObj.form+' gridButton" style="'+styleText+'"></div>';
			}
			else if(object.pointObj.href != undefined)
				return '<div style="height: 20px; float: left;"><img src="./'+object.pointObj.href+'" style="margin-right: 3px;"/></div>';
			break;
	}
};



//Сортировка по свойству объекта (c учетом строкового/числового полей)
map.controls.ManageLayersControl.prototype.dynamicSort = function dynamicSort(property) {
	return function (obj1,obj2) {
		//Исправление для отсутствующего в данных поля - если поля нет, автоматически считаем это значение меньше
		if (obj1==undefined || obj1==null || !obj1.hasOwnProperty(property)) return -1;
		if (obj2==undefined || obj2==null || !obj2.hasOwnProperty(property)) return 1;
		//Внутренняя функция сортировки учитывает, что значения могут быть числовыми
		var value1 = obj1[property].toLowerCase();
		var value2 = obj2[property].toLowerCase();
		try {
			var tmpvalue1 = parseFloat(value1);
			var tmpvalue2 = parseFloat(value2);
			if (!isNaN(tmpvalue1) && !isNaN(tmpvalue2)) {
				if (tmpvalue1 < tmpvalue2) { return -1; }
				if (tmpvalue1 > tmpvalue2) { return 1; }
			} else {
				if (value1 < value2) { return -1; }
				if (value1 > value2) { return 1; }
			}
		} catch (error) {}
		return 0;
	}
};

/**
 * Смена видимости для всех слоёв
 */
map.controls.ManageLayersControl.prototype.setAllVisible = function(){
	//console.log('fdf');
	/*var opacity = ''+$('manageLayersGridEyeHeaderImg').css('opacity');
	if(opacity == '0.3')
		$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'allowtext','true');
	else
		$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'allowtext','false');*/
};

/**
 * Смена видимости для конкретного слоя
 * @param input чекбокс
 * @param rowKey id ключа
 */
map.controls.ManageLayersControl.prototype.setVisible = function(input, rowKey){
	//TODO сделать сдесь для слоёв загрузку данных, если они до этого не грузились
	//устанавливаем значение
	var isChecked = ''+$(input).prop('checked');
	$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'visible',isChecked);
	var item = $("#manageLayersGrid").jqxTreeGrid('getRow',rowKey);
	var layer = WidgetMap.layerManager.getLayerByName(item.layer);
	if(goog.isDef(layer) && goog.isDef(layer.layer)){
		if(item.visible == 'true'){
			if(goog.isDef(layer.layer.setVisible)){//если слой векторный
				WidgetMap.layerManager.enableLayer(item.layer);
				layer.layer.setVisible(true);
			}
			else
				layer.visible = true;
		}
		else{
			if(goog.isDef(layer.layer.setVisible)) {
				WidgetMap.layerManager.disableLayer(item.layer);
				layer.layer.setVisible(false);
			}
			else
				layer.visible = false;
		}
	}
};

/**
 * Вкл/выкл подписи на карте для слоя
 * @param img
 * @param rowKey
 */
map.controls.ManageLayersControl.prototype.allowText = function(img, rowKey){
	//устанавливаем значение
	//если видимость слоя выключили, то никаких реакций на кнопки не будет
	var item = $("#manageLayersGrid").jqxTreeGrid('getRow',rowKey);
	/*if(false && item.visible=='false')return;
	else{
		//если слой видимый, но данные ещё загружаются, то игнорируем
		var layer = WidgetMap.layerManager.getLayerByName(item.layer);
		if(goog.isDef(layer) && goog.isDef(layer.layer) && layer.layer.dataReady_==false)
			return;
	}*/

	var opacity = ''+$(img).css('opacity');
	if(opacity == '0.3')
		$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'allowtext','true');
	else
		$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'allowtext','false');
};


/**
 * Применяем видимость и показ подписей к слоям
 * @private
 */
map.controls.ManageLayersControl.prototype.applyLayers_ = function() {
	var allLayers = WidgetMap.layerManager.getAllLayers();
	var rows = $("#manageLayersGrid").jqxTreeGrid('getRows');
	var i = 0,j=0;

	//проходим по исправленным стилям
	var s = 0;
	for(s;s<this.changedStyles.length;s++){
		//находим в layerManager стиль и подменяем
		var cStyle = this.changedStyles[s];
		var origStyle = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(cStyle.sId,cStyle.topologyType);
		var layer = WidgetMap.layerManager.getLayerByName(cStyle.layerId);
		if(!goog.isNull(origStyle)){
			if(goog.isArray(cStyle.style))
				origStyle.style = cStyle.style.reverse();
			else{
				var cStyleText = cStyle.style.getText();
				if(!goog.isNull(cStyleText)){
					var newAlign = 'center';
					if(cStyleText.getOffsetX()<0) newAlign = 'left';
					else if(cStyleText.getOffsetX()>0) newAlign = 'right';
					var newBaseLine = 'middle';
					if(cStyleText.getOffsetY()<0) newBaseLine = 'top';
					else if(cStyleText.getOffsetY()>0) newBaseLine = 'bottom';

					origStyle.text.align = newAlign+'|'+newBaseLine;
					origStyle.text.bold = cStyleText.getFont().indexOf('bold') != -1?'1':'0';
					origStyle.text.italic = cStyleText.getFont().indexOf('italic') != -1?'1':'0';
					if(!goog.isNull(cStyleText.getFill())){
						if(goog.isArray(cStyleText.getFill().getColor()) && cStyleText.getFill().getColor().length == 4){
							var r = cStyleText.getFill().getColor()[0].toString(16);
							if(r.length==1)r='0'+r;
							var g = cStyleText.getFill().getColor()[1].toString(16);
							if(g.length==1)g='0'+g;
							var b = cStyleText.getFill().getColor()[2].toString(16);
							if(b.length==1)b='0'+b;
							origStyle.text.color = 'ff'+r+g+b;
						}
						else
							origStyle.text.color = cStyleText.getFill().getColor();
					}
					var kk=0;
					var splittedFont = cStyleText.getFont().split(' ');
					for(;kk<splittedFont.length;kk++){
						if(splittedFont[kk].indexOf('px')!=-1){
							origStyle.text.fontSize = splittedFont[kk].replace('px','');
							break;
						}
					}
					origStyle.text.fontFamily = cStyleText.getFont().substring(cStyleText.getFont().indexOf('px ')+3);
				}
				origStyle.style = cStyle.style;
			}

		}
		if(goog.isDef(layer.layer.featureProjLayer)){
			layer.layer.featureProjLayer.getSource().setStyle(undefined);
			/*WidgetMap.layerManager.setStyleForLayer(cStyle.sId,cStyle.topologyType);
			var i = 0;
			for (i = 0; i < styles.length; i++) {
				styles[i].iconHtml = this.formatHref(styles[i]);
			}*/
		}
	}
	for(i in rows){
		j = 0;
		for(j;j<rows[i].records.length;j++){
			//если менялись данные, то слой обновляем
			var layer = WidgetMap.layerManager.getLayerByName(rows[i].records[j].layer);
			if(goog.isDef(layer)){
				var isCurrAllow = rows[i].records[j].allowtext=='true';
				if(isCurrAllow==layer.isTextAllow)
					continue;
				if(layer.layer instanceof map.layer.RasterLayer)
					return;
				/*if(rows[i].records[j].visible == 'true'){
					WidgetMap.layerManager.enableLayer(rows[i].records[j].layer);
					layer.layer.setVisible(true);
				}
				else{
					WidgetMap.layerManager.disableLayer(rows[i].records[j].layer);
					layer.layer.setVisible(false);
				}
				*/
				//if(layer.isTextAllow == false){
				//layer.layer.featureProjLayer.setStyle(undefined);
					//layer.layer.setVisibleText(layer.isTextAllow);
				//}
				layer.isTextAllow = rows[i].records[j].allowtext=='true';
				layer.layer.setVisibleText(layer.isTextAllow);
				layer.layer.featureProjLayer.getSource().changed();
				/*var newf = new ol.Feature(new ol.geom.Point([-100,-100]));
				layer.layer.featureProjLayer.getSource().getSource().addFeature(newf);
				layer.layer.featureProjLayer.getSource().getSource().removeFeature(newf);*/

			}

		}


	}

};



goog.provide('map.controls.PreviousSiteControl');

/**
 * Контрол перехода на предыдущую версию сайта
 * @constructor
 */
map.controls.PreviousSiteControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	var className = goog.isDef(options.className) ?
		options.className : 'map-prevsite';
	this.innerElement = undefined, this.descriptionElement = undefined;
	if(App.prevSite !== '')
		this.innerElement = goog.dom.createDom(goog.dom.TagName.A, {
			name: 'prevsite',
			href: '',
			target:'_self',
			className : className+'-label'
		},gis_prevsitecontrol_1);
	else
		className+= '-only-version';

	var versionElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
		name: 'siteversion',
		className : 'map-version-label'
	},gis_prevsitecontrol_2+App.config.SYSTEM_NAME);

	if(options.description){
		this.descriptionElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
			name: 'description',
			className : 'map-description-label'
		}, options.description);
	}


	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;

	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, versionElement, this.innerElement, this.descriptionElement);

	goog.base(this, {
		element: element,
		target: options.target,
		render: map.controls.PreviousSiteControl.prototype.handleMapPostrender
	});
};

goog.inherits(map.controls.PreviousSiteControl, ol.control.Control);


/**
 * @inheritDoc
 */
map.controls.PreviousSiteControl.prototype.handleMapPostrender = function(mapEvent) {
	if(!goog.isDefAndNotNull(this.map_) || this.innerElement === undefined)
		return;
	var view = this.map_.getView();
	var center = view.getCenter();
	var zz = this.map_.getView().getZoom();
	var cp = new proj4.toPoint([center[0], center[1]] );
	this.dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
	this.source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
	proj4.transform(this.source_, this.dest_, cp);
	var coord_x = cp.x.toPrecision(12);
	var coord_y = cp.y.toPrecision(12);
	var currUrl = document.URL;
	var splittedUrl  = currUrl.split('#')[0].split('?');
	var smallurl = splittedUrl[0];
	var urlParams = splittedUrl[1];
	var splittedParams = urlParams.split('&');
	//отсекаем из url параметры ненужные
	for(var i=splittedParams.length-1; i>=0;i--){
		if(!(splittedParams[i].indexOf('task=') != -1 || splittedParams[i].indexOf('mdl=') != -1 )){
			splittedParams.splice(i,1);
		}
	}
	//urlParams = splittedParams.join('&');
	var prevTask = App.prevSite;
	urlParams = '?';
	if(prevTask !== undefined && prevTask.indexOf('task=') !== -1 && prevTask.indexOf('mdl=') !== -1)
		urlParams = '';
	var prevTask = App.prevSite;
	var selObjects = (goog.isDef(WidgetMap.mapSelectedObject))?'&objects='+WidgetMap.mapSelectedObject:'';
	var prevLink = prevTask/*smallurl*/+urlParams+'&ll='+coord_x+','+coord_y+'&z='+zz+selObjects;
	this.innerElement.setAttribute('href',prevLink+Auth.hash);
};
goog.provide('map.controls.FastTaskAccessControl');

/**
 * Контрол для быстрого открытия задачи, указанной в
 * @constructor
 */
map.controls.FastTaskAccessControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};


	this.fastAccessConfig = goog.isDef(options.fastAccessConfig) ?
		options.fastAccessConfig : undefined;
	/*this.grids = [];
	this.tasks = [];
	if(this.fastAccessConfig){
		var grids = this.fastAccessConfig.grid;
		var tasks = this.fastAccessConfig.tasks;
		if(grids && grids.length)
			this.grids = grids;
		if(tasks && tasks.length)
			this.tasks = tasks;
	}*/
	this.taskUrl = goog.isDef(options.url) ?
		options.url : undefined;

	this.taskText = goog.isDef(options.text) ?
		options.text : '';

	this.taskTarget = goog.isDef(options.target) ?
		options.target : '_blank';

	var className = goog.isDef(options.className) ?
		options.className : 'map-fast-task-access';

	var tooltip = goog.isDef(options.tooltip) ?
		options.tooltip : gis_fasttaskaccesscontrol_1;
	var taskElement = undefined;
	/*if(this.grids &&  this.grids.length > 0){
		var grid = this.grids[0];
		taskElement = goog.dom.createDom(goog.dom.TagName.A, {
			'class': className + '-link',
			'title' : grid.title,
			'target': this.taskTarget
		}, grid.title );
		goog.events.listen(taskElement,
			goog.events.EventType.CLICK, goog.partial(
				map.controls.FastTaskAccessControl.prototype.handleClick_), false, this);
	}*/
		taskElement = goog.dom.createDom(goog.dom.TagName.A, {
			'class': className + '-link',
			'title' : tooltip,
			'href': this.taskUrl + Auth.hash,
			'target': this.taskTarget
		}, this.taskText );

	if(!this.taskUrl || !this.taskText){
		this.taskElement = undefined;
	}

	/**/

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;
	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, taskElement);

	goog.base(this, {
		element: element,
		target: options.target
	});

};
goog.inherits(map.controls.FastTaskAccessControl, ol.control.Control);


/**
 * @private
 */
map.controls.FastTaskAccessControl.prototype.handleClick_ = function() {
	var pArr =  [
		{name: "template", value: "PODS_STO_SHURF_PLAN_LIST"},
		{name: "title", value: "'Участки пропуска снарядов'"},
		{name: "fullLayerId", value: "STO_Layers.xml*PODS_STO_SHURF_PLAN"}]
	openNewWindow(location.href, 'gridWindow', 'GRID', pArr);

};
goog.provide('map.controls.MapInfoControl');


map.controls.requestFindInfId = "GAZPROM_SYS_SEM.xml#FIND_INF_IDS";

/**
 * Кнопка получения информации по объекту на карте
 * @param opt_options
 * @constructor
 */
map.controls.MapInfoControl = function (opt_options) {
	var options = goog.isDef(opt_options) ? opt_options : {};
	this.coordX;
	this.coordY;

	this.searchX;
	this.searchY;

	//начальное положение панели свойств
	this.ppanelPosition = [NaN, NaN];

	this.data_;

	//array of selected features
	this.overFeatures = [];

	this.lastXpx;
	this.lastYpx;

	//если был клик с ctrl для объединения массивов
	//последний клик с отжатием открывает панель свойств
	this.withCtrlBtn = false;
	//если использовался при поиске ctrl
	this.useCtrl = false;
	//Массив всех выбранных объектов
	this.infoArr = [];
	//Массив их координат
	this.infoCoordArr = [];


	//текущий выполняемый запрос
	this.curRequest = undefined;
	//массив ссылкок, которые подгружаются в данный момент
	this.cadastreUrls = [];
	//массив ссылок с идентификаторами которые ждут обработки
	this.cadastreFeatures = [];
	//справочники по атрибутам данных изх росрееестра
	this.COL_DICT = undefined;
	this.COL_DICT_loaded = false;//файл был однажды загружен и обработан, поэтому дальше не грузим
	this.cadastreError = '';// ошибки, возникшие при

	//адреса сервисов получения информации по росреестру
	this.cadastreFeatureUrl = undefined;
	this.useEmailCadastre = false;
	//флаг, прикреплять ли к письму доп. данные(скриншот и ФИО)
	this.useEmailCadastreFullAttach = false;

	this.mapInfoRadius = goog.isDef(options.mapInfoRadius) ?
		options.mapInfoRadius : 5;


	var className = goog.isDef(options.className) ?
		options.className : 'map-info';


	var tooltipLabel = goog.isDef(options.tooltipLabel) ?
		options.tooltipLabel : gis_mapinfocontrol_4;
	this.innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-button',
		'type': 'button',
		'title': tooltipLabel
	});
	var that = this;
	goog.events.listen(this.innerElement,
		goog.events.EventType.CLICK, this.handleMapInfoClick_, false, this);
	//TODO недо будет в нормальном виде листенер добавить
	$('body').on('keyup', function (event) {
		if (event.keyCode == 17)
			that.handleMapInfoKeyUp_(that);
	});
	/*goog.events.listen('body',
	 goog.events.EventType.KEYUP, goog.partial(
	 map.controls.MapInfoControl.prototype.handleMapInfoKeyUp_), false, this);*/

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;
	if (options.noElement) {
		var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
	} else {
		var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.innerElement);
	}
	goog.base(this, {
		element: element,
		target: options.target
	});
};
goog.inherits(map.controls.MapInfoControl, ol.control.Control);


/**
 * Реация на нажатие "Получить информацию"
 * @private
 */
map.controls.MapInfoControl.prototype.handleMapInfoClick_ = function () {
	if (WidgetMap.currentMapButtonState === WidgetMap.MAP_BUTTON_STATE.INFO) {
		WidgetMap.handleEscClick_();
		return;
	}

	this.checkCadastreTileLayer();

	//временная проверка, что работаем с ПКа
	if (!goog.isDef(WidgetMap.LINE_ID)) {
		map.controls.PanControl.prototype.handlePanClick_();
	} else {
		//удаляем сначала перемещение мышью
		WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
		WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);
	}
	this.searchX = undefined;
	this.searchY = undefined;
	this.coordX = undefined;
	this.coordY = undefined;
	WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.INFO;
	WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.INFO, this.innerElement);
	WidgetMap.map.un(ol.MapBrowserEvent.EventType.CLICK, this.mapClickHandler_, this);
	WidgetMap.map.on(ol.MapBrowserEvent.EventType.CLICK, this.mapClickHandler_, this);
};


/**
 * Проверка, является ли данны слой кадастровыми тайлами
 * @returns {boolean}
 * @private
 */
map.controls.MapInfoControl.prototype.checkCadastreTileLayer = function () {
	this.cadastreFeatureUrl = undefined;
	this.useEmailCadastre = false;
	this.useEmailCadastreFullAttach = false;
	var checkCadastre = false;
	if (WidgetMap.BaseLayersParser === undefined || WidgetMap.BaseLayersParser.currentBaseLayers === undefined) {
		return false;
	}
	//TODO забрать адрес из конфига
	//upd. 16.09.21 принято решение, что отправка писем будет зависеть только от  флага в настройках пользователя
	//а не от флага в подложке, чтобы была возможность с любой карты отправлять письма через рореестр
	//upd. 26.11.21 Принято решение хардкодить id слоя с кадастром, чтобы была возможность открывать
	if(WidgetMap.sendCadastreEmail) {
		var currBaseLayers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayersArray();
		for (var i in currBaseLayers) {
			if (currBaseLayers[i].get('id') === 'KADASTR' && currBaseLayers[i].getVisible()) {
				this.cadastreFeatureUrl = 'https://pkk.rosreestr.ru/api/features/';
				this.useEmailCadastre = true;
				this.useEmailCadastreFullAttach = true;
				return WidgetMap.sendCadastreEmail;
			}
		}
	}
	return false;
		/*
        for (var i in currBaseLayers) {
            var source = currBaseLayers[i].getSource();
            if (source instanceof map.source.OSMWebService && source.useEmail && currBaseLayers[i].getVisible()) {
                this.cadastreFeatureUrl = source.cadastreFeatureURL;
                this.useEmailCadastre = true;
                this.useEmailCadastreFullAttach = source.useEmailFullAttach;
                checkCadastre = true;
            }
        }
	return false;*/
};


/**
 * Реация на нажатие кнопки на клавиатуре
 * @private
 */
map.controls.MapInfoControl.prototype.handleMapInfoKeyUp_ = function (event) {
	if (WidgetMap.currentMapButtonState === WidgetMap.MAP_BUTTON_STATE.INFO) {
		this.withCtrlBtn = false;
		if (this.infoArr.length > 0) {
			this.showPropertyPanel_(this.infoArr);
		}
	}
};

map.controls.MapInfoControl.prototype.mapClickHandler_ = function (event) {
	if (WidgetMap.currentMapButtonState === WidgetMap.MAP_BUTTON_STATE.INFO) {
		this.withCtrlBtn = event.browserEvent.ctrlKey;
		var pointX = event.coordinate[0];
		var pointY = event.coordinate[1];
		this.coordX = event.pixel[0];
		this.coordY = event.pixel[1];
		if (goog.isDef(this.curRequest)) {
			this.curRequest.abort();
			this.curRequest = undefined;
			this.cadastreUrls = [];
			this.cadastreError = '';
		}
		this.checkCadastreTileLayer();
		this.startFindObjects_(pointX, pointY);
	}
};


map.controls.MapInfoControl.prototype.startFindObjects_ = function (pointX, pointY) {
	if (!(goog.isNumber(pointX) && goog.isNumber(pointY)))
		return;
	this.searchX = pointX;
	this.searchY = pointY;
	this.startFindCacheObjects_([]);
};


/**
 * Отправка письма для последующей обработки и пересылки результата на почту пользователя
 * @param arr
 * @private
 */
map.controls.MapInfoControl.prototype.sendEmailToRosreestr_ = function (userFIO, userMail, dateTime, arr) {
	var that = this;
	//собираем текст + картинку
	//грузим данные по пользователю

	//получаем картинку
	try {
		if (that.useEmailCadastreFullAttach) {
			WidgetMap.map.once('postcompose', function (event) {
				var canvas = event.context.canvas;
				try {
					var strData = canvas.toDataURL('image/png');
					strData = strData.replace("data:image/png;base64,", '');
					var screenUid = App.generateUUID();
					var fileName = screenUid + ".png";
					var requestCreateFileParams = map.controls.ExportImageControl.prototype.makeCreateImageReqParams(fileName, strData);
					App.getJsonNode(Services.createImageNode, requestCreateFileParams,
						function reqCreateFileResult(createResultXML) {
							var er = HTTPServiceUtil.getError(createResultXML);
							if (er !== '') {
								that.sendMail_(userFIO, userMail, dateTime, arr, '');
								return;
							}
							that.sendMail_(userFIO, userMail, dateTime, arr, screenUid);
						}
						, function reqCreateFileFault() {
							that.sendMail_(userFIO, userMail, dateTime, arr, screenUid);
						});
				} catch (ex) {
					that.sendMail_(userFIO, userMail, dateTime, arr, '');
				}
			});
			WidgetMap.map.renderSync();
		} else
			that.sendMail_(userFIO, userMail, dateTime, arr, '');
	} catch (ex) {
		that.sendMail_(userFIO, userMail, dateTime, arr, '');
	}

};


//Получаем данные о текущем пользователе (вместе с его ролями)
map.controls.MapInfoControl.prototype.getCurrentUserData_ = function (arr) {
	var that = this;
	var requestUserWithRole = "ADM_SEM.xml#WEB50_B_USER_PRIVATE";

	function getCurrentUserDataParams(request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'">' +
				'<data FILTER="' + ' d.USER_ID=' + userId + '" />' +
				'</root>'
		};
	}

	function getCurrentUserDataResult(resultXml) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if (er !== '') {
			App.errorReport(gis_mapinfocontrol_5, er, undefined, {
				filename: gis_filename_459,
				functionname: 'gis_filename_459_1'
			});
			that.startFindRasterObjects_(that.searchX, that.searchY, arr);
			return;
		}
		that.longStr = '';
		//делаем разбор пришедших данных и добавляем их в mailMessage.text
		var userFIO = '';
		var userMail = '';
		var d = new Date();
		var mm = d.getMonth() + 1;
		var curDateTimeStr = ((d.getDate() < 10) ? '0' + d.getDate() : d.getDate()) + '.'
			+ ((mm < 10) ? '0' + mm : mm) + '.'
			+ d.getFullYear() + '  '
			+ ((d.getHours() < 10) ? '0' + d.getHours() : d.getHours()) + ':'
			+ ((d.getMinutes() < 10) ? '0' + d.getMinutes() : d.getMinutes()) + ':'
			+ ((d.getSeconds() < 10) ? '0' + d.getSeconds() : d.getSeconds());
		var resultXml = ($.parseXML(resultXml)).firstChild;
		var datas = resultXml.getElementsByTagName("data");
		if (datas.length > 0) {
			var data = datas[0];
			var ln = goog.isNull(data.getAttribute("LASTNAME")) ? '' : data.getAttribute("LASTNAME");
			var fn = goog.isNull(data.getAttribute("FIRSTNAME")) ? '' : data.getAttribute("FIRSTNAME");
			var sn = goog.isNull(data.getAttribute("SECONDNAME")) ? '' : data.getAttribute("SECONDNAME");
			userFIO = ln + ' ' + fn + ' ' + sn;
			userMail = data.getAttribute("MAIL");
			if (!goog.isNull(userMail) && userMail !== '')
				that.sendEmailToRosreestr_(userFIO, userMail, curDateTimeStr, arr);
			else {
				App.errorReport(gis_mapinfocontrol_6, gis_mapinfocontrol_7, undefined, {
					filename: gis_filename_459,
					functionname: 'gis_filename_459_2'
				});
				that.startFindRasterObjects_(that.searchX, that.searchY, arr);
			}
			return;
		}
		App.errorReport(gis_mapinfocontrol_5, gis_mapinfocontrol_5, undefined, {
			filename: gis_filename_459,
			functionname: 'gis_filename_459_3'
		});
		//продолжаем поиск на карте
		that.startFindRasterObjects_(that.searchX, that.searchY, arr);
	}

	function getCurrentUserDataFault(resultXml) {
		BlockingUtil.ready();
		App.errorReport(gis_mapinfocontrol_5, resultXml, undefined, {
			filename: gis_filename_459,
			functionname: 'gis_filename_459_4'
		});
		//продолжаем поиск на карте
		that.startFindRasterObjects_(that.searchX, that.searchY, arr);

	}

	BlockingUtil.wait();
	App.serverQueryXML2Node(Services.processQueryNode, getCurrentUserDataParams(requestUserWithRole), getCurrentUserDataResult, getCurrentUserDataFault);

};

map.controls.MapInfoControl.prototype.sendMail_ = function (userFIO, userMail, dateTime, arr, screenUid) {
	var that = this;
	//продолжаем поиск на карте
	that.startFindRasterObjects_(that.searchX, that.searchY, arr);

	function sendMailResult(resultXml) {
		var er = HTTPServiceUtil.getError(resultXml);
		if (er !== '') {
			App.errorReport(gis_mapinfocontrol_8 + gis_mapinfocontrol_9, resultXml, undefined, {
				filename: gis_filename_459,
				functionname: 'gis_filename_459_5'
			});
		}
	}

	function sendMailFault(resultXml) {
		App.errorReport(gis_mapinfocontrol_8 + gis_mapinfocontrol_9, resultXml, undefined, {
			filename: gis_filename_459,
			functionname: 'gis_filename_459_6'
		});
	}

	var center = GeoUtil.convertCoords([this.searchX, this.searchY], WidgetMap.DEFAULT_PROJECTION, GeoUtil.PROJS.WGS84);
	var zoom = WidgetMap.map.getView().getZoom();
	var tolerance = that.getToleranceByZoom_(zoom);
	var centerStr = ('' + center[1]).replace('.', ',') + ' ' + ('' + center[0]).replace('.', ',');
	var addText = 'text=' + centerStr + '&tolerance=' + tolerance + '&limit=2';
	var sendMailMessage = '';
	//20.09.17 из-за частых блокировок росреестра множественных запросов решено оставить только земельные участки и кадастровые кварталы
	/*if (this.zouitFeatureUrl != '')
	 sendMailMessage += '<url>' + this.zouitFeatureUrl + '10?' + addText + '</url>';*/
	if (this.cadastreFeatureUrl !== undefined && this.cadastreFeatureUrl !== '') {
		sendMailMessage += '<url>' + this.cadastreFeatureUrl + '1?' + addText + '</url>' +
			'<url>' + this.cadastreFeatureUrl + '2?' + addText + '</url>';
	} else {
		that.startFindRasterObjects_(that.searchX, that.searchY, arr);
		return;
	}

	sendMailMessage += '<EMAIL>' + userMail + '</EMAIL>';
	var fileName = '';
	if (screenUid !== '')
		fileName = App.config.UPLOAD_PATH + screenUid + '.png';
	if (!that.useEmailCadastreFullAttach)
		userFIO = gis_mapinfocontrol_10;
	App.getJsonTextNode(Services.sendMailNode, {
		addMailTo: goog.isDef(App.config.ROSREESTR_POP3_EMAIL) ? App.config.ROSREESTR_POP3_EMAIL : 'rosreestr@corelight.ru',
		subject: userFIO + '|' + dateTime,//ФИО|DATE , upd 08.11.17 - убираем ФИО  и добавляем флаг
		fileName1: fileName,
		isBodyHtml: false,
		message: sendMailMessage,
		to: goog.isDef(App.config.ROSREESTR_POP3_EMAIL) ? App.config.ROSREESTR_POP3_EMAIL : 'rosreestr@corelight.ru'
	}, sendMailResult, sendMailFault);
};


map.controls.MapInfoControl.prototype.startFindRasterObjects_ = function (pointX, pointY, arr) {
	var that = this;
	var currArr = arr;
	//если выставлен флаг не показывать подложку
	if (WidgetMap.config !== undefined && WidgetMap.config.showInfo === false) {
		this.showPropertyPanel_(currArr);
		return;
	}

	//сначала собираем все растровые слои
	var layers = WidgetMap.layerManager.getAllVisibleInScaleSortedRasterLayers();//getAllVisibleInScaleRasterLayers();
	var resultRasterLayers = [];
	//если в подложке выставлен флаг showInfo=false, то ищем пересечения с теми, которые можно показывать
	//добавляем в массив видимые слои, смотрим у них доступные группы(M_1,M_R,...)
	if (WidgetMap.baseLayersControl !== undefined && WidgetMap.BaseLayersParser !== undefined && WidgetMap.BaseLayersParser.currentBaseLayers !== undefined) {
		var bLayers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group
		var bVisibleLayers = [];
		bLayers.forEach(//ol.Collection
			/**
			 * @param {ol.layer.Layer} layer Layer.
			 */
			function (layer) {
				if (layer.getVisible()) {
					try {
						for (var el in WidgetMap.BaseLayersParser.rasterLayers) {
							var rasterLayersObjs = WidgetMap.BaseLayersParser.rasterLayers[el].baselayerscontrolarray;
							for (var r = 0; r < rasterLayersObjs.length; r++) {
								if (layer.get('id') !== undefined && rasterLayersObjs[r].id === layer.get('id')) {
									bVisibleLayers = bVisibleLayers.concat(rasterLayersObjs[r].layers);
									break;
								}
							}
						}
					} catch (ex) {
					}
				}
			}, this);
	}

	// по условию нахождения в bVisibleLayers добавляем в финальную выборку слои
	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function (layer) {
			if (bVisibleLayers.indexOf(layer.modelName) != -1)
				resultRasterLayers.push(layer);
		}, this);


	if (resultRasterLayers.length > 0 || WidgetMap.isBaseLayerRosreestr) {
		var mapDescr = '<DRAWLAYERS>';
		for (var i = 0; i < layers.length; i++) {
			//если режим векторный, проверям, находится ли слой в векторных слоях, если находится,
			// то не запрашиваем, как растровый
			if (WidgetMap.CURRENT_MODE === WidgetMap.MODES.VECTOR) {
				var vecLayer = WidgetMap.layerManager.getVectorLayerByName(layers[i].id)
				if (vecLayer !== undefined)
					continue;
			}
			if (!layers[i].visible)
				continue;
			var currLayer = layers[i].layer;
			/* as map.layer.*/
			mapDescr += currLayer.toXML();
		}
		mapDescr += '</DRAWLAYERS>';
		var mapSize = WidgetMap.map.getSize();
		var leftTop = WidgetMap.map.getCoordinateFromPixel([0, 0]);

		var rightBottom = WidgetMap.map.getCoordinateFromPixel([mapSize[0], mapSize[1]]);
		var vSearchRad = 5;
		var source = new proj4.Proj(GeoUtil.PROJS.WGS84);
		var dest = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
		var cp = new proj4.toPoint([leftTop[0], leftTop[1]]);
		proj4.transform(dest, source, cp);

		var cp1 = new proj4.toPoint([rightBottom[0], rightBottom[1]]);
		proj4.transform(dest, source, cp1);

		var cp2 = new proj4.toPoint([pointX, pointY]);
		proj4.transform(dest, source, cp2);

		if (App.projection === GeoUtil.PROJS.Pulkovo42) {
			var p42WgsPnt = GeoUtil.WGSP42(cp.y, cp.x);
			cp = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);

			p42WgsPnt = GeoUtil.WGSP42(cp1.y, cp1.x);
			cp1 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);

			p42WgsPnt = GeoUtil.WGSP42(cp2.y, cp2.x);
			cp2 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
		}

		if (goog.isDefAndNotNull(this.mapInfoRadius))
			vSearchRad = this.mapInfoRadius;
		vSearchRad = vSearchRad * (cp1.x - cp.x) / mapSize[0];

		var reqParams = this.getReqParams_(cp2.x, cp2.y, vSearchRad, mapDescr);
		BlockingUtil.wait();
		App.serverQueryXMLWithTries(Services.mapInfoService, reqParams, function (resultXml) {
			BlockingUtil.ready();
			that.result_(resultXml, currArr);
		}, function (resultXml) {
			BlockingUtil.ready();
			that.fault_(resultXml, currArr);
		},4);
	} else {
		this.showPropertyPanel_(currArr);
	}
};

map.controls.MapInfoControl.prototype.startFindVectorObjects_ = function (arr) {
	//ищем вектор
	if (goog.isDef(WidgetMap.currentVectorGroupLayer)) {
		var vSearchRad = 5;
		if (goog.isDefAndNotNull(this.mapInfoRadius))
			vSearchRad = this.mapInfoRadius;
		//calculate bounds
		//`[minx, miny, maxx, maxy]`.
		var lastPx = [this.coordX, this.coordY];
		var leftBottom = WidgetMap.map.getCoordinateFromPixel([lastPx[0] - vSearchRad, lastPx[1] - vSearchRad]);
		var rightTop = WidgetMap.map.getCoordinateFromPixel([lastPx[0] + vSearchRad, lastPx[1] + vSearchRad]);

		//TODO добавить проверку на видимость в масштабе слоя
		var layers = WidgetMap.currentVectorGroupLayer.getLayersArray();
		// видимость слоя в масштабе
		var filteredMapLayersArray = [];
		var tt;
		for (tt in layers) {
			if (WidgetMap.map.getView().getResolution() <= layers[tt].get('maxResolution') && WidgetMap.map.getView().getResolution() >= layers[tt].get('minResolution') && layers[tt].get('visible') == true)
				filteredMapLayersArray.push(layers[tt]);
		}
		var resVectorArr = [];
		var findedObjects = [];
		var overFeatures = [];
		var of, t;
		for (of in filteredMapLayersArray) {
			var lId = filteredMapLayersArray[of].get('id');
			var layer = WidgetMap.layerManager.getLayerByName(lId);
			if (goog.isDef(lId) && goog.isDef(layer) && goog.isDef(layer.layer) && layer.layer.type != 'system') {
				overFeatures.push(filteredMapLayersArray[of]);
			}
		}
		var ext = [leftBottom[0], rightTop[1], rightTop[0], leftBottom[1]];
		for (t in overFeatures) {
			overFeatures[t].getSource().getSource().forEachFeatureIntersectingExtent(ext, function (feature) {
				findedObjects = findedObjects.concat(GeoUtil.getIntersectedGeometry(feature, ext));
			});
		}
		var curFeature;
		var k;
		for (k in findedObjects) {
			var obj = {};
			curFeature = findedObjects[k].feature;
			var objId = findedObjects[k].id
			var isSemanticId = false;//случай составного id для техсхемы кап ремонтов
			if (objId === undefined)
				continue;
			if(objId.indexOf('|') !== -1){//комбинированный случай, техсхема и слой ремонты КПГ
				objId = objId.split('|')[1];
				isSemanticId = true;
			}
			var layName = curFeature.get('layerId');
			var layType = curFeature.get('type');
			var typeStr = '';
			if (layType.indexOf('#') != -1) {
				var splitted = layType.split('#');
				layType = splitted[0];
				if (splitted.length > 1) {
					var sp = splitted[1].split('_');
					if (sp.length > 1) {
						//удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
						sp.splice(0, 1);
						typeStr = '_' + sp.join('_');
						layType += typeStr;
					}
				}
			}
			//TODO переписать логику
			var objectStyle = WidgetMap.layerManager.getStyleByName(layType);
			var layObj = WidgetMap.layerManager.getLayerByName(layName);
			var skip = false;
			var isCasLayer = false;

			if (layObj && layObj.layer) {// layObj.layer instanceof map.layer.CASLayer
				try {
					goog.asserts.assertInstanceof(layObj.layer, map.layer.CASLayer,
						'layer must be an map.layer.CASLayer instance');
					isCasLayer = true;
				} catch (ex) {
					isCasLayer = false;
				}
				//upd 23.10.20  Если слой тех схемы, то объект пытаемся показать. Далее сделать и для обычной карты. Регулировку показа панели свойств оставить на *layers.xml, атрибут type
				if (GeoUtil.PROJS['EPSG:5807'] !== WidgetMap.DEFAULT_PROJECTION || isCasLayer) {
					//если нет семантики, слой игнорируем
					if (goog.isDef(layObj.layer.dataProvider) && goog.isDef(layObj.layer.dataProvider.semantic) &&
						layObj.layer.dataProvider.semantic !== '') {
						//получаем стиль. если он не найден - игнорируем объект
						if (goog.isNull(objectStyle)) {
							objectStyle = WidgetMap.layerManager.getStyleByName(layObj.layer.name);
							if (goog.isNull(objectStyle)) {
								if (goog.isDef(layObj.layer.dataProvider) && goog.isDef(layObj.layer.dataProvider.style)) {
									objectStyle = WidgetMap.layerManager.getStyleByName(layObj.layer.dataProvider.style + typeStr);
									if (goog.isNull(objectStyle)) {
										objectStyle = WidgetMap.layerManager.getStyleByName(layObj.layer.dataProvider.style);
										if (goog.isNull(objectStyle))
											continue;
									}
								} else
									continue;
							}
						}
					} else
						skip = true;
				}
			}
			if (!skip) {
				if (layName.indexOf('#') != -1) {
					layName = layName.split('#')[0];
				}
				var geo = findedObjects[k].geo;
				if(isSemanticId){
					//geo = layObj.layer.getFull
					//geo = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(layObj.layer, [objId]);
					geo = undefined;
				}

				obj['id'] = layName + ':' + objId;
				obj['uniqueLayerName'] = curFeature.get('layerId');
				obj['USER_LAYER_NAME'] = layName;
				obj['ID'] = objId;
				obj['label'] = (goog.isDef(layObj)) ? layObj.layer.sourceDescr : layName;
				obj['geo'] = geo;
				obj['mapOrder'] = layObj.layer.mapOrder;
				obj['order'] = layObj.layer.order;
				if (layName === 'COSMETIC_OBJECT' && !goog.isNull(findedObjects[k].label)) {
					obj['LABEL'] = findedObjects[k].label;
				}
				resVectorArr.push(obj);
			}

		}
		//сортируем
		// generic comparison function
		var cmp = function (x, y) {
			return x > y ? 1 : x < y ? -1 : 0;
		};

		//sort name ascending then id descending
		resVectorArr = resVectorArr.sort(function (a, b) {
			//note the minus before -cmp, for descending order
			return cmp(
				[-cmp(a.mapOrder, b.mapOrder), cmp(a.order, b.order)],
				[-cmp(b.mapOrder, a.mapOrder), cmp(b.order, a.order)]
			);
		});
		if (resVectorArr.length > 0) {
			arr = resVectorArr.concat(arr);
		}

	}
	//пока ищем буфер
	if (goog.isDef(WidgetMap.bufferLayer)) {
		var vSearchRad = 5;
		if (goog.isDefAndNotNull(this.mapInfoRadius))
			vSearchRad = this.mapInfoRadius;
		//calculate bounds
		//`[minx, miny, maxx, maxy]`.
		var resArr = [];
		layName = 'COSMETIC_OBJECT';
		var leftBottom = /*WidgetMap.map.getCoordinateFromPixel(*/[this.searchX - vSearchRad, this.searchY - vSearchRad]/*)*/;
		var rightTop = /*WidgetMap.map.getCoordinateFromPixel(*/[this.searchX + vSearchRad, this.searchY + vSearchRad]/*)*/;
		var features = WidgetMap.bufferLayer.getSource().getFeaturesInExtent([leftBottom[0], leftBottom[1], rightTop[0], rightTop[1]]);
		for (var i in features) {
			var obj = {};
			var id = features[i].getId();
			if (!goog.isDef(features[i].get('labelType')))
				features[i].set('labelType', 'COSMETIC_OBJECT');
			var objs = GeoUtil.getIntersectedGeometry(features[i], [leftBottom[0], leftBottom[1], rightTop[0], rightTop[1]]);
			for (var t in objs) {
				obj['id'] = layName + ':' + objs[t].id;
				obj['USER_LAYER_NAME'] = layName;
				obj['ID'] = objs[t].id;
				obj['label'] = gis_mapinfocontrol_11;
				obj['geo'] = objs[t].geo;
				obj['LABEL'] = objs[t].label;
				resArr.push(obj);
			}
			/*obj['id'] = id;
			 obj['USER_LAYER_NAME'] = id.split(':')[0];
			 obj['ID'] = id.split(':')[1];
			 obj['label'] = 'Объект косметического слоя';
			 obj['geo'] = features[i].clone();
			 //obj['LABEL'] = findedObjects[k].label;
			 resArr.push(obj);*/
		}
		if (resArr.length > 0) {
			resArr = resArr.concat(arr);
			return resArr;
		}
	}
	return arr;
};


map.controls.MapInfoControl.prototype.startFindCacheObjects_ = function (arr) {
	if (!(goog.isNumber(this.searchX) && goog.isNumber(this.searchY)))
		return;
	//сначала собираем все растровые слои
	var isBaseLayerCadastre = WidgetMap.isBaseLayerCadastre;
	//isBaseLayerCadastre = true 
	if (!goog.isDefAndNotNull(arr))
		arr = [];
	if (!goog.isDef(App.config.ROSREESTR_URL) || (goog.isDef(App.config.ROSREESTR_URL) && App.config.ROSREESTR_URL.length == 0))
		isBaseLayerCadastre = false;
	if (this.useEmailCadastre) {
		if (WidgetMap.sendCadastreEmail)
			this.getCurrentUserData_(arr);
		else this.startFindRasterObjects_(this.searchX, this.searchY, arr);
	} else if (isBaseLayerCadastre)
		//this.startFindCadastreObjectsJSON_(this.searchX, this.searchY, arr);
		this.preloadCAD_NUM_XML_(this.searchX, this.searchY, arr);
	else
		this.startFindRasterObjects_(this.searchX, this.searchY, arr);
};


map.controls.MapInfoControl.prototype.getReqParams_ = function (x, y, radius, mapDescr) {
	var userId = Auth.getUid();
	return {
		user_uid: userId,
		x: x,
		y: y,
		radius: radius,
		mapDescr: mapDescr
	};
};

map.controls.MapInfoControl.prototype.result_ = function (resultXml, currArr) {
	var er = HTTPServiceUtil.getError(resultXml);
	if (er !== '') {
		this.showPropertyPanel_(currArr, er);
		//пробуем выставить стиль кнопки панели свойств в красный цвет и текстом с ошибкой
		//App.errorReport(gis_mapinfocontrol_1, er, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_7'});
	} else {
		var layerGeoXml = ($.parseXML(resultXml)).firstChild;
		var datas = layerGeoXml.getElementsByTagName("OBJECT");
		var arr = [];
		for (var i = 0; i < datas.length; i++) {
			var obj = {};
			var attrNamesList = datas[i].attributes;
			for (var j = 0; j < attrNamesList.length; j++) {
				var nodeName = attrNamesList[j].nodeName;
				var nodeValue = attrNamesList[j].nodeValue;
				if (nodeName === 'USER_LAYER_NAME') {
					obj[nodeName] = nodeValue;
					obj['label'] = nodeValue;// для панели свойств
				}
				if (nodeName === 'ID')
					obj[nodeName] = nodeValue;
			}
			obj['id'] = obj.USER_LAYER_NAME + ':' + obj.ID;
			var layerObj = WidgetMap.layerManager.getLayerByName(obj.USER_LAYER_NAME);
			if (goog.isDef(layerObj) && goog.isDef(layerObj.layer))
				obj['label'] = layerObj.layer.sourceDescr;
			else
				obj['label'] = obj.USER_LAYER_NAME;
			//добавляем проверку на cover и system
			if (layerObj.layer.type != 'system' && layerObj.layer.showInfo != 'false') {
				arr.push(obj);
			}
			if (layerObj.layer.cover == 'true') {
				var finalArr = currArr.concat(arr);
				this.showPropertyPanel_(finalArr);
				return;
			}
		}
		var finalArr = currArr.concat(arr);
		this.showPropertyPanel_(finalArr);
	}
};


map.controls.MapInfoControl.prototype.fault_ = function (resultXml, currArr) {
	//upd. 02.20.20 принято решение, в случае ошибки получения информации по подложке карты не отображать отдельным окном
	// и по вохможности выделить красным правую кнопку переключения на след. объект с тултипом с текстом ошибки
	var er = HTTPServiceUtil.getError(resultXml);
	/*if (er !== '')
		App.errorReport(gis_mapinfocontrol_1, er, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_8'});*/
	this.showPropertyPanel_(currArr, er);
};


/**
 * Подгружаем файл с расшифровкой атрибутов и значения из справочников
 * @param pointX
 * @param pointY
 * @param arr
 * @private
 */
map.controls.MapInfoControl.prototype.preloadCAD_NUM_XML_ = function (pointX, pointY, arr) {
	var that = this;
	if (this.COL_DICT_loaded) {
		that.startFindCadastreObjectsJSON_(pointX, pointY, arr);
		return;
	}
	function getLayersReqParams(fileName) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

		return {
			descrId: 'SYS_SEM.xml#GET_XML_FILE',
			descrType: 'select',
			data: '<root USER_ID="1045" USER_LOGIN="' + userLogin + '" PODS_USER="' + userId + '">' +
				'<data FILE="../../Public/Data/ROSREESTR/' + fileName + '"/>' +
				'</root>'
		};
	}

	function getPreloadResult(resultXml) {
		that.COL_DICT_loaded = true;
		var er = HTTPServiceUtil.getError(resultXml);
		if (er != "")
			that.startFindCadastreObjectsJSON_(pointX, pointY, arr);
		else {
			var value = ($.parseXML(resultXml)).firstChild;
			var zu = $(value).children('zu');
			var cad_kvartal = $(value).children('cad_kvartal');
			var cad_rayon = $(value).children('cad_rayon');
			var cad_okrug = $(value).children('cad_okrug');
			var zouit = $(value).children('zouit');
			var area_types = $(value).children('area_types');
			var unit_types = $(value).children('unit_types');
			var classid_types = $(value).children('classid_types');
			if (zu.length > 0 || cad_kvartal.length > 0 || cad_rayon.length > 0 || cad_okrug.length > 0 || zouit.length > 0 || area_types.length > 0 || unit_types.length > 0 || classid_types.length > 0)
				that.COL_DICT = {};
			if (zu.length > 0) that.COL_DICT.zu = {};
			if (cad_kvartal.length > 0) that.COL_DICT.cad_kvartal = {};
			if (cad_rayon.length > 0) that.COL_DICT.cad_rayon = {};
			if (cad_okrug.length > 0) that.COL_DICT.cad_okrug = {};
			if (zouit.length > 0) that.COL_DICT.zouit = {};
			if (area_types.length > 0) that.COL_DICT.area_types = {};
			if (unit_types.length > 0) that.COL_DICT.unit_types = {};
			if (classid_types.length > 0) that.COL_DICT.classid_types = {};
			var k;
			var cols = zu.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.zu[name] = value
			}
			cols = cad_kvartal.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.cad_kvartal[name] = value
			}
			cols = cad_rayon.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.cad_rayon[name] = value
			}
			cols = cad_okrug.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.cad_okrug[name] = value
			}
			cols = zouit.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.zouit[name] = value
			}
			cols = area_types.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.area_types[name] = value
			}
			cols = unit_types.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.unit_types[name] = value
			}
			cols = classid_types.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.classid_types[name] = value
			}
			that.startFindCadastreObjectsJSON_(pointX, pointY, arr);
		}
	}

	function getPreloadFault() {
		that.COL_DICT_loaded = true;
		that.startFindCadastreObjectsJSON_(pointX, pointY, arr);
	}

	App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams("COL_DICT.xml"), getPreloadResult, getPreloadFault);
};


map.controls.MapInfoControl.CADASTRE_INFO_URL = '';//'http://pkk5.rosreestr.ru/api/features/';
// •	1 - Земельные участки
// •	2 - Кварталы
// •	3 - Районы
// •	4 - Округи
// •	5 - ОКСы
// •	6 - Тер.зоны
// •	7 - Границы
// •	9 - ОМС
// •	10 - ЗОУИТы
// •	12 - Лесничества и лесопарки


map.controls.MapInfoControl.prototype.startFindCadastreObjectsJSON_ = function (pointX, pointY, arr) {
	var that = this;
	if (!(goog.isNumber(pointX) && goog.isNumber(pointY)))
		return;
	this.searchX = pointX;
	this.searchY = pointY;
	//получили группу
	var currBaseLayer = WidgetMap.BaseLayersParser.currentBaseLayers.getLayersArray();
	//преобразовываем точки в wgs
	var wgsPoint = GeoUtil.convertCoords([pointX, pointY], WidgetMap.DEFAULT_PROJECTION, GeoUtil.PROJS.WGS84);
	this.cadastreUrls = [];
	for (var i in currBaseLayer) {
		var cadastreLayer = currBaseLayer[i].getSource();
		if (goog.isDef(cadastreLayer.getGetFeatureInfoUrl)) {
			if (goog.isDef(App.config.ROSREESTR_URL) && App.config.ROSREESTR_URL.length > 0)
				map.controls.MapInfoControl.CADASTRE_INFO_URL = App.config.ROSREESTR_URL;
			//20.09.17 решено включать в получение информации только кварталы и земельные участки, чтобы меньше шансов быть забаненными
			/*if (cadastreLayer.restURL_.indexOf('ZONES') != -1)
			 this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '10');
			 else {*/
			this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '1');
			this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '2');
			/*this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '3');
			 this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '4');
			 }*/
		}
	}
	that.loadCadastreJSON(wgsPoint, arr);
};

/**
 * Результат запроса к кадастру через новове api
 * @param res
 * @param arr
 * @private
 */
map.controls.MapInfoControl.prototype.resultCadastreJSON_ = function (res, center, url, arr) {
	var that = this;
	if (goog.isDef(res) && goog.isDef(res.features) && res.features.length > 0) {
		that.cadastreFeatures = res.features;
		this.loadCadastreFeatureJSON(url, center, arr);
	} else
		this.loadCadastreJSON(center, arr);
};


map.controls.MapInfoControl.prototype.loadCadastreFeatureJSON = function (url, center, arr) {
	var that = this;
	if (that.cadastreFeatures.length > 0) {
		var feature = that.cadastreFeatures[0];
		that.cadastreFeatures.splice(0, 1);
		if (goog.isDef(feature.attrs) && goog.isDef(feature.attrs.id)) {
			this.curRequest = App.serverQueryCadastreJSON(url + '/' + feature.attrs.id,
				function (resultJSON) {
					BlockingUtil.ready();
					that.resultCadastreJSONObject_(resultJSON, url, center, arr);
				}, function (result) {
					if (goog.isDef(result) && that.cadastreError == '')
						that.cadastreError = result;
					BlockingUtil.ready();
					//если есть ещё фичи, то их продолжаем обрабатывать
					if (that.cadastreFeatures.length > 0)
						that.loadCadastreFeatureJSON(url, center, arr);
					else
						that.loadCadastreJSON(center, arr);
				},4);
			return;
		}
		if (that.cadastreFeatures.length > 0)
			that.loadCadastreFeatureJSON(url, center, arr);
		else
			that.loadCadastreJSON(center, arr);
	} else {
		that.loadCadastreJSON(center, arr);
	}


};

/**
 * Результат запроса к кадастру - получение данных по объекту
 * @param res
 * @param arr
 * @private
 */
map.controls.MapInfoControl.prototype.resultCadastreJSONObject_ = function (res, url, center, arr) {
	var that = this;
	if (goog.isDef(res) && goog.isDef(res.feature)) {
		var feature = res.feature;
		if (goog.isDef(feature.attrs) && goog.isDef(feature.attrs.id) && goog.isDef(feature.type)) {
			//обабатываем
			var label = '';
			var fullId = '';
			if (feature.type == 4) {//кадастровый округ
				label = gis_mapinfocontrol_15;
				fullId = 'CADASTRE_DISTRICT_JSON';
			}
			if (feature.type == 3)//кадастровый район
			{
				label = gis_mapinfocontrol_16;
				fullId = 'CADASTRE_RAYON_JSON';
			}
			if (feature.type == 2)//кадастровый квартал
			{
				label = gis_mapinfocontrol_17;
				fullId = 'CADASTRE_KVARTAL_JSON';
			}
			if (feature.type == 1)//земельный участок
			{
				label = gis_mapinfocontrol_18;
				fullId = 'CADASTRE_PARCEL_JSON';
			}
			if (feature.type == 10)//ЗОУИТ
			{
				label = gis_mapinfocontrol_19;
				fullId = 'CADASTRE_ZOUIT_JSON';
			}
			var resultAttrs = [];
			var obj = {};
			obj.CODE = 'ID';
			obj.DESCR = feature.attrs.id;
			resultAttrs.push(obj);
			for (var attr in feature.attrs) {
				if (attr == 'json_documents')
					continue;
				obj = {};
				if (attr == 'cad_eng_data') {
					if (goog.isNull(feature.attrs[attr]))
						continue;
					obj.CODE = attr;
					obj.DESCR = feature.attrs[attr]['co_name'];
					resultAttrs.push(obj);
					continue;
				}
				var nodeName = that.replaceAttr(feature.type, attr);
				var nodeValue = feature.attrs[attr];
				if (nodeName == 'id') {
					//obj.CODE = 'ID';
					fullId += ':' + nodeValue;
					continue;
				} else {
					obj.CODE = nodeName;//map.controls.MapInfoControl.transliterate(nodeName);
				}
				obj.DESCR = that.replaceValue(nodeName, nodeValue);
				resultAttrs.push(obj);
			}
			arr.push({label: label, id: fullId, attrs: resultAttrs});
		}
	}
	if (that.cadastreFeatures.length > 0)
		that.loadCadastreFeatureJSON(url, center, arr);
	else
		that.loadCadastreJSON(center, arr);
};
/*замена значения из справочника*/
map.controls.MapInfoControl.prototype.replaceValue = function (attrName, value) {
	var resValue = value;
	if (goog.isDef(this.COL_DICT) && value != '') {
		switch (attrName) {
			case 'util_code':
				if (goog.isDef(this.COL_DICT.classid_types) && goog.isDef(this.COL_DICT.classid_types[value]))
					resValue = this.COL_DICT.classid_types[value];
				break;
			case 'area_type':
				if (goog.isDef(this.COL_DICT.area_types) && goog.isDef(this.COL_DICT.area_types[value]))
					resValue = this.COL_DICT.area_types[value];
				break;
			case 'area_unit':
			case 'cad_unit':
				if (goog.isDef(this.COL_DICT.unit_types) && goog.isDef(this.COL_DICT.unit_types[value]))
					resValue = this.COL_DICT.unit_types[value];
				break;
		}
	}
	return resValue;
};
/*замена названия из справочника*/
map.controls.MapInfoControl.prototype.replaceAttr = function (type, attr) {
	var resAttr = attr;
	if (goog.isDef(this.COL_DICT)) {
		if (type == 10 && goog.isDef(this.COL_DICT.zouit) && goog.isDef(this.COL_DICT.zouit[attr]) && this.COL_DICT.zouit[attr] != '')
			resAttr = this.COL_DICT.zouit[attr];
		if (type == 1 && goog.isDef(this.COL_DICT.zu) && goog.isDef(this.COL_DICT.zu[attr]) && this.COL_DICT.zu[attr] != '')
			resAttr = this.COL_DICT.zu[attr];
		if (type == 2 && goog.isDef(this.COL_DICT.cad_kvartal) && goog.isDef(this.COL_DICT.cad_kvartal[attr]) && this.COL_DICT.cad_kvartal[attr] != '')
			resAttr = this.COL_DICT.cad_kvartal[attr];
		if (type == 3 && goog.isDef(this.COL_DICT.cad_rayon) && goog.isDef(this.COL_DICT.cad_rayon[attr]) && this.COL_DICT.cad_rayon[attr] != '')
			resAttr = this.COL_DICT.cad_rayon[attr];
		if (type == 4 && goog.isDef(this.COL_DICT.cad_okrug) && goog.isDef(this.COL_DICT.cad_okrug[attr]) && this.COL_DICT.cad_okrug[attr] != '')
			resAttr = this.COL_DICT.cad_okrug[attr];

	}
	return resAttr;

};


map.controls.MapInfoControl.prototype.resultCadastre_ = function (resultXml, arr) {
	BlockingUtil.ready();
	var resultArr = [];
	var objIds = [];//массив ids пришедших, чтобы убрать дубли в результирущим массиве объектов
	if (resultXml.length > 0) {
		var datas = resultXml[0].getElementsByTagName("FIELDS");
		try {
			// собираем в виде attrs:[{name:'KluchSF', value:'166'},{name:'TekstoviyidentifikatorIPGU', value:'66:17:101018'}]})
			var i = 0;
			for (; i < datas.length; i++) {
				var resultAttrs = [];
				//проверяем к какому слою относится
				//значение по умолчанию, если не попали ни в один вид
				var label = gis_mapinfocontrol_12;
				var objId = '';
				var cadNumber = datas[i].getAttribute(gis_mapinfocontrol_13);
				var count = (cadNumber != "" && cadNumber != null) ? cadNumber.split(":").length - 1 : -1;
				var fullId = 'CADASTRE_OBJECT';
				//0 ":" - округ
				//1 ":" - район
				//2 ":" - квартал
				//3 ":" - земельный участок
				// иначе - кадастровый объект

				if ((count == 0) || (datas[i].getAttribute("RAYONS_CNT") != null) || (datas[i].getAttribute(gis_mapinfocontrol_20) != null)) {//кадастровый округ
					label = gis_mapinfocontrol_15;
					fullId = 'CADASTRE_DISTRICT';
				}
				if ((count == 1) || (datas[i].getAttribute(gis_mapinfocontrol_21) != null) || (datas[i].getAttribute("KVARTALS_CNT") != null && datas[i].getAttribute("RAYONS_CNT") == null) || (datas[i].getAttribute(gis_mapinfocontrol_22) != "" && datas[i].getAttribute(gis_mapinfocontrol_23) == ""))//кадастровый район
				{
					label = gis_mapinfocontrol_16;
					fullId = 'CADASTRE_RAYON';
				}
				if ((count == 2) || (datas[i].getAttribute(gis_mapinfocontrol_24) != null) || (datas[i].getAttribute("KVARTAL_ID") != null) || (datas[i].getAttribute(gis_mapinfocontrol_25) != null))//кадастровый квартал
				{
					label = gis_mapinfocontrol_17;
					fullId = 'CADASTRE_KVARTAL';
				}
				if ((count == 3) || (datas[i].getAttribute(gis_mapinfocontrol_26) != null) || datas[i].getAttribute("PARCEL_ID") != null)//земельный участок
				{
					label = gis_mapinfocontrol_18;
					fullId = 'CADASTRE_PARCEL';
				}
				if (datas[i].getAttribute("OKS_ID") != null)//объект капитального строительства
				{
					label = gis_mapinfocontrol_27;
					fullId = 'CADASTRE_OKS';
				}

				var attrNamesList = datas[i].attributes;
				var needAdd = true;

				var j = 0;
				for (; j < attrNamesList.length; j++) {
					var obj = {};
					var nodeName = attrNamesList[j].nodeName;
					var nodeValue = attrNamesList[j].nodeValue;
					if (nodeName == 'OBJECTID') {
						if (objIds.indexOf(nodeValue) != -1) {
							needAdd = false;
							break;
						}
						obj.name = 'ID';
						objIds.push(nodeValue);
						objId = nodeValue;
						fullId += ':' + nodeValue;
					} else {
						obj.name = map.controls.MapInfoControl.transliterate(nodeName);

					}
					obj.value = nodeValue;
					resultAttrs.push(obj);
				}

				if (needAdd == true)
					resultArr.push({label: label, id: fullId, attrs: resultAttrs});
			}
		} catch (ex) {
		}
	}
	if (!goog.isDefAndNotNull(arr))
		arr = [];
	var finalArr = arr.concat(resultArr);
	this.startFindRasterObjects_(this.searchX, this.searchY, finalArr);
};

/**
 * Функция открытия панели свойств
 * @param arr - массив на выдачу
 * @param error - сообщение об ошибке для случая получения информации из подложки
 * @private
 */
map.controls.MapInfoControl.prototype.showPropertyPanel_ = function (arr, error) {
	var that = this;
	//Если в модели не было выборки объектов или мы не нажимали CTRL - передаем info
	if (this.infoArr.length == 0 || this.withCtrlBtn == false) {
		//на первом клике чистим лой
		if (!this.useCtrl)
			MapUtil.clearSelectionLayer();
		//Если первую выборку делали с нажатым CTRL - берем только первый элемент массива
		//поэтому исходный массив обнуляем, чтобы потом добавить в него только первый объект
		if (this.withCtrlBtn == true && arr.length > 0)
			this.infoArr = [];
		else
			this.infoArr = arr;
	}
	if (this.withCtrlBtn == true) {
		this.useCtrl = true;
		var concatArr = [];
		arr = this.startFindVectorObjects_(arr);
		if (arr.length > 0) {
			for (var i = 0; i < arr.length; i++) {
				var isNewElem = true;
				for (var j = 0; j < this.infoArr.length; j++) {
					if (goog.isDef(arr[i].id) && goog.isDef(this.infoArr[j].id) && arr[i].id == this.infoArr[j].id) {
						isNewElem = false;
						break;
					}
				}
				//прошли по всем объектам существующего массива и не нашли с таким же ID - включаем
				if (isNewElem == true) {
					concatArr.push(arr[i]);
					break;
				}
			}
		}
		this.infoArr = this.infoArr.concat(concatArr);
		//в массив searchXY добавляем координаты точек, в которых жали с ctrl
		this.infoCoordArr.push({searchX: this.searchX, searchY: this.searchY});
	}
	if (this.withCtrlBtn == false) {
		if (!this.useCtrl) {
			arr = this.startFindVectorObjects_(arr);
			//выставляем в WidgetMap.mapSelectedObject массив выбранных объектов
			MapUtil.clearSelectionLayer();
		}

		/*проверка, что задача ПКА*/
		var exportToGpxKmlCallback = undefined;
		var centeringCallback = undefined;
		var deleteCASCallback = undefined;
		var calculateObjectSizeCallback = undefined;
		if (goog.isDef(WidgetMap.LINE_ID)) {
			exportToGpxKmlCallback = function () {
				return false;
			};
			centeringCallback = function () {
				return false;
			};
			deleteCASCallback = function () {
				App.errorReport(gis_mapinfocontrol_14, gis_mapinfocontrol_3, undefined, {
					filename: gis_filename_459,
					functionname: 'gis_filename_459_10'
				});
				return false;
			};
			//если не нашли объектов, не показываем панель свойств для ПКА
			if (arr.length === 0) {
				this.useCtrl = false;
				//для АСМО выполняем пересборку id в xml
				this.sendObjectsInfo_(arr);
				this.infoArr = [];
				this.infoCoordArr = [];

				return;
			}

		} else if (GeoUtil.PROJS['EPSG:5807'] === WidgetMap.DEFAULT_PROJECTION)
			calculateObjectSizeCallback = undefined;
		else {
			calculateObjectSizeCallback = function (params) {
				if (params && params.selector && params.object) {
					$(params.selector).text(MapUtil.calculateObjectSize(params.object));
				}
			};
		}

		var dontShowEmplyPanel = WidgetMap.config && WidgetMap.config.ppanel && WidgetMap.config.ppanel.showInfoEmptyMap === false && arr.length === 0;

		if (!dontShowEmplyPanel) {
			var mapPropPanelId = 'mapPPanel';
			var dId = getParameterByName('dialogId');
			if(dId){
				parent.App.resizeIframeMap(dId);
			}
			$('#' + mapPropPanelId).remove();
			var mapPropPanelDiv = '<div id="' + mapPropPanelId + '" class="gsi-zindex__ppanel"></div>';
			$('body').append(mapPropPanelDiv);
			$('#' + mapPropPanelId).myPropertiesPanel({
				coords: [this.searchX, this.searchY],
				error: error,
				withCtrl: this.useCtrl,
				objects: arr,
				position: that.ppanelPosition,
				opener: 'body',
				handlers: {
					dragPanelCallback: function (coords) {
						that.ppanelPosition = coords;
					},
					calculateObjectSizeCallback: calculateObjectSizeCallback,
					deleteCASCallback: deleteCASCallback,
					centeringCallback: centeringCallback,
					exportToGpxKmlCallback: exportToGpxKmlCallback,
					changePanelObjectCallback: function (dataObject, withCtrl) {
						//если не был нажат ctrl, то переформировываем выделение, иначе оставляем всё как есть.
						//используется для построения буферов по всем выбранным объектам
						if (withCtrl !== true) {
							//переформировываем для выделения
							var objects = [];
							if (dataObject.id.indexOf('CADASTRE') != -1)
								return;
							if (goog.isDef(dataObject.geo))
								objects.push({name: 'objects', value: dataObject.id, geo: dataObject.geo});
							else
								objects.push({name: 'objects', value: dataObject.id});
							objects.push({name: 'centering', value: 'false'});
							objects.push({name: 'uniqueLayerName', value: dataObject.uniqueLayerName});

							WidgetMap.showObjects(objects);
						}
					},
					closeCallback: function () {
						if (WidgetMap.currentCutFeature && WidgetMap.currentCutFeature[WidgetMap.mapSelectedObject]) {
							WidgetMap.addObjectControl.pasteFeature = undefined;
							WidgetMap.addObjectControl.moveFeature = undefined;
							map.controls.DeleteBufferObjectControl.revertCurrentObject([WidgetMap.mapSelectedObject]);
						}
						MapUtil.clearSelectionLayer();
						//обнуляем массив подписей, который прятали при выделении объектов
						if (goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0) {
							WidgetMap.map.render();
							WidgetMap.hideLabelsArr = [];
						}
					},
					semanticCallback: function (dataObject) {
						var syncOptions = {
							syncType: SyncTypes.TYPE_3,
							syncSender : 'ppanel',
							syncUniqueLayerName: undefined
						};
						var syncType = SyncTypes.TYPE_NO;
						syncOptions = undefined;
						var pasteFeature = undefined;
						var needBind = false;
						try{
							if (goog.isDef(WidgetMap.addObjectControl) && goog.isDef(WidgetMap.addObjectControl.pasteFeature)) {
								pasteFeature = WidgetMap.addObjectControl.pasteFeature;
								var objId = pasteFeature.get('objectId');
								if (objId) {//если редактировали на карте, нужно перепровернить привязку
									needBind = true;
								}
								//syncType = SyncTypes.TYPE_1;
							} else if (goog.isDef(WidgetMap.moveGeometryControl) && !goog.isDef(pasteFeature)) {
								//если двигали на карте, нужно перепровернить привязку
								pasteFeature = WidgetMap.moveGeometryControl.pasteFeature;
								needBind = true;
							}

							if (goog.isDef(pasteFeature)) {
								var layerName = pasteFeature.get('layerName');
								var semId = pasteFeature.get('objectId');
								var clonedFeature = GeoUtil.cloneFeature(pasteFeature, true, true);
								pasteFeature = GeoUtil.recreateFeatureGeometry(pasteFeature);
								var layObj = WidgetMap.layerManager.getLayerByName(layerName);
								var geo = clonedFeature.getGeometry();
								if(geo && geo.flatCoordinates.length === 0){ //если нет координат, то не привязываем
									needBind = false;
								}

								if (needBind) {
									var bindDataTypes = (goog.isDef(App.config.MAP_BIND_CLASSES) && App.config.MAP_BIND_CLASSES.length > 0) ? App.config.MAP_BIND_CLASSES.split(',') : [];
									if (goog.isDef(bindDataTypes) && bindDataTypes.length > 0 && bindDataTypes.indexOf(layerName) != -1) {
										map.controls.DrawGeometryControl.showBindForm(layerName, clonedFeature, ["PODS_ROUTE"], syncOptions);
									} else {
										var projection = (goog.isDef(layObj) && goog.isDef(layObj.layer)) ? layObj.layer.projection : GeoUtil.PROJS.Pulkovo42;
										GeoUtil.convertFeature(clonedFeature, WidgetMap.DEFAULT_PROJECTION, projection);
										//that.pasteFeature - уже наша отредактированная фича
										map.controls.DrawGeometryControl.updateGeometry_(semId, clonedFeature, pasteFeature, layerName, false, syncOptions);
									}
								} else {
									var projection = (goog.isDef(layObj) && goog.isDef(layObj.layer)) ? layObj.layer.projection : GeoUtil.PROJS.Pulkovo42;
									GeoUtil.convertFeature(clonedFeature, WidgetMap.DEFAULT_PROJECTION, projection);
									//that.pasteFeature - уже наша отредактированная фича
									map.controls.DrawGeometryControl.updateGeometry_(semId, clonedFeature, pasteFeature, layerName, false, syncOptions);
								}
								var selectedObject = layerName + ':' + semId;
								//СИНХРОНИЗАЦИЯ #H5
								App.syncManager.callSync(selectedObject, 'ppanel', undefined, syncType);

								WidgetMap.addObjectControl.pasteFeature = undefined;
								WidgetMap.addObjectControl.moveFeature = undefined;
								WidgetMap.handleEscClick_();
							}
							//если слой косметический
							else {
								var dataObj = dataObject.savingData;
								if (goog.isDef(dataObj)) {
									//<root USER_ID="1045" USER_LOGIN="editor" PODS_USER="editor"><data FILTER="ID=-657789252" SYS_FULL_ID="COSMETIC_OBJECT/-657789252" DB_SCHEMA_ID="COSMETIC" DB_TABLE_ID="OBJECT" SYS_CLASS_ID="COSMETIC_OBJECT" SYS_OBJ_ID="-657789252"  LABEL="qq1" NAME="Объект косметического слоя" /></root>
									//<root USER_ID="1045" USER_LOGIN="editor" PODS_USER="editor"><data FILTER="ID=1" SYS_FULL_ID="COSMETIC_OBJECT/1" DB_SCHEMA_ID="COSMETIC" DB_TABLE_ID="OBJECT" SYS_CLASS_ID="COSMETIC_OBJECT" SYS_OBJ_ID="1"  LABEL="sadsd" NAME="Объект косметического слоя" /></root>
									//забираем id слоя и объекта и обновляем информацию
									var layerGeoXml = ($.parseXML(dataObj)).firstChild;
									var data = layerGeoXml.getElementsByTagName("data");
									if (data.length >= 0) {
										var fullId = data[0].getAttribute('SYS_FULL_ID');
										if (fullId.indexOf('COSMETIC_OBJECT') != -1) {
											var splitted = fullId.split('/');
											if (splitted.length > 1) {
												var semId = splitted[1];
												var layObj = WidgetMap.layerManager.getLayerByName(splitted[0]);
												//пробуем искать в косметике, потом в буфере
												var found = false;
												var label = null;
												if (goog.isDef(layObj) && goog.isDef(layObj.layer)) {
													if (!goog.isNull(data[0].getAttribute(layObj.layer.labelField)) && data[0].getAttribute(layObj.layer.labelField) != 'NULL')
														label = data[0].getAttribute(layObj.layer.labelField);
													if (!goog.isNull(data[0].getAttribute('LABEL')))
														label = data[0].getAttribute('LABEL');
													found = layObj.layer.updateLabel(semId, label);
												}
												if (!found) {
													var features = WidgetMap.bufferLayer.getSource().getFeatures();
													var i = 0, j = 0;
													for (j; j < features.length; j++) {
														var labelsObj = features[j].get('labelsObj');
														if (!goog.isDef(labelsObj)) {
															var geoType = features[j].getGeometry().getType();
															switch (geoType) {
																case 'Point':
																	globalPointsLabels_[splitted[0]] = [{
																		label: label,
																		id: semId,
																		geo: features[j].getGeometry()
																	}];
																	break;
																case 'LineString':
																	globalLinesLabels_[splitted[0]] = [{
																		label: label,
																		id: semId,
																		geo: features[j].getGeometry()
																	}];
																	break;
																case 'Polygon':
																	globalPolygonsLabels_[splitted[0]] = [{
																		label: label,
																		id: semId,
																		geo: features[j].getGeometry()
																	}];
																	break;
															}
															features[j].set('labelsObj', [{
																label: label,
																id: semId,
																geo: features[j].getGeometry()
															}]);
														} else {
															for (i; i < labelsObj.length; i++) {
																if (labelsObj[i].id == semId) {
																	var geoType = features[j].getGeometry().getType();
																	switch (geoType) {
																		case 'Point':
																			for (var kk in globalPointsLabels_['COSMETIC_OBJECT'])
																				if (globalPointsLabels_['COSMETIC_OBJECT'][kk].id == semId) {
																					globalPointsLabels_['COSMETIC_OBJECT'][kk].label = label;
																					break;
																				}
																			break;
																		case 'LineString':
																			for (var kk in globalLinesLabels_['COSMETIC_OBJECT'])
																				if (globalLinesLabels_['COSMETIC_OBJECT'][kk].id == semId) {
																					globalLinesLabels_['COSMETIC_OBJECT'][kk].label = label;
																					break;
																				}
																			break;
																		case 'Polygon':
																			for (var kk in globalPolygonsLabels_['COSMETIC_OBJECT'])
																				if (globalPolygonsLabels_['COSMETIC_OBJECT'][kk].id == semId) {
																					globalPolygonsLabels_['COSMETIC_OBJECT'][kk].label = label;
																					break;
																				}
																			break;
																	}
																	labelsObj[i].label = label;
																	break;
																}
															}
														}
													}
													//WidgetMap.bufferLayer.changed();
												}
												//обнуляем массив подписей, который прятали при выделении объектов
												/*if(goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0){
												 WidgetMap.map.render();
												 WidgetMap.hideLabelsArr = [];
												 }*/
											}
										} else {
											//Если меняли стиль объекта TYPE_CL при сохранении семантики, то ищем его в фичах и переносим в новую или не трогаем
											var splitted = fullId.split('/');
											var label = null;
											if (splitted.length > 1) {
												var layerId = splitted[0];
												var semId = splitted[1];
												var layObj = WidgetMap.layerManager.getLayerByName(layerId);
												if (goog.isDef(layObj) && goog.isDef(layObj.layer)) {
													//сначала меняем подпить, если её меняли на сохранении семантики
													if (!goog.isNull(data[0].getAttribute(layObj.layer.labelField)) && data[0].getAttribute(layObj.layer.labelField) != 'NULL')
														label = data[0].getAttribute(layObj.layer.labelField);
													if (!goog.isNull(data[0].getAttribute('LABEL')))
														label = data[0].getAttribute('LABEL');
													var found = layObj.layer.updateLabel(semId, label);
													//меняем стиль отрисовки на карте
													layObj.layer.updateObjectGeoStyle(semId, data, dataObject);
												}
												var selectedObject = layerId + ':' + semId;
												//СИНХРОНИЗАЦИЯ #I5
												App.syncManager.callSync(selectedObject, 'ppanel', undefined, SyncTypes.TYPE_3);
											}
										}
									}
								}
							}
						}
						catch(ex){
							App.errorReport(gis_mapinfocontrol_29, ex.message, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_14'});
						}

					},
					successDeleteCallback: function (data) {
						if (goog.isDef(data) && goog.isDef(data.id) && data.id != '' && data.layerName != '') {
							var layObj = WidgetMap.layerManager.getLayerByName(data.layerName);
							if (goog.isDef(layObj) && goog.isDef(layObj.layer)) {
								layObj.layer.deleteObjectById(data.id);
							}
						}
						MapUtil.clearSelectionLayer();
						//обнуляем массив подписей, который прятали при выделении объектов
						if (goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0) {
							WidgetMap.map.render();
							WidgetMap.hideLabelsArr = [];
						}
						//СИНХРОНИЗАЦИЯ #K6
						$('#mapPPanel').remove();
					}
				}
			});
		}

		this.useCtrl = false;
		//для АСМО выполняем пересборку id в xml
		this.sendObjectsInfo_(arr);
		this.infoArr = [];
		this.infoCoordArr = [];
	} else {
		//05.03.20 Новое поведение. Когда выбираем объект, то ставим не точку, а выделяем весь объект
		var k = this.infoArr.length - 1;
		//нашли объект и заносим его в слой выделения
		if (this.infoArr && this.infoArr.length > 0 && this.infoArr[k]) {
			this.addObjectToSelectionLayer_(this.infoArr[k], k);
		}
	}
};

/**
 * Добавляем выбранный объект в слой выделения на карте
 * @param object
 * @param index
 * @private
 */
map.controls.MapInfoControl.prototype.addObjectToSelectionLayer_ = function (object, index) {
	function getLayerGeoReqParams(filter, request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' +
				'<data FILTER="' + filter + '"/>' +
				'</root>'
		};
	}
	function getLayerGeoRequest(filter, request, layerObj, indexId) {
		var filterStr = generateFilterStr(filter);
		App.serverQueryXMLNodeWithTries(Services.processQueryNodeGeo, getLayerGeoReqParams(filterStr, request), getLayerGeoResult, getLayerGeoFault,4);
		function getLayerGeoResult(resultXml) {
			try { // Иногда ответ в формате XML, а иногда в виде просто строки
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== ''){
					App.errorReport(gis_mapinfocontrol_28, er, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_13'});
				}
				else{
					var layerGeoXml = ($.parseXML(resultXml)).firstChild;
					var datas = layerGeoXml.getElementsByTagName("data");
					var stride = 2;
					for (var i = 0; i < datas.length; i++) {
						//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
						var format = new ol.format.WKT({dimension: stride});
						var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
						var idStr = datas[i].getAttribute("ID");
						var feature = undefined;
						try {
							feature = format.readFeature(wktStr);
						} catch (ex) {
							//для случая с видеозаписями, приходит 3 координаты
							stride = 3;
							format = new map.format.WKT({dimension: stride});
							feature = format.readFeature(wktStr);
						}
						if (goog.isDef(feature)) {
							//забираем координаты и переводим их в нормальную проекцию
							var flatCoordinates = feature.getGeometry().flatCoordinates;
							if (flatCoordinates.length > 1 && flatCoordinates[0] != -1 && flatCoordinates[1] != -1) {
								//устанавливаем в фичу стиль дефолтный
								if (stride == 3) {
									var newArr = [];
									for (var j = 0; j < flatCoordinates.length; j += stride) {
										var lng = flatCoordinates[j];
										var lat = flatCoordinates[j + 1];
										newArr.push(lng);
										newArr.push(lat);
									}
									//геометрия выделяемого участка трубопровода
									var geometry = new ol.geom.LineString(null);
									geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY, newArr);
									var newLineFeature = new ol.Feature(geometry);
									WidgetMap.layerManager.defaultSelectionStyle(newLineFeature);
									GeoUtil.convertFeature(newLineFeature, App.projection, WidgetMap.DEFAULT_PROJECTION);
									newLineFeature.setId('DEFAULT_SELECTED_' + idStr);
									WidgetMap.mapSelectionLayer.getSource().addFeature(newLineFeature);
								} else {
									WidgetMap.layerManager.defaultSelectionStyle(feature);
									GeoUtil.convertFeature(feature, App.projection, WidgetMap.DEFAULT_PROJECTION);
									feature.setId('DEFAULT_SELECTED_' + idStr);
									WidgetMap.mapSelectionLayer.getSource().addFeature(feature);
								}
							}
						}
					}
				}
			} catch (ex) {
			}
		}
		function getLayerGeoFault(resultXml) {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '')
				App.errorReport(gis_mapinfocontrol_28, er, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_12'});
		}
		function generateFilterStr(filter) {
			return "ID in (" + filter.join(",") + ")";
		}
	}

	if (object) {
		//если есть геометрия, то сразу добавляем
		if (object.geo) {
			var currFeature = new ol.Feature(object.geo.getGeometry());
			currFeature.setId('DEFAULT_SELECTED_' + index);
			WidgetMap.layerManager.defaultSelectionStyle(currFeature);
			WidgetMap.mapSelectionLayer.getSource().addFeature(currFeature);
		} else {
			//если нет гео, то смотрим, какой слой, растр или вектор
			var layerName = object.id.split(':')[0];
			var objId = object.id.split(':')[1];
			var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
			//если слоя нет в _rasterLayers
			var isRasterLayer = false;
			var layerRasterObj = WidgetMap.layerManager.getRasterLayerByName(layerName);
			if (layerRasterObj && WidgetMap.CURRENT_MODE === WidgetMap.MODES.RASTER)
				isRasterLayer = true;
			if (object.uniqueLayerName && !isRasterLayer) {//слой векторный
				var features = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(object.layerName, [objId]);
				WidgetMap.mapSelectionLayer.getSource().addFeatures(features);
			} else {
				//грузим растровые данные данные
				var spatialRequest = layerObj.dataProvider.spatial;
				getLayerGeoRequest([objId], spatialRequest, layerObj, index);
			}
		}
	}
};



/**
 * для АСМО выполняем пересборку id в xml
 * @param arr
 */
map.controls.MapInfoControl.prototype.sendObjectsInfo_ = function (arr) {
	var that = this;
	try {
		var screen = GeoUtil.convertCoords([this.searchX, this.searchY], WidgetMap.DEFAULT_PROJECTION, App.projection);
		var userId = '1';
		var sessionId = '1';
		var data = '<data x="' + this.searchX + '" y="' + this.searchY + '"  screen_x="' + screen[0] + '" screen_y="' + screen[1] + '" />';
		var reqData = '';
		var i, j;
		var c;
		var layer_name;
		var obj_id;
		var cls;
		//Среди растровых слоев могут быть трубы и прочие объекты - обрабатываем их
		var rLayers = WidgetMap.layerManager.getRasterLayers();
		var rLayersByName = {};
		for (j = 0; j < rLayers.length; j++) {
			var rLayer = rLayers[j];
			if (goog.isDef(rLayer) && goog.isDef(rLayer.layer) && rLayer.layer.name != '')
				rLayersByName[rLayer.layer.name] = rLayer;
		}
		var rLayersCache = WidgetMap.layerManager.getVectorLayersByMode();
		var rLayersByNameCache = {};
		for (j = 0; j < rLayersCache.length; j++) {
			var rLayer = rLayersCache[j];
			if (goog.isDef(rLayer) && goog.isDef(rLayer.layer) && goog.isDefAndNotNull(rLayer.layer.name) && rLayer.layer.name != '')
				rLayersByNameCache[rLayer.layer.name] = rLayer;
		}
		var hasChildren = false;
		for (i = 0; i < arr.length; i++) {
			var o = arr[i];
			if (!goog.isDef(o.VECTOR_LAYER) && goog.isDef(o.USER_LAYER_NAME) && goog.isDef(o.ID)) {
				var layDescr = o["USER_LAYER_NAME"];
				//Обрабатываем информацию с растровых труб и аналогичных слоев
				var curRasterLay = rLayersByName[layDescr];
				var curCacheLay = rLayersByNameCache[layDescr];
				//Просто растровую подложку не обрабатываем
				if (goog.isDef(curRasterLay) && goog.isDef(curRasterLay.layer) && curRasterLay.layer.name.indexOf('WEB50_M_') == -1) {
					var idStr = curRasterLay.layer.name + "/" + o.ID;
					cls = (goog.isDef(curRasterLay.layer.name)) ? curRasterLay.layer.name.replace("PODS_", "").replace("PKMETADATA_", "") : '';
					c = '<data OBJ_ID="' + o.ID + '" CLS="' + cls + '"  USER_ID="' + userId + '" SESSION_ID="' + sessionId + '" />';
					data += c;
					reqData += c;
					hasChildren = true;
				} else if (goog.isDef(curCacheLay) && goog.isDef(curCacheLay.layer) && curCacheLay.layer.name.indexOf('WEB50_M_') == -1) {
					obj_id = o.ID;
					layer_name = curCacheLay.layer.name;//o.CLS_NAME;
					obj_id = obj_id.substr(obj_id.indexOf("/") + 1);
					cls = (goog.isDef(layer_name)) ? layer_name.replace("PODS_", "").replace("PKMETADATA_", "") : '';
					c = '<data OBJ_ID="' + obj_id + '" CLS="' + cls + '"  USER_ID="' + userId + '" SESSION_ID="' + sessionId + '" />';
					data += c;
					reqData += c;
					hasChildren = true;
				}
			}
		}
		if (hasChildren) {
			function getLayersReqParams(data) {
				var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
				var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

				return {
					descrId: map.controls.requestFindInfId,
					descrType: 'select',
					data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '">' +
						data +
						'</root>'
				};
			}

			App.serverQueryXMLNodeWithTries(Services.processQueryNode, getLayersReqParams(reqData), function (resultXml) {
				that.resultAsmo_(resultXml);
			}, function (resultXml) {
				that.faultAsmo_(resultXml);
			});
		}

		data += '</data>';
		this.data_ = data;
		onObjectsInfo(this.data_);
	} catch (e) {

	}

};

map.controls.MapInfoControl.prototype.resultAsmo_ = function (resultXml) {
	var er = HTTPServiceUtil.getError(resultXml);
	this.data_ = this.data_.replace('</data>', '');
	if (er !== '') {
		return;
	} else {
		var layerGeoXml = ($.parseXML(resultXml)).firstChild;
		var datas = layerGeoXml.getElementsByTagName("root");
		var hasChildren = false;
		for (var i = 0; i < datas.length; i++) {
			var cls = (goog.isDef(datas[i].getAttribute('CLS'))) ? datas[i].getAttribute('CLS') : '';
			var c = '';
			if (cls != '') {
				c = '<item id="' + datas[i].getAttribute('ID') + '" cls="' + cls + '" obj_id="' + datas[i].getAttribute('OBJ_ID') + '" />';
				this.data_ += c;
			} else {
				if (parseFloat(datas[i].getAttribute('id')) > 0) {
					c = '<item id="' + datas[i].getAttribute('ID') + '" />';
					this.data_ += c;
				}
			}
		}
	}

	this.data_ += '</data>';
	if (hasChildren) {
		onObjectsInfo(this.data_);
	}

	this.data_ = '';
};

map.controls.MapInfoControl.prototype.faultAsmo_ = function (resultXml) {
	var er = HTTPServiceUtil.getError(resultXml);
	if (er !== '') {
		this.data_ = this.data_.replace('</data>', '');
		this.data_ += 'Error: ' + er;
		this.data_ += '</data>';
		onObjectsInfo(this.data_);
	}
	this.data_ = '';
};

map.controls.MapInfoControl.transliterate = function (word) {
	var answer = ""
		, a = {};

	a["Ё"] = "YO";
	a["Й"] = "I";
	a["Ц"] = "TS";
	a["У"] = "U";
	a["К"] = "K";
	a["Е"] = "E";
	a["Н"] = "N";
	a["Г"] = "G";
	a["Ш"] = "SH";
	a["Щ"] = "SCH";
	a["З"] = "Z";
	a["Х"] = "H";
	a["Ъ"] = "";
	a["ё"] = "yo";
	a["й"] = "i";
	a["ц"] = "ts";
	a["у"] = "u";
	a["к"] = "k";
	a["е"] = "e";
	a["н"] = "n";
	a["г"] = "g";
	a["ш"] = "sh";
	a["щ"] = "sch";
	a["з"] = "z";
	a["х"] = "h";
	a["ъ"] = "";
	a["Ф"] = "F";
	a["Ы"] = "I";
	a["В"] = "V";
	a["А"] = "a";
	a["П"] = "P";
	a["Р"] = "R";
	a["О"] = "O";
	a["Л"] = "L";
	a["Д"] = "D";
	a["Ж"] = "ZH";
	a["Э"] = "E";
	a["ф"] = "f";
	a["ы"] = "i";
	a["в"] = "v";
	a["а"] = "a";
	a["п"] = "p";
	a["р"] = "r";
	a["о"] = "o";
	a["л"] = "l";
	a["д"] = "d";
	a["ж"] = "zh";
	a["э"] = "e";
	a["Я"] = "Ya";
	a["Ч"] = "CH";
	a["С"] = "S";
	a["М"] = "M";
	a["И"] = "I";
	a["Т"] = "T";
	a["Ь"] = "";
	a["Б"] = "B";
	a["Ю"] = "YU";
	a["я"] = "ya";
	a["ч"] = "ch";
	a["с"] = "s";
	a["м"] = "m";
	a["и"] = "i";
	a["т"] = "t";
	a["ь"] = "";
	a["б"] = "b";
	a["ю"] = "yu";
	a["."] = "";
	var i;
	for (i in word) {
		if (word.hasOwnProperty(i)) {
			if (a[word[i]] === undefined) {
				answer += word[i];
			} else {
				answer += a[word[i]];
			}
		}
	}
	return answer;
	//2-й вариант
	var a = {
		"Ё": "YO",
		"Й": "I",
		"Ц": "TS",
		"У": "U",
		"К": "K",
		"Е": "E",
		"Н": "N",
		"Г": "G",
		"Ш": "SH",
		"Щ": "SCH",
		"З": "Z",
		"Х": "H",
		"Ъ": "'",
		"ё": "yo",
		"й": "i",
		"ц": "ts",
		"у": "u",
		"к": "k",
		"е": "e",
		"н": "n",
		"г": "g",
		"ш": "sh",
		"щ": "sch",
		"з": "z",
		"х": "h",
		"ъ": "'",
		"Ф": "F",
		"Ы": "I",
		"В": "V",
		"А": "a",
		"П": "P",
		"Р": "R",
		"О": "O",
		"Л": "L",
		"Д": "D",
		"Ж": "ZH",
		"Э": "E",
		"ф": "f",
		"ы": "i",
		"в": "v",
		"а": "a",
		"п": "p",
		"р": "r",
		"о": "o",
		"л": "l",
		"д": "d",
		"ж": "zh",
		"э": "e",
		"Я": "Ya",
		"Ч": "CH",
		"С": "S",
		"М": "M",
		"И": "I",
		"Т": "T",
		"Ь": "'",
		"Б": "B",
		"Ю": "YU",
		"я": "ya",
		"ч": "ch",
		"с": "s",
		"м": "m",
		"и": "i",
		"т": "t",
		"ь": "'",
		"б": "b",
		"ю": "yu"
	};

	function transliterate(word) {
		return word.split('').map(function (char) {
			return a[char] || char;
		}).join("");
	}
};


/***
 *  Подгрузка данные
 * @param urls
 * @param arr
 */
map.controls.MapInfoControl.prototype.loadCadastreJSON = function (center, arr) {
	var that = this;
	if (this.cadastreUrls.length == 0) {
		if (that.cadastreError != '')
			App.errorReport(gis_mapinfocontrol_2, that.cadastreError, undefined, {
				filename: gis_filename_459,
				functionname: 'gis_filename_459_11'
			});
		this.startFindRasterObjects_(this.searchX, this.searchY, arr);
		return;
	}
	var zoom = WidgetMap.map.getView().getZoom();
	var tolerance = this.getToleranceByZoom_(zoom);

	var url = this.cadastreUrls[0];
	this.cadastreUrls.splice(0, 1);
	var centerStr = ('' + center[1]).replace('.', ',') + ' ' + ('' + center[0]).replace('.', ',');
	var detailUrl = url + '?text=' + centerStr + '&tolerance=' + tolerance + '&limit=2';
	var proxyUrl = (goog.isDef(App.config.ROSREESTR_PROXY_URL) && App.config.ROSREESTR_PROXY_URL.length > 0) ? App.config.ROSREESTR_PROXY_URL : '';//'https://proxy.anonymster.com/browse.php?u=';
	if (proxyUrl != '') {
		detailUrl = detailUrl.replace(/\//g, '%2F').replace(/ /g, '%20').replace(/,/g, '%2C').replace(/:/g, '%3A').replace(/&/g, '%26').replace(/=/g, '%3D').replace(/\?/g, '%3F');
		detailUrl = proxyUrl + detailUrl;
	}

	that.curRequest = App.serverQueryCadastreJSON(detailUrl,
		function (resultJSON) {
			BlockingUtil.ready();
			that.resultCadastreJSON_(resultJSON, center, url, arr);
		}, function (result) {
			if (goog.isDef(result) && that.cadastreError == '')
				that.cadastreError = result;
			BlockingUtil.ready();
			that.loadCadastreJSON(center, arr);
		},4);

};

map.controls.MapInfoControl.prototype.getToleranceByZoom_ = function (zoom) {
	var tolerance = 1;
	switch (zoom) {
		case 19:
			tolerance = 2;
			break;
		case 18:
			tolerance = 4;
			break;
		case 17:
			tolerance = 8;
			break;
		case 16:
			tolerance = 16;
			break;
		case 15:
			tolerance = 32;
			break;
		case 14:
			tolerance = 64;
			break;
		case 13:
			tolerance = 128;
			break;
		case 12:
			tolerance = 258;
			break;
		case 11:
			tolerance = 512;
			break;
		case 10:
			tolerance = 1024;
			break;
		case 9:
			tolerance = 2048;
			break;
		case 8:
			tolerance = 4097;//4094;
			break;
		case 7:
			tolerance = 8195;
			break;
		case 6:
			tolerance = 16391;
			break;
		case 5:
			tolerance = 32782;
			break;
		case 4:
			tolerance = 65564;
			break;
		default:
			tolerance = 1;
	}
	return tolerance;
};


goog.provide('map.controls.BufferZoneControl');
goog.provide('map.controls.BufferZoneChooserControl');


map.controls.LOAD_BUFFER_ZONE_ERROR = gis_bufferzonechoosercontrol_1;

//границы зон в wgs
map.controls.bufferZonesBounds = {};


/**
 * Контрол для выбора вариантов измерения на карте
 * @param opt_options
 * @constructor
 */
map.controls.BufferZoneChooserControl = function (opt_options) {
    var options = goog.isDef(opt_options) ? opt_options : {};
    var className = goog.isDef(options.className) ?
        options.className : 'map-choose-buffer';

    this.currentBufferType = 'custom';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_bufferzonechoosercontrol_2;
    this.innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-current map-buffer-custom',
        'type': 'button',
        'title': tooltipLabel
    });
    this.innerElement.style.display = 'inline';

    goog.events.listen(this.innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.BufferZoneChooserControl.prototype.handleBufferClick_), false, this);

    var arrowElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-arrow',
        'type': 'button',
        'title': gis_bufferzonechoosercontrol_2
    });
    arrowElement.style.display = 'inline';


    goog.events.listen(arrowElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.BufferZoneChooserControl.prototype.handleBufferChooseClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.innerElement, arrowElement);
    }


	goog.base(this, {
		element: element,
		target: options.target
	});

};
goog.inherits(map.controls.BufferZoneChooserControl, ol.control.Control);

/**
 * Реация на нажатие кнопки поиска
 * @private
 */
map.controls.BufferZoneChooserControl.prototype.handleBufferClick_ = function () {
	WidgetMap.bufferZoneControl.handleBufferClick_(this.currentBufferType);
};

/**
 * Реация на нажатие кнопки выбора режима поиска
 * @private
 */
map.controls.BufferZoneChooserControl.prototype.handleBufferChooseClick_ = function () {
	WidgetMap.bufferZoneControl.setVisible_(!WidgetMap.bufferZoneControl.isVisible);
};


/**
 * Смена типа построения буферных зон по клику на кнопки из map.controls.BufferZoneControl
 * @private
 */
map.controls.BufferZoneChooserControl.prototype.changeBufferType = function (type) {
	this.currentBufferType = type;
	if (type == 'custom') {
		$(this.innerElement).addClass('map-buffer-custom');
		$(this.innerElement).removeClass('map-buffer-all');
	}
	if (type == 'all') {
		$(this.innerElement).removeClass('map-buffer-custom');
		$(this.innerElement).addClass('map-buffer-all');
	}
	else {
		$(this.innerElement).removeClass('map-buffer-all');
		$(this.innerElement).removeClass('map-buffer-custom');
	}
};


/**
 * Контрол для построения буферной зоны
 * @constructor
 */
map.controls.BufferZoneControl = function (opt_options) {
	var options = goog.isDef(opt_options) ? opt_options : {};

	//массив id для построения по ним буферных зон
	var selectedIds = goog.isDef(options.selectedIds) ?
		options.selectedIds : [];

	var className = goog.isDef(options.className) ?
		options.className : 'map-buffer';

	this.currentBufferType = 'custom';
	this.isVisible = false;

	var tooltipCustom = goog.isDef(options.tooltipCustom) ?
		options.tooltipCustom : gis_bufferzonechoosercontrol_3;
	var bufferElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-custom',
		'type': 'button',
		'title': tooltipCustom
	});

	var tooltipAll = goog.isDef(options.tooltipAll) ?
		options.tooltipAll : gis_bufferzonechoosercontrol_4;
	var bufferElementAll = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-all',
		'type': 'button',
		'title': tooltipAll
	});

	map.controls.BufferZoneControl.prototype.add326NNProjections_();

	goog.events.listen(bufferElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.BufferZoneControl.prototype.handleBufferClick_, 'custom'), false, this);
	goog.events.listen(bufferElementAll,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.BufferZoneControl.prototype.handleBufferClick_, 'all'), false, this);

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;

	//убрал kmElement, работает нестабильно
    if(options.noElement) {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, bufferElement, bufferElementAll);
    }
	goog.base(this, {
		element: element,
		target: options.target
	});
};
goog.inherits(map.controls.BufferZoneControl, ol.control.Control);

/**
 * Спрятать/показать кнопку
 * @param visible
 * @private
 */
map.controls.BufferZoneControl.prototype.setVisible_ = function (visible) {
	if (visible)
		$('.map-buffer').css('visibility', 'visible');
	else
		$('.map-buffer').css('visibility', 'hidden');
	this.isVisible = visible;
};

/**
 * Добавляем проекции для корректного пересчета буфера в различных зонах
 *
 * @private
 */
map.controls.BufferZoneControl.prototype.add326NNProjections_ = function () {
	var startBounds = [18, 0, 24, 84];
	for (var i = 0; i <= 26; i++) {
		//proj4.defs("EPSG:326"+(i+34),"+proj=utm +zone="+(i+34)+" +datum=WGS84 +units=m +no_defs");
		map.controls.bufferZonesBounds["EPSG:326" + (i + 34)] = [startBounds[0] + 6 * i, 0, startBounds[2] + 6 * i, 84];
	}
};

/**
 * Реация на нажатие кнопок построения буферной зоны
 * @param type - тип построения буферной зоны
 * @param withCtrl - была ли нажата кнопка ctrl при получении информации, чтобы в дальнейшем построить буферную зхону по всем объектам
 * @private
 */
map.controls.BufferZoneControl.prototype.handleBufferClick_ = function (type, withCtrl) {
	var that = this;
	this.setVisible_(false);
	WidgetMap.bufferZoneChooserControl.changeBufferType(type);
	$('#bufferZoneDiv').remove();
	if (type === 'all') {
		var currDialog = $('#addBufferLayersTreeDialog');
		if (currDialog.length == 0) {
			$('body').append('<div id="addBufferLayersTreeDialog" style="overflow: hidden"></div>');
			$('#addBufferLayersTreeDialog').hide();
			currDialog = $('#addBufferLayersTreeDialog');
		}
		//выбираем в окошке слои
		function build() {
			dlg.dialog({
				modal: true,
				title: gis_bufferzonechoosercontrol_5,
				dialogClass: 'gsi-zindex__dialog',
				closeOnEscape: true,
				width: 300,
				height: 360,
				resizable: false,
				create: function() {
					$(this).closest('div.ui-dialog')
						.find('.ui-dialog-titlebar-close')
						.click(function(e) {
							that.closeBufferZoneDialog_();
							e.preventDefault();
						});
				}
			});
			that.setDefaultsLayersTreeControls_();
			that.fillLayersTreeData_();
		}

		var dlg = currDialog;
		dlg.load('ui/html/map/AddBufferFromTreeForm.html', build);

		return;
	}
	if (WidgetMap.mapSelectionLayer.getSource().getFeatures().length == 0) {
		App.confirmDialog(gis_bufferzonechoosercontrol_6, null, {
			title: gis_bufferzonechoosercontrol_7,
			width: 300,
			dialogClass: 'noCloseButton gsi-zindex__dialog'
		});
		return;
	}


	function cancel() {
		dlg.dialog('destroy').remove();
	}

	function create() {
		map.controls.BufferZoneControl.prototype.createBuffer_();
		dlg.dialog('destroy').remove();
	}

	var element = $('<div id="bufferZoneDiv" style="display: block;">\
                        <div class="map-buffer-div" style="margin-top: 3px;"><label class="map-buffer-label">' + gis_bufferzonechoosercontrol_8 + '</label></div>\
                        <div class="map-buffer-div" id="bufferZoneInput"></div>\
                        <div class="map-buffer-div"  style="margin-top: 3px;"><label class="map-buffer-label">' + gis_bufferzonechoosercontrol_13 + '</label></div>\
                      </div>');
	$('body').append(element);

	var buttons = [];
	buttons.push({text: gis_core_12, click: create});
	buttons.push({text: gis_core_6, click: cancel});
	var dlg = $(element).dialog({
		modal: true,
		title: gis_bufferzonechoosercontrol_9,
		dialogClass: 'noCloseButton gsi-zindex__dialog',
		closeOnEscape: true,
		width: 245,
		height: 115,
		resizable: false,
		buttons: buttons
	});

	$('#bufferZoneInput').jqxNumberInput({
		promptChar: "", textAlign: "left", value: 100, inputMode: 'simple',
		decimalDigits: 0, groupSeparator: "", height: 22, width: 60, min: 0, max: 10000, spinButtons: true
	});

};

/**
 * Заполняем html шаблон контролами библиотечными
 * @private
 */
map.controls.BufferZoneControl.prototype.setDefaultsLayersTreeControls_ = function () {
	var that = this;
	var source = {
		localdata: [],
		datatype: "array"
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#addBufferLayersTreeGrid").jqxTreeGrid({
		width: 300,
		height: 270,
		source: dataAdapter,
		pageable: false,
		altRows: false,
		columnsResize: false,
		theme: 'gis-blue-treegrid',
		localization: getLocalization('ru'),
		sortable: true,
		icons: function (rowKey, rowData) {
			var level = rowData.level;
			if (level == 0) {
				return "/ui/images/folder_icon.png";
			}
			return false;
		},
		columns: [{text: gis_bufferzonechoosercontrol_10, dataField: 'LayerName', width: 300}]
	})
		.on('rowSelect', function (event) {
			var args = event.args;
			var row = args.row;
			if (goog.isDef(row)) {
				$('#addBufferLayersTreeOk').prop('disabled', false).removeClass('disableButtonState');
			}
			else {
				$('#addBufferLayersTreeOk').prop('disabled', true).addClass('disableButtonState');
			}
		});
	$('#addBufferLayersTreeOk').prop('disabled', true).addClass('disableButtonState');


	//кнопки "Ок", "Отмена"
	$('#addBufferLayersTreeOk').on('click', function () {
		that.okButtonClicked();
		that.closeBufferZoneDialog_();

	});

	$('#addBufferLayersTreeCancel').on('click', function () {
		that.closeBufferZoneDialog_();
	});

};

/**
 * Закрытие окра выбора слоя для буферной зоны
 * @private
 */
map.controls.BufferZoneControl.prototype.closeBufferZoneDialog_ = function(){
	$('#addBufferLayersTreeDialog').remove();
};

map.controls.BufferZoneControl.prototype.okButtonClicked = function () {
	var that = this;
	var selection = $("#addBufferLayersTreeGrid").jqxTreeGrid('getSelection');
	var layerName = '';
	if (selection.length > 0) {
		layerName = selection[selection.length - 1].layer;
	}
	var layer = WidgetMap.layerManager.getLayerByName(layerName);
	if (goog.isDef(layer) && layer.visible == false) {
		App.confirmDialog(gis_bufferzonechoosercontrol_11, null, {title: gis_core_1});
		return;
	}
	function cancel() {
		dlg.dialog('destroy').remove();
	}

	function create() {
		map.controls.BufferZoneControl.prototype.createAllBuffer_(layerName);
		dlg.dialog('destroy').remove();
	}

	var element = $('<div id="bufferZoneDiv" style="display: block;">\
                        <div class="map-buffer-div" style="margin-top: 3px;"><label class="map-buffer-label">' + gis_bufferzonechoosercontrol_8 + '</label></div>\
                        <div class="map-buffer-div" id="bufferZoneInput"></div>\
                        <div class="map-buffer-div"  style="margin-top: 3px;"><label class="map-buffer-label">' + gis_bufferzonechoosercontrol_13 + '</label></div>\
                      </div>');
	$('body').append(element);

	var buttons = [];
	buttons.push({text: gis_core_12, click: create});
	buttons.push({text: gis_core_6, click: cancel});
	var dlg = $(element).dialog({
		modal: true,
		title: gis_bufferzonechoosercontrol_9,
		dialogClass: 'noCloseButton gsi-zindex__dialog',
		closeOnEscape: true,
		width: 245,
		height: 115,
		resizable: false,
		buttons: buttons
	});

	$('#bufferZoneInput').jqxNumberInput({
		promptChar: "", textAlign: "left", value: 100, inputMode: 'simple',
		decimalDigits: 0, groupSeparator: "", height: 22, width: 60, min: 0, max: 10000, spinButtons: true
	});
};

/**
 * Заполняем дерево списком слоёв
 * @private
 */
map.controls.BufferZoneControl.prototype.fillLayersTreeData_ = function () {
	var layers = WidgetMap.layerManager.getAllSortedVectorLayers();
	var treeGridLayers = [];
	var i = 0;
	for (i; i < layers.length; i++) {
		var obj = {
			LayerId: i,
			LayerName: layers[i].layer.sourceDescr,
			MapName: layers[i].layer.mapName,
			layer: layers[i].layer.name
		};
		if (layers[i].layerQueryId != 'COSMETIC_Layers.xml')
			treeGridLayers.push(obj);
	}
	var source = {
		dataType: "array",
		dataFields: [
			{name: 'LayerID', type: 'number'},
			{name: 'LayerName', type: 'string'},
			{name: 'MapName', type: 'string'},
			{name: 'layer', type: 'string'}
		],
		hierarchy: {groupingDataFields: [{name: "MapName"}]},
		id: 'LayerID',
		localData: treeGridLayers
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#addBufferLayersTreeGrid").jqxTreeGrid({source: dataAdapter});

};


/**
 * Создание буферной зоны для выбранного объекта
 **/
map.controls.BufferZoneControl.prototype.createBuffer_ = function () {
	var that = this;
	var stubGeo = '';//POINT(881208.9362265598 6275263.916475014)'; //POINT(5765748.976529075 8017582.229152669)';
	this.zone = 'EPSG:32639';

	var format = new ol.format.WKT();
	var tempFeatures = [];
	for (var t = 0; t < WidgetMap.mapSelectionLayer.getSource().getFeatures().length; t++) {
		var tF = WidgetMap.mapSelectionLayer.getSource().getFeatures()[t].clone();
		//если фича состоит из мультиобъектов, то делим её на примитивы(в рамках обработки @ из gdal)
		//преобразуем проекцию
		this.zone = this.getFeatureZone_(tF);
		GeoUtil.convertFeature326NN(tF, WidgetMap.DEFAULT_PROJECTION, this.zone);
		//GeoUtil.convertFeature(tF, WidgetMap.DEFAULT_PROJECTION, GeoUtil.PROJS.WGS84);
		tempFeatures.push(tF);
	}
	var buffer = $('#bufferZoneInput').jqxNumberInput('val');

	//TODO реализовать выбор режима, в котором выбрали либо групповой буфер, либо по кажждому отдельно
	if(tempFeatures.length === 1){
		stubGeo = format.writeFeatures(tempFeatures);
		getLayerGeoRequest(buffer, stubGeo);
	}
	else{
		this.showModeForm_(function(type){
			if(type === 'group'){
				stubGeo = format.writeFeatures(tempFeatures);
				getLayerGeoRequest(buffer, stubGeo);
			}
			else{
				tempFeatures.forEach(function (it, index) {
					//добавить проверку на обработку объектов сложной топологии через @
					stubGeo = format.writeFeatures([it]);
					getLayerGeoRequest(buffer, stubGeo);
				});
			}
		});
	}

	function getLayerGeoRequest(bufferSize, geo) {
		App.serverQueryNodeWithTries(Services.bufferZoneNode, {bufferWidth: bufferSize, wktGeometry: geo, zone: that.zone}, function getBufferGeoResult(resultXml) {
			try { // Иногда ответ в формате XML, а иногда в виде просто строки
				format = new ol.format.WKT();
				var wktBuffer = resultXml.find('string').text();
				var feature = format.readFeature(wktBuffer);
				GeoUtil.convertFeature326NN(feature, that.zone, WidgetMap.DEFAULT_PROJECTION);
				//GeoUtil.convertFeature(feature, GeoUtil.PROJS.WGS84, WidgetMap.DEFAULT_PROJECTION);
				var layer = WidgetMap.layerManager.getLayerByName('BUFFER_OBJECT');
				if (goog.isDef(layer) && goog.isDef(layer.layer)) {
					var fId = 0;//(layer.layer.featureProjLayer.getSource().getSource().getFeatures().length+1);
					if (goog.isDef(globalPolygonsLabels_['BUFFER_OBJECT']))
						fId = globalPolygonsLabels_['BUFFER_OBJECT'].length;
					//разделить мультиобъект
					var fGeo = feature.getGeometry();
					if(goog.isDef(fGeo) && fGeo.getType() == ol.geom.GeometryType.MULTI_POLYGON){
						var endss = fGeo.getEndss().length;
						for(var i=0; i<endss; i++){
							var gm = new ol.geom.Polygon(null);
							var linearRing = new ol.geom.LinearRing(null);
							linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY,fGeo.getPolygon(i).clone().flatCoordinates);
							gm.appendLinearRing(linearRing);
							layer.layer.addGeometry(new ol.Feature(gm), ''+fId, undefined);
							fId++;
						}
					}
					else
						layer.layer.addGeometry(feature, ''+fId, undefined);
				}
				WidgetMap.map.render();
			}
			catch (ex) {
				App.errorReport(map.controls.LOAD_BUFFER_ZONE_ERROR, resultXml, undefined, {filename:gis_filename_436, functionname:'gis_filename_436_2'});
			}
		}, function getBufferGeoFault(resultXml) {
			App.errorReport(map.controls.LOAD_BUFFER_ZONE_ERROR, resultXml, undefined, {filename:gis_filename_436, functionname:'gis_filename_436_3'});
		},4);
	}
};

/**
 * Создание буверных зон для всех объектов слоя
 **/
map.controls.BufferZoneControl.prototype.createAllBuffer_ = function (layerName) {
	var that = this;
	var stubGeo = '';//POINT(881208.9362265598 6275263.916475014)'; //POINT(5765748.976529075 8017582.229152669)';
	var stubGeoArr = [];
	this.zone = 'EPSG:32639';
	function getLayerGeoRequest(bufferSize, geoObj) {
		BlockingUtil.wait();
		App.serverQueryNodeWithTries(Services.bufferZoneNode, {bufferWidth: bufferSize, wktGeometry: geoObj.geo, zone: geoObj.zone}, getBufferGeoResult, getBufferGeoFault,4);
		function getBufferGeoResult(resultXml) {
			try { // Иногда ответ в формате XML, а иногда в виде просто строки
				format = new ol.format.WKT();
				var wktBuffer = resultXml.find('string').text();
				var feature = format.readFeature(wktBuffer);
				GeoUtil.convertFeature326NN(feature, geoObj.zone, WidgetMap.DEFAULT_PROJECTION);
				//GeoUtil.convertFeature(feature, GeoUtil.PROJS.WGS84, WidgetMap.DEFAULT_PROJECTION);
				var layer = WidgetMap.layerManager.getLayerByName('BUFFER_OBJECT');
				if (goog.isDef(layer) && goog.isDef(layer.layer)) {
					var fId = '0';//(layer.layer.featureProjLayer.getSource().getSource().getFeatures().length+1);
					if (goog.isDef(globalPolygonsLabels_['BUFFER_OBJECT']))
						fId = '' + globalPolygonsLabels_['BUFFER_OBJECT'].length;
					layer.layer.addGeometry(feature, fId, undefined);
				}
			}
			catch (ex) {
				//App.errorReport(map.controls.LOAD_BUFFER_ZONE_ERROR,resultXml);
			}
			finally {
				BlockingUtil.ready();
				stubGeoArr.splice(0, 1);
				if (stubGeoArr.length > 0)
					getLayerGeoRequest(buffer, stubGeoArr[0]);
				else {
					App.confirmDialog(gis_bufferzonechoosercontrol_16, null, {title: gis_core_1});
					WidgetMap.map.render();
				}

			}
		}

		function getBufferGeoFault(resultXml) {
			BlockingUtil.ready();
			//App.errorReport(map.controls.LOAD_BUFFER_ZONE_ERROR,resultXml);
		}
	}

	//получаем название слоя
	var layer = WidgetMap.layerManager.getLayerByName(layerName);
	if (goog.isDef(layer)) {
		if (layer.visible == false) {
			App.confirmDialog(gis_bufferzonechoosercontrol_17, null, {title: gis_core_1});
			return;
		}

		var format = new ol.format.WKT();
		var buffer = $('#bufferZoneInput').jqxNumberInput('val');
		var features = layer.layer.featureProjLayer.getSource().getSource().getFeatures();
		for (var i = 0; i < features.length; i++) {
			var objs = features[i].get('pointsObjAll');
			for (var j in objs) {
				var tF = objs[j].clone();
				//преобразуем проекцию
				try {
					this.zone = this.getGeometryZone_(tF);
					GeoUtil.convertGeometry(tF, WidgetMap.DEFAULT_PROJECTION, this.zone);
					//GeoUtil.convertGeometry(tF, WidgetMap.DEFAULT_PROJECTION, GeoUtil.PROJS.WGS84);
					//stubGeoArr.push({zone: this.zone, geo: format.writeGeometry(tF)});
					stubGeoArr.push({geo: format.writeGeometry(tF), zone: this.zone});
				}
				catch (ex) {
				}

			}
		}
	}
	if (stubGeoArr.length > 0)
		getLayerGeoRequest(buffer, stubGeoArr[0]);
};

/**
 * Получение зоны для фичи по центру её экстента
 *
 * @param feature
 * @private
 */
map.controls.BufferZoneControl.prototype.getFeatureZone_ = function (feature) {
	//забираем экстент, находим его центр и смотрим, в какую зону он попадает
	var featureExtent = feature.getGeometry().getExtent();
	var center = ol.extent.getCenter(featureExtent);
	//преобразуем в wgs
	var dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
	var source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
	var pnt = new proj4.toPoint([center[0], center[1]]);
	proj4.transform(source_, dest_, pnt);
	var centerExtent = [pnt.x, pnt.y, pnt.x, pnt.y];
	for (var i in map.controls.bufferZonesBounds) {
		if (ol.extent.intersects(centerExtent, map.controls.bufferZonesBounds[i]))
			return i;
	}
	return "EPSG:32634";
};

map.controls.BufferZoneControl.prototype.getGeometryZone_ = function (geometry) {
	//забираем экстент, находим его центр и смотрим, в какую зону он попадает
	var featureExtent = geometry.getExtent();
	var center = ol.extent.getCenter(featureExtent);
	//преобразуем в wgs
	var dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
	var source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
	var pnt = new proj4.toPoint([center[0], center[1]]);
	proj4.transform(source_, dest_, pnt);
	var centerExtent = [pnt.x, pnt.y, pnt.x, pnt.y];
	for (var i in map.controls.bufferZonesBounds) {
		if (ol.extent.intersects(centerExtent, map.controls.bufferZonesBounds[i]))
			return i;
	}
	return "EPSG:32634";
};


/**
 * Форма выбора режима построения группового буфера. сводный контур или по отдельности
 *
 * @param opt_options
 * @private
 */
map.controls.BufferZoneControl.prototype.showModeForm_ = function (callback) {
	var that  = this;
	var currDialog = $('#groupBufferFormDialog');
	if (currDialog.length == 0) {
		$('body').append('<div id="groupBufferFormDialog" style="overflow: hidden"></div>');
		$('#groupBufferFormDialog').hide();
		currDialog = $('#groupBufferFormDialog');
	}
	var dlg = currDialog;
	dlg.load('ui/html/map/GroupBufferForm.html', build);
	function build() {
		dlg.dialog({
			modal: true,
			title: gis_bufferzonechoosercontrol_18,
			dialogClass: 'noCloseButton gsi-zindex__dialog',
			closeOnEscape: false,
			width: 350,
			height: 155,
			resizable: false,
		});
		that.setDefaultControls_(callback);
	}
}

/**
 * Заполняем html шаблон контролами библиотечными
 * @private
 */
map.controls.BufferZoneControl.prototype.setDefaultControls_ = function (callback) {
	var that = this;
	$("#groupBuffer").jqxRadioButton({width: 20, checked: true}).css('display', 'inline-block');
	$("#splitBuffer").jqxRadioButton({width: 20, checked: false}).css('display', 'inline-block');
	//кнопки "Ок", "Отмена"
	$('#createGroupBufferOk').on('click', function () {
		if(callback)
			callback($("#groupBuffer").jqxRadioButton('checked')?'group':'split');
		that.closeGroupBufferDialog_();
	});
	$('#createGroupBufferCancel').on('click', function () {
		that.closeGroupBufferDialog_();
	});
};


map.controls.BufferZoneControl.prototype.closeGroupBufferDialog_ = function(){
	$('#groupBufferFormDialog').remove();
};
goog.provide('map.controls.EditStyleControl');


/**
 * Контрол для редактирования стилей объектов на карте
 * @constructor
 */
map.controls.EditStyleControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	var className = goog.isDef(options.className) ?
		options.className : 'map-editstyle';

	var tooltip = goog.isDef(options.tooltip) ?
		options.tooltip : gis_editstylecontrol_1;
	var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className+'-button',
		'type' : 'button',
		'title' : tooltip
	});
	innerElement.style.display = 'inline';

	goog.events.listen(innerElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.EditStyleControl.prototype.handleEditStyleClick_), false, this);

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;

	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);

	goog.base(this, {
		element: element,
		target: options.target
	});
};

goog.inherits(map.controls.EditStyleControl, ol.control.Control);



/**
 * Реация на нажатие кнопок редактиварония стиля
 * @private
 */
map.controls.EditStyleControl.prototype.handleEditStyleClick_ = function() {
	alert(gis_editstylecontrol_2);

};

goog.provide('map.controls.ClearCosmeticV7Control');
/**
 * Контрол для отчистки косметического слоя (Версия 7.7.0)
 * @constructor
 */
map.controls.ClearCosmeticV7Control = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    goog.base(this, {
        target: options.target,
        noElement: options.noElement
    });

};
goog.inherits(map.controls.ClearCosmeticV7Control, map.controls.ClearCosmeticControl);


/**
 * Реация на нажатие кнопки "Очистить косметический слой"
 * @private
 */
map.controls.ClearCosmeticV7Control.prototype.handleCosmeticClick_ = function() {
    BlockingUtil.wait();
    try{
        var cosmeticLayer = WidgetMap.layerManager.getLayerByName('COSMETIC_OBJECT');
        if(goog.isDef(cosmeticLayer) && goog.isDef(cosmeticLayer.layer)){
            cosmeticLayer.layer.featureProjLayer.getSource().getSource().clear();
        }
        var bufferLayer = WidgetMap.layerManager.getLayerByName('BUFFER_OBJECT')
        if(goog.isDef(bufferLayer) && goog.isDef(bufferLayer.layer)){
            bufferLayer.layer.featureProjLayer.getSource().getSource().clear();
        }
        if(goog.isDefAndNotNull(WidgetMap.currentVectorLayer))
            WidgetMap.currentVectorLayer.getSource().clear();

        MapUtil.clearSelectionLayer();
        if(WidgetMap.findRoute !== undefined)
            WidgetMap.findRoute.reset();
        if(goog.isDefAndNotNull(WidgetMap.bufferLayer))
            WidgetMap.bufferLayer.getSource().clear();
        if(goog.isDefAndNotNull(WidgetMap.pipeLengthLayer))
            WidgetMap.pipeLengthLayer.getSource().clear();
        //удалить interaction и выставить ладошку
        WidgetMap.infoControl.handleMapInfoClick_();
    }
    catch(ex){

    }
    finally{
        //обнуляем массив подписей, который прятали при выделении объектов
        if (goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0) {
            WidgetMap.map.render();
            WidgetMap.hideLabelsArr = [];
        }
        BlockingUtil.ready();
    }
};
goog.provide('map.controls.LayersControl');
/**
 * Контрол управления подложками и векторными слоями
 * @constructor
 */
map.controls.LayersControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    //базовые слои подложки
    this.baseLayers = goog.isDef(options.baseLayers) ?
        options.baseLayers : [];

    this.vectorLayers = goog.isDef(options.vectorLayers) ?
        options.vectorLayers : [];

    var className = goog.isDef(options.className) ?
        options.className : 'map-layers';

    this.cosmeticLayerId = 'COSMETIC_GROUP';

    //режим отображения данных
	this.mode = 'vector';
    //превью подложки
    var previewLayerImg = goog.dom.createDom(goog.dom.TagName.IMG, {
        className : 'map-layers-img'
    });

    //текст выбранной подложки
    var layerNameDiv = goog.dom.createDom(goog.dom.TagName.LABEL, {
        className : 'map-layers-label'
    },null, 'Карта');

    this.fillData();

    this.newMaxZoom = -1;

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, previewLayerImg, layerNameDiv);

    goog.events.listen(element,
        goog.events.EventType.CLICK, map.controls.LayersControl.prototype.handleClick_, false, this);


    goog.base(this, {
        element: element,
        target: options.target
    });
};
goog.inherits(map.controls.LayersControl, ol.control.Control);

/**
 * Заполнение данными
 * @private
 */
map.controls.LayersControl.prototype.fillData = function () {
	//разделение по группам:
	//1. Косметический слой
	//2. Векторные слои 1
	//3. Растровая карта трубопроводов pods_equip
	//4. растровая подложка
	$('body').append('<div class="map-layers-before collapsed"><div class="map-layers-main-list collapsed">' +
			'<div class="map-layers-vector-list-container"></div>' +
			'<div class="map-layers-raster-list-container"></div>' +
		'</div></div>');
	//добавляем обработку клика для закрытия окна управления слоями
	$('#map').click(function (event) {
		try{
			if(WidgetMap.baseLayersControl){
				WidgetMap.baseLayersControl.close();
			}

			/*if(WidgetMap.measureChooserControl)
				WidgetMap.measureChooserControl.close();
			if(WidgetMap.shareChoose)
				WidgetMap.shareChoose.close();
			if(WidgetMap.exportImageChooserControl)
				WidgetMap.exportImageChooserControl.close();
			if(WidgetMap.viewMapChoose)
				WidgetMap.viewMapChoose.close();*/
		}
		catch(ex){

		}
	});
	$('.map-layers-before').click(function (e) {
		e.stopPropagation();
	});
	this.fillVector_();
	this.fillRaster_();
};

map.controls.LayersControl.prototype.toggleClick_ = function (event) {
	var closed = 'closed';
	var className = '.'+this.className;
	var listClassName = className.replace('header','list');
	var element = $(this).find('.map-layers-toggle');
	$(element).toggleClass(closed);
	var css = $(listClassName).css('display');
	if(css === 'block') $(listClassName).hide();
	else $(listClassName).show();
};

map.controls.LayersControl.prototype.handleClick_ = function () {
    //открываем список с подложками и векторными слоями
	$('.map-layers-main-list, .map-layers-before').toggleClass('collapsed');
	//$('.map-layers-before').toggleClass('collapsed');
};

map.controls.LayersControl.prototype.close = function () {
	$('.map-layers-main-list, .map-layers-before').addClass('collapsed');
};

/**
 * Заполняем грид данными
 * @private
 */
map.controls.LayersControl.prototype.fillVector_ = function() {
	//1. Косметический слой
	//2. Векторные слои 1
	var headerVector = '<div class="map-layers-vector-header">' +
		'<div class="map-layers-toggle"></div>' +
		'<label class="map-layers-toggle-label">'+gis_layerscontrol_2+'</label></div>';
	$('.map-layers-vector-list-container')
		.append('<div class="map-layers-cosmetic-list"></div>')
		.append(headerVector).append('<div class="map-layers-vector-list"></div>');
	$('.map-layers-vector-header').click(this.toggleClick_);
};

/**
 * Создание элемента списка для векторных и растровых слоёв
 * @param item
 * @param isRaster
 * @returns {string}
 * @private
 */
map.controls.LayersControl.prototype.createLIItem_= function(item, isRaster) {
	if(isRaster)
		return '<li><div class="bl-wrapper" data-id="' + item.id + '">' +
			'    <div class="bl-layer">' +
			'        <div>' +
			'            <span data-id="' + item.id + '" class="toggle-checkbox bl-checkbox-raster ' + ((item.visible) ? 'checked' : '') + '" ></span>' +
			'            <span class="bl-img" style="background:url(' + item.icon + ') center no-repeat;"></span>' +
			'            <span class="bl-descr "title="'+item.descr+'">' + item.descr + '</span>' +
			'        </div>' +
			'        <div class="bl-opacity-wraper" data-id="' + item.id + '">' +
			'            <span class="bl-opacity-value" title="'+gis_layerscontrol_6+'" data-default="'+item.opacity.toFixed(2)+'">' + item.opacity.toFixed(2) * 100 + '%</span>' +
			'            <span class="bl-opacity" title="'+gis_layerscontrol_6+'" ></span>' +
			'            <div class="bl-opacity-menu layer-dropdown-menu" role="menu">' +
			'                0<div class="bl-opacity-slider"></div>100' +
			'        </div>' +
			'    </div>' +
			'</div>' +
			'</li>';
	var styleSpan = (item.buttons.styleButton)?'<span class="edit-style-button"  title="'+gis_layerscontrol_9+'" data-id="' + item.id + '" />':'';
	var allowTextSpan = (item.buttons.allowTextButton)?'<span class="allow-text-button '+(item.allowText?'checked':'')+'"  title="'+gis_layerscontrol_10+'" data-id="' + item.id + '" />':'';
	var forceLoadGeo =  (item.buttons.forceLoadGeo)?'<span class="force-load-button"  title="'+gis_layerscontrol_11+'" data-id="' + item.id + '" />':'';

	var buttonWrapper =
		'<div class="bl-buttons-wraper" data-id="' + item.id + '">' +
		'        <span class="bl-buttons" title="'+gis_layerscontrol_8+'"></span>' +
		'        <div class="bl-buttons-menu layer-dropdown-menu">' +
		'            <div class="bl-buttons-slider">'+styleSpan+allowTextSpan+forceLoadGeo+'</div>' +
		'    </div>';
	if(item.id === this.cosmeticLayerId){//для косметики убираем кнопки
		return '<li data-canraster="'+item.layerQueryId+'"><div class="bl-wrapper" data-id="' + item.id + '">' +
			'    <div class="bl-layer">' +
			'        <div>' +
			'            <span data-id="' + item.id + '" class="toggle-checkbox bl-checkbox-vector ' + ((item.visible) ? 'checked' : '') + '" ></span>' +
			'            <span class="bl-img bl-cosmetic" ></span>' +
			'            <span class="bl-descr " title="'+item.descr+'">' + item.descr + '</span>' +
			'        </div>' +
			'    </div>' +
				buttonWrapper +
			'</div>' +
			'</li>';
	}
	var icon = '';
	//векторные слои
	if(item.icon !== undefined)
		icon='background-image:url('+item.icon+');';
	return '<li data-canraster="'+item.layerQueryId+'"><div class="bl-wrapper" data-id="' + item.id + '">' +
		'    <div class="bl-layer">' +
		'        <div>' +
		'            <span data-id="' + item.id + '" class="toggle-checkbox bl-checkbox-vector ' + ((item.visible) ? 'checked' : '') + '" ></span>' +
		'            <span class="bl-img bl-default-img" style="'+icon+'"></span>' +
		'            <span class="bl-descr " title="'+item.descr+'">' + item.descr + '</span>' +
		'        </div>' +
		'    </div>' +
			 buttonWrapper +
		'</div>' +
		'</li>';
};

/**
 * Заполняем контрол данными подложек
 * @private
 */
map.controls.LayersControl.prototype.fillRaster_= function() {
	//3. Растровая карта трубопроводов pods_equip
	//4. Растровая подложка. Наборы слоев из *_rasterlayers.json
	var that = this;
	if(jQuery.isEmptyObject(that.baseLayers))// если пустой объект и нет растровых слоёв не рисуем растр в контроле
		return;
	//составляем блок "подложки карты"
	var mode = MapUtil.getAvailableMapMode(WidgetMap.CURRENT_MODE)
	if(mode === WidgetMap.MODES.VECTOR){
		var item = {
			id:'RouteTiles', visible:WidgetMap.CURRENT_MODE === WidgetMap.MODES.RASTER, descr: gis_layerscontrol_4,
			icon:'./Public/assets/UMBILICAL.png', opacity: 1,
			buttons:{styleButton:false,allowTextButton:false}
		};

		var result = '<ul class="bl-list bl-sortable">';
		result += this.createLIItem_(item,true);
		result += '</ul>';
		$('.map-layers-raster-list-container')
			.append('<div class="map-layers-rastermixed-list"></div>')
		$('.map-layers-rastermixed-list').append(result);
	}

	for(var index in this.baseLayers){
		var item = this.baseLayers[index];
		if(item.mode === WidgetMap.MODES.RASTER)
			continue;
		var header = '<div class="map-layers-raster-header">' +
			'<div class="map-layers-toggle"></div>' +
			'<label class="map-layers-toggle-label">'+((item.descr !== '')?item.descr:gis_layerscontrol_5)+'</label></div>';

		$('.map-layers-raster-list-container').append(header);
		$('.map-layers-raster-header').click(this.toggleClick_);
		var result = '<div class="map-layers-raster-list"><ul class="bl-list bl-sortable">';
		//сортируем слои снизу вверх, как на карте
		var layers = item.baselayerscontrolarray.reverse();
		for (var i = 0; i < layers.length; i++) {
			var item = layers[i];
			result += this.createLIItem_(item, true);
			
			if (item.visible && item.error !== '')
				App.errorReport(gis_core_17, item.error + gis_core_19, undefined, {filename:gis_filename_485, functionname:'gis_filename_485_2'});
		}
		result += '</ul></div>';
		$('.map-layers-raster-list-container').append(result);
		$('.bl-sortable').sortable({
			axis: 'y',
			cursor: "n-resize",
			helper: "clone",
			distance: 10,
			placeholder: "ui-state-highlight",
			stop: function(evt, ui) {
				var item = ui.item.find('.bl-wrapper');
				that.rearrangeRaster($(item).data('id'),ui.item.index());
			}
		});
		$('.bl-sortable').disableSelection();

		$('.bl-checkbox-raster').on('click', function(event){
			//удаляем с карты слой wms
			if(WidgetMap){
				if(WidgetMap.viewMap)
					WidgetMap.viewMap.removeRosLayer();
				WidgetMap.isBaseLayerRosreestr = false;
			}
			$(this).toggleClass('checked');

			if($(this).hasClass('checked') && !WidgetMap.defaultDisablePrint){
				var internetSrcDisable = (goog.isDef(App.config.INTERNET_SRC_DISABLE) && App.config.INTERNET_SRC_DISABLE.length > 0)?App.config.INTERNET_SRC_DISABLE:'';
				var internetSrcDisableSplit = internetSrcDisable.split(',');
				if(internetSrcDisableSplit.indexOf($(this).data('id')) != -1){
					WidgetMap.defaultDisablePrint = true;
					if(WidgetMap.exportImageChooserControl !== undefined)
						WidgetMap.exportImageChooserControl.disableButtons();
				}

			}
			that.setVisible($(this).data('id'), $(this).hasClass('checked'));
		});

		$('.bl-layer').find('.bl-opacity-slider').each(function(el){
			var value = parseFloat($(this).parent().parent().find('.bl-opacity-value').first().data('default'));
			$(this).slider({
				range: false,
				min: 0,
				max: 100,
				step: 10,
				value: 100 * value ,
				slide: that.setOpacity
			})
		});

		$('.bl-opacity').on('click', function(event){
			var isVisible = $(this).parent().find('.layer-dropdown-menu').first().is(":visible");
			$('.layer-dropdown-menu').hide();
			if(!isVisible) $(this).parent().find('.layer-dropdown-menu').first().show();
		});

		$('.bl-opacity-wraper').on('click', function(e){
			e.stopPropagation();
		});
		$('body').on('click', function(e){
			$('.layer-dropdown-menu').hide();
		});
	}
};

/**
 * Устанавливаем в грид список с векторными слоями
 */
map.controls.LayersControl.prototype.setVectorLayers = function(){
	var that = this;
	if(goog.isDef(WidgetMap.layerManager)){
		//var layers = WidgetMap.layerManager.getAllSortedVectorLayers();
		var layers = WidgetMap.layerManager.getAllSortedVectorLayersWOMode();

		if(layers.length === 0) return;
		//получаем отсортированный массив
		var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
		var layers = tLayers.getArray();

		var vectorLayers = [];
		//разделяем
		for(var i=0; i < layers.length; i++){
			var layer = WidgetMap.layerManager.getLayerByName(layers[i].get('id'));
			if(goog.isDef(layer) && goog.isDef(layer.layer)){
				if(layer.layerQueryId === 'COSMETIC_Layers.xml')
					continue;
				else{
					var vectorIcon = '';
					vectorIcon = layer.layer.getIcon();
					vectorLayers.push({
						id:layer.id, visible:layer.visible, descr: layer.layer.sourceDescr,
						icon:vectorIcon, allowText:layer.isTextAllow,
						layerQueryId:layer.layerQueryId,
						buttons:{styleButton:true,allowTextButton:true, forceLoadGeo: true}
					});
				}

			}

		}
		vectorLayers = vectorLayers.reverse();
		//общий косметический слой для всей косметики из cosmetic_layers.xml
		var result = '<ul class="bl-vector-list bl-sortable-vector">';
		var item = {
			id: this.cosmeticLayerId, visible:true, descr: gis_layerscontrol_7,
			icon:'./Public/assets/UMBILICAL.png', allowText:true,
			buttons:{styleButton:true,allowTextButton:true}
		};
		result += this.createLIItem_(item, false);
		result += '</ul>';
		$('.map-layers-cosmetic-list').append(result);

		result = '<ul class="bl-vector-list bl-sortable-vector">';
		for (var i = 0; i < vectorLayers.length; i++) {
			var item = vectorLayers[i];
			result += this.createLIItem_(item, false);
		}
		result += '</ul>';
		$('.map-layers-vector-list').append(result);

		$('.bl-sortable-vector').sortable({
			axis: 'y',
			cursor: "n-resize",
			helper: "clone",
			distance: 10,
			placeholder: "ui-state-highlight",
			cancel: "li-disabled",
			stop: function(evt, ui) {
				var item = ui.item.find('.bl-wrapper');
				that.rearrangeVector($(item).data('id'),ui.item.index());
			}
		});
		$('.bl-sortable-vector').disableSelection();

		$('.bl-checkbox-vector').on('click', function(event){
			var layerId =  $(this).data('id');
			if($(this).hasClass('li-disabled')) return;
			$(this).toggleClass('checked');
			if(layerId === that.cosmeticLayerId)
				that.setVisibleCosmeticVector(layerId, $(this).hasClass('checked'));
			else
				that.setVisibleVector(layerId, $(this).hasClass('checked'));
		});

		$('.edit-style-button').on('click', function(event){
			var layerId =  $(this).data('id');
			if($(this).hasClass('li-disabled')) return;
			if(layerId === that.cosmeticLayerId)
				that.editCosmeticLayerStyle();
			else
				that.editVectorLayerStyle(layerId);
		});
		$('.allow-text-button').on('click', function(event){
			var layerId =  $(this).data('id');
			$(this).toggleClass('checked');
			if(layerId === that.cosmeticLayerId)
				that.editCosmeticLayerText();
			else
				that.allowVectorLayerText(layerId);
		});
		$('.force-load-button').on('click', function(event){
			var layerId =  $(this).data('id');
			$(this).toggleClass('checked');
			that.forceLoadLayerGeoDataWoCache(layerId);
		});

		$('.bl-buttons').on('click', function(event){
			var isVisible = $(this).parent().find('.layer-dropdown-menu').first().is(":visible");
			$('.layer-dropdown-menu').hide();
			if(!isVisible) $(this).parent().find('.layer-dropdown-menu').first().show();
		});

		$('.bl-buttons-wraper').on('click', function(e){
			e.stopPropagation();
		});
		$('body').on('click', function(e){
			$('.layer-dropdown-menu').hide();
		});
		var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
		if(WidgetMap.CURRENT_MODE === WidgetMap.MODES.RASTER && mapConfig.block_raster_pipe_mode !== true){
			this.setVisible('RouteTiles',true);
		}
	}
};

/**
 * вкл/откл видимости слоя
 * @param layerId
 * @param visible
 */
map.controls.LayersControl.prototype.setVisibleCosmeticVector = function(layerId, visible) {
	var that = this;
	if(!goog.isDef(layerId)) return;
	var cosmeticIds = WidgetMap.layerManager.getCosmeticIds();
	var layers = WidgetMap.currentVectorGroupLayer.getLayers();//of ol.Group
	if(layerId === that.cosmeticLayerId) //группа косметических слоёв
	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function(layer) {

			if(goog.isDef(layer.get('id')) && cosmeticIds.indexOf(layer.get('id')) != -1 ){
				var layerObj = WidgetMap.layerManager.getLayerByName(cosmeticIds[cosmeticIds.indexOf(layer.get('id'))]);
				if(goog.isDef(layerObj) && goog.isDef(layerObj.layer)){
					if(visible){
						if(goog.isDef(layerObj.layer.setVisible)){//если слой векторный
							WidgetMap.layerManager.enableLayer(layerId);
							layerObj.layer.setVisible(true);
						}
						else layerObj.visible = true;
					}
					else{
						if(goog.isDef(layerObj.layer.setVisible)) {
							WidgetMap.layerManager.disableLayer(layerId);
							layerObj.layer.setVisible(false);
						}
						else layerObj.visible = false;
					}
				}
			}

		}, this);
};

/**
 * вкл/откл видимости слоя
 * @param layerId
 * @param visible
 */
map.controls.LayersControl.prototype.setVisibleVector1 = function(layerId, visible) {
	if(!goog.isDef(layerId)) return;
	var layers = WidgetMap.currentVectorGroupLayer.getLayers();//of ol.Group
	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function(layer) {
			if(goog.isDef(layer.get('id')) && layer.get('id') === layerId ){
				//layer.setVisible(visible);  уже вызывается в layerObj.layer.setVisible
				var layerObj = WidgetMap.layerManager.getLayerByName(layerId);
				if(goog.isDef(layerObj) && goog.isDef(layerObj.layer)){
					if(visible){
						if(goog.isDef(layerObj.layer.setVisible)){//если слой векторный
							WidgetMap.layerManager.enableLayer(layerId);
							layerObj.layer.setVisible(true);
						}
						else layerObj.visible = true;
					}
					else{
						if(goog.isDef(layerObj.layer.setVisible)) {
							WidgetMap.layerManager.disableLayer(layerId);
							layerObj.layer.setVisible(false);
						}
						else layerObj.visible = false;
					}
				}
			}

		}, this);
};


/**
 * вкл/откл видимости слоя
 * @param layerId
 * @param visible
 */
map.controls.LayersControl.prototype.setVisibleVector = function(layerId, visible) {
	if(!goog.isDef(layerId))
		return;
	var layers = WidgetMap.currentVectorGroupLayer.getLayers();//of ol.Group
	if(layerId === 'COSMETIC_GROUP') //группа косметических слоёв
		layers.forEach(//ol.Collection
			/**
			 * @param {ol.layer.Layer} layer Layer.
			 */
			function(layer) {
				var layerObj = WidgetMap.layerManager.getLayerByName(layerId);
				if(goog.isDef(layer.get('id')) && layer.get('id') === layerId ){
					//layer.setVisible(visible);  уже вызывается в layerObj.layer.setVisible
					if(goog.isDef(layerObj) && goog.isDef(layerObj.layer)){
						if(visible){
							if(goog.isDef(layerObj.layer.setVisible)){//если слой векторный
								WidgetMap.layerManager.enableLayer(layerId);
								layerObj.layer.setVisible(true);
							}
							else layerObj.visible = true;
						}
						else{
							if(goog.isDef(layerObj.layer.setVisible)) {
								WidgetMap.layerManager.disableLayer(layerId);
								layerObj.layer.setVisible(false);
							}
							else layerObj.visible = false;
						}
					}
				}

			}, this);
	else
		layers.forEach(//ol.Collection
			/**
			 * @param {ol.layer.Layer} layer Layer.
			 */
			function(layer) {
				if(goog.isDef(layer.get('id')) && layer.get('id') === layerId ){
					//layer.setVisible(visible);  уже вызывается в layerObj.layer.setVisible
					var layerObj = WidgetMap.layerManager.getLayerByName(layerId);
					if(goog.isDef(layerObj) && goog.isDef(layerObj.layer)){
						if(visible){
							if(goog.isDef(layerObj.layer.setVisible)){//если слой векторный
								WidgetMap.layerManager.enableLayer(layerId);
								layerObj.layer.setVisible(true);
							}
							else layerObj.visible = true;
						}
						else{
							if(goog.isDef(layerObj.layer.setVisible)) {
								WidgetMap.layerManager.disableLayer(layerId);
								layerObj.layer.setVisible(false);
							}
							else layerObj.visible = false;
						}
					}
				}

			}, this);
};

/**
 * Меняем режим раст/вектор
 * @param visible
 */
map.controls.LayersControl.prototype.setVisibleMixed = function(visible) {
	//блокируем векторные слои в списке
	$("li[data-canraster='PODS_EQUIP_Layers.xml']").each(function(){
		if(visible)
			$(this).addClass('li-disabled');
		else
			$(this).removeClass('li-disabled');
	});
	this.changeMode(!visible);
	//включаем слой растровый PODS_RASTER
	var layers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group
	var layerId = 'RouteTiles';
	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function(layer) {
			if(goog.isDef(layer.get('id')) && layer.get('id') === layerId )
				layer.setVisible(visible);
		}, this);

};

/**
 * * Смена режима отображения данных
 * @param isVector
 */
map.controls.LayersControl.prototype.changeMode = function (isVector) {
	//проходим по всем векторным слоям, ищем среди них нужную модель по флагу hasRaster и скрываем
	//если рубрикатор видит, что режим растр, то смена видимости игнорируется
	if(WidgetMap === undefined) return;
	WidgetMap.canFirstTimeCentering = false;
	if (!isVector) {
		WidgetMap.CURRENT_MODE = WidgetMap.MODES.RASTER;
		WidgetMap.layerManager.hideVectorLayers(WidgetMap.MULTI_MODE_LAYERS);
	}
	else {
		WidgetMap.CURRENT_MODE = WidgetMap.MODES.VECTOR;
		WidgetMap.layerManager.showVectorLayers(WidgetMap.MULTI_MODE_LAYERS);
	}
};

/**
 * вкл/откл видимости слоя
 * @param layerId
 * @param visible
 */
map.controls.LayersControl.prototype.setVisible = function(layerId, visible) {
	var that = this;

	that.checkError(layerId);
	//TODO убрать зардкод
	var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
	if(layerId === 'RouteTiles' && mapConfig.block_raster_pipe_mode !== true)
		return this.setVisibleMixed(visible);

	if(!goog.isDef(layerId))
		return;
	var layers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group

	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function(layer) {
			if(goog.isDef(layer.get('id')) && layer.get('id') === layerId ){
				layer.setVisible(visible);
				//обновление доступного массива resolutions
				that.changeMapView_();
			}

		}, this);
	that.updateRasterLayers();
};

/**
 * Обновление описаний слоёв растровых для их подгрузки. Используется для получения информации
 */
map.controls.LayersControl.prototype.updateRasterLayers = function(){
	var that = this;
	var layers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group

	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function(layer) {

		}, this);
};
/**
 * Установка прозрачности слоя
 * @param event
 * @param ui
 */
map.controls.LayersControl.prototype.setOpacity = function(event, ui) {
	if($(this).parent().css('display') === 'none') return;
	var opacity = ui.value;
	$(this).parent().parent().find('.bl-opacity-value').first().text(opacity+'%');
	var layerId = $(this).parent().parent().data('id');
	if(!goog.isDef(layerId)) return;
	var layers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group

	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function(layer) {
			if(goog.isDef(layer.get('id')) && layer.get('id') === layerId )
				layer.setOpacity(opacity/100);
		}, this);
};

/**
 * Установка положения слоя
 * @param layerId
 * @param position новая позиция
 */
map.controls.LayersControl.prototype.rearrangeVector = function(layerId, position) {
	var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();//of ol.Group
	//TODO пока косметика на первых трех позициях
	//WidgetMap.currentVectorGroupLayer.setLayers(tLayers);
	//т.к. сортировка в обратном порядке, то
	position = tLayers.getLength()-1-position;
	for(var i = 3; i<tLayers.getLength(); i++){
		var item = tLayers.item(i);
		if(goog.isDef(item.get('id')) && item.get('id') === layerId  && i !== position){
			tLayers.removeAt(i);
			tLayers.insertAt(position, item);
			break;
		}
	}
};

/**
 * Установка положения слоя
 * @param layerId
 * @param position новое положение
 */
map.controls.LayersControl.prototype.rearrangeRaster = function(layerId, position) {
	var layers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group
	//т.к. список в обратном порядке, то инвертирует позицию
	position = layers.getLength()-1-position;
	for(var i = 0; i<layers.getLength(); i++){
		var item = layers.item(i);
		if(goog.isDef(item.get('id')) && item.get('id') === layerId  && i !== position){
			layers.removeAt(i);
			layers.insertAt(position, item);
			break;
		}
	}
};


/**
 * Смена видимости для конкретного слоя
 * @param input чекбокс
 * @param rowKey id ключа
 */
map.controls.LayersControl.prototype.setVectorLayerVisible = function(input, rowKey){
	//устанавливаем значение
	var isChecked = ''+$(input).prop('checked');
	$(".map-layers-vector-list").jqxTreeGrid('setCellValue',rowKey,'visible',isChecked);
	var item = $(".map-layers-vector-list").jqxTreeGrid('getRow',rowKey);

};

/**
 * Вкл/выкл подписи на карте для косметического слоя
 * @param layerId
 */
map.controls.LayersControl.prototype.editCosmeticLayerText = function(){
	//текст влк/откл для всех слоёв, сходящих в эту группу
	var cosmeticIds = WidgetMap.layerManager.getCosmeticIds();
	cosmeticIds.forEach(function(layerId){
		var layer = WidgetMap.layerManager.getLayerByName(layerId);
		if(goog.isDef(layer)){
			layer.isTextAllow = !layer.isTextAllow;
			layer.layer.setVisibleText(layer.isTextAllow);
			layer.layer.featureProjLayer.getSource().changed();
		}
	});

};

/**
 * Вкл/выкл подписи на карте для слоя
 * @param layerId
 */
map.controls.LayersControl.prototype.allowVectorLayerText = function(layerId){
	var layer = WidgetMap.layerManager.getLayerByName(layerId);
	if(goog.isDef(layer)){
		layer.isTextAllow = !layer.isTextAllow;
		layer.layer.setVisibleText(layer.isTextAllow);
		layer.layer.featureProjLayer.getSource().changed();
	}
};

/**
 * Принудительна загрузка векторных данных слоя в обходи кэщирования
 * @param layerId
 */
map.controls.LayersControl.prototype.forceLoadLayerGeoDataWoCache = function(layerId){
	var layer = WidgetMap.layerManager.getLayerByName(layerId);
	if(goog.isDef(layer)){
		layer.layer.refreshLayerData(true);
	}
};

/**
 * Вкл/выкл подписи на карте для слоя
 * @param img
 * @param rowKey
 */
map.controls.LayersControl.prototype.allowVectorLayerText1 = function(img, rowKey){
	var opacity = ''+$(img).css('opacity');
	if(opacity == '0.3')
		$(".map-layers-vector-list").jqxTreeGrid('setCellValue',rowKey,'allowtext','true');
	else
		$(".map-layers-vector-list").jqxTreeGrid('setCellValue',rowKey,'allowtext','false');


	var item = $(".map-layers-vector-list").jqxTreeGrid('getRow',rowKey);
	var layer = WidgetMap.layerManager.getLayerByName(item.layer);
	if(goog.isDef(layer)){
		var isCurrAllow = item.allowtext === 'true';
		if(isCurrAllow === layer.isTextAllow)
			return;
		layer.isTextAllow = item.allowtext === 'true';
		layer.layer.setVisibleText(layer.isTextAllow);
		layer.layer.featureProjLayer.getSource().changed();
	}

};

/**
 * Смена стиля для кометического слоя с выбором топологии
 */
map.controls.LayersControl.prototype.editCosmeticLayerStyle = function(){
	//меняем стиль общий для всех слоёв, входящих в эту группу
	//если видимость слоя выключили, то никаких реакций на кнопки не будет
	var cosmeticIds = WidgetMap.layerManager.getCosmeticIds();
	if(cosmeticIds.length > 0){
		var layerId = 'COSMETIC_OBJECT';//cosmeticIds[0];
		var layer = WidgetMap.layerManager.getLayerByName(layerId);
		if(goog.isDef(layer)){
			if(!layer.visible || !goog.isDef(layer.layer)){
				App.confirmDialog(gis_managelayerscontrol_4,null,{title:gis_core_1});
				return;
			}
			var layerStyleQuery = layer.layerQueryId.replace('_Layers.xml','_STYLE.xml');
			//забираем все стили, которые связаны со слоем
			var styles = {};
			if(layerId === 'COSMETIC_OBJECT')
				styles = WidgetMap.layerManager.getAllCosmeticStylesForLayerObj(layerStyleQuery,layerId);
			else
				styles = WidgetMap.layerManager.getAllStylesForLayerObj(layerStyleQuery,layerId);
			var newStyles = this.getAllStylesForCosmeticLayer(layerId, styles);
			for (var i = 0; i < newStyles.length; i++) {
				newStyles[i].iconHtml = this.formatHref(newStyles[i]);
			}
			this.openForm(newStyles,layer.layer.drawTypes);
		}
		else
			App.confirmDialog(gis_managelayerscontrol_4,null,{title:gis_core_1});

	}

};


/**
 * Смена стиля для слоя с выбором топологии
 */
map.controls.LayersControl.prototype.editVectorLayerStyle = function(layerId){
	//если видимость слоя выключили, то никаких реакций на кнопки не будет
	var layer = WidgetMap.layerManager.getLayerByName(layerId);
	if(goog.isDef(layer)){
		if(!layer.visible || (goog.isDef(layer.layer) && !layer.layer.dataReady_)){
			App.confirmDialog(gis_managelayerscontrol_4,null,{title:gis_core_1});
			return;
		}
		var layerStyleQuery = layer.layerQueryId.replace('_Layers.xml','_STYLE.xml');
		//забираем все стили, которые связаны со слоем
		var styles = WidgetMap.layerManager.getAllStylesForLayerObj(layerStyleQuery,layerId);
		var newStyles = this.getAllStylesForLayerWithGeo(layerId, styles);
		for (var i = 0; i < newStyles.length; i++) {
			newStyles[i].iconHtml = this.formatHref(newStyles[i]);
		}
		this.openForm(newStyles,layer.layer.drawTypes);
	}
	else
		App.confirmDialog(gis_managelayerscontrol_4,null,{title:gis_core_1});
};

//Функция предпросмотра стиля в иконке аналогично рубрикатору
map.controls.LayersControl.prototype.formatHref = function (object) {
	var topology = 'none';
	if (goog.isDef(object.pointObj))
		topology = 'point';
	if (goog.isDef(object.lineObj))
		topology = 'line';
	if (goog.isDef(object.polyObj))
		topology = 'polygon';

	switch (topology) {
		case 'line':
			return '<div class="divIcon divIconLineStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: #' + object.lineObj.color.substring(2) + '"></div>';
			break;
		case 'polygon':
			if (object.fill == '1')
				return '<div class="divIcon divIconPolyStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: #' + object.polyObj.color.substring(2) + '"></div>';
			else
				return '<div class="divIcon divIconPolyStyle divIconPolyStyleBorder gridButton" style="margin-right: 3px; display: inline-block;"></div>';
			break;
		case 'point':
			if ((object.pointObj.form !== undefined) && (object.pointObj.form != 'bitmap')) {
				var styleText = 'margin-right: 3px; display: inline-block; background-color: #' + object.pointObj.color.substring(2) + '; ';
				if (object.size !== undefined) styleText += 'width:' + object.pointObj.size + 'px; height:' + object.pointObj.size + 'px;';
				return '<div class="divIcon divIconStyle' + object.pointObj.form + ' gridButton" style="' + styleText + '"></div>';
			} else if (object.pointObj.href !== undefined)
				return '<div style="height: 20px; float: left;"><img src="./' + object.pointObj.href + '" style="margin-right: 3px;"/></div>';
			break;
	}
}

map.controls.LayersControl.prototype.getAllStylesForLayerWithGeo = function(layerName, styles){
	var resArr = [];
	var o;
	for(o in globalPointsLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['point'][sId])){
			resArr.push(styles['point'][sId]);
			styles['point'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['point'][layerName])){
				resArr.push(styles['point'][layerName]);
				delete styles['point'][layerName];
				continue;
			}

		}
	}
	for(o in globalLinesLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['line'][sId])){
			resArr.push(styles['line'][sId]);
			delete styles['line'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['line'][layerName])){
				resArr.push(styles['line'][layerName]);
				delete styles['line'][layerName];
				continue;
			}

		}
	}
	for(o in globalPolygonsLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['polygon'][sId])){
			resArr.push(styles['polygon'][sId]);
			delete styles['polygon'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['polygon'][layerName])){
				resArr.push(styles['polygon'][layerName]);
				delete styles['polygon'][layerName];
				continue;
			}
		}
	}
	return resArr;
};

map.controls.LayersControl.prototype.getAllStylesForCosmeticLayer = function(layerName, styles){
	var resArr = [];
	for(var item in styles['point']){
		resArr.push(styles['point'][item]);
	}
	for(var item in styles['line']){
		resArr.push(styles['line'][item]);
	}
	for(var item in styles['polygon']){
		resArr.push(styles['polygon'][item]);
	}
	return resArr;
	var o;
	for(o in globalPointsLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['point'][sId])){

			delete styles['point'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['point'][layerName])){
				resArr.push(styles['point'][layerName]);
				delete styles['point'][layerName];
				continue;
			}

		}
	}
	for(o in globalLinesLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['line'][sId])){
			resArr.push(styles['line'][sId]);
			delete styles['line'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['line'][layerName])){
				resArr.push(styles['line'][layerName]);
				delete styles['line'][layerName];
				continue;
			}

		}
	}
	for(o in globalPolygonsLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['polygon'][sId])){
			resArr.push(styles['polygon'][sId]);
			delete styles['polygon'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['polygon'][layerName])){
				resArr.push(styles['polygon'][layerName]);
				delete styles['polygon'][layerName];
				continue;
			}
		}
	}
	return resArr;
};

map.controls.LayersControl.prototype.openForm = function(dataArrr,drawTypes){
	var that = this;
	var dataArr = dataArrr;
	var selectedTopology = '';
	var source = {
		localdata: dataArr,
		datatype: "array"
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	$('body').append('<div id="editStyleTypeDialog" style="overflow: hidden;"></div>');
	var currDialog = $('#editStyleTypeDialog');
	var dlg = currDialog;
	dlg.load('ui/html/map/EditStyleTypeForm.html', build);

	function build() {
		dlg.dialog({
			modal: true,
			dialogClass: 'noCloseButton gsi-zindex__dialog',
			title: gis_managelayerscontrol_7,
			closeOnEscape: false,
			width: 290,
			height: 195,
			resizable: false
		});
		$('#editStyleTypeDrop').jqxDropDownList({ source: dataAdapter, theme:'gis-blue-slider',
			selectedIndex: -1,
			placeHolder:gis_managelayerscontrol_8,
			disabled:false,
			displayMember: "descr",
			valueMember: "sId",
			width: 287, height: 20,
			enableBrowserBoundsDetection: true,
			dropDownWidth: 287,
			dropDownHeight: 187,
			renderer: function (index, label, value) {
				//var item = $('#editStyleTypeDrop').jqxDropDownList('getItem',index).originalItem;
				var datarecord = dataArr[index];
				var table = '<div>'+datarecord.iconHtml+label+'</div>';
				return table;
			}
		}).on('select', function (event) {
			var args = event.args;
			if (goog.isDef(args)) {
				var item = event.args.item;
				if(!goog.isNull(item))
					$('#editStyleTypeApply').prop('disabled', false).removeClass('disableButtonState');
			}
		});
		var isPoint = drawTypes.indexOf('point')!=-1;
		var isLine = drawTypes.indexOf('line')!=-1;
		var isPolygon = drawTypes.indexOf('polygon')!=-1;
		$('#editStyleTypeTopologyPoint').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isPoint})
			.bind('change', function (event) {
				var checked = event.args.checked;
				if(checked){
					selectedTopology = 'Point';
					that.updateEditStyleTypeDrop_('point',dataArrr);
				}

			});
		$('#editStyleTypeTopologyLine').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isLine})
			.bind('change', function (event) {
				var checked = event.args.checked;
				if(checked){
					selectedTopology = 'LineString';
					that.updateEditStyleTypeDrop_('line',dataArrr);
				}
			});
		$('#editStyleTypeTopologyPolygon').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isPolygon})
			.bind('change', function (event) {
				var checked = event.args.checked;
				if(checked){
					selectedTopology = 'Polygon';
					that.updateEditStyleTypeDrop_('polygon',dataArrr);
				}
			});
		$('#editStyleTypeApply').on('click',function(){
			that.applyStyle_(selectedTopology);
			$('#editStyleTypeDialog').remove();
		});
		$('#editStyleTypeApply').prop('disabled', true).addClass('disableButtonState');


		$('#editStyleTypeCancel').on('click',function(){
			$('#editStyleTypeDialog').remove();
		});
		if(isPolygon)
			$('#editStyleTypeTopologyPolygon').jqxRadioButton('check');
		if(isLine)
			$('#editStyleTypeTopologyLine').jqxRadioButton('check');
		if(isPoint)
			$('#editStyleTypeTopologyPoint').jqxRadioButton('check');
	}

};

/**
 * Обновляем список в зависимости от топологии
 * @param topologyType
 * @param originalArray
 * @private
 */
map.controls.LayersControl.prototype.updateEditStyleTypeDrop_ = function(topologyType, originalArray){
	var newArr = [];
	var i = 0;
	switch(topologyType){
		case 'point':
			for (i; i < originalArray.length; i++) {
				if (originalArray[i].pointObj)
					newArr.push(originalArray[i]);
			}
			break;
		case 'line':
			for (i; i < originalArray.length; i++) {
				if (!originalArray[i].polyObj && !originalArray[i].pointObj)
					newArr.push(originalArray[i]);
			}
			break;
		case 'polygon':
			for (i; i < originalArray.length; i++) {
				if (originalArray[i].polyObj)
					newArr.push(originalArray[i]);
			}
			break;
	}
	var source ={
		localdata: newArr,
		datatype: "array"
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#editStyleTypeDrop").jqxDropDownList('clear');
	$('#editStyleTypeDrop').jqxDropDownList({ source: dataAdapter});
};

map.controls.LayersControl.prototype.applyStyle_ = function(topologyType){
	var that = this;
	if(topologyType === '')return;
	var objectType = $('#editStyleTypeDrop').jqxDropDownList('getSelectedItem').originalItem;

	WidgetMap.editStyleForm = new EditStyleForm({
		topologyType:topologyType,
		objectType:objectType,
		applyCallback:function(style){
			that.applyVectorLayerStyle_(style);
			//WidgetMap.baseLayersControl.changedStyles.push(style);
		}
	});
	WidgetMap.editStyleForm.build();
};

map.controls.LayersControl.prototype.applyVectorLayerStyle_ = function(cStyle) {
	//находим в layerManager стиль и подменяем
	var origStyle = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(cStyle.sId, cStyle.topologyType);
	var layerId = (cStyle.layerId)?cStyle.layerId:'COSMETIC_OBJECT';
	var layer = WidgetMap.layerManager.getLayerByName(layerId);
	if(!goog.isNull(origStyle)){
		if(goog.isArray(cStyle.style))
			origStyle.style = cStyle.style.reverse();
		else{
			var cStyleText = cStyle.style.getText();
			if(!goog.isNull(cStyleText)){
				var newAlign = 'center';
				if(cStyleText.getOffsetX()<0) newAlign = 'left';
				else if(cStyleText.getOffsetX()>0) newAlign = 'right';
				var newBaseLine = 'middle';
				if(cStyleText.getOffsetY()<0) newBaseLine = 'top';
				else if(cStyleText.getOffsetY()>0) newBaseLine = 'bottom';

				origStyle.text.align = newAlign+'|'+newBaseLine;
				origStyle.text.bold = cStyleText.getFont().indexOf('bold') != -1?'1':'0';
				origStyle.text.italic = cStyleText.getFont().indexOf('italic') != -1?'1':'0';
				if(!goog.isNull(cStyleText.getFill())){
					if(goog.isArray(cStyleText.getFill().getColor()) && cStyleText.getFill().getColor().length == 4){
						var r = cStyleText.getFill().getColor()[0].toString(16);
						if(r.length==1)r='0'+r;
						var g = cStyleText.getFill().getColor()[1].toString(16);
						if(g.length==1)g='0'+g;
						var b = cStyleText.getFill().getColor()[2].toString(16);
						if(b.length==1)b='0'+b;
						origStyle.text.color = 'ff'+r+g+b;
					}
					else
						origStyle.text.color = cStyleText.getFill().getColor();
				}
				var kk=0;
				var splittedFont = cStyleText.getFont().split(' ');
				for(;kk<splittedFont.length;kk++){
					if(splittedFont[kk].indexOf('px')!=-1){
						origStyle.text.fontSize = splittedFont[kk].replace('px','');
						break;
					}
				}
				origStyle.text.fontFamily = cStyleText.getFont().substring(cStyleText.getFont().indexOf('px ')+3);
			}
			origStyle.style = cStyle.style;
		}

	}
	if(layer && layer.layer && layer.layer.featureProjLayer){
		layer.layer.featureProjLayer.getSource().setStyle(undefined);
	}
};


//обновление иконок в контроле
map.controls.LayersControl.prototype.updateVectorIcons = function(fileStyleName){
	var layersName = fileStyleName.replace('STYLE','Layers');
	var layers = $('li[data-canRaster="'+layersName+'"]');
	layers.each(function(index){
		var lName = $(this).find('.bl-wrapper').attr('data-id');
		if(lName !== undefined){
			var layer = WidgetMap.layerManager.getLayerByName(lName);
			if(layer !== undefined && layer.layer !== undefined){
				var icon = layer.layer.getIcon();
				$(this).find('.bl-img').css('background-image','url('+icon+')');
			}
		}

	});
};

/**
 * Поменять view в случае смены видимости слоя. Зависит от текущего максимального масштаба
 * @private
 */
map.controls.LayersControl.prototype.changeMapView_ = function () {
	var that = this;
	if(WidgetMap === undefined || WidgetMap.map === undefined)
		return;
	var zz = WidgetMap.map.getView().getZoom();
	var cc = WidgetMap.map.getView().getCenter();
	var resolutions = [];
	var DEFAULT_MAX_RESOLUTION = 156543.0339;
	var minZoom = 4;
	//сначала получаем текущий максимальный масштаб - кол-во элементов resolution
	//если не совпадает количество с максимальным включенным - обновляем view
	var maxZoom = this.getMaxZoom();

	//дизейблим форму перехода по координатам, если она открыта
	if ($('#mapCenteringDialog').length > 0) {
		//map.controls.MapCenteringControl.updateValues();
		$('#mapCenteringDialog').remove();
	}

	if( this.newMaxZoom ==  maxZoom )
		return;
	else
		this.newMaxZoom = maxZoom;
	var zoom = maxZoom + 1;
	resolutions.push(DEFAULT_MAX_RESOLUTION);
	var i = 1;
	for (; i < zoom; i++) {
		resolutions.push(resolutions[i - 1] / 2);
	}
	resolutions = resolutions.slice(minZoom);

	//проверяем, если максимальный масштаб уже был выставлен, но не обновляем view

	WidgetMap.map.setView(new ol.View({
		maxZoom: maxZoom,
		projection: WidgetMap.DEFAULT_PROJECTION,
		minZoom: minZoom,
		center: cc,
		zoom: zz,
		resolutions: resolutions
	}));
	if(goog.isDef(WidgetMap.zoomSliderControl)){
		//устанавливаем ползунок слайдера масштабирования
		WidgetMap.zoomSliderControl.forceSetThumbPosition();
	}
};

/**
 * Получение максимального масштаба для включенных слоёв
 * @returns {number}
 */
map.controls.LayersControl.prototype.getMaxZoom = function () {
	var maxZoom = -1;
	var layersObjs = [];
	try{
		layersObjs = WidgetMap.BaseLayersParser.rasterLayers.raster_map.baselayerscontrolarray
	}
	catch(ex){}
	var layers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group
	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function(layer) {
			if(layer.getVisible() && layer.get('id')){
				for(var j = 0; j < layersObjs.length; j++){
					if(layersObjs[j].id === layer.get('id') && layersObjs[j].maxZoom > maxZoom){
						maxZoom = layersObjs[j].maxZoom;
					}
				}
			}

		}, this);

	if(maxZoom != -1 )
		return maxZoom-1;
	else
		return 21;
};


/**
 * Получение списка видимых слоёв в виде массива идентификаторов в порядке следования
 */
map.controls.LayersControl.prototype.getVisibleLayers = function(){
	var visibleLayers = [];
	var layers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group
	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function(layer) {
			if(layer.getVisible() && layer.get('id')){
				visibleLayers.push(layer.get('id'));
			}
		}, this);
	//меняем местами порядок. вначале списка идут верхние слои
	//visibleLayers = visibleLayers.reverse();
	return visibleLayers.join(',');
};

/**
 * Обновляем состояния видимости чекбоксов
 * @param layerName
 * @param visible
 */
map.controls.LayersControl.prototype.updateVisibility = function(layerName, visible){
	$('.bl-checkbox-vector').each(function(){
		if($(this).data('id') === layerName){
			if(visible)
				$(this).addClass('checked');
			else
				$(this).removeClass('checked');
		}

	});
};

map.controls.LayersControl.prototype.checkError = function(layerId){
	if(!WidgetMap.BaseLayersParser.rasterLayers.raster_map) return;
	var layers = WidgetMap.BaseLayersParser.rasterLayers.raster_map.baselayerscontrolarray;
	layers.forEach(function (layer){
			if(layer.id === layerId && layer.error !== ''){
				App.errorReport(gis_core_17, layer.error + gis_core_19, undefined, {filename:gis_filename_485, functionname:'gis_filename_485_1'});
				layer.error = '';
			}
		},this);
}

/**
 * Вкл/Выкл все растровые слои, если работаем со слоем wms
 * @param visible флаг включения
 */
map.controls.LayersControl.prototype.toggleRasterLayers = function(visible){
	if(visible){

	}
	else{//выключаем растровые слои
		var layers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group
		layers.forEach(//ol.Collection
			/**
			 * @param {ol.layer.Layer} layer Layer.
			 */
			function(layer) {
				if(layer.get('id')){
					layer.setVisible(false);
				}
			}, this);
		//выключаем чекбоксы
		$('.bl-checkbox-raster').removeClass('checked');
		$("li[data-canraster='PODS_EQUIP_Layers.xml']").each(function(){
			if(visible)
				$(this).addClass('li-disabled');
			else
				$(this).removeClass('li-disabled');
		});
		//при смене режима wms/растровые слои не меняем режим. Просто отключаем растровые
		//this.changeMode(!visible);
	}
};

goog.provide('map.controls.MapInfoV7Control');
/**
 * Контрол получения информации по объекту на карте (Версия 7.7.0)
 * @param opt_options
 * @constructor
 */
map.controls.MapInfoV7Control = function (opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    goog.base(this, {
        target: options.target,
        noElement: true
    });
};
goog.inherits(map.controls.MapInfoV7Control, map.controls.MapInfoControl);

map.controls.MapInfoV7Control.prototype.handleMapInfoClick_ = function () {
    this.checkCadastreTileLayer();
    map.controls.PanControl.prototype.handlePanClick_();
    //временная проверка, что работаем с ПКа
    if (!goog.isDef(WidgetMap.LINE_ID)) {
        //map.controls.PanControl.prototype.handlePanClick_();
    }
    else {
        //удаляем сначала перемещение мышью
        WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
        WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);
    }
    this.searchX = undefined;
    this.searchY = undefined;
    this.coordX = undefined;
    this.coordY = undefined;
    WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.INFO;
    WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.INFO, this.innerElement);
    WidgetMap.map.un(ol.MapBrowserEvent.EventType.CLICK, this.mapClickHandler_, this);
    WidgetMap.map.on(ol.MapBrowserEvent.EventType.CLICK, this.mapClickHandler_, this);
};
goog.provide('map.controls.MapViewControl');

/**
 * Контрол для группы "Вид карты"
 * @constructor
 */
map.controls.MapViewControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var needClearCosmetic = goog.isDef(options.needClearCosmetic) ?
        options.needClearCosmetic : true;
    var needFullMap = goog.isDef(options.needFullMap) ?
        options.needFullMap : true;
    var needPrevView = goog.isDef(options.needPrevView) ?
        options.needPrevView : true;
    var needNextView = goog.isDef(options.needNextView) ?
        options.needNextView : true;
    var needWms = goog.isDef(options.needWms) ?
        options.needWms : true;


    var className = goog.isDef(options.className) ?
        options.className : 'map-view';

    this.isVisible = false;
    var tooltipCosmetic = goog.isDef(options.tooltipCosmetic) ?
        options.tooltipCosmetic : gis_basecontrols_12;
    var viewElementCosmetic = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-cosmetic-button',
        'type': 'button',
        'title': tooltipCosmetic
    });

    var tooltipFullMap = goog.isDef(options.tooltipFullMap) ?
        options.tooltipFullMap : gis_basecontrols_4;
    var viewElementFullMap = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-fullmap-button',
        'type': 'button',
        'title': tooltipFullMap
    });

    //массив вклдюченных слоёв для wms слоя
    this.wmsLayers = [];

    //массив загруженных слоёв
    this.loadedWmsLayers = [];
    //массив слоёв со всей информацией(порядок слудования, масштаб)
    this.loadedWmsLayersFullData = [];
    //принято решение хардкодить перечень моделей для wms слоя
    this.baseWmsModels = ["M_1","M_5","M_10","M_25","M_100","M_200","M_1K","M_R","M_W"];

    var tooltipPrev = goog.isDef(options.tooltipPrev) ?
        options.tooltipPrev : gis_historycontrol_1;
    var viewElementPrev = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-history-prev',
        'type': 'button',
        'title': tooltipPrev
    });

    var tooltipNext = goog.isDef(options.tooltipNext) ?
        options.tooltipNext : gis_historycontrol_2;
    var viewElementNext = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-history-next',
        'type': 'button',
        'title': tooltipNext
    });

    var tooltipWms = goog.isDef(options.tooltipWms) ?
        options.tooltipWms : gis_basecontrols_13;
    var viewElementWms = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-wms',
        'type': 'button',
        'title': tooltipWms
    });

    goog.events.listen(viewElementCosmetic,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.MapViewControl.prototype.handleMapViewClick_, 'map-cosmetic-button'), false, this);
    goog.events.listen(viewElementFullMap,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.MapViewControl.prototype.handleMapViewClick_, 'map-fullmap-button'), false, this);
    goog.events.listen(viewElementPrev,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.MapViewControl.prototype.handleMapViewClick_, 'map-history-prev'), false, this);
    goog.events.listen(viewElementNext,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.MapViewControl.prototype.handleMapViewClick_, 'map-history-next'), false, this);
    goog.events.listen(viewElementWms,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.MapViewControl.prototype.handleMapViewClick_, 'map-wms'), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    var element;
    if(!needClearCosmetic) viewElementCosmetic = undefined;
    if(!needFullMap) viewElementFullMap = undefined;
    if(!needPrevView) viewElementPrev = undefined;
    if(!needNextView) viewElementNext = undefined;
    if(!needWms) viewElementWms = undefined;
    if(!needClearCosmetic && !needFullMap && !needPrevView && !needNextView && !needWms)
        options.noElement = false;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, viewElementCosmetic, viewElementFullMap, viewElementPrev, viewElementNext, viewElementWms);
    goog.events.listen(element,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.MapViewChooserControl.prototype.handleMapViewChooseEvents_, 'mouseover'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.MapViewChooserControl.prototype.handleMapViewChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.MapViewChooserControl.prototype.handleMapViewChooseEvents_, 'mouseenter'), false, this);


    /*$('.map-view').mouseup(function (e) {
        e.stopPropagation();
    });
    $('.map-choose-view').mouseup(function (e) {
        e.stopPropagation();
    });*/
    goog.base(this, {
        element: element,
        target: options.target
    });
};
goog.inherits(map.controls.MapViewControl, ol.control.Control);
/**
 * Контрол для выбора вида карты. Включает в себя контролы: "Очистка косметического слоя", "Показать всю карту", "Вернутьсяя к пред.след положению карты"
 * @param opt_options
 * @constructor
 */
map.controls.MapViewChooserControl = function (opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-choose-view';

    this.currentClass= 'map-cosmetic-button';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : 'Вид карты';
    this.innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': this.currentClass,
        'type': 'button',
        'title': tooltipLabel
    });
    this.innerElement.style.display = 'inline';

    var arrowElement = goog.dom.createDom(goog.dom.TagName.DIV, {
        'class': className + '-arrow',
        'type': 'button',
        'title': 'Вид карты'
    });
    arrowElement.style.display = 'inline';

    goog.events.listen(this.innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.MapViewChooserControl.prototype.handleMapViewClick_), false, this);

    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.MapViewChooserControl.prototype.handleMapViewChooseEvents_, 'mouseover'), false, this);
    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.MapViewChooserControl.prototype.handleMapViewChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.MapViewChooserControl.prototype.handleMapViewChooseEvents_, 'mouseenter'), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, arrowElement, this.innerElement);
    }

    goog.base(this, {
        element: element,
        target: options.target
    });
};
goog.inherits(map.controls.MapViewChooserControl, ol.control.Control);

map.controls.MapViewControl.prototype.setVisible_ = function (visible) {
    if (visible)
        $('.map-view').css('visibility', 'visible');
    else
        $('.map-view').css('visibility', 'hidden');
    this.isVisible = visible;
};

map.controls.MapViewControl.prototype.handleMapViewClick_ = function (currentClass) {
    this.setVisible_(false);
    WidgetMap.viewMapChoose.changeCurrentClass_(currentClass);
    switch(currentClass) {
        case 'map-cosmetic-button':
            map.controls.ClearCosmeticV7Control.prototype.handleCosmeticClick_();
            break;
        case 'map-fullmap-button':
            WidgetMap.fullMap.handleFullMapClick_();
            break;
        case 'map-history-prev':
            WidgetMap.history.handleHistoryClick_(-1);
            break;
        case 'map-history-next':
            WidgetMap.history.handleHistoryClick_(1);
            break;
        case 'map-wms':
            this.handleWmsClick_();
            break;
    }
};

map.controls.MapViewChooserControl.prototype.handleMapViewChooseEvents_ = function (eventType) {
	return;
	var that = this;
    if(eventType === 'mouseover') {
        WidgetMap.viewMap.setVisible_(true);
        if(WidgetMap.baseLayersControl !== undefined)
            WidgetMap.baseLayersControl.close();
    }
    if(eventType === 'mouseleave'){
	    setTimeout(function(){
                WidgetMap.viewMap.setVisible_(false);
        },2000);
    }
};

map.controls.MapViewChooserControl.prototype.handleMapViewClick_ = function () {
    MapUtil.closeButtons('mapView');
	return;
    WidgetMap.viewMap.handleMapViewClick_(this.currentClass);
};

map.controls.MapViewChooserControl.prototype.changeCurrentClass_ = function (currentClass) {
    if(this.currentClass !== currentClass) {
        this.currentClass = currentClass;
        switch (currentClass) {
            case 'map-cosmetic-button':
                $(this.innerElement).addClass('map-cosmetic-button');
                $(this.innerElement).removeClass('map-fullmap-button');
                $(this.innerElement).removeClass('map-history-prev');
                $(this.innerElement).removeClass('map-history-next');
                break;
            case 'map-fullmap-button':
                $(this.innerElement).addClass('map-fullmap-button');
                $(this.innerElement).removeClass('map-cosmetic-button');
                $(this.innerElement).removeClass('map-history-prev');
                $(this.innerElement).removeClass('map-history-next');
                break;
            case 'map-history-prev':
                $(this.innerElement).addClass('map-history-prev');
                $(this.innerElement).removeClass('map-cosmetic-button');
                $(this.innerElement).removeClass('map-fullmap-button');
                $(this.innerElement).removeClass('map-history-next');
                break;
            case 'map-history-next':
                $(this.innerElement).addClass('map-history-next');
                $(this.innerElement).removeClass('map-cosmetic-button');
                $(this.innerElement).removeClass('map-fullmap-button');
                $(this.innerElement).removeClass('map-history-prev');
                break;
        }
    }
};



/**
 * Реация на нажатие кнопки включить карту по масштабам
 * @param type тип нажатой кнопки(copy или paste)
 * @private
 */
map.controls.MapViewControl.prototype.handleWmsClick_ = function() {
    //открываем форму выбора списка слоёв для фильтрации карты по масштабам
    if(this.loadedWmsLayers.length === 0)
        this.loadLayers4Wms();
    else
        this.handleManageLayersClick_()
};

/**
 * Реация на нажатие кнопок редактиварония стиля
 * @private
 */
map.controls.MapViewControl.prototype.handleManageLayersClick_ = function() {
    var that = this;
    var currDialog = $('#manageLayersDialog');
    if(currDialog.length == 0){
        $('body').append('<div id="manageLayersDialog" style="overflow: hidden;"></div>');
        $('#manageLayersDialog').hide();
        currDialog = $('#manageLayersDialog');
    }
    var dlg = currDialog;
    dlg.load('ui/html/map/ManageLayersForm.html', build);
    var width = 396;
    if(!this.needStyle)
        width = 360;
    function build() {
        dlg.dialog({
            modal: true,
            title: gis_managelayerscontrol_2,
            closeOnEscape: true,
            dialogClass: 'gsi-zindex__dialog',
            width: width,
            height: 396,
            resizable: false
        });
        //заполняем данными элементы
        that.fillGrid_();
        //кнопки "Отправить", "Отмена"
        $('#manageLayersApply').on('click',function(){
            that.applyLayers_();
            $('#manageLayersDialog').remove();
        });
        $('#manageLayersCancel').on('click',function(){
            $('#manageLayersDialog').remove();
        });
    }
};


/**
 * Заполняем грид данными
 * @private
 */
map.controls.MapViewControl.prototype.fillGrid_ = function() {
    if(goog.isDef(WidgetMap.layerManager)){
        var layers = this.loadedWmsLayers;//WidgetMap.layerManager.getAllSortedRasterLayers();
        var treeGridLayers = [];
        for(var i=0; i < layers.length; i++){
            //var obj = {LayerId:i, LayerName:layers[i].layer.sourceDescr, MapName:layers[i].layer.mapName, layer:layers[i].layer.name,visible:''+layers[i].visible,allowtext:''+layers[i].isTextAllow};
            var obj = {LayerId:i, LayerName:layers[i].sourceDescr, MapName:layers[i].mapName, layer:layers[i].name,visible:''+layers[i].visible,allowtext:''+layers[i].isTextAllow};
            treeGridLayers.push(obj);
        }
        var source = {
            dataType: "array",
            dataFields: [
                { name: 'LayerID', type: 'number' },
                { name: 'LayerName', type: 'string' },
                { name: 'MapName', type: 'string' },
                { name: 'layer', type: 'string'},
                { name: "visible", type: "string" },
                { name: 'icon', type: 'string' },
                { name: "style", type: "string" },
                { name: "allowtext", type: "string" }
            ],
            hierarchy:{groupingDataFields:[{name: "MapName"}]},
            id: 'LayerID',
            localData: treeGridLayers
        };
        var dataAdapter = new $.jqx.dataAdapter(source, {
            loadComplete: function () {
            }
        });
        var columns = [
            { text: gis_managelayerscontrol_3, dataField: 'LayerName', width: 295 },
            //{ text: "Name", align: "left", dataField: "name", width: 320 },
            {
                text: '', dataField: 'visible', width: 25,sortable:false,
                renderer: function (text, align, height) {
                    return "<div><img id='manageLayersGridEyeHeaderImg' class='manageLayersGridEyeOn' style='margin-left: 2px;margin-top: 1px;' src='/ui/images/eye.png'/></div>";
                },
                cellsRenderer: function (rowKey, dataField, value, data) {
                    if(value == 'true'){
                        return "<div><input type='checkbox' style='margin-left: 5px;' onchange='map.controls.ManageLayersControl.prototype.setVisible(this,"+rowKey+")' checked></div>";
                    }
                    else{
                        return "<div><input type='checkbox' style='margin-left: 5px;' onchange='map.controls.ManageLayersControl.prototype.setVisible(this,"+rowKey+")'></div>";
                    }
                }
            }
        ];
        $("#manageLayersGrid").jqxTreeGrid(
            {
                source: dataAdapter,
                altRows: true,
                sortable: true,
                width: 393,
                height: 332,
                columnsResize: false,
                localization: getLocalization('ru'),
                theme:'gis-blue-treegrid',
                icons: function (rowKey, rowData) {
                    var level = rowData.level;
                    if (level == 0) {
                        return "/ui/images/folder_icon.png";
                    }
                    return false;
                },
                checkboxes: false,
                columns: columns
            });

        $("#manageLayersGrid .iconscontainer").remove();
    }
};

/**
 * Применяем видимость и показ подписей к слоям
 * @private
 */
map.controls.MapViewControl.prototype.applyLayers_ = function() {
    //включаем wms слой и выключаем видимость у всех остльаных растровых слоёв
    var rows = $("#manageLayersGrid").jqxTreeGrid('getRows');
    var layers = [];
	rows.forEach(function(i){
		if(i.records && i.records.length > 0){
			i.records.forEach(function(j){
				if(j.visible === "true")
					layers.push(j.layer);
			});
		}
	});

    //
    this.removeRosLayer();
    this.addRosLayer(layers);
};
//удаляем wms слой
map.controls.MapViewControl.prototype.removeRosLayer = function(){
    var rasterLayer = WidgetMap.map.getLayers();
    var rosLayer = undefined;
    rasterLayer.forEach(//ol.Collection
        /**
         * @param {ol.layer.Layer} layer Layer.
         */
        function(layer) {
            if(layer.get('id') && layer.get('id') === "RosLayer"){
                rosLayer = layer;
            }
        }, this);
    if(rosLayer)
        WidgetMap.map.removeLayer(rosLayer);
};
//добавляем wms-слой
map.controls.MapViewControl.prototype.addRosLayer = function(layers){
    if(WidgetMap.baseLayersControl)// выключаем растровые слои
        WidgetMap.baseLayersControl.toggleRasterLayers(false);
    //добавляем wms слой на карту
    var rosLayerSource = new map.layer.RosLayerImageWMS({
        url: './WmsServicePage.aspx/WmsOperation',
        type:'',
	    visibleLayers: layers,
        layers: this.loadedWmsLayersFullData,
        params: {
            STYLES:'',
            VERSION: '1.3.0',
            PROJECTION: 'EPSG:900913'}
    });

    var rosLayer = new map.layer.RestrictByZoomImage({
        source: rosLayerSource,
        id:'RosLayer',
        restrictZoom: WidgetMap.LPURestrictZoom,
        restrictExtent: WidgetMap.LPURestrictExtent
    });
    //устанавливаем пслой под всеми
    var rasterLayers = WidgetMap.map.getLayers();
    rasterLayers.insertAt(0,rosLayer);
    //выставляем флаг, что слой RosRayer
    WidgetMap.isBaseLayerRosreestr = true;
    //WidgetMap.map.addLayer(rosLayer);
};

map.controls.MapViewControl.prototype.loadLayers4Wms = function(){
    this.loadModel(this.baseWmsModels.shift());
};


map.controls.MapViewControl.prototype.loadModel = function(modelName){
    var that = this;
    modelName += '_Layers.xml';
    function getLayersReqParams(layerName) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: 'SYS_SEM.xml#GET_XML_FILE',
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
                '<data FILE="'+layerName+'"/>'+
                '</root>'
        };
    }

    function getLayersResult(resultXml) {
        try { // Иногда ответ в формате XML, а иногда в виде просто строки
            var er = HTTPServiceUtil.getError(resultXml);
            if (er === '') {
                var layersDescriptionXml = $.parseXML(resultXml);
                var layers = $(layersDescriptionXml).find('layer');
                var mapName = $(layersDescriptionXml).find('root').attr('descr');
                if(!mapName)
                    mapName = modelName
                var mapOrder = (that.loadedWmsLayers.length > 0) ? that.loadedWmsLayers[that.loadedWmsLayers.length - 1].mapOrder + 1 : 0;
                layers.each(function (){
                    var curLayer = $(this);
                    var order = (!goog.isNull(curLayer.attr('order'))) ? parseFloat(curLayer.attr('order')) : 100;
                    var zMax = parseFloat(curLayer.attr('zoomMin'));
                    zMax = LayerManager.prototype.getZoom(zMax);
                    if(isNaN(zMax))zMax = Infinity;
                    var zMin =  parseFloat(curLayer.attr('zoomMax'));
                    zMin = LayerManager.prototype.getZoom(zMin);
                    if(isNaN(zMin))zMin = 0;
                    // var obj = {LayerId:i, LayerName:layers[i].sourceDescr, MapName:layers[i].mapName, layer:layers[i].name,visible:''+layers[i].visible,allowtext:''+layers[i].isTextAllow};
                    var layerObj = {
                        sourceDescr:curLayer.attr('descr'),
                        mapName: mapName,
                        name: curLayer.attr('id'),
                        visible: ('true' == curLayer.attr('visible')),
                        isTextAllow: true,
                        order: order,
                        mapOrder: mapOrder,
                        minZoom:zMin,
                        maxZoom:zMax
                    }
                    var clonedLayerObj = $.extend({}, layerObj);
                    that.loadedWmsLayersFullData.push(clonedLayerObj);
                    that.loadedWmsLayers.push(layerObj);
                });
            }
            else 
                App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_456, functionname:'gis_filename_456_0'});
        }
        catch(ex) {}
        finally {
            if(that.baseWmsModels.length === 0)
                that.handleManageLayersClick_();
            else
                that.loadModel(that.baseWmsModels.shift());
        }

    }

    function getLayersFault(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== '')
            App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_456, functionname:'gis_filename_456_1'});
        if(that.baseWmsModels.length === 0)
            that.handleManageLayersClick_();
        else
            that.loadModel(that.baseWmsModels.shift());
    }
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(modelName), getLayersResult,getLayersFault);
};

goog.provide('map.controls.SearchControl');
/**
 * Контрол поиска через поисковую систему (Версия 7.7.0)
 * @constructor
 */
map.controls.SearchControl = function (opt_options) {
	var that = this;
	var options = goog.isDef(opt_options) ? opt_options : {};
	//конфиг из описания задачи
	this.config = goog.isDef(options.config) ?
		options.config : {//дефолтные значения
			requests: ['search_engine.xml#search_idx_common', 'search_engine.xml#search_idx_gas'],
			filter: '',
			input: {
				width: '179px'
			},
			results: 20,
			sorting: 'asc'
		};
	this.className = goog.isDef(options.className) ?
		options.className : 'map-search';

	//текущий установленный расширенный фильтр
	this.advFilters = [];
	this.boolFilters;
	this.dateFilters;

	//список режимов поиска, забираются из конфига
	this.searchEngineList = this.config.requests;

	this.textElement = goog.dom.createDom(goog.dom.TagName.INPUT, {
		class: this.className + '-input',
		type: 'text',
		placeholder: gis_searchcontrol_1,
		autocomplete: 'disable',
		autocorrect: 'off'
	});

	this.findElement = goog.dom.createDom(goog.dom.TagName.INPUT, {
		class: this.className + '-find-button',
		type: 'button',
		title: gis_searchcontrol_2
	});

	this.closeElement = goog.dom.createDom(goog.dom.TagName.INPUT, {
		class: this.className + '-close-button',
		type: 'button',
		title: gis_searchcontrol_6
	});

	this.advancedFindElement = goog.dom.createDom(goog.dom.TagName.INPUT, {
		class: this.className + '-ext-button',

		type: 'button',
		title: gis_searchcontrol_3
	});

	//красный кружок над кнопкой расширенного фильтра - индикатор того, что был выбран фильтр
	this.advancedFindElementBadge = goog.dom.createDom(goog.dom.TagName.DIV, {
		class: this.className + '-ext-button-badge'
	});

	goog.events.listen(this.textElement,
		goog.events.EventType.KEYUP, goog.partial(
			map.controls.SearchControl.prototype.handleSearchClick_), false, this);
	goog.events.listen(this.findElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.SearchControl.prototype.handleSearchClick_), false, this);
	goog.events.listen(this.advancedFindElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.SearchControl.prototype.handleAdvancedSearchClick_), false, this);
	var cssClasses = this.className + ' collapsed';
	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.textElement, this.findElement, this.advancedFindElement, this.advancedFindElementBadge);

	//форма с результирующим списком
	this.searchView = undefined;
	//форма с фильтрами
	this.filterView = undefined;


	/*if (this.config.filter !== '') {
		this.filterView = new SearchEngineFiltersForm({
			config: this.config.filters,
			applyCallback: function(filters, boolFilters, dateFilters){
				//показываем индикатор, что был выбран фильтр
				$('.map-search-advbutton-badge').show();
				//применяем фильтр
				that.applyAdvFilter(filters, boolFilters, dateFilters);
			}
		});
		this.filterView.build();
	}*/
	this.page = 0;

	goog.base(this, {
		element: element,
		target: options.target
	});

};
goog.inherits(map.controls.SearchControl, ol.control.Control);

/**
 * Реация на нажатие кнопки "Найти"
 * @private
 */
map.controls.SearchControl.prototype.handleSearchClick_ = function (e) {
	var that = this;

	var keyCode;
	if (e && e.type === goog.events.EventType.KEYUP) {
		keyCode = e.keyCode;
		//если нажали enter - ищем
		if (keyCode === goog.events.KeyCodes.ENTER) {
		}
		//если нажали esc - чистим поле ввода
		else if (keyCode === goog.events.KeyCodes.ESC) {
			that.abortSearch();
			return;
		}
		else{
			if($(this.textElement).val() === '')
				that.abortSearch();
			return;
		}
	}
	else if($(this.findElement).hasClass('map-search-find-button-finded')) {
		that.abortSearch();
	}

	//прячем фильтр
	if(this.filterView !== undefined)
		this.filterView.hide();

	var searchStr = $(this.textElement).val();
	if (searchStr !== '') {
		//обнуляем счетчик страниц
		this.searchView = new SearchEngineViewForm({
			config: this.config,
			searchString: searchStr,
			filters: this.advFilters,
			boolFilters: this.boolFilters,
			dateFilters: this.dateFilters
		});
		this.searchView.build();
		this.searchView.search();
		$(this.findElement).addClass('map-search-find-button-finded');
	}
	else{//чистим выборку
		that.abortSearch();
	}
};


/**
 * Функция применения поиска после выбора расширенной фильтрации
 * @param filters
 * @param boolFilters
 * @param dateFilters
 */
map.controls.SearchControl.prototype.applyAdvFilter = function (filters, boolFilters, dateFilters) {
	var that = this;
	//прячем фильтр
	if(this.filterView !== undefined)
		this.filterView.hide();

	var searchStr = $(this.textElement).val();
	if (searchStr !== '') {
		//обнуляем счетчик страниц
		this.advFilters = filters;
		this.boolFilters = boolFilters;
		this.dateFilters = dateFilters;
		this.searchView = new SearchEngineViewForm({
			config: this.config, searchString: searchStr,
			filters: filters, boolFilters: boolFilters, dateFilters: dateFilters
		});
		this.searchView.build();
		this.searchView.search();
		$(this.findElement).addClass('map-search-find-button-finded');
	}
	else{//чистим выборку
		that.abortSearch();
	}
};


/**
 * Функция сброса сортировки
 */
map.controls.SearchControl.prototype.abortSearch = function(){
	$(this.findElement).removeClass('map-search-find-button-finded');
	$(this.textElement).val('');
	SearchEngineViewForm.destroy();
}

/**
 * Реация на нажатие кнопки "Расширенный поиск"
 * @private
 */
map.controls.SearchControl.prototype.handleAdvancedSearchClick_ = function () {
	if(this.filterView){
		this.filterView.toggle();
	}
	if(this.searchView)
		this.searchView.hide();
};
goog.provide('map.controls.SearchOnMapControl');
/**
 * Контрол для группы "Поиск"
 * @constructor
 */
map.controls.SearchOnMapControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-search-centering';
    var needCentering = goog.isDef(options.needCentering) ?
        options.needCentering : true;
    var needSearch = goog.isDef(options.needSearch) ?
        options.needSearch : true;

    this.isVisible = false;

    var tooltipLink = goog.isDef(options.tooltipLink) ?
        options.tooltipLink : gis_mapcenteringcontrol_6;
    var shareElementLink = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-centering-button',
        'type': 'button',
        'title': tooltipLink
    });

    var tooltipSend = goog.isDef(options.tooltipSend) ?
        options.tooltipSend : gis_searchaddresscontrol_1;
    var shareElementSend = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-address-search-button',
        'type': 'button',
        'title': tooltipSend
    });

    goog.events.listen(shareElementLink,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.SearchOnMapControl.prototype.handleSearchCenteringClick_, 'map-centering-button'), false, this);
    goog.events.listen(shareElementSend,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.SearchOnMapControl.prototype.handleSearchCenteringClick_, 'map-address-search-button'), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    if(!needCentering) shareElementLink = undefined;
    if(!needSearch) shareElementSend = undefined;
    if(!needCentering && !needSearch) options.noElement = true;
    var element;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, shareElementLink, shareElementSend);
    goog.events.listen(element,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringChooseEvents_, 'mouseover'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringChooseEvents_, 'mouseenter'), false, this);
    goog.base(this, {
        element: element,
        target: options.target
    });

};
goog.inherits(map.controls.SearchOnMapControl, ol.control.Control);
/**
 * Контрол для выбора операциий. Включает в себя контролы: "Сообщить об ошибке", "Ссылка на карту"
 * @param opt_options
 * @constructor
 */
map.controls.SearchOnMapChooserControl = function (opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-choose-search-centering';

    this.currentClass= 'map-centering-button';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_mapcenteringcontrol_6;
    this.innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': this.currentClass,
        'type': 'button',
        'title': tooltipLabel
    });
    this.innerElement.style.display = 'inline';

    var arrowElement = goog.dom.createDom(goog.dom.TagName.DIV, {
        'class': className + '-arrow',
        'type': 'button',
        'title': tooltipLabel
    });
    arrowElement.style.display = 'inline';

    goog.events.listen(this.innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringClick_), false, this);
    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringChooseEvents_, 'mouseover'), false, this);
    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringChooseEvents_, 'mouseenter'), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, arrowElement, this.innerElement);

    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.SearchOnMapChooserControl, ol.control.Control);

/**
 * Спрятать/показать кнопку
 * @param visible
 * @private
 */
map.controls.SearchOnMapControl.prototype.setVisible_ = function (visible) {
    if (visible)
        $('.map-search-centering').css('visibility', 'visible');
    else
        $('.map-search-centering').css('visibility', 'hidden');
    this.isVisible = visible;
};

map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringChooseEvents_ = function (eventType) {
	return;
};

map.controls.SearchOnMapChooserControl.prototype.handleSearchCenteringClick_ = function () {
    MapUtil.closeButtons('searchOnMap');
};

map.controls.SearchOnMapChooserControl.prototype.changeCurrentClass_ = function (currentClass) {
    if(this.currentClass !== currentClass) {
        this.currentClass = currentClass;
        switch (currentClass) {
            case 'map-centering-button':
                $(this.innerElement).addClass('map-centering-button');
                $(this.innerElement).removeClass('map-address-search-button');
                break;
            case 'map-address-search-button':
                $(this.innerElement).addClass('map-address-search-button');
                $(this.innerElement).removeClass('map-centering-button');
                break;
        }
    }
};

map.controls.SearchOnMapControl.prototype.handleSearchCenteringClick_ = function (currentClass) {
    this.setVisible_(false);
    WidgetMap.searchOnMapChooser.changeCurrentClass_(currentClass);
    switch(currentClass) {
        case 'map-centering-button':
            WidgetMap.mapCentering.handleCenteringClick_();
            break;
        case 'map-address-search-button':
            WidgetMap.searchAddress.handleSearchClick_();
            break;
    }
};
goog.provide('map.controls.ShareControl');
/**
 * Контрол для группы "Поделиться"
 * @constructor
 */
map.controls.ShareControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-share';
    var needLink = goog.isDef(options.needLink) ?
        options.needLink : true;
    var needSendMail = goog.isDef(options.needSendMail) ?
        options.needSendMail : true;

    this.isVisible = false;

    var tooltipLink = goog.isDef(options.tooltipLink) ?
        options.tooltipLink : gis_linkmapcontrol_1;
    var shareElementLink = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-link-button',
        'type': 'button',
        'title': tooltipLink
    });

    var tooltipSend = goog.isDef(options.tooltipSend) ?
        options.tooltipSend : gis_sendmailcontrol_19;
    var shareElementSend = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': 'map-sendmail-button',
        'type': 'button',
        'title': tooltipSend
    });

    goog.events.listen(shareElementLink,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ShareControl.prototype.handleShareClick_, 'map-link-button'), false, this);
    goog.events.listen(shareElementSend,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ShareControl.prototype.handleShareClick_, 'map-sendmail-button'), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    if(!needLink) shareElementLink = undefined;
    if(!needSendMail) shareElementSend = undefined;
    if(!needLink && !needSendMail) options.noElement = true;
    var element;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, shareElementLink, shareElementSend);
    goog.events.listen(element,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.ShareChooserControl.prototype.handleShareChooseEvents_, 'mouseover'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.ShareChooserControl.prototype.handleShareChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.ShareChooserControl.prototype.handleShareChooseEvents_, 'mouseenter'), false, this);


    /*$('.map-choose-share').mouseup(function (e) {
        e.stopPropagation();
    });
    $('.map-share').mouseup(function (e) {
        e.stopPropagation();
    });*/
    goog.base(this, {
        element: element,
        target: options.target
    });

};
goog.inherits(map.controls.ShareControl, ol.control.Control);
/**
 * Контрол для выбора операциий. Включает в себя контролы: "Сообщить об ошибке", "Ссылка на карту"
 * @param opt_options
 * @constructor
 */
map.controls.ShareChooserControl = function (opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-choose-share';

    this.currentClass= 'map-link-button';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : 'Поделиться';
    this.innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': this.currentClass,
        'type': 'button',
        'title': tooltipLabel
    });
    this.innerElement.style.display = 'inline';

    var arrowElement = goog.dom.createDom(goog.dom.TagName.DIV, {
        'class': className + '-arrow',
        'type': 'button',
        'title': tooltipLabel
    });
    arrowElement.style.display = 'inline';

    goog.events.listen(this.innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ShareChooserControl.prototype.handleShareClick_), false, this);

    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.ShareChooserControl.prototype.handleShareChooseEvents_, 'mouseover'), false, this);
    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.ShareChooserControl.prototype.handleShareChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen(this.innerElement,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.ShareChooserControl.prototype.handleShareChooseEvents_, 'mouseenter'), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, arrowElement, this.innerElement);

    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.ShareChooserControl, ol.control.Control);

/**
 * Спрятать/показать кнопку
 * @param visible
 * @private
 */
map.controls.ShareControl.prototype.setVisible_ = function (visible) {
    if (visible)
        $('.map-share').css('visibility', 'visible');
    else
        $('.map-share').css('visibility', 'hidden');
    this.isVisible = visible;
};

map.controls.ShareChooserControl.prototype.handleShareChooseEvents_ = function (eventType) {
	return;
    if(eventType === 'mouseover') {
        WidgetMap.share.setVisible_(true);
        if(WidgetMap.baseLayersControl !== undefined)
            WidgetMap.baseLayersControl.close();
    }
    if(eventType === 'mouseleave'){
        setTimeout(function(){
            WidgetMap.share.setVisible_(false);
        },2000);
    }
};

map.controls.ShareChooserControl.prototype.handleShareClick_ = function () {
    MapUtil.closeButtons('share');
	return;
    WidgetMap.share.handleShareClick_(this.currentClass);
};

map.controls.ShareChooserControl.prototype.changeCurrentClass_ = function (currentClass) {
    if(this.currentClass !== currentClass) {
        this.currentClass = currentClass;
        switch (currentClass) {
            case 'map-link-button':
                $(this.innerElement).addClass('map-link-button');
                $(this.innerElement).removeClass('map-sendmail-button');
                break;
            case 'map-sendmail-button':
                $(this.innerElement).addClass('map-sendmail-button');
                $(this.innerElement).removeClass('map-link-button');
                break;
        }
    }
};

map.controls.ShareControl.prototype.handleShareClick_ = function (currentClass) {
    this.setVisible_(false);
    WidgetMap.shareChoose.changeCurrentClass_(currentClass);
    switch(currentClass) {
        case 'map-link-button':
            WidgetMap.linkMap.handleLinkMapClick_();
            break;
        case 'map-sendmail-button':
            WidgetMap.sendMail.handleSendMailClick_();
            break;
    }
};
/*** GLOBAL VARS  ***/
try{
	goog.provide('map.render.canvas.Replay');
}
catch(ex){}
try{
	goog.provide('map.renderer.vector');
}
catch(ex){}

var _TRANSFORM = {};
var _CONTEXT = undefined;
var _LABELS = [];
MAP_MATRIX_DX = 1;
MAP_MATRIX_DY = 1;
var _dx = MAP_MATRIX_DX;
var _dy = MAP_MATRIX_DY;
var _visibleMatrix = {};
var _visibleTextMatrix = {};
ol.render.canvas.BATCH_CONSTRUCTORS_ = {
	'Image': (map && map.render && map.render.canvas)?map.render.canvas.ImageReplay:ol.render.canvas.ImageReplay,
	'LineString': (map && map.render && map.render.canvas)?map.render.canvas.LineStringReplay:ol.render.canvas.LineStringReplay,
	'Polygon': (map && map.render && map.render.canvas)?map.render.canvas.PolygonReplay:ol.render.canvas.PolygonReplay,
	'Text': (map && map.render && map.render.canvas)?map.render.canvas.TextReplay:ol.render.canvas.TextReplay,
};
ol.renderer.vector.GEOMETRY_RENDERERS_['Point'] = (map && map.renderer && map.renderer.vector)?
	map.renderer.vector.renderPointGeometry_: ol.renderer.vector.renderPointGeometry_;
ol.renderer.vector.GEOMETRY_RENDERERS_['MultiPoint'] = (map && map.renderer && map.renderer.vector)?
	map.renderer.vector.renderMultiPointGeometry_:ol.renderer.vector.renderMultiPointGeometry_;
ol.renderer.vector.GEOMETRY_RENDERERS_['MultiLineString'] = (map && map.renderer && map.renderer.vector)?
	map.renderer.vector.renderMultiLineStringGeometry_:ol.renderer.vector.renderMultiLineStringGeometry_;
ol.renderer.vector.GEOMETRY_RENDERERS_['MultiPolygon'] =(map && map.renderer && map.renderer.vector)?
	map.renderer.vector.renderMultiPolygonGeometry_:ol.renderer.vector.renderMultiPolygonGeometry_;

var MAP_TYPE = {
	MAP: 'map',
	CAS: 'cas',
	SCHEMA: 'schema'
}

var CURRENT_MAP_TYPE = MAP_TYPE.MAP;
goog.provide('ru.corelight.classes.map');
ru.corelight.classes.map.BaseWidget = function(opt_options){
	this.map = undefined;
	this.kinetic = null;//new ol.Kinetic(-0.005, 0.05, 100);//дефолтные настройки перемещения карты
	//список предзагруженных ЛПУ, чтобы фильтры не подгружали данные;
	this.preloadLpuValues = undefined;
	//теже предзагруженные ЛПУ, только в виде справочника с ключом по коду ЛПУ
	this.preloadLpuValuesDict = {};
	//массив дефолтных идентификаторов ЛПУ для сверки с текущим. Если не совпадают с пользовательскими - гео данные из БД всегда
	this.defaultLpuIds = [];

	this.config = null;
	this.mapHistory = undefined;

	//текущая выбранная кнопка
	this.selectedMapButton = undefined;
	this.baseLayersControl = undefined;
	//текущий контрол для рисования, чтобы могли из любых мест его удалить
	this.drawControl = undefined;
	this.panControl = undefined;
	this.managelayersControl = undefined;
	this.mapInfoControl = undefined;
}

ru.corelight.classes.map.BaseWidget.prototype.build = function(){

}
ru.corelight.classes.map.BaseWidget.prototype.regenerateMatrix = function(layerId){
	//Значение ширины, которое добавляется к матрице слева и справа,
	//чтобы при разрядке точечные объекты не пропадали как только их центр выйдет за границы карты
	var matrixAddWidth = _dx;
	//Значение высоты, которое добавляется к матрице сверху и снизу,
	//чтобы при разрядке точечные объекты не пропадали как только их центр выйдет за границы карты
	var matrixAddHeight = _dy;
	//Расширяем матрицу при генерации, чтобы не происходила разрядка точечных объектов, центр которых вышел за границу но часть объекта должна отображаться
	var mapSize = WidgetMap.map.getSize();
	var i = Math.ceil((mapSize[0]*2 + matrixAddWidth*2) / _dx);
	var j = Math.ceil((mapSize[1]*2 + matrixAddHeight*2) / _dy);
	_visibleMatrix[layerId] = new Array(i);
	var k = 0;
	for (k; k<i; k++){
		_visibleMatrix[layerId][k] = new Array(j);
	}
	if(layerId == 'label'){
		i = Math.ceil((mapSize[0]*2 + matrixAddWidth*2) / _dx);
		j = Math.ceil((mapSize[1]*2 + matrixAddHeight*2) / _dy);
		_visibleTextMatrix[layerId] = new Array(i);
		var k = 0;
		for (k; k<i; k++){
			_visibleTextMatrix[layerId][k] = new Array(j);
		}
	}
};


ru.corelight.classes.map.BaseWidget.prototype.updateTopFilter = function (params) {
	var layerId = '';
	var j = 0;
	for (j; j < params.length; j++) {
		var curParam = params[j];
		if(curParam['name'] === 'layerId')
			layerId = curParam['value'];
	}
	for (j = 0; j < params.length; j++) {
		var curParam = params[j];
		if (!curParam.hasOwnProperty('name')) continue;
		var newFilters = [];
		var curFilters;
		switch (curParam['name']) {
			case 'filter':
			case 'roughFilter':
				curFilters = curParam['value'].split('|');
				for (var i = 0; i < curFilters.length; i++) {
					var nameValArr = curFilters[i].split(':');
					if (nameValArr && nameValArr.length == 2) {
						var newFilterObj = {name: nameValArr[0], value: nameValArr[1], layerName: layerId};
						newFilters.push(newFilterObj);
					}
				}

				if (curParam['name'] == 'filter') {
					//Переписываем массив фильтров верхнего уровня, из которых формируются запросы
					newFilters.forEach(function(val){
						if(val && val.name){
							if(WidgetMap.currentTopFilter.length == 0)
								WidgetMap.currentTopFilter = newFilters;
							else{
								var finded = false;
								for(var ni = 0; ni < WidgetMap.currentTopFilter.length; ni++){
									if(WidgetMap.currentTopFilter[ni].name !== undefined ){
										if(WidgetMap.currentTopFilter[ni].name === val.name ){
											WidgetMap.currentTopFilter[ni].value = val.value;
											finded = true;
											break;
										}
									}
								}
								if(!finded)
									WidgetMap.currentTopFilter.push(val);
							}
						}
						//WidgetMap.currentTopFilter = newFilters;
					});

				}
				else if (curParam['name'] == 'roughFilter') {
					//Переписываем массив фильтров среднего уровня, из которых формируются запросы
					WidgetMap.currentRoughFilter = newFilters;
				}
				break;
			case 'layerId':
				layerId = curParam['value'];
				break;
		}
	}

};

/**
 * Центрируемся на карте по экстенту
 * @param extent экстент текущей геометрии
 */
ru.corelight.classes.map.BaseWidget.prototype.centerOnMap = function(extent){
	if (App.config.MAP_CENTERING_MIN_ZOOM === undefined){
		App.errorReport(gis_core_17, 'MAP_CENTERING_MIN_ZOOM' + gis_core_18, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_13'});
		return;
	}
	var minZoom = App.config.MAP_CENTERING_MIN_ZOOM;
	if(goog.isDef(minZoom) && goog.isNumber(parseFloat(minZoom)) && parseFloat(minZoom) > 0 && WidgetMap.getZoomForExtent(extent) >= parseFloat(minZoom)){

		map.controls.FullMapControl.prototype.centerOn_(ol.extent.getCenter(extent),minZoom);
	}
	else{
		WidgetMap.map.getView().fit(extent, WidgetMap.map.getSize());
	}
};

/**
 * Получить зум для переданного экстента
 * @param extent
 * @returns {number}
 */
ru.corelight.classes.map.BaseWidget.prototype.getZoomForExtent = function(extent){
	var viewSize =  WidgetMap.map.getSize();
	var idealResolution ;//= Math.max(extent[0]/viewSize[0],extent[1] / viewSize[1]);
	var view = WidgetMap.map.getView();
	var RESOLUTION_TOLERANCE = 0.000001;
	idealResolution = Math.max(ol.extent.getWidth(extent)/ viewSize[0], ol.extent.getHeight(extent) / viewSize[1]);//view.getResolutionForExtent(extent,viewSize);
	var offset;
	var resolution = idealResolution;

	if (goog.isDef(resolution)) {
		var res, z = 0;
		do {
			res = view.constrainResolution(view.maxResolution_, z);
			if (res < resolution && Math.abs(res - resolution) > RESOLUTION_TOLERANCE) {
				offset = z;
				break;
			}
			++z;
		} while (res > view.minResolution_);
	}
	return z + view.minZoom_ - 1;//view.maxResolution_ соответствует minZoom, поэтому добавляем. И отнимаем 1, как во флеш
};

/**
 * Получить зум для переданной resolution
 * @param resolution
 * @returns {number}
 */
ru.corelight.classes.map.BaseWidget.prototype.getZoomForResolution = function(resolution){
	var offset;
	var view = WidgetMap.map.getView();
	if (goog.isDef(resolution)) {
		var res, z = 0;
		do {
			res = view.constrainResolution(view.maxResolution_, z);
			if (res == resolution) {
				offset = z;
				break;
			}
			++z;
		} while (res > view.minResolution_);
	}

	return goog.isDef(offset) ? view.minZoom_ + offset : offset;
};

ru.corelight.classes.map.BaseWidget.prototype.createVectorLayer = function(){
	//добавляем на карту векторный слой для рисования
	var source = new ol.source.Vector();
	WidgetMap.currentVectorLayer = new ol.layer.Vector({
		source: source
	});
	WidgetMap.map.addLayer(WidgetMap.currentVectorLayer);
};
/**
 * Слой для выделения объектов на карте
 *
 */
ru.corelight.classes.map.BaseWidget.prototype.addMapSelectionLayer = function(){
	if(goog.isDef(WidgetMap.map)) {
		try {
			var vector = new ol.layer.Vector({
				source: new ol.source.Vector({
				})
			});
			WidgetMap.mapSelectionLayer = vector;
			WidgetMap.map.addLayer(WidgetMap.mapSelectionLayer);
		}
		catch (ex) {
		}
	}
};

//прячем подписи по инциденту #1505
ru.corelight.classes.map.BaseWidget.prototype.hideLabels = function(layerName,objects){
	var layer = WidgetMap.layerManager.getLayerByName(layerName);
	if(goog.isDef(layer) && goog.isDef(layer.layer)){
		//проходим по всем фичам и забираем по id Объекта геометрию из _globalPointLabels,
		var features = layer.layer.featureProjLayer.getSource().getSource().getFeatures();
		var i = 0;
		var j = 0;
		var hideGeos = [];
		for(j;j<objects.length;j++){
			i = 0;
			for(i;i<features.length;i++){
				//ищем только в multiPoint
				var oId = objects[j];
				if(features[i].getGeometry().getType() == ol.geom.GeometryType.MULTI_POINT && goog.isDef(features[i].get('pointsObj')) && goog.isDef(features[i].get('pointsObj')[oId])){
					var coords = features[i].get('pointsObj')[oId].flatCoordinates;
					hideGeos.push({id:oId, unique:features[i].get('labelType')+'_'+coords[0]+'_'+coords[1]});
				}
			}
		}
		WidgetMap.hideLabelsArr = hideGeos;
		layer.layer.featureProjLayer.changed();
	}
};
/**
 * Оставить на карте выбранные объекты
 * @param layerName
 * @param layerIds
 * @param that
 */
ru.corelight.classes.map.BaseWidget.prototype.selectFeatures = function (layerName, layerIds, that, findCallback) {
	if(!checkMapExisting())
		return;
	var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
	if(goog.isDef(layerObj) && goog.isDef(layerObj.layer)) {
		if (!layerObj.layer.hasData) {//если данных нет в слое вообще
			if(findCallback)
				findCallback(false);
			else
				MapUtil.showObjectError(that, layerObj, this);
			return;
		}
		var features = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(layerObj.layer,layerIds);
		MapUtil.clearSelectionLayer();
		if(features.length == 0){
			/*if(showObjectsIsGroupButton == true)//если нажата была групповая кнопка, то не показываем ошибки
			 return;*/
			if(findCallback)
				findCallback(false);
			else
				MapUtil.showObjectError(that, layerObj, this);
		}
		else{
			if(findCallback)
				findCallback(true);
			var layer = WidgetMap.layerManager.getLayerByName(layerName);
			if(goog.isDef(layer) && goog.isDef(layer.layer))
				layer.layer.showObjectsByIds(layerIds, that.showObjectsCentering);
			//прячем подписи для слоя
			//WidgetMap.hideLabels(layerName,layerIds);
		}

	}
};
ru.corelight.classes.map.BaseWidget.prototype.selectAndCenterByFoundedGeom = function(centering){
	//добавляем массив найденных фич в слой для выделений
	//если надо, масштабируемся
	if(WidgetMap.rasterLayersFeatures.length==0)
		return;
	WidgetMap.mapSelectionLayer.getSource().addFeatures(WidgetMap.rasterLayersFeatures);
	WidgetMap.rasterLayersFeatures = [];
	//зуммируемся к ним
	var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
	if(centering){
		WidgetMap.centerOnMap(extent);
	}
};
ru.corelight.classes.map.BaseWidget.prototype.setStartupScenario = function(){
	try{
		if (goog.isDefAndNotNull(WidgetMap.config)) {
			var tree = WidgetMap.config.tree;
			if(tree && tree.trees && tree.trees.length > 0){
				var startupScenario = tree.trees[0].startupScenario;
				if(startupScenario){
					var openLayers =  startupScenario.openLayers;
					if(openLayers){
						WidgetMap.startupLayers = openLayers;
						//меняем порядок слодования, чтобы при добавлении в список через pop добавлялся первый
						//WidgetMap.startupLayers =  WidgetMap.startupLayers.reverse();
					}
				}
			}
		}
		//если выполниласьт обработка сценария с показом слоёв
		if(App.scenarioParams && App.scenarioParams.vars){
			WidgetMap.startupLayers = App.scenarioParams.vars.openLayers;
			App.scenarioParams = undefined;
		}
	}
	catch(ex){}
}
ru.corelight.classes.map.BaseWidget.prototype.changeMapView = function(maxZoom, viewName, projection){
	throw new Error(gis_core_error_4);
};
/**
 * Проверяем, есть ли в url параметры, пришедшие из внешней системы
 * Если есть, то работаем через externalFunctionaAPI
 */
ru.corelight.classes.map.BaseWidget.prototype.checkExternalParamsFromURL = function(){
	throw new Error(gis_core_error_4);
};
/**
 * Реакция на нажатие ESC
 * @private
 */
ru.corelight.classes.map.BaseWidget.prototype.handleEscClick_ = function () {
	throw new Error(gis_core_error_4);
};


/*** STATIC  ***/
ru.corelight.classes.map.BaseWidget.getHideButtonsConfig = function(){
	var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
	if (mapConfig) {
		var buttons = mapConfig.hideButtons;
		if (goog.isDef(buttons)) {
			return buttons;
		}
	}
	return [];
};

WidgetMap = {};
WidgetMap.map = undefined;
WidgetMap.kinetic = null;//new ol.Kinetic(-0.005, 0.05, 100);//дефолтные настройки перемещения карты

//типы моделей, которые могут быть растровыми
WidgetMap.MULTI_MODE_LAYERS = [];
WidgetMap.MODES = {
    VECTOR:'vector',
    RASTER:'raster'
};
WidgetMap.COORD_MODES = {
    DECIMAL: 'decimal',
    GRAD: 'grad'
};

WidgetMap.MAP_NUM_ZOOM_LEVELS = 13;

//список удаленных с карты объектов, чтобы в дальнейшем была возможность их восстановить после закрытия панели свойств
WidgetMap.recentlyDeletedObjectsFromMap = {};
// объект на карте, который подвергается удалению узлов для корректного отката геометрии в случае закрытия панели свойств или ошибочная команда в БД
WidgetMap.currentCutFeature = {};
//текущий режим отобраюения основных данных
WidgetMap.CURRENT_MODE = WidgetMap.MODES.VECTOR;

WidgetMap.MAP_BUTTON_STATE = {
    PAN:'pan',
    ZOOM:'zoom',
    INFO:'info'
};
//текущая выбранная кнопка
WidgetMap.selectedMapButton = undefined;

WidgetMap.panControl = undefined;
WidgetMap.managelayersControl = undefined;
WidgetMap.infoControl = undefined;
WidgetMap.measureChooserControl = undefined;
WidgetMap.shareChoose = undefined;
WidgetMap.viewMapChoose = undefined;

//положение карты по умолчанию
WidgetMap.config = null;
WidgetMap.treeConfig = undefined;
WidgetMap.mapHistory = undefined;
WidgetMap.showTree = true;

WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.PAN;

WidgetMap.canFirstTimeCentering = true;

WidgetMap.filterDataMessageId = undefined;//Это не ID запроса. Это сам текущий запрос на грид, который можно отменить через currentGridCountMessageId.abort()

/*  Какого типа модель в задачах(вектор или быстрые кеши). Используется, чтобы определить в каком виде изначально зуммироваться
 * через вектор или через сервис */
WidgetMap.isModelsVector = false;

WidgetMap.START_X = 991;
WidgetMap.START_Y = 245.5;
WidgetMap.START_ZOOM = 4;
WidgetMap.DEFALT_ZOOM_FOR_FONT = 11;//дефолтный масштаб для шрифта, который будет считаться базовым и от него будет высчитываться размер в пунктах для техсхемы
WidgetMap.DEFAULT_PROJECTION = 'EPSG:5807';

/**
 * Параметры для работы задачи гурфовок
 * @type {undefined}
 */
WidgetMap.BEGIN_MEASURE = undefined;
WidgetMap.END_MEASURE = undefined;
WidgetMap.ROUTE_ID = undefined;
WidgetMap.SHEET_ID = undefined;
WidgetMap.ILI_INSPECTION_ID = undefined;

WidgetMap.layerManager = undefined;

//векторный слоя для рисования
WidgetMap.currentVectorLayer = undefined;

WidgetMap.mapSelectionLayer = undefined;
//текущий выбранный объект
WidgetMap.mapSelectedObject = undefined;

//флаг, можно ли искать в данной подложке по растрам
WidgetMap.showRasterInfo = false;

//базовое взаимодействие на карте. Чтобы была возможность менять его при режиме зуммирования, перемещения,..
WidgetMap.baseInteraction = undefined;

//текущий групповой слой с данными из распарсенных настроек карты <Models>
WidgetMap.currentVectorGroupLayer = undefined;

var MIN_VISIBLE_RATIO = 0.001;
var MAX_LABEL_RATIO = 1.5;
var LABEL_FONT_RATIO = 0.9;
var LABEL_REPEAT_RATIO = 0.8;
var LABEL_CUT_TOLERANCE = 20;
var LABEL_CUT_RATIO = 0.3;
var LABEL_OFFSET = 0;
var LABEL_DRAW_TYPE = 'cut';

WidgetMap.getTreeMaximizedFlag = function () {
    if(getParameterByName('w') === '1')// && getParameterByName('task').toLowerCase() !== 'ili_widget')
        WidgetMap.showTree = false;
    return WidgetMap.showTree;
};

WidgetMap.getTreePercentWidth = function () {
    if (goog.isDefAndNotNull(WidgetMap.config)) {
        var treePercentWidth = WidgetMap.config.treePercentWidth;
        if (goog.isDef(treePercentWidth)) {
            var percentWidth = parseInt(treePercentWidth);
            if (!isNaN(percentWidth) && percentWidth >= 0 && percentWidth <= 100)
                return percentWidth;
        }
    }
    return -1; //Возвращаем -1 если значение не определено или не число
};

//Флаг, для первоначального отображения кнопки "показать трубопровод"
WidgetMap.getMapDrawParams = function(){
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    if (mapConfig) {
        if (mapConfig.MAP_Label_Len_Ratio !== undefined)
            MAX_LABEL_RATIO = parseFloat(mapConfig.MAP_Label_Len_Ratio);
        if (mapConfig.MAP_Len_Ratio !== undefined)
            MIN_VISIBLE_RATIO = parseFloat(mapConfig.MAP_Len_Ratio);
        if (mapConfig.MAP_Label_Font_Ratio !== undefined)
            LABEL_FONT_RATIO = parseFloat(mapConfig.MAP_Label_Font_Ratio);
        if (mapConfig.MAP_Label_Repeat_Ratio !== undefined)
            LABEL_REPEAT_RATIO = parseFloat(mapConfig.MAP_Label_Repeat_Ratio);
        if (mapConfig.MAP_Label_Cut_Tolerance !== undefined)
            LABEL_CUT_TOLERANCE = parseFloat(mapConfig.MAP_Label_Cut_Tolerance);
        if (mapConfig.MAP_Label_Cut_Ratio !== undefined)
            LABEL_CUT_RATIO = parseFloat(mapConfig.MAP_Label_Cut_Ratio);
        if (mapConfig.MAP_Label_Offset !== undefined)
            LABEL_OFFSET = parseFloat(mapConfig.MAP_Label_Offset);
        if (mapConfig.MAP_Label_Draw_Type !== undefined)
            LABEL_DRAW_TYPE = mapConfig.MAP_Label_Draw_Type;
        if (mapConfig.MAP_Use_Kinetic !== undefined && mapConfig.MAP_Use_Kinetic)
            WidgetMap.kinetic = new ol.Kinetic(-0.005, 0.05, 100);
        if (mapConfig.MAP_Matrix_DX !== undefined)
            MAP_MATRIX_DX = mapConfig.MAP_Matrix_DX;
        if (mapConfig.MAP_Matrix_DY !== undefined)
            MAP_MATRIX_DY = mapConfig.MAP_Matrix_DY;
        if (mapConfig.MAP_Num_Zoom_Levels !== undefined)
            WidgetMap.MAP_NUM_ZOOM_LEVELS = parseFloat(mapConfig.MAP_Num_Zoom_Levels);
        if (mapConfig.MAP_Centering_Min_Zoom !== undefined)
            App.config.MAP_CENTERING_MIN_ZOOM = parseFloat(mapConfig.MAP_Centering_Min_Zoom);
        _dx = MAP_MATRIX_DX;
        _dy = MAP_MATRIX_DY;
    }
};
WidgetMap.init = function () {
    CURRENT_MAP_TYPE = MAP_TYPE.SCHEMA;
    WidgetMap.getMapDrawParams();
    this.addMap();
    //загружаем дефолтные стили
    if(!goog.isDefAndNotNull(WidgetMap.layerManager))
        WidgetMap.layerManager = new LayerManager({layersReadyCallback:WidgetMap.layersAndStylesParsed});
    WidgetMap.layerManager.loadDefaultStyles('Default_STYLE.xml', "default_schema_style.xml");
    //добавляем базовый слой
    WidgetMap.addBaseLayer();
    this.addModelLayers();
    this.addMapSelectionLayer();
    WidgetMap.addBaseControls();
};

WidgetMap.addMap = function(){
    var mapX = WidgetMap.START_X;
    var mapY = WidgetMap.START_Y;
    var mapZoom = WidgetMap.START_ZOOM;
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    var position = mapConfig.position;
    //пытаемся читать из конфига
    if(position && ((position.x && position.y) || position.zoom)){
        if(goog.isDef(position.x))
            mapX = parseFloat(position.x);
        WidgetMap.START_X = mapX;
        if(goog.isDef(position.y))
            mapY = parseFloat(position.y);
        WidgetMap.START_Y = mapY;
        if(goog.isDef(position.zoom))
            mapZoom = parseFloat(position.zoom);
        WidgetMap.START_ZOOM = mapZoom;
        WidgetMap.canFirstTimeCentering = false;
    }
    //если в url лежат зум, центр, текущий режим, то меняем их
    if (getParameterByName('ll') !== '') {
        var splitterLL = getParameterByName('ll').split(',');
        if (goog.isDef(splitterLL[0]))
            mapX = parseFloat(splitterLL[0]);
        if (goog.isDef(splitterLL[1]))
            mapY = parseFloat(splitterLL[1]);
        WidgetMap.canFirstTimeCentering = false;
    }
    if (getParameterByName('z') !== '') {
        mapZoom = parseFloat(getParameterByName('z'));
        WidgetMap.canFirstTimeCentering = false;
    }

    var arr = [mapX, mapY];
    //устанавливаем дефолтные элементы взаимодействия
    var interactions = new ol.Collection();
    //устанавливаем базовое взаимодействие на карте
    WidgetMap.baseInteraction = new ol.interaction.DragPan({
        kinetic: (goog.isDef(WidgetMap.kinetic)) ? WidgetMap.kinetic : null
    });
    interactions.push(WidgetMap.baseInteraction);
    //зуммирование по колесику мыши
    interactions.push(new ol.interaction.MouseWheelZoom({
        duration: 0
    }));
    //перемещение по стрелкам
    interactions.push(new ol.interaction.KeyboardPan ());

    //proj4.defs("EPSG:5807","+title=Plan +units=m +no_defs ");
    var projection = new ol.proj.Projection({
        code: 'EPSG:5807',
        // The extent is used to determine zoom level 0. Recommended values for a
        // projection's validity extent can be found at http://epsg.io/.
        extent: [-10508.34,-10508.34,10508.34,10508.34],
        units: 'm'
    });
    ol.proj.addProjection(projection);
    var resolutions = MapUtil.setDefaultTechSchemaResolutions(WidgetMap.MAP_NUM_ZOOM_LEVELS);

    //устанавливаем карту
    WidgetMap.map = new ol.Map({
        target: 'map',
        renderer: 'canvas',
        ol3Logo: false,
        view: new ol.View({
            //maxZoom: WidgetMap.MAP_NUM_ZOOM_LEVELS,
            resolutions: resolutions,//ВАЖНО! если устанавливаем resolution, то maxZoom и minZoom игнорируются
            projection: WidgetMap.DEFAULT_PROJECTION,
            minZoom:4,
            center:arr,
            zoom: mapZoom
        }),
        interactions: interactions,
        controls:new ol.Collection()
    });

	//фокус на карту, чтобы при старте приложения были доступны кнопки перемещения карты
	$('#map').focus();
    function onPreCompose(evt) {
        _CURRENT_RENDERED_LAYERS = [];
        _CONTEXT = evt.context;
        _visibleMatrix = {};
        WidgetMap.regenerateMatrix('label');
    }
    function onPostCompose(evt) {
        /*if (_pointLabels.length > 0 && _LABELS.length == 0) {//если на экстенте карты нет точечных объектов
            _LABELS = _pointLabels;
        }
        else
            _pointLabels = _LABELS;

        var i = _LABELS.length - 1;
        for (i; i >= 0; i--) {
            _LABELS[i]['finded'] = false;
            _LABELS[i].hide = false;
        }
        //когда мы закончили рендерить, нужно отбросить неиспользуемые подписи
        var t = 0;
        if (_LABELS.length > 0) {
            for (t; t < _CURRENT_RENDERING_LAYERS.length; t++) {
                var i = _LABELS.length - 1;
                for (i; i >= 0; i--) {
                    if (_LABELS[i].unique.indexOf(_CURRENT_RENDERING_LAYERS[t]) != -1)
                        _LABELS[i]['finded'] = true;
                }
            }
        }

        //удаляем
        var i = _LABELS.length - 1;
        for (i; i >= 0; i--) {
            if (_LABELS[i].finded != true)
                _LABELS.splice(i, 1);
        }
        if (goog.isDef(WidgetMap.hideLabelsArr)) {
            var t = 0;
            for (t; t < WidgetMap.hideLabelsArr.length; t++) {
                var k = 0;
                for (k; k < _LABELS.length; k++) {
                    if (_LABELS[k].unique == WidgetMap.hideLabelsArr[t].unique) {
                        _LABELS[k].hide = true;
                        break;
                    }
                }
            }
        }
        if (_LABELS.length > 0) {
            var context = evt.context;
            var i = 0;
            for (i; i < _LABELS.length; i++) {
                var obj = _LABELS[i];
                //если есть флаг, то не отрисовываем подпись
                if (obj.hide == true)
                    continue;
                var coordsXY = WidgetMap.map.getPixelFromCoordinate([obj.coordX, obj.coordY]);
                coordsXY[0]*=getBrowserZoom();
                coordsXY[1]*=getBrowserZoom();
                obj.x = coordsXY[0] + obj.textStyle.offsetX_;
                obj.y = coordsXY[1] + obj.textStyle.offsetY_;

                context.font = obj.textStyle.getFont();
                //context.textAlign = obj.textStyle.getTextAlign();
                context.textBaseline = obj.textStyle.getTextBaseline();
                obj.localTransform = _TRANSFORM;
                if (obj.scale != 1 || obj.rotation !== 0) {
                    ol.vec.Mat4.makeTransform2D(
                        obj.localTransform, obj.x, obj.y, obj.scale, obj.scale, obj.rotation, -obj.x, -obj.y);
                    context.setTransform(
                        goog.vec.Mat4.getElement(obj.localTransform, 0, 0),
                        goog.vec.Mat4.getElement(obj.localTransform, 1, 0),
                        goog.vec.Mat4.getElement(obj.localTransform, 0, 1),
                        goog.vec.Mat4.getElement(obj.localTransform, 1, 1),
                        goog.vec.Mat4.getElement(obj.localTransform, 0, 3),
                        goog.vec.Mat4.getElement(obj.localTransform, 1, 3));
                }

                if (obj.stroke) {
                    context.lineWidth = 2;
                    context.strokeStyle = //obj.textStyle.getStroke().getColor();
                    context.strokeText(obj.text, obj.x, obj.y);
                }
                if (obj.fill) {
                    context.fillStyle = obj.textStyle.getFill().getColor();
                    context.fillText(obj.text, obj.x, obj.y);
                }
                if (obj.scale != 1 || obj.rotation !== 0) {
                    context.setTransform(1, 0, 0, 1, 0, 0);
                }
            }
        }*/
        _IS_FULL_REDRAW = false;
    }

    function onMoveEnd(evt) {
        _IS_FULL_REDRAW = true;
        _TEMP_LAYERS_LABELS = {};
    }

    WidgetMap.map.on('precompose', onPreCompose);
    WidgetMap.map.on('postcompose', onPostCompose);
    //TODO такое же событие повесить на движение обзорной карты
    WidgetMap.map.on('moveend', onMoveEnd);

    WidgetMap.mapHistory = new MapHistory({map:WidgetMap.map});

    //добавляем на карту листенер по esc, отменять все интеракции и включать ладошку
    $('body').on('keyup',function(event){
        if(event.keyCode == 27 && WidgetMap.currentMapButtonState != WidgetMap.MAP_BUTTON_STATE.PAN){
            if(goog.isDef(WidgetMap.baseInteraction) && goog.isDef(WidgetMap.baseInteraction.box_)){
                WidgetMap.baseInteraction.box_.setMap(null);
            }
            WidgetMap.handleEscClick_();
        }
    });

};

//создаем 2 флага, чтобы различать, было ли просто вкл/выкл видимости из рубрикатора или движение карты
var _TEMP_LAYERS_LABELS = {};// временные подписи, если просто вкл/выкл видимость слоя
var _IS_CHANGE_LAYER_VISIBILITY = {};//заносим сюда подписи из отдельных слоев
var _IS_FULL_REDRAW = false; // в этом случае перерисовывается все векторы, т.к. зхуммировались или т.п.

var _CURRENT_RENDERED_LAYERS = [];

WidgetMap.stubMatrixLayer = undefined;
WidgetMap.stubTextLayer = undefined;
createTextExtentLayer = function(){
    if(!WidgetMap.stubTextLayer){
        WidgetMap.stubTextLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
            id: 'stubTextLayer',
        });
        WidgetMap.map.addLayer(WidgetMap.stubTextLayer);
    }
};
generateStubMatrixLayer = function(){
    if(!WidgetMap.stubMatrixLayer){
        WidgetMap.stubMatrixLayer = new ol.layer.Vector({
            source: new ol.source.Vector(),
            id: 'stubMatrixLayer',
        });
        WidgetMap.map.addLayer(WidgetMap.stubMatrixLayer);

    }
    WidgetMap.stubMatrixLayer.getSource().clear()
    var lineMatrixGeo = new ol.geom.MultiLineString(null);
    //формируем линии матрицы
    //_visibleTextMatrix['kap_remont_label']
    //добавляем вертикальные
    for(var i = 0; i < 200; i++){
        var pntLeft = [0, i * _dx];
        var pntRight = [200 * _dx, i * _dx];
        pntLeft = WidgetMap.map.getCoordinateFromPixel(pntLeft);
        pntRight = WidgetMap.map.getCoordinateFromPixel(pntRight);
        var lineAddGeo = new ol.geom.LineString([pntLeft,pntRight],ol.geom.GeometryLayout.XY);
        //Добавляем незаметные линии по вертикали, чтобы удобнее было просматривать километры
        lineMatrixGeo.appendLineString(lineAddGeo);
    }
    //горизонтальные линии
    for(var j = 0; j < 200; j++){
        var pntTop = [j * _dx, 0];
        var pntBottom = [j * _dx, 200 * _dy];
        pntTop = WidgetMap.map.getCoordinateFromPixel(pntTop);
        pntBottom = WidgetMap.map.getCoordinateFromPixel(pntBottom);
        var lineAddGeo = new ol.geom.LineString([pntTop,pntBottom],ol.geom.GeometryLayout.XY);
        //Добавляем незаметные линии по вертикали, чтобы удобнее было просматривать километры
        lineMatrixGeo.appendLineString(lineAddGeo);
    }

    var lineMatrixGeoFtr = new ol.Feature(lineMatrixGeo);
    lineMatrixGeoFtr.setStyle(function(){ //стили ПКА берем за основу полувидимых линий
            var s = WidgetMap.layerManager.getStyleByNameAndType('CAS_LIGHT_AXES', 'LineString');
            if(!goog.isNull(s)) {
                if (goog.isArray(s))
                    return [s];
                return [s];
            }
        }
    );
    WidgetMap.stubMatrixLayer.getSource().addFeature(lineMatrixGeoFtr);
}

WidgetMap.regenerateMatrix = function(layerId){
    //Значение ширины, которое добавляется к матрице слева и справа,
    //чтобы при разрядке точечные объекты не пропадали как только их центр выйдет за границы карты
    var matrixAddWidth = _dx;
    //Значение высоты, которое добавляется к матрице сверху и снизу,
    //чтобы при разрядке точечные объекты не пропадали как только их центр выйдет за границы карты
    var matrixAddHeight = _dy;
    //Расширяем матрицу при генерации, чтобы не происходила разрядка точечных объектов, центр которых вышел за границу но часть объекта должна отображаться
    var i = Math.ceil((WidgetMap.map.getSize()[0] + matrixAddWidth * 2) / _dx);
    var j = Math.ceil((WidgetMap.map.getSize()[1] + matrixAddHeight * 2) / _dy);
    _visibleMatrix[layerId] = new Array(i);
    var k = 0;
    for (k; k < i; k++){
        _visibleMatrix[layerId][k] = new Array(j);
    }
    if(layerId === 'label' || layerId === 'kap_remont_label'){
        i = Math.ceil((WidgetMap.map.getSize()[0] + matrixAddWidth * 2) / _dx);
        j = Math.ceil((WidgetMap.map.getSize()[1] + matrixAddHeight * 2) / _dy);
        _visibleTextMatrix[layerId] = new Array(i);
        for (k = 0; k<i; k++){
            _visibleTextMatrix[layerId][k] = new Array(j);
        }
    }
    return;
    generateStubMatrixLayer();
    createTextExtentLayer();
};

WidgetMap.addModelLayers = function(){
    if(!goog.isDef(WidgetMap.currentVectorGroupLayer)) {
        //добавляем групповой слой на карту
        WidgetMap.currentVectorGroupLayer = new ol.layer.Group();
        WidgetMap.map.addLayer(WidgetMap.currentVectorGroupLayer);

        if(!goog.isDefAndNotNull(WidgetMap.layerManager))
            WidgetMap.layerManager = new LayerManager();

        var models = WidgetMap.config.vectorlayers;
        //оставляем пока вектор. Быстрые кеши пока не используем, т.к. запросы могут подтормаживать систему
        WidgetMap.isModelsVector = true;
        var mapOrder = 0;
        for(var i=0;i < models.length; i++){
            var modelName = models[i];
            var name = modelName.replace('_Layers.xml','');
            if (goog.isDefAndNotNull(name)) {
                WidgetMap.layerManager._vectorMapOrders[name] = mapOrder++;
                WidgetMap.layerManager.parseLayersDescr(modelName);
            }
        }
    }
};

WidgetMap.createVectorLayer = function(){
    //добавляем на карту векторный слой для рисования
    var source = new ol.source.Vector();
    WidgetMap.currentVectorLayer = new ol.layer.Vector({
        source: source
    });
    WidgetMap.map.addLayer(WidgetMap.currentVectorLayer);
};

/**
 * Получить зум для переданного экстента
 * @param extent
 * @returns {number}
 */
WidgetMap.getZoomForExtent = function(extent){
    var viewSize =  WidgetMap.map.getSize();
    var idealResolution ;//= Math.max(extent[0]/viewSize[0],extent[1] / viewSize[1]);
    var view = WidgetMap.map.getView();
    var RESOLUTION_TOLERANCE = 0.000001;
    idealResolution = Math.max(ol.extent.getWidth(extent)/ viewSize[0], ol.extent.getHeight(extent) / viewSize[1]);//view.getResolutionForExtent(extent,viewSize);
    var offset;
    var resolution = idealResolution;

    if (goog.isDef(resolution)) {
        var res, z = 0;
        do {
            res = view.constrainResolution(view.maxResolution_, z);
            if (res < resolution && Math.abs(res - resolution) > RESOLUTION_TOLERANCE) {
                offset = z;
                break;
            }
            ++z;
        } while (res > view.minResolution_);
    }
    return z + view.minZoom_ - 1;//view.maxResolution_ соответствует minZoom, поэтому добавляем. И отнимаем 1, как во флеш
};

/**
 * Получить зум для переданной resolution
 * @param extent
 * @returns {number}
 */
WidgetMap.getZoomForResolution = function(resolution){
    var offset;
    var view = WidgetMap.map.getView();
    if (goog.isDef(resolution)) {
        var res, z = 0;
        do {
            res = view.constrainResolution(view.maxResolution_, z);
            if (res == resolution) {
                offset = z;
                break;
            }
            ++z;
        } while (res > view.minResolution_);
    }

    return goog.isDef(offset) ? view.minZoom_ + offset : offset;
};

/**
 * Слой для выделения объектов на карте
 *
 */
WidgetMap.addMapSelectionLayer = function(){
    if(goog.isDef(WidgetMap.map)) {
        try {
            var vector = new ol.layer.Vector({
                source: new ol.source.Vector({
                })
            });
            this.mapSelectionLayer = vector;
            WidgetMap.map.addLayer(this.mapSelectionLayer);
        }
        catch (ex) {
        }
    }
};


WidgetMap.addBaseControls = function(){
    try{
	    var hideButtons = ru.corelight.classes.map.BaseWidget.getHideButtonsConfig();
        //иконка лоадинга процесса загрузки геометрий
        WidgetMap.geometryLoaderControl = new map.controls.GeometryLoaderControl({loadingText:gis_loadercontrol_1});
        WidgetMap.map.addControl(WidgetMap.geometryLoaderControl);
        WidgetMap.geometryLoaderControl.setVisible(false);
        if (hideButtons.indexOf("PrevSite") === -1) {
            WidgetMap.map.addControl(new map.controls.PreviousSiteControl());
        }
        if(WidgetMap.config && WidgetMap.config.open_task && WidgetMap.config.open_task && WidgetMap.config.open_task.url && WidgetMap.config.open_task.text)
            if (hideButtons.indexOf("FastTask") === -1) {
                WidgetMap.map.addControl(new map.controls.FastTaskAccessControl({
                    url: WidgetMap.config.open_task.url,
                    text: WidgetMap.config.open_task.text,
                    target: WidgetMap.config.open_task.target,
                }));
            }
	    if (hideButtons.indexOf("Pan") === -1) {
		    WidgetMap.panControl = new map.controls.PanControl();
		    WidgetMap.map.addControl(WidgetMap.panControl);
	    }
        //добавляем контролы для зуммирования
        if (hideButtons.indexOf("ZoomBox") === -1)
            WidgetMap.map.addControl(new map.controls.ZoomBoxControl());

        if (hideButtons.indexOf("ZoomSlider") === -1) {
            WidgetMap.map.addControl(new map.controls.ZoomControl());
            WidgetMap.zoomSliderControl = new map.controls.ZoomSliderControl();
            WidgetMap.map.addControl(WidgetMap.zoomSliderControl);
        }
        if (hideButtons.indexOf("MapInfo") === -1) {
            WidgetMap.infoControl = new map.controls.MapInfoControl();
            WidgetMap.map.addControl(WidgetMap.infoControl);
            /*WidgetMap.infoControl = new map.controls.MapInfoV7Control();
            WidgetMap.map.addControl(WidgetMap.infoControl);
            WidgetMap.infoControl.handleMapInfoClick_();*/
        }
        if (hideButtons.indexOf("ExportImageChooser") === -1) {
            var needExport = hideButtons.indexOf("ExportImage") === -1;
            var needPrint = hideButtons.indexOf("PrintImage") === -1;
            WidgetMap.exportImageChooserControl = new map.controls.ExportImageChooserControl({noElement: (!needExport && !needPrint)});
            WidgetMap.map.addControl(WidgetMap.exportImageChooserControl);
            WidgetMap.exportImageControl = new map.controls.ExportImageControl({needExport:needExport, needPrint:needPrint});
            WidgetMap.map.addControl(WidgetMap.exportImageControl);
        }
        if (hideButtons.indexOf("MapViewChooser") === -1) {
            if (hideButtons.indexOf("ClearCosmetic") === -1) {
                WidgetMap.map.addControl(new map.controls.ClearCosmeticV7Control({noElement: true}));
            }
            if (hideButtons.indexOf("FullMap") === -1) {
                WidgetMap.fullMap = new map.controls.FullMapControl({noElement: true});
                WidgetMap.map.addControl(WidgetMap.fullMap);
            }

            if(hideButtons.indexOf("History") === -1){
                WidgetMap.history = new map.controls.HistoryControl({mapHistory: WidgetMap.mapHistory, noElement: true});
                WidgetMap.map.addControl(WidgetMap.history);
            }
            var needClearCosmetic = hideButtons.indexOf("ClearCosmetic") === -1;
            var needFullMap = hideButtons.indexOf("FullMap") === -1;
            var needPrevView = hideButtons.indexOf("PrevView") === -1;
            var needNextView = hideButtons.indexOf("NextView") === -1;
            var needWms = hideButtons.indexOf("Wms") === -1;
            WidgetMap.viewMapChoose = new map.controls.MapViewChooserControl({noElement:(!needClearCosmetic && !needFullMap && !needPrevView && !needNextView && !needWms)});
            WidgetMap.viewMap = new map.controls.MapViewControl({
                needClearCosmetic:needClearCosmetic,
                needFullMap:needFullMap,
                needPrevView:needPrevView,
                needNextView:needNextView,
                needWms:needWms
            });
            WidgetMap.map.addControl(WidgetMap.viewMap);
            WidgetMap.map.addControl(WidgetMap.viewMapChoose);
        }
        if (hideButtons.indexOf("ShareChooser") === -1) {
            var needLink = hideButtons.indexOf("LinkMap") === -1;
            var needSendMail = hideButtons.indexOf("SendMail") === -1;
            if (needLink){
                WidgetMap.linkMap = new map.controls.LinkMapControl({noElement: true});
                WidgetMap.map.addControl(WidgetMap.linkMap);
            }

            if(needSendMail) {
                WidgetMap.sendMail = new map.controls.SendMailControl({noElement: true});
                WidgetMap.map.addControl(WidgetMap.sendMail);
            }
            WidgetMap.shareChoose = new map.controls.ShareChooserControl({noElement:(!needLink && !needSendMail)});
            WidgetMap.share = new map.controls.ShareControl({needLink:needLink, needSendMail:needSendMail});
            WidgetMap.map.addControl(WidgetMap.share);
            WidgetMap.map.addControl(WidgetMap.shareChoose);
        }

        if (hideButtons.indexOf("DSP") === -1)
            WidgetMap.map.addControl(new map.controls.DSPControl());

    }
    catch(ex){
        App.errorReport('Ошибка при добавлении кнопок на карту: '+ ex, ex );
    }
};

/**
 * TODO перевести на вызов события
 * @param currentState  WidgetMap.MAP_BUTTON_STATE
 * @param currentButton  Текущий контрол, чтобы, по возможности, мы могли его удалить с карты
 */
WidgetMap.changeToolState = function (currentState, currentButton) {
    if (goog.isDef(WidgetMap.selectedMapButton))
        $(WidgetMap.selectedMapButton).removeClass('selectedMapButton');
    switch (currentState) {
        case WidgetMap.MAP_BUTTON_STATE.PAN:
            WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.PAN;
            map.controls.ZoomBoxControl.reset();
            break;
        case WidgetMap.MAP_BUTTON_STATE.ZOOM:
            WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.ZOOM;
            map.controls.PanControl.reset();
            break;
    }
    if (currentButton)
        $(currentButton).addClass('selectedMapButton');
    WidgetMap.selectedMapButton = currentButton;
};

WidgetMap.isCheckedExternalParamsFromURL = false;

//когда мы распарсили всё, то смотрим на урл и забирает objects, lineId,..
WidgetMap.layersAndStylesParsed = function(){
    if(goog.isDef(WidgetMap.layerManager)){
        if(WidgetMap.layerManager._rasterLayersQuery == 0 &&
            WidgetMap.layerManager._layersQuery == 0 &&
            WidgetMap.layerManager._styleQuery == 0){
            WidgetMap.checkExternalParamsFromURL();

            MapUtil.reorderVectorLayers();
            //грузим данные для всех видимых слоёв
            WidgetMap.loadAllLayersData();

            //устанавливаем в кнопку с базовыми слоями грид с векторными
            if(goog.isDef(WidgetMap.baseLayersControl))
                WidgetMap.baseLayersControl.setVectorLayers();

            //проверяем наличие параметров, пришедших из внешней системы
            // ИЗ widgetMap
            /*if(!WidgetMap.isCheckedExternalParamsFromURL)
                WidgetMap.checkExternalParamsFromURL();
            WidgetMap.isCheckedExternalParamsFromURL = true;*/
        }
    }
};


/**
 * Проверяем, есть ли в url параметры, пришедшие из внешней системы
 * Если есть, то работаем через externalFunctionaAPI
 */
WidgetMap.checkExternalParamsFromURL = function(){
    if(! WidgetMap.currentTopFilter) WidgetMap.currentTopFilter = [];
    if(getParameterByName('BEGIN_MEASURE') !== ''){
        WidgetMap.BEGIN_MEASURE = getParameterByName('BEGIN_MEASURE');
        WidgetMap.currentTopFilter.push({name:'BEGIN_MEASURE', value:WidgetMap.BEGIN_MEASURE});
    }

    if(getParameterByName('END_MEASURE') !== ''){
        WidgetMap.END_MEASURE = getParameterByName('END_MEASURE');
        WidgetMap.currentTopFilter.push({name:'END_MEASURE', value:WidgetMap.END_MEASURE});
    }

    if(getParameterByName('ROUTE_ID') !== ''){
        WidgetMap.ROUTE_ID = getParameterByName('ROUTE_ID');
        WidgetMap.currentTopFilter.push({name:'ROUTE_ID', value:WidgetMap.ROUTE_ID});
    }

    if(getParameterByName('SHEET_ID') !== ''){
        WidgetMap.SHEET_ID = getParameterByName('SHEET_ID');
        WidgetMap.currentTopFilter.push({name:'SHEET_ID', value:WidgetMap.SHEET_ID});
    }

    if(getParameterByName('ILI_INSPECTION_ID') !== ''){
        WidgetMap.ILI_INSPECTION_ID = getParameterByName('ILI_INSPECTION_ID');
        WidgetMap.currentTopFilter.push({name:'ILI_INSPECTION_ID', value:WidgetMap.ILI_INSPECTION_ID});
    }





};



WidgetMap.loadAllLayersData = function(){
    if(WidgetMap.isModelsVector == true){
        var layers = WidgetMap.layerManager.getAllLayers();//все векторые слои
        WidgetMap.layerManager.currentLoadingCacheIds = layers.length;
        var i;
        try{
            var filter = $('#treeDiv').myCategories('callbackFilter', {params: {windowId: ''}});
            WidgetMap.updateTopFilter(filter.params);
        }
        catch(ex){}
        for(i in layers){
            var layerObj = layers[i];
            if(layerObj.visible === 'true' || layerObj.visible == true){
                WidgetMap.layerManager.enableLayer(layerObj.id);
            }
            else{
                --WidgetMap.layerManager.currentLoadingCacheIds;
                WidgetMap.layerManager.disableLayer(layerObj.id);
            }
            //привязываем событие, чтобы мониторить, нужно ли подгружать данные для слоев
            if(goog.isDef(layerObj.layer))
                layerObj.layer.bindDataRequest();
        }
    }
};

WidgetMap.updateTopFilter = function(params){

};

/**
 * Сентрируемся на карте по экстенту
 * @param extent экстент текущей геометрии
 */
WidgetMap.centerOnMap = function(extent){
    if (App.config.MAP_CENTERING_MIN_ZOOM === undefined){
		App.errorReport(gis_core_17, 'MAP_CENTERING_MIN_ZOOM' + gis_core_18, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_13'});
        return;
    }
    var minZoom = App.config.MAP_CENTERING_MIN_ZOOM;
    if(goog.isDef(minZoom) && goog.isNumber(parseFloat(minZoom)) && parseFloat(minZoom) > 0 && WidgetMap.getZoomForExtent(extent) >= parseFloat(minZoom)){
        map.controls.FullMapControl.prototype.centerOn_(ol.extent.getCenter(extent),minZoom);
    }
    else{
        WidgetMap.map.getView().fit(extent, WidgetMap.map.getSize());
    }
};

WidgetMap.addBaseLayer = function () {
    if (WidgetMap.map) {
        try {
            //добавляем базовые слои на карту
            if(WidgetMap.BaseLayersParser)
                WidgetMap.map.addLayer(WidgetMap.BaseLayersParser.currentBaseLayers);
            //добавляем кнопку на карту
            WidgetMap.baseLayersControl = new map.controls.LayersControl({baseLayers:WidgetMap.BaseLayersParser.rasterLayers});
            WidgetMap.map.addControl(WidgetMap.baseLayersControl);
        }
        catch (ex) {
        }
    }
};


/**
 * Подсветить на карте выбранные объекты
 * @param layerName
 * @param layerIds
 * @param showObjectsIsGroupButton
 * @param showObjectsErrorHandler
 * @param showObjectError
 * @param showObjectNoDataError
 */
WidgetMap.highlightFeatures = function (layerName, layerIds, that, findCallback) {
    var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
    if (goog.isDef(layerObj) && goog.isDef(layerObj.layer)) {
        if (!layerObj.layer.hasData) {//если данных нет в слое вообще
            MapUtil.showObjectError(that, layerObj, this);
            return;
        }
        var features = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(layerObj.layer, layerIds);
        MapUtil.clearSelectionLayer();
        if (features.length == 0) {
            /*if(showObjectsIsGroupButton == true)//если нажата была групповая кнопка, то не показываем ошибки
			 return;*/
            if(findCallback)
                findCallback(false);
            else
                MapUtil.showObjectError(that, layerObj, this);
        }
        else {
            if(findCallback)
                findCallback(true);
            WidgetMap.mapSelectionLayer.getSource().addFeatures(features);
            var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
            //прячем подписи для слоя
            WidgetMap.hideLabels(layerName, layerIds);
            if (that.showObjectsCentering)
                WidgetMap.centerOnMap(extent);
        }
    }
};
//прячем подписи по инциденту #1505
WidgetMap.hideLabels = function (layerName, objects) {
    var layer = WidgetMap.layerManager.getLayerByName(layerName);
    if (goog.isDef(layer) && goog.isDef(layer.layer)) {
        //проходим по всем фичам и забираем по id Объекта геометрию из _globalPointLabels,
        var features = layer.layer.featureProjLayer.getSource().getSource().getFeatures();
        var i = 0;
        var j = 0;
        var hideGeos = [];
        for (j; j < objects.length; j++) {
            i = 0;
            for (i; i < features.length; i++) {
                //ищем только в multiPoint
                var oId = objects[j];
                if (features[i].getGeometry().getType() == ol.geom.GeometryType.MULTI_POINT && goog.isDef(features[i].get('pointsObj')) && goog.isDef(features[i].get('pointsObj')[oId])) {
                    var coords = features[i].get('pointsObj')[oId].flatCoordinates;
                    hideGeos.push({id: oId, unique: features[i].get('labelType') + '_' + coords[0] + '_' + coords[1]});
                }
            }
        }
        WidgetMap.hideLabelsArr = hideGeos;
        layer.layer.featureProjLayer.changed();
    }
};


/* TODO надо будет перенести подобные функции в некий mapUtil или ещё какой-нибудь хелпер */
/**
 *
 * @param params
 * @param clearSelectionLayer - флаг, нужно ли чистить слой с выделениями   TODO Используется?
 * @param isCurrentTab - центровка происходит в текущей вкладке?
 * @param findCallback коллбек найденного объекта
 */
WidgetMap.showObjects = function (params, clearSelectionLayer, ignoreErrors, isCurrentTab, findCallback) {
    var that = this;
    that.showObjectsCentering = true;
    that.showObjectsSelect = true;
    that.showObjectsValue = '';
    that.showObjectsGeo = undefined;
    that.showObjectsLayerDescr = '';
    that.showObjectError = '';
    that.showObjectsIsGroupButton = true;
    that.showObjectsErrorHandler = undefined;
    that.showObjectsFromFilter = false;
    that.ignoreErrors = false;
    that.loadDynamicData = true;
    that.isCurrentTab = isCurrentTab === true;

    var i = 0;
    for (i; i < params.length; i++) {
        var objects = params[i];
        if (objects.name == "objects") {
            that.showObjectsValue = objects.value;
            if (goog.isDef(objects.geo))
                that.showObjectsGeo = objects.geo;
        }
        if (objects.name == "centering")  that.showObjectsCentering = (objects.value == 'true' || objects.value == true);
        if (objects.name == "select") that.showObjectsSelect = (objects.value == 'true' || objects.value == true);
        if (objects.name == "gridCenteringResultFunction") that.showObjectsErrorHandler = objects.value;
        if (objects.name == "isGroupButton") that.showObjectsIsGroupButton = (objects.value == 'true' || objects.value == true);
        if (objects.name == "fromFilter") that.showObjectsFromFilter = (objects.value == 'true' || objects.value == true);
        if (objects.name == "ignoreErrors") that.ignoreErrors = (objects.value == 'true' || objects.value == true);
        if (objects.name == "loadDynamicData") that.loadDynamicData = (objects.value == 'true' || objects.value == true);
    }
    if (that.showObjectsValue != '') {
        var arr = that.showObjectsValue.split(':');
        var layerName = arr[0];
        var layerIds = arr[1].split(',');//array
        var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
        //если слоя нет в _rasterLayers
        var isRasterLayer = false;
        var layerRasterObj = WidgetMap.layerManager.getRasterLayerByName(layerName);
        if (goog.isDef(layerRasterObj) && WidgetMap.CURRENT_MODE === WidgetMap.MODES.RASTER)
            isRasterLayer = true;
        if (goog.isDef(layerObj) && goog.isDef(layerObj.layer))
            that.showObjectsLayerDescr = layerObj.layer.sourceDescr;
        else {
            if(!that.ignoreErrors)
                App.errorReport(gis_widgetmap_1, gis_widgetmap_6, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_5'});
            return;
        }
        if (goog.isDef(that.showObjectsGeo)) {
            if(clearSelectionLayer !== false)
                MapUtil.clearSelectionLayer();
            //переустанавливаем стиль у клона геометрии на тот, дефолтный для выделения
            WidgetMap.layerManager.defaultSelectionStyle(that.showObjectsGeo);

            WidgetMap.mapSelectionLayer.getSource().addFeature(that.showObjectsGeo);
            //добавляем выбранный объект в глобальную переменную
            WidgetMap.mapSelectedObject = that.showObjectsValue;
            if(clearSelectionLayer !== false)
                WidgetMap.hideLabels(layerName, layerIds);
            //зуммируемся к ним
            if (that.showObjectsCentering) {
                var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
                WidgetMap.centerOnMap(extent);
            }
            return;
        }
        //формируем строку ошибочную, если не найдем геометрию
        that.showObjectError = gis_widgetmap_3 + ': ' + that.showObjectsLayerDescr + gis_widgetmap_23 + that.showObjectsLayerDescr + gis_widgetmap_24 + arr[1];
        if (that.showObjectsFromFilter == true)
            that.showObjectError = gis_widgetmap_4 + gis_widgetmap_23 + that.showObjectsLayerDescr + gis_widgetmap_24 + arr[1];
        that.showObjectNoDataError = gis_widgetmap_5 + ': ' + that.showObjectsLayerDescr;


        //TODO сделать кооректным поведение при подсветке вектора, растра
        //1. при растре должен идти запрос на геометрию и она подсвечиваться на карте
        //3. для вектора поиск в уже пришедшей геометрии
        //var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
        //вариант в вектором
        //LogUtil.sendLog('$$ isModelsVector isRasterLayer=' +isRasterLayer);
        if(that.isCurrentTab/* && layerObj.layer.filter === undefined*/)
            that.loadDynamicData = true;
        if (WidgetMap.isModelsVector == true && goog.isDef(layerObj) && goog.isDef(layerObj.layer.zIndex) && !isRasterLayer) {//zindex - только в векторных слоях есть, либо использовать другой параметр
            if (layerObj.visible ) {
                //если не нашли из фильтров, то не показываем сообщение об ошибке

                if (layerObj.layer.dataReady_ == false) {
                    if(that.loadDynamicData) {
                        layerObj.layer.layerLoadCallback = function (result) {
                            layerObj.layer.layerLoadCallback = undefined;
                            //LogUtil.sendLog('$$ layerLoadCallback');
                            if (that.showObjectsSelect) {
                                if (that.showObjectsFromFilter == true && layerIds.length == 1 && layerIds[0] == '')
                                    return;
                                WidgetMap.highlightFeatures(layerName, layerIds, that, findCallback);
                            } else {
                                WidgetMap.selectFeatures(layerName, layerIds, that, findCallback);
                            }
                            WidgetMap.mapSelectedObject = that.showObjectsValue;
                        };
                        layerObj.layer.loadData(true);//форсируем загрузку данных, если текущий масштаб не попал в проверку отрисовки по стилям
                    }
                }
                else {
                    //ищем геометрии, выделяем по ним и, если надо, центрируемся
                    //нужно разделить ids с PODS_COMPRESSOR_STATION:13001654,13001655 на массив PODS_COMPRESSOR_STATION/13001654, PODS_COMPRESSOR_STATION/13001655
                    //LogUtil.sendLog('$$ dataReady_= true');
                    if (that.showObjectsSelect){
                        if (that.showObjectsFromFilter == true && layerIds.length == 1 && layerIds[0] == '')
                            return;
                        WidgetMap.highlightFeatures(layerName, layerIds, that, findCallback);
                    }
                    else{
                        WidgetMap.selectFeatures(layerName, layerIds, that, findCallback);
                    }
                    WidgetMap.mapSelectedObject = that.showObjectsValue;
                }
            }
            else {
                if (that.showObjectsFromFilter == true)
                    return;
                if(that.ignoreErrors)// если центровка синхронизации не в текущей вкладке, то не включаем слой
                    return;
                //добавляем callback, чтобы после загрузки прицентрироваться
                if (layerObj.layer.dataReady_ == false) {
                    if(that.loadDynamicData) {
                        layerObj.layer.layerLoadCallback = function (result) {
                            //LogUtil.sendLog('$$ raster layerLoadCallback');
                            layerObj.layer.layerLoadCallback = undefined;
                            if (that.showObjectsSelect) {
                                if (that.showObjectsFromFilter == true && layerIds.length == 1 && layerIds[0] == '')
                                    return;
                                WidgetMap.highlightFeatures(layerName, layerIds, that, findCallback);
                            } else
                                WidgetMap.selectFeatures(layerName, layerIds, that, findCallback);
                            WidgetMap.mapSelectedObject = that.showObjectsValue;
                        };
                        WidgetMap.layerManager.enableLayer(layerName);
                    }
                }
                else {
                    //LogUtil.sendLog('$$ raster dataReady_= true');
                    if(that.loadDynamicData  || that.isCurrentTab) {
                        WidgetMap.layerManager.enableLayer(layerName);
                        //нужно разделить ids с PODS_COMPRESSOR_STATION:13001654,13001655 на массив PODS_COMPRESSOR_STATION/13001654, PODS_COMPRESSOR_STATION/13001655
                        if (that.showObjectsSelect) {
                            if (that.showObjectsFromFilter == true && layerIds.length == 1 && layerIds[0] == '')
                                return;
                            WidgetMap.highlightFeatures(layerName, layerIds, that, findCallback);
                        } else
                            WidgetMap.selectFeatures(layerName, layerIds, that, findCallback);
                        WidgetMap.mapSelectedObject = that.showObjectsValue;
                    }
                }
            }
        }
        else {
            //запрос геометрии
            var spatialRequest = layerObj.dataProvider.spatial;
            if (that.showObjectsIsGroupButton == false) {
                getLayerGeoRequest(layerIds, spatialRequest,layerObj);
            }
            else {
                getLayerGroupGeoRequest(layerIds, spatialRequest);
            }
        }
    }

    function getLayerGeoReqParams(filter, request) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' +
                '<data FILTER="' + filter + '"/>' +
                '</root>'
        };
    }


    function getLayerGeoRequest(filter, request, layerObj) {
        var filterStr = generateFilterStr(filter);
        App.serverQueryXMLNodeWithTries(Services.processQueryNodeGeo, getLayerGeoReqParams(filterStr, request), getLayerGeoResult, getLayerGeoFault,4);


        function getLayerGeoResult(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') {
                App.errorReport(gis_core_error_1, ex, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_8'});
                MapUtil.showObjectError(that, layerObj, this);
                return;
            }
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                //var resultXml = WidgetMap.getStubPolygon();
                var layerGeoXml = ($.parseXML(resultXml)).firstChild;
                var datas = layerGeoXml.getElementsByTagName("data");
                if(clearSelectionLayer !== false)
                    MapUtil.clearSelectionLayer();
                if (datas.length == 0) {
                    if (that.showObjectsIsGroupButton == true)//если нажата была групповая кнопка, то не показываем ошибки
                        return;
                    MapUtil.showObjectError(that, layerObj, this);
                    return;
                }
                var stride = 2;
                for (var i = 0; i < datas.length; i++) {
                    //парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
                    var format = new ol.format.WKT({dimension: stride});
                    var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
                    var feature = undefined;
                    try {
                        feature = format.readFeature(wktStr);
                    }
                    catch (ex) {
                        //для случая с видеозаписями, приходит 3 координаты
                        stride = 3;
                        format = new map.format.WKT({dimension: stride});
                        feature = format.readFeature(wktStr);
                    }
                    if (goog.isDef(feature)) {
                        //забираем координаты и переводим их в нормальную проекцию
                        var flatCoordinates = feature.getGeometry().flatCoordinates;
                        if (flatCoordinates.length > 1 && flatCoordinates[0] != -1 && flatCoordinates[1] != -1) {
                            //устанавливаем в фичу стиль дефолтный
                            if (stride == 3) {
                                var newArr = [];
                                for (var j = 0; j < flatCoordinates.length; j += stride) {
                                    var lng = flatCoordinates[j];
                                    var lat = flatCoordinates[j + 1];
                                    newArr.push(lng);
                                    newArr.push(lat);
                                }
                                //геометрия выделяемого участка трубопровода
                                var geometry = new ol.geom.LineString(null);
                                geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY, newArr);
                                var newLineFeature = new ol.Feature(geometry);
                                WidgetMap.layerManager.defaultSelectionStyle(newLineFeature);
                                GeoUtil.convertFeature(newLineFeature, App.projection, WidgetMap.DEFAULT_PROJECTION);
                                WidgetMap.mapSelectionLayer.getSource().addFeature(newLineFeature);
                            }
                            else {
                                WidgetMap.layerManager.defaultSelectionStyle(feature);
                                GeoUtil.convertFeature(feature, App.projection, WidgetMap.DEFAULT_PROJECTION);
                                WidgetMap.mapSelectionLayer.getSource().addFeature(feature);
                            }
                            //добавляем выбранный объект в глобальную переменную
                            WidgetMap.mapSelectedObject = that.showObjectsValue;
                        }
                        else {
                            //if(that.showObjectsIsGroupButton == true)//если нажата была групповая кнопка, то не показываем ошибки
                            //    continue;
                            MapUtil.showObjectError(that, layerObj, this);
                            return;
                        }
                    }
                }
                //зуммируемся к ним
                var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
                if (that.showObjectsCentering) {
                    WidgetMap.centerOnMap(extent);
                }
            }catch(ex){
                App.errorReport(gis_core_error_1, ex, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_3'});
                MapUtil.showObjectError(that, layerObj, this);
            }
        }

        function getLayerGeoFault(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '')
                App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_4'});
            MapUtil.showObjectError(that, layerObj, this);
        }

        function generateFilterStr(filter) {
            return "ID in (" + filter.join(",") + ")";
        }
    }

    function getLayerGroupGeoRequest(filter, request) {
        if(clearSelectionLayer !== false)
            MapUtil.clearSelectionLayer();
        var filterCount = filter.length;
        var features = [];//все фичи, полученные после группового запроса
        for (var fi in filter) {
            var filterStr = generateFilterStr([filter[fi]]);
            App.serverQueryXMLNodeWithTries(Services.processQueryNodeGeo, getLayerGeoReqParams(filterStr, request), getLayerGeoResult, getLayerGeoFault,4);
        }

        function getLayerGeoResult(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er === '') { // Иногда ответ в формате XML, а иногда в виде просто строки
                var layerGeoXml = ($.parseXML(resultXml)).firstChild;
                var datas = layerGeoXml.getElementsByTagName("data");
                --filterCount;
                if (datas.length != 0) {
                    var stride = 2;
                    for (var i = 0; i < datas.length; i++) {
                        //парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
                        var format = new ol.format.WKT({dimension: stride});
                        var wktStr = datas[i].getAttribute("WKT");
                        var idStr = datas[i].getAttribute("ID");///;"POINT(-1 -1)";
                        var feature = undefined;
                        try {
                            feature = format.readFeature(wktStr);
                        }
                        catch (ex) {
                            //для случая с видеозаписями, приходит 3 координаты
                            stride = 3;
                            format = new map.format.WKT({dimension: stride});
                            feature = format.readFeature(wktStr);
                        }
                        if (goog.isDef(feature)) {
                            //забираем координаты и переводим их в нормальную проекцию
                            var flatCoordinates = feature.getGeometry().flatCoordinates;
                            if (flatCoordinates.length > 1 && flatCoordinates[0] != -1 && flatCoordinates[1] != -1) {
                                //устанавливаем в фичу стиль дефолтный
                                if (stride == 3) {
                                    var newArr = [];
                                    for (var j = 0; j < flatCoordinates.length; j += stride) {
                                        var lng = flatCoordinates[j];
                                        var lat = flatCoordinates[j + 1];
                                        newArr.push(lng);
                                        newArr.push(lat);
                                    }
                                    //геометрия выделяемого участка трубопровода
                                    var geometry = new ol.geom.LineString(null);
                                    geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY, newArr);
                                    var newLineFeature = new ol.Feature(geometry);
                                    WidgetMap.layerManager.defaultSelectionStyle(newLineFeature);
                                    GeoUtil.convertFeature(newLineFeature, App.projection, WidgetMap.DEFAULT_PROJECTION);
                                    newLineFeature.setId('DEFAULT_SELECTED_' + idStr);
                                    WidgetMap.mapSelectionLayer.getSource().addFeature(newLineFeature);
                                }
                                else {
                                    WidgetMap.layerManager.defaultSelectionStyle(feature);
                                    GeoUtil.convertFeature(feature, App.projection, WidgetMap.DEFAULT_PROJECTION);
                                    feature.setId('DEFAULT_SELECTED_' + idStr);
                                    WidgetMap.mapSelectionLayer.getSource().addFeature(feature);
                                }
                                //добавляем выбранный объект в глобальную переменную
                                WidgetMap.mapSelectedObject = that.showObjectsValue;
                            }
                            else {
                                if (that.showObjectsIsGroupButton == true)//если нажата была групповая кнопка, то не показываем ошибки
                                    continue;
                            }
                        }
                    }
                }
                if (filterCount == 0) {
                    //зуммируемся к ним
                    var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
                    if (that.showObjectsCentering && WidgetMap.mapSelectionLayer.getSource().getFeatures().length > 0) {
                        WidgetMap.centerOnMap(extent);
                    }
                }

            }
            else {
                App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_1'});
                --filterCount;
                if (filterCount == 0) {
                    //зуммируемся к ним
                    var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
                    if (that.showObjectsCentering && WidgetMap.mapSelectionLayer.getSource().getFeatures().length > 0) {
                        WidgetMap.centerOnMap(extent);
                    }
                }
            }
        }

        function getLayerGeoFault(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '')
                App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_2'});
            --filterCount;
            if (filterCount == 0) {
                //зуммируемся к ним
                var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
                if (that.showObjectsCentering && WidgetMap.mapSelectionLayer.getSource().getFeatures().length > 0) {
                    WidgetMap.centerOnMap(extent);
                }
            }
        }

        function generateFilterStr(filter) {
            return "ID in (" + filter.join(",") + ")";
        }
    }


};

/**
 * Оставить на карте выбранные объекты
 * @param layerName
 * @param layerIds
 * @param that
 */
WidgetMap.selectFeatures = function (layerName, layerIds, that, findCallback) {
    if(!checkMapExisting())
        return;
	var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
	if (goog.isDef(layerObj) && goog.isDef(layerObj.layer)) {
		if (!layerObj.layer.hasData) {//если данных нет в слое вообще
            if(findCallback)
                findCallback(false);
            else
            MapUtil.showObjectError(that, layerObj, this);
			return;
		}
		var features = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(layerObj.layer, layerIds);
        MapUtil.clearSelectionLayer();
		if (features.length == 0) {
			/*if(showObjectsIsGroupButton == true)//если нажата была групповая кнопка, то не показываем ошибки
			 return;*/
			//если выборка из грида, и не нашли объекты, то не выдаем ошибки
			if(that.showObjectsFromFilter === true){
				layerObj.layer.showObjectById([-99999999999], false);
				return;
			}
            if(findCallback)
                findCallback(false);
            else
            MapUtil.showObjectError(that, layerObj, this);
		}
		else {
            if(findCallback)
                findCallback(true);
			layerObj.layer.showObjectsByIds(layerIds, that.showObjectsCentering);
			//прячем подписи для слоя
			//WidgetMap.hideLabels(layerName,layerIds);
		}

	}
};

/*
 Фильтрация геометрии из грида
 */
WidgetMap.filterData = function (params) {
    if(WidgetMap.filterDataMessageId !== undefined){
        WidgetMap.filterDataMessageId.abort();
    }
    var that = this;
    that.showObjectsCentering = true;
    that.showObjectsValue = '';
    that.showObjectsRequest = '';
    that.showObjectFilterXML = '';
    that.showObjectsIsGroupButton = false;
    that.showObjectsSelect = false;
    that.showObjectsLayerName = '';
    var i;
    for (i = 0; i < params.length; i++) {
        var objects = params[i];
        if (objects.name === "objects") that.showObjectsValue = objects.value;
        if (objects.name === "requestId") that.showObjectsRequest = objects.value;
        if (objects.name === "layer") that.showObjectsLayerName = objects.value;
        if (objects.name === "zoom") that.showObjectsCentering = (objects.value == 'true' || objects.value == true);
        if (objects.name === "highlight") that.showObjectsSelect = (objects.value == 'true' || objects.value == true);
        if (objects.name === "isGroupButton") that.showObjectsIsGroupButton = (objects.value == 'true' || objects.value == true);
        if (objects.name === "filterXML") that.showObjectFilterXML = objects.value;
    }
    function getLayerGeoReqParams(filter, request) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' +
                filter +
                '</root>'
        };
    }

    function getLayerGeoResult(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er === '') {
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var datas = layerGeoXml.getElementsByTagName("data");
            var objectsStr = '';
            var objects = [];
            var dataLength = datas.length;
            var showDialog = false;

            for (var t = 0; t < dataLength; t++) {
                var idAttr = datas[t].getAttribute("ID");
                objectsStr += idAttr + ',';
                objects.push(idAttr);
            }
            objectsStr = that.showObjectsLayerName + ':' + objectsStr.substr(0, objectsStr.length - 1);
            //формируем объект для вызова WidgetMap.showObjects;
            var objParams = [];
            objParams.push({name: 'centering', value: that.showObjectsCentering});
            objParams.push({name: 'objects', value: objectsStr});
            objParams.push({name: 'isGroupButton', value: true});
            objParams.push({name: 'select', value: that.showObjectsSelect});
            objParams.push({name: 'fromFilter', value: true});
            var dlg;
            function closeDialog() {
                if (goog.isDef(dlg)) {
                    dlg.dialog('destroy');
                    dlg.remove();
                }
            }
            if (WidgetMap.CURRENT_MODE === WidgetMap.MODES.VECTOR) {//слой векторный
                function showAlertVectorDialog() {
                    WidgetMap.showObjects(objParams, undefined, false, true);
                    closeDialog();
                }
                if (showDialog) {
                    var buttons = [{text: gis_core_12, click: showAlertVectorDialog}];
                    dlg = App.confirmDialog(gis_widgetmap_21, buttons, {
                        title: gis_widgetmap_22,
                        dialogClass: 'noCloseButton gsi-zindex__dialog'
                    });
                }
                else
                    WidgetMap.showObjects(objParams, undefined, false, true);
            }
        }
        else {
            App.errorReport(gis_widgetmap_28, er, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_6'});
        }
    }

    function getLayerGeoFault(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== '') {
            App.errorReport(gis_widgetmap_28, er, undefined, {filename:gis_filename_394, functionname:'gis_filename_394_7'});
        }
    }
    WidgetMap.filterDataMessageId = App.serverQueryXMLNode(Services.processQueryNode, getLayerGeoReqParams(that.showObjectFilterXML, that.showObjectsRequest), getLayerGeoResult, getLayerGeoFault);
};

WidgetMap.getShowErrorInGridDictationary = function () {
    if (goog.isDefAndNotNull(WidgetMap.config)) {
        var flag = WidgetMap.config.showErrorInGridDictionary;
        if (goog.isDef(flag))
            return flag;
    }
    return true;
};

/**
 * Реация на нажатие ESC
 * @private
 */
WidgetMap.handleEscClick_ = function () {
    BlockingUtil.wait();
    try {
        //прячем попап с измерениями линейкой
        if(map.controls.MeasureControl)
            map.controls.MeasureControl.reset()
        if (goog.isDef(WidgetMap.baseInteraction) && goog.isDef(WidgetMap.baseInteraction.abortDrawing_))
            WidgetMap.baseInteraction.abortDrawing_();
        if (goog.isDef(WidgetMap.currentVectorLayer))
            WidgetMap.currentVectorLayer.getSource().clear();
        WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
        WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);
        WidgetMap.map.removeControl(WidgetMap.drawControl);
        //удалить interaction и выставить ладошку
        if(goog.isDef(WidgetMap.panControl))
            map.controls.PanControl.prototype.handlePanClick_();
        //WidgetMap.infoControl.handleMapInfoClick_();

    }
    catch (ex) {}
    finally {
        BlockingUtil.ready();
    }
};
/**
* Класс для навигации кнопками положений карты
*/
MapHistory = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    this.map = options.map;
    this.justChanged = false;
    // центр карты, масштаб отображения, текущая проекция базового слоя
    this.mapCenterLonLat = NaN;
    this.mapZoom = NaN;
    // история перемещений
    this.history_ = [];
    this.positionCursor_ = -1;
    //контрол с кнопками
    this.historyControl = undefined;
    var that = this;
    if(goog.isDef(this.map))
        this.map.on('moveend', function(){
            that.saveCurrentState();
        });
};

MapHistory.prototype.clearHistory = function(){
    this.justChanged = false;
    this.mapCenterLonLat = NaN;
    this.mapZoom = NaN;
    this.history_ = [];//массив положений
    this.positionCursor_ = -1;// текущее положение карты
    this.saveCurrentState();
};

MapHistory.prototype.saveCurrentState = function(){
    if(!goog.isDef(this.map))
        return;
    if(this.justChanged == false){
        this.history_.splice(this.positionCursor_+ 1);
        //сохраняем центр в wgs
        var cp = new proj4.toPoint(this.map.getView().getCenter() );
        this.dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
        if(GeoUtil.PROJS['EPSG:5807'] !== WidgetMap.DEFAULT_PROJECTION){
            this.source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
            proj4.transform(this.source_, this.dest_, cp);
        }
        this.mapCenterLonLat = [cp.x, cp.y];
        this.mapZoom = this.map.getView().getZoom();
        this.history_.push({zoom:this.mapZoom, lonlat:this.mapCenterLonLat});
        this.positionCursor_ = this.history_.length - 1;

    }
    if(goog.isDef(this.historyControl)){
        //в зависимости от текущего курсора выставляем стили кнопкам
        if(this.positionCursor_ == 0){
            $(this.historyControl.inElement).addClass('map-disabled-button');
        }
        else{
            $(this.historyControl.inElement).removeClass('map-disabled-button');
        }
        if(this.positionCursor_ == this.history_.length - 1){
            $(this.historyControl.outElement).addClass('map-disabled-button');
        }
        else{
            $(this.historyControl.outElement).removeClass('map-disabled-button');
        }
    }

    this.justChanged = false;
};

MapHistory.prototype.setState = function(state){
    this.positionCursor_ += state;
    var currPosition  = this.history_[this.positionCursor_];
    if(!goog.isDef(currPosition)){
        this.positionCursor_ -= state;
        this.justChanged = false;
        return;
    }
    //преобразуем центр в проекцию подложки
    var cp = new proj4.toPoint(currPosition.lonlat );
    this.source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
    if(GeoUtil.PROJS['EPSG:5807'] !== WidgetMap.DEFAULT_PROJECTION){
        this.dest_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
        proj4.transform(this.source_, this.dest_, cp);
    }
    this.map.getView().setCenter([cp.x,cp.y]);
    this.map.getView().setZoom(currPosition.zoom);
};
/**
 * Класса парсера новых базовых слоёв rasterlayers.json
 * @constructor
 */
function BaseLayersParser(opt_options){
	var options = opt_options !== undefined ? opt_options : {};

	// дефолтная базовая проекция
	this.projection = GeoUtil.PROJS.GoogleMercator;
	this.OSM_DEFAULT_MAX_RESOLUTION = 156543.0339;

	//массив пришедших данных
	this.pureLayers = [];
	this.layers = [];
	this.mode = 'vector';
	//слои для растрового режима, подложка pods_raster
	this.rasterModeLayers = [];
	this.currentBaseLayers = new ol.layer.Group();/** @link ol.layer.Group  */
	//массив для заполнения контрола с базовыми слоями
	//массив растровых слоёв из *_rasterlayers.json
	this.rasterLayers = {};
	this.baselayerscontrolarray = [];
	//массив со списком файлов со слоями, которые могут быть растровыми
	this.canRasterLayers = [];
	this.init();

	//массив со списком слоём для получения информации по ним в режиме растра M_1, M_R, PODS_EQUIP,...
	this.rasterInfos = [];
	this.maxZoomLevel = 23;
	//список файлов с подложками
	this.urls = [];
	if(options.urls !== undefined && options.urls.length > 0 )
		this.urls = options.urls.reverse();

	
	/*if(options.url !== undefined && options.url !== '')
		this.loadLayers(options.url);*/
	if(options.urls !== undefined && options.urls.length > 0 )
		this.loadLayers();
}

/**
 * Инициализация доп. данных
 */
BaseLayersParser.prototype.init = function(){
	var that = this;
	proj4.defs("EPSG:3395", "+title=Yandex +proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs");
	ol.proj.get('EPSG:3395').setExtent(
		[-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244]
	);
	//устанавливаем массив со списком файлов со слоями, которые могут быть растровыми
	var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
	if(mapConfig.canRaster && mapConfig.canRaster.length > 0){
		mapConfig.canRaster.forEach(function(el){
			var sp = el.split(':');
			if(sp.length == 2 && sp[1] !== '')
				that.canRasterLayers.push(sp[1]);
		});
	}
};

/**
 * Загрузка файла с набором базовых слоёв
 */
BaseLayersParser.prototype.loadLayers = function(){
	var that = this;
	if(this.urls.length > 0){
		var url = this.urls.pop();
		if(!url) return;
		App.serverQueryJSON('./Core/Query/'+url, result, fault,4);
		function fault(res) {
			App.errorReport(gis_baselayerparser_1, res, undefined, {filename:gis_filename_484, functionname:'gis_filename_484_1'});
			that.loadLayers();
		}
		function result(res) {
			try {
				if (res !== undefined && res.code === 200 && res.layers !== undefined) {
					that.parseLayers(res, url);
				}
			}
			catch(ex) {
				App.errorReport(gis_baselayerparser_1, ex, undefined, {filename:gis_filename_484, functionname:'gis_filename_484_2'});
			}
			finally {
				that.loadLayers();
			}
		}
	}

};

/**
 * Получение идентификатора шаблона из параметра url - mapId(прошлой реализации)
 * Если через зяпятую перечисляются id, то новый формат без шаблона. Выбираются основные слои по id
 * @returns {string}
 */
BaseLayersParser.prototype.getTemplateIdFromUrl = function(){
	return getParameterByName('mapId');
};

/**
 * Получение режима отображения из параметра url - mode
 * @returns {string}
 */
BaseLayersParser.prototype.getMode = function(){
	//пробуем забрать из урл
	var mode =  getParameterByName('mode');
	if(mode !== '' && (mode ===  WidgetMap.MODES.VECTOR || mode ===  WidgetMap.MODES.RASTER))
		WidgetMap.CURRENT_MODE = mode;
	WidgetMap.CURRENT_MODE = MapUtil.getAvailableMapMode(WidgetMap.CURRENT_MODE);
	//пробуем забрать из настроек настроек пользователя. уже установленных в WidgetMap.CURRENT_MODE
	return WidgetMap.CURRENT_MODE;
};


/**
 * Обработка списка слоёв
 * @param data
 * @param url Название json файла
 */
BaseLayersParser.prototype.parseLayers = function(data, url){
	var that = this;
	var mode = 'vector';
	if(this.canRasterLayers.indexOf(url) !== -1)
		mode = 'raster';
	var serverRepl = '{SERVER}';
	var isOverview = false;
	if(data !== undefined ){
		var templateLayers = [];
		if(data.templates1 !== undefined && data.templates1.length > 0){
			//массив шаблонов
			var templateIdFromUrl = this.getTemplateIdFromUrl();
			var currentMode = this.getMode();
			if(templateIdFromUrl.indexOf(',') !== -1){
				templateLayers = templateIdFromUrl.split(',');
			}
			else{
				for(var i=0; i< data.templates.length;i++){
					if(data.templates[i].template_id !== undefined && data.templates[i].template_id === templateIdFromUrl && data.templates[i].layers !== undefined){
						templateLayers = data.templates[i].layers;
						break;
					}
				}
			}
		}

		if( data.projection !== undefined && data.projection !== '')
			this.projection = data.projection;
		try {
			if(data.layers !== undefined && data.layers.length > 0) {
				this.rasterLayers[data.name] = {
					pojection: data.projection,
					name: data.name,
					descr: data.descr,
					mode: mode,
					layers: [], //список для добавления во view
					baselayerscontrolarray: []//список для наполения контрола
				};
				//объект контрола с базовыми слоями
				var internetSrcDisable = (App.config.INTERNET_SRC_DISABLE !== undefined && App.config.INTERNET_SRC_DISABLE.length > 0)?App.config.INTERNET_SRC_DISABLE:'';
				var internetSrcDisableSplit = internetSrcDisable.split(',');
				function compare( a, b ) {
					if ( a.order > b.order ){
						return -1;
					}
					if ( a.order < b.order ){
						return 1;
					}
					return 0;
				}

				data.layers.sort( compare );
				var defaultVisibleLayers  = [];
				//если в url пришел mapId, то выставляем видимость и порядок следования исходя из параметра
				var mapId = getParameterByName('mapId');
				if(mapId !== '')
					defaultVisibleLayers = mapId.split(',');
				templateLayers = defaultVisibleLayers;
				for(var i =0; i<data.layers.length; i++){
					var layer = data.layers[i];
					var errorMessage = this.checkParam(layer, url);

					//проверяем, есть ли слой в шаблонах, чтобы принудительно выставить видимость. Иначе всё по умолчанию
					if(templateLayers.length > 0){
						//сначала всё прячем, а найденные включаем
						layer.visible = false;
						if(templateLayers.indexOf(layer.id) !== -1)
							layer.visible = true;
					}
					var zoomLevels = (layer.zoomLevels !== undefined)?layer.zoomLevels:19;
					var opacity = (layer.opacity !== undefined)?layer.opacity:1;
					if(layer.visible ){
						if(layer.layers !== undefined && layer.layers.length > 0){
							layer.layers.forEach(function(modelName){
								if(that.rasterInfos.indexOf(modelName) == -1)
									that.rasterInfos.push(modelName);
							});
						}
						if(zoomLevels<that.maxZoomLevel)
							that.maxZoomLevel = zoomLevels;
					}


					this.rasterLayers[data.name].baselayerscontrolarray.push({
						id:layer.id, opacity:opacity, visible:layer.visible, descr: layer.descr, projection:layer.projection,
						maxZoom:zoomLevels, showInfo:layer.showInfo === true, isCadastre: layer.type ==='WMSCadastre',
						icon:layer.icon, mode: mode, layers:layer.layers, error: errorMessage,
					});
					if(internetSrcDisableSplit.indexOf(layer.id) != -1 && layer.visible)
						WidgetMap.defaultDisablePrint = true;

					switch(layer.type){
						case "OSMLayer":{
							//если есть useEmail и он тру, мы в режиме cadastr => проверить cadastreURL
							var hasZXY = layer.url.indexOf('{z}') !== -1;
							var layerUrl = hasZXY ? layer.url.replace(serverRepl, ".") : layer.url.replace(serverRepl, ".") + '{z}/{x}/{y}' + layer.extension
							var tempSource = new map.source.OSMWebService({
								url: layerUrl,
								projection: layer.projection,
								maxZoom: zoomLevels,
								useEmail: layer.useEmail,
								useEmailFullAttach: layer.useEmailFullAttach,
								cadastreFeatureURL: layer.cadastreURL,
								interimTilesOnErrorList: layer.interimTilesOnErrorList,
								useInterimTilesOnError: layer.useInterimTilesOnError,
								isOverview: isOverview,
								tileSize: layer.tileSize
							});
							var tempLayer = new map.layer.RestrictByZoomTile({
								id: layer.id,
								source: tempSource,
								opacity: opacity,
								visible: layer.visible,
								restrictZoom: WidgetMap.LPURestrictZoom,
								restrictExtent: WidgetMap.LPURestrictExtent
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						case 'TMS':{
							var tempSource = new map.source.OSMWebService({
								url: layer.url.replace(serverRepl, ".") + '{z}/{x}/{-y}' + layer.extension,
								projection: layer.projection,
								maxZoom: zoomLevels,
								interimTilesOnErrorList: layer.interimTilesOnErrorList,
								useInterimTilesOnError: layer.useInterimTilesOnError
							});
							var tempLayer = new map.layer.RestrictByZoomTile({
								id: layer.id,
								source: tempSource,
								opacity:  opacity,
								visible: layer.visible,
								restrictZoom: WidgetMap.LPURestrictZoom,
								restrictExtent: WidgetMap.LPURestrictExtent
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						case 'XYZ':{
							var tempSource = new ol.source.XYZ({
								url: (layer.url !== undefined) ? layer.url.replace(serverRepl, ".") : undefined,
								projection: layer.projection,
								maxResolution: this.OSM_DEFAULT_MAX_RESOLUTION,
							});
							var tempLayer = new map.layer.RestrictByZoomTile({
								id: layer.id,
								source: tempSource,
								opacity: opacity,
								visible: layer.visible,
								restrictZoom: WidgetMap.LPURestrictZoom,
								restrictExtent: WidgetMap.LPURestrictExtent
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						case 'XYZ1024':{
							//вариант для отображения тайловой пирамиды с тайлами размером 1024х1024,
							// которые генерирует sasplanet для росреестра и openstreetmap
							var tempSource = new ol.source.XYZ({
								url: (layer.url !== undefined) ? layer.url.replace(serverRepl, ".") : undefined,
								projection: layer.projection,
								maxResolution: this.OSM_DEFAULT_MAX_RESOLUTION,
								tileSize: 1024,
							});
							var tempLayer = new map.layer.RestrictByZoomTile({
								id: layer.id,
								source: tempSource,
								opacity: opacity,
								visible: layer.visible,
								restrictZoom: WidgetMap.LPURestrictZoom,
								restrictExtent: WidgetMap.LPURestrictExtent
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						case 'Mapnik':{
							var tempSource = new ol.source.OSM({
								projection: layer.projection,
								url: (layer.url !== undefined) ? layer.url.replace(serverRepl, ".") : undefined,
								maxResolution: this.OSM_DEFAULT_MAX_RESOLUTION
							});
							var tempLayer = new map.layer.RestrictByZoomTile({
								id: layer.id,
								source: tempSource,
								opacity: opacity,
								visible: layer.visible,
								restrictZoom: WidgetMap.LPURestrictZoom,
								restrictExtent: WidgetMap.LPURestrictExtent
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						case 'WMSCadastre':{
							if (layer.zouitURL !== undefined) {
								var zouitSource = new map.layer.ImageRosreestrWMS({
									url: layer.url.replace(serverRepl, ".").replace('CadastreWMS', 'ZONES'),
									restURL: layer.zouitURL.replace(serverRepl, "."),
									projection: layer.projection,
									params: {
										LAYERS: layer.layers_wms,
										STYLES: layer.styles_wms,
										VERSION: '1.3.0'
									}
								});
								var zouitLayer = new map.layer.RestrictByZoomImage({
									id: layer.id,
									source: zouitSource,
									opacity: opacity,
									visible: layer.visible,
									restrictZoom: WidgetMap.LPURestrictZoom,
									restrictExtent: WidgetMap.LPURestrictExtent
								});
								this.rasterLayers[data.name].layers.push(zouitLayer);
								break;
							}
							var tempSource = new map.layer.ImageRosreestrWMS({
								url: layer.url.replace(serverRepl, "."),
								restURL: layer.restURL.replace(serverRepl, "."),
								projection: layer.projection,
								params: {
									LAYERS: layer.layers_wms,
									STYLES: layer.styles_wms,
									VERSION: '1.3.0'
								}
							});
							var tempLayer = new map.layer.RestrictByZoomImage({
								id: layer.id,
								source: tempSource,
								opacity: opacity,
								visible: layer.visible,
								restrictZoom: WidgetMap.LPURestrictZoom,
								restrictExtent: WidgetMap.LPURestrictExtent
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						case 'DynamicWmsLayer':{
							var tempSource = new map.layer.DynamicImageWMS({
								url: './' + layer.url,
								params: {
									STYLES: '',
									VERSION: '1.3.0',
									CRS: layer.projection,
									PROJECTION: layer.projection
								}
							});
							var tempLayer = new map.layer.RestrictByZoomImage({
								id: layer.id,
								source: tempSource,
								opacity: opacity,
								visible: layer.visible,
								restrictZoom: WidgetMap.LPURestrictZoom,
								restrictExtent: WidgetMap.LPURestrictExtent
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						case 'VectorPbf':{
							var tempSource = new ol.source.VectorTile({
								url: (layer.url !== undefined) ? layer.url.replace(serverRepl, ".") : undefined,
								projection: layer.projection,
								format: new ol.format.MVT(),
								tileGrid: ol.tilegrid.createXYZ({maxZoom: 18}),
							});
							var tempLayer = new ol.layer.VectorTile({
								id: layer.id,
								source: tempSource,
								opacity: opacity,
								visible: layer.visible,
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						case 'VectorPbf2':{
							var key = 'pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2pzbmg0Nmk5MGF5NzQzbzRnbDNoeHJrbiJ9.7_-_gL8ur7ZtEiNwRfCy7Q';
							var tempSource = new ol.source.VectorTile({
								attributions: [new ol.Attribution({
									html: '© <a href="https://www.mapbox.com/map-feedback/">Mapbox</a> ' +
										'© <a href="http://www.openstreetmap.org/copyright">' +
										'OpenStreetMap contributors</a>'
								})],
								format: new ol.format.MVT(),
								tileGrid: ol.tilegrid.createXYZ({maxZoom: 22}),
								tilePixelRatio: 16,
								url: 'http://{a-d}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/' +
									'{z}/{x}/{y}.vector.pbf?access_token=' + key
							});
							var tempLayer = new ol.layer.VectorTile({
								id: layer.id,
								source: tempSource,
								visible: layer.visible,
							});
							this.rasterLayers[data.name].layers.push(tempLayer);
							break;
						}
						default:
							break;
					}
				}
				
				if(WidgetMap.defaultDisablePrint && WidgetMap.exportImageChooserControl !== undefined)
					WidgetMap.exportImageChooserControl.disableButtons();
				var layers = this.rasterLayers[data.name].layers;
				//устанавливаем базовые слои
				var tLayers = this.currentBaseLayers.getLayers().getArray();
				tLayers = tLayers.concat(layers);
				this.currentBaseLayers.setLayers(new ol.Collection(tLayers));
				if(that.urls.length == 0){
					WidgetMap.init();
					WidgetMap.changeMapView(that.maxZoomLevel - 1,'Карта',this.projection);
					var order = 1;//TODO с 1, чтобы поместить pods_equip
					for(var j = 0; j < that.rasterInfos.length; j++){
						if(that.rasterInfos[j] !== '') WidgetMap.layerManager.parseRasterLayersDescr(that.rasterInfos[j]+'_Layers.xml', order++);
					}
					//парсим слои смешанного слоя, типа PODS_EQUIP_Layers
					var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
					var canRasterArr = mapConfig.canRaster;
					if(goog.isDef(canRasterArr)){
						for(var d=0; d< canRasterArr.length; d++){
							var el = canRasterArr[d].split(':');
							WidgetMap.layerManager.parseRasterLayersDescr(el[0], order++);
						}
					}
				}
			}
		}
		catch (ex) {
			App.errorReport(gis_baselayerparser_1, ex, undefined, {filename:gis_filename_484, functionname:'gis_filename_484_3'});
		}
	}
};
/**
 * Сверка параметров
 * @param {*} layer Подложка
 * @param {*} url Имя файла с подложками
 * @return {*} Пустая строка || Строка с ошибкой
 */
BaseLayersParser.prototype.checkParam = function(layer, url){
	var errorMessage = gis_core_20.replace('{URL}', url);			
	var errorParams = [];
	if (layer.descr !== undefined){
		errorMessage = errorMessage.replace('{DESCR}', layer.descr);
	} else {
		if (layer.order !== undefined || layer.order !== '')
			errorMessage = errorMessage.replace('{DESCR}', 'order='+layer.order);
		else
			errorMessage = errorMessage.replace('{DESCR}', '');
		errorParams.push('descr');
	}
	if (layer.visible === undefined)
		errorParams.push('visible');
	else if (layer.visible !== true)
		layer.visible = false;

	if (layer.order === undefined || layer.order === '')
		errorParams.push('order');
	if (!layer.id)
		errorParams.push('id');

	if (layer.url === undefined){
		errorParams.push('url');
		layer.url = '';
	}
	if (!layer.type)
		errorParams.push('type');
	if (!layer.projection)
		errorParams.push('projection');
	if (layer.cadastreURL === undefined)
		errorParams.push('cadastreURL');
	if (errorParams.length > 0)
		return errorMessage.replace('{PARAM}', errorParams.join());
	else 
		return '';
};

BaseLayersParser.prototype.parseOverviewLayers = function(urls){
	if(urls !== undefined && urls.length > 0){
		var serverRepl = '{SERVER}';
		var layers = [];
		for(var i=0; i<urls.length;i++){
			var tempSource = new map.source.OSMWebService({
				url: urls[i].url.replace(serverRepl, ".") + '{z}/{x}/{y}' + urls[i].extension,
				projection: WidgetMap.DEFAULT_PROJECTION,
				maxZoom: 23,
				interimTilesOnErrorList: urls[i].interimTilesOnErrorList,
				useInterimTilesOnError: urls[i].useInterimTilesOnError,
				isOverview: true
			});
			var tempLayer = new map.layer.RestrictByZoomTile({
				id: 'OverviewMap_'+i,
				source: tempSource,
				opacity: 1,
				visible: true,
				restrictZoom: WidgetMap.LPURestrictZoom,
				restrictExtent: WidgetMap.LPURestrictExtent
			});
			layers.push(tempLayer);
		}
		WidgetMap.overviewLayers = new ol.Collection(layers);
	}
};
/*
 * Общие глобальные функции
 */
/*
 * Расширение стадартноего объекто String. Экранирование XML символов.
 */
if(!String.prototype.xmlEscape) {
    String.prototype.xmlEscape = function () {
        return this
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    };
};

/* 
 * Эмуляция наследования для старых браузеров 
 */
//if(typeof Object.create !== 'function') {
Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
};
//}


// Настройки datepicker
$.datepicker.setDefaults($.datepicker.regional['ru']);
$.datepicker.setDefaults({
    dateFormat: 'dd-mm-yy',
    changeYear: true,
    yearRange: '-100:+100'
});


$.cookie.raw = true;

App = {};
//уникальный идентификатор окна. Будет использоваться в синхронизации
App.UNIQUE_ID = undefined;
//счетчик открытия ПКА для дальнейшей выдачи сообщения, что могут быть артефакты из-за некорректной работы ie - не чистит память нормально
App.GLOBAL_CAS_OPEN_LIMIT = 5;
App.GLOBAL_MAP_OPEN_LIMIT = 5;
//Строка для проверки на пустой файл
App.EMPTY_FILE_RESPONSE = '<string><root fileName=';
App.EMPTY_FILE_TEMPLATE = '<string><root/></string>';

App.name = gis_app_55_1;
App.version = gis_app_55_2;

App.SERVER_ERRORS = {
    'OK':gis_app_55_25, //случай, если запросили тип xml, а пришло не то
    'Internal Server Error':gis_app_55_26,
    'error':gis_app_55_27,
    'abort':gis_app_55_28,
    'Not Found':gis_app_55_30,
    'Service Unavailable':gis_app_55_30,//случай, если не работает сервер nodejs
    'Proxy Error':gis_app_55_30,//случай, если не работает сервер nodejs
    '404':gis_app_55_31 // файл не найден
};

/**
 * Возврачает читаемый текст ошибки от сервера
 * @param textStatus
 * @param errorThrown
 * @returns {string|*}
 */
App.prettyCodeError = function(textStatus, errorThrown){
    if(textStatus === '' || errorThrown === '')
        textStatus = gis_app_55_26 + '. ' + gis_app_55_23 + '. textStatus='+textStatus ;
    var result = textStatus;
    try{
        if(App.SERVER_ERRORS[errorThrown] !== undefined)
            result = App.SERVER_ERRORS[errorThrown];
        else if(App.SERVER_ERRORS[textStatus] !== undefined)
            result = App.SERVER_ERRORS[textStatus];
        else if(errorThrown.indexOf('Service Unavailable'))
            result = App.SERVER_ERRORS['Service Unavailable'] + '. textStatus='+textStatus;
        else if(errorThrown.indexOf('Internal Server Error'))
            result = App.SERVER_ERRORS['Internal Server Error'] + '. textStatus='+textStatus;
        return result;
    }
    catch(ex){}

    return textStatus;
};


/**
 * Возврачает читаемый текст ошибки от сервера, если он вернулся в успешном результате
 * @param textStatus
 * @param errorThrown
 * @returns {string|*}
 */
App.prettyCodeSuccessError = function(text){
    var result = text;
    try{
        if(text && text !== ''){
            if(text.indexOf(App.SERVER_ERRORS['Internal Server Error']) !== -1)
                result = App.SERVER_ERRORS['Internal Server Error'] + '. ' + text;
            if(text.indexOf(App.SERVER_ERRORS['Service Unavailable']) !== -1)
                result = App.SERVER_ERRORS['Service Unavailable'] + '. ' + text;
        }
        return result;
    }
    catch(ex){}

    return result;
};

/**
 * Возвращает читаемы текст ошибки без спец символов в окно с ошибкой
 * @param str
 * @returns {*}
 */
App.formatErrorString = function(str){
    try{
        if (str.indexOf('&amp;') != -1) {
            str = str.replace(/&amp;/g, '&');
        }
        if (str.indexOf('&lt;') != -1) {
            str = str.replace(/&lt;/g, '<');
        }
        if (str.indexOf('&gt;') != -1) {
            str = str.replace(/&gt;/g, '>');
        }
        if (str.indexOf('&quot;') != -1) {
            str = str.replace(/&quot;/g, '"');
        }
        if (str.indexOf('&#39;') != -1) {
            str = str.replace(/&#39;/g, '\'');
        }
        if (str.indexOf('&#xA;') != -1) {
            str = str.replace(/&#xA;/g, '\\n');
        }
        if (str.indexOf('\\"') != -1) {
            str = str.replace(/\\"/g, '"');
        }
    }
    catch(e){}
    return str;
};

/**
 * НОРМАЛЬНАЯ обертка для отправки запросов на сервер.
 * При успехе вызывается функция callbackResult с содержимым из тега <string></string>
 * При ошибке вызывается функция callbackFail с текстом критической ошибки.
 * Функция возвращает ссылку на запрос для возможности отмены запроса через .abort()
 */

App.serverQueryXML = function (url, params, callbackResult, callbackFail, returnReq) {
    var req = $.ajax({
        type: "POST",
        url: url,
        data: params,
        timeout: App.clientRequestTimeout,
        dataType: 'xml'
    });

    var xmlData = "";

    req.done(function (resp) {
        xmlData = $(resp).find('string').text();
        //Вызываем переданную функцию для обработки результата
        callbackResult(xmlData);
    });

    req.fail(function (jqXHR, textStatus, errorThrown) {
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText === "timeout") {
            xmlData = gis_app_55_13;
        }
        //Вызываем переданную функцию для обработки результата
        callbackFail(xmlData);
    });

    return req;
};

App.serverQueryXMLWithTries = function (url, params, callbackResult, callbackFail, triesCount) {
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount) {
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'xml'
        });
        var xmlData = "";
        req.done(function (resp) {
            xmlData = $(resp).find('string').text();
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(triesCount);
};

App.serverQueryXMLGrid = function (url, params, callbackResult, callbackFail, returnReq) {
    var internalServerErrorCounter = 5;
    function sendRequest(internalServerErrorCounter){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'xml'
        });

        var xmlData = "";

        req.done(function (resp) {
            xmlData = $(resp).find('string').text();
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);
};

App.serverQueryXMLGridNew = function (url, params, callbackResult, callbackFail, returnReq, processId) {
    var internalServerErrorCounter = 5;
    function sendRequest(internalServerErrorCounter){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'xml'
        });

        var xmlData = "";

        req.done(function (resp) {
            xmlData = $(resp).find('string').text();
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData, processId);
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData, processId);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);
};




/**
 * Запрос для получения информации по кадастровому слою
 * @param url
 * @param callbackResult
 * @param callbackFail
 * @returns {*}
 */
App.serverCadastreQueryXML = function (url, callbackResult, callbackFail) {
    $.support.cors = true;
    // Create the XHR object.
    function createCORSRequest(method, url) {
        var xhr = new XMLHttpRequest();
        if ("withCredentials" in xhr) {
            // XHR for Chrome/Firefox/Opera/Safari.
            xhr.open(method, url, true);
        } else if (typeof XDomainRequest != "undefined") {
            // XDomainRequest for IE.
            xhr = new XDomainRequest();
            xhr.open(method, url);
        } else {
            // CORS not supported.
            xhr = null;
        }
        return xhr;
    }

    // Make the actual CORS request.
    function makeCorsRequest(url) {
        // All HTML5 Rocks properties support CORS.
        var xhr = createCORSRequest('GET', url);
        xhr.timeout = 5000;//30 секунд = 30000 (в миллисекундах)
        if (!xhr) {
            callbackFail('CORS not supported');
            return;
        }
        var res = false;

        // Response handlers.
        xhr.onload = function() {
            res = true;
            var text = xhr.responseText;
            try{
                var doc = $($.parseXML(text));
                var xmlData = $(doc).children('FeatureInfoResponse');
                //Вызываем переданную функцию для обработки результата
                callbackResult(xmlData);
            }
            catch(ex){
                callbackFail(text);
            }
        };
        xhr.ontimeout  = function() {
            res = true;
            callbackFail(gis_app_55_18);
        };
        xhr.onerror = function(xhr, textStatus, errorThrown) {
            res = true;
            callbackFail(gis_app_55_17);
        };
        xhr.onabort = function() {
            res = true;
            callbackFail(gis_app_55_16);
        };
        /*xhr.onreadystatechange = function() {
            if (this.readyState != 4) return;
            // по окончании запроса доступны:
            // status, statusText
            // responseText, responseXML (при content-type: text/xml)
            if (this.status != 200) {
                // обработать ошибку
                alert( 'ошибка: ' + (this.status ? this.statusText : 'запрос не удался') );
                return;
            }
            // получить результат из this.responseText или this.responseXML
        };*/
        function abortRequest(){
            xhr.abort();
            if( !res )
                callbackFail(gis_app_55_19);
        }

        setTimeout(abortRequest,5000);
        xhr.send();
    }
    makeCorsRequest(url);
    return;

};

/**
 * Отчет об ошибке
 * @param text - основной текст ошибки
 * @param detail - детализация
 * @param closeCallback - колбек на закрытие
 * @param params - дополнительные параметры, которые уйдут в письме
 */
App.errorReport = function(text, detail, closeCallback, params) {
    var errDetail = detail;
    detail = App.formatErrorString(detail);
    var genId = App.generateUUID();
    var id = 'errorReportDialog_'+genId;
    var smallDivErrText = 'smallDivErrText_'+genId;
    var dlg = undefined;
    var dId = getParameterByName('dialogId');
    if(dId){
        parent.App.resizeIframeMap(dId);
    }
   /* if(parent){
        parent.$('body').append('<div id="'+id+'" class="error-report-dialog" title="'+gis_app_55_5+'"></div>');
        dlg = parent.$('#'+id);
    }
    else{*/
        $('body').append('<div id="'+id+'" class="error-report-dialog" title="'+gis_app_55_5+'"></div>');
        dlg = $('#'+id);
    /*}*/

    var buttons = [];
    if(detail) {
        buttons.push({text:gis_app_55_6, click:moreHandler, 'class':'errorReportDialogMore', tabindex:-1});
    }
    buttons.push({text:gis_app_55_8, click:send, tabindex:-1, 'class':'errorReportDialogMail'});
    buttons.push({text:gis_app_55_9, click:close, tabindex:1,'class':'errorReportDialogOk'});

    var smallErr = '<div><table cellpadding="0" cellspacing="0" class="error-dialog-table">'+
        '<tbody><tr>'+
        '<td class="error-dialog-img">'+
        '<img src="/ui/images/err.png" width="50" height="50">'+
        '</td><td><div id="'+smallDivErrText+'" class="text"></div></td></tr></tbody></table>' +
        '</div>' +
        '<div class="detail" contenteditable="true" style="width:100%;height: 100%;"></div>';

    dlg.append(smallErr);
    $('#'+smallDivErrText).text(text);
    if(detail) {
        var address = (App.config && App.config.SUPPORT_ADDRESS !== undefined)?App.config.SUPPORT_ADDRESS:'';
        var paramStr = '';
        if(params !== undefined) {
            if(params.filename != undefined)
                paramStr += gis_senderrorreportdialog_16 + params.filename+"\n";
            if(params.functionname != undefined)
                paramStr += gis_senderrorreportdialog_17 + params.functionname+"\n";
            if(params.rawresponse != undefined)
                paramStr += 'rawresponse:' + params.rawresponse+"\n";
        }
        $('.detail', dlg).text(paramStr+gis_app_55_22+detail+'\n\n'+address);
    }
    dlg.dialog({
        resizable: false,
        modal:     true,
        dialogClass: 'ui-error-dialog gsi-zindex__global',
        width:     705,
        height:    135,
        close:     close,
        buttons:   buttons
    });

    function send() {
        var text   = $('.text',   dlg).text();
        var detail = errDetail;//$('.detail', dlg).text();

        var dialog = Object.create(SendErrorReportDialog);
        dialog.setData(
            gis_app_55_10+
            text+"\n\n"+
            gis_app_55_11+
            detail+"\n\n"
            , params, id, closeCallback);

        dialog.build();
    }

    function close() {
        if(closeCallback != undefined)
            closeCallback();
        dlg.dialog("close");
    }

    function moreHandler() {
        var detail = $('.detail', dlg);
        var text = $('.ui-dialog-buttonset .ui-button.errorReportDialogMore span.ui-button-text');
        if(detail.is(':visible')) {
            dlg.dialog({resizable:false, width:705, height: 135});
            text.text(gis_app_55_6);
            $('.error-dialog-table').show();
            detail.hide();
        }
        else {
            dlg.css({width: 705, height: 358});
            dlg.dialog({resizable:true});
            text.text(gis_app_55_7);
            $('.error-dialog-table').hide();
            detail.show();
        }
    }
};

/**
 * Диалог
 */
App.confirmDialog = function(text, buttons, params) {

    var dlg = undefined;
    /*if(parent){
        parent.$('body').append('<div class="confirmDialog"></div>');
        dlg = parent.$('.confirmDialog');
    }
    else{
        $('body').append('<div class="confirmDialog"></div>');
        dlg = $('.confirmDialog');
    }*/
    var dlg = $('<div class="confirmDialog"></div>');
    dlg.appendTo('body');
    if(params && params.html){
        dlg.html(text);
    }
    else{
        dlg.text(text);
    }
    var bts = buttons || {"   OK   ": function() { App.destroyDialog(null, dlg) }};
    var dialogClass = (params && params.dialogClass)? params.dialogClass: 'gsi-zindex__global';
    var defaultParams = {
        resizable: true,
        modal:     true,
        buttons:   bts,
        width:     400,
        minWidth:  150,
        maxWidth:  4000,
        minHeight: 10,
        dialogClass: dialogClass
    };
    dlg.dialog($.extend(defaultParams, params));
    return dlg;
};

App.infoDialog = function(text, id) {
    var defaultParams = {
        resizable: false,
        modal:     true,
        buttons:   null,
        width:     200,
        height:  55,
        dialogClass: 'ui-dialog-confirm noCloseButton'
    };
    id = id || App.generateUUID();
    var dlg = $('<div class="infoDialog" id="'+id+'"></div>');
    dlg.appendTo('body');
    dlg.text(text);
    dlg.dialog(defaultParams);
    return dlg;
};

App.showConfirmForm = function(opt_options) {
    var options = opt_options ? opt_options : {};
    var title = options.title || gis_core_1;
    var descr = options.descr || gis_core_17;
    var successCallback = options.successCallback;
    var bts = {
        "Да": function() {
            if(successCallback) successCallback();
            $( this ).dialog("close");
        },
        "Нет": function() {
            $( this ).dialog("close");
    }
    };

    var defaultParams = {
        resizable: false,
        modal:     true,
        buttons:   bts,
        width:     400,
        minWidth:  150,
        maxWidth:  400,
        minHeight: 10,
        title: title,
        dialogClass: 'ui-dialog-confirm'
    };

    var dlg = $('<div class="confirmDialog"></div>');
    dlg.appendTo('body');
    dlg.html(descr);
    dlg.dialog(defaultParams);
    return dlg;
};

/**
 * Диалог
 */
App.notSupportedDialog = function(text, buttons, params) {
    var bts = buttons || {"   OK   ": function() { $( this ).dialog("close"); }};

    var defaultParams = {
        resizable: true,
        modal:     true,
        buttons:   bts,
        width:     400,
        minWidth:  150,
        maxWidth:  4000,
        minHeight: 10
    };


    var dlg = $('<div class="confirmDialog"></div>');
    dlg.appendTo('body');
    dlg
        .text((text) ? text : gis_core_error_0)
        .dialog($.extend(defaultParams, params));

    return dlg;
};

/**
 * Открывает задачу. Структура Task может формироваться объектом UserSettings
 */
App.openTask = function(task, authStr, params) {
    // Хардкодные компоненты
    var dialog;
    var paramsStr = '';
    if(params){
        for(var p in params)
            paramsStr+='&'+p+'='+params[p];
    }
    if(task.name && (task.name === 'USER_OFFICE_DIALOG' || task.name === 'USER_OFFICE')) {
        dialog = Object.create(UserOfficeDialog);
        dialog.init();
        dialog.build();
    }
    else if(task.name && (task.name === 'TASK_OFFICE_DIALOG' || task.name === 'TASK_OFFICE')) {
        dialog = new TaskOfficeForm();
        dialog.build();
    }
    else if(task.name && task.name == 'USER_CHANGE') {
        dialog = new UserChangeDialog();
        dialog.setTargetUrl('main.html');
        dialog.build();
    }
        // Статическая HTML страничка в новом окне браузера
    // В mdl задан URL статического HTML файла
    else if(task.mdl && /\.html$/.test(task.mdl)) {
        //Условие для добавления к тестовому гриду параметров task и mdl, необходимых для корректной работы открытого окна
        //window.open(task.mdl, 'STATIC__'+task.name, 'height=600,width=800,menubar=no,location=no,directories=no,status=no,resizable=yes,scrollbars=yes');
        var url = task.mdl+
            "?task="+escape(task.name)+
            "&mdl="+escape(task.mdl) +
            "&rand="+Math.random()*1000000+escape(paramsStr);
        var currAuth  = '';
        if(task.auth == 'true'){
            if(authStr)
                currAuth = authStr;
            else
                currAuth = Auth.getAuthStr();
            url += '#'+currAuth;
        }
        if(task.newWindow == 'true')
            window.open(task.mdl+currAuth, 'EXTRA__'+task.name, 'height=600,width=800,menubar=no,location=no,directories=no,status=no,resizable=yes,scrollbars=yes');
        else
            window.location.href = url;
    }
        // Дополнительное окно с модулем в новом окне браузера
    // В mdl задан URL страницы mail.html с дополнительными параметрами
    else if(task.mdl && /\.html?$/.test(task.mdl)) {
        //window.open(task.mdl, 'EXTRA__'+task.name, 'height=600,width=800,menubar=no,location=no,directories=no,status=no,resizable=yes,scrollbars=yes');
        window.location.href = task.mdl;
    }
        // Переход на другую задачу в том же самом окне браузера
    // Иначе открываем задачу в том же самом окне
    else if(task.name && task.mdl) {
        //если флеш вариант, то выходим из main_js.html и переводим для обработки в main.html
        var url =
            "main.html"+
            "?task="+escape(task.name)+
            "&mdl="+escape(task.mdl) +
            "&rand="+Math.random()*1000000;
        if(task.mdl.indexOf('http://') !== -1 || task.mdl.indexOf('https://') !== -1) {
            url = task.mdl;
            var target = (task.newWindow !== 'true')?'_self':'_blank';
            window.open(url, target);
            return;
        }

        if(authStr) {
            url += '#'+authStr;
        }
        else {
            url += '#'+Auth.getAuthStr();
        }

        window.location.href = url;
    }
    else {
        //В остальных случаях генерируем ошибку, чтобы знать, почему не удалось запустить задачу
        App.errorReport(gis_app_55_14,gis_app_55_15+' name='+task.name+', mdl='+task.mdl,undefined,{filename:gis_filename_9, functionname:'App.openTask'});
    }
};


/*
 * Аналог config-a - объект, в котором хранятся все глобальные переменные
 * Получаем и парсим web.config так: var config = App.getClientConfig();
 * Используем так: var someParameter = App.config.hasOwnProperty(someProperty);
 * */
App.config = null;
/* Сразу по получению web.config'a нужно установить requestTimeout, чтобы все запросы уходили с этим таймаутом (значение таймаута в минутах) */
App.clientRequestTimeout = 0;
//путь к криватной директории из web.config
App.privatePath = "";
//Проекция геоданных из БД
App.projection = 'EPSG:4284';
//путь к предыдущей версии сайта
App.prevSite = '';//'/old55/main_js.html?task=MULT_MAIN&mdl=main_js.html';
App.newSite = '';
//флаг использования сервисов nodejs напрямую минуя апач
App.useDirectlyNodeService = false;
//Считывание конфига из web.config
App.getClientConfig = function(resultCallback){
    if (App.config===null) {
        function onGetClientConfigResult(resultXml) {
            App.config = {};
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                var doc = $($.parseXML(resultXml));
                //var nodes = doc.children('configuration').children('appSettings').children('add');
                var nodes = doc.find('add');
                // Цикл по текущему уровню
                nodes.each(function(){
                    var node = $(this);
                    //Обязательно поднимаем регистр ключа
                    App.config[node.attr('key').toUpperCase()] = node.attr('value');
                });
                //Сразу устанавливаем значение App.clientRequestTimeout из App.config['REQUEST_TIMEOUT']
                if (App.config.hasOwnProperty('REQUEST_TIMEOUT')) {
                    var timeout = parseFloat(App.config['REQUEST_TIMEOUT']);
                    if (timeout && timeout != undefined && !isNaN(timeout)) {
                        App.clientRequestTimeout = Math.round(timeout*60*1000);
                    }
                }
                if (App.config.hasOwnProperty('USE_DIRECTLY_NODEJS')) {
                    App.useDirectlyNodeService = App.config['USE_DIRECTLY_NODEJS'] === 'true';
                }

                //Сразу устанавливаем значение приватной директории App.PrivatePath из App.config['PRIVATE_PATH']
                if (App.config.hasOwnProperty('PRIVATE_PATH'))
                    App.privatePath = App.config['PRIVATE_PATH'];

                //Сразу устанавливаем значение приватной директории App.PrivatePath из App.config['PRIVATE_PATH']
                if (App.config.hasOwnProperty('PROJECTION'))
                    App.projection = App.config['PROJECTION'];
                if(App.config.hasOwnProperty('APP_60_SERVER')){
                    Services.updateMonoServices();
                }
            }
            catch(e) { // Распарсить XML не удалось, видимо это просто строка
                //Конфиг запрашиваем 1 раз для приложения, поэтому при любых ошибках сохраняем конфиг как пустой объект
            }
            finally {
                if(resultCallback)
                    resultCallback();
            }
        }

        function onGetClientConfigFail(resultXml) {
            App.config = {};
            if (resultXml.indexOf(gis_app_55_30) !== -1){
                App.errorReport(gis_app_55_33, resultXml.toString(),undefined,{filename:gis_filename_9, functionname:'App.getClientConfig_onGetClientConfigFail'});
                return;
            }
            App.errorReport(gis_app_55_20, resultXml.toString(),undefined,{filename:gis_filename_9, functionname:'App.getClientConfig_onGetClientConfigFail'});
            if(resultCallback)
                resultCallback();
        }

        function getReqParams() {
            return {
                descrId: 'SYS_SEM.xml#GET_CLIENT_CONFIG',
                descrType: 'select',
                data:'<root><data FILE="../../Web.config" /></root>'
            };
        }

        //При обращении к сервису без параметров, все равно нужно указывать пустой объект (null вызовет ошибку сервиса)
        //Возвращаем ссылку на запрос
        return App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getReqParams(), onGetClientConfigResult, onGetClientConfigFail);
    }
    else {
        //Конфиг уже загружен, возвращаем его
        if(resultCallback)
            resultCallback();
        return App.config;
    }
};


/*
 * Создание динамических iframe-ов
 * */
App.iframeIdsCount = 0;
//Создание очередного iframe с новым id по переданной ссылке
App.createIFrame = function(linkUrl,name){
    //Прибавляем общее количество iframe
    App.iframeIdsCount++;
    var iframe = document.createElement('iframe');
    iframe.frameBorder=0;
    iframe.name = name;
    iframe.width="100%";
    iframe.height="100%";
    iframe.id="iframe" + App.iframeIdsCount;
    iframe.setAttribute("src", linkUrl);
    return iframe;
};

/**
 * Функция генерайции UUID
 * */

App.generateUUID = function generateUUID() {
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x7|0x8)).toString(16);
    });
    return uuid;
};

// Установим заголовки приложения
$(document).ready(function(){
    //document.title = App.name+' '+App.version;
    //$('body.login h1').text(App.name+' '+App.version);
});



//устанавливаем куки
App.setCookie = function(cookieName, value, expires){
    var options = {
        path:    '/',
        expires: expires || 365*20 // Запомнить на 20 лет
    };
    $.cookie(cookieName, value, options);
};

//удаляем куки
App.removeCookie = function(cookieName){
    //код из флеша, т.к jquery $.removeCookie(this.cookieName);  не удаляет куки
    function  setCookie(name, value, days){
        if (days) {
            var date = new Date();
            date.setTime(date.getTime()+(days*24*60*60*1000));
            var expires = '; expires='+date.toGMTString();
        }
        else
            var expires = '';
        document.cookie = name + '=' + value+expires+'; path=/';
    }
    setCookie(cookieName,'',-1);
};

//проверяем наличие куков
App.hasCookie = function(cookieName){
    if(!$.cookie || !$.cookie(cookieName)) {
        return false;
    }
    return true;
};

App.getCookie = function(cookieName){
    return $.cookie(cookieName);
};

App.serverQueryXMLSplit1 = function (url, params, callbackResult, callbackFail) {
    var filename = params.descrId.split('#')[1];
    var xmlIndex =  params.xmlIndex;
    filename = filename+'_'+xmlIndex+'.xml';
    filename = filename.replace('_0.xml','.xml');//нулевой элемент без индекса
    var lpuHash = '';
    //добавлено хэширование лпу для доступа к персональной папке геокэша. Используем начальные ЛПУ
    if (WidgetMap.preloadLpuValues) {
        var lpus = [];
        WidgetMap.preloadLpuValues.forEach(function(lpu){
            if(lpu)lpus.push(Number(lpu.CODE));
        })
        lpuHash = CryptoJS.MD5(lpus.sort().join()) + '/';
    }

    var reqParams = {
        descrId: 'SYS_SEM.xml#GET_XML_FILE',
        descrType: 'select',
        dataType: 'text',
        data: '<root><data FILE="../../../' + App.privatePath + '/geo/' + lpuHash + filename + '"/></root>'
    };
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, reqParams, callbackResult, callbackFail, undefined, undefined, false);

    return undefined;
};

App.serverQueryJSON = function (url, callbackResult, callbackFail, triesCount) {
    if(!triesCount) triesCount = 4;
    var fileName = url.substr(url.lastIndexOf('/')+1);
    function sendRequest(triesCount){
        var req = $.ajax({
            url: url,
            timeout: 20000,
            cache: false,
            dataType: "json",
        });
        req.done(function(data) {
            callbackResult(data);
        });
        req.fail(function(jqXHR, textStatus, errorThrown){
            if(errorThrown === 'Not Found') errorThrown = '404'
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            if (fileName && textStatus === gis_app_55_31)
                textStatus = textStatus.replace(gis_app_55_34,gis_app_55_34 + ': ' + fileName);
            if(textStatus.indexOf('timeout')!=-1)
                callbackFail(gis_app_55_13+textStatus+' .'+errorThrown);
            else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(textStatus+'. '+errorThrown);
        });
        return req;
    }
    return sendRequest(triesCount);
};

App.serverQueryCadastreJSON = function (url, callbackResult, callbackFail,triesCount) {
    if(!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            url: url,
            timeout: 20000,
            cache: false,
            dataType: "json",
        });
        req.done(function(data) {
            callbackResult(data);
        });
        req.fail(function(jqXHR, textStatus, errorThrown){
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            if(textStatus.indexOf('timeout')!=-1)
                callbackFail(gis_app_55_21+textStatus+' .'+errorThrown);
            else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(textStatus+'. '+errorThrown);
        });
        return req;
    }
    return sendRequest(triesCount);
};

/**
 * Полное удаление диалогового окна
 * @param selector
 */
App.destroyDialog = function(id, selector){
    if(id)
        selector = '#' + id;
    try{
        $(selector).empty();
        $(selector).dialog('destroy').remove();
    }
    catch(ex){
    }
    finally {
        $(selector).empty();
    }
};

App.serverQueryXMLNode = function (url, params, callbackResult, callbackFail, returnReq) {
    url = App.formatNodeServiceUrl(url);
    var req = $.ajax({
        type: "POST",
        url: url,
        data: params,
        timeout: App.clientRequestTimeout,
        dataType: 'text'
    });

    var xmlData = "";

    req.done(function (resp) {
        xmlData = resp;//$(resp).find('string').text();
        //Вызываем переданную функцию для обработки результата
        callbackResult(xmlData);
    });

    req.fail(function (jqXHR, textStatus, errorThrown) {
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText=="timeout") {
            xmlData = gis_app_55_13;
        }
        //Вызываем переданную функцию для обработки результата
        callbackFail(xmlData);
    });

    return req;
};

App.serverQueryXMLNodeWithTries = function (url, params, callbackResult, callbackFail, triesCount) {
    url = App.formatNodeServiceUrl(url);
    if(!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });
        var xmlData = "";
        req.done(function (resp) {
            xmlData = resp;//$(resp).find('string').text();
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000);
                return;
            }
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(triesCount);
};


App.serverQueryXML2Node = function (url, params, callbackResult, callbackFail, handleEmptyFileError) {
    url = App.formatNodeServiceUrl(url);
    var internalServerErrorCounter = 5;
    handleEmptyFileError = handleEmptyFileError !== false;
    function sendRequest(internalServerErrorCounter){
        //url = window.location.origin+':3000'+ url.replace('.','');
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });

        var xmlData = "";

        req.done(function (resp) {
            var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(resp, 'fileName') + '. '+ gis_core_19);
            else{
                if(isEmptyFile) resp = App.EMPTY_FILE_TEMPLATE;
                xmlData = resp.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
                callbackResult(xmlData);
            }
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state()=="rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            else{
                if(jqXHR.statusText !== '' || jqXHR.statusText !== 'error')
                    xmlData = jqXHR.statusText;
                else xmlData = gis_app_55_23;
                xmlData = '<error>'+xmlData+'</error>';
            }

            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);

};

App.serverQueryXML3Node = function (url, params, callbackResult, callbackFail, handleEmptyFileError) {
    url = App.formatNodeServiceUrl(url);
    var internalServerErrorCounter = 5;
    handleEmptyFileError = handleEmptyFileError !== false;
    function sendRequest(internalServerErrorCounter){
        //url = window.location.origin+':3000'+ url.replace('.','');
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });

        var xmlData = "";

        req.done(function (resp) {
            var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(resp, 'fileName') + '. '+ gis_core_19);
            else{
                if(isEmptyFile) resp = App.EMPTY_FILE_TEMPLATE;
                xmlData = resp.replace(/&amp;/g, "&");//.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
                callbackResult(xmlData);
            }
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state()=="rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            else{
                if(jqXHR.statusText !== '' || jqXHR.statusText !== 'error')
                    xmlData = jqXHR.statusText;
                else xmlData = gis_app_55_23;
                xmlData = '<error>'+xmlData+'</error>';
            }

            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);

};

/**
 * Обертка для отправки запросов на сервер.
 * При успехе - возвращает вложенную XML.
 */
App.serverQueryNode = function(url, params, callback, fault) {
    url = App.formatNodeServiceUrl(url);
    var dfd = new $.Deferred();
    params.user =  Auth.getUserId();
    //url = window.location.origin+':3000'+ url.replace('.','');
    var req = $.ajax({
        type:     'POST',
        url:      url,
        data:     params,
        timeout:  App.clientRequestTimeout,
        dataType: 'text'
    });

    req.done(function(resp){
        var xmlData = resp;
        var doc;
        var errorText;

        try { // Иногда ответ в формате XML, а иногда в виде просто строки
            doc = $($.parseXML(xmlData));
            errorText = doc.find('error').text();
        }
        catch(e) { // Распарсить XML не удалось, видимо это просто строка
            doc = xmlData;
        }

        if(errorText) {
            if(fault)
                fault(errorText);
            dfd.rejectWith(null, [errorText]);
        }
        else {
            if(callback) {
                callback(doc);
            }
            dfd.resolveWith(null, [doc]);
        }
    });

    req.fail(function(jqXHR, textStatus, errorThrown){
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText === "timeout") {
            errorText = gis_app_55_13;
        }
        if(fault)
            fault(errorText);
        dfd.rejectWith(null, [errorText]);
    });

    return dfd;
};
/**
 *
 * @param {*} url
 * @param {*} params
 * @param {*} callbackResult
 * @param {*} callbackFail
 * @param {*} triesCount количество попыток
 * @param {*} handleEmptyFileError являющийся флагом, который используется для регулирования показа сообщения об ошибке.
 * @returns
 */
App.serverQueryNodeWithTries = function(url, params, callbackResult, callbackFail, triesCount, handleEmptyFileError) {
    url = App.formatNodeServiceUrl(url);
    handleEmptyFileError = handleEmptyFileError !== false;
    if (!triesCount)
        triesCount = 4;
    var dfd = new $.Deferred();
    params.user =  Auth.getUserId();
    //url = window.location.origin+':3000'+ url.replace('.','');
    function sendRequest(triesCount){
        var req = $.ajax({
            type:     'POST',
            url:      url,
            data:     params,
            timeout:  App.clientRequestTimeout,
            dataType: 'text'
        });
        req.done(function(resp){
            var xmlData = resp, doc, errorText;
            var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(xmlData, 'fileName') + '. '+ gis_core_19);
            else{
                if(isEmptyFile) xmlData = App.EMPTY_FILE_TEMPLATE;
                try { // Иногда ответ в формате XML, а иногда в виде просто строки
                    doc = $($.parseXML(xmlData));
                    errorText = doc.find('error').text();
                }
                catch(e) { // Распарсить XML не удалось, видимо это просто строка
                    doc = xmlData;
                }

                if(errorText) {
                    if(callbackFail)
                        callbackFail(errorText);
                    dfd.rejectWith(null, [errorText]);
                }
                else {
                    if(callbackResult) {
                        callbackResult(doc);
                    }
                    dfd.resolveWith(null, [doc]);
                }
            }
        });
        req.fail(function(jqXHR, textStatus, errorThrown){
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                errorText = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            if(callbackFail)
                callbackFail(errorText);
            dfd.rejectWith(null, [errorText]);
            callbackFail(xmlData);
        });
        return dfd;
    }
    return sendRequest(triesCount);
};


App.serverQueryXMLGridNode = function (url, params, callbackResult, callbackFail, canAbort) {
    url = App.formatNodeServiceUrl(url);
    var internalServerErrorCounter = 5;
    //url = window.location.origin+':3000'+ url.replace('.','');
    function sendRequest(internalServerErrorCounter){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });

        var xmlData = "";

        req.done(function (resp) {
            xmlData = resp;
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //случай, если происходит отмена запроса во время фильтра грида
            if(canAbort === true && errorThrown === 'abort' && jqXHR.status === 0){
                return;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);
};


App.serverQueryXMLNode1 = function (url, params, callbackResult, callbackFail, returnReq) {
    url = App.formatNodeServiceUrl(url);
    var req = $.ajax({
        type: "POST",
        url: url,
        data: params,
        timeout: App.clientRequestTimeout,
        dataType: 'xml'
    });

    var xmlData = "";

    req.done(function (resp) {
        xmlData = $(resp).find('string').text();
        //Вызываем переданную функцию для обработки результата
        callbackResult(xmlData);
    });

    req.fail(function (jqXHR, textStatus, errorThrown) {
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText === "timeout") {
            xmlData = gis_app_55_13;
        }
        //Вызываем переданную функцию для обработки результата
        callbackFail(xmlData);
    });

    return req;
};

App.serverQueryXML2Node1 = function (url, params, callbackResult, callbackFail) {
    var internalServerErrorCounter = 5;
    function sendRequest(internalServerErrorCounter){
        url = App.formatNodeServiceUrl(url);
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });

        var xmlData = "";

        req.done(function (resp) {
            xmlData = resp.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);

};

App.serverQueryXMLGridNewNode = function (url, params, result, fail, returnReq, processId) {
    var internalServerErrorCounter = 5;
    function sendRequest(internalServerErrorCounter){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            jsonp: "jsonp",
            cache: false
        });

        var xmlData = "";
        //результат может прийти, как удачный json, там и ошибка в xml
        req.done(function (resp) {
            try{
                if(resp){
                    var xmlData = $(resp).find('string').text();
                    if(xmlData !== '')
                        resp = $(resp);
                }
            }
            catch (e) {}
            if(result){
                result(resp, processId);
            }
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            if(fail)
                fail(xmlData, processId);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);
};

/******** nodejs json requests *********/
App.getJsonNode = function(url, params, result, fault, method, triesCount) {
    if(!triesCount) triesCount = 4;
    if(!method) method = 'POST';
    url = App.formatNodeServiceUrl(url);
    var url = App.formatNodeServiceUrl(url );
    if(params === undefined)
        params = {};
    function sendRequest(triesCount){
        var req = $.ajax({
            type: method,
            url: url,
            data:params,
            timeout: App.clientRequestTimeout,
            dataType: 'json',
            jsonp: "jsonp",
            cache: false
        });
        req.done(function (resp) {
            (resp && (resp.status === 200 || resp.code === 200 )) ?
                result(resp) : fault(resp);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
            }else if(fault) {
                fault(textStatus);
            }
        });
        return req;
    }
    return sendRequest(triesCount);
};

App.jsonNode = function(url, params, result, fault, method, triesCount) {
    if(!triesCount) triesCount = 4;
    if(!method) method = 'POST';
    function sendRequest(triesCount){
        var req = $.ajax({
            type: method,
            url: url,
            data: params || {},
            timeout: App.clientRequestTimeout,
            dataType: 'json',
            jsonp: "jsonp",
            cache: false
        });
        req.done(function (resp) {
            (resp && (resp.status === 200 || resp.code === 200 )) ?
                result(resp) : fault(resp);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
            }else if(fault) {
                fault(textStatus);
            }
        });
        return req;
    }
    return sendRequest(triesCount);
};

/**
 *
 * @param url
 * @param params
 * @param result
 * @param fault
 * @param processId
 * @param triesCount
 * @param requestOptions
 * @returns {*}
 */
App.getJsonTextNode = function (url, params, result, fault, processId, requestOptions, triesCount) {
    var url = App.formatNodeServiceUrl(url);
    if (!triesCount)
        triesCount = 4;
    if (params === undefined)
        params = {};
    var method = (requestOptions && requestOptions.method) ? requestOptions.method : 'POST';
    var dataType = (requestOptions && requestOptions.dataType) ? requestOptions.dataType : 'text';

    function sendRequest(triesCount) {
        var req = $.ajax({
            type: method,
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: dataType,
            jsonp: "jsonp",
            cache: false
        });
        req.done(function (resp) {
            if(result)
                result(resp, processId);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            textStatus = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                textStatus = gis_app_55_13;
            }
            else if (triesCount > 0) {
                --triesCount;
                setTimeout(function () {
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            if (fault)
                fault(textStatus, processId);
        });
        return req;
    }

    return sendRequest(triesCount);
};

App.getUTEProcessStatus = function(processId, isNodeMonitor, result, fault) {
    var url = App.formatNodeServiceUrl('./api/status/ute-process-status');
    var req = $.ajax({
        type: "GET",
        url: url,
        data: { processId: processId, place: (isNodeMonitor)?'node':'ute'},
        timeout: 9000,// на секунду меньше, чем интервал вызова
        dataType: 'json',
        jsonp: "jsonp",
        cache: false
    });
    req.done(function (resp) {
        result(resp);
    });
    req.fail(function (jqXHR, textStatus, errorThrown) {
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        textStatus = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
        fault(textStatus);
    });
    return req;
};
//upd. 03.03.21 принято решение не выносить в конфиг
App.REQUEST_ERROR_TRIES = 5;
App.getUTEProcessStatus1 = function(processId, result, fault) {
    var internalServerErrorCounter = App.REQUEST_ERROR_TRIES; //5
    function sendRequest(internalServerErrorCounter) {
        var url = App.formatNodeServiceUrl('./api/status/ute-process-status');
        var req = $.ajax({
            type: "GET",
            url: url,
            data: {processId: processId},
            dataType: 'json',
            jsonp: "jsonp",
            cache: false
        });
        req.done(function (resp) {
            result(resp);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            if (internalServerErrorCounter > 0) {
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            fault(textStatus);
        });
    };
    return sendRequest(internalServerErrorCounter);
}


/**
 *
 * @param url
 * @param params
 * @param callbackResult
 * @param callbackFail
 * @param method
 * @param triesCount количество попыток
 * @param handleEmptyFileError являющийся флагом, который используется для регулирования показа сообщения об ошибке.
 * @returns {jQuery|{getAllResponseHeaders: function(): *|null, abort: function(*=): this, setRequestHeader: function(*=, *): this, readyState: number, getResponseHeader: function(*): null|*, overrideMimeType: function(*): this, statusCode: function(*=): this}}
 */
App.serverQueryXmlFileNodeWithTries = function (url, params, callbackResult, callbackFail, method, triesCount, handleEmptyFileError) {
    if(!method) method = 'POST';
    url = App.formatNodeServiceUrl(url);
    handleEmptyFileError = handleEmptyFileError !== false;
    if(!triesCount)
        triesCount = 4;

    function sendRequest(triesCount){
        var req = $.ajax({
            type: method,
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });
        req.done(function (resp) {
            var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(resp, 'fileName') + '. '+ gis_core_19);
            else{
                if(isEmptyFile) resp = App.EMPTY_FILE_TEMPLATE;
                callbackResult(resp);
            }

        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(triesCount);
};
/**
 *
 * @param {*} url
 * @param {*} descrId
 * @param {*} fileName
 * @param {*} callback
 * @param {*} handleEmptyFileError являющийся флагом, который используется для регулирования показа сообщения об ошибке.
 * @returns
 */
App.serverQueryXmlFileNode1 = function(url, descrId, fileName, callback, handleEmptyFileError) {
    url = App.formatNodeServiceUrl(url);
    handleEmptyFileError = handleEmptyFileError !== false;
    var params = {
        descrId: descrId,
        descrType: 'select',
        data:'<root ><data FILE="'+fileName+'"/></root>'
    };
    var dfd = new $.Deferred();
    params.user =  Auth.getUserId();
    var req = $.ajax({
        type:     "POST",
        url:      url,
        data:     params,
        timeout:  App.clientRequestTimeout,
        dataType: 'text'
    });

    req.done(function(resp){
        var xmlData = resp, doc, errorText;
        var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;

        if (isEmptyFile && handleEmptyFileError)
            callback(gis_core_21 + App.getAttributeFromXml(xmlData, 'fileName') + '. '+ gis_core_19);
        else{
            if (isEmptyFile) xmlData = App.EMPTY_FILE_TEMPLATE;
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                doc = $($.parseXML(xmlData));
                errorText = doc.find('error').text();
            }
            catch(e) { // Распарсить XML не удалось, видимо это просто строка
                doc = xmlData;
            }
            if(errorText) {
                dfd.rejectWith(null, [errorText]);
            }
            else {
                if(callback)
                    callback(doc);
                dfd.resolveWith(null, [doc]);
            }
        }
    });

    req.fail(function(jqXHR, textStatus, errorThrown){
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText === "timeout") {
            errorText = gis_app_55_13;
        }
        dfd.rejectWith(null, [errorText]);
    });

    return dfd;
};

App.formatNodeServiceUrl = function(url){
    $.support.cors = true;
    if(App.useDirectlyNodeService){
        if(window.location.origin)
            url = window.location.origin+':3000'+ url.replace('.','');
        else
            url = window.location.protocol+'//'+window.location.host+':3000'+ url.replace('.','');
    }
    return url;
}

App.areCookiesEnabled = function() {
    try {
        document.cookie = 'cookietest=1';
        var cookiesEnabled = document.cookie.indexOf('cookietest=') !== -1;
        document.cookie = 'cookietest=1; expires=Thu, 01-Jan-1970 00:00:01 GMT';
        return cookiesEnabled;
    } catch (e) {
        return false;
    }
}

App.showCookieMessage = function(message){
    var div = $('.cookie-button');
    if(div.length > 0)
        div.remove();

    $('body').append('<div class="cookie-button show" >' + message + '<button>X</button></div>');
    $('.cookie-button :button').click(function(){
        $('.cookie-button').remove();
    });
}


/**
 * Базовая функция подготовки параметров запроса.
 * @param requestId
 * @param data
 */
App.composeRequestParams = function(requestId, data){
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    return {
        descrId: requestId,
        descrType: 'select',
        data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '" >'+
            DBUtil.serializeData(data) +
            '</root>'
    };
};



App.formattedQueryNode = function (url, params, callbackResult, callbackFail,triesCount) {
    url = App.formatNodeServiceUrl(url);
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });
        var xmlData = "";
        req.done(function (resp) {
            try{
                var er = HTTPServiceUtil.getError(resp);
                if (er !== '') {
                    callbackResult({error:er});
                }
                else{
                    var resData = $($.parseXML(resp)).find("data");
                    var resArr = [];
                    if(resData && resData.length > 0 ){
                        var obj = {};
                        for (var i=0; i< resData[0].attributes.length; i++) {
                            obj[resData[0].attributes[i].name] = resData[0].attributes[i].value;
                        }
                        resArr.push(obj);
                    }
                    callbackResult({data: resArr});
                }
            }
            catch(ex){
                callbackResult({error:ex.message});
            }
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText=="timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail({error: xmlData});
        });
        return req;
    }
    return sendRequest(triesCount);
};

App.saveMultigeomDataWithTries = function (dataObject, pasteMultiFeature,callbackResult, callbackFail, triesCount) {  
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: 'POST',
            url: dataObject.requestUrl,
            data: dataObject.requestParams,
            timeout: App.clientRequestTimeout,
            dataType: 'xml',
        });
        req.done(function (resp) {
            callbackResult(resp);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(xmlData);
        });
    }
    return sendRequest(triesCount);
};
App.getClosestPointWithTries = function (url,callbackResult,callbackFail,triesCount){
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: "GET",
            url: url,
            data: {},
            timeout: 5000,
            dataType: 'json',
            jsonp: "jsonp",
            cache: true
        });
        req.done(function (data) {
            callbackResult(data);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail();
        });
        //Возвращаем ссылку на запрос (для возможности отмены запроса)
        return req;
    }
    return sendRequest(triesCount);
}

App.getClosestPathWithTries = function (url,callbackResult,callbackFail,triesCount){
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: "GET",
            url: url,
            data: {},
            timeout: 5000,
            dataType: 'json',
            jsonp: "jsonp",
            cache: true
        });
        req.done(function (data) {
            callbackResult(data);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(xmlData);
        });
        //Возвращаем ссылку на запрос (для возможности отмены запроса)
        return req;
    }
    return sendRequest(triesCount);
}
App.serverQueryStringWithTries = function (url, params, callbackResult, callbackFail, triesCount){
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: 'POST',
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'xml',
        });
        req.done(function (data) {
            callbackResult(data);
        });
        req.fail(function(jqXHR, textStatus, errorThrown){
            var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                errorText = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(errorText);
        });
        return req;
    }
    return sendRequest(triesCount);
}

App.serverQueryStringNodeWithTries = function (url, params, callbackResult, callbackFail, triesCount){
    if (!triesCount)
        triesCount = 4;

    function sendRequest(triesCount) {
        var req = $.ajax({
            type: 'POST',
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text',
        });
        req.done(function (data) {
            callbackResult(data);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                errorText = gis_app_55_13;
            } else if (triesCount > 0) {
                --triesCount;
                setTimeout(function () {
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(textStatus);
        });
        return req;
    }
    return sendRequest(triesCount);    
}
/**
 *
 * @param {*} url
 * @param {*} params
 * @param {*} callbackResult
 * @param {*} callbackFail
 * @param {*} triesCount
 * @param {*} handleEmptyFileError являющийся флагом, который используется для регулирования показа сообщения об ошибке.
 * @returns
 */
App.serverQueryNodeWithTries2 = function(url, params, callbackResult, callbackFail, triesCount, handleEmptyFileError){
    if (!triesCount)
        triesCount = 4;
    handleEmptyFileError= handleEmptyFileError !== false;
    function sendRequest(triesCount) {
        var req = $.ajax({
            type: 'POST',
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text',
        });
        req.done(function (data) {
            var isEmptyFile = data.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile) data = App.EMPTY_FILE_TEMPLATE;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(data, 'fileName') + '. '+ gis_core_19);
            else
                callbackResult(data);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                errorText = gis_app_55_13;
            } else if (triesCount > 0) {
                --triesCount;
                setTimeout(function () {
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(errorText);
        });
        return req;
    }
    return sendRequest(triesCount);
}
/**
 * Пасринг ошибки при отсутсвие на сервере файла.
 * @param {*} inputXmlStr <string><root attributes/></string>
 * @returns значение атрибута
 */
App.getAttributeFromXml = function (inputXmlStr, attribute) {
    try{
        //Получаем xml с данными в виде структуры (берем корневой элемент, т.е. root)
        var inputXml = ($.parseXML(inputXmlStr)).firstChild;
        return inputXml.firstElementChild.getAttribute(attribute);
    }catch(ex){};
};


App.convertDataXmlToArray = function(inputDataStr, toUpper){
    var dataArr = []
    try{
        $(inputDataStr).find('data').each(function () {
            var newDataObj = {};
            //TODO то modern loop
            for (var curAttrInd = 0; curAttrInd < this.attributes.length; curAttrInd++) {
                var name = this.attributes[curAttrInd].name;
                if(toUpper) name = name.toUpperCase();
                newDataObj[name] = this.attributes[curAttrInd].value;
            }
            dataArr.push(newDataObj);
        });
    }
    catch (ex){}
    return dataArr;
}

/**
 * Функция ресайза карты, открытой в iframe
 *
 * @param dialogId
 */
App.resizeIframeMap = function(dialogId){
    var dashboard = App.dashboardManager.getCurrentDashboard();
    var maps = dashboard.getMaps();
    maps.forEach(function(map){
        if(map.mapId === dialogId){
            var mapDlg = $('#'+map.mapId);
            mapDlg.dialog("option", "height", $(window).height() - 40);
            mapDlg.dialog("option", "width", $(window).width() - 40);
            mapDlg.dialog("option", "position", [20, 20]);
        }
        //var parent = mapDlg.parent();
    });
}
/**
 * Всякие действия по авторизации
 */
Auth = {};
Auth.getParameterByName = function(name){
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
};

// Запомитаем хеш с которым была открыта страница (а то потом он будет убран из адресной строки)
Auth.hash = window.location.hash;

// Сотрем хеш, если не указана флешка.
// Иначе хеш потребуется самой флешке, которая его прочитает и сама потом почистит
if(! /task=([^&#\^]+)&mdl=([^&#\^]+)/.test(window.location.href)) {
    var m = /^(.*)#(.*)$/.exec(window.location.href);
    if(m) {
        window.location.href = m[1]+'#';
    }
}

Auth.cookieName = "gis_gots_web53_cookie";

/**
 * Пытаемся залогинится.
 * Если не получилось то ругаемся.
 * Если получилось, то переходим на дефолтную страницу пользователя
 */
Auth.login = function(login, password, remember, targetUrl) {
    function rememberLastLogin(login) {
        var options = {
            path:    '/',
            expires: 365*20 // Запомнить на 20 лет
        };
        var str = 'login='+login;
        $.cookie(Auth.cookieName+'_last_login', str, options);
    }

    var loginDfd = $.Deferred();

    // Запрашиваем авторизацию
    $.post(Services.loginNode, {login:login, password:password},
        function(resp){
        var er = HTTPServiceUtil.getError(resp);
        if(er !== ''){
            //вызываем доп форматирование ошибки логина, чтобы не выводило пользователям пароль в чистом виде
            er = HTTPServiceUtil.getLoginError(resp, login);
            //send audit event
            LogUtil.sendAuditEvent( login, AuditEventType.USER_LOGIN, 'false');
            App.errorReport(gis_auth_55_1 + gis_auth_55_1_1, er, undefined,{filename:gis_filename_110, functionname:'gis_filename_110_8'});
            loginDfd.rejectWith(this, [er]);
            return;
        }
        var jsonData = JSON.parse(resp);

        Auth._removeCookie();
        // Нам вернули юзера. Запомним в куках.
        if(jsonData.id) {
            var chk    = CryptoJS.MD5(login+'system_check'+login);
            var uid    = jsonData.uid;
            var userId = jsonData.id;

            //Проверяем, первый ли раз мы заходим под этим пользователем. Если первый - нужно выдавать диалог смены пароля.
            var userLogonTime = null;
            var requestParams = { descrType: 'select', descrId: 'SYS_SEM.xml#WEB50_B_USER_PRIVATE', toElements: false, getSchema: false,
                data: '<root USER_ID="'+userId+'" USER_LOGIN="'+login+'" PODS_USER="'+login+'" ><data SYS_OBJ_ID="'+userId+'"/></root>' };
            //Устанавливаем курсор ожидания
            BlockingUtil.wait();
            App.serverQueryXMLNodeWithTries(Services.processQueryNode, requestParams, function onCheckUserResult(resultXML){
                //Снимаем курсор ожидания
                BlockingUtil.ready();
                if (resultXML) {
                    var er = HTTPServiceUtil.getError(resultXML);
                    if (er=='') {
                        userLogonTime = $($.parseXML(resultXML)).find('data').attr('LOGONTIME');
                        checkLogon(userLogonTime);
                    } else {
                        App.errorReport(gis_auth_55_1, er, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_1'});
                    }
                }
            },
            function onCheckUserFault(resultXML){
                //Снимаем курсор ожидания
                BlockingUtil.ready();
                if (resultXML) {
                    var er = HTTPServiceUtil.getError(resultXML);
                    App.errorReport(gis_auth_55_1, er, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_2'});
                }
                //checkLogon();
            });
            function checkLogon(userLogonTime){
                //Пользователь залогинился успешно, но устанавливать  - устанавли
                //Если первый раз заходим - атрибута нет или в нем пусто
                if (!userLogonTime || userLogonTime=='') {
                    //Показываем форму смены пароля
                    var dialog = Object.create(ChangeFirstPasswordDialog);
                    dialog.userLoginPassChange = login;
                    dialog.userIdChange = userId;
                    dialog.build();
                    loginDfd.reject(this);
                    return;
                } else {
                    //Иначе фиксируем последнее время входа
                    var requestParams = { descrType: 'update', descrId: 'SYS_SEM.xml#WEB50_B_USER_PRIVATE_REG', toElements: false, getSchema: false,
                        data: '<root><data SYS_OBJ_ID="'+userId+'"/></root>' };
                    App.serverQueryNodeWithTries(Services.processQueryNode, requestParams);
                }

                // Выбрано "запомнить"
                if(remember) {
                    var str = "login="+login+"||UID="+uid+"||chk="+chk+"||ID="+userId;
                    var options = {
                        path:    '/',
                        expires: 365*20 // Запомнить на 20 лет
                    };
                    $.cookie(Auth.cookieName, str, options);
                }

                // Надо считать главное меню, чтобы перети на дефолтную задачу пользователя
                var tasksDef = $.get(Services.userTasksNode, {user:login,"_": $.now()}, null, 'text');
                tasksDef.done(function(resultXml){
                    var er = HTTPServiceUtil.getError(resultXml);
                    if(er !== ''){
                        App.errorReport(gis_main55_4, er, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_3'});
                        return;
                    }
                    //var xml = $($.parseXML(xmlData));
                    var xml = $($.parseXML(resultXml));
                    var menu = new UserSettings();
                    menu.setContainer($('nav.menu'));
                    menu.setXml(xml);

                    var defaultTask = menu.getDefaultTask();
                    var authStr = Auth.makeAuthStr(login, uid, userId);

                    //проверка, если в url указан task, то он должен быть в списке новом, иначе игнорируем и грузим дефолтную задачу
                    var urlTask = Auth.getParameterByName('task');
                    var urlMdl = Auth.getParameterByName('mdl');

                    if(!menu.hasTaskAndMdlInMenu(urlTask,urlMdl)){
                        if(urlTask != '' && urlMdl != '' && targetUrl != undefined){
                            App.errorReport(gis_auth_55_7, gis_auth_55_8, function(){
                                var splitHref = window.location.href.split('?')[0];
                                window.location.href = splitHref;//+'?#'+authStr;
                            });
                        }
                        else{
                            if(defaultTask) {
                                App.openTask(defaultTask, authStr);
                            }
                            // Нет дефолтной задачи у этого пользователя
                            else {
                                var splitHref = window.location.href.split('?')[0];
                                window.location.href = splitHref + '?#' + authStr;
                            }
                        }
                    }else{
                        // Переходим на URL если какой то был задан
                        if(targetUrl) {
                            window.location.href = targetUrl+'#'+authStr;
                        }
                        else {
                            // Переходим на дефолтную задачу
                            if(defaultTask) {
                                App.openTask(defaultTask, authStr);
                            }
                            // Нет дефолтной задачи у этого пользователя
                            else {
                                var splitHref = window.location.href.split('?')[0];
                                window.location.href = splitHref+'?#'+authStr;
                            }
                        }
                    }
                    rememberLastLogin(login);

                    loginDfd.resolveWith(this, [login]);
                });
            }

        }
        // Не пустили
        else if(resp) {
            //send audit event
            LogUtil.sendAuditEvent(login, AuditEventType.USER_LOGIN, 'false');

            var errorText = resp;
            App.errorReport(gis_auth_55_1, errorText, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_5'});
            loginDfd.rejectWith(this, [errorText]);
        }
        // Вообще неадекватный ответ сервера
        else {
            //send audit event
            LogUtil.sendAuditEvent(login, AuditEventType.USER_LOGIN, Auth.getUid(), 'false');
            App.errorReport(gis_auth_55_1, gis_auth_55_2, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_6'});
            loginDfd.reject(this);
        }
    }, 'text')
        .fail(function(jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            App.errorReport(gis_auth_55_1, textStatus, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_7'});
            loginDfd.reject(this);
        });

    return loginDfd.promise(this);
};

/**
 * Устанавливает хеш авторизации, если параметры были запомнены в куках
 */
Auth.autoAuthorization = function(){
    // Уже авторизованы
    if(Auth.isAuthorized()) {
        //send audit event
        LogUtil.sendAuditEvent(Auth.getUserId(), AuditEventType.USER_LOGIN, 'true');
        return;
    }

    // Нет куки
    if(!$.cookie || !$.cookie(Auth.cookieName)) {
        return;
    }
    /*if($.cookie(Auth.cookieName)==null)
        return;*/

    var targetUrl;
    var m = /task=([^&#\^]+)&mdl=([^&#\^]+)([^$#]*)/.exec(window.location.href);
    if(m) {
        targetUrl = 'main_js.html?task='+m[1]+'&mdl='+m[2]+'&rand='+Math.random()+m[3];
    }
    else {
        targetUrl = 'main_js.html?rand='+Math.random();
    }

    var authStr = Auth.makeAuthStr(
        Auth.parseCookiePart('user'),
        Auth.parseCookiePart('uid'),
        Auth.parseCookiePart('id')
    );

    window.location.href = targetUrl+'#'+authStr;
};

/**
 * Выход и перескок на стартовую страницу
 */
Auth.logout = function() {
    //send audit event
    LogUtil.sendAuditEvent(Auth.getUserId(), AuditEventType.USER_LOGOUT, 'true');

    Auth._removeCookie();
    window.location.href = 'login.html';
};

/**
 * Проверка что мы авторизованы (по параметрам их хэша)
 */
Auth.isAuthorized = function() {
    return !!Auth.getUserName() && !!Auth.getUserId() && Auth.isChkOk();
};

Auth.isChkOk = function() {
    return (Auth.parseHashPart('chk') === CryptoJS.MD5(Auth.getUserName() + 'system_check' + Auth.getUserName()).toString());
};

Auth.getUserName = function() {
    return Auth.parseHashPart('user');
};

Auth.getUserId = function() {
    return Auth.parseHashPart('id');
};

Auth.getUid = function() {
    return Auth.parseHashPart('uid');
};

Auth.getPass = function(){
    if(!!Auth.hash){
        var arr = Auth.hash.split('&');
        var i = 0;
        for(;i<arr.length;i++){
            if(arr[i].indexOf('pass=') != -1){
                return arr[i].substring(5);
            }
        }
    }
    return null;
};

Auth._removeCookie = function() {
    //код из флеша, т.к jquery $.removeCookie(Auth.cookieName);  не удаляет куки
    function  setCookie(name, value, days){
        if (days) {
            var date = new Date();
            date.setTime(date.getTime()+(days*24*60*60*1000));
            var expires = '; expires='+date.toGMTString();
        }
        else
            var expires = '';
        document.cookie = name + '=' + value+expires+'; path=/';
    }
    setCookie(Auth.cookieName,'',-1);
};


/**
 * Возвращает якорную строку авторизации для текущего пользователя
 */
Auth.getAuthStr = function() {
    if(!Auth.getUserName()) {
        return null;
    }
    else {
        var str =
            "login=" + Auth.getUserName() +
            "&UID="  + Auth.getUid() +
            "&chk="  + CryptoJS.MD5(Auth.getUserName() + 'system_check' + Auth.getUserName()) +
            "&ID="   + Auth.getUserId();
        return str;
    }
};

Auth.makeAuthStr = function(userName, uid, userId) {
    var str = "";
    str += "login=" + userName;
    str += "&UID="  + uid ;
    str += "&chk="  + CryptoJS.MD5(userName + 'system_check' + userName).toString();
    str += "&ID="   + userId;
    return str;
};

/**
 * Вытаскивает запрошенный кусок из авторизационной куки
 */
Auth.parseCookiePart = function(partName) {
    var str = $.cookie(Auth.cookieName);

    var m = /^login=(.+)\|\|UID=(.+)\|\|chk=(.+)\|\|ID=(.+)$/.exec(str);
    if(m) {
        var parts = {user:m[1], uid:m[2], chk:m[3], id:m[4]};
        return parts[partName];
    }
    return null;
};

Auth.parseHashPart = function(partName) {
    //замена парминха хэш части
    if(!!Auth.hash){
        var parts = {};
        var authStr = Auth.hash.replace('#','');
        var arr = authStr.split('&');
        var i = 0;
        for(;i<arr.length;i++){
            if(arr[i].indexOf('pass=') != -1){
                parts['pass'] = arr[i].substring(5);
            }
            if(arr[i].indexOf('chk=') != -1){
                parts['chk'] = arr[i].substring(4);
            }
            if(arr[i].indexOf('ID=') != -1){
                parts['id'] = arr[i].substring(3);
            }
            if(arr[i].indexOf('login=') != -1){
                parts['user'] = arr[i].substring(6);
            }
            if(arr[i].indexOf('UID=') != -1){
                parts['uid'] = arr[i].substring(4);
            }
        }
        return parts[partName];
    }
    return null;
    var m = /^#login=(.+)&UID=(.+)&chk=(.+)&ID=(.+)$/.exec(Auth.hash);
    if(m) {
        var parts = {user:m[1], uid:m[2], chk:m[3], id:m[4]};
        return parts[partName];
    }
    return null;
};

Auth.registration = function() {
    var text = gis_auth_55_3;

    var buttons = [
        {text:gis_core_4,  click:launchRegistrationDialog},
        {text:gis_core_5, click:closeDialog}
    ];

    var dlg = App.confirmDialog(text, buttons, {title:gis_auth_55_6, width:700});

    function closeDialog() {
        dlg.dialog('destroy');
        dlg.remove();
    }

    function launchRegistrationDialog() {
        closeDialog();

        var dialog = Object.create(UserRegistrationDialog);
        dialog.init();
        dialog.build();
    }
};

Auth.getLastLogin = function() {
    var lastLoginStr = $.cookie(Auth.cookieName+'_last_login');
    var re = /^login=([a-z0-9\.\_\-]+)$/i;
    var m = re.exec(lastLoginStr);
    if(m) {
        return m[1];
    }
    else {
        return '';
    }
};

Auth.Autorization = function(){
    //Устанавливаем параметры авторизации из cookies, если их нет (перезагружаем страницу с добавленными в url параметрами авторизации)
    //Новая проверка на наличие атрибука pass в хэше
    if(!!Auth.getPass()){
        var userPass = Auth.getPass();
        //удаляем из хеша pass
        var str = '&pass='+userPass;
        window.location.href = window.location.href.replace(str,'');
        Auth.hash = Auth.hash.replace(str,'');
        var userN = Auth.getUserName();
        Auth.login(userN, userPass, true);
        return;
    }

    Auth.autoAuthorization();

    // Если не авторизованы, то просим авторизовываться
    if(!Auth.isAuthorized()) {
        var dialog = new UserLoginDialog();
        dialog.setTargetUrl(window.location.href);
        dialog.build();
    }
    // Если авторизованы, то загружаем меню задач
    else {
        //Функция обратного вызова для получения списка задач пользователя
        function onGetUserTasksResult(resultXml){
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                if(App.userTasksLoadErrorCounter > 1)
                    if(resultXml.indexOf(gis_app_55_13) != -1) {
                        --App.userTasksLoadErrorCounter;
                        reLoadUserTasks();
                        return;
                    }
                App.errorReport(gis_main55_4, er, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_9'});
                return;
            }
            App.userTasksLoadErrorCounter = 0;
            //если в mdl есть .html, то остается на main_js.html, иначе редирект на main.html c теми же параметрами
            if(window.location.pathname.indexOf('main_js.html') != -1  && window.location.search.indexOf('mdl=') != -1){
                if (window.location.search.indexOf('.html') == -1){
                    window.location.href = window.location.pathname.replace('main_js.html','main.html')+window.location.search+window.location.hash;
                    return;
                }
            }
            var xml = $($.parseXML(resultXml));
            var menu = new UserSettings();
            menu.setContainer($('nav.menu-user'));
            menu.setXml(xml);
            menu.onChoice(function(task){
                App.openTask(task);
            });
            //Сохраняем экземпляр меню в App.menu
            App.menu = menu;
            // Если страница открыта без соответствующих параметров task и mdl, то откроем задачу по умолчанию
            if(!/task=([^&#\^]+)&mdl=([^&#\^]+)([^$#]*)/.test(window.location.href)) {
                var task = menu.getDefaultTask();
                if(task) {
                    App.openTask(task);
                }
                $('nav').show();
                menu.build();
            }
            // Страница загружена со всеми нужными параметрами
            else {
                menu.setMask(menu.getTaskFromUrl());
                var type = menu.getTaskType(menu.getTaskFromUrl());
                //если нашли по задаче из url её тип
                //прячем меню изначально(показываем, если тип задачи подходит)
                $('nav').hide();
                if(type !== undefined){
                    //если тип == "", то не показываем меню
                    if(type !== ''){
                        $('nav').show();
                        menu.build();
                    }
                    else{
                        fixSizes(false);
                    }
                    menu.setTitleByCurrentTask();
                }
                else{
                    //добавляем проверку, есть ли эта задачи в private/uitasks
                    fixSizes(false);
                }

                // Если авторизованы и загружено главное меню, то выясняем какой нам нужен swf
                if(Auth.isAuthorized()) {
                    //Менеджер панелей, конструирует по описанию задачи панели, в которых содержатся отдельные модули
                    $('.taskContent').append('<div class="panels" style="width:100%; height:100%; padding:0">'+gis_main55_1+'</div>');
                    //Запускаем получение описания задачи
                    var taskName = menu.getTaskFromUrl();
                    var urlMdl = menu.getMdlFromUrl();
                    var pm = new PanelManagerJson();
                    pm.setContainer($('.panels'));
                    if(urlMdl !== null && (urlMdl === 'main_js.html' || urlMdl === 'tech_schema_js.html'))
                        taskName = taskName.toLowerCase();
                    var taskMdl = menu.getTaskMdl(taskName);
                    //условие, что работаем с новой версией. Если не нашли в нижнем регистре, пробуем в верхнем
                    if(taskMdl !== null && (taskMdl === 'main_js.html' || taskMdl === 'shurf_schema_js.html' || taskMdl === 'tech_schema_js.html' )
                        || taskMdl === 'cas_js.html'
                    ){
                        App.serverQueryJSON('./Core/UITasks/'+taskName.toLowerCase()+'.json', result, fault);
                        function fault(res) {
                            App.errorReport(gis_main55_2, res, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_12'});
                        }
                        function result(res) {
                            try {
                                if (res !== undefined && res.code === 200) {
                                    pm.build(res, taskName);
                                }
                            }
                            catch(ex) {
                                App.errorReport(gis_main55_2, ex.message, undefined, {filename:gis_filename_110, functionname:'gis_filename_483_6'});
                            }
                        }
                    }else{
                        //проверка, является ли задача приватной, если да, то грузим её
                        App.getJsonNode(Services.hasTaskNode, {task: taskName}, function result(res) {
                            if (res !== undefined && res.code === 200) {
                                App.getJsonNode(Services.userTaskNode, {task: taskName}, function result(res) {
                                    try {
                                        if (res !== undefined && res.code === 200) {
                                           if(res.bRoleToTasks && res.bRoleToTasks.type === 'main'){
                                               $('nav').show();
                                               menu.build();
                                           }
                                            pm.build(res, taskName);
                                        }
                                    }
                                    catch(ex) {
                                        App.errorReport(gis_main55_2, ex.message, undefined, {filename:gis_filename_110, functionname:'gis_filename_483_6'});
                                    }
                                }, function fault(res) {
                                    App.errorReport(gis_main55_2, res.message, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_15'});
                                }, 'GET');
                            }
                        }, function fault(res) {
                            App.errorReport(gis_main55_2, res.message, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_16'});
                        }, 'GET');
                    }
                }
                else if (menu.getTaskFromUrl().indexOf('GRID') >= 0) {
                    App.errorReport(gis_main55_3, '', {filename:gis_filename_110, functionname:'gis_filename_110_13'});
                }
            }

        }

        //Функция обратного вызова для получения списка задач пользователя
        function onGetUserTasksFail(resultXml){
            if(App.userTasksLoadErrorCounter > 1)
                if(resultXml.indexOf(gis_app_55_13) != -1) {
                    --App.userTasksLoadErrorCounter;
                    reLoadUserTasks();
                    return;
                }
            App.userTasksLoadErrorCounter = 0;
            App.errorReport(gis_main55_4, resultXml.toString(), undefined, {filename:gis_filename_110, functionname:'gis_filename_110_14'});
        }
        function reLoadUserTasks(){
            var getUserTasksParams = {user:Auth.getUserName()};
            App.serverQueryXmlFileNodeWithTries(Services.userTasksNode,getUserTasksParams, onGetUserTasksResult, onGetUserTasksFail, 'GET');
        }

        //Запускаем получение списка задач пользователя
        var getUserTasksParams = {user:Auth.getUserName()};
        App.serverQueryXmlFileNodeWithTries(Services.userTasksNode,getUserTasksParams, onGetUserTasksResult, onGetUserTasksFail, 'GET');
    }
}

App.collectUserTasks = function(response){
    var xmlTasks = $('<data></data>');
    if(response){
        response.find('tasks').each(function () {
            xmlTasks.append($(this).children());
        });
    }
    return xmlTasks
}

/*
 * Построитель форм по MXML файлу
 */
function Form() {
    this.container = null;
    this.xml = null;
    this.values = {};
    this._width = null;
    this._height = null;
};

/*
 * Установка контейнера, в котором строим форму
 */
Form.prototype.setContainer = function(container) {
    this.container = container;
};

/*
 * Задает XML с описанием структуры формы
 */
Form.prototype.setXml = function(xml) {
    this.xml = xml;
};

/*
 * Задает значения полей в виде структуры имя-значение
 */
Form.prototype.setValues = function(values) {
    this.values = values;
};

/*
 * Возвращае текущие значения в элементах управления формы в виде структуры ключ-значение
 */
Form.prototype.getValues = function() {
    var values = {};
    
    this.container.find('input[name][type="text"], select[name]').each(function(){
        var input = $(this);        
        values[ input.attr('name') ] = input.val();
    });
    //обработка для чекбоксов и радио
    this.container.find('input[name][type="checkbox"]').each(function(){
        var input = $(this);
        values[ input.attr('name') ] = input.prop('checked');
    });
    this.container.find('input[name][type="radio"]').each(function(){
        var input = $(this);
        values[ input.attr('value') ] = input.prop('checked');
    });
    //обработка случая для атрибута THEME личных настроек, туда заносится строка json
    if(values.map_mode_raster !== undefined){
        //пока хардкодятся элементы
        values['theme']=JSON.stringify({
            MAP_MODE: (values.map_mode_raster === true)?'raster':'vector',
            SHOW_OVERVIEW_MAP: values.show_overview_map === true,
            SHOW_TREE: values.show_tree === true,
            SEND_CADASTRE_EMAIL: values.send_cadastre_email === true,
            SHOW_CENTER_MAP: values.show_center_map === true,
            COORD_MODE: (values.coord_mode_decimal === true)?'decimal':'grad',
            USE_SYNCHRONIZATION: values.use_synchronization === true,
        });
    }
    return values;
};

/*
 * Строит форму по заранее настроенным свойствам
 */
Form.prototype.build = function() {    
    // Рекурсивный пробег по MXML и строим по ней элементы управления
    function walkLevel(container, xmlNodes) {
        xmlNodes.each(function(){
            var xmlNode = $(this);
            var elem;
            // Считываем общие аттрибуты
            var cssWidth;                    
            var width = xmlNode.attr('width');
            if(/^(\d+)%$/) { // А вдруг указаны проценты
                cssWidth = width;
            }
            else if(width > 0) {
                cssWidth = width + 'px';
            }                    
            var percentWidth = xmlNode.attr('percentWidth');
            if(percentWidth > 0) {
                cssWidth = percentWidth*1 + '%';
            }
            var cssHeight = xmlNode.attr('height');
            if(cssHeight) { cssHeight += 'px'; }

            var cssTextAlign = xmlNode.attr('textAlign');                 

            var name = xmlNode.attr('id');
            if(name) {
                name = name.toLowerCase();
            }    
            var readOnly = (xmlNode.attr('editable') === 'false') || (xmlNode.attr('disabled') === 'true');
            var selected = (xmlNode.attr('selected') === 'true');
            var maxChars = xmlNode.attr('maxChars');
            var text = xmlNode.attr('text');
            var visible = (xmlNode.attr('visible') !== "false");
            var tooltip = xmlNode.attr('tooltip');
            var tabindex = xmlNode.attr('tabindex');
            //для радиокнопок
            var groupname = xmlNode.attr('groupName');
            var radiovalue = xmlNode.attr('value');
            var inp;
            // Вложенные контейнеры. Будет запущена рекурсия.
            if(xmlNode.is('mx\\:VBox')) {
                elem = $('<div class="vBox clearfix"></div>');
                if(cssWidth) { elem.css('width', cssWidth); }

                walkLevel(elem, xmlNode.children());
            }
            else if(xmlNode.is('mx\\:HBox')) {
                elem = $('<div class="hBox clearfix"></div>');
                if(cssWidth) { elem.css('width', cssWidth); }

                walkLevel(elem, xmlNode.children());
            }            
            
            // Прочие элементы управления
            else if(xmlNode.is('mx\\:Text')) {
                elem = $('<div class="control"><div class="text"></div></div>');
                text = $('.text', elem).text(text);
                if(cssWidth) { text.css('width', cssWidth); }
                if(cssTextAlign) { text.css('textAlign', cssTextAlign); }                
            }            
            else if(xmlNode.is('mx\\:TextInput')) {                
                if(xmlNode.attr('displayAsPassword') == "true") {
                    elem = $('<div class="control"><input type="password" /></div>');
                }
                else {
                    elem = $('<div class="control"><input type="text" /></div>');
                }                
                inp = $('input', elem);
                $('input', elem).attr('name', name);
                if(text)      { inp.attr('value', text); }             
                if(maxChars)  { inp.attr('maxlength', maxChars); }                        
                if(readOnly)  { inp.attr('readonly', 'readonly').addClass('readOnly');  }                        
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }                                                
                if(cssWidth)  { elem.css('width', cssWidth); }           
                if(!visible) { elem.css('visibility', 'hidden'); }
            }            
            else if(xmlNode.is('controls\\:NumberInput')) {
                elem = $('<div class="control"><input type="text" class="number" /></div>');
                inp = $('input', elem);

                inp.attr('name', name);
                if(readOnly) { inp.attr('readonly', 'readonly').addClass('readOnly');  }                        
                if(cssWidth) { elem.css('width', cssWidth); }                        
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }                                                
            }            
            else if(xmlNode.is('mx\\:ComboBox')) {                
                elem = $('<div class="control"><div class="selectWrap"><select /></div></div>');
                inp = $('select', elem);
                var wrap = $('.selectWrap', elem);
                inp.attr('name', name);
                if(readOnly) {
                    inp.attr('disabled', 'disabled');
                    wrap.addClass('readOnly'); 
                }                        
                xmlNode.children("mx\\:dataProvider, dataProvider").children('mx\\:Object, Object').each(function(){
                    var code  = $(this).attr('CODE').toLowerCase();                            
                    var label = $(this).attr('label');
                    var option = $('<option>').attr('value', code).text(label);                                                        
                    inp.append(option);
                });
                if(cssWidth) { elem.css('width', cssWidth); }                                
                
                if(!cssHeight) { cssHeight = '20px'; } // По умолчанию
                if(cssHeight) { wrap.css({'height':cssHeight, 'line-height':cssHeight}); } 
            }                           
            else if(xmlNode.is('mx\\:DateField')) {
                elem = $('<div class="control"><input type="text" class="date" maxlength="12" /></div>');
                inp = $('input', elem);

                if(readOnly) { inp.attr('readonly', 'readonly').addClass('readOnly');  }                        
                inp.attr('name', name);
                if(cssWidth) { elem.css('width', cssWidth); }
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }                                                
            }
            else if(xmlNode.is('mx\\:RadioButton')) {
                elem = $('<div class="control"><input type="radio"></div>');
                inp = $('input', elem);
                inp.attr('id', name);
                if(groupname) { inp.attr('name', groupname); }
                if(radiovalue) { inp.attr('value', radiovalue); }
                if(selected)  { inp.prop('checked', selected);  }
                if(cssWidth) { elem.css('width', cssWidth); }
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }
            }
            else if(xmlNode.is('mx\\:CheckBox')) {
                elem = $('<div class="control"><input type="checkbox"></div>');
                inp = $('input', elem);
                if(selected)  { inp.prop('checked', selected);  }
                inp.attr('name', name);
                if(cssWidth) { elem.css('width', cssWidth); }
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }

            }
            // Непонятный элемент            
            else {
                elem = $('<div class="unknown"></div>').text('<' + xmlNode.prop('tagName') + '>');
            }

            // Попробуем добавить tooltip
            if(tooltip && $(elem).is('div.control')) {
                $(elem).attr('title', tooltip);
            }
            // Попробуем добавить tabindex
            if(tabindex && $(elem).has('input, select').length > 0) {
                $('input, select', elem).attr('tabindex', tabindex);
            }

            // Добавляем построенный элемент в текущий контейнер
            if(elem) {
                container.append(elem);
            }
        });
    }        

    // Подготавливаем обвязку формы
    var mxForm = $('<div class="mxForm" />').appendTo(this.container);    
    this._width  = this.xml.children('DATA_EDIT_FORM').attr('width');
    this._height = this.xml.children('DATA_EDIT_FORM').attr('height');    
    if(this._width > 0) {
        mxForm.css('width', this._width+'px');
    }
    
    // Начальный запуск рекурсии обхода MXML
    walkLevel(mxForm, this.xml.children('DATA_EDIT_FORM').children('mx\\:VBox, VBox, mx\\:HBox, HBox'));

    // Устанавливаем значения в элементы управления
    $.each(this.values, function(name, value){             
        name = name.toLowerCase();
        var input = $('input[name="'+name+'"], select[name="'+name+'"]', mxForm);
        
        // Для полей типа "дата" - преобразуем формат даты
        if(input.hasClass('date')) {
            var date = /^(\d{4})\-(\d{1,2})\-(\d{1,2})/.exec(value);//YYYY-MM-DD
            if(!date){
                date = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(value);//DD.MM.YYYY
                value = date[1]+'.'+date[2]+'.'+date[3];
                //date = /^(\d{1,2})[.\/](\d{1,2})[.\/](\d{4})$/.exec(value);//DD.MM.YYYY
            }
            else
                value = date[3]+'.'+date[2]+'.'+date[1];
        }
        // Для списков - ловеркэйсим значения
        else if(input.is('select')) {
            value = value.toLowerCase();            
        }

        input.val(value);     
    });
    //обработка values колонки theme формата json
    if(this.values.THEME !== undefined){
        try{
            var theme = JSON.parse(this.values.THEME.replace(/&quot;/g,'"'));
            var showOverviewMap = theme.SHOW_OVERVIEW_MAP === true;
            var showTree = theme.SHOW_TREE === true;
            var sendCadastreEmail = theme.SEND_CADASTRE_EMAIL === true;
            var useSynchronization = theme.USE_SYNCHRONIZATION === true;
            var showCenterMap = theme.SHOW_CENTER_MAP === true;
            var selector = 'SHOW_OVERVIEW_MAP';
            var input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', showOverviewMap);
            selector = 'MAP_MODE'+(theme.MAP_MODE === 'raster'?'_RASTER':'_VECTOR');
            input = $('input[id="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', true);
            selector = 'SHOW_TREE';
            input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', showTree);
            selector = 'SEND_CADASTRE_EMAIL';
            input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', sendCadastreEmail);
            selector = 'USE_SYNCHRONIZATION';
            input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', useSynchronization);
            selector = 'SHOW_CENTER_MAP';
            input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', showCenterMap);
            selector = 'COORD_MODE'+(theme.COORD_MODE === 'decimal'?'_DECIMAL':'_GRAD');
            input = $('input[id="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', true);

        }
        catch(e){}

    }

    // Для полей типа даты, которые доступны к редактированию устанавливаем datepicker
    $('input.date', this.container).not('.readOnly').datepicker();
    
    $('.control').wrapInner('<div class="spacer" />');
};




/*
 * Возвращает ширину заданную в MXML
 */
Form.prototype.getWidth = function() {
    return parseFloat(this._width);
};

/*
 * Возвращает высоту заданную в MXML
 */
Form.prototype.getHeight = function() {
    return parseFloat(this._height);
};
/**
 * Класс для управления синхронизациями в приложении(перезагрузки гридов, центровки в других вкладках,..)
 *
 */
//перечень типов синхронизаций
SyncTypes = {
	TYPE_NO: -1,// ничего не должно происходить
	TYPE_1: 1,// таже вкладка, id слоя совпадает, в гриде нет фильтров - перезапрос + центровка
	TYPE_2: 2,// центровка без перезапроса по всем вкладкам при условии, что id слоя совпадает
	TYPE_3: 3,// грид должен перезаполняться и всё
	TYPE_4: 4,// перезапрос геометрии в других вкладках. В рамках задачи СУ ТС ТПА, чтобы при смене ранга опасности менялся цвет на карте в iframe
	TYPE_5: 5,// комбинация типа 3 и 4
}

function SyncManager(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	//флаг, включена ли синхронизация
	this.isOn = false;
	//храним интервал, чтобы при необходимости выключить синхронизацию
	this.interval;
	//находится ли в процессе выполнения синхронизация
	this.syncPending = false;
	//отправитель команды.
	this.commandSender = undefined; // ppanel$123123-12312f-343-34$PODS_VALVE:123
}

/**
 * Функция отключения мониторинга синхронизации
 */
SyncManager.prototype.turnOff = function () {
	if (this.isOn)
		clearInterval(this.interval);
}

/**
 * Функция включает миниторинг синхронизации
 */
SyncManager.prototype.turnOn = function () {
	var that = this;
	if (this.isOn)
		return;
	this.isOn = App.syncEnabled;
	this.interval = setInterval(function () {
		if (!App.syncEnabled)
			return;
		var syncObjectFromCookie = App.getCookie('gis_web77_sync_select_object');
		if (syncObjectFromCookie && !that.syncPending) {
			that.syncPending = true;
			setTimeout(function () {
				that.syncPending = false;
				var secondTryFromCookie = App.getCookie('gis_web77_sync_select_object');
				//случай, когда где-то кликнули быстро и кука поменяла значение, чтобы старый объект не выделять
				if (secondTryFromCookie !== undefined && syncObjectFromCookie !== secondTryFromCookie) {
					return;
				}
				that.dispatchSync(syncObjectFromCookie);
			}, 2000)// делаем подтормаживание в секунду, чтобы кука умерла и не
		}
	}, App.config.SYNC_INTERVAL * 1000 || 1000);
}


/**
 * Диспетчеризация пришедшей синхронизации
 * @param {string} syncDataFromCookie
 */
SyncManager.prototype.dispatchSync = function (syncDataFromCookie) {
	var that = this;
	if (!syncDataFromCookie)
		return;
	var uniqueWindowId = syncDataFromCookie.split('$')[0];
	var selectedObjectFromCookie = syncDataFromCookie.split('$')[1];
	var uniqueLayerName = syncDataFromCookie.split('$')[2];
	var syncType = this.parseSyncType_(syncDataFromCookie.split('$')[3]);//Number(syncDataFromCookie.split('$')[3]);
	if (uniqueLayerName === 'undefined')
		uniqueLayerName = undefined;
	var isCurrentTab = uniqueWindowId === App.UNIQUE_ID;
	if(isCurrentTab && (syncType === SyncTypes.TYPE_4 || syncType === SyncTypes.TYPE_5)) isCurrentTab = false;
	var ignoreErrors = !isCurrentTab;
	if (!isCurrentTab) {//текущая вкладка
		that.findObjectInGrid_(selectedObjectFromCookie, isCurrentTab, syncType);
		that.findObjectInMap_(selectedObjectFromCookie, ignoreErrors, isCurrentTab, uniqueLayerName, syncType);
	}
};


/**
 * Поиск объекта в гриде
 * @param selectedObject
 * @param {boolean} isCurrentTab
 * @param {SyncTypes} syncType
 * @private
 */
SyncManager.prototype.findObjectInGrid_ = function (selectedObject, isCurrentTab, syncType) {
	var that = this;
	if(syncType === SyncTypes.TYPE_4 || syncType === SyncTypes.TYPE_5)
		return;
	if (selectedObject && selectedObject.indexOf(':') !== -1) {
		var layId = selectedObject.split(':')[0];
		var semIdStr = selectedObject.split(':')[1];

		var tabNav = $('#gridTabNavigator');
		if (tabNav.length === 0)
			return;
		var tabLength = tabNav.jqxTabs('length');
		var isTabSelected = false;
		for (var i = 0; i < tabLength; i++) {
			var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
			var selector = $(selectedContent).find('.gridTabContentElement');
			if (selector.length === 0 && $(selectedContent).hasClass('gridTabContentElement')) {
				selector = $(selectedContent);
			}
			selector.each(function () {
				var gridContentId = $(this).attr('id');
				var dataAdapter = $('#jqxgrid' + gridContentId).jqxGrid('source');
				var currentGridDescr = dataAdapter.currentGridDescr;
				if (!currentGridDescr)
					return;
				var layerName = currentGridDescr.layerId;
				if (!checkMapExisting())
					return;
				var layers = WidgetMap.layerManager.getLayersBySynonym(layerName);
				layers.forEach(function (layerId) {
					if (layId === layerId) {
						var rows = $('#jqxgrid' + gridContentId).jqxGrid('getrows');
						var semIds = [];
						if (semIdStr && semIdStr.indexOf(',') !== -1)
							semIds = semIdStr.split(',');
						else {
							semIds = [semIdStr];
						}
						var finded = false;
						$('#jqxgrid' + gridContentId).jqxGrid('clearselection');
						semIds.forEach(function (semId, rowIndex) {
							rows.forEach(function (item, rowIndex) {
								if (item.ID === semId) {
									finded = true;
									if (!isTabSelected) {
										isTabSelected = true;
										tabNav.jqxTabs('select', i);
									}
									var dataInfo = $('#jqxgrid' + gridContentId).jqxGrid('getdatainformation');
									if (dataInfo && dataInfo.paginginformation) {
										rowIndex = rowIndex + dataInfo.paginginformation.pagesize * dataInfo.paginginformation.pagenum;
									}
									$('#jqxgrid' + gridContentId).jqxGrid('ensureRowVisible', 0);
									$('#jqxgrid' + gridContentId).jqxGrid('selectrow', rowIndex);
									$('#jqxgrid' + gridContentId).jqxGrid('ensureRowVisible', rowIndex);
									//$('#jqxgrid' + gridContentId).jqxGrid('selectrow', item);
								}
							});
						});

						if (finded) {
							//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
							widgetMoveWindowToPosition('grid', 'restore');
						} else {
							//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
							var titlebar = !(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.titlebar === false);
							if (titlebar)
								widgetMoveWindowToPosition('grid');
						}
					}
				})
			});
		}
	}
};


/**
 * Функция поиска объекта на карте
 * @param selectedObject строка из куков  LAYER_NAME:ID1,ID2...
 * @param {boolean} ignoreErrors
 * @param {boolean} isCurrentTab
 * @param uniqueLayerName
 * @param {SyncTypes} syncType
 * @private
 */
SyncManager.prototype.findObjectInMap_ = function (selectedObject, ignoreErrors, isCurrentTab, uniqueLayerName, syncType) {
	var that = this;
	if (selectedObject && selectedObject.indexOf(':') !== -1) {
		var layName = selectedObject.split(':')[0];
		var semId = selectedObject.split(':')[1];
		/*if(syncType === SyncTypes.TYPE_4){
			var mapWidgetFrame = $('#mapWidgetInlineFrame');//TODO поменять селектор на класс
			if(mapWidgetFrame.length){
				try{
					$('#mapWidgetInlineFrame')[0].contentWindow.WidgetMap.syncShowObjects(layName, uniqueLayerName, selectedObject, ignoreErrors);
				}
				catch(ex){}
			}
			return;
		}*/
		if (!checkMapExisting())
			return;
		var layers = WidgetMap.layerManager.getLayersBySynonym(layName);
		//upd. 21.04.21 принято решение, если текущая вкладка, то центровка на карте по-старому без синхронизации
		if (!isCurrentTab) {
			var objParams = [];
			layers.forEach(function (layerId) {
				var objParams = [];
				if (CURRENT_MAP_TYPE === MAP_TYPE.CAS) {// обрабатываем случай ПКА, когда центрируемся из карты
					var layer = WidgetMap.layerManager.getCasLayerByName(layerId);
					if (layer && layer.layer)
						uniqueLayerName = layer.layer.uniqueLayerName;
					else
						layer = WidgetMap.layerManager.getCasLayerByName(layerId.split('#')[0]);
					if (layer && layer.layer) {
						uniqueLayerName = layer.layer.uniqueLayerName;
					}
					else
						return;
				}
				objParams.push({name: 'centering', value: true});
				objParams.push({name: 'objects', value: selectedObject.replace(layName, layerId)});
				objParams.push({name: 'uniqueLayerName', value: uniqueLayerName});
				objParams.push({name: 'isGroupButton', value: false});
				objParams.push({name: 'select', value: true});
				objParams.push({name: 'fromFilter', value: false});
				objParams.push({name: 'ignoreErrors', value: ignoreErrors === true ? ignoreErrors : false});
				objParams.push({name: 'loadDynamicData', value: false});//нужно ли грузить слой с динамической подгрузкой данных
				WidgetMap.showObjects(objParams, undefined, ignoreErrors, isCurrentTab, function () {

				});
			});
		}
	}
}

/**
 * Поиск объекта в других слоях-синономах, в случае, если не найден объект в основном.
 * handler возвраает результат результат поиска в слое
 * @param layers
 * @param selectedObject
 * @param ignoreErrors
 * @param isCurrentTab
 * @param uniqueLayerName
 * @param isMainLayer
 * @private
 */
SyncManager.prototype.findObjectInMapHandler_ = function (layers, selectedObject, ignoreErrors, isCurrentTab, uniqueLayerName, isMainLayer) {
	var that = this;
	var layName = selectedObject.split(':')[0];
	var layerId = layName;
	if (layers && layers.length > 0)
		layerId = layers.shift();
	var objParams = [];
	if (!uniqueLayerName)
		uniqueLayerName = layerId;

	objParams.push({name: 'centering', value: true});
	objParams.push({name: 'objects', value: selectedObject.replace(layName, layerId)});
	objParams.push({name: 'uniqueLayerName', value: uniqueLayerName});
	objParams.push({name: 'isGroupButton', value: false});
	objParams.push({name: 'select', value: true});
	objParams.push({name: 'fromFilter', value: false});
	objParams.push({name: 'ignoreErrors', value: ignoreErrors === true ? ignoreErrors : false});
	objParams.push({name: 'loadDynamicData', value: false});//нужно ли грузить слой с динамической подгрузкой данных
	//если не основной слой, то выставляем флаг будто в другой вкладке работаем, чтобы не подгружать данные по синонимичному слою
	if (!isMainLayer)
		isCurrentTab = false;
	WidgetMap.showObjects(objParams, undefined, ignoreErrors, isCurrentTab, function (finded) {
		if (!finded) {
			that.findObjectInMapHandler_(layers, selectedObject, ignoreErrors, isCurrentTab, undefined, false);
		}
	});
};



SyncManager.prototype.refreshGrid = function(curObject, isCurrentTab, syncType, force, refreshGridCallback){
	if (curObject && isCurrentTab && syncType){
		if (App.GridManager){
			var fullLayerId = App.GridManager.getFullLayerIdByLayerName(curObject.split(':')[0]);
			if (fullLayerId){
				var gridWidgets = GridUtil.findAllGridWidgetByFullLayerId(fullLayerId);
				if (gridWidgets && gridWidgets.length > 0 ) {
					gridWidgets.forEach(function(gridWidget){
						if(!gridWidget.modified || force) //если грид не менялся(не фильтровался, не было сортировок), то мы имеем право его обновить
							if(gridWidget.modified) force = false;
							GridWidget.refreshGrid('jqxgrid' + gridWidget.id, force, refreshGridCallback);
					});
				}
			}
		}
	}
};

/**
 * Команда установки данных синхронизации
 * @param selectedObject выбранный объект LAYER_NAME:123
 * @param sender отправитель команды grid|ppanel
 * @param uniqueLayerName
 * @param {SyncTypes} syncType перечень типов синхронизаций
 */
SyncManager.prototype.callSync = function (selectedObject, sender, uniqueLayerName, syncType) {
	if (!App.syncEnabled){// если выставлен флаг в настройках, использовать режим синхронизации
		this.callCurrentTabSync_(selectedObject, sender, uniqueLayerName, syncType);//25.11.2021 Vartanian правка в рамках инцидента 2565, отработка по замечанию
		return;
	}
	if (!syncType) syncType = SyncTypes.TYPE_NO;
	var areCookiesEnabled = App.areCookiesEnabled();//если включены куки
	//если текущая вкладка, то часть функционала не прогоняем через куки(центровка)
	this.callCurrentTabSync_(selectedObject, sender, uniqueLayerName, syncType)
	if (areCookiesEnabled && selectedObject) {
		var cookieTimeout = App.config.SYNC_TIMEOUT || 2;
		var date = new Date();
		date.setTime(date.getTime() + (cookieTimeout * 1000)); // 5 seconds
		this.commandSender = [sender, App.UNIQUE_ID, selectedObject].join('$');
		App.setCookie('gis_web77_sync_select_object', [App.UNIQUE_ID, selectedObject, uniqueLayerName, syncType].join('$'), date);
	}
};

/**
 * Команда запуска функций синхронизации для текущей вкладки(центровка). При обработке кук, центровка будет игнорироваться в текущей вкладке
 * @param selectedObject выбранный объект LAYER_NAME:123
 * @param sender отправитель команды  grid|ppanel|grid_ppanel
 * @param uniqueLayerName
 * @param {SyncTypes} syncType перечень типов синхронизаций
 * @private
 */
SyncManager.prototype.callCurrentTabSync_ = function (selectedObject, sender, uniqueLayerName, syncType) {
	var isCurrentTab = true;
	var ignoreErrors = false;
	var that = this;
	switch (syncType) { //12.10.2021 Vartanian рефакторинг
		case SyncTypes.TYPE_1:
		case SyncTypes.TYPE_2:
			if(uniqueLayerName){// случай ПКА
				selectedObject = uniqueLayerName + ':' + selectedObject.split(':')[1];
			}
			var funcName = "showObjects";
			var params = [{name:"objects", value:selectedObject}, {name:"select", value:true}, {name:"centering", value:true}, {name:"gridCenteringResultFunction", value:App.errorReport}];
			ExternalInteraction.callFunction("", funcName, params);
			//если не кнопка удалить, то не ищем объект в гриде, соответственно не сворачиваем его
			//TODO grid_ppanel посмотреть, где устанавливается grid_ppanel и оптимизировать
			if (sender !== 'grid_ppanel' && sender !== 'grid_delete' && sender !== 'grid_refresh')
				that.findObjectInGrid_(selectedObject, isCurrentTab, syncType);
			if(syncType === SyncTypes.TYPE_1){
				that.refreshGrid(selectedObject, isCurrentTab, syncType, true, function(){
					if (sender !== 'grid_ppanel' && sender !== 'grid_delete' && sender !== 'grid_refresh')
						that.findObjectInGrid_(selectedObject, isCurrentTab, syncType);
				});
			}
			break;
		case SyncTypes.TYPE_3:
		case SyncTypes.TYPE_5:
			that.refreshGrid(selectedObject, isCurrentTab, syncType, true, function(){
				if (sender !== 'grid_ppanel' && sender !== 'grid_delete' && sender !== 'grid_refresh')
					that.findObjectInGrid_(selectedObject, isCurrentTab, syncType);
			});
			break;
	}
};



/**
 *
 * @param syncTypeString
 * @returns {SyncTypes}
 * @private
 */
SyncManager.prototype.parseSyncType_ = function (syncTypeString) {
	if (syncTypeString) {
		try {
			var syncType = SyncTypes['TYPE_' + syncTypeString];
			if (syncType !== undefined)
				return syncType;
		} catch (ex) {

		}
	}
	return SyncTypes.TYPE_NO;
}


App.syncManager = new SyncManager();

/**
 * Класс управления сценариями
 * @param opt_options
 * @constructor
 */

function ScenarioManager(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.config = goog.isDef(options.config) ?
		options.config : undefined;
	//начальное событие, которое срабатывает перед всеми другими(водные/дорожные переходы)
	this.startEvent = undefined;
	//необходимые параметры для работы задачи(могут быть получены из url/либо внешних функций)
	this.requiredParams = [];
	//перечень гридов, которые открываются при старте задачи
	this.openTables = [];
	//перечень слоёв карты, у которых включается видимость при старте задачи
	this.openLayers = [];
	//фильтр. какого вида фильтр будет использоваться (верхний|средний)
	this.filter = undefined;

}

ScenarioManager.prototype.setConfig = function(config){
	if(!this.config)
		this.config = config;
	this.parseConfig_();
}
ScenarioManager.prototype.parseConfig_ = function(){
	var config = this.config || null;
	if(config){
		this.startEvent = config.startEvent || undefined;
		this.requiredParams = config.requiredParams || [];
		this.filter = config.filter || undefined;
		this.openTables = config.openTables || [];
		this.openLayers = config.openLayers || [];
	}
}

/**
 * Функция вызова сценария. После успешного выполнения сценария происходит загрузка карты
 * @param callback
 */
ScenarioManager.prototype.call = function(callback){
	var urlParams = {};
	var topFilterArr = [];
	var hasAllRequiredParams = true;
	if(this.config && this.config.urlParams && this.config.urlParams.length > 0){
		hasAllRequiredParams = 0;
		this.config.urlParams.forEach(function(urlParam){
			var paramValue = getParameterByName(urlParam);
			urlParams[urlParam] = paramValue;
			topFilterArr.push(urlParam+':'+paramValue);
			hasAllRequiredParams |= !!paramValue;
		});
		if(hasAllRequiredParams){
			this.setAppFilters(urlParams, topFilterArr, callback);
			var vars = this.createVars_();
			this.callSubScenario(this.openLayers, false, vars, callback)
			return;
		}
	}
	this.callScenario(callback);
}
/**
 * Функция, которая проставляет в верхний/нижний фильтры параметры, пришедшие из url
 * @param params
 */
ScenarioManager.prototype.setAppFilters = function(params, topFilterArr, callback){
	if(this.filter){
		var setTopFilter = (this.filter.type && this.filter.type.indexOf('top') !== -1);
		var setMiddleFilter = (this.filter.type && this.filter.type.indexOf('middle') !== -1);
		if(setTopFilter){
			//устанавливаем выбранное значение в верхний фильтр
			if(topFilterArr && topFilterArr.length){
				var prms = [{
					name: 'filter',
					value:topFilterArr.join('|')
				}]
				WidgetMap.updateTopFilter(prms);
				if(this.openLayers.length){
					this.openLayers.forEach(function(layerName){
						WidgetMap.currentFilter[layerName] = [];
						topFilterArr.forEach(function(topFilter){
							WidgetMap.currentFilter[layerName].push({
								layerName: layerName,
								filter: topFilter.split(':')[0],
								value: topFilter.split(':')[1]
							});
						})
					})
				}
			}
		}
		if(setMiddleFilter){
			if (this.openLayers.length) {
				this.openLayers.forEach(function (layerName) {
					//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
					WidgetMap.currentFilter[layerName] = [];
					WidgetMap.currentRoughFilter = [];
					topFilterArr.forEach(function(topFilter){
						WidgetMap.currentFilter[layerName].push({
							layerName: layerName,
							filter: topFilter.split(':')[0],
							value: topFilter.split(':')[1]
						});
						WidgetMap.currentRoughFilter.push({name: topFilter.split(':')[0], value: topFilter.split(':')[1], layerName: layerName});
					})
				});
			}
		}
	}

	/*if(callback)
		callback.apply();*/

}

/**
 *
 * @returns {{openLayers: ([]|*), queryFileName: *[], openTableGridId: *[], querySource: *[], openTableTitle: *[], openTableInterval: undefined, queryLayerId: *[], openTableLevelParams: *[]}}
 * @private
 */
ScenarioManager.prototype.createVars_ = function(){
	var vars = {};
	if(this.config){
		vars = {
			openLayers: this.config.openLayers,
			openTableInterval: undefined,
			openTableTitle: [],
			openTableGridId: [],
			openTableLevelParams: [],
			openTableShowDashboard: [],
			querySource: [],
			queryLayerId: [],
			queryFileName: [],
			mainScenario: true,
		};
		if(this.filter){
			//vars.filterType = this.filter.type;
			//vars.topFilterSource = this.filter.topDataSource;
			//vars.middleFilterSource = this.filter.middleDataSource;
		}
		/*данные для открытия грида*/
		this.config.openTables.forEach(function(tableObj){
			vars.openTableGridId.push(tableObj.gridId);
			if(tableObj.minimize)
				vars.openTableMinimize = true;
			vars.openTableTitle.push(tableObj.title);
			vars.openTableLevelParams.push(tableObj.levelParams);
			vars.openTableShowDashboard.push(tableObj.showDashboard);
			if(tableObj.query){
				vars.querySource.push(tableObj.query.source);
				vars.queryLayerId.push(tableObj.query.LAYER_ID);
				vars.queryFileName.push(tableObj.query.FILE_NAME);
			}
		});
		vars.openTableGridId = vars.openTableGridId.join('|');
		vars.openTableTitle = vars.openTableTitle.join('|');
		vars.openTableLevelParams = vars.openTableLevelParams.join('|');
		vars.openTableShowDashboard = vars.openTableShowDashboard.join('|');
		vars.querySource = vars.querySource.join('|');
		vars.queryLayerId = vars.queryLayerId.join('|');
		vars.queryFileName = vars.queryFileName.join('|');
	}
	return vars;
};
/**
 * Запуск сценария по открытию фильтров/гридов и включению слоёв(перенос из TreeUtils)
 */
ScenarioManager.prototype.callScenario = function(callback){
	var that  = this;
	//забираем флаг открытия среднегно фильтрна, список на открытие гридов и список на включение слоёв
	var middleFilterDataSource = (this.filter) ? this.filter.middleDataSource : '';//'MIDDLE_ILI_FILTER';
	var topFilterDataSource = (this.filter) ? this.filter.topDataSource : '';//'ILI_INSP_FILTER;
	var filterType = (this.filter) ? this.filter.type : '';
	var hideButtons = this.filter ? this.filter.hideButtons : [];
	var showLayers = this.openLayers;//['PODS_ILI_DATA','PODS_ILI_DATA_FEATURE'];
	var vars = this.createVars_();
	if (middleFilterDataSource !== '') {
		if (Array.isArray(middleFilterDataSource)) {
			that.showSelectableFilter(filterType, topFilterDataSource, middleFilterDataSource, showLayers, function (selectedFilterIndex) {
				//выбираем тот средний фильтр за основу, который пришел из формы выбора
				var middleFilterSource = middleFilterDataSource[0];
				if (selectedFilterIndex < middleFilterDataSource.length)
					middleFilterSource = middleFilterDataSource[selectedFilterIndex];
				if (selectedFilterIndex !== -1) {
					that.showFilter(filterType, topFilterDataSource, middleFilterSource, showLayers, function () {
						that.callSubScenario(showLayers, false, vars, callback);
					},hideButtons);
				} else {
					//если selectedFilterIndex = -1 , значит выбрать всё
					that.callSubScenario(showLayers, true, vars, callback);
				}
			})
		} else {
			that.showFilter(filterType, topFilterDataSource, middleFilterDataSource, showLayers, function () {
				//TODO рефакторинг
				/*if (WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.fullLayerId){
					var pArr = [],
						fullLayerId = WidgetMap.config.grid.fullLayerId.replace('#', '*');
					for (var key in WidgetMap.config.grid)
						pArr.push({name: key, value: WidgetMap.config.grid[key]});
					ExternalInteraction.openGrid({
						pArr: pArr,
						reload: useExistList,
						fullLayerId: fullLayerId,
						forceTopFilter: true,
					});
					return;
				}*/
				that.callSubScenario(showLayers, false, vars, callback);
			},hideButtons);
		}
	} else {
		that.callSubScenario(showLayers, false, vars, callback);
	}
};

/**
 * вызов функции открытия гридов и включения видимости слоя, когда карта загрузится
 */
ScenarioManager.prototype.callSubScenario = function(showLayers, clearFilter, vars, callback){
	if(!App.scenarioParams && (showLayers.length > 0 || vars.mainScenario !== undefined)){
		App.scenarioParams = {
			vars: vars,
			mainScenario: true,//TODO сделать нормальный вызов, чтобы treeutil корректно обрабатывал loadScenario
		}
		if(showLayers.length > 0)
			App.scenarioParams.vars.openLayers = showLayers;
	}
	if(callback){
		callback.apply(vars);
	}

	/*this.showLayersFnc(showLayers, clearFilter);
	this.openTablesFnc(vars);*/
}




/**
 * Показать перед фильтром форму с выбором, какой из фильтров использовать
 * @param filterType
 * @param topFilterDataSource
 * @param middleFilterDataSource
 * @param showLayers
 * @param applyHandler
 */
ScenarioManager.prototype.showSelectableFilter = function (filterType, topFilterDataSource, middleFilterDataSource, showLayers, applyHandler) {
	//сначала грузим все
	ExternalInteraction.loadFiltersDescr(middleFilterDataSource, [], function (filters) {
		$('#selectableFilterFormDialog').remove();
		var divv = '<div id="selectableFilterFormDialog">' +
			'<div class="filter-form-div">';
		divv += '<div>' + gis_treeutils_12 + '</div><br/>';
		var checked = '';
		var height = 160;
		for (var i = 0; i < filters.length; i++) {
			checked = (i === 0) ? 'checked' : '';
			divv += '<div class="filter-form-radio">';
			divv += '   <input name="filterRadio" id="filterRadio_' + i + '" type="radio" ' + checked + ' value="' + i + '"/>';
			divv += '   <label for="filterRadio_' + i + '" style="margin-left: 5px;">' + filters[i].title + '</label>';
			divv += '</div>';
			height += 30;
		}
		divv += '<br/><div>' + gis_treeutils_13 + '</div>';
		divv += '</div></div>';
		$('body').append(divv);
		var dlg = $('#selectableFilterFormDialog');
		var buttons = [{
			text: gis_core_16,
			click: function () {
				var selectedFilterIndex = Number($("input[name='filterRadio']:checked", dlg).val());
				if (applyHandler)
					applyHandler(selectedFilterIndex);
				$('#selectableFilterFormDialog').remove();
			}
		},
			{
				text: gis_treeutils_9,
				click: function () {
					if (applyHandler)
						applyHandler(-1);
					$('#selectableFilterFormDialog').remove();
				}
			}];
		dlg.dialog({
			modal: true,
			title: gis_treeutils_8,
			dialogClass: 'noCloseButton gsi-zindex__dialog',
			closeOnEscape: true,
			width: 470,
			height: height,
			resizable: false,
			buttons: buttons,
		});
	});
};

/**
*  Показать фильтр
 *  @param filterType тип фильтра
 *  @param topFilterSource
 *  @param middleFilterSource
 *  @param showLayers
 *  @param applyHandler
 *  @param hideButtons флаг для скрытия кнопок фильтра
*/
ScenarioManager.prototype.showFilter = function (filterType, topFilterSource, middleFilterSource, showLayers, applyHandler, hideButtons) {
	var isMiddleFilter = topFilterSource === undefined || topFilterSource === '';
	var that = this;
	var setTopFilter = (filterType && filterType.indexOf('top') !== -1)? true: false;
	var setMiddleFilter = (filterType && filterType.indexOf('middle') !== -1)? true: false;
	//если уже был открыт средний фильтр, то игнорируем. Обход ситуации, когда от каждого фильтра рубрикатора вызывается checkHeadRadioHandler
	if ($('#middleFilterDialog').length > 0)
		return;
	$('body').append('<div id="middleFilterDialog"></div>');
	var dlg = $('#middleFilterDialog');
	dlg.append('<div id="middleFilterDiv"></div>');
	var middleFilterDiv = $('#middleFilterDiv');
	middleFilterDiv.myFilters({
		dataSource: middleFilterSource,
		hideButtons: hideButtons,
		handlers: {
			cancelHandler: function (params) {
				$('#middleFilterDialog').remove();
			},
			applyHandler: function (params) {
				//устанавливаем верхний фильтр
				var resFilterValues = middleFilterDiv.myFilters('getFilterValuesArray');
				var dotSplitArr = resFilterValues[0].values;
				//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
				var roughArr = [];
				for (var j = 0; j < dotSplitArr.length; j++) {
					roughArr.push(dotSplitArr[j].code);
				}
				if (dotSplitArr.length == 0) {
					roughArr.push('NULL');
				}
				var showInfo = false;
				$('#middleFilterDialog').remove();
				var idFilter = resFilterValues[0].idFilter;
				if(setTopFilter){
					//устанавливаем выбранное значение в верхний фильтр
					var prms = [{
						name: 'filter',
						value:idFilter+':'+roughArr.join()
					}]
					WidgetMap.updateTopFilter(prms);
					if(that.openLayers.length){
						that.openLayers.forEach(function(layerName){
							WidgetMap.currentFilter[layerName] = [];
							WidgetMap.currentFilter[layerName].push({
								layerName: layerName,
								filter: idFilter,
								value: roughArr.join()
							});
						})
					}
				}
				if (setMiddleFilter) {
					var rr = [];
					WidgetMap.currentRoughFilter = [];
					for (var k = 0; k < showLayers.length; k++) {
						//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
						var smallLayerId = showLayers[k];
						rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
						WidgetMap.currentFilter[smallLayerId] = [];
						WidgetMap.currentFilter[smallLayerId].push({
							layerName: smallLayerId,
							filter: idFilter,
							value: roughArr.join(",")
						});
						WidgetMap.currentRoughFilter.push({name: idFilter, value: roughArr.join(","), layerName: smallLayerId});
					}
					//WidgetMap.currentRoughFilter = [{name:idFilter, value:}];
					if (applyHandler !== undefined)
						applyHandler();
				}
				//если был объявлен верхний фильтр, то при работе со средним выбранные значения будут заноситься в верхний
				else {
					//если открывался ещё средний фильтр, то выставляем currentRoughFilter для корректного нанесения геометрии на карту
					if (middleFilterSource !== undefined && middleFilterSource !== '' && filterType.indexOf('middle') !== -1) {
						var rr = [];
						WidgetMap.currentRoughFilter = [];
						for (var t = 0; t < showLayers.length; t++) {
							//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
							var smallLayerId = showLayers[t];
							rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
						}
						WidgetMap.currentRoughFilter.push({name: idFilter, value: roughArr.join(","), layerName: smallLayerId});
					}
					var newData = '<data OBJ_IDS="' + roughArr.join(',') + '" TOP_FILTER="' + idFilter + '" ></data>';
					var treeDiv = $('#treeDiv');
					if(treeDiv.length > 0)
						treeDiv.myCategories('updateTopFilter', {params: newData});

					function checkFilter(filter) {
						WidgetMap.updateTopFilter(filter.params);
						var splittedFilter = filter.params[0].value.split('|');
						for (var i = 0; i < splittedFilter.length; i++) {
							if (splittedFilter[i].indexOf(filterName) != -1) {
								var filterValue = splittedFilter[i].split(':')[1];
								for (var k = 0; k < showLayers.length; k++) {
									//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
									var smallLayerId = showLayers[k];
									WidgetMap.currentFilter[smallLayerId] = [];
									WidgetMap.currentFilter[smallLayerId].push({
										layerName: smallLayerId,
										filter: filterName,
										value: filterValue
									});
								}
								if (filterValue == '' || filterValue == 'VOID') {
									showInfo = true;
								}
								if (filterValue !== roughArr.join(',')) {
									return false;
								}
								break;
							}
						}
						return true;
					}

					var filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: {}}) : undefined;
					if (filter && filter.params && filter.params.length > 0) {
						//добавляем проверку на выбранное кол-во записей перед открытием грида
						if (goog.isDef(idFilter)) {
							var filterName = idFilter;
							var start = Date.now();
							var timeout = 0;
							while (!checkFilter(filter) && timeout < 1000) {
								filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: {}}) : undefined;
								timeout = Date.now() - start;
							}
						}
					}
					if (showInfo) {
						var text = gis_treeutils_3;
						var title = gis_treeutils_4;
						var buttons = [
							{text: gis_core_4, click: showGridDialog},
							{text: gis_core_5, click: closeDialog}
						];
						var dlg = App.confirmDialog(text, buttons, {title: title, width: 400});

						function closeDialog() {
							dlg.dialog('destroy');
							dlg.remove();
						}

						function showGridDialog() {
							if (applyHandler !== undefined)
								applyHandler();
							closeDialog();
						}
					} else if (applyHandler !== undefined)
						applyHandler(roughArr);
				}
			}
		}
	});

	var closeDiv = '<div id="middleFilterCloseDiv" class="middleFilterCloseDiv"></div>';
	middleFilterDiv.append(closeDiv);
	$('#middleFilterCloseDiv').on('click', function (event) {
		$('#middleFilterDialog').remove();
	});
	dlg.dialog({
		resizable: false,
		modal: true,
		dialogClass: 'noCloseButton noTitleBar gsi-zindex__dialog',
		width: 605,
		height: 440,
		title: ''
	});

};
ScenarioManager.prototype.updateTopFilter = function(){

}
ScenarioManager.prototype.updateRoughFilter = function(){

}


ScenarioManager.prototype.show = function(showLayers, clearFilter, vars){
	this.showLayersFnc(showLayers, clearFilter);
	this.openTablesFnc(vars);
}

ScenarioManager.prototype.showLayersFnc = function (showLayers, clearFilter) {
	if (showLayers.length > 0) {
		if (WidgetMap.layerManager != undefined) {
			for (var index = 0; index < showLayers.length; index++) {
				var smallLayerId = showLayers[index];
				var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
				if (goog.isDef(layer)) {

					if (layer.filter !== undefined && layer.filter !== '' && WidgetMap.isModelsVector == true) {
						//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
						WidgetMap.layerManager.clearLayer(smallLayerId, true);
					}
					if(clearFilter === true){
						layer.filter = undefined;
						layer.filters = undefined;
						if(layer.layer){
							layer.layer.filter = undefined;
							layer.layer.filters = undefined;
						}
					}
					if (layer.visible != true)
						WidgetMap.layerManager.updateLayer(smallLayerId);
					WidgetMap.layerManager.enableLayer(smallLayerId);
				}
			}
		}
	}
}

ScenarioManager.prototype.openTablesFnc = function (scenarioParams) {
	var timeout = 3000;
	if (scenarioParams !== undefined) {
		if (scenarioParams.interval !== undefined)
			timeout = scenarioParams.interval;
		//сначала подгружаем часть стиля для получения title грида
		var openTableTitle = scenarioParams.title;
		var openTableGridId = scenarioParams.gridId;
		var openTableLevelParams = scenarioParams.levelParams;
		var querySource = scenarioParams.querySource;
		var queryLayerId = scenarioParams.queryLayerId;
		var queryFileName = scenarioParams.queryFileName;
		//если есть данные для открытия гридов
		if (openTableTitle !== undefined && openTableGridId !== undefined && openTableLevelParams !== undefined
			&& querySource !== undefined && queryLayerId !== undefined && queryFileName !== undefined) {
			var openTableTitleArr = openTableTitle.replace('undefined|', '').split('|');
			var openTableGridIdArr = openTableGridId.replace('undefined|', '').split('|');
			var openTableLevelParamsArr = openTableLevelParams.replace('undefined|', '').split('|');
			var querySourceArr = querySource.replace('undefined|', '').split('|');
			var queryLayerIdArr = queryLayerId.replace('undefined|', '').split('|');
			var queryFileNameArr = queryFileName.replace('undefined|', '').split('|');
			var gridArr = [];
			function loadStyle() {
				if (gridArr.length > 0) {
					var gridItem = gridArr.pop();
					if (gridItem.title.indexOf('{') == -1) {
						ExternalInteraction.openTable(gridItem.gridId, gridItem.title, gridItem.levelParams);
						setTimeout(function () {
							loadStyle();
						}, timeout)
					} else
						App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
							{
								descrId: gridItem.source,
								descrType: 'select',
								getSchema: false,
								toElements: false,
								data: '<root><data LAYER_ID="' + gridItem.layerId + '" FILE_NAME="' + gridItem.fileName + '"/></root>'
							},
							function (xmlElement) {
								var xmlData = ($.parseXML(xmlElement)).firstChild;
								var styles = xmlData.getElementsByTagName("Style");
								var i = 0;
								if (styles.length > 0) {
									var curStyle = styles[0];
									var descr = curStyle.getAttribute('descr');
									//открываем грид
									if (descr !== undefined && descr !== '') {
										ExternalInteraction.openTable(gridItem.gridId, descr, gridItem.levelParams);
										setTimeout(function () {
											loadStyle();
										}, timeout)
									}
								}
							},
							function (xmlElement) {
							});
				}
			}
			//если количество данных для открытия гридов совпадает
			if (openTableTitleArr.length == openTableGridIdArr.length && openTableTitleArr.length == openTableLevelParamsArr.length &&
				openTableTitleArr.length == querySourceArr.length && openTableTitleArr.length == queryLayerIdArr.length &&
				openTableTitleArr.length == queryFileNameArr.length) {
				for (var i = 0; i < querySourceArr.length; i++) {
					gridArr.push({
						title: openTableTitleArr[i],
						source: querySourceArr[i],
						layerId: queryLayerIdArr[i],
						fileName: queryFileNameArr[i],
						gridId: openTableGridIdArr[i],
						levelParams: openTableLevelParamsArr[i]
					});
				}
				loadStyle();
			}
		}
	}
}

App.scenarioManager = new ScenarioManager();
/**
 * Абстрактный класс диалога с формой редактирования записей БД
 * Умеет считывать конфигурацию формы, загружать в нее данны и сохранять их на диске
 * Формирует всплывающий диалог и кнопочками. По умолчанию есть кнопки Сохранить и Отменить
 */

/* TEXT CONSTANTS */
var ABSTRACT_FORM_DIALOG_BUTTON_SAVE = gis_abstractformdialog_1;
var ABSTRACT_FORM_DIALOG_BUTTON_CLOSE = gis_abstractformdialog_2;
var ABSTRACT_FORM_DIALOG_LOADING_TEXT = gis_abstractformdialog_3;
var ABSTRACT_FORM_DIALOG_ERROR_LOADING_FORM = gis_abstractformdialog_4;
var ABSTRACT_FORM_DIALOG_ERROR_CREATING_FORM = gis_abstractformdialog_5;
var ABSTRACT_FORM_DIALOG_ERROR_SAVE_FORM = gis_abstractformdialog_6;
/**/


AbstractFormDialog = {};

AbstractFormDialog.dialogId = 'popupDialog';
 
AbstractFormDialog.form = null;

AbstractFormDialog.defaultValues = {};

AbstractFormDialog.loadData = true;
AbstractFormDialog.sendUser = true;

AbstractFormDialog.title = 'AbstractFormDialog';
AbstractFormDialog.formDescrId = null;
AbstractFormDialog.sysClassId = null;
AbstractFormDialog.descrId = null;
AbstractFormDialog.dbSchemaId = null; 
AbstractFormDialog.dbTableId = null; 
AbstractFormDialog.saveDescrType = 'update'; 
AbstractFormDialog.buttons = {                
    save           :ABSTRACT_FORM_DIALOG_BUTTON_SAVE,
    close          :ABSTRACT_FORM_DIALOG_BUTTON_CLOSE
};    
AbstractFormDialog.defaultAction = 'save';

AbstractFormDialog.init = function() {   
    this.form = new Form();
    
    var m = /^([^_]+)_(.+)$/.exec(this.sysClassId);
    if(m) {
        this.dbSchemaId = m[1]; // sysClassId до первого подчеркивания
        this.dbTableId  = m[2]; // sysClassId после первого подчеркивания
    }
};

AbstractFormDialog.makeLoadDataReqParams = function() {
    var userId    = this.sendUser ? ''+Auth.getUserId()   : '-1';
    var userLogin = this.sendUser ? ''+Auth.getUserName() : 'guest';

    return {
        getSchema:  false,
        descrId:    this.descrId,
        toElements: false,
        descrType:  'select',
        data:
            '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data SYS_FULL_ID="'+this.sysClassId+'/'+userId.xmlEscape()+'" SYS_CLASS_ID="'+this.sysClassId+'" SYS_OBJ_ID="'+userId.xmlEscape()+'" DB_SCHEMA_ID="'+this.dbSchemaId+'" DB_TABLE_ID="'+this.dbTableId+'" CURRENT_USER_LOGIN="'+userLogin.xmlEscape()+'" CURRENT_USER_ID="'+userId.xmlEscape()+'" />'+
            '</root>'
    };
};

AbstractFormDialog.makeSaveDataReqParams = function(values) {
    var userId    = this.sendUser ? ''+Auth.getUserId()   : '-1';
    var userLogin = this.sendUser ? ''+Auth.getUserName() : 'guest';

    return {
        descrType:  this.saveDescrType,
        getSchema:  false,
        descrId:    this.descrId,
        toElements: false,
        data:              
            '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data '+this.structToXmlAttrs(values)+' SYS_FULL_ID="'+this.sysClassId+'/'+userId.xmlEscape()+'" SYS_CLASS_ID="'+this.sysClassId+'" SYS_OBJ_ID="'+userId.xmlEscape()+'" DB_SCHEMA_ID="'+this.dbSchemaId+'" />'+
            '</root>'                                  
    };       
};

AbstractFormDialog.structToXmlAttrs = function(values) {
    var fieldsAttrs = '';
    $.each(values, function(name, value){
        fieldsAttrs += ' '+name.toUpperCase()+'="'+value.toString().xmlEscape()+'"';
    });        
    return fieldsAttrs;
};

/*
 * Построение всего диалога и обработка событий
 */
AbstractFormDialog.build = function() {    
    var that = this;
    
    // Создадим диалог. Сначала пустой
    $('#'+this.dialogId).remove();
    $('body').append('<div id="'+this.dialogId+'">'+ABSTRACT_FORM_DIALOG_LOADING_TEXT+'</div>');
    $('#'+this.dialogId+'').dialog({
        dialogClass: 'appDialog',
        modal  : true,
        title  : this.title,
        width  : 800,
        height : 100        
    });

    //Устанавливаем курсор ожидания
    BlockingUtil.wait();
    try {
        // Запрос данных
        var values = this.defaultValues;
        function dataReq() {
            return App.serverQueryNodeWithTries(Services.processQueryNode, that.makeLoadDataReqParams(), function(xml){
                $.each(xml.find('data:first').get(0).attributes, function(){
                    if(this.specified) {
                        values[this.name] = this.value;                        
                    }                                    
                });                         
            });
        }        

        // Запрос структуры формы
        var formStruct;
        function formReq() {
            var fileName = '../../Public/Modules/Form/'+that.formDescrId+'.mxml';
            return App.serverQueryXmlFileNode1(Services.processQueryNodeXml, 'SYS_SEM.xml#GET_XML_FILE', fileName,
                function (xml) {
                var er = HTTPServiceUtil.getError(xml);
                if (er !== '')
                    App.errorReport(gis_core_error_1, er,undefined,{filename:gis_filename_4, functionname:'gis_filename_4_1'});
                else 
                    formStruct = xml;
            });
        }

        // Построим форму, когда данные и описание формы загрузятся
        var prom;
        if(this.loadData) {
            prom = $.when(formReq(), dataReq());
        }
        else {
            prom = $.when(formReq());
        }
        
        prom.then(function(){     
            var dlg = $('#'+that.dialogId);
            dlg
                .empty()
                .append('<form class="form" method="post"></form>');

            that.form.setContainer($('.form', dlg));
            that.form.setXml(formStruct);
            that.form.setValues(values);
            that.form.build();                                 

            // Ставим фокус на первое поле
            $('form input[type="text"]:first', dlg).attr('autofocus', 'autofocus').focus();

            var w = that.form.getWidth();
            var h = that.form.getHeight();                

            // Готовим кнопки, и добавляем обработчики
            var buttons = [];
            $.each(that.buttons, function(name, text){                
                buttons.push({ 
                    text: text,
                    click: function(){
                        var funcName = name+'Action';
                        if(that[funcName]) {
                            that[funcName].apply(that);
                        }
                    }
                });                    
            });

            // Формируем диалог
            dlg.dialog({
                width   : w ? w+10  : 800,
                height  : h ? h     : 'auto',                    
                buttons : buttons                  
            }); 
                        
            // Костыль: Исправление бага в Chrome который приводит к скаканию высоты диалога при наличии в нем select-ов            
            $('select', dlg).hide().show();                       
            
            // При нажатии Enter автоматичеcки делаем действие по умолчанию
            dlg.keydown(function(event) {
                if (event.keyCode == 13) {                    
                    var func = that[that.defaultAction+'Action'];
                    if(func) {
                        func.apply(that);
                    }                    
                    event.preventDefault();
                    return false;
                }                
            });
            //Снимаем курсор ожидания
            BlockingUtil.ready();
        });
        prom.fail(function(){
            //Снимаем курсор ожидания
            BlockingUtil.ready();
            App.errorReport(ABSTRACT_FORM_DIALOG_ERROR_LOADING_FORM+' "'+that.title+'"', '',undefined,{filename:gis_filename_4, functionname:'AbstractFormDialog.build_fail'});
        });
    }
    catch(e) {
        //Снимаем курсор ожидания
        BlockingUtil.ready();
        App.errorReport(ABSTRACT_FORM_DIALOG_ERROR_CREATING_FORM+' "'+that.title+'"', e,undefined,{filename:gis_filename_4, functionname:'AbstractFormDialog.build_catch'});
    }               
};

AbstractFormDialog.saveAction = function() {
    var that = this;
    //Устанавливаем курсор ожидания
    BlockingUtil.wait();

    var formValues = this.form.getValues();

    if(formValues.theme !== undefined){
        //пока хардкодятся элементы
        var mode = (formValues.map_mode_raster === true) ? WidgetMap.MODES.RASTER : WidgetMap.MODES.VECTOR;
        mode = MapUtil.getAvailableMapMode(mode);
        MapUtil.applyThemeParams({
            mapMode: mode,
            showOverviewMap: formValues.show_overview_map === true,
            showTree: formValues.show_tree === true,
            sendCadastreEmail: formValues.send_cadastre_email === true,
            showCenterMap: formValues.show_center_map === true,
            coordMode: (formValues.coord_mode_decimal === true)?'decimal':'grad',
            useSynchronization: formValues.use_synchronization === true,
        });
    }

    var req = App.serverQueryNode(Services.processQueryNode, this.makeSaveDataReqParams(formValues));
    req.done(function(resultXml){
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== ''){
            App.errorReport(ABSTRACT_FORM_DIALOG_ERROR_SAVE_FORM+' "'+that.title+'"', er,undefined,{filename:gis_filename_4, functionname:'AbstractFormDialog.saveAction_done'});
            BlockingUtil.ready();
        }
        else {
            //Снимаем курсор ожидания
            BlockingUtil.ready();
            $('#'+that.dialogId).dialog('destroy').remove();
        }
    }); 
    req.fail(function(errorText){
        var er = HTTPServiceUtil.getError(errorText);
        if (er !== '')
            App.errorReport(ABSTRACT_FORM_DIALOG_ERROR_SAVE_FORM+' "'+that.title+'"', er,undefined,{filename:gis_filename_4, functionname:'AbstractFormDialog.saveAction_fail'});
        //Снимаем курсор ожидания
        BlockingUtil.ready();
        //BlockingUtil.unblockApplication();
        
    });        
};

AbstractFormDialog.closeAction = function() {
    $('#'+this.dialogId).dialog('destroy').remove(); 
};


UserOfficeDialog = Object.create(AbstractFormDialog);
UserOfficeDialog.title          = gis_userofficedialog_1;
UserOfficeDialog.formDescrId    = 'WEB50_B_USER_PRIVATE';
UserOfficeDialog.sysClassId     = 'WEB50_B_USER_PRIVATE';
UserOfficeDialog.descrId        = 'SYS_SEM.xml#WEB50_B_USER_PRIVATE';
UserOfficeDialog.buttons = {     
    changePassword :gis_userofficedialog_2,
    save           :gis_core_2,
    close          :gis_core_6
};   
UserOfficeDialog.defaultAction = null;

UserOfficeDialog.changePasswordAction = function() {    
    var dialog = Object.create(ChangePasswordDialog);
    dialog.build();
};

/**
 * Класс формы управления задачами
 */
function TaskOfficeForm(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.callback = options.callback;
}
TaskOfficeForm.prototype.build = function() {
	var that = this;
	var dcf = new DashboardChooserForm();
	dcf.build();
	/*$('#taskOfficeDialog').remove();
	var divv = '<div id="taskOfficeDialog">' +
		'<div style="display: flex;margin-top: 9px;justify-content: space-around;">' +
		'<input type="button" class="map-dialog-button" style="width: 123px;" id="taskArchive" name="archive"  value="'+ gis_taskofficedialog_1 + '" >' +
		'<input type="button" class="map-dialog-button" style="width: 123px;" id="taskSave" name="save" value="'+ gis_taskofficedialog_2 + '" >' +
		'</div>'
	'</div>';
	$('body').append(divv);
	var dlg = $('#taskOfficeDialog');
	dlg.dialog({
		modal: false,
		title: gis_taskofficedialog_3,
		dialogClass: 'gsi-zindex__task-office',
		closeOnEscape: true,
		width: 260,
		height: 80,
		resizable: false,
		close: function () {
			try {
				$(this).dialog('destroy').remove();
			} catch (e) { }
		}
	});
	$('#taskArchive').on('click',function(){
		var dcf = new DashboardChooserForm();
		dcf.build();
		App.destroyDialog(null, dlg);
	});
	$('#taskSave').on('click',function(){
		var dashboard = App.dashboardManager.getDashboard(null);
		if(dashboard)
			App.dashboardManager.showSaveDashboardForm(dashboard.id);
		App.destroyDialog(null, dlg);
	});*/
};


/*
 * Диалог регистрации пользователя
 */
UserRegistrationDialog = Object.create(AbstractFormDialog);

UserRegistrationDialog.loadData = false;
UserRegistrationDialog.sendUser = false;

UserRegistrationDialog.title          = gis_userregistrationdialog_1;
UserRegistrationDialog.formDescrId    = 'WEB50_B_USER_PRIVATE_REG';
UserRegistrationDialog.sysClassId     = 'WEB50_B_USER_PRIVATE_REG';
UserRegistrationDialog.descrId        = 'SYS_SEM.xml#WEB50_B_USER_PRIVATE_REG';
UserRegistrationDialog.saveDescrType  = 'insert';
UserRegistrationDialog.defaultValues  = {status:'B'};

UserRegistrationDialog.buttons = {         
    register : gis_userregistrationdialog_2,
    cancel   : gis_userregistrationdialog_3
};   
UserRegistrationDialog.defaultAction = null;

/**  
 * Нажатие на кнопку отмены
 */
UserRegistrationDialog.cancelAction = function() {       
    var that = this;
    
    var buttons = [
        {text:gis_core_4,  click:yesAction},
        {text:gis_core_5, click:noAction}
    ];
    
    var dlg = App.confirmDialog(gis_userregistrationdialog_6, buttons, {title:gis_userregistrationdialog_7});

    function noAction() {        
        dlg.dialog('destroy').remove();
    }
    
    function yesAction() {                
        that.closeAction();
        dlg.dialog('destroy').remove();
    }    
};

/**  
 * Нажатие на кнопку регистрации
 */
UserRegistrationDialog.registerAction = function() {       
    var that = this;
    
    var buttons = [
        {text:gis_core_4,  click:yesAction},
        {text:gis_core_5, click:noAction}
    ];
    
    var dlg = App.confirmDialog(gis_userregistrationdialog_8, buttons, {title:gis_userregistrationdialog_9});

    function noAction() {        
        dlg.dialog('destroy').remove();
    }
    
    function yesAction() {                
        that.saveAction();
        dlg.dialog('destroy').remove();
    }    
};

/**  
 * Переопределение действия сохранения формы
 */
UserRegistrationDialog.saveAction = function() {       
    req = App.serverQueryNode(Services.processQueryNode, this.makeSaveDataReqParams(this.form.getValues()));
    
    req.done(function(doc){
        var id = doc.find('data:first').attr('ID');
        if(id) {
            $('#userOfficeDialog').dialog('close').remove();
            App.confirmDialog(gis_userregistrationdialog_10, null, {title:gis_userregistrationdialog_1});
        }
    }); 
    
    req.fail(function(errorText){
        App.errorReport(gis_userregistrationdialog_12, errorText, undefined, {filename:gis_filename_293, functionname:'gis_filename_293_1'});
    });        
};


/**
 * Класс диалога смены пользователя
 */
/* TEXT CONSTANTS */
var USER_CHANGE_DIALOG_TITLE = gis_userchangedialog_1;
/**/

function UserChangeDialog() {    
    this.targetUrl = null;
    this.title = USER_CHANGE_DIALOG_TITLE;
    this.closable = true;    
    this.htmlUrl = 'ui/html/UserChangeDialog.html';    
};

UserChangeDialog.prototype._anonimUpdate = function () {           
    var dlg = $('#userChangeDialog');
    
    var fields = $("input[name='login'], input[name='password'], input[name='remember']", dlg);
    if($('input[name="anonimous"]', dlg).is(':checked')) {
        fields.addClass('readOnly').attr('disabled', 'disabled');
    }
    else {
        fields.removeClass('readOnly').removeAttr('disabled');
    }        
 };

UserChangeDialog.prototype.build = function() {
    var that = this;
    
    $('#userChangeDialog').remove();
    $('body').append('<div id="userChangeDialog"></div>');
    var dlg = $('#userChangeDialog');
    dlg.load(this.htmlUrl, build);    
    
    function build() {        
        dlg.dialog({
            modal  : true,
            title  : that.title,
            dialogClass   : that.closable ? '' : 'noCloseButton',
            closeOnEscape : that.closable,
            width  : 248,
            height : 154
        });       
 

 
        // Пятаемся перелогинится и по нажатию Enter тоже
        $('input[name="login"], input[name="password"]', dlg).keypress(function(e){       
            if(e.which == 13) {
                that.change();
            }
        });       
        
        // Блокируем поля ввода если надо войти анонимно
        $('input[name="anonimous"]', dlg).change(function(){
            that._anonimUpdate();
        });  
        
        // Кнопки
        $("input[name='change']",       dlg).click(function(){ that.change(); });
        $("input[name='cancel']",       dlg).click(function(){ that.cancel(); });        
        $("input[name='registration']", dlg).click(function(){ that.registration(); });      
        
        // Подставим последний логин
        $('input[name="login"]', dlg).val(Auth.getLastLogin());
    }
};

UserChangeDialog.prototype.setTargetUrl = function(url) {
    this.targetUrl = url;
};

UserChangeDialog.prototype.change = function() { 
    var that = this;
    
    var dlg = $('#userChangeDialog');
    var login    = $("input[name='login']",    dlg).val();
    var password = $("input[name='password']", dlg).val();
    var remember = $("input[name='remember']", dlg).is(':checked');

    // Или анонимно, если стоит чекбокс
    if($('input[name="anonimous"]', dlg).is(':checked')) {
        login    = 'guest';
        password = 'guest';
    }
    
    $('input', dlg).attr('disabled', 'disabled');
    var promise = Auth.login(login, password, remember);
    promise.always(function(){
        $('input', dlg).removeAttr('disabled');
        that._anonimUpdate();
    });       
};

UserChangeDialog.prototype.logout = function() {
    Auth.logout();
};

UserChangeDialog.prototype.cancel = function() {
    $('#userChangeDialog').remove();
};

UserChangeDialog.prototype.registration = function() {
    Auth.registration();
};

function UserLoginDialog() {
    this.title = gis_userlogindialog_1;
    this.htmlUrl = 'ui/html/UserLoginDialog.html';    
    this.closable = false;
}

UserLoginDialog.prototype = new UserChangeDialog();

UserLoginDialog.prototype.build = function() {
    var that = this;

    $('#userChangeDialog').remove();
    $('body').append('<div id="userChangeDialog"></div>');
    var dlg = $('#userChangeDialog');
    dlg.load(this.htmlUrl, build);

    function build() {
        dlg.dialog({
            modal  : true,
            title  : that.title,
            dialogClass   : that.closable ? '' : 'noCloseButton',
            closeOnEscape : that.closable,
            width  : 265,
            height : 143
        });



        // Пятаемся перелогинится и по нажатию Enter тоже
        $('input[name="login"], input[name="password"]', dlg).keypress(function(e){
            if(e.which == 13) {
                that.change();
            }
        });

        // Блокируем поля ввода если надо войти анонимно
        $('input[name="anonimous"]', dlg).change(function(){
            that._anonimUpdate();
        });

        // Кнопки
        $("input[name='change']",       dlg).click(function(){ that.change(); });
        $("input[name='cancel']",       dlg).click(function(){ that.cancel(); });
        $("input[name='registration']", dlg).click(function(){ that.registration(); });

        // Подставим последний логин
        $('input[name="login"]', dlg).val(Auth.getLastLogin());
    }
};

UserLoginDialog.prototype.change = function() { 
    var that = this;
    
    var dlg = $('#userChangeDialog');
    var login    = $("input[name='login']",    dlg).val();
    var password = $("input[name='password']", dlg).val();
    var remember = $("input[name='remember']", dlg).is(':checked');

    // Если страница открыта с параметрами (например нам прислали ссылку по email)
    // От попробуетм открыть именно с такими параметрами
    var targetUrl;
    var m = /task=([^&#\^]+)&mdl=([^&#\^]+)([^$#]*)/.exec(window.location.href);
    if(m) {
        var splittedUrl  = window.location.href.split('#')[0].split('?');
        var smallurl = splittedUrl[0];
        targetUrl = smallurl+'?task='+m[1]+'&mdl='+m[2]+'&rand='+Math.random()+m[3];
    }    

    $('input', dlg).attr('disabled', 'disabled');    
    var promise = Auth.login(login, password, remember, targetUrl);        
    promise.always(function(){
        $('input', dlg).removeAttr('disabled');
        that._anonimUpdate();
    });    
};
/**
 * Класс диалога смены пароля
 */
ChangePasswordDialog = {
    build: function() {
        var that = this;

        if (!that.hasOwnProperty('changingUserLogin') || that.changingUserLogin==undefined || that.changingUserLogin==null) that.changingUserLogin = '';

        function build() {
            dlg.dialog({
                modal : true,
                dialogClass: 'gsi-zindex__dialog',
                title : gis_changepassworddialog_1,
                width : 380,
                buttons: [
                    {text:gis_changepassworddialog_2, click: function (){ that.change(that.changingUserLogin);} },
                    {text:gis_core_6, click: that.cancel}
                ]
            });
            var wgt = dlg.dialog('widget');

            dlg.keydown(function(event) {
                if (event.keyCode == 13) {
                    $('.ui-dialog-buttonset button:first', wgt).click();
                    return false;
                }
            });
        }

        $('#changePasswordDialog').remove();
        $('body').append('<div id="changePasswordDialog"></div>');
        var dlg = $('#changePasswordDialog');
        dlg.load('ui/html/ChangePasswordDialog.html', build);
    },
    
    change: function(changingUserLogin) {
        var dlg = $('#changePasswordDialog');
        
        var oldPassword  = $("input[name='oldPassword']",  dlg).val();
        var newPassword  = $("input[name='newPassword']",  dlg).val();
        var newPassword2 = $("input[name='newPassword2']", dlg).val();
        
        var error = null;
        var errorTitle = null;
        if(!/^.{1,}$/.test(newPassword)) {
            error = gis_changepassworddialog_4;
            errorTitle = gis_changepassworddialog_7;
        }
        /* Условие проверки - пароль не менее 8 символов, состоящий из латинских букв, хотя бы 1 цифры и хотя бы 1 спецсимвола */
        else if (newPassword.length<8 || !newPassword.match(/\d/) || !newPassword.match(/[a-zA-Z]/) || !newPassword.match(/[!,@,#,$,%,^,&,*,\(,\),\-,\+,?,_,:,;,~]/)) {
            error = gis_changepassworddialog_5;
            errorTitle = gis_changepassworddialog_6;
        }
        else if(newPassword !== newPassword2) {
            error = gis_changepassworddialog_8;
            errorTitle = gis_changepassworddialog_9;
        }
        
        if(error) {
            App.confirmDialog(error, null, {title:errorTitle});
        }
        else {
            //Для административной задачи вставляем условие, что если передали свойство currentUserLogin, то меняем пароль для него
            var userLoginPassChange = changingUserLogin!=undefined && changingUserLogin ? changingUserLogin : '';
            App.getJsonTextNode(Services.changePassNode, {
                newPassword	: CryptoJS.MD5(newPassword).toString(),
                password	: oldPassword,
                changeLogin	: userLoginPassChange,
                useExtAuth	: 'false',
                login       : Auth.getUserName()
            },function(resultXml){
                var er = HTTPServiceUtil.getError(resultXml);
                if(er !== ''){
                    App.errorReport(gis_admchangepassform_6, er, undefined, {filename:gis_filename_302, functionname:'gis_filename_302_3'});
                    return;
                }
                $('#changePasswordDialog').remove();
                App.confirmDialog(gis_changepassworddialog_10, null, {title:gis_changepassworddialog_11});
            },function(error){
                App.errorReport(error);
            });
        }
    },

    cancel: function() {
        $('#changePasswordDialog').remove();
    }        
};




/**
 * Класс диалога отправки отчета об ошибке
 */
SendErrorReportDialog = {
    dialogId: 'sendErrorReportDialog',    
    data: '',
    params: '',
	opener:undefined,
	closeCallback: undefined,//функция закрытия из формы ошибки
    
    setData: function(data, params, opener, closeCallback){
        this.data = data;
		this.closeCallback = closeCallback;
        //если дополнительные данные пришли(название файла, название функции,..), то заполняем переменную
        if(params !== undefined) {
            if(params.filename != undefined)
	            this.params += gis_senderrorreportdialog_16 + params.filename+"\n\n";
	        if(params.functionname != undefined)
	            this.params += gis_senderrorreportdialog_17 + params.functionname+"\n\n";
	        if(params.datatext != undefined)
		        this.params += gis_senderrorreportdialog_18 + params.datatext+"\n\n";
        }
        this.opener = opener;
    },
    
    build: function() {
        var that = this;

        $('#'+this.dialogId).remove();
        $('body').append('<div id="'+this.dialogId+'"></div>');
        var dlg = $('#'+this.dialogId);
        dlg.load('ui/html/SendErrorReportDialog.html', build);
        function build() {
            $('input[name="user"]',    dlg).val(Auth.getUserName());
            $('textarea[name="data"]', dlg).val(that.data);
	        $('textarea[name="paramsdata"]', dlg).val(that.params);

	        var buttons = {};
	        buttons[gis_senderrorreportdialog_19] = function(){ that.send()};
		    buttons[gis_senderrorreportdialog_20] = function(){ that.cancel()};

            dlg.dialog({
                modal : true,
                title : gis_senderrorreportdialog_1,
	            dialogClass: 'ui-send-error-dialog',
                width : 460,
                buttons: buttons
            });
        }
    },
    
    send: function() { 
        var that = this;
        
        var dlg = $('#'+this.dialogId);
        
        var type        = $("select[name='type']",          dlg).val();
        var email       = $("input[name='email']",          dlg).val();        
        var name        = $("input[name='name']",           dlg).val();
        var description = $("textarea[name='description']", dlg).val();
        var data        = $("textarea[name='data']",        dlg).val();
	    var paramsdata  = $("textarea[name='paramsdata']",  dlg).val();



	    if(paramsdata != '')
		    data += gis_senderrorreportdialog_15 + paramsdata + gis_app_55_12;
	    else
		    data += gis_app_55_12;

        var message =
	        gis_senderrorreportdialog_2 + Auth.getUserId() + "<br>" +
	        gis_senderrorreportdialog_3 + Auth.getUserName() + "<br>" +
	        gis_senderrorreportdialog_4 + name + "<br>" +
	        gis_senderrorreportdialog_5 + "<br><pre>"+description+"</pre><br>"+
	        gis_senderrorreportdialog_6 + "<br><pre>"+data+"</pre><br>";

	    App.getJsonTextNode(Services.sendMailNode, {
            addMailTo : email,
            subject   : type,
            fileName1  : '',
            message   : message
        },function(resp){
	    },function(textError){
		    App.errorReport(gis_senderrorreportdialog_11,gis_senderrorreportdialog_9+'. '+textError, undefined, {filename:gis_filename_292, functionname:'gis_filename_292_1'});
	    });
	    if(this.closeCallback)
		    this.closeCallback();
        App.destroyDialog(that.dialogId);
        if(this.opener)
	        App.destroyDialog(this.opener);
    },
    cancel: function() {
    	if(this.closeCallback)
		    this.closeCallback();
        App.destroyDialog(this.dialogId);
    }        
};




/**
 * Менеджер панелей задачи в json формате
 */
function PanelManagerJson() {
    this.container = null;
    this.json = null;
    /*Объект с возможными id панелей в качестве ключей и константами с текстом загрузки в качестве значений*/
    this.panelLoadingTextDict = {MAPSERVICE:gis_panelmanager55_2, WIDGET_GRID:gis_panelmanager55_3, CAS:gis_panelmanager55_4};
};

/**
 * Установка контейнера для панели с модулями
 */
PanelManagerJson.prototype.setContainer = function(container) {
    this.container = container;
};


//Парсинг структуры XML данных в div-ы с модулями
PanelManagerJson.prototype.build = function(json, taskName) {
    var that = this;
    if(json === undefined) return;
    try {
        var panelId = json.id;
        if(json.previous_site !== undefined && json.previous_site !== '')
            App.prevSite = json.previous_site;
        if(json.new_site !== undefined && json.new_site !== '')
            App.newSite = json.new_site;
        if (panelId === undefined){
            App.errorReport(gis_core_17,'В файле задач - ' + taskName + ' отсутствует id.' + gis_core_19, undefined, {filename:gis_filename_288, functionname:'gis_filename_288_3'});
            return;
        }
        var element = $('<div class="panel" id="'+panelId+'"/>');
        element.attr('style','width : 100%; height : 100%');
        this.container.empty().append(element);
        if(App.config !== undefined && json.ppanel !== undefined){
            App.config.SHOW_SYSTEM_INFO = json.ppanel.showSystemInfo;
        }
        if(App.scenarioManager){
            //устанавливаем конфиг сценариев
            App.scenarioManager.setConfig(json.startupScenario);
            App.scenarioManager.call(function(){
                that.loadTask(panelId, json);
            })
        }
        else{
            this.loadTask(panelId, json);
        }
    }
    catch(e) { // Распарсить XML не удалось
        App.errorReport(gis_panelmanager55_5, e, undefined, {filename:gis_filename_288, functionname:'gis_filename_288_2'});
        //Очищаем панель задач
        this.container.empty();
    }

};

/**
 * Функция загрузки задачи
 * @param panelId идентификатор задачи
 * @param json настройки задачи
 */
PanelManagerJson.prototype.loadTask = function(panelId, json){
    var panels = ['MAPSERVICE', 'MAPSERVICE_ADM_TREE', 'MAPTECHSERVICE', 'adm_lib_doc'];
    if(panels.indexOf(panelId) !== -1 ){
        //для карты парсим её настройки в отдельнфй объект карты
        if(!goog.isDefAndNotNull(WidgetMap.config)){
            WidgetMap.config = json;
            WidgetMap.treeConfig = json.tree;
            WidgetMap.videoConfig = json.video;
        }
        if(panelId === "MAPTECHSERVICE") {
            var browserScale = getBrowserZoom();
            if(browserScale !== 1){
                App.confirmDialog(gis_core_23, null, {title:gis_core_1, dialogClass: 'noCloseButton', closeOnEscape: false});
            }
        }
        App.PreloadUser(panelId, true);
    }
    else if(panelId === "CAS"){
        //для ПКА парсим её настройки в отдельнфй объект карты
        if(!goog.isDefAndNotNull(WidgetMap.config))
            WidgetMap.setConfig(json);
        App.PreloadUser(panelId,true);
        //App.PreloadCAS(panelId,true);
    }
}

/**
 * Класс всплывающей формы с гридом
 */
/* TEXT CONSTANTS */
var GRID_DIALOG_DEFAULT_TITLE = gis_gridwindow_55_1;
var GRID_DIALOG_ERROR_CLOSE_TAB_TEXT = gis_gridwindow_55_2;
var GRID_DIALOG_ERROR_OPEN_TAB_IN_NEW_WINDOW_TEXT = gis_gridwindow_55_3;
var GRID_DIALOG_ERROR_DIALOG_CLOSE_TEXT = gis_gridwindow_55_4;
var GRID_DIALOG_ERROR_DIALOG_RESIZE_TEXT = gis_gridwindow_55_5;
var GRID_WINDOW_POSITION = undefined;
//перечень кнопок, по нажатию которых, открываются какие-либо попапы(открытие панели свойств, фильтры, экспорт gpx, excel)
GridButtonsWithPopup = ['showInfoEvent', 'updateSheetExcavateEvent', 'updateSheetRepairEvent', 'doubleClickEvent', 'ru.corelight.business.events.CreateObjectEvent',
'ru.corelight.business.events.BEditControlShowEvent', 'gridAdmMapsEditMap', 'gridAdmUsersRegisterUser', 'ru.corelight.business.events.ExportToExcelEvent',
'ru.corelight.business.events.ExportToGPXEvent'];

HAS_DASHBOARD = false;

function GridWindow() {
    this.title = GRID_DIALOG_DEFAULT_TITLE;
    this.closable = true;
    this.gridTabNavId = 'gridTabNavigator';
    this.gridWidget = undefined;
    this.defaultSize = []; //width, height
    this.defaultPosition = []; //left, top
    //29.12.2021 Vartanian Параметр регулирет поведение, сохранять положение грида или нет
    this.singleTab = false;
};

GridWindow.prototype.build = function(newTaskUrl, elementId, urlParams, windowTemplate, minimize) {
    //TODO временное условие, если флаг не показывать кнопки закрытия грида , то грид делаем не интерактивным.
    //нельзя двигать, менять размеры - только взаимодействие с контентом грида и открытие вкладок при небходимости перемещения между ними
    var titlebar = !(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.titlebar === false);
    var draggable = titlebar, resizable = titlebar;
    var that = this;
    /*Функция очистки iframe при закрытии */
    function deleteIFrame(iframeId) {
        try {
            var elem = $('#' + iframeId);
            if (elem!=undefined && elem!=null) {
                elem[0].src = "about:blank";
                elem[0].contentWindow.document.write('');
                elem[0].contentWindow.close();
                elem.remove();
                if( typeof CollectGarbage == "function") {
                    CollectGarbage();
                }
            }
        }
        catch (e) {
            /*ничего не делаем, если iframe не очистился*/
        }
    }
    /*Функция очистки всех iframe в текущем tabNavigator'е (вызывается когда закрываем плавающее окно)*/
    function deleteAllTabNavIFrames() {
        try {
            var tabNav = $('#' + that.gridTabNavId);
            var length = tabNav.jqxTabs('length');
            for (i = 0; i < length; i++) {
                var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
                /*Получаем iframe из данной вкладки*/
                var selectedContentIFrame = selectedContent.getElementsByTagName('iframe')[0];
                /*Очищаем удаляемую из вкладки iframe */
                if(selectedContentIFrame != undefined)
                    deleteIFrame(selectedContentIFrame.id);
            }
            tabNav.jqxTabs('destroy');
        }
        catch (e) {
            /*ничего не делаем, если iframe не очистился*/
        }
    }

    /*Функция-слушатель события закрытия вкладки tabNavigator'a*/
    function onSingleTabClose(event) {
        var tabNav = $('#' + that.gridTabNavId);
        try {
            if (event.args.hasOwnProperty('item')) {
                var tabNum = event.args.item;
                var selectedContent = tabNav.jqxTabs('getContentAt', tabNum)[0];
                //Удаляем все панели свойств, созданные из грида текущей вкладки
                $('#divPPanel'+'jqxgrid'+selectedContent.id).each(function removeTabGridPropPanels(){
                    $(this).remove();
                });
                $('#jqxDockPanel'+'jqxgrid'+selectedContent.id).each(function removeTabGridButtons(){
                    $('.gridButtonsPanel',$(this)).remove();
                });
                //дестроим грид
                $('#jqxgrid'+selectedContent.id).each(function destroyGrid(){
                    try{
                        $(this).jqxGrid('destroy');
                    }
                    catch(err){

                    }
                });
                //дестроим докпанель
                $('#jqxDockPanel'+'jqxgrid'+selectedContent.id).each(function destroyGridDockPanel(){
                    try{
                        $(this).jqxDockPanel('destroy');
                    }
                    catch(err){

                    }
                });
                /* Получаем iframe из данной вкладки*/
                var selectedContentIFrame = selectedContent.getElementsByTagName('iframe')[0];
                /*Очищаем удаляемую из вкладки iframe */
                if(selectedContentIFrame!=undefined)
                    deleteIFrame(selectedContentIFrame.id);
            }
        }
        catch (e) {
            //App.errorReport(GRID_DIALOG_ERROR_CLOSE_TAB_TEXT, e);
        }
        /*Если вкладка всего одна - закрываем все окно*/
        try {
            var items = tabNav.jqxTabs('length');
            if (items <= 1 ) {
                tabNav.jqxTabs('destroy');
                tabNav.remove();
            }
        }
        catch (e) {
            App.errorReport(GRID_DIALOG_ERROR_CLOSE_TAB_TEXT, e, undefined, {filename:gis_filename_281, functionname:'gis_filename_281_1'});
        }
    }

    /*Функция для очистки при закрытии окна*/
    function onDialogClose(event, ui) {
        if(!event) return;
        var tabNav = $('#'+that.gridTabNavId);
        try {
            //Удаляем все панели свойств, созданные из всех открытых гридов
            $('.gridTabContentElement',tabNav).each(function (){
                $('#divPPanel'+'jqxgrid'+this.id).each(function removeTabGridPropPanels(){
                    $(this).remove();
                });
                $('#jqxDockPanel'+'jqxgrid'+this.id).each(function removeTabGridButtons(){
                    $('.gridButtonsPanel',$(this)).remove();
                });
                //дестроим грид
                $('#jqxgrid'+this.id).each(function destroyGrid(){
                    try{
                        $(this).jqxGrid('destroy');
                    }
                    catch(err){
                    }

                });
                //дестроим докпанель
                $('#jqxDockPanel'+'jqxgrid'+this.id).each(function destroyGridDockPanel(){
                    try{
                        $(this).jqxDockPanel('destroy');
                    }
                    catch(err){
                    }
                });
            });
            /*Пытаемся удалить все iframe из памяти */
            deleteAllTabNavIFrames();
            /*Удаляем tabNavigator*/
            tabNav.remove();
        }
        catch (e) {
            /*Пытаемся удалить все iframe из памяти */
            deleteAllTabNavIFrames();
            /*Удаляем tabNavigator*/
            tabNav.remove();
            App.errorReport(GRID_DIALOG_ERROR_DIALOG_CLOSE_TEXT, e, undefined, {filename:gis_filename_281, functionname:'gis_filename_281_3'});
        }
    }
    function onDialogDrag(event, ui){
        if(!event) return;
        var tabNav = $('#' + that.gridTabNavId);
        var popupWnd = tabNav.parent();
        if (popupWnd) {
            //сохраняем размеры грида и положение
            if (that.singleTab)//29.12.2021 Vartanian Параметр регулирет поведение, сохранять положение грида или нет
                that.savePositionState(popupWnd.position().left, popupWnd.position().top, popupWnd.outerWidth(), popupWnd.outerHeight());
        }
    }
    /*Функция для перемасштабирования элементов внутри tabNavigator'а после изменения размеров плавающего окна*/
    function onDialogResize(event, ui) {
        try {
            if(!event) return;
            if(event === 'restore_default'){
                onDialogRestoreDefault(event, ui);
                return;
            }
            GridUtil.removeAllPPanels();
            var tabNav = $('#' + that.gridTabNavId);
            var popupWnd = tabNav.parent();
            if (popupWnd != undefined && popupWnd) {
                var popupWndHeight = popupWnd.outerHeight() - 75;
                $('#' + that.gridTabNavId + ' .gridTabContentElement').css({height: popupWndHeight, overflow: 'hidden'});

                //сохраняем размеры грида и положение(если не нажимали кнопку "развернуть")
                // if(event && event.type !== 'dialogextendmaximize')
                if (that.singleTab)//29.12.2021 Vartanian Параметр регулирет поведение, сохранять положение грида или нет
                    that.savePositionState(popupWnd.position().left, popupWnd.position().top, popupWnd.outerWidth(), popupWnd.outerHeight());
            }
        }
        catch (e) {
            App.errorReport(GRID_DIALOG_ERROR_DIALOG_RESIZE_TEXT, e, undefined, {filename:gis_filename_281, functionname:'gis_filename_281_4'});
        }
    }

    function onDialogRestoreDefault(event, ui){
        var tabNav = $('#' + that.gridTabNavId);
        tabNav.dialog('option', {width:that.defaultSize[0], height: that.defaultSize[1], "position": that.defaultPosition});
        /*Вызываем события resize как при изменении размеров мышкой*/
        /*tabNav.trigger("resize");
        tabNav.dialog('option', 'resize').apply(tabNav, [null, null]);*/
        var popupWnd = tabNav.parent();
        if (popupWnd != undefined && popupWnd) {
            var popupWndHeight = popupWnd.outerHeight() - 75;
            $('#' + that.gridTabNavId + ' .gridTabContentElement').css({height: popupWndHeight, overflow: 'hidden'});
        }
    }

    /*Функция для построения диалоговой формы с контентом внутри*/
    function buildDialog(dlg) {
        //пересчет координат и положения
        var mmap = $('#map');
        var tree = $('#treeDiv');
        //если есть карта, получаем её границы и от них отсчитываем
        var left = 0;
        var top = 0;
        if(mmap.length > 0){
            //делаем отступы
            left = 42;
            top = 54;
            firstDialogWidth = mmap.width()-85;
            firstDialogHeight = mmap.height()-104;
            if(!titlebar){
                firstDialogWidth = mmap.width();
                firstDialogHeight = mmap.height() - 54;
            }
        }
        if(tree.length > 0){///если есть рубрикатор,
            left += tree.width();
            firstDialogWidth -= tree.width();
            if(!titlebar){
                left = 10;
                firstDialogWidth += tree.width() -10;
                $('#treeButtonDiv').parent().hide();
            }
        }
        //если настройки установлены в файле задач

        var gridConf = WidgetMap.config.grid;
        if(gridConf ){
            if(gridConf.position){
                var gridPos = gridConf.position;
                if(gridPos.left !== undefined)
                    left = gridPos.left;
                if(gridPos.top !== undefined)
                    top = gridPos.top;
                if(gridPos.width !== undefined){
                    if(gridPos.width.toString().indexOf('%') !== -1){
                        var gridWidth = Number(gridPos.width.toString().replace('%',''))/100;
                        firstDialogWidth =  $(window).width() * gridWidth;
                    }
                }
                if(gridPos.height !== undefined){
                    if(gridPos.height.toString().indexOf('%') !== -1){
                        var gridHeight = Number(gridPos.height.toString().replace('%',''))/100;
                        firstDialogHeight =  $(window).height() * gridHeight;
                    }
                }
            }
            if(gridConf.resizable === false){
                resizable = gridConf.resizable;
            }
            if(gridConf.draggable === false){
                draggable = gridConf.draggable;
            }
            if(gridConf.singleTab === true){ //29.12.2021 Vartanian Параметр регулирет поведение, сохранять положение грида или нет
                that.singleTab = gridConf.singleTab;
            }
        }
        if(GRID_WINDOW_POSITION && GRID_WINDOW_POSITION.width !== undefined){
            left = GRID_WINDOW_POSITION.left;
            top = GRID_WINDOW_POSITION.top;
            firstDialogWidth = GRID_WINDOW_POSITION.width;
            firstDialogHeight = GRID_WINDOW_POSITION.height;
        }
        that.defaultPosition = [left,top];
        that.defaultSize = [firstDialogWidth, firstDialogHeight];
        var pos = [left, top];
        var isDashboard = false;
        var dialogClass = 'gridDialogClass';
        if(HAS_DASHBOARD || (WidgetMap && WidgetMap.config && WidgetMap.config.charts && WidgetMap.config.charts.length > 0)){
            HAS_DASHBOARD = true;
            var config = $.extend({}, WidgetMap.config.grid);
            var p = getPositionFromConfig(config.position, true);
            pos = {my: "left+" + p.left + " top+" + p.top, at: "left top", of: 'body', collision: 'none'};
            firstDialogWidth = p.width;
            firstDialogHeight = p.height;
            that.defaultPosition = [p.left,p.top];
            that.defaultSize = [firstDialogWidth, firstDialogHeight];
            isDashboard = true;
            dialogClass = 'noCloseButton hide-dialog';
            titlebar = false;
            resizable = false;
            draggable = false;
        }
        dlg.dialog({
            resizable: resizable,
            draggable: draggable,
            modal  : false,
            title  : that.title,
            dialogClass   : that.closable ? dialogClass : 'noCloseButton '+dialogClass,
            closeOnEscape : false,
            width  : firstDialogWidth,
            height : firstDialogHeight,
            close: onDialogClose,
            resize: onDialogResize,
            drag: onDialogDrag,
            position: pos
        })
            .dialogExtend({
                "closable" : titlebar,
                "maximizable" : titlebar,
                "minimizable" : titlebar,
                /*"collapsable" : true,*/
                "dblclick" : "maximize",
                "titlebar" : "transparent",
                "minimizeLocation" : "right",
                "icons" : {
                    "close" : "ui-icon-gisCloseButton",
                    "maximize" : "ui-icon-gisMaximizeButton",
                    "minimize" : "ui-icon-gisMinimizeButton",
                    "collapse" : "ui-icon-triangle-1-s",
                    "restore" : "ui-icon-gisRestoreButton"
                },
                "load" : onDialogResize,
                "maximize" : onDialogResize,
                "restore" : onDialogResize
            });
        if(HAS_DASHBOARD){
            dlg.addClass('hide-grid');
            //dlg.dialog('hide')
            //$('html').scrollTop(0);
        }

    }


    var gridTaskName = 'GRID';
    var parentGrid, childGrid;
    var parentRoughFilter = undefined;
    var parentRoughParams = undefined;
    var staticParentRoughFilter = undefined;
    var parentGridRowId, parentGridFilter;
    var filterMap = false;
    var showDashboard = false;
    var ignoreLabelColumn = true;
    var position = -1;
    /*Шаблон грида (например 'PODS_ROUTE_LIST')*/
    var gridTemplate;
    //Полный идентификатор слоя (в виде PODS_EQUIP_Layers.xml*PODS_ROUTE - разделитель звездочка)
    var  gridFullLayerId;
    /*Заголовок окна с гридами (берется из меню)*/
    var firstDialogTitle = GRID_DIALOG_DEFAULT_TITLE;
    /*Начальные ширина/высота плавающего диалога со вкладкими гридов*/
    var firstDialogWidth = 500;
    var firstDialogHeight = 300;
    var tabTitle = GRID_DIALOG_DEFAULT_TITLE; /*Заголовок новой вкладки по-умолчанию*/
    var tabTitleMaxLength = 30; /*Максимальная длина строки, отображаемой в заголовке вкладки*/

    var gridType = "GridWidget"; /*Класс, которым обрабатываем загрузку грида (админский или обычный грид)*/

    /*Забираем необходимые значения из параметров windowTemplate*/
    if (windowTemplate && windowTemplate!='') {
        var windowTemplateStr = windowTemplate.replace(/ /g, '');
        var wndTemplateParams = windowTemplateStr.split(',');
        for (var j = 0; j < wndTemplateParams.length; j++) {
            var curParam = wndTemplateParams[j];
            var curParamArr = curParam.split('=');
            if (curParamArr && curParamArr.length==2) {
                if (curParamArr[0].toLowerCase()=='width') firstDialogWidth = parseFloat(curParamArr[1]);
                if (curParamArr[0].toLowerCase()=='height') firstDialogHeight = parseFloat(curParamArr[1]);
            }
        }
    }
    if(firstDialogWidth>$(window).width())
        firstDialogWidth = $(window).width()-20;
    if(firstDialogHeight>$(window).height())
        firstDialogHeight = $(window).height()-20;

    /*Забираем необходимые значения из параметров urlParams*/
    if (urlParams) {
        for (var i = 0; i < urlParams.length; i++) {
            /*Устанавливаем заголовок очередной вкладки (при этом обрезаем его, если он слишком длинный)*/
            if (urlParams[i].hasOwnProperty('name')) {
                var urlParamName = urlParams[i]['name'].toLowerCase();
                var urlParamValue = urlParams[i]['value'];
                //Не обрезаем заголовок вкладки, оставляем оригинальный (он используется для панели свойств)
                if (urlParamName=='title') tabTitle = urlParamValue.substring(0, urlParamValue.length); //tabTitle = urlParamValue.substring(0, Math.min(urlParamValue.length, tabTitleMaxLength));
                tabTitle = tabTitle.replace(/'/g,''); //Убираем в заголовке обрамляющие кавычки
                if (urlParamName=='task') gridTaskName = urlParamValue.substring(0, urlParamValue.length);
                if (urlParamName=='template') gridTemplate = urlParamValue.substring(0, urlParamValue.length);
                if (urlParamName=='fulllayerid') gridFullLayerId = urlParamValue.substring(0, urlParamValue.length);
                if (urlParamName=='gridtype') gridType = urlParamValue.substring(0, urlParamValue.length);
                if (urlParamName=='parentgrid' && urlParamValue) parentGrid = urlParamValue.substring(0, urlParamValue.length);
                if (urlParamName=='childgrid' && urlParamValue) childGrid = urlParamValue.substring(0, urlParamValue.length);
                if (urlParamName=='position' && urlParamValue !== undefined) position = urlParamValue;
                if (urlParamName=='parentroughfilter' && urlParamValue !== undefined) parentRoughFilter = urlParamValue;
                if (urlParamName=='staticparentroughfilter' && urlParamValue !== undefined) staticParentRoughFilter = urlParamValue;
                if (urlParamName=='parentroughparams' && urlParamValue !== undefined) parentRoughParams = urlParamValue;
                if (urlParamName=='filtermap' && urlParamValue !== undefined) filterMap = urlParamValue;
                if (urlParamName=='showdashboard' && urlParamValue !== undefined) showDashboard = urlParamValue == 'true';
                if (urlParamName=='ignorelabelcolumn' && urlParamValue !== undefined) ignoreLabelColumn = urlParamValue == 'true';
                if (urlParamName=='parentgridrowid' && urlParamValue !== undefined) parentGridRowId = urlParamValue;
                if (urlParamName=='parentgridfilter' && urlParamValue !== undefined) parentGridFilter = urlParamValue;
            }
        }
    }

    /*Устанавливаем заголовок для окна с гридами*/
    if (App.menu!=undefined && App.menu) {
        firstDialogTitle = App.menu.getTaskTitleByTaskName(gridTaskName);
        that.title = firstDialogTitle;
    }

    /*Очищаем содержимое элемента, в котором создаем грид*/
    $('#'+elementId).remove();

    var tabNavigatorElement = document.getElementById(that.gridTabNavId);
    var tabNav = null;

    /*Тег дополнительной кнопки для открытия вкладки в окне (задаем класс для управления через css)*/
    /*var btnInWndTag = '<div id="btnInWnd_'+elementId+'" class="jqx-tabs-open-in-window-button"></div>';*/

    //Функция обновления всплывающих подсказок на вкладках
    var refreshTabsTooltips = function refreshTabsTooltips() {
        /*$('.jqx-tabs-open-in-window-button').jqxTooltip({position: 'mouse', content: 'Открыть в новом окне'});*/
        //$('.jqx-tabs-close-button').jqxTooltip({position: 'mouse', content: gis_gridwindow_55_6});
        $('.jqx-tabs-close-button').attr('title', gis_gridwindow_55_6);
    };

    /*Если навигатора еще не было, создаем новый с 1 вкладкой*/
    if (!tabNavigatorElement) {
        var bodyElement = $('body');
        /*Добавляем к body div для навигатора*/
        bodyElement.append('<div id="'+that.gridTabNavId+'" class="gridTabContent"></div>');

        tabNav = $('#'+that.gridTabNavId);

        /*к пустому div'у добавляем необходимый контент для создания навигатора (добавляя в заголовок кнопку открытия в окне)*/
        /*tabNav.append('<ul><li>' + tabTitle + btnInWndTag + '</li></ul><div id="'+elementId+'" class="gridTabContentElement"></div>');*/
        /*к пустому div'у добавляем необходимый контент для создания навигатора (без добавления в заголовок кнопку открытия в окне)*/
        tabNav.append('<ul><li>' + tabTitle.substring(0, Math.min(tabTitle.length, tabTitleMaxLength)) + '</li></ul><div id="'+elementId+'" class="gridTabContentElement"></div>');
        /*Создаем навигатор*/
        tabNav.jqxTabs({ width: '100%', theme: 'gis-blueorange', showCloseButtons: true});
        //Обновляем tooltip'ы для кнопок на вкладках
        refreshTabsTooltips();

        /*Добавляем слушатель события закрытия вкладки tabNavigator'a*/
        tabNav.on('beforeremove', onSingleTabClose);
        /*Создаем плавающий диалог из tabNavigator'a*/
        buildDialog(tabNav);
    }
    else { /*Если навигатор со вкладками уже создан, просто добавляем очередную вкладку*/
        tabNav = $('#'+that.gridTabNavId);
        /*Если плавающее окно с гридами находится в свернутом состоянии - сначала разворачиваем, иначе вкладки не будут показываться корректно*/
        var curDialogState = tabNav.dialogExtend("state");
        if (curDialogState && curDialogState!=undefined && (curDialogState=='minimized' || curDialogState=='collapsed')) {
            tabNav.dialogExtend("restore");
        }
        /*Добавляем новую вкладку (добавляя в заголовок кнопку открытия в окне)*/
        /*tabNav.jqxTabs('addFirst', tabTitle + btnInWndTag, '<div id="'+elementId+'" class="gridTabContentElement"></div>');*/
        /*Добавляем новую вкладку (без добавления в заголовок кнопки открытия в окне)*/
        var length = tabNav.jqxTabs('length');
        if(position !== -1 && position !== undefined && position < length){
            tabNav.jqxTabs('addAt', position, tabTitle.substring(0, Math.min(tabTitle.length, tabTitleMaxLength)), '<div id="'+elementId+'" class="gridTabContentElement"></div>');
            tabNav.jqxTabs('ensureVisible', position);
        }
        else{
            tabNav.jqxTabs('addLast', tabTitle.substring(0, Math.min(tabTitle.length, tabTitleMaxLength)), '<div id="'+elementId+'" class="gridTabContentElement"></div>');
            var length = tabNav.jqxTabs('length') - 1;
            tabNav.jqxTabs('ensureVisible', length);
        }

        //Добавляем tooltip'ы для кнопок на вкладках
        refreshTabsTooltips();
    }
    /*if(!titlebar)
        tabNav.jqxTabs('hideAllCloseButtons');*/

    /*Выравниваем высоту элементов внутри плавающего окна*/
    tabNav.css({overflow:'hidden'});

    onDialogResize(null, null);
    if(minimize) widgetMoveWindowToPosition('grid');

    /*Добавляем в новую вкладку контент (iframe с гридом)*/
    /*Чтобы не грузилить iframe - устанавливаем условие проверки наличия gridTemplate*/
    if (gridTemplate===undefined && newTaskUrl!=undefined && newTaskUrl!=null && newTaskUrl!="") {
        /*Создаем iframe*/
        var iframe = App.createIFrame(newTaskUrl,elementId);
        /*Сохраняем параметры для открытия окна в iframe (понадобятся для открытия вкладки в новом окне браузера)*/
        iframe["openWindowVars"] = {newTaskUrl: newTaskUrl, urlParams: urlParams, windowTemplate: windowTemplate};
        /*Добавляем созданный iframe в наш div*/
        var element = document.getElementById(elementId);
        element.appendChild(iframe);
        /*Возвращаем загруженный iframe*/
        return iframe;
    }
    else {
        /*Загружаем виджет грида в только что созданный div*/
        /*Возвращаем элемент с гридом*/
        /*var gridWidget = undefined;
        that.gridWidget  = gridWidget;*/
        return App.loadWidgetGrid(elementId, gridTemplate, gridFullLayerId, tabTitle, gridType, urlParams);
    }
};

GridWindow.prototype.cancel = function() {
    $('#'+this.gridTabNavId).remove();
};

/**
 * Сохранение позиции грида
 * @param left
 * @param top
 * @param width
 * @param height
 */
GridWindow.prototype.savePositionState = function(left, top, width, height){
    //TODO объединить две установки в одну
    GRID_WINDOW_POSITION = {
        left: left,
        top: top,
        width: width,
        height: height,
    }
    this.defaultSize = [width, height]; //width, height
    this.defaultPosition = [left, top]; //left, top
}


/**
 * Класс для хранения всех открытых гридов
 * @constructor
 */
function GridManager(){
    this.grids = [];
};


GridManager.prototype.add = function(gridWidget){
    if(gridWidget){
        var newGrids = [];
        //перед добавлением чистим пустые гриды
        for (var j = 0; j < this.grids.length; j++) {
            //добавляем проверку. Если грида нет в dom, то удаляем его из массива
            var gridElem = $("#jqxgrid" + this.grids[j].id);//jqxgridid1466_GRID
            //временная заглушка по шурфовкам. Там сохраняется id грида закрытого
            if (gridElem.length === 0 && (gridWidget.layerId !== 'PODS_STO_SHURF_PLAN' ||
                gridWidget.layerId !== 'PODS_STO_SHEET_EXCAVATE' ||
                gridWidget.layerId !== 'PODS_STO_ILI_DATA_SHEET_RELOAD'))
                continue;
            newGrids.push(this.grids[j]);
        }
        this.grids = newGrids;
        /*for (var j = 0; j < this.grids.length; j++) {
            if (this.grids[j].fullLayerId !== gridWidget.fullLayerId) {
                newGrids.push(this.grids[j]);
            }
        }
        for(var i=0; i<this.grids.length; i++){
            //if(this.grids[i].id === gridWidget.id)
            if(this.grids[i].fullLayerId === gridWidget.fullLayerId)
                return;
        }*/
        this.grids.push(gridWidget);
    }
};

/**
 * Получить первый объект грида по его полному названию слоя *_Layers.xml*LAYER_NAME
 * @param fullLayerId
 * @returns {undefined|*}
 */
GridManager.prototype.get = function(fullLayerId){
    for (var i = 0; i < this.grids.length; i++) {
        //if(this.grids[i].id === gridId)
        if (this.grids[i].fullLayerId === fullLayerId)
            return this.grids[i];
    }
    return undefined;
};


/**
 * Получить массив гридов по полному названию слоя *_Layers.xml*LAYER_NAME
 * @param fullLayerId
 * @returns {*[]}
 */
GridManager.prototype.getAll = function(fullLayerId){
    var grids = [];
    for (var i = 0; i < this.grids.length; i++) {
        if (this.grids[i].fullLayerId === fullLayerId)
            grids.push(this.grids[i]);
    }
    return grids;
};

GridManager.prototype.getFullLayerIdByLayerName = function(layerName){
    for(var i=0; i<this.grids.length; i++){
        if (this.grids[i].fullLayerId.indexOf('#') !== -1)
            this.grids[i].fullLayerId = this.grids[i].fullLayerId.replace('#', '*')
        if(this.grids[i].fullLayerId.split('*')[1] === layerName)
            return this.grids[i].fullLayerId;
    }
    return undefined;
};

GridManager.prototype.getByGridId = function(gridId){
    for(var i=0; i<this.grids.length; i++){
        if(this.grids[i].id === gridId)
            return this.grids[i];
    }
    return undefined;
};

GridManager.prototype.has = function(gridId){
    /*var newGrids = [];
    for (var j = 0; j < this.grids.length; j++) {
        //добавляем проверку. Если грида нет в dom, то удаляем его из массива
        var gridElem = $("#jqxgrid" + this.grids[j].id);//jqxgridid1466_GRID
        if (gridElem.length === 0)
            continue;
        newGrids.push(this.grids[j]);
        // if (this.grids[j].fullLayerId === gridId) {
        //     newGrids.push(this.grids[j]);
        // }
    }
    this.grids = newGrids;*/
    for (var i = 0; i < this.grids.length; i++) {
        //if(this.grids[i].id === gridId)
        if (this.grids[i].fullLayerId === gridId) {
            //добавляем проверку. Если грида нет в dom, то удаляем его из массива
            return true;
        }
    }
    return false;
};


App.GridManager = new GridManager();

/**
 * Класс js-виджета грида (встраивается функцией build в элемент с id=widgetElementId)
 */
GridWidget.DEFAULT_FILTER = "8=8";
//глобавлая переменная с описаниями гридов для работы кнопки фильтрации вначале при открытии грида
GlobalGridDescr = {};

function GridWidget(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.layerId = '';
	this.fullLayerId = options.fullLayerId;
	this.id = options.id; //ex. id5828_GRID
	this.title = options.title || '';
	this.gridDescriptionXml = null;
	this.gridDescriptionJson = null;
	this.dataAdapter = undefined;
	//флаг указывает, были ли какие-то манипуляции с контентом грида(фильтрация, сортировка, смена кол-ва записей)
	this.modified = false;
	this.refreshGridCallback = undefined;
	this.ignoreAllFilter = false;
	//флаг начального открытия формы фильтров для дашбордов
	this.showDashboard = options.showDashboard;
	//условия раскраски ячеек
	this.colorValidations = {};
	//условие раскраски строк
	//формат расцветки(выбрано или нет условие и массив расцветки) {selected: false, array:[]};
	this.colorRowValidations = {};
	this.colorRowSelectType = 0;//не выделять строки грида после расцветки. 1 - выделить некритичные, 2 - выделить критичные
	this.maxCriticalColor = undefined;
	this.minCriticalColor = undefined;
	//фильтр, пришедший извне
	this.filter = options.filter;
	this.checkedList = [1];
	//название грида в тулбаре от названия выбранной колонки
	this.titleGridColumn = undefined;
	//нужно ли игнорировать отрисовку колонки(для случая наличия кнопки "Показать все записи")
	this.ignoreLabelColumn = (options.ignoreLabelColumn !== undefined) ? options.ignoreLabelColumn: true;

	//идентификаторы родительского грида и потомка
	this.parentGrid = options.parentGrid;
	this.childGrid = options.childGrid;

	//фильтры из родительского грида, которые попадают как есть в переменную FILTER_SQLITE
	this.parentRoughFilter = options.parentRoughFilter;
	//храним родительский фильтр для использования при переходе наружу
	this.staticParentRoughFilter = options.staticParentRoughFilter;
	//переменные из родительского грида, которые попадают в <var> - являются содержимым колонок грида
	this.parentRoughParams = options.parentRoughParams;
	this.parentGridRowId = options.parentGridRowId;
	this.parentGridFilter = options.parentGridFilter;
	this.showFirstBottomFilterMessage = false; // флаг показа сообщения, что был переход из дочернего грида и нельзя выставить скалярные значения
	if(this.parentGridFilter && this.parentGridFilter.length > 0)
		this.showFirstBottomFilterMessage = true;

	if(!this.parentRoughFilter)
		this.ignoreLabelColumn = true;
	//флаг, нужно ли центроватьна карте сразу при открытии грида
	this.filterMap = options.filterMap;

	//перечень колонок грида
	this.columns = [];
	//перечень скрытых на данный момент колонок грида
	this.hiddenColumns = undefined;

	/********* Начало блока для предзагрузки данных ************/
	//закэшированные изначальные данные со всеми колонками
	this.cachedRecords = []; //pageSize * 10 = 500 записей

	//массив отображаемых записей в гриде.
	this.cachedContentRecords = [];

	this.pageSize = 30;//количество записей на страницу
	this.pageCacheSize = 150;//количество закешированных записей
	this.pageCursor = 1;//начальное положение, по достижению лимита 120 записей(this.pageCacheSize-this.pageSize) отправляем запрос на догрузку новых данных

	/********* Конец блока для предзагрузки данных ************/
	//список идентификаторов, которые на данный момент находятся в заполненном гриде.
	//используется в рамках синхронизации с картой
	this.currentRequestedIds = [];

	//начальное состояние настроек грида
	this.defaultState = null;
	//используется для хранения промежуточной информации, например, когда скрываем колонки
	this.currentState = null;

	//Функция обратного вызова для передачи данных в плагин jqxDataAdapter после их успешного возвращения
	this.jqxDataAdapterCallback = undefined;

	this.primaryKeyField = 'ID';
	this.foreignKeyField = '';

	//фильтры из build
	this.filters = [
		{name: 'LPU_ACCESS_FILTER', value: '13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0'}
	];
}

GridWidget.prototype.build = function(widgetElementId, gridTemplate, fullLayerId, gridTitle) {
	var that = this;
	that.title = gridTitle;
	//Уникальный идентификатор грида формируем на основе идентификатора элемента
	var jqxGridId = "jqxgrid" + widgetElementId;
	//Формируем обертку, в которой будем создавать грид
	var widgetContent =
		'<div id="jqxDockPanel' + jqxGridId + '" style="width: 100%; height: 100%">' +
		'<div dock="left" id="gridButtons' + jqxGridId + '" class="gridButtonsPanel">' +
		'</div>' +
		'<div id="jqxWidget' + jqxGridId + '" dock="right" style="width: 100%; height: 100%;">' +
		'<div id="' + jqxGridId + '" class="mainGrid" data-layerid="' + fullLayerId + '" >' + getLocalization('ru').loadtext +
		'</div>' +
		'</div>' +
		'</div>';
	$('#' + widgetElementId).html(widgetContent);
	//Создаем панель с возможностью процентного и фиксированного layout
	$("#jqxDockPanel"+jqxGridId).jqxDockPanel({ width: '100%', height: '100%'});
	//id запроса на данные и количество записей
	var currentGridMessageId = undefined; //Это не ID запроса. Это сам текущий запрос на грид, который можно отменить через currentGridMessageId.abort()
	var isDataAborted = false;
	//Источник данных текущего грида (сделан публичным для обновления грида)
	var gridSource = {};

	//Фильтры верхнего уровня по-умолчанию, которые передаются в запрос
	var filters = [
		{name: 'LPU_ACCESS_FILTER', value: '13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0'}
	];
	this.filters = filters;
	//количество загруженных справочников
	var loadingFilterCount = 0;

	//Фильтры среднего уровня по-умолчанию, которые передаются в запрос
	var roughFilters = [];

	//Сразу парсим и получаем слой грида через LayerManager
	var layerManagerInst;
	if (WidgetMap !== undefined && WidgetMap.layerManager !== undefined) {
		layerManagerInst = WidgetMap.layerManager;
	} else {
		//Устанавливаем fullLayerId в нормальный (с разделителем # вместо *)
		var gridFullLayerId = fullLayerId.replace('*','#');
		var gridFullLayerIdArr = gridFullLayerId.split('#');
		var gridLayerFileName = gridFullLayerIdArr[0];
		var gridLayerId = gridFullLayerIdArr[1];

		layerManagerInst = new LayerManager();
		layerManagerInst.parseLayersDescr(gridLayerFileName);
	}
	var cancelGridProcess = function () {
		if (currentGridMessageId) {
			isDataAborted = true;
			currentGridMessageId.abort();
			currentGridMessageId = undefined;
			//Снимаем курсор ожидания
			BlockingUtil.ready();
			//Не обновляем грид - это делается в endProcess.
		}
	};

	/* Получение описания нашего грида */
	function getGridDescription(gridDescrId) {
		//Получаем объект запроса из описания грида
		var gridDescrRequest = GridWidget.prototype.makeLoadGridDescrReqParams(gridDescrId);
		//Устанавливаем курсор ожидания
		BlockingUtil.wait();
		//BlockingUtil.blockApplication();
		//Делаем запрос на получение описания грида
		return App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, gridDescrRequest, onLoadGridDescrResult, onLoadGridDescrFail, undefined, 4);
	}

	//Функция обратного вызова для получения описания грида
	function onLoadGridDescrResult(resultXml) {
		//Снимаем курсор ожидания
		BlockingUtil.ready();
		//BlockingUtil.unblockApplication();
		if (resultXml) {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er != "")
				App.errorReport(gis_gridwidget_3, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_1'});
			else {
				if ($('#' + widgetElementId).length > 0) {
					//Получаем из описания грида необходимые нам переменные и структуру грида
					parseGridDescription(resultXml);
				} else {
					//Иначе это означает, что мы уже закрыли грид до того как пришло его описание
				}
			}
		}
	}

	//Функция обратного вызова для получения описания грида
	function onLoadGridDescrFail(resultXml) {
		//Снимаем курсор ожидания
		BlockingUtil.ready();
		//BlockingUtil.unblockApplication();
		App.errorReport(gis_gridwidget_3, resultXml.toString(), undefined, {filename:gis_filename_243, functionname:'gis_filename_243_2'});
	}

	// Вызов всех необходимых для виджета грида функций
	function callWidgetGridFunctions(layerId) {
		try {
			/*Получаем список фильтров для подстановки в запрос данных
			 Если параметр в массиве params один и это layer - это первоначальный запрос на передачу в грид данных фильтрации,
			 Иначе это вызов из грида фильтрации на карте*/
			var layerObj = {name: 'layer', value: layerId};
			var params = [layerObj];
			//Сохраняем функцию для приема ответа в App.callbackFilter (таким образом получим результат в текущий грид)
			ExternalInteraction.callbackFilter = callbackFilterFnc;
			// Теперь вызываем функцию для начала получения фильтра из виджета карты
			var filterRes = callbackFunction(widgetElementId, 'callbackFilter', params); //ExternalInteraction.callbackFunction(widgetElementId, 'callbackFilter', params);//
			if (filterRes === 0) {
				App.errorReport(gis_gridwidget_5, filterRes, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_3'});
			}
		}
		catch (e) { // Вызов функции не сработал
			App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_4'});
		}
	}

	// Функция обратного вызова для получения результата фильтра верхнего уровня.
	// Называется тоже callbackFilter, 2 параметра - params (массив) и winId (строка).
	function callbackFilterFnc(params) {
		try {
			for (var j = 0; j < params.length; j++) {
				var curParam = params[j];
				if (!curParam.hasOwnProperty('name')) continue;

				var newFilters = [];
				var curFilters;
				switch (curParam['name']) {
					case 'filter':
					case 'roughFilter':
						curFilters = curParam['value'].split('|');
						for (var i = 0; i < curFilters.length; i++) {
							var nameValArr = curFilters[i].split(':');
							if (nameValArr && nameValArr.length >= 2) {
								//для кадастровых районов вида "1:23:23.."
								var nameVal = nameValArr[0];
								nameValArr.splice(0,1);
								var newFilterObj = { name: nameVal, value: nameValArr.join(':') };
								newFilters.push(newFilterObj);
							}
						}

						if (curParam['name'] == 'filter') {
							//Переписываем массив фильтров верхнего уровня, из которых формируются запросы
							filters = newFilters;
							that.filters = newFilters;
						}
						else if (curParam['name'] == 'roughFilter') {
							//Переписываем массив фильтров среднего уровня, из которых формируются запросы
							roughFilters = newFilters;
						}
						break;
				}
			}
		}
		catch (e) { // Вызов функции не сработал
			App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_5'});
		}

		//объединяем верхние фильтры с фильтрами, которые пришли в грид извне
		for(var item in that.filter){
			filters.push({name:item, value: that.filter[item]});
			that.filters.push({name:item, value: that.filter[item]});
		}
	}

	//Парсинг пришедшего описания грида (колонки, запросы и т.д.)
	function parseGridDescription(gridDescription) {
		try {
			if (gridDescription !== undefined && gridDescription !== null) {
				//Получаем описание грида в виде структуры (берем корневой элемент, т.е. grids:Grid)
				//var gridDescriptionXml = ($.parseXML(gridDescription)).firstChild;
				var gridDescriptionXml = $($.parseXML(gridDescription)).find('grids\\:Grid:first-child');//($.parseXML(gridDescription)).firstChild;
				//Создаем пока что пустой грид по его описанию
				createGrid(gridDescriptionXml[0], gridTitle);
			}
		}
		catch (e) { // Распарсить XML не удалось
			App.errorReport(gis_gridwidget_4, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_6'});
		}
	}

	//Установка/снятие доступности групповых кнопок грида в зависимости от атрибута "isenabled" кнопки и выбранных записей
	function setEnableToGroupButtons() {
		try {
			//Получаем количество выделенных в гриде рядов
			var rowindexes = $("#" + jqxGridId).jqxGrid('getselectedrowindexes'); //Если length==0, то не выбран ни 1 ряд
			var isSelected = rowindexes && rowindexes.length > 0;
			//Получаем список групповых кнопок грида
			var groupButtons = $('#gridButtons' + jqxGridId)[0].childNodes;
			for (var i = 0; i < groupButtons.length; i++) {
				var curGroupBtn = groupButtons[i];
				for (var j = 0; j < curGroupBtn.attributes.length; j++) {
					var curAttribute = curGroupBtn.attributes[j];
					if (curAttribute.nodeName=="isenabled") {
						//Обрабатываем атибут доступности согласно выделению в гриде (если == "length" - то доступна если выделен хотя бы 1 объект, иначе всегда доступна)
						if (curAttribute.nodeValue=="false") {
							$(curGroupBtn).jqxButton({ disabled: !isSelected});
						} //Если же кнопка всегда доступна - ничего не делаем, поскольку доступность кнопок меняться не будет
						break;
					}
				}
			}
		} catch (e) {
			//Ничего не делаем
		}
	}

	/* Создание грида по полученному описанию грида */
	function createGrid(gridDescriptionXml, gridTitle) {
		that.gridDescriptionXml = gridDescriptionXml;
		//объект, в который сохраняем описание грида
		var currentGridDescr = {};
		//Получаем id слоя для грида (нужен для получения фильтров)
		var layerId = gridDescriptionXml.getAttribute('layerId');
		layerId = that.setLayerId(layerId);
		//Вызываем функции, необходимые для заполнения переменных виджета
		callWidgetGridFunctions(layerId);
		var i = 0;
		//Менеджер фильтров - хранит загруженные справочники для отображения в гриде и фильтрации
		var gridFilterManager = new FilterManager();
		//промежуточные результаты фильтра, чтобы могли работать с данными, пока загружаются данные
		var filterDataCntPureResponse = undefined;
		var filterDataPureResponse = undefined;
		//Получаем запрос данных для грида
		var dataRequest = gridDescriptionXml.getAttribute('dataRequest');
		if(that.filterMap){
			GridUtil.centerOnMap(layerId, that.parentRoughFilter, dataRequest);
			that.filterMap = false;
		}
		//Флаг редактирования грида
		var isGridEditable = gridDescriptionXml.getAttribute('editable');
		//Начальная сортировака колонок
		var initialSortField = gridDescriptionXml.getAttribute('initialSortField');
		//Количество фиксированных колонок
		var lockedColumnCount = gridDescriptionXml.getAttribute('lockedColumnCount');
		//высота колонки
		var columnVertSize = gridDescriptionXml.getAttribute('headerVertSize');
		//заголовок таблицы около нумерации
		var titleGridColumn = gridDescriptionXml.getAttribute('labelColumn');
		//перечень колонок, которые необходимо скрывать, если "проваливаемся" в дочерний грид
		var hideColumnWhenLabel = gridDescriptionXml.getAttribute('hideColumnWhenLabel');
		//первичный ключ для использования в механизме копипасты
		var primaryKeyField = gridDescriptionXml.getAttribute('primaryKeyField') || 'ID';
		that.primaryKeyField = primaryKeyField;
		var foreignKeyField = gridDescriptionXml.getAttribute('foreignKeyField') || '';
		that.foreignKeyField = (foreignKeyField) ? foreignKeyField.split(','): [];
		//количество записей на страницу
		var pageSize = gridDescriptionXml.getAttribute('pageSize');
		var pageSizeOptions =  [25, 50, 100, 500, 1000, 5000];
		if(pageSize === null || pageSize === ''){
			pageSize = 100;
		}
		else{
			pageSize = parseInt(pageSize);
			//если pageSize нет в массиве pageSizeOptions, то помещаем его в него на соответствующее место
			if(pageSizeOptions.indexOf(pageSize) === -1){
				var inserted = false;
				for(var p = 0; p < pageSizeOptions.length; p++){
					if(pageSize < pageSizeOptions[p]){
						pageSizeOptions.splice( p, 0, pageSize );
						inserted = true;
						break;
					}
				}
				if(!inserted)
					pageSizeOptions.push(pageSize);
			}
		}

		//Дополнительный запрос для экспорта в Excel - если есть, используем его для группового экспорта
		var excelDataRequest = gridDescriptionXml.getAttribute('excelDataRequest');
		if (excelDataRequest==undefined || excelDataRequest==null || excelDataRequest=='') excelDataRequest = dataRequest;
		//Дополнительное ограничение числа записей для экспорта в Excel - если есть, используем его вместо ограничения из конфига
		var excelMaxExport = gridDescriptionXml.getAttribute('excelMaxExport');
		//колонки грида
		var gridColumns = [];

		//Колонки с маппингом данных (для dataAdapter)
		var dataFields = [];
		//Получаем описание групповых кнопок грида
		var descrGroupButtons = gridDescriptionXml.getElementsByTagName("picPutton:GridButton");
		if (descrGroupButtons.length == 0) {
			descrGroupButtons = gridDescriptionXml.getElementsByTagName("GridButton");
		}
		//Получаем все имеющиеся описания колонок
		var descrColumns = gridDescriptionXml.getElementsByTagName("columns:GridColumn");
		if (descrColumns.length == 0) {
			descrColumns = gridDescriptionXml.getElementsByTagName("GridColumn");
		}
		//рендерер выбора грида
		var listChooserRenderer = function listChooserRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
				//В данном случае используем columnfield для определения номера колонки, которая рендерится
				if (columnfield < columns.length && columns[columnfield].colItemRendererParams) {
					var listRendererParams = columns[columnfield].colItemListRendererParams;
					var rendererParams = columns[columnfield]['colItemRendererParams'];
					var paramsObj = {
						path: '', eventname: '', tooltip: '', request: '', task: '', layerid: '', gridid: '', templatename: '',
						ext_data_id: '', opennewwnd: 'false', width: '', height: '', syncmap: '', paneltitle: '',
						classname:'',
						columns:'',/*перечень колонок, которые будут использоваться в качестве верхнего фильтра при открытиии нового грида */
						filter:'',/*фильтр для "проваливания в дочерний грид"*/
					}; //Объект для доступа к параметрам рендерера по их имени
					for (var k = 0; k < rendererParams.length; k++) {
						var paramName = rendererParams[k]['name'].toLowerCase(); //Обязательно переводим в нижний регистр!
						var paramValue = rendererParams[k]['value'];
						paramsObj[paramName] = paramValue;
					}
					var imageBtnHtml = '';
					if(paramsObj['text']){
						//Сохраняем в атрибуты кнопки все необходимые значения (path, eventName, toolTip, layerId, templateName, ext_data_id)
						imageBtnHtml = '<div class="grid-cell-style"><input type="submit" onClick="GridWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')" '
							+' style="padding: 0;'+'" class="'+paramsObj["classname"]+'" descrcolumns="'+paramsObj["columns"]+'"  value="'+paramsObj["text"]+'" title="'+paramsObj["tooltip"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" syncmap="'+paramsObj["syncmap"]+'" task="'+paramsObj["task"]+'" opennewwnd="'+paramsObj["opennewwnd"]+'"  paneltitle="'+paramsObj["paneltitle"]+'" openwndwidth="'+paramsObj["width"]+'" openwndheight="'
							+paramsObj["height"]+'" gridid="'+paramsObj["gridid"]+'"  layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'" request="'+paramsObj["request"]+'" '
							+' ext_data_id="'+paramsObj["ext_data_id"]+'"  listrendererparams="'+listRendererParams+'"  filterparams="'+paramsObj["filterparams"]+'" /></div>';
					}
					else{
						imageBtnHtml = '<div class="grid-cell-style"><input type="submit" onClick="GridWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')"  class="gridButton" '
							+' style="padding: 0;'+" background-image: url('./"+paramsObj["path"]+"');"+'"  descrcolumns="'+paramsObj["columns"]+'"  value=" " title="'+paramsObj["tooltip"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" syncmap="'+paramsObj["syncmap"]+'" task="'+paramsObj["task"]+'" opennewwnd="'+paramsObj["opennewwnd"]+'"  paneltitle="'+paramsObj["paneltitle"]+'" openwndwidth="'+paramsObj["width"]+'" openwndheight="'
							+paramsObj["height"]+'" gridid="'+paramsObj["gridid"]+'"  layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'" request="'+paramsObj["request"]+'" '
							+' ext_data_id="'+paramsObj["ext_data_id"]+'"  listrendererparams="'+listRendererParams+'"  filterparams="'+paramsObj["filterparams"]+'" /></div>';
					}
					return imageBtnHtml;
				}
			} catch (e) {}
			return ''; //не можем отрендерить как картинку
		}
		//Рендерер кнопки-иконки
		var imageRenderer = function imageRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
				//В данном случае используем columnfield для определения номера колонки, которая рендерится
				if (columnfield < columns.length && columns[columnfield].hasOwnProperty('colItemRendererParams')) {
					var rendererParams = columns[columnfield]['colItemRendererParams'];
					var paramsObj = {
						path: '', eventname: '', tooltip: '', request: '', task: '', layerid: '', gridid: '', templatename: '',
						ext_data_id: '', opennewwnd: 'false', width: '', height: '', syncmap: '', paneltitle: '',
						classname:'',
						columns:''/*перечень колонок, которые будут использоваться в качестве верхнего фильтра при открытиии нового грида */,
					}; //Объект для доступа к параметрам рендерера по их имени
					for (var k = 0; k < rendererParams.length; k++) {
						var paramName = rendererParams[k]['name'].toLowerCase(); //Обязательно переводим в нижний регистр!
						var paramValue = rendererParams[k]['value'];
						paramsObj[paramName] = paramValue;
					}
					if(!paramsObj["paneltitle"])
						paramsObj["paneltitle"] = '';
					var imageBtnHtml = '';
					if(paramsObj['text']){
						//Сохраняем в атрибуты кнопки все необходимые значения (path, eventName, toolTip, layerId, templateName, ext_data_id)
						imageBtnHtml = '<div class="grid-cell-style"><input type="submit" onClick="GridWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')" '
							+' style="padding: 0;'+'" class="'+paramsObj["classname"]+'" descrcolumns="'+paramsObj["columns"]+'"  value="'+paramsObj["text"]+'" title="'+paramsObj["tooltip"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" syncmap="'+paramsObj["syncmap"]+'" task="'+paramsObj["task"]+'" opennewwnd="'+paramsObj["opennewwnd"]+'"  paneltitle="'+paramsObj["paneltitle"]+'" openwndwidth="'+paramsObj["width"]+'" openwndheight="'
							+paramsObj["height"]+'" gridid="'+paramsObj["gridid"]+'"  layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'" request="'+paramsObj["request"]+'" '
							+' ext_data_id="'+paramsObj["ext_data_id"]+'"/></div>';
					}
					else{
						//Сохраняем в атрибуты кнопки все необходимые значения (path, eventName, toolTip, layerId, templateName, ext_data_id)
						imageBtnHtml = '<div class="grid-cell-style"><input type="submit" onClick="GridWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')" class="gridButton"'
							+' style="padding: 0;'+" background-image: url('./"+paramsObj["path"]+"');"+'" value=" " title="'+paramsObj["tooltip"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" syncmap="'+paramsObj["syncmap"]+'" task="'+paramsObj["task"]+'" opennewwnd="'+paramsObj["opennewwnd"]+'"  paneltitle="'+paramsObj["paneltitle"]+'"  openwndwidth="'+paramsObj["width"]+'" openwndheight="'
							+paramsObj["height"]+'"  layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'" data-request="'+paramsObj["request"]+'" request="'+paramsObj["request"]+'"'
							+' ext_data_id="'+paramsObj["ext_data_id"]+'"/></div>';
					}
					return imageBtnHtml;
				}
			} catch (e) {}
			return ''; //не можем отрендерить как картинку
		};

		//Рендерер символьной строки
		var stringRenderer = function stringRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var colorRowColumn = '';
				var colorRow = undefined;
				var noPaddingsHtml = $(defaulthtml);
				noPaddingsHtml.addClass("grid-cell-style");
				var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', row);
				gridItem = GridUtil.getFullRowDataById({id: jqxGridId}, gridItem);
				var selectedColorValidation = {critical: -999999};
				for(var item in that.colorRowValidations){
					if(that.colorRowValidations[item].selected){
						//находим элемент в текущей строке грида
						var gridItemValueNumber = parseFloat(gridItem[item]);
						var gridItemValueString = gridItem[item];
						that.colorRowValidations[item].array.forEach(function (curValue, index, array) {
							if(curValue){
								if(curValue.type === 'string'){
									if(gridItemValueString && gridItemValueString === curValue.min && gridItemValueString === curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
								if(curValue.type === 'number'){
									if(!isNaN(gridItemValueNumber) && gridItemValueNumber >= curValue.min && gridItemValueNumber <= curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
							}
						});
					}
				}
				if(selectedColorValidation.critical !== -999999)
					noPaddingsHtml.css('background', selectedColorValidation.color);
				//22.10.21 доп. проверка для дат из внешних источников, если данные пришли в миллисекундах
				if(columnproperties && columnproperties.columntype === 'date'){
					//upd. 03.11.21 проверка случая в задаче су тс тпа, когда из sqlite проходит значение даты вместо NULL значение 0
					if(value === '0'){
						var resultHtml = noPaddingsHtml[0].outerHTML;
						resultHtml = resultHtml.replace(">"+value+"<", "><");
						return resultHtml;
					}
					if(value && (''+value).length > 10 && !isNaN(Number(value))){
						var newValue = new Date(Number(value)).format('dd.mm.yyyy');
						var resultHtml = noPaddingsHtml[0].outerHTML;
						resultHtml = resultHtml.replace(">"+value+"<", ">"+newValue+"<");
						return resultHtml;
					}

					/*var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
					//В данном случае используем columnfield для определения номера колонки, которая рендерится
					for(var col = 0; col < columns.length; col++){
						if(columns[col].datafield === columnfield && columns[col].colItemRendererParams && columns[col].colItemRendererParams.length > 0){
							for(var colI = 0; colI < columns[col].colItemRendererParams.length; colI ++){
								if(columns[col].colItemRendererParams[colI].name === 'dateFormat' && columns[col].colItemRendererParams[colI].value === 'bigint'){

								}
							}
						}
					}*/
				}
				//17.02.20 Добавлено условие для дат, т.к. нет отдельного обработчика DateRenderer
				//если есть текст "T00:00:00" - отбрасываем правую часть
				//Возвращаем элемент с нужными стилями
				var returnStr = noPaddingsHtml[0].outerHTML;
				if(value && value.indexOf("T00:00:00") !== -1)
					returnStr = returnStr.replace(value.substring(value.indexOf("T00:00:00")),'');
				return returnStr;
			} catch (e) {}
			return ''; //не можем отрендерить
		};

		//Рендерер чисел с округлением до числа знаков после запятой, указанного в параметре buffer рендерера (2 по дефолту)
		var numberRenderer = function numberRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var noPaddingsHtml = $(defaulthtml);
				noPaddingsHtml.addClass("grid-cell-style");
				//Возвращаем элемент с нужными стилями
				var resultHtml = undefined;
				var newValue = value;
				if(newValue && newValue.indexOf(',') !== -1)
					newValue = newValue.replace(',','.');
				var numberVal = parseFloat(newValue);
				var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', row);
				gridItem = GridUtil.getFullRowDataById({id: jqxGridId}, gridItem);
				var selectedColorValidation = {critical: -999999};
				for(var item in that.colorRowValidations){
					if(that.colorRowValidations[item].selected){
						//находим элемент в текущей строке грида
						var gridItemValueNumber = parseFloat(gridItem[item]);
						var gridItemValueString = gridItem[item];
						that.colorRowValidations[item].array.forEach(function (curValue, index, array) {
							if(curValue){
								if(curValue.type === 'string'){
									if(gridItemValueString && gridItemValueString === curValue.min && gridItemValueString === curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
								if(curValue.type === 'number'){
									if(!isNaN(gridItemValueNumber) && gridItemValueNumber >= curValue.min && gridItemValueNumber <= curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
							}
						});
					}
				}
				if(selectedColorValidation.critical !== -999999)
					noPaddingsHtml.css('background', selectedColorValidation.color);
				if (!isNaN(numberVal)) {
					//Обрезаем число до 6 знаков после запятой (если в рендерере не указан format=<число>)
					var numPrecision = 6;
					var indexColumn;
					//В данном случае используем columnfield для определения номера колонки, которая рендерится
					for(var i=0; i<gridDescription.columns.length; ++i){
						if(gridDescription.columns[i]['datafield'] === columnfield){
							indexColumn = i;
							break;
						}
					}
					if (gridDescription.columns[indexColumn].hasOwnProperty('colItemRendererParams')) {
						for(var i=0; i<gridDescription.columns[indexColumn]['colItemRendererParams'].length; ++i) {
							var rendererParams = gridDescription.columns[indexColumn]['colItemRendererParams'][i];
							if (rendererParams && rendererParams.hasOwnProperty('name') && (rendererParams['name'] === 'format') && rendererParams.hasOwnProperty('value') && !isNaN(parseInt(rendererParams['value']))){
								numPrecision = parseInt(rendererParams['value']);
							}
						}
					}
					var numVal = parseFloat(numberVal.toFixed(numPrecision));
					var numValStr = (isNaN(numVal))?'':numVal.toString();
					numValStr = numValStr.replace(/\.00$/,"");
					resultHtml = noPaddingsHtml[0].outerHTML;
					resultHtml = resultHtml.replace(">"+value+"<", ">"+numValStr+"<");
					//value = numValStr;
					return resultHtml;
				}
				resultHtml = noPaddingsHtml[0].outerHTML;
				//Возвращаем элемент с нужными стилями
				return resultHtml;
			} catch (e) {}
			return ''; //не можем отрендерить
		};

		var booleanRenderer = function booleanRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var noPaddingsHtml = $(defaulthtml);
				noPaddingsHtml.addClass("grid-cell-style");
				//Возвращаем элемент с нужными стилями
				var resultHtml = undefined;
				var booleanVal = (value === '0')? gis_core_5: gis_core_4;
				resultHtml = noPaddingsHtml[0].outerHTML;
				resultHtml = resultHtml.replace(">"+value+"<", ">"+booleanVal+"<");
				return resultHtml;
			} catch (e) {}
			return ''; //не можем отрендерить
		};

		//Добавляем особый рендерер, который будет забирать из FilterManager нужное значение для отображения
		var filterCellRenderer = function filterCellRenderer(index, datafield, value, defaulthtml, column, rowdata) {
			try {
				var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
				var noPaddingsHtml = $(defaulthtml);
				noPaddingsHtml.addClass("grid-cell-style");
				var filterData = [];
				var curFilterRequestiId;
				for (i = 0; i < columns.length; i++) {
					var curCol = columns[i];
					if (curCol.datafield == datafield) {
						curFilterRequestiId = curCol.filterrequestid;
						filterData = gridFilterManager.getArrayData(curCol.filterrequestid);
						break;
					}
				}

				var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', index);
				gridItem = GridUtil.getFullRowDataById({id: jqxGridId}, gridItem);
				var selectedColorValidation = {critical: -999999};
				for(var item in that.colorRowValidations){
					if(that.colorRowValidations[item].selected){
						//находим элемент в текущей строке грида
						var gridItemValueNumber = parseFloat(gridItem[item]);
						var gridItemValueString = gridItem[item];
						that.colorRowValidations[item].array.forEach(function (curValue, index, array) {
							if(curValue){
								if(curValue.type === 'string'){
									if(gridItemValueString && gridItemValueString === curValue.min && gridItemValueString === curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
								if(curValue.type === 'number'){
									if(!isNaN(gridItemValueNumber) && gridItemValueNumber >= curValue.min && gridItemValueNumber <= curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
							}
						});
					}
				}
				if(selectedColorValidation.critical !== -999999)
					noPaddingsHtml.css('background', selectedColorValidation.color);
				defaulthtml = noPaddingsHtml[0].outerHTML;
				var curDescr = gridFilterManager.EMPTY_NAME;
				//Ищем в полученном справочнике текущее значение и забираем его описание
				if (filterData!=null && filterData.hasOwnProperty('codehash') && filterData.codehash[value]!=undefined && filterData.codehash[value]!=null) {
					curDescr = filterData.codehash[value];
				} else {
					/*if(filterData == 'loading') {
						var guidErrorDict = 'cell_guid_'+App.generateUUID();
						console.log(guidErrorDict)
						defaulthtml = defaulthtml.replace('class="grid-cell-style"', 'class="grid-cell-style ' + guidErrorDict + '"');
						return defaulthtml.replace(">" + value + "<", "><");
					}*/
					if(value == '')
						curDescr = value;
					else{
						//Иначе однократно сообщаем, что такого значения в справочнике нет
						if (that.notFoundCodeHash==undefined || !that.notFoundCodeHash.hasOwnProperty(datafield) || !that.notFoundCodeHash[datafield].hasOwnProperty(value)) {
							if (that.notFoundCodeHash==undefined) that.notFoundCodeHash = {};
							if (!that.notFoundCodeHash.hasOwnProperty(datafield)) that.notFoundCodeHash[datafield] = {};
							that.notFoundCodeHash[datafield][value] = value;
							//Показываем однократное сообщение об ошибке, что для этого значения не найдено значение справочника
							if(WidgetMap !== undefined && WidgetMap.getShowErrorInGridDictationary() == false){}//если выставлен флаг, то не показываем сообения
							else{
								var guidErrorDict = 'cell_guid_'+App.generateUUID();
								//console.log(guidErrorDict)
								defaulthtml = defaulthtml.replace('class="grid-cell-style"', 'class="grid-cell-style ' + guidErrorDict + '"');
								var confirm = App.infoDialog(gis_gridwidget_142, guidErrorDict);
								gridFilterManager.reloadDictationary(curCol.filterrequestid, function(arr){
									filterData = gridFilterManager.getArrayData(curCol.filterrequestid);
									if(filterData && filterData.codehash && filterData.codehash[value]!=undefined && filterData.codehash[value]!=null){
										gridElem.jqxGrid('setcellvalue', index, datafield, value);
									}
									App.destroyDialog(guidErrorDict);
								});
							}
						}
					}
				}
				//Заменяем подстроку значения включая > и <, чтобы не заменить где-то кроме самой ячейки
				if(WidgetMap !== undefined && WidgetMap.getShowErrorInGridDictationary() == false && curDescr == gridFilterManager.EMPTY_NAME)
					return defaulthtml.replace(">"+value+"<", ">"+curDescr+":"+value+"<");
				return defaulthtml.replace(">"+value+"<", ">"+curDescr+"<");
			} catch (e) {}
			return ''; //не можем отрендерить
		};

		var filterCount = [];//количество справочников

		for (i = 0; i < descrColumns.length; i++) {
			var curColumn = descrColumns[i];
			//Определяем тип колонки и что именно она будет рендерить по атрибуту itemRenderer
			var listRendererParams = [];
			if (curColumn === undefined || !curColumn || !curColumn.hasAttribute('itemRenderer')){ } //continue;
			else{
				//Обрабатываем атрибут itemRenderer
				var colItemRendererSrc = curColumn.getAttribute('itemRenderer');

				var colItemRendererArr = colItemRendererSrc.split('?'); //В строке itemRenderer тип рендерера отделяется от параметров символом '?';
				var colItemRendererType = 'ru.corelight.view.renderer.StringRenderer'; //по-умолчанию - обычная строка
				var colItemRendererParams = []; //по-умолчанию параметров у рендерера нет
				if (colItemRendererArr && colItemRendererArr.length > 0) {
					//Сохраняем тип рендерера колонки
					colItemRendererType = colItemRendererArr[0];
					//Если у рендерера есть параметры - парсим их в массив параметров colItemRendererParams
					if (colItemRendererArr.length > 1) {
						var paramsArr = colItemRendererArr[1].split(';'); // параметры всегда содержатся во 2 элементе массива и разделяются символом ';'
						for (var j = 0; j < paramsArr.length; j++) {
							var nameValArr = paramsArr[j].split('='); //имя параметра отделяется от его значения символом '='
							if (nameValArr.length > 1) {
								var paramObj = {name: nameValArr[0], value: nameValArr[1]};
								colItemRendererParams.push(paramObj);
							}
						}
					}
					if(colItemRendererType === 'ru.corelight.view.renderer.ImageListRenderer'){
						for (var atr=0; atr<curColumn.attributes.length; atr++) {
							if(curColumn.attributes[atr].name.indexOf('rendererParams') !== -1)
								listRendererParams.push(curColumn.attributes[atr].value);
							if(curColumn.attributes[atr].name === 'filter'){
								//прокидываем параметр filter
								colItemRendererParams.push({name: 'filterparams', value: curColumn.attributes[atr].value});
							}
						}

					}
				}
			}
			//Получаем из атрибутов параметры для маппинга и описания очередной колонки грида
			//В dataField для колонок, которые являются кнопками, сохраняем порядковый номер колонки, иначе просто сохраняем dataField
			var colDataField = curColumn.hasAttribute('dataField') ? curColumn.getAttribute('dataField') : i; //dataField ОБЯЗАТЕЛЬНО должно быть уникальным !
			var colDataFieldSynonym = curColumn.hasAttribute('dataFieldSynonym') ? curColumn.getAttribute('dataFieldSynonym') : undefined; //dataField ОБЯЗАТЕЛЬНО должно быть уникальным !
			var colHeaderText = curColumn.hasAttribute('headerText') ? curColumn.getAttribute('headerText') : '';
			var colWidth = curColumn.hasAttribute('width') ? curColumn.getAttribute('width') : 0; //Если ширина не указана то дефолтная будет = 0
			var colEditable = curColumn.hasAttribute('editable') && curColumn.getAttribute('editable') === 'true'; //Если ширина не указана то дефолтная будет = 0

			//проверяем наличие условий расцветки ячеек
			var colorValidations = curColumn.getElementsByTagName("colorValidation");
			if(colorValidations !== undefined && colorValidations.length > 0 ) {
				that.colorValidations[colDataField] = {selected: false, descr: colHeaderText, array:[]};
				that.colorRowValidations[colDataField] = {selected: false, descr: colHeaderText, array:[]};
				for (var v = 0; v < colorValidations.length; v++) {
					var cvItem = colorValidations[v];
					var cvMin = cvItem.getAttribute('min');
					var cvMax = cvItem.getAttribute('max');
					var cvColor = cvItem.getAttribute('color');
					var cvPreload = cvItem.getAttribute('preload') === 'true';
					var cvCriticalLevel = parseInt(cvItem.getAttribute('critical'));
					var cvMode = cvItem.getAttribute('mode') === 'row' ? 'row' : 'cell';
					var cvType = cvItem.getAttribute('type') === 'string' ? 'string' : 'number';
					if (cvMin !== null && cvMax !== null && cvColor !== '') {
						if(cvType === 'number'){
							cvMin = (cvMin === '-infinity') ? Number.NEGATIVE_INFINITY : parseFloat(cvMin);
							cvMax = (cvMax === 'infinity') ? Number.POSITIVE_INFINITY : parseFloat(cvMax);
						}
					}
					var colObj = {
						mode: cvMode,
						min: cvMin,
						max: cvMax,
						type: cvType,
						color: '#' + cvColor,
						critical: cvCriticalLevel,
						preload: cvPreload
					};
					if(cvMode === 'cell') {
						that.colorValidations[colDataField].array.push(colObj);
						if(cvPreload)
							that.colorValidations[colDataField].selected = true;
					}
					else{
						that.colorRowValidations[colDataField].array.push(colObj);
						if(cvPreload)
							that.colorRowValidations[colDataField].selected = true;
					}
				}
			}

			//Отдельные атрибуты для фильтрации
			var colFilterRequestId = curColumn.hasAttribute('filterRequestId') ? curColumn.getAttribute('filterRequestId') : undefined; //Запрос справочника значений
			var colFilterComparisionType = curColumn.hasAttribute('filterComparisionType') ? curColumn.getAttribute('filterComparisionType') : undefined; //Тип фильтра
			//TODO костыль. Обработка случая фильтра с большим количеством записей(распределители)
			var colFilterInfinite = curColumn.hasAttribute('infinite') ? curColumn.getAttribute('infinite') === 'true' : false; //
			var colSortField = curColumn.hasAttribute('sortField') ? curColumn.getAttribute('sortField') : undefined; //Поле для сортировки справочника
			var colSortable = colFilterComparisionType !== undefined;

			//Скрытая ли колонка
			var colHidden = curColumn.hasAttribute('hidden') ? curColumn.getAttribute('hidden') === 'true' : false; //Запрос справочника значений
			// флаг, что грид показывается весь. Если показываем шапку - значит можно скрывать колонку(если она описана в )
			if(!that.ignoreLabelColumn){
				if(hideColumnWhenLabel && hideColumnWhenLabel.split(',').indexOf(colDataField) !== -1)
					colHidden = true;
			}
			//Маппинг - для маппинга xml-атрибута заключаем в квадратные скобки, для массива - не нужно
			/*var colMapping = '['+curColumn.getAttribute('dataField')+']';*/
			var colMapping = curColumn.hasAttribute('dataField') ? curColumn.getAttribute('dataField') : i;
			//Пока что все считаем строкой, в будущем нужно определять тип колонки по itemRenderer или по filterComparisionType
			var colType = 'string';

			//pinned - зафиксированная колонка или нет
			var colIsPinned = i < lockedColumnCount-1;

			var columnrenderer = function(value, align, columnsheight) {
				var splitted = value.split('\\n');
				var newVal = splitted.join('<br/>');

				return '<div style="text-align: left; margin-top: 2px;">' + newVal + '</div>';
			};
			//Объект с описанием колонки
			var columnObj = {text: colHeaderText,
				editable: colEditable,
				datafield: colDataField, width: colWidth, minwidth: 0, pinned: colIsPinned, hidden: colHidden,
				filterrequestid: colFilterRequestId, filtercomparisiontype: colFilterComparisionType, filterinfinite: colFilterInfinite,
				sortfield: colSortField, sortable: colSortable,
			};
			//Дефолтный рендерер - убираем избыточные отступы и выдаем просто текст
			columnObj['cellsrenderer'] = stringRenderer;
			columnObj['columntype'] = 'string';
			if(colDataFieldSynonym)
				columnObj['datafieldsynonym'] = colDataFieldSynonym;

			//Если тип рендерера - 'ru.corelight.view.renderer.NumberRenderer', меняем на численный с точностью (параметр format, 2 знака после запятой по дефолту)
			if (colItemRendererType==='ru.corelight.view.renderer.NumberRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['cellsrenderer'] = numberRenderer;
				columnObj['columntype'] = 'stringnumber';
			}
			if (colItemRendererType==='ru.corelight.view.renderer.BooleanRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['cellsrenderer'] = booleanRenderer;
				columnObj['columntype'] = 'boolean';
			}
			if (colItemRendererType==='ru.corelight.view.renderer.StringRenderer' || colItemRendererType.indexOf('StringRenderer') !== -1) {
				if(colDataField === 'RWN')
					columnObj['editable'] = false;
			}
			// тип рендерера - для показа окна с выбором списков, в которые погружаемся
			if (colItemRendererType==='ru.corelight.view.renderer.ImageListRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['colItemListRendererParams'] = listRendererParams.join('|');// добавляем самостоятельные параметры
				if (columnObj['width'] < 25) {
					columnObj['width'] = 25;
				}
				columnObj['cellsrenderer'] = listChooserRenderer;
				columnObj['editable'] = false;
				columnObj['columntype'] = 'image';
			}
			//Если тип рендерера = 'ru.corelight.view.renderer.ImageRenderer', добавляем рендерер для колонки с кнопкой
			if (colItemRendererType==='ru.corelight.view.renderer.ImageRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				if (columnObj['width'] < 25) {
					columnObj['width'] = 25;
				}
				columnObj['cellsrenderer'] = imageRenderer;
				columnObj['editable'] = false;
				columnObj['columntype'] = 'image';
			}
			//Если тип рендерера - 'ru.corelight.view.renderer.DateRenderer', убираем возможность редактирования этой колонки
			if (colItemRendererType==='ru.corelight.view.renderer.DateRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['columntype'] = 'date';
				//Тип даты(либо в миллисекунда, либо текстовое представление)
				var colDateFormat = curColumn.hasAttribute('dateFormat') ? curColumn.getAttribute('dateFormat') : 'text';
				columnObj['dateformat'] = colDateFormat;
			}
			//Объект маппинга данных
			var dataFieldObj = {name: colDataField, map: colMapping, type: colType};
			if(colDataFieldSynonym)
				dataFieldObj['synonym'] = colDataFieldSynonym;

			//Если есть свойство filterRequestId - добавляем displayfield и запрашиваем значения справочника (они должны быть доступны, когда грид загрузится)
			if (colFilterRequestId !== undefined) {
				//Добавляем особый рендерер, который будет забирать из FilterManager нужное значение для отображения
				columnObj['cellsrenderer'] = filterCellRenderer;
				columnObj['columntype'] = 'filter';
				//Сразу при создании колонки запрашиваем данные справочника
				//var curFilterData = gridFilterManager.getArrayData(colFilterRequestId);
				if(filterCount.indexOf(colFilterRequestId)==-1)
					filterCount.push(colFilterRequestId);
			}

			columnObj['renderer'] = columnrenderer;
			//Добавляем колонку
			that.columns.push(columnObj);
			/*if(columnObj.hidden === true && columnObj.datafield !== 'ID')
				continue;*/
			gridColumns.push(columnObj);
			//Добавляем поля данных (маппинг)
			dataFields.push(dataFieldObj);
		}
		loadingFilterCount = filterCount.length;
		for(var a in filterCount){
			gridFilterManager.getArrayData(filterCount[a], onFilterLoadedCallback);
		}

		//Функция формирует строку сортировки из массива
		var getSortStringFromArr = function getSortStringFromArr(sortArr) {
			var sortStr = "";
			var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
			if (sortArr && sortArr!==undefined && sortArr.length>0) {
				var tmpSortArr = [];
				for (var i = 0; i < sortArr.length; i++) {
					var sortinformation = sortArr[i];
					//Теперь если мы добавляем сортировку и этот элемент уже был - меняем его (или убираем если сортировка отменена), иначе просто добавляем
					if (sortinformation.sortdirection.ascending || sortinformation.sortdirection.descending) {
						for (var j = 0; j < currentGridDescr.gridColumns.length; j++) {
							//Ищем среди колонок ту, по которой сортируем и забираем значение из ее свойства sortfield
							//Если такого свойста у колонки нет, сортируем по datafield
							var curGridCol = currentGridDescr.gridColumns[j];
							if (curGridCol.hasOwnProperty('datafield') && curGridCol.datafield==sortinformation.sortcolumn) {
								var tmpSortStr = curGridCol.hasOwnProperty('sortfield') && curGridCol.sortfield!=undefined ? curGridCol.sortfield : curGridCol.datafield;
								if (sortinformation.sortdirection.descending)
									tmpSortStr += " DESC";
								tmpSortArr.push(tmpSortStr);
							}
						}
					}
				}
				//Собираем получившийся массив в строку, разделенную запятой
				sortStr = tmpSortArr.join(",");
			}
			else{//иначе проходим по колонкам в gridDescription, ищем соответствующие initialSortField поля сортировки
				if(columns != undefined){
					if(initialSortField!=null){
						var i=0;
						var sortArr = [];
						var isf = initialSortField.split(',');

						for(i; i<isf.length;i++){
							var j=0;
							var found = false;
							for(j; j<columns.length;j++){
								if(isf[i] == columns[j].datafield && columns[j].sortfield!=undefined && columns[j].sortfield!=''){
									sortArr.push(columns[j].sortfield);
									found = true;
									break;
								}
							}
							if(!found)
								sortArr.push(isf[i]);
						}
						sortStr = sortArr.join(',');
					}
				}
			}
			//по-умолчанию возвращаем первоначальный порядок сортировки
			if (sortStr=="") sortStr = initialSortField;
			return sortStr;
		};
		//Описание групповых кнопок в тулбаре
		var gridToolbarGroupButtons = [];
		//Сохраняем описание грида
		currentGridDescr = {
			layerId: layerId,
			colorRowValidations: that.colorRowValidations,
			colorValidations: that.colorValidations,
			colorRowSelectType: 0,
			maxCriticalColor: undefined,
			minCriticalColor: undefined,//тип выделения ячеек после цветового анализа
			dataRequest: dataRequest,
			initialSortField: initialSortField,
			gridColumns: gridColumns,
			dataFields: dataFields,
			descrGroupButtons: descrGroupButtons,
			layerManager: layerManagerInst,
			gridFilterManager: gridFilterManager,
			topFilter: that.filters,
			roughFilter: roughFilters,
			currentFilter: [],
			currentSort: [],
			selecting: false,
			centering: false,
			propPanelWidth: 800,
			propPanelHeight: 280,
			excelDataRequest: excelDataRequest,
			excelMaxExport: excelMaxExport
		};
		GlobalGridDescr[jqxGridId] = currentGridDescr;
		for (i = 0; i < descrGroupButtons.length; i++) {
			var curButton = descrGroupButtons[i];
			//Получаем из атрибутов параметры для описания очередной групповой кнопки грида
			//В исходных путях присутствует ненужное указание выхода на директорию из поддиректории '../../' - убираем его (путь формируем от корня сайта)
			var btnSource = curButton.hasAttribute('source') ? curButton.getAttribute('source').replace('../../','') : '';
			var btnTooltip = curButton.hasAttribute('tooltip') ? curButton.getAttribute('tooltip') : '';
			var btnClickEvent = curButton.hasAttribute('clickEvent') ? curButton.getAttribute('clickEvent') : '';
			//Параметр isEnabled принимает значения: 'true' или 'null' - всегда доступна, иначе (в т.ч. если нет этого параметра) - доступна если выбрана хотя бы 1 запись
			var btnIsEnabled = curButton.hasAttribute('isEnabled') && (curButton.getAttribute('isEnabled')=='true' || curButton.getAttribute('isEnabled')=='null');
			var btnDisabled = !btnIsEnabled; //По-умолчанию недоступными будут кнопки, доступность которых регулируется выбором записей грида
			var btnSelectedObjects = curButton.hasAttribute('selectedObjects') ? curButton.getAttribute('selectedObjects') : ''; //Не нужно - доступность групповых кнопок регулируется только через isEnabled
			var btnPosition = curButton.hasAttribute('position') ? curButton.getAttribute('position') : 'left'; //Позиция кнопки - в левой панели ('left') или сверху ('top')
			var btnWidth = curButton.hasAttribute('width') ? curButton.getAttribute('width') : '200'; //Ширина кнопки
			var btnHeight = curButton.hasAttribute('height') ? curButton.getAttribute('height') : '27'; //Высота кнопки
			var btnTemplate = curButton.hasAttribute('template') ? curButton.getAttribute('template') : '';
			var btnGridId = curButton.hasAttribute('gridId') ? curButton.getAttribute('gridId') : '';
			var btnSyncMap = curButton.hasAttribute('syncMap') ? curButton.getAttribute('syncMap') : '';
			var btnPanelTitle = curButton.hasAttribute('panelTitle') ? curButton.getAttribute('panelTitle') : '';
			var btnTask = curButton.hasAttribute('task') ? curButton.getAttribute('task') : '';
			var btnOpenNewWnd = curButton.hasAttribute('openNewWnd') ? curButton.getAttribute('openNewWnd') : '';
			var clickEventParams = btnClickEvent.split('?')[1];
			var btnQuery = '';
			if(clickEventParams){
				clickEventParams.split(';').forEach(function(p){
					if(p && p.split('=')[0] === 'request')
						btnQuery = p.split('=')[1]
				});
			}
			btnClickEvent = btnClickEvent.split('?')[0];
			var curButtonHtml = '<input type="submit" onClick="GridWidget.prototype.groupButtonClick(event,'+jqxGridId+')" class="gridGroupButton"'
				+' style="padding: 10px; '+" background-image: url('./"+btnSource+"');"+'" value=" " title="'+btnTooltip+'"'
				+' id="btngroup_'+jqxGridId+'_'+i+'" layerid="'+layerId+'" clickevent="'+btnClickEvent+'"  opennewwnd="'+btnOpenNewWnd+'"  ' +
				'task="'+btnTask+'"  syncmap="'+btnSyncMap+'" paneltitle="'+btnPanelTitle+'" ' +
				'request="'+btnQuery+'"  ' +
				'isenabled="'+btnIsEnabled+'" selectedobjects="'+btnSelectedObjects+'" template="'+btnTemplate+'"  ' +
				'gridid="'+btnGridId+'" />';
			//Добавляем очередную кнопку в панель с групповыми кнопками грида
			if (btnPosition.indexOf('top') !== -1) {
				var btnFloat = (btnPosition.split('|').length > 1 && btnPosition.split('|')[1] === 'right')?' float: right; ':' float: left; ';
				var btnText = curButton.hasAttribute('text') ? curButton.getAttribute('text') : btnTooltip;
				var parentGridId = curButton.hasAttribute('parentGridId') ? curButton.getAttribute('parentGridId') : '';
				if(btnClickEvent === 'showParentGridEvent'){
					if(that.ignoreLabelColumn ){// если самостоятельный грид, то в нем не показываем кнопку "перейни на уровень вверх"
						continue;
					}
				}
				if(btnClickEvent === 'showAllDataEvent'){
					if(that.ignoreLabelColumn ){// если самостоятельный грид, то в нем не показываем кнопку "перейни на уровень вверх"
						continue;
					}
				}

				//Для административных гридов сохраняем кнопки для верхнего тулбара
				var curButtonFullHtml = '<input type="submit" onClick="GridWidget.prototype.groupButtonClick(event,'+jqxGridId+')" class="myButton"'
					+'value="'+btnText+'" title="'+btnTooltip+'" style="display: inline;padding: 0px; '+btnFloat+' white-space: normal;" data-btnwidth="'+btnWidth+'" data-btnheight="'+btnHeight+'"'
					+' id="btngrouptoolbar_'+jqxGridId+'_'+gridToolbarGroupButtons.length+'" request="'+btnQuery+'" layerid="'+layerId+'" opennewwnd="'+btnOpenNewWnd+'"  task="'+btnTask+'" clickevent="'+btnClickEvent+'"  syncmap="'+btnSyncMap+'" isenabled="'+btnIsEnabled+'" selectedobjects="'+btnSelectedObjects+'"' +
					'" gridlayerid="'+gridLayerId+'"  paneltitle="'+btnPanelTitle+'" parentgridid="'+parentGridId+'"/>';
				gridToolbarGroupButtons.push(curButtonFullHtml);
			}
			else {
				$('#gridButtons' + jqxGridId).append(curButtonHtml);
				//Делаем нормальную кнопку, в которую добавляем текущее состояние (доступна или нет изначально)
				$('#btngroup_'+jqxGridId+'_'+i).jqxButton({ theme: 'gis-blueorange', disabled: btnDisabled});
			}
		}
		//Не устанавливаем доступность групповых кнопок, она выставлена правильно при создании кнопок
		/*setEnableToGroupButtons();*/
		//Функция-рендерер тулбара административных гридов
		//TODO перенос из админских панелей
		function admGridRenderToolbar(toolbar) {
			try {
				//Если в тулбаре уже добавлен этот div, 2 раз не добавляем, а также проверяем что кнопки вставляются после постраничности (когда тулбар заполнен чем-то)
				if ($('#btngrouptoolbardiv_'+jqxGridId).length > 0 || toolbar.children().length==0) return;
				var container = $('<div id="btngrouptoolbardiv_'+jqxGridId+'" style="display: inline;margin: 0px; padding-top: 25px;padding-left: 5px; font-size: 14px;"></div>');
				toolbar.append(container);
				for (var ii = 0; ii < gridToolbarGroupButtons.length; ii++) {
					var curGroupBtnInput = gridToolbarGroupButtons[ii];
					container.prepend(curGroupBtnInput);
					var curGroupBtn = $('#btngrouptoolbar_'+jqxGridId+'_'+ii);
					var btnWidth = parseInt(curGroupBtn.attr('data-btnwidth')); //ширина кнопки
					if (btnWidth==undefined || btnWidth==null || isNaN(btnWidth)) btnWidth = 200;
					var btnHeight = parseInt(curGroupBtn.attr('data-btnheight')); //высота кнопки
					if (btnHeight==undefined || btnHeight==null || isNaN(btnHeight)) btnHeight = 27;
					var btnDisabled = false; //curGroupBtn.attr('isenabled')!="true";
					curGroupBtn.jqxButton({ width: btnWidth, height: btnHeight, disabled: btnDisabled});
				}

			} catch (e) {
			}
		}
		//описание грида
		//Сохраняем в gridSource, чтобы подставить в него данные после загрузки
		gridSource = {
			datatype: "text",
			datafields: dataFields,
			formatdata: function (data) {
				//Перед отправкой запроса устанавливаем в него нижний и верхний пределы согласно выбранным границам
				var lowLimit = data.pagenum * data.pagesize + 1;
				var highLimit = (data.pagenum + 1) * data.pagesize;
				that.pageSize = data.pagesize;
				/*var lowLimit = (that.pageCursor - 1) * that.pageSize + 1;
				var highLimit = lowLimit + that.pageCacheSize -1;
				that.pageCursor++;*/
				if(that.parentGridFilter !== undefined && that.parentGridFilter.length > 0){
					gridDescription.source.currentGridDescr.currentFilter = that.parentGridFilter;
					that.parentGridFilter = undefined;
				}
				var bottomFilters = gridDescription.source.currentGridDescr.currentFilter;
				//Текущая сортировка (получаем из массива объектов колонок)
				var gridSortStr = getSortStringFromArr(gridDescription.source.currentGridDescr.currentSort);
				//проброс флага не использовать фильтр
				var ignoreAllFilter = that.ignoreAllFilter;
				that.ignoreAllFilter = false;
				//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
				return GridWidget.prototype.makeLoadDataReqParams(dataRequest, bottomFilters, gridSortStr, lowLimit, highLimit, that.filters, roughFilters, that.parentRoughFilter, that.parentRoughParams, ignoreAllFilter);
			},
			url: Services.processQueryNode
		};
		//Создаем адаптер данных для грида
		var dataAdapterSettings = { contentType: 'application/xml; charset=utf-8',
			type: "POST",
			formatData: function (data) {
				return data;
			},
			beforeSend: function (jqXHR, settings) {
				return null;
			},
			loadError: function (jqXHR, status, error) {
				onLoadGridDataFail(error);
			},

			beforeLoadComplete: function (records) {
				return records;
			},
			loadComplete: function (data) {
				try {
					//Вызываем функцию центровки только если устанавливали в true флаг selecting или centering при фильтрации
					if (data.records && data.records.length > 0
						&& ((gridDescription.source.currentGridDescr.hasOwnProperty('selecting') && gridDescription.source.currentGridDescr.selecting == true)
							|| (gridDescription.source.currentGridDescr.hasOwnProperty('centering') && gridDescription.source.currentGridDescr.centering == true))) {
						var selecting = gridDescription.source.currentGridDescr.selecting;
						var centering = gridDescription.source.currentGridDescr.centering;
						//Затираем значения в gridDescription.source.currentGridDescr, иначе при переключении на следующие записи снова произойдет центровка
						gridDescription.source.currentGridDescr.selecting = false;
						gridDescription.source.currentGridDescr.centering = false;
						//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
						var curLayerObj = layerManagerInst.getLayerByName(layerId);
						if (curLayerObj==undefined || curLayerObj==null)
							return data;
						//Формируем параметры для вызова функции центровки
						var objectsStr = layerId + ":";
						for (i = 0; i < data.records.length; i++) {
							if (!data.records[i].hasOwnProperty("ID")) continue;
							objectsStr += data.records[i]["ID"];
							//К последнему ID сзади запятую не добавляем
							if (i < data.records.length - 1) {
								objectsStr += ",";
							}
						}
					}
					if (data.records && data.records.length > 0){
						//забираем последний RWN, если он меньше, чем в запрашиваемом, то ограничиваем totalrecords
					}
					if(that.showDashboard){
						//TODO пока временно положил сюда запуск заполнения пресетов
						if(WidgetMap && WidgetMap.config && WidgetMap.config.dashboard && (WidgetMap.config.dashboard.preset || WidgetMap.config.dashboard.charts || WidgetMap.config.charts)){
							var dashboard = WidgetMap.config.dashboard.preset || WidgetMap.config.dashboard;
							WidgetMap.config.dashboard.preset = undefined; // отключаем запуск пресетов, чтобы не срабатывали при переключении между гридами
							if(WidgetMap.config.charts && WidgetMap.config.dashboard){//временное решение
								WidgetMap.config.dashboard.charts = WidgetMap.config.charts;
							}
							if(WidgetMap.config.goals && WidgetMap.config.dashboard){//временное решение
								WidgetMap.config.dashboard.goals = WidgetMap.config.goals;
							}
							dashboard.canvas = WidgetMap.config.canvas;
							App.dashboardManager.loadDashboard(dashboard, function(dashboardConf){
								that.showDashboard = false;
								var currentGrid = $("#" + jqxGridId);
								var da = $(currentGrid).jqxGrid('source');
								if(da.currentGridDescr !== undefined){
									//TODO хардод. избавиться
									if($('#searchEngine_'+jqxGridId).length > 0){
										$('#searchEngine_'+jqxGridId).toggle();
									}
									else{
										$('.search-engine-filters__grid').remove();
										var fltrs = GridUtil.formatFilters2SearchFrom(da.currentGridDescr.gridColumns, function(filters){
											var filterView = new SearchEngineGridFiltersForm({
												opener: 'grid',
												openerId: jqxGridId,
												curDataAdapter: da,
												currentGrid: currentGrid,
												layerName: gridDescription.source.currentGridDescr.layerId,
												settings:{
													dashboard: dashboardConf,
													noTitle:true,
												},
												config: filters,
												applyCallback: function(filters, boolFilters, dateFilters, sender){
													//применяем фильтр
													var curFilter = GridUtil.reformatFilters(filters, boolFilters, dateFilters);
													da.currentGridDescr.currentFilter = curFilter;
													if(sender !== 'dashboard')
														GridWidget.refreshGrid(jqxGridId);
												}
											});
											filterView.build();
										});
									}
								}
							});
						}
						else{
							that.showDashboard = false;
							var currentGrid = $("#" + jqxGridId);
							var da = $(currentGrid).jqxGrid('source');
							if(da.currentGridDescr !== undefined){
								//TODO хардод. избавиться
								if($('#searchEngine_'+jqxGridId).length > 0){
									$('#searchEngine_'+jqxGridId).toggle();
								}
								else{
									$('.search-engine-filters__grid').remove();
									var fltrs = GridUtil.formatFilters2SearchFrom(da.currentGridDescr.gridColumns, function(filters){
										var filterView = new SearchEngineGridFiltersForm({
											opener: 'grid',
											openerId: jqxGridId,
											curDataAdapter: da,
											currentGrid: currentGrid,
											layerName: gridDescription.source.currentGridDescr.layerId,
											settings:{
												noTitle:true,
											},
											config: filters,
											applyCallback: function(filters, boolFilters, dateFilters, sender){
												//применяем фильтр
												var curFilter = GridUtil.reformatFilters(filters, boolFilters, dateFilters);
												da.currentGridDescr.currentFilter = curFilter;
												if(sender !== 'dashboard')
													GridWidget.refreshGrid(jqxGridId);
											}
										});
										filterView.build();
									});
								}
							}
						}
					}
					//that.currentState = $("#" + jqxGridId).jqxGrid('savestate');
				} catch (e) {
					App.errorReport(gis_gridwidget_12, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_8'});
				}

				return data;
			},
			loadServerData: function (serverdata, source, callback) {
				//Показываем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
				try { $("#" + jqxGridId).jqxGrid('showloadelement'); } catch (err) {}
				//Здесь будет непрямая ссылка на callback для отправки результата запроса данных в плагин jqxDataAdapter
				that.jqxDataAdapterCallback = callback;
				delete dataAdapter.currentGridDescr.rows4Update;
				currentGridMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, serverdata, onLoadGridDataResult, onLoadGridDataFail, true);
			}
		};

		//В адаптер добавляем параметры, отвечающие за постраничную обработку результата
		var dataAdapter = new $.jqx.dataAdapter(gridSource, dataAdapterSettings);
		dataAdapter.currentGridDescr = currentGridDescr;
		that.dataAdapter = dataAdapter;
		//22.12.2021 Vartanian Правка по инц 2566
        var layer = currentGridDescr.layerManager.getLayerByName(layerId);
		var	editable = true;
		if(!layer || !layer.dataProvider || !layer.dataProvider.semantic){
			editable = false;
		}

		var gridDescription = {
			width: '100%',
			height: '100%',
			rowsheight: 20,
			source: [],
			sortable: true,
			altrows: true,
			columns: gridColumns,
			/*showstatusbar:true,
			renderstatusbar: function(statusbar){
				GridUtil.renderStatusBar(statusbar, jqxGridId, that);
			},
			statusbarheight: 25,*/
			toolbarheight: 40,
			columnsmenu: false,
			theme: 'gis-blueorange',
			showtoolbar: true,
			columnsresize: true,
			pageable: true,
			pagesizeoptions: pageSizeOptions,
			pagesize: pageSize,
			pagerheight: 1,
			localization: getLocalization('ru'),
			//enablebrowserselection: true,//+
			clipboard: false,//+
			virtualmode: true,
			editable: editable,
			editmode: 'dblclick',
			selectionmode: 'checkbox',
			rendergridrows: function (args) {
				return args.data;
			},
			ready: function(){
				that.defaultState = $("#" + jqxGridId).jqxGrid('savestate');
				//that.defaultState = $.extend({}, that.defaultState);
				that.currentState = $("#" + jqxGridId).jqxGrid('savestate');//$.extend({}, that.defaultState);
			},
			rendered: function gridRenderedFunction(){
				//обнуляем после рендеринга переменную, чтобы не выделялись строки
				that.colorRowSelectType = 0;
			},
			rendertoolbar: admGridRenderToolbar

		};
		if(columnVertSize !== null)
			gridDescription['columnsheight'] = columnVertSize;
		if(titleGridColumn !== null)
			that.titleGridColumn = titleGridColumn;
		//Загружаем общее количество записей - запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
		var gridDataRefresh = function (evt) {
			//перед обновлением грида, отменяем прошлые запросы
			cancelGridProcess();
			//Если id в событии есть но не совпадает с id текущего грида - обновление не запускаем
			if (evt && evt.gridId && evt.gridId==jqxGridId) {
				//Показываем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
				try { $("#" + jqxGridId).jqxGrid('showloadelement'); } catch (err) {}
				if(evt.force === true) {
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = false;
					callWidgetGridFunctions(that.layerId);
					//gridDescription.topFilter = that.filters;
					dataAdapter.currentGridDescr.topFilter = that.filters;
				}
				that.ignoreAllFilter = !!evt.ignoreAllFilter;
				gridSource.totalrecords = 99999999;
				var gridElem = $("#" + jqxGridId);
				if(evt.force === true) {
					//that.pageCursor = 1;
					//gridElem.off('sort');
					//Создаем грид только после получения количества записей
					if(that.currentState){
						try{
							gridElem.jqxGrid('loadstate', that.currentState);
						}
						catch(ex){
						}
					}
					else {
						try{
							gridElem.jqxGrid('removesort');
						}
						catch(ex){ }
						try{
							gridElem.jqxGrid('loadstate', that.defaultState);
						}
						catch(ex){ }
						that.currentState = $("#" + jqxGridId).jqxGrid('savestate');
					}
					gridElem.jqxGrid('clearselection');
					callWidgetGridFunctions(that.layerId);
					//gridDescription.topFilter = that.filters;
					dataAdapter.currentGridDescr.topFilter = that.filters;
					that.refreshGridCallback = evt.refreshGridCallback;
					return;
				}
				//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
				if (gridElem.length === 0) return;
				//Если грид пересоздается (применили фильтр) - сохраняем информацию постраничности (важно, сколько страниц показываем)
				var paginginformation = gridElem.jqxGrid('getpaginginformation');
				if (paginginformation !== undefined) {
					gridDescription.pagesize = paginginformation.pagesize;
				}
				//Удаляем старые слушатели с элемента грида
				gridElem.off('rowselect');
				gridElem.off('rowunselect');
				gridElem.off('rowclick');
				gridElem.off('pagechanged');
				gridElem.off('sort');
				gridElem.off('columnresized');
				//Создаем грид только после получения количества записей
				gridDescription.source = dataAdapter;
				gridElem.jqxGrid(gridDescription);
				//Прячем спиннер загрузки данных
				//gridElem.jqxGrid('hideloadelement');
				/*После создания грида биндимся к нужным событиям*/
				//Биндим события изменения выбора в гриде для установки доступности групповых кнопок
				gridElem.on('rowselect', function (event) {
					setEnableToGroupButtons();
				});
				gridElem.on('rowunselect', function (event) {
					setEnableToGroupButtons();
				});
				gridElem.on('columnresized', function (event) {
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = true;
					if(document.selection !== undefined && document.selection.empty !== undefined)
						document.selection.empty();
				});
				gridElem.on('cellendedit', function (event) {
					// event arguments.
					var args = event.args;
					// cell value
					var value = args.value;
					// cell old value.
					var oldvalue = args.oldvalue;
					var dataField = event.args.datafield;
					// row's bound index.
					var rowBoundIndex = event.args.rowindex;
					var columntype = event.args.columntype;
					var rwn = rowBoundIndex;
					var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', rwn);
					//эмуляция currentGrid, чтобы использовать id грида при поиске
					gridItem = GridUtil.getFullRowDataById({id: widgetElementId}, gridItem);
					if(gridItem && gridItem.RWN)
						rwn = gridItem.RWN;
					dataAdapter.currentGridDescr.lastEditedCell = { rwn:rwn, boundIndex: rowBoundIndex, dataField: dataField, event: event} ;

					if(value === oldvalue){
						//that  - GridWidget
						return;
					}
					//валидируем ячейки
					var validateResult = GridUtil.validateCell(value, columntype);
					var origValue = GridUtil.prepareCellValue(value, columntype)
					value = '' + GridUtil.prepareCellValue(value, columntype);
					if(validateResult !== ''){
						App.confirmDialog(validateResult, null, {title:gis_core_1});
						GridUtil.revertCell(gridElem, event);
						return;
					}

					//сохраняем измененное значение в общий массив измененных записей
					//уникальным считаю ID.
					if(!dataAdapter.currentGridDescr.rows4Update)
						dataAdapter.currentGridDescr.rows4Update = {};
					if(!dataAdapter.currentGridDescr.rows4Update[gridItem.ID]){
						dataAdapter.currentGridDescr.rows4Update[gridItem.ID] = JSON.parse(JSON.stringify(gridItem));//клонируем объект
					}
					//обновляем измененным значением временный список
					var synonym = undefined;
					var gridColumns = dataAdapter.currentGridDescr.gridColumns;
					var fieldName = dataField;
					for (i = 0; i < gridColumns.length; i++) {
						//Так исключаем колонки с иконками, а также колонку с номером
						if (gridColumns[i].datafield === dataField && gridColumns[i].datafieldsynonym)
							fieldName = gridColumns[i].datafieldsynonym;
					}
					dataAdapter.currentGridDescr.rows4Update[gridItem.ID][fieldName] = value;
					dataAdapter.currentGridDescr.rows4Update[gridItem.ID][dataField] = value;
				});
				//Биндим событие смены страницы для снятия выделения грида при переключении страниц
				gridElem.on('pagechanged', function (event) {
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = true;

					gridElem.jqxGrid('clearselection');
				});
				//Биндим событие выбора сортировки (будем перезапрашивать данные грида)
				gridElem.on("sort", function (event) {
					//Перед сортировкой очищаем выделение, иначе чекбокс будет в том же месте, но уже на другой записи.
					gridElem.jqxGrid('clearselection');
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = true;
					var sortinformation = event.args.sortinformation;
					//Поскольку когда сортировка отменяется в событии не указывается колонка - очищаем весь массив
					currentGridDescr.currentSort.splice(0);
					if (sortinformation && sortinformation.sortcolumn && sortinformation.sortcolumn!=undefined)
						currentGridDescr.currentSort.push(sortinformation);
					//Перезапрашиваем данные грида
					gridElem.jqxGrid('updatebounddata', 'sort');
				});
			}
		};

		//Чтобы сразу показались колонки, устанавливаем то же описание грида, но без источника данных.
		var gridElem = $("#" + jqxGridId);
		//устанавливаем dataAdapter
		//gridDescription.source = dataAdapter;

		gridElem.jqxGrid(gridDescription);

		gridElem.data('parentGrid', that.parentGrid);
		gridElem.data('childGrid', that.childGrid);

		//Слушатель завершения отрисовки пустого грида
		setTimeout(function (event) {
			//Прячем надпись "Нет данных для отображения"
			gridElem.find('span:contains('+gridDescription.localization.emptydatastring+')').hide();
		}, 10);

		//Добавляем слушатель события обновления грида
		$("body").on(GridEvent.REFRESH_GRID+"_"+jqxGridId, gridDataRefresh);
		//Однократно вызываем обновление для самого первого отображения данных грида
		GridWidget.refreshGrid(jqxGridId);
	}

	//Функция обратного вызова для получения данных грида
	function onLoadGridDataResult(resultXml) {
		try {
			//если справочники ещё не подгрузились - ждём, иначе работаем по прошлой схеме
			if(loadingFilterCount != 0 ){
				//сохраняем в data пришедшие данные
				$("#" + jqxGridId).data('resultXml',resultXml);
				return;
			}
			if(resultXml === undefined)
				return;
			//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
			try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}

			var gridElem = $("#" + jqxGridId);
			//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
			if (gridElem.length==0) return;
			if (resultXml) {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er != ""){
					App.errorReport(gis_gridwidget_1, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_9'});
				}
				else {
					var hiddenColumns = [];
					/*if(that.hiddenColumns !== undefined)//если уже устанавливали колонки через управление, то переприсваиваем
						hiddenColumns = that.hiddenColumns;*/
					for(var idx = 0; idx < that.columns.length; idx++){
						if(that.columns[idx].hidden === true && that.columns[idx].datafield !== 'ID')
							hiddenColumns.push(that.columns[idx].datafield);
					}
					var dataArr = GridWidget.prototype.getDataFromXmlByAttr(resultXml, 'data');

					that.cachedRecords = GridWidget.prototype.getDataFromXmlByAttr(resultXml, 'data');;
					//that.cachedRecords.concat(dataArr);
					/********************/
					//TODO хардкодим подпись к гриду
					try{
						var titleGridColumn =  $('#btngrouptoolbardiv_'+jqxGridId);
						/*if(eventParamsObj.layerid === 'PODS_STO_REPAIR_SHEET_RELOAD')
						titleDiv.addClass('toolbar-title-grid-clearfix')*/
						if (titleGridColumn.length > 0  && that.titleGridColumn &&  that.titleGridColumn !== ''){//&& titleGridColumn.text() === ''
							var toolbarTitle = titleGridColumn.parent().find('.toolbar-title-grid');
							if(dataArr.length > 0  && dataArr[0][that.titleGridColumn] ) {//если нет заголовка - добавляем
								//если нет кнопок, то добавляем стиль, где нет смещения
								if( toolbarTitle.length === 0){ //если заголовок есть, удаляем стары и добавляем новый
									var clearFixStyle = '';
									if(!titleGridColumn.has( "input" ).length)
										clearFixStyle = 'toolbar-title-grid-clearfix';
									var elem = $('<div class="toolbar-title-grid  ' + clearFixStyle + '"></div>').text(dataArr[0][that.titleGridColumn]);
									$(titleGridColumn).parent().append(elem);
								}
								else{
									$(titleGridColumn).parent().find('.toolbar-title-grid').text(dataArr[0][that.titleGridColumn]);
								}
							}
							if(that.ignoreLabelColumn === true){
								try{
									$(titleGridColumn).parent().find('.toolbar-title-grid').text('');
								}
								catch(ex){}
							}
						}
						//TODO хардкод. устанавливаем в годовом плане заголовок с годом обследования
						var shurfPlanLayerName = $("#" + jqxGridId).data('layerid');
						if(shurfPlanLayerName && shurfPlanLayerName.indexOf('*') !== -1){
							shurfPlanLayerName = shurfPlanLayerName.split('*')[1];
						}
						/*if (titleGridColumn.length > 0  && that.titleGridColumn &&  that.titleGridColumn !== ''){//&& titleGridColumn.text() === ''
							var toolbarTitle = titleGridColumn.parent().find('.toolbar-title-grid');
							if(dataArr.length > 0  && dataArr[0][that.titleGridColumn] && toolbarTitle.length === 0 ) {
								//если нет кнопок, то добавляем стиль, где нет смещения
								var clearFixStyle = '';
								if(!titleGridColumn.has( "input" ).length)
									clearFixStyle = 'toolbar-title-grid-clearfix';
								var elem = $('<div class="toolbar-title-grid  ' + clearFixStyle + '"></div>').text(dataArr[0][that.titleGridColumn]);
								$(titleGridColumn).parent().append(elem);
								// titleGridColumn.text(dataArr[0][that.titleGridColumn]);
							}
						}*/
					}
					catch(ex){}

					/**************/
					var totalrecords = gridSource.hasOwnProperty('totalrecords') ? gridSource.totalrecords : 100000;
					//нужно оставить только те, которые попадают в отображение по курсору
					var visibleDataArr = dataArr;//dataArr.slice(0, (that.pageCursor - 1)  * that.pageSize);

					//Устанавливаем реальное число записей в грид
					gridSource.totalrecords = totalrecords;//visibleDataArr.length;
					totalrecords = visibleDataArr.length;

					visibleDataArr = GridUtil.filterDataFromJson(visibleDataArr, hiddenColumns);

					that.currentRequestedIds = GridUtil.convertGridDataToIdsArray(dataArr);


					//Добавляем полученные данные в грид
					if (that.jqxDataAdapterCallback !== undefined) {
						var resultObj = {
							records: visibleDataArr,
							totalrecords: 100000//totalrecords
						};
						//Указываем, с какую по какую запись загрузили
						if (dataArr && gridSource && gridSource.hasOwnProperty('recordstartindex') && gridSource.hasOwnProperty('recordendindex')) {
							gridSource.recordstartindex = dataArr.length > 0 ? dataArr[0]['RWN'] - 1 : 0;
							gridSource.recordendindex = dataArr.length > 0 ? dataArr[dataArr.length - 1]['RWN'] - 1 : 0;
							var pageSize = that.pageSize;
							if(dataArr.length > 0 && dataArr.length < pageSize){
								resultObj.totalrecords = Number(dataArr[dataArr.length - 1]['RWN']);
							}
						}
						//забираем последний RWN, если он меньше, чем в запрашиваемом, то ограничиваем totalrecords
						//Добавляем через имеющуюся функцию обратного вызова плагина jqxDataAdapter
						that.jqxDataAdapterCallback(resultObj);
					}
					else {
						//Добавляем как обычно, просто массивом (тогда не обрабатывается серверная постраничность)
						addDataToGrid(visibleDataArr);
					}

					if(that.refreshGridCallback){
						that.refreshGridCallback();
						that.refreshGridCallback = undefined;
					}
					if(that.parentGridRowId !== undefined){
						var rows = gridElem.jqxGrid('getrows');
						rows.forEach(function (item, rowIndex) {
							if (item.ID == that.parentGridRowId) {
								//var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', row);
								gridElem.jqxGrid('ensureRowVisible', 0);
								gridElem.jqxGrid('selectrow', rowIndex);
								gridElem.jqxGrid('ensureRowVisible', rowIndex);
								//$(currentGrid).jqxGrid('selectrow', data.selectedIndexes[item] );
							}
						});
						that.parentGridRowId = undefined;

					}

				}
			}
		} catch (e) {
			//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
			try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}
			if(e.message === 'Недостаточно памяти')
				App.errorReport(gis_gridwidget_1_1, 'ex=' + e.message+';data='+resultXml.toString(), undefined, {filename:gis_filename_243, functionname:'gis_filename_243_100'});
			else
				App.errorReport(gis_gridwidget_1, 'ex=' + e.message+';data='+resultXml.toString(), undefined, {filename:gis_filename_243, functionname:'gis_filename_243_10'});

		}
	}
	//Функция обратного вызова для получения данных грида
	function onLoadGridDataFail(resultXml) {
		currentGridMessageId = undefined;
		//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
		try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}
		App.errorReport(gis_gridwidget_1, resultXml.toString(), undefined, {filename:gis_filename_243, functionname:'gis_filename_243_11'});
	}
	//колбек на загрузку каждого справочника
	function onFilterLoadedCallback(){
		--loadingFilterCount;
		if(loadingFilterCount == 0){
			var resultXml = $("#" + jqxGridId).data('resultXml');
			if(resultXml)
				onLoadGridDataResult(resultXml);
		}
	}

	/* Добавление в грид полученных данных */
	function addDataToGrid(gridData) {
		gridSource.localdata = gridData;
		//Обновляем записи в гриде
		$("#"+jqxGridId).jqxGrid({ source: gridSource });
	}

	//Запускаем получение описания грида по названию его шаблона
	if(App && App.GridManager && App.GridManager.has(that.fullLayerId)){
		var gridWidget = App.GridManager.get(that.fullLayerId);
		if(gridWidget && gridWidget.gridDescriptionXml){
			createGrid(gridWidget.gridDescriptionXml, gridTitle);
		}
		else{
			getGridDescription(gridTemplate);
		}
	}
	else{
		getGridDescription(gridTemplate);
	}

	//если открывали грид из другого, то устанавливаем связь
	try{
		if(this.parentGrid)
			$(this.parentGrid).data('childGrid', jqxGridId);
		if(this.childGrid)
			$(this.childGrid).data('parentGrid', jqxGridId);
	}
	catch(ex){

	}

	//Возвращаем построенный элемент грида
	return $('#'+widgetElementId);
};

// Запрос xml-файла с описанием грида
GridWidget.prototype.makeLoadGridDescrReqParams = function (gridDescrId) {
	var userId = Auth.getUserId();
	var userLogin = Auth.getUserName();
	var gridName = (gridDescrId && gridDescrId.indexOf('.xml') === -1) ? gridDescrId + '.xml' : gridDescrId;

	return {
		getSchema: false,
		descrId: 'SYS_SEM.xml#GET_XML_FILE',
		toElements: false,
		descrType: 'select',
		data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userId.xmlEscape() + '">' +
			'<data FILE="../../Public/Modules/Grid/' + gridName.xmlEscape() + '"/>' +
			'</root>'
	};
};

//Получение по значению данных его обертки для отправки в запрос (для строк добавляет кавычки)
GridWidget.prototype.getStrOrNumVal = function (val) {
	var valueStr = '';
	if($.isNumeric(val))
		valueStr += val;
	else if(val === "NULL")
		valueStr += val;
	else if(val === "")
		valueStr += 'NULL';
	else
		valueStr += "'"+val+"'";
	valueStr = valueStr.replace(/''/g, "'");//случай, если пришел уже в одинарных кавычках
	//if(val === '') valueStr = "''";//вариант, если пришла пустая строка
	return valueStr;
};
//Получение из массива фильтров строки со всеми фильтрами верхнего уровня (передаются в тег root, разделяются пробелами)
GridWidget.prototype.getTopFiltersString = function (filtersArr, bottomFilterArr) {
	var resultStr = '';
	if (filtersArr) {
		for (var i = 0; i < filtersArr.length; i++) {
			var curObj = filtersArr[i];
			var curObjName = curObj['name'];
			//Для фильтра верхнего уровня не передаем в запрос OLD_LPU_ACCESS_FILTER (но он передается в нижнем фильтре)
			if (curObjName=='OLD_LPU_ACCESS_FILTER') continue;
			var curObjValue = ""+curObj['value'];

			var curObjValArr = curObjValue.split(',');
			var valuesStr = '';
			if(curObjName === 'ROUTE_DESCR' || curObjName === 'ILI_LBL' || curObjName === 'GRID_TITLE'){//TODO УБРАТЬ хардкод! сделано, чтобы не разбивался текст, который пробрасывали из дргуого грида в запрос
				curObjValArr = [];
				if(curObjValue !== '')
					valuesStr += GridWidget.prototype.getStrOrNumVal(curObjValue);
				valuesStr = valuesStr.replace("'","");
			}
			var findYear = false;
			if(bottomFilterArr && bottomFilterArr.length > 0){
				//ищем YEAR_INSP
				for (var k = 0; k < bottomFilterArr.length; k++) {
					//TODO хардкод если поле YEAR_INSP, то в нижним фильтре игнорируем
					if (bottomFilterArr[k].fld === 'YEAR_INSP'){
						findYear = true;
						if(bottomFilterArr[k].val && bottomFilterArr[k].val.length > 0)
							bottomFilterArr[k].val.forEach(function(t){
								valuesStr += GridWidget.prototype.getStrOrNumVal("'"+t.CODE+"'") + ",";
							});
						break;
					}
				}
			}
			for (var j=0; j < curObjValArr.length; j++) {
				var fVal = curObjValArr[j];
				//TODO хардкод дляшурфовок
				if(curObjName === 'YEAR_INSP' ){
					if(findYear)//если фильтр забрали из нижнего, то не используем верхний
						break;
					//забираем из нижнего фильтра год, если выбрали, т.к. в запросе используется переменная YEAR_INSP, а не фильтр
					if (fVal === '') fVal = '999';//недостижимое число, чтобы скрипт работал
					valuesStr += GridWidget.prototype.getStrOrNumVal("'"+fVal+"'") + ",";
				}
				else
					valuesStr += GridWidget.prototype.getStrOrNumVal(fVal) + ",";
			}

			//убираем последнюю ","
			valuesStr = valuesStr.substr(0, valuesStr.length-1);
			//Если valuesStr=="''", заменяем на NULL (если выбираем в верхнем фильре 0 обследований, как во флеш-версии)
			if (valuesStr=="''") valuesStr = 'NULL';
			//Формируем общую строку со всеми фильтрами
			resultStr += curObjName + '="' + valuesStr + '" '; //Сзади добавляем пробел для разделения с последующими значениями
		}
	}
	return resultStr.replace(/&amp;#60;/g, '&amp;lt;'); //Фиксим баг #1016 - Если задать условие "<" , то ничего не найдется.
};
//Получение из массива фильтров строки со всеми фильтрами среднего уровня (передаются в тег data в атрибут FILTER, разделяются словом ' AND ')
GridWidget.prototype.getRoughFiltersString = function (filtersArr) {
	var resultStr = '';
	if (filtersArr) {
		for (var i = 0; i < filtersArr.length; i++) {
			var curObj = filtersArr[i];
			var curObjName = curObj['name'];
			var curObjValue = curObj['value'];
			var curObjValArr = curObjValue.split(',');
			//Средний фильтр добавляем в конец атрибута FILTER через AND, используем IN для перечисления
			var valuesStr = ' AND ' + curObjName + ' IN ('; //Спереди добавляем пробел для разделения с последующими значениями
			for (var j=0; j < curObjValArr.length; j++) {
				var fVal = curObjValArr[j];
				//TODO хардкод дляшурфовок
				if(curObjName === 'YEAR_INSP'){
					if (fVal === '') fVal = '999';//недостижимое число, чтобы скрипт работал
					valuesStr += GridWidget.prototype.getStrOrNumVal("'"+fVal+"'") + ",";
				}
				else
					valuesStr += GridWidget.prototype.getStrOrNumVal(fVal) + ",";
			}
			//убираем последнюю ",", добавляем закрывающую ")"
			valuesStr = valuesStr.substr(0, valuesStr.length-1) + ")";
			//Формируем общую строку со всеми фильтрами
			resultStr += valuesStr;
		}
	}

	return resultStr.replace(/&amp;#60;/g, '&amp;lt;'); //Фиксим баг #1016 - Если задать условие "<" , то ничего не найдется.
};
// Запрос получения данных грида
GridWidget.prototype.makeLoadDataReqParams = function (dataRequest, bottomFilters, initialSortField, lowLimit, highLimit, topFilters, roughFilters, parentRoughFilter, parentRoughParams, ignoreAllFilter) {
	var userId = Auth.getUserId();
	var userLogin = Auth.getUserName();
	lowLimit = isNaN(lowLimit) ? 1 : lowLimit;
	highLimit = isNaN(highLimit) ? 100 : highLimit;
	//Строка с фильтрами верхнего уровня (добавляем в конце всех атрибутов, причем и в тег root, и в тег data)
	var topFiltersStr = GridWidget.prototype.getTopFiltersString(topFilters, bottomFilters);
	//Строка с фильтрами среднего уровня (добавляем в конце атрибута FILTER в теге data)
	var roughFilterStr = GridWidget.prototype.getRoughFiltersString(roughFilters);
	//Строка с фильтрами нижнего уровня (добавляем в начало атрибута FILTER в теге data)
	var bottomFiltersStr = GridWidget.prototype.getBottomFilterString(bottomFilters, parentRoughFilter);
	var parentVars = (parentRoughParams && parentRoughParams.length) ? parentRoughParams[parentRoughParams.length - 1] : undefined;
	var parentRoughFilterParams = GridUtil.composeFilterVarByColumns(parentVars);
	//Поле начальной сортировки (если ничего не передано - сортируем по полю ID )
	var orderColumnsField = initialSortField!=null && initialSortField!="" && initialSortField!="ID" ? initialSortField+',ID' : 'ID';

	if(ignoreAllFilter){
		roughFilterStr = ''; bottomFiltersStr = '8=8'; parentRoughFilterParams = '';
	}
	return {
		descrId: dataRequest,
		descrType: 'select',
		data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" '+topFiltersStr+'>' +
			'<data ' + parentRoughFilterParams + ' FILTER="'+bottomFiltersStr+roughFilterStr.xmlEscape()+'" ' +
			'ORDER_COLUMNS="'+orderColumnsField+'" LOW_LIMIT="'+lowLimit+'" HIGH_LIMIT="'+highLimit+'" '+topFiltersStr+'/>' +
			'</root>'
	};
};
// Запрос получения данных геометрии по выбранными ID грида
GridWidget.prototype.makeLoadGeoDataReqParams = function (dataRequest, filterStr) {
	var userId = Auth.getUserId();
	var userLogin = Auth.getUserName();

	return {
		descrId: dataRequest,
		descrType: 'select',
		data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" >' +
			'<data FILTER="'+filterStr.xmlEscape()+'" />' +
			'</root>'
	};
};
// Строка с фильтрами для центровки на карте (добавляется специальное поле COLUMNS_FILTER="ID")
GridWidget.prototype.makeFilterXMLForCentering = function (bottomFilters, initialSortField, topFilters, roughFilters, parentRoughFilter) {
	//Строка с фильтрами верхнего уровня (добавляем в конце всех атрибутов, причем и в тег root, и в тег data)
	var topFiltersStr = GridWidget.prototype.getTopFiltersString(topFilters, bottomFilters);
	//ДАТЫ ОБРАБАТЫВАЕМ ОТДЕЛЬНО - включаем как переменные на уровень тега <data >, например: <data CURRENT_DATE="20.05.2015">
	if (bottomFilters && bottomFilters.length > 0) {
		for (var i = 0; i < bottomFilters.length; i++) {
			var filterObj = bottomFilters[i];
			if (filterObj.hasOwnProperty('hasType') && filterObj.hasType=='date' && filterObj.fld!=undefined && filterObj.val!=undefined) {
				topFiltersStr += ' '+filterObj.fld+'="'+filterObj.val+'" ';
			}
		}
	}
	//Строка с фильтрами среднего уровня (добавляем в конце атрибута FILTER в теге data)
	var roughFilterStr = GridWidget.prototype.getRoughFiltersString(roughFilters);
	//Строка с фильтрами нижнего уровня (добавляем в начало атрибута FILTER в теге data)
	//TODO перейти на статический метод
	//GridUtil.getBottomFilterString(bottomFilters, parentRoughFilter);
	var bottomFiltersStr = GridWidget.prototype.getBottomFilterString(bottomFilters, parentRoughFilter);
	//Поле начальной сортировки (если ничего не передано - сортируем по полю ID )
	var orderColumnsField = initialSortField!=null && initialSortField!="" && initialSortField!="ID" ? initialSortField+',ID' : 'ID';

	return '<data FILTER="'+bottomFiltersStr.xmlEscape()+roughFilterStr.xmlEscape()+'" ORDER_COLUMNS="'+orderColumnsField.xmlEscape()+'" '+topFiltersStr+' COLUMNS_FILTER="ID"/>';
};

//Функция получения из xml с данными массива данных (в виде объектов)
GridWidget.prototype.getDataFromXmlByAttr = function (inputXmlStr, dataAttrName, excludeColumns) {
	var retArr = [];
	//Получаем xml с данными в виде структуры (берем корневой элемент, т.е. root)
	var inputXml = ($.parseXML(inputXmlStr)).firstChild;
	var items = inputXml.getElementsByTagName(dataAttrName);

	for (var i = 0; i < items.length; i++) {
		var curItem = items[i];
		var attrNameNodeMap = curItem.attributes;
		if(attrNameNodeMap.length === 0) continue;
		//добавляем в виде объекта со свойствами согласно именам атрибутов
		var addItem = {};
		for (var j = 0; j < attrNameNodeMap.length; j++) {
			var node = attrNameNodeMap[j];
			if(excludeColumns && excludeColumns.length > 0 && excludeColumns.indexOf(node.nodeName.toUpperCase()) !== -1)
				continue;
			addItem[node.nodeName.toUpperCase()] = node.nodeValue;
		}
		retArr.push(addItem);
	}

	return retArr;
};

//Функция обработки щелчка на кнопке в колонке грида
GridWidget.prototype.imageButtonClick = function (event, currentGrid, value, gridTitle) {
	try {
		var imgButton = event.target;
		var idArr = imgButton.id.split('_');
		if (idArr && idArr.length==5) {
			//Грид берет колонку не по ее номеру, а по ее dataField, но в dataField колонок с кнопками как раз находятся их номера
			var rowNum = idArr[4];
			//Данные выбранной строки грида
			var curRowData = $(currentGrid).jqxGrid('getrowdatabyid', rowNum);
			//Получаем необходимые значения из атрибутов кнопки
			var paramsObj = {
				index: value,
				path: '',
				eventname: '',
				tooltip: '',
				request: '',
				task: '',
				opennewwnd: '',
				openwndwidth: '',
				openwndheight: '',
				layerid: '',gridid: '',
				templatename: '',
				ext_data_id: '',
				syncmap:'',
				paneltitle:'',
				descrcolumns:'',
				listrendererparams:'',
				filterparams:'',
			};
			for (var i = 0; i < imgButton.attributes.length; i++) {
				var curAttr = imgButton.attributes[i];
				var attrName = curAttr.nodeName;
				var attrValue = curAttr.nodeValue;
				if (paramsObj.hasOwnProperty(attrName)) {
					paramsObj[attrName] = attrValue;
				}
			}

			//т.к. часть данных в скрытых колонках, то из cachedRecords забираем весь набор атрибутов для выбраннй записи
			curRowData = GridUtil.getFullRowDataById(currentGrid, curRowData);
			var selectedArr = [curRowData];

			//По содержимому объекта paramsObj будем вызывать соответствующую внешнюю функцию грида на данных selectedArr
			GridWidget.prototype.callExternalGridFunction(paramsObj, selectedArr, currentGrid, gridTitle, rowNum, event);

			//В dataAdapter в records хранятся все записи. В _source.datafields хранится описание колонок.
			/*var curDataAdapter = $(currentGrid).jqxGrid('source');
			 var curRowData = curDataAdapter.records[rowNum];*/
		} else {
			App.errorReport(gis_gridwidget_5);
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_14'});
	}
};

//Функция обработки щелчка на групповой кнопке грида
GridWidget.prototype.groupButtonClick = function (event, currentGrid) {
	try {
		var imgGroupButton = event.target;
		var idArr = imgGroupButton.id.split('_');
		if (idArr) {
			//Получаем необходимые значения из атрибутов кнопки
			var paramsObj = {source:'', clickevent:'', tooltip:'', request:'', isenabled:'',
				selectedobjects:'', layerid:'', template:'', gridid:'', syncmap:'',
				parentgridid:'',paneltitle:'', task: '', opennewwnd: '', filter: '',
			};

			var i;
			for (i = 0; i < imgGroupButton.attributes.length; i++) {
				var curAttr = imgGroupButton.attributes[i];
				var attrName = curAttr.nodeName;
				var attrValue = curAttr.nodeValue;
				if (paramsObj.hasOwnProperty(attrName)) {
					paramsObj[attrName] = attrValue;
				}
			}
			//Данные выбранных строк грида
			var selectedArr = [];
			var rowindexes = $(currentGrid).jqxGrid('getselectedrowindexes');
			for (i = 0; i < rowindexes.length; i++) {
				var curRowData = $(currentGrid).jqxGrid('getrowdatabyid', rowindexes[i]);
				//Для еще не подгруженных данных грида элементы массива с недогруженными номерами будут undefined
				if (curRowData && curRowData.hasOwnProperty("ID")) {
					//т.к. часть данных в скрытых колонках, то из cachedRecords забираем весь набор атрибутов для выбраннй записи
					curRowData = GridUtil.getFullRowDataById(currentGrid, curRowData);
					selectedArr.push(curRowData);
				}
			}
			var isFiltering = false;
			//если в процессе фильтрации, то нельзя получить доступ к выбранным элементам, например, при экспорте
			if(rowindexes.length !== selectedArr)
				isFiltering = true;

			//По содержимому объекта paramsObj будем вызывать соответствующую внешнюю функцию грида на данных selectedArr
			GridWidget.prototype.callExternalGridFunction(paramsObj, selectedArr, currentGrid, isFiltering);

			//В dataAdapter в records хранятся все записи. В _source.datafields хранится описание колонок.
			/*var curDataAdapter = $(currentGrid).jqxGrid('source');
			 var curRowData = curDataAdapter.records[rowNum];*/
		} else {
			App.errorReport(gis_gridwidget_5);
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_16'});
	}
};

//Функция вызова внешней функции взаимодействия по переданным данным (выбранные ряды грида) и объекту с типом события
//eventParamsObj - объект, полученный от кнопки грида вида {path:'', eventname:'', tooltip:'', layerid:'', templatename:'', ext_data_id:''}
//dataObj - объект с данными (массив выбранных записей грида)
GridWidget.prototype.callExternalGridFunction = function (eventParamsObj, dataObj, currentGrid, gridTitle, rowNum, event) {
	try {
		var that = this;
		//Если переданы все параметры
		if (eventParamsObj && dataObj) {
			var i = 0;
			var windowId = "";
			var funcName = "";
			var params = [];
			var objectsStr = "";
			//Дополнительные переменные перед разделением на групповую и строковую операции
			var filterStr, dataRequest, curLayerObj, layerManagerInst, layerId, gridLayerId;
			var curDataAdapter = $(currentGrid).jqxGrid('source');
			if(curDataAdapter !== undefined && curDataAdapter.currentGridDescr === undefined && GlobalGridDescr[currentGrid.id] !== undefined ){//условие самого начала работы с гридом. Используем описание грида по умолчанию
				curDataAdapter.currentGridDescr = GlobalGridDescr[currentGrid.id];
			}
			var deletingObject, fileName, extDataId, deletingArr, deleteConfirmationForm, limitExportExcel, alertForm, dialog;
			/* переменные для административных задач */
			var deleteArray, currentTemplate;
			var currentMessageId; //Это не ID запроса. Это сам текущий запрос, который можно отменить через currentMessageId.abort()
			var requestParams, sendingData, gridPropPanelId, gridPropPanelDiv, routeIds, curObjectId, _baseOutputData;
			/* Задача администрирования трубопроводов */
			var kmCalcArray, lrsCalcArray, makeSrvDistrBndArray, offlineBindingByRouteArray;
			/* Задача администрирования отчетов ВТД */
			var iliCalcArray, iliCalcPressureArray, iliCalcPressureInput, iliCalcClusterArray, iliCalcClusterInput, iliCalcSTOArray, iliCalcSTOInput, iliCalcSTOforEHZArray, iliCalcSTOforEHZInput;
			/* Задача администрирования отчетов ЭХЗ */
			var cpCalcArray;
			/* Задача администрирования учетных записей */
			var addRolesToUsersArray;
			/* Задача администрирования ролей */
			var createRolesByLPUArray;
			/* Задача администрирования политик доступа */
			var addRolesToPoliciesArray, addPolicyRulesArray;
			/* Задача администрирования видеомониторинга */
			var addRoutesToVideosArray;
			/* Задача администрирования ЛПУ */
			var addZonesToLpuArray, addNomenclaturesToLpuArray;

			//Функция для вызова именно из грида сообщения об ошибке центровки
			var gridCenteringResultFunction = function (shortText, fullText) {
				App.confirmDialog(shortText, null, {title:gis_core_1});
			};
			//Функция для вызова именно из грида сообщения об ошибке центровки
			var noErrorFunction = function (shortText, fullText) {
				//App.confirmDialog(gis_bindtolineform_4, null, {title:gis_core_1});
			};

			//слушатель результата выполнения задачи
			var onShurfResult = function onResult(resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				if (resultXML) {
					var er = HTTPServiceUtil.getError(resultXML);
					if (GridWidget.processStatusForm)
						GridWidget.processStatusForm.processResultString(er);
				}
			};
			//слушатель результата выполнения задачи
			var onShurfFault = function (resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				if (resultXML) {
					var er = HTTPServiceUtil.getError(resultXML);
					if (GridWidget.processStatusForm)
						GridWidget.processStatusForm.processResultString(er);
				}
			};
			var cancelShurfProcess = function cancelProcess() {
				if (currentMessageId)
					currentMessageId.abort();
				currentMessageId = undefined;
				BlockingUtil.ready();
			};

			//Функция обновления грида после добавления
			var refreshGridAfterDelete = function (errorsCount, processedCount, isCancel, layerName, ids) {
				//После удаления обновляем грид
				//СИНХРОНИЗАЦИЯ #K6
				//СИНХРОНИЗАЦИЯ #S5
				//СИНХРОНИЗАЦИЯ #U5
				if(layerName && ids){//Рефакторинг Vartanian 25.11.2021
					var selectedObject = layerName + ':' + ids.join(',');
					App.syncManager.callSync(selectedObject, 'grid_delete', undefined, SyncTypes.TYPE_3);
				}
			};
			var refreshGridAfterProcEnd = function (layerName, ids) {
				//После удаления обновляем грид
				//СИНХРОНИЗАЦИЯ #K6
				//СИНХРОНИЗАЦИЯ #S5
				//СИНХРОНИЗАЦИЯ #U5
				if(layerName && ids){//Рефакторинг Vartanian 25.11.2021
					var selectedObject = layerName + ':' + ids.join(',');
					App.syncManager.callSync(selectedObject, 'grid_refresh', undefined, SyncTypes.TYPE_3);
				}
			};
			var refreshDataAfterProcEnd = function (layerName, ids) {
				//После удаления обновляем грид
				//СИНХРОНИЗАЦИЯ #K6
				//СИНХРОНИЗАЦИЯ #S5
				//СИНХРОНИЗАЦИЯ #U5
				if(layerName && ids){//Рефакторинг Vartanian 25.11.2021
					var selectedObject = layerName + ':' + ids.join(',');
					App.syncManager.callSync(selectedObject, 'grid_refresh', undefined, SyncTypes.TYPE_3);
					var layer = WidgetMap.layerManager.getLayerByName(layerName);
					if(layer && layer.layer){
						layer.layer.loadDataByIds(ids, false);
					}
				}
			};
			var refreshGridAfterDeleteWithSyncMap = function (errorsCount, processedCount, isCancel, layerName, ids) {
				//После удаления обновляем грид
				GridWidget.refreshGrid(currentGrid.id);
				/*//ВЫЗОВ ФУНКЦИИ СИНХРОНИЗАЦИИ
				//Не смог воспроизвести синхронизацию(не отвечает за ячейки из екселя по реакциям)
				//Нужно удалить блок кода.
				if(layerName && ids){
					var selectedObject = layerName + ':' + ids.join(',');
					App.syncManager.callSync(selectedObject, 'grid', undefined, SyncTypes.TYPE_3);
				}*/
				if(MapUtil){
					/*if(ids.length > 100)
						MapUtil.updateLayerData(layerName, [], false);
					else*/
					MapUtil.updateLayerData(layerName, ids, false);
				}
			};


			//слушатель результата выполнения задачи
			var onResult = function onResult(resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				if (resultXML) {
					var er = HTTPServiceUtil.getError(resultXML);
					var showAlertMessage = function showAlertMessage(alertMsg, alertTitle) {
						if (er != "")
							App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_18'});
						else {
							alertForm = new AlertForm();
							alertForm.width = 320;
							alertForm.build("gridAdmTaskAlertForm", alertMsg, alertTitle, AlertForm.OK);
						}
					};
					switch (currentTemplate) {
						/* Задача администрирования отчетов ВТД */
						case "ILI_INSP_Proc.xml":
						case "ILI_Pressure.xml":
						case "ILI_Cluster.xml":
						case "STO_ILI_INSP_Proc.xml":
						case "STO_EHZ_INSP_Proc.xml":
						case "gridAdmPiCPBindToLine":
						case "gridAdmPiCISBindToLine":
						case "UnlinkReperTemplate":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							break;
						case "IliReportCalcCorrTemplate":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							GridWidget.successIliReportCalcCorr();
							break;
						case "ILI_INSP_ProcRevert.xml":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							if(er === ''){
								showAlertMessage(gis_gridwidget_157, gis_gridwidget_14);
								refreshGridAfterOperation();
							}
							break;
						/* Задача администрирования отчетов ВТД */
						case "gridAdmIliBindToRoute":
							showAlertMessage(gis_gridwidget_13, gis_gridwidget_14);
							break;
						default:
							if (er != "")
								App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_19'});
							break;
					}
				}
			};
			//слушатель результата выполнения задачи
			var onFault = function onFault(resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				if (resultXML) {
					var er = HTTPServiceUtil.getError(resultXML);
					switch (currentTemplate) {
						/* Задача администрирования отчетов ВТД */
						case "ILI_INSP_Proc.xml":
						case "ILI_Pressure.xml":
						case "ILI_Cluster.xml":
						case "STO_ILI_INSP_Proc.xml":
						case "STO_EHZ_INSP_Proc.xml":
						case "gridAdmPiCPBindToLine":
						case "gridAdmPiCISBindToLine":
						case "UnlinkReperTemplate":
						case "ILI_INSP_ProcRevert.xml":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							break;
						case "IliReportCalcCorrTemplate":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							break;
						case "gridAdmIliBindToRoute":
						default:
							App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_20'});
							break;
					}
				}
			};
			//Окончание обработки групповой операции
			var endProcess = function endProcess() {
				//Не снимаем курсор ожидания - это делают onResult, onFault и cancelProcess
				//BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				deleteArray = null;
				/* Задача администрирования трубопроводов */
				kmCalcArray, lrsCalcArray, makeSrvDistrBndArray, offlineBindingByRouteArray = null;
				/* Задача администрирования отчетов ВТД */
				iliCalcArray, iliCalcPressureArray, iliCalcPressureInput, iliCalcClusterArray, iliCalcClusterInput, iliCalcSTOArray, iliCalcSTOInput, iliCalcSTOforEHZArray, iliCalcSTOforEHZInput = null;
				/* Задача администрирования отчетов ЭХЗ */
				cpCalcArray = null;
				/* Задача администрирования учетных записей */
				addRolesToUsersArray = null;
				/* Задача администрирования ролей */
				createRolesByLPUArray = null;
				/* Задача администрирования политик */
				addRolesToPoliciesArray, addPolicyRulesArray = null;
				/* Задача администрирования видеомониторинга */
				addRoutesToVideosArray = null;
				/* Задача администрирования ЛПУ */
				addZonesToLpuArray, addNomenclaturesToLpuArray = null;
				//Очищаем форму статуса процесса
				GridAdmWidget.processStatusForm = null;
				//обновляем грид
				refreshGridAfterOperation();
			};
			//Функция обновления грида после удаления
			var refreshGridAfterOperation = function refreshGridAfterOperation() {
				//После удаления обновляем грид
				GridWidget.refreshGrid(currentGrid.id);
			};

			//Отмена текущего выполняемого запроса. Особенность - даже при отмене отработает функция onFault с ошибкой abort. abort.
			var cancelProcess = function cancelProcess() {
				if (currentMessageId)
					currentMessageId.abort();
				currentMessageId = undefined;
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//Не обновляем грид - это делается в endProcess.
			};
			//Простая функция для перевода JSON Object с примитивными атрибутами (без массива) в xml с тегом <input />
			var convertSimpleObjectToXml = function convertSimpleObjectToXml(simpleObj) {
				var resXml = '<input />';
				for (var attrName in simpleObj) {
					var attrValue = simpleObj[attrName];
					//Значения "Y" и "N" переводим в true и false для админских серверных задач
					if (attrValue == "Y" || attrValue == "N") attrValue = attrValue == "Y";
					//Добавляем к результирующей строке
					resXml = resXml.replace('/>', attrName + '="' + attrValue + '" />');
				}
				// resXml = resXml.replace('<', '&lt;');
				// resXml = resXml.replace('>', '&gt;');
				return resXml;
			};

			//Простая функция для перевода xml с примитивными атрибутами в JSON Object (обязательно надо чтобы заканчивался на '" />' а не '"/>')
			var convertXmlToSimpleObject = function convertXmlToSimpleObject(simpleXml) {
				var resObj = {};
				//root_path="|zip_file_name="|do_calc_inspection="true|do_read_about="true|data_file_name="data.xml"
				simpleXml = simpleXml.replace('<input ', '');
				simpleXml = simpleXml.replace('/>', '');
				var xmlSplitArr = simpleXml.split('" ');
				for (var i = 0; i < xmlSplitArr.length; i++) {
					var paramSplitArr = xmlSplitArr[i].split('="');
					if (paramSplitArr.length == 2) {
						//Значения true и false переводим в "Y" и "N" для админских серверных задач
						var paramValue = paramSplitArr[1];
						if (paramValue == true || paramValue == false) paramValue = paramValue ? "Y" : "N";
						resObj[paramSplitArr[0]] = paramSplitArr[1];
					}
				}
				return resObj;
			};
			function closeDialog() {
				dlg.dialog('destroy');
				dlg.remove();
			}
			//Обрабатываем полученный объект.
			/* КНОПКА В СТРОКЕ ГРИДА. Если есть свойство eventname - значит это вызов с кнопки для персонального ряда. Нужно обработать вызов согласно eventname
			 Типы eventName: ru.corelight.business.events.ExportToGPXEvent, ru.corelight.business.events.ShowOnMapEvent,
			 ru.corelight.business.events.ExportToExcelEvent, ru.corelight.business.events.RemoveGridRowEvent
			 */
			if (eventParamsObj.hasOwnProperty('eventname')) {
				if(rowNum !== undefined){
					if(eventParamsObj['eventname'] !== 'showDetailEvent'){ // при "проваливании" в дочерний грид у текущего грида нет выполняем команды(он закрывается)
						$(currentGrid).jqxGrid('clearselection');
						$(currentGrid).jqxGrid('selectrow', Number(rowNum));
					}
				}

				if (GridButtonsWithPopup && GridButtonsWithPopup.indexOf(eventParamsObj['eventname']) !== -1)
					widgetMoveWindowToPosition('grid','restore_default');
				switch (eventParamsObj['eventname']) {
					//Экспорт пикетажа по всему газопроводу
					case 'gridAdmRoutesExportPicketingByLine':
						if(dataObj[0] === undefined) break;
						//Формируем список routeIds из поля LINE_ID
						var rId = undefined;
						if(dataObj.length>0 && goog.isDef(dataObj[0]["LINE_ID"]))
							rId = dataObj[0]["LINE_ID"];
						extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_LINE';
						//Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде "русскоязычный заголовок колонки":value
						ExportUtil.exportAdmPicketingToExcel([{LINE_ID:rId}], 'server_export', extDataId);
						break;
					case 'ru.corelight.business.events.ExportToExcelPicketingByRouteEvent':
						if(dataObj[0] === undefined) break;
						var rId = undefined;
						var lId = undefined;
						if(dataObj.length>0 && goog.isDef(dataObj[0]["ID"]))
							rId = dataObj[0]["ID"];
						if(dataObj.length>0 && goog.isDef(dataObj[0]["LINE_ID"]))
							lId = dataObj[0]["LINE_ID"];
						extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE';


					function build() {
						//Создаем диалоговую форму
						dlg.dialog({
							modal: true,
							title: gis_gridwidget_15,
							dialogClass: 'noCloseButton gsi-zindex__dialog',
							closeOnEscape: true,
							width: 300,
							height: 180
						});

						//Кнопки Ок и отмены
						$("input[name='export']", dlg).click(function () {
							if($('input[id="radioPicketingByRoute"]', dlg).is(':checked'))
								ExportUtil.exportAdmPicketingToExcel([{ROUTE_ID: rId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE');
							else
								ExportUtil.exportAdmPicketingToExcel([{LINE_ID: lId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_LINE');
							$('#exportPicketingToExcelForm').remove();
						});
						$("input[name='cancel']", dlg).click(function () {
							$('#exportPicketingToExcelForm').remove();
						});
					}
						var elementId = 'exportPicketingToExcelForm';
						$('#'+elementId).remove();
						$('body').append('<div id="'+elementId+'"></div>');
						var dlg = $('#'+elementId);
						dlg.load('ui/html/ExportPicketingToExcelForm.html', build);
						break;
					case 'ru.corelight.business.events.ExportToGPXEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						filterStr = "ID = " + dataObj[0]["ID"];
						//Экспортируем объекты
						GridWidget.prototype.exportObjectsToGPX(filterStr, curDataAdapter.currentGridDescr);
						break;
					case 'ru.corelight.business.events.ShowOnMapEvent':
						//Формируем параметры для вызова функции центровки
						try {
							if(dataObj[0] === undefined) break;
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							//закомментировал, чтобы выдавалось сообщение, что не найден слой
							//if (curLayerObj==undefined || curLayerObj==null) break;
							var titlebar = !(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.titlebar === false);
							objectsStr = eventParamsObj["layerid"] + ":" + dataObj[0]["ID"];
							funcName = "showObjects";
							params = [{name: "objects", value: objectsStr}, {name: "select", value: true}, {name: "centering", value: true}, {name: "gridCenteringResultFunction",value: gridCenteringResultFunction},{name: "isGroupButton", value: false}];
							if(!App.syncEnabled){
								//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
								ExternalInteraction.callFunction(windowId, funcName, params);
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								if(titlebar)//TODO заглушка, чтобы не сворачивать грид
									widgetMoveWindowToPosition('grid');
							}
							else {

								//1. для клика из самой вкладки делаем первоначальною центровку
								//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
								//ExternalInteraction.callFunction(windowId, funcName, params);
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								if(titlebar)
									widgetMoveWindowToPosition('grid');
								//2. и параллельно отправляем событие на центровку через синхронизацию
								//СИНХРОНИЗАЦИЯ #Z5
								//СИНХРОНИЗАЦИЯ #V6
								//СИНХРОНИЗАЦИЯ #V7
								var selectedObject = objectsStr;
								if(selectedObject)
									App.syncManager.callSync(selectedObject, 'grid', undefined, SyncTypes.TYPE_2);
							}
						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_21'});
						}
						break;
					case 'ru.corelight.business.events.ExportToExcelEvent':
						if(dataObj[0] === undefined) break;
						//забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
						limitExportExcel = NaN;
						if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
							limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						// isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
						if (limitExportExcel && dataObj.length > limitExportExcel && false && isNaN(limitExportExcel))
						{
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+gis_gridwidget_18+limitExportExcel+".<br/>"
								+gis_gridwidget_19+limitExportExcel+gis_gridwidget_20,gis_gridwidget_21);
						}
						else
						{
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+ gis_gridwidget_22,gis_gridwidget_23);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								//TODO переделать описание грида, чтобы в нем явно был указан шаблон для выгрузки в Excel (для PODS_ANODE_LIST.XML он например не указан)
								fileName = App.generateUUID() + ".xls";
								//Если вызов экспорта одиночной записи - при отсутствии templatename подставляем tamplate='export'
								layerId = eventParamsObj.hasOwnProperty('templatename') && eventParamsObj.templatename!='' ? eventParamsObj.templatename : curDataAdapter.currentGridDescr.layerId;
								extDataId = eventParamsObj.hasOwnProperty('ext_data_id') && eventParamsObj.ext_data_id!='' ? eventParamsObj.ext_data_id : '';
								//Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде "русскоязычный заголовок колонки":value
								if (extDataId=='') {
									var newDataObj = {};
									var gridColArr = curDataAdapter.currentGridDescr.gridColumns;
									for (i = 0; i < gridColArr.length; i++) {
										//Так исключаем колонки с иконками, а также колонку с номером
										if (gridColArr[i].text=='' || gridColArr[i].datafield=="RWN" || !dataObj[0].hasOwnProperty(gridColArr[i].datafield)) continue;
										var curColHeaderText = gridColArr[i].text;
										//upd 27.05.20.заменяем \n в колонках на '', чтобы в excel в названиях не было _n
										curColHeaderText = curColHeaderText.replace(/(\\r\\n|\\n|\\r)/gm,'');
										var repl = /[^0-9a-zA-Zа-яА-Я_]/gi;
										curColHeaderText = curColHeaderText.replace(repl, "_");
										newDataObj[curColHeaderText] = dataObj[0][gridColArr[i].datafield];
									}
									ExportUtil.exportToExcel([newDataObj], fileName, layerId, 'export');
								} else {
									ExportUtil.exportToExcel(dataObj, fileName, layerId, extDataId);
								}
							}
						});
						break;
					case 'ru.corelight.business.events.RemoveGridRowEvent':
						try {
							if(dataObj[0] === undefined) break;
							var syncMap = (eventParamsObj && eventParamsObj.syncmap === 'true');

							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							if (curLayerObj==undefined || curLayerObj==null) {
								//Если слоя нет - делаем как во флеше (там ничего не происходило, даже запрос не отправлялся, здесь Володя сказал должна быть форма с сообщением)
								alertForm = new AlertForm();
								alertForm.build("gridDeleteNoLayerAlertForm",gis_gridwidget_24,gis_gridwidget_25,AlertForm.OK);
								//Чистим выделение в гриде
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							//удаление ТОЛЬКО СЕМАНТИКИ (исправить provider на dataRequest = "", чтобы прошел полный алгоритм удаления сначала геометрии затем семантики)
							dataRequest = curLayerObj.dataProvider.semantic;
							//выставил PropertyPanelName="" как для случая групповой операции удаления было сделано
							deletingObject = {rowData:dataObj[0], classId:layerId, objectId:dataObj[0]["ID"], provider:dataRequest, propertyPanelName:""};
							deletingArr = [];
							deletingArr.push(deletingObject);

							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_26,deletingArr,that,(syncMap)?that.deleteObjectWithSyncMap:that.deleteObject,
										(syncMap)?refreshGridAfterDeleteWithSyncMap:refreshGridAfterDelete, null, true);
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_22'});
						}
						break;
					case 'ru.corelight.business.events.ShowOnCASEvent':
						if(dataObj[0] === undefined) break;//qq
						//проверяем , есть ли lineId, если нет то не открываем ПКА
						function buildCasForm(data) {
							var taskName = 'CAS_JS';
							var params = {
								lineId: data["LINE_ID"],
								beginKm: stationBegin,
								endKm: stationEnd,
							}
							//ПКА просто открываем в новом окне без функций взаимодействия
							function confirm(){
								App.destroyDialog(null, dlgC);
								GridUtil.showOnCas(taskName, params);
							}
							var browserScale = getBrowserZoom();
							if(browserScale !== 1)
								var dlgC = App.confirmDialog(gis_gridwidget_50, [{text:gis_app_55_9,  click:confirm}], {title:gis_core_1, dialogClass: 'noCloseButton', closeOnEscape: false});
							else
								GridUtil.showOnCas(taskName, params);
						}
						var stationBegin = dataObj[0]["STATION_BEG"];
						var stationEnd =  dataObj[0]["STATION_END"];
						if( stationBegin === undefined || stationEnd === undefined){
							if(dataObj[0]["STATION"] !== undefined){
								var station = parseFloat(dataObj[0]["STATION"]);
								if(isNaN(station)){
									App.errorReport(gis_gridwidget_46, gis_gridwidget_49, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_43'});
									return;
								}
								//для километров выставляем +- 300 метров от station
								stationBegin = (station - 0.3).toFixed(2);
								stationEnd = (station + 0.3).toFixed(2);
							}
							else{
								App.errorReport(gis_gridwidget_46, gis_gridwidget_49, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_37'});
								return;
							}
						}
						if(dataObj[0].LINE_ID === undefined){
							if(dataObj[0].ROUTE_ID === undefined){
								App.errorReport(gis_gridwidget_46, gis_gridwidget_47, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_33'});
								return;
							}
							else{
								function onFaultLine(inputXmlStr){
									App.errorReport(gis_gridwidget_46, gis_gridwidget_48, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_35'});
								}
								function onResultLine(inputXmlStr){
									//Получаем xml с данными в виде структуры (берем корневой элемент, т.е. root)
									var inputXml = ($.parseXML(inputXmlStr)).firstChild;
									var items = inputXml.getElementsByTagName('data');
									if(items.length > 0){
										var attrNameNodeMap = items[0].attributes;
										//добавляем в виде объекта со свойствами согласно именам атрибутов
										for (var j = 0; j < attrNameNodeMap.length; j++) {
											var node = attrNameNodeMap[j];
											if(node.nodeName.toUpperCase() === 'LINE_ID'){
												dataObj[0].LINE_ID =  node.nodeValue;
												buildCasForm(dataObj[0]);
												return;
											}
										}
									}
									App.errorReport(gis_gridwidget_46, gis_gridwidget_48, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_36'});
								}
								sendingData = '<data FILTER="ROUTE_ID=' + dataObj[0].ROUTE_ID + '" />';
								var userId = Auth.getUserId();
								var userLogin = Auth.getUserName();
								requestParams = {
									descrId: 'GAZPROM_ADM_SEM.xml#PODS_ROUTE',
									descrType: 'select',
									data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' + sendingData + '</root>'
								};
								App.serverQueryXMLNodeWithTries(Services.processQueryNode, requestParams, onResultLine, onFaultLine,4);
								return;
							}
						}
						else
							buildCasForm(dataObj[0]);
						break;
					//обработка клика по кнопке из задачи ЭХЗ. В ПКА передается дополнительно идентификатор обследования
					case 'showOnCASEHZEvent':
						if(dataObj[0] === undefined) break;
						var stationBegin = dataObj[0]["STATION_BEG"];
						var stationEnd =  dataObj[0]["STATION_END"];
						if( stationBegin === undefined || stationEnd === undefined){
							if(dataObj[0]["STATION"] !== undefined){
								var station = parseFloat(dataObj[0]["STATION"]);
								//для километров выставляем +- 300 метров от station
								stationBegin = (station - 0.3).toFixed(2);
								stationEnd = (station + 0.3).toFixed(2);
							}
							else{
								App.errorReport(gis_gridwidget_46, gis_gridwidget_49, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_38'});
								return;
							}
						}
						var taskName = "cas_ehz";
						if(eventParamsObj !== undefined){
							if(eventParamsObj.task !== undefined && eventParamsObj.task !== '')
								taskName = eventParamsObj.task;
						}
						var params = {
							lineId: dataObj[0]["LINE_ID"],
							beginKm: stationBegin,
							endKm: stationEnd,
							id: dataObj[0]["ID"],
						}
						//ПКА просто открываем в новом окне без функций взаимодействия
						function confirm(){
							App.destroyDialog(null, dlgC);
							GridUtil.showOnCas(taskName, params);
						}
						var browserScale = getBrowserZoom();
						if(browserScale !== 1)
							var dlgC = App.confirmDialog(gis_gridwidget_50, [ {text:gis_app_55_9,  click:confirm} ], {title:gis_core_1, dialogClass: 'noCloseButton', closeOnEscape: false});
						else
							GridUtil.showOnCas(taskName, params);
						break;
					case 'ru.corelight.business.events.ShowVideoEvent':
						if(dataObj[0] === undefined) break;
						/*funcName = "showVideo";
						 params = [{name:"docId", value:dataObj[0]["ID"]}, {name:"videoUrl", value:dataObj[0]["FILE_NAME"]}];
						 //Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
						 ExternalInteraction.callFunction(windowId, funcName, params);*/
						//Вызываем через функцию виджет-взаимодействия js, а не через вызов флеша
						showVideo(dataObj[0]["ID"], dataObj[0]["FILE_NAME"],dataObj[0]["NAME"]);
						//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
						widgetMoveWindowToPosition('grid');
						break;
					case 'ru.corelight.business.events.ExportWRLEvent':
						if(dataObj[0] === undefined) break;
						ExportUtil.exportToWRL(dataObj[0].ID, dataObj[0].FILE_NAME);
						break;
					case 'ru.corelight.business.events.ExportIMGEvent':
						if(dataObj[0] === undefined) break;
						ExportUtil.exportToIMG(dataObj[0].ID, dataObj[0].FILE_NAME);
						break;
					case 'showInfoEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if (curRowData && curRowData.ID) {
							//Добавляем доп. условие. Если грид годового плана шурфовок, что нужно открывать панель свойств PODS_ILI_INSPECTION
							layerId = curDataAdapter.currentGridDescr.layerId;
							var currentGridDescr = curDataAdapter.currentGridDescr;
							var curObjectId = layerId + ":" + curRowData.ID;
							var centeringCallback = undefined;
							var addObj = {};//доп.данные для панели свойств
							//заголовок забирается из панели свойств
							if(layerId === 'PODS_STO_SHEET_EXCAVATE' || layerId === 'PODS_STO_SHEET_MTR' || layerId === 'PODS_STO_SHEET_REPAIR'
								|| layerId === "PODS_STO_SHURF_PLAN" || layerId === "PODS_STO_ILI_DATA_SHEET_RELOAD"){
								gridTitle = "";
							}
							if(layerId === "PODS_STO_SHURF_PLAN"){
								curObjectId = "PODS_ILI_INSPECTION" + ":" + curRowData.ID;
							}
							if( layerId === "PODS_STO_ILI_DATA_SHEET_RELOAD" || layerId === 'PODS_STO_REPAIR_SHEET_RELOAD' ){
								if(curRowData.ILI_CLUSTER_ID && curRowData.ILI_CLUSTER_ID !== '')
									curObjectId = "PODS_ILI_CLUSTER" + ":" + curRowData.ID;
								else
									curObjectId = "PODS_ILI_DATA" + ":" + curRowData.ID;
							}
							if(layerId === "PODS_STO_ILI_DATA_SHEET_BASE"){
								// принято решение убрать двойной клик по этому гриду
								return;
							}
							if(layerId === "PODS_STO_SHEET_EXCAVATE" || layerId === 'PODS_STO_SHEET_MTR' || layerId === 'PODS_STO_SHEET_REPAIR'){
								centeringCallback = function(data, opts){
									if(WidgetMap ){
										WidgetMap.loadLineProfile(curRowData.LINE_ID, curRowData.STATION_BEG, curRowData.STATION_END);
									}

								}
							}
							if(curObjectId.indexOf("PODS_ILI_DATA:") === 0){
								addObj.ILI_DATA_ID = curRowData.ILI_DATA_ID;
								if(curRowData.ILI_CLUSTER_ID)
									addObj.ILI_CLUSTER_ID = curRowData.ILI_CLUSTER_ID;
							}

							//Добавляем div панели свойств текущего грида
							var gridPropPanelId = 'divPPanel' + currentGrid.id;
							var widgetElementId = currentGrid.id.replace('jqxgrid','')
							var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
							$('#' + gridPropPanelId).remove();
							var opener = "#" + widgetElementId;
							if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
								opener = 'body';
								$('body').append(gridPropPanelDiv);
							}
							else{
								$('#' + widgetElementId).append(gridPropPanelDiv);
							}
							var gridCurrentHeight = currentGridDescr.propPanelHeight;
							var gridCurrentWidth = currentGridDescr.propPanelWidth;
							if($('#' + widgetElementId).outerHeight()<currentGridDescr.propPanelHeight) gridCurrentHeight = $('#' + widgetElementId).outerHeight();
							if($('#' + widgetElementId).outerWidth()<currentGridDescr.propPanelWidth) gridCurrentWidth = $('#' + widgetElementId).outerWidth();
							//Создаем панель свойств для текущего объекта
							$('#' + gridPropPanelId).myPropertiesPanel({
								zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
								objects:[{id: curObjectId, label: gridTitle, curRowData:curRowData}],
								opener: opener,
								openerType: 'grid',
								data: addObj,
								panelSize: {propPanelWidth:gridCurrentWidth, propPanelHeight:gridCurrentHeight},
								handlers:{
									calculateObjectSizeCallback: function(params){
									},
									centeringCallback: centeringCallback,
									closeCallback: function (dataObj) {
										//Сохраняем размеры панели свойств, которую уже открывали, чтобы следующие открываемые были того же размера (но не со свернувшейся)
										if ($('#' + gridPropPanelId).outerWidth()>50 && $('#' + gridPropPanelId).outerHeight()>50) {
											currentGridDescr.propPanelWidth = $('#' + gridPropPanelId).outerWidth() - 6; // -6 чтобы панель свойств не росла при каждом закрытии/открытии
											currentGridDescr.propPanelHeight = $('#' + gridPropPanelId).outerHeight() - 6; // -6 чтобы панель свойств не росла при каждом закрытии/открытии
										}
									},
									successDeleteCallback:function(data){
										if(goog.isDef(data) && goog.isDef(data.id) && data.id != '' && data.layerName != ''){
											var layObj = currentGridDescr.layerManager.getLayerByName(data.layerName);
											if(goog.isDef(layObj) && goog.isDef(layObj.layer)){
												layObj.layer.deleteObjectById(data.id);
											}
										}
										if(MapUtil)
											MapUtil.clearSelectionLayer();
										$('#' + gridPropPanelId).remove();
										var selectedObject = undefined;
										if (data.layerName && data.id)
											selectedObject = data.layerName + ':' + data.id;
										if (selectedObject) {
											//СИНХРОНИЗАЦИЯ #Y5-OK
											var syncType = SyncTypes.TYPE_5;
											App.syncManager.callSync(selectedObject, 'grid_delete', undefined, syncType);//Vartanian рефакторинг 25.11.2021
										}
									},
									semanticCallback: function (dataObj) {//Vartanian рефакторинг 25.11.2021
										if(dataObj.success === true && dataObj.retObj){
											var layerName = dataObj.retObj.layerId;
											var semId = dataObj.retObj.id;
											var selectedObject = layerName;
											if(semId){
												selectedObject += ':' + semId;
												//СИНХРОНИЗАЦИЯ #W5
												var syncType = SyncTypes.TYPE_5;
												App.syncManager.callSync(selectedObject, 'grid_refresh', undefined, syncType);
											}
										}
									},
								}
							});
						}
						break;

					//Задача шурфовки. Начало
					//Внести расчетные данные по отчету
					case 'addStoIliDataAdvEvent':
						if(dataObj[0] === undefined)
							break;
						try {
							//jqxGridId, gridElem, dataAdapter, event

							that.pasteFromExcelStoIliDataAdvDialog(currentGrid, curDataAdapter, dataObj[0]);
						}
						catch(ex){
						}


						break;
					//Грид "Подготовить выгрузку данных для ССД ИНФОТЕХ"
					case 'exportInfotehShurfEvent':
						if(dataObj[0] === undefined)
							break;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_INFOTEH_ANOMALY_DATA";
								extDataId = "STO_EXPORT.xml#STO_INFOTEH_ANOMALY_DATA";
								ExportUtil.exportToExcel([dataObj[0]], fileName, layerId, extDataId);
							}
						});
						break;
					//задача "Сформировать акт приемка результатов ВТД"
					case 'createActOfILIResultsEvent':
						if(dataObj[0] === undefined)
							break;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								//Если вызов экспорта одиночной записи - при отсутствии templatename подставляем tamplate='export'
								layerId = "STO_ALLOW_ILI";
								extDataId = "STO_EXPORT.xml#STO_ALLOW_ILI";
								ExportUtil.exportToExcel([dataObj[0]], fileName, layerId, extDataId);
							}
						});
						break;

					//сформировать/выбрать новую ведомость шуррфовок на межкрановом участке
					case 'selectSheetShurfEvent':
						if(dataObj[0] === undefined)
							break;
					function createNewExcavateSheet(){
						GridUtil.getCountStoIliDataAdv(dataObj[0], function(isEmptySheet, hasIliDataAdv){
							var gridSTOILIRangeForm = new GridSTOILIRangeForm({
								dataProvider: "STO_SEM.xml#STO_DICT_1",
								item: dataObj[0],
								type: 'excavate',
								gridId: currentGrid.id,
								hasIliDataAdv: hasIliDataAdv,
								eventParams: eventParamsObj,
								saveCallback: function(sheetId, rangeData){
									if(rangeData && rangeData.uid)
										delete rangeData.uid;
									if(isEmptySheet){//upd. 02.12.20 создаем пустую ведомость, если нет доп. сведений по дефектам
										var duplicateGrid = (WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true)
										ExternalInteraction.openGrid({
											data: {
												ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
												BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
												END_MEASURE: rangeData.END_MEASURE,
												ROUTE_ID: rangeData.ROUTE_ID,
												SHEET_ID: sheetId,
												STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
												//upd. 08.10.20 при создании не пробрасываем заголовок, т.к. он соответствует всему обследованию, а не участку
												//upd. 04.03.21 название берется из новой колонки
												ROUTE_DESCR:rangeData.ROUTE_DESCR//проброс в запрос на получение заголовка грида
											},
											//при создании новой ведомости не должно быть кнопки "добавить дефект"
											gridId: eventParamsObj.layerid+"_LIST",
											label: gis_gridwidget_73,
											fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid,
											position: 2,
											reload: true,
											forceTopFilter: true,
										});
										return;
									}
									BlockingUtil.wait();
									var reqParams = DBUtil.getReqParams('STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH', DBUtil.serializeData(rangeData), 'insert');
									App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
										BlockingUtil.ready();
										if (resultXML) {
											var er = HTTPServiceUtil.getError(resultXML);
											if (er !== ""){
												App.errorReport(gis_gridwidget_82, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_50'});
												return;
											}
											var duplicateGrid = (WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true)
											ExternalInteraction.openGrid({
												data: {
													ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
													BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
													END_MEASURE: rangeData.END_MEASURE,
													ROUTE_ID: rangeData.ROUTE_ID,
													SHEET_ID: sheetId,
													STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
													//upd. 08.10.20 при создании не пробрасываем заголовок, т.к. он соответствует всему обследованию, а не участку
													//upd. 04.03.21 название берется из новой колонки
													ROUTE_DESCR:rangeData.ROUTE_DESCR//проброс в запрос на получение заголовка грида
												},
												//при создании новой ведомости не должно быть кнопки "добавить дефект"
												gridId: eventParamsObj.layerid+"_LIST",
												label: gis_gridwidget_73,
												fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid,
												position: 2,
												reload: true,
												forceTopFilter: true,
											});

										}
									}, function (resultXML) {
										BlockingUtil.ready();
										var er = HTTPServiceUtil.getError(resultXML);
										if (er !== "")
											App.errorReport(gis_gridwidget_82, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_51'});
									},4);
								}
							});
							gridSTOILIRangeForm.build();
						})

						closeDialog();
					}
					function selectExcavateSheet(){
						var gridSTOILIArchiveForm = new GridSTOILIArchiveForm({
							dataProvider: "STO_SEM.xml#STO_DATA_EXC_CHOOSE",
							item: dataObj[0],
							type:'excavate'
						});
						gridSTOILIArchiveForm.build();
						closeDialog();
					}
						//TODO сначала запрашиваем список ведомостей из архива. Если их нет, то сразу выдаем форму создания новой ведомости
						var buttons = [
							{text:gis_gridwidget_70, click:createNewExcavateSheet},
							{text:gis_gridwidget_71, click:selectExcavateSheet}
						];
						var dlg = App.confirmDialog(gis_gridwidget_72, buttons, {title:gis_core_1, width:400});
						break;
					//сформировать /выбрать ведомость материально-технических ресурсов по межкрановому участку
					case 'selectSheetMTRShurfEvent':
						if(dataObj[0] === undefined)
							break;
					function createNewMTRSheet(){
						var gridSTOILIRangeForm = new GridSTOILIRangeForm({
							dataProvider: "STO_SEM.xml#STO_DICT_1",
							item: dataObj[0],
							type:'mtr',
							eventParams: eventParamsObj,
							saveCallback: function(datas, sheetId, rangeData){
								App.notSupportedDialog('Нет возможности открыть созданную ведомость МТР, т.к. данный функционал не реализован');
								return;
								ExternalInteraction.openGrid({
									data: {
										ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
										BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
										END_MEASURE: rangeData.END_MEASURE,
										ROUTE_ID: rangeData.ROUTE_ID,
										SHEET_ID: sheetId,
										STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
										ROUTE_DESCR:rangeData.ILI_LBL//проброс в запрос на получение заголовка грида
									},
									gridId: eventParamsObj.layerid+"_LIST",
									label: gis_gridwidget_75,
									fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid
								});
							}
						});
						gridSTOILIRangeForm.build();
						closeDialog();
					}
					function selectMTRSheet(){
						var gridSTOILIArchiveForm = new GridSTOILIArchiveForm({
							dataProvider: "STO_SEM.xml#STO_DATA_MTD_CHOOSE",
							item: dataObj[0],
							type:'mtr'
						});
						gridSTOILIArchiveForm.build();
						closeDialog();
					}
						//TODO сначала запрашиваем список ведомостей из архива. Если их нет, то сразу выдаем форму создания новой ведомости
						var buttons = [
							{text:gis_gridwidget_70, click:createNewMTRSheet},
							{text:gis_gridwidget_71, click:selectMTRSheet}
						];
						var dlg = App.confirmDialog(gis_gridwidget_72, buttons, {title:gis_core_1, width:400});
						break;
					//Сформировать/выбрать перечень ремонтов
					case 'selectSheetRepairShurfEvent':
						if(dataObj[0] === undefined)
							break;
					function createNewRepairSheet(){
						var gridSTOILIRangeForm = new GridSTOILIRangeForm({
							dataProvider: "STO_SEM.xml#STO_DICT_1",
							item: dataObj[0],
							type:'repair',
							eventParams: eventParamsObj,
							saveCallback: function(datas, sheetId, rangeData){
								ExternalInteraction.openGrid({
									data: {
										ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
										BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
										END_MEASURE: rangeData.END_MEASURE,
										ROUTE_ID: rangeData.ROUTE_ID,
										SHEET_ID: sheetId,
										STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
										ROUTE_DESCR:rangeData.ILI_LBL//проброс в запрос на получение заголовка грида
									},
									gridId: eventParamsObj.layerid+"_LIST",
									label: gis_gridwidget_74,
									fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid
								});
							}
						});
						gridSTOILIRangeForm.build();
						closeDialog();
					}
					function selectRepairSheet(){
						var gridSTOILIArchiveForm = new GridSTOILIArchiveForm({
							dataProvider: "STO_SEM.xml#STO_DATA_REP_CHOOSE",
							item: dataObj[0],
							type:'repair'
						});
						gridSTOILIArchiveForm.build();
						closeDialog();
					}

						//TODO сначала запрашиваем список ведомостей из архива. Если их нет, то сразу выдаем форму создания новой ведомости
						var buttons = [
							{text:gis_gridwidget_70, click:createNewRepairSheet},
							{text:gis_gridwidget_71, click:selectRepairSheet}
						];
						var dlg = App.confirmDialog(gis_gridwidget_72, buttons, {title:gis_core_1, width:400});
						break;
					//Задача "сформировать перечень обследованных дефектов"
					case 'createInspectedILIDataEvent':
						if(dataObj[0] === undefined)
							break;
						alert('Задача "сформировать перечень обследованных дефектов" не реализована');
						break;
					/*Грид "Ведомость аномалий"*/
					//Задача "внести информацию о выполненном наружном обследовании"
					case 'updateSheetExcavateEvent':
						if(dataObj[0] === undefined)
							break;
						//Создаем панель свойств по классу объекта - она сохраняет новый объект
						var curObjectId = "PODS_STO_SHEET_EXCAVATE_LIST:"+dataObj[0].ID;
						var clusterId = (dataObj[0].ILI_CLUSTER_ID)?dataObj[0].ILI_CLUSTER_ID:undefined;
						//Добавляем div панели свойств текущего грида
						var gridPropPanelId = 'divPPanel' + currentGrid.id;
						var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var opener = "#" + widgetElementId;
						if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
							opener = 'body';
							$('body').append(gridPropPanelDiv);
						}
						else{
							$('#' + widgetElementId).append(gridPropPanelDiv);
						}
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: ''}],
							opener: opener,
							openerType: 'grid',
							data: {LIST_ID:dataObj[0].LIST_ID, ILI_CLUSTER_ID:clusterId},
							panelSize: {propPanelWidth:curDataAdapter.currentGridDescr.propPanelWidth, propPanelHeight:curDataAdapter.currentGridDescr.propPanelHeight},
							handlers:{
								calculateObjectSizeCallback: function(params){

								},
								closeCallback: function (dataObj) {
									//Сохраняем размеры панели свойств, которую уже открывали, чтобы следующие открываемые были того же размера (но не со свернувшейся)
									if ($('#' + gridPropPanelId).outerWidth()>50 && $('#' + gridPropPanelId).outerHeight()>50) {
										curDataAdapter.currentGridDescr.propPanelWidth = $('#' + gridPropPanelId).outerWidth();
										curDataAdapter.currentGridDescr.propPanelHeight = $('#' + gridPropPanelId).outerHeight();
									}
								}
							}
						});
						break;
					//вызов задачи 'Внести информацию о выполненном ремонте'
					case 'updateSheetRepairEvent':
						if(dataObj[0] === undefined)
							break;
						//сначала получаем sheet_id из sto_sheet_repair
						// Запрос получения данных геометрии по выбранными ID грида
						var sheetObj = {};
						//забираем из верхнего фильтра
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "ILI_INSPECTION_ID" || item.name == "STO_ILI_INSP_EVENT_ID"){
									sheetObj[item.name]= item.value;
								}
							});
						}
						openSTOSheetRepairListForm();
					function openSTOSheetRepairListForm(sheetId){
						var curObjectId = 'PODS_STO_SHEET_REPAIR_LIST:'+dataObj[0].ID;//передаем ili_data_id
						var clusterId = (dataObj[0].ILI_CLUSTER_ID)?dataObj[0].ILI_CLUSTER_ID:undefined;
						//Добавляем div панели свойств текущего грида
						//ищем ILI_INPECTION_ID и EVENT_ID, чтобы передать дальше в панель свойств
						var sheetObj = {};
						sheetObj.ILI_DATA_ID = dataObj[0].ID;
						if(dataObj[0].ILI_CLUSTER_ID){
							sheetObj.ILI_DATA_ID = dataObj[0].ILI_CLUSTER_ID;
							sheetObj.ILI_CLUSTER_ID = dataObj[0].ILI_CLUSTER_ID;
						}
						/*if(sheetId)
							sheetObj.SHEET_ID = sheetId;*/
						var gridPropPanelId = 'divPPanel' + currentGrid.id;
						var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var opener = "#" + widgetElementId;
						if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
							opener = 'body';
							$('body').append(gridPropPanelDiv);
						}
						else{
							$('#' + widgetElementId).append(gridPropPanelDiv);
						}
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: ''}],
							data: sheetObj,
							opener: opener,
							openerType: 'grid',
							panelSize: {propPanelWidth:curDataAdapter.currentGridDescr.propPanelWidth, propPanelHeight:curDataAdapter.currentGridDescr.propPanelHeight},
							handlers:{
								calculateObjectSizeCallback: function(params){

								},
								closeCallback: function (dataObject) {
									//Сохраняем размеры панели свойств, которую уже открывали, чтобы следующие открываемые были того же размера (но не со свернувшейся)
									if ($('#' + gridPropPanelId).outerWidth()>50 && $('#' + gridPropPanelId).outerHeight()>50) {
										curDataAdapter.currentGridDescr.propPanelWidth = $('#' + gridPropPanelId).outerWidth();
										curDataAdapter.currentGridDescr.propPanelHeight = $('#' + gridPropPanelId).outerHeight();
									}
								},
								semanticCallback: function (dataObject) {
									//СИНХРОНИЗАЦИЯ #W5
									var selectedObject = curObjectId;
									App.syncManager.callSync(selectedObject,'grid', undefined, SyncTypes.TYPE_3);
								},
							}
						});
					}
						break;
					// задача "удалить запись из списка аномалий"
					case 'deleteSheetExcavateListEvent':
						try {
							if(dataObj[0] === undefined) break;
							//SHEET_ID забираем из верхнего фильтра, который пришел извне
							//если нет SHEET_ID, то это новая ведомость и удаляем только строку
							//если есть - удаляем из БД
							var sheetId = undefined;
							if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
								//получаем из фильтра, который пришел от родительского грида
								curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
									if(item.name === "SHEET_ID"){
										sheetId = item.value;
									}
								});
							}
							if(sheetId === undefined && eventParamsObj && eventParamsObj.index && eventParamsObj.index !==''){
								$(currentGrid).jqxGrid('deleterow', eventParamsObj.index);
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST';
							var clId = curDataAdapter.currentGridDescr.layerId;
							if(curDataAdapter.currentGridDescr.layerId === 'PODS_STO_REPAIR_SHEET_RELOAD'){
								dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
							}
							//выставил PropertyPanelName="" как для случая групповой операции удаления было сделано
							deletingObject = {rowData:dataObj[0], classId:clId, objectId:dataObj[0].LIST_ID, provider:dataRequest, propertyPanelName:""};
							deletingArr = [];
							deletingArr.push(deletingObject);
							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_26,deletingArr,that,that.deleteObject,
										refreshGridAfterDelete, null, true);
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_42'});
						}
						break;

					//показать на карте дефект
					case 'showOnMapShurfEvent':
						//Формируем параметры для вызова функции центровки
						try {
							if(dataObj[0] === undefined) break;
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							if(eventParamsObj["layerid"] !== undefined && eventParamsObj["layerid"] !== ''){
								var splittedLayersIds = eventParamsObj["layerid"].split(',');
								//ВЫСТАВЛЯЕМ ВЕРХНИЙ ФИЛЬТР, чтобы каждлый клик на показать на карте в слое PODS_ILI_DATA обновлялись корретнео данные
								var lpuFilter = MapUtil.getTopFilterByName('LPU_ACCESS_FILTER');
								WidgetMap.currentTopFilter = undefined;
								WidgetMap.currentTopFilter = (curDataAdapter.currentGridDescr.topFilter)?[lpuFilter].concat(curDataAdapter.currentGridDescr.topFilter):[];

								var iliInspFilter = {};
								curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
									if(item.name === "ILI_INSPECTION_ID" ){
										iliInspFilter = {name:'ILI_INSP_FILTER',value:item.value};
										var finded = false;
										for(var it in WidgetMap.currentTopFilter){
											if(WidgetMap.currentTopFilter[it].name === 'ILI_INSP_FILTER')
												finded = true;
										}
										if(!finded)
											WidgetMap.currentTopFilter.push({name:'ILI_INSP_FILTER', value: item.value});
									}
								});
								splittedLayersIds.forEach(function(val){
									layerId = val;
									layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
									if(layerId === 'PODS_ILI_DATA' && dataObj[0].ILI_CLUSTER_ID && dataObj[0].ILI_CLUSTER_ID !== '')
										layerId = 'PODS_ILI_CLUSTER';
									curLayerObj = layerManagerInst.getLayerByName(layerId);
									var needReloadLayer = true;
									if(WidgetMap.currentFilter[layerId]){
										WidgetMap.currentFilter[layerId].forEach(function(filter){
											if(filter.filter === iliInspFilter.name && filter.value === iliInspFilter.value){
												needReloadLayer = false;
											}
										});
									}
									if(needReloadLayer){
										WidgetMap.currentFilter[layerId] = [];
										WidgetMap.currentFilter[layerId].push({
											layerName: layerId,
											filter: iliInspFilter.name,
											value: iliInspFilter.value
										});
										layerManagerInst.clearLayer(layerId, true);
									}
									if(dataObj[0].ILI_CLUSTER_ID && dataObj[0].ILI_CLUSTER_ID !== '')
										objectsStr = "PODS_ILI_CLUSTER:" + dataObj[0]["ID"];
									else
										objectsStr = "PODS_ILI_DATA:" + dataObj[0]["ID"];
									curLayerObj.layer.layerLoadCallback = undefined;
									var preparedParams = [{name: "objects", value: objectsStr},
										{name: "select", value: true },
										{name: "centering", value: true},
										{name: "gridCenteringResultFunction", value: noErrorFunction },
										{name: "isGroupButton", value: false}];

									if(curLayerObj && curLayerObj.layer){
										if(layerId === 'PODS_ILI_DATA' || layerId === 'PODS_ILI_CLUSTER'){
											if(needReloadLayer)
												curLayerObj.layer.layerLoadCallback = function(){
													//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
													WidgetMap.showObjects(preparedParams);
												};
											else {
												WidgetMap.showObjects(preparedParams, false, function(finded){
													if(!finded) {
														curLayerObj.layer.layerLoadCallback = function(){
															//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
															WidgetMap.showObjects(preparedParams);
														};
													}
												});
											}
										}
										if(needReloadLayer)
											curLayerObj.layer.setVisible(true);
									}
								});
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								widgetMoveWindowToPosition('grid');
							}
						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_21'});
						}
						break;
					//показать участок на карте
					case 'showOnMapPipePartEvent':
						try {
							if(dataObj[0] === undefined) break;
							if(WidgetMap){
								WidgetMap.loadLineProfile(dataObj[0].LINE_ID, dataObj[0].STATION_BEG, dataObj[0].STATION_END);
							}
							//if(eventParamsObj["request"] !== undefined && eventParamsObj["request"] !== '' && WidgetMap && dataObj[0].LINE_ID && dataObj[0].LINE_ID !== ''){
							//проверям, заполнен список с routeId, чтобы там найти соответственный lineId, чтобы потом выделить участок
							/*if(WidgetMap.preloadRoutesWithLinesList === undefined){
								WidgetMap.loadRoutesWithLines({
									request: eventParamsObj["request"],
									loadedCallback: function(){
										var lineId = WidgetMap.preloadRoutesWithLinesList[dataObj[0].ROUTE_ID];
										if(lineId !== undefined){
											var requestLineProfile = 'GAZPROM_SYS_SEM.xml#MG_PROFILE';
										}
									}
								});
							}
							else{
								var lineId = WidgetMap.preloadRoutesWithLinesList[dataObj[0].ROUTE_ID];
								if(lineId !== undefined){

								}
							}*/
							//}

						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_21'});
						}
						break;
					//вызов задачи 'Сформировать ведомость шурфовок'
					case 'exportExcelShurfSheetEvent':
						if(dataObj[0] === undefined || dataObj[0].ILI_INSPECTION_ID === undefined) break;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_ANOM_LIST";
								extDataId = "STO_EXPORT.xml#STO_ANOM_LIST";
								ExportUtil.exportToExcel([{ID:dataObj[0].ID}], fileName, layerId, extDataId);
							}
						});
						break;
					//вызов задачи 'Сформировать ведомость обследовний'
					case 'createInspectionsSheetEvent':
						//забираем SHEET_ID, который пришел извне
						if(dataObj[0] === undefined) break;
						if(!dataObj[0].ID){
							App.errorReport(gis_gridwidget_53, gis_gridwidget_54, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_39'});
							break;
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_PHYS_INSP_LIST";
								extDataId = "STO_EXPORT.xml#STO_PHYS_INSP_LIST";
								ExportUtil.exportToExcel([{ID:dataObj[0].ID}], fileName, layerId, extDataId);
							}
						});
						break;
					case 'addShurfEvent':
						if(dataObj[0] === undefined) break;
						var addFilter = ' STO_ILI_INSP_EVENT_ID="' + dataObj[0].STO_ILI_INSP_EVENT_ID + '" BEGIN_MEASURE="' + dataObj[0].BEGIN_MEASURE + '"' +
							' END_MEASURE="' + dataObj[0].END_MEASURE + '" ROUTE_ID="' + dataObj[0].ROUTE_ID + '" SHEET_ID="' + dataObj[0].ID + '"' +
							' ROUTE_DESCR="' + dataObj[0].ROUTE_DESCR + '" ILI_INSPECTION_ID="' + dataObj[0].ILI_INSPECTION_ID + '" ';
						if(curDataAdapter.currentGridDescr !== undefined){
							var gridSTOILIDataListForm = new GridSTOILIDataListForm({
								gridId:currentGrid.id,
								sheetId:dataObj[0].ID,
								dataProvider:'STO_SEM.xml#PODS_STO_ILI_DATA_SHEET_ADD',
								items: [],//массив дефектов для выбранной ведомости
								layerId:curDataAdapter.currentGridDescr.layerId,
								filter:curDataAdapter.currentGridDescr.topFilter,
								addFilter: addFilter,
								applyCallback:function(array){
									var allDatas = array;
									//в цикле сохраняем все записи из грида
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_55,allDatas,that,
										function (obj) {
											//Заведомо обнуляем поля перед сохранением
											delete obj.TYPE;
											delete obj.DESCRIPTION;
											delete obj.COMMENTS;
											//у ремонтов доп. поля
											var prvd = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST';
											if(curDataAdapter.currentGridDescr.layerId === "PODS_STO_REPAIR_SHEET_RELOAD"){
												delete obj.WIDTH;
												delete obj.LENGTH;
												prvd = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
											}
											var reqParams = DBUtil.getReqParams(prvd, DBUtil.serializeData(obj), 'insert');
											BlockingUtil.wait();
											currentMessageId = App.serverQueryXMLNode(Services.processQueryNode, reqParams, onShurfResult, onShurfFault);
										},
										function(){
											refreshGridAfterProcEnd(curDataAdapter.currentGridDescr.layerId, []);
										}, cancelShurfProcess, true);
								}
							});
							gridSTOILIDataListForm.build();
						}
						break;
					//Задача шурфовки. Конец
					//кнопка в гридах архивах - дублирование двойного клика
					case 'doubleClickEvent':
						if(dataObj[0] === undefined) break;
						var curObjectId = curDataAdapter.currentGridDescr.layerId + ":" + dataObj[0].ID;
						//Добавляем div панели свойств текущего грида
						var gridPropPanelId = 'divPPanel' + currentGrid.id;
						var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var opener = "#" + widgetElementId;
						if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
							opener = 'body';
							$('body').append(gridPropPanelDiv);
						}
						else{
							$('#' + widgetElementId).append(gridPropPanelDiv);
						}
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: ''}],
							opener: opener,
							openerType: 'grid',
							panelSize: {propPanelWidth:curDataAdapter.currentGridDescr.propPanelWidth, propPanelHeight:curDataAdapter.currentGridDescr.propPanelHeight},
							handlers:{
								calculateObjectSizeCallback: function(params){

								},
								closeCallback: function (dataObj) {
									//Сохраняем размеры панели свойств, которую уже открывали, чтобы следующие открываемые были того же размера (но не со свернувшейся)
									if ($('#' + gridPropPanelId).outerWidth()>50 && $('#' + gridPropPanelId).outerHeight()>50) {
										curDataAdapter.currentGridDescr.propPanelWidth = $('#' + gridPropPanelId).outerWidth();
										curDataAdapter.currentGridDescr.propPanelHeight = $('#' + gridPropPanelId).outerHeight();
									}
								}
							}
						});
						break;

					//ДЕТАЛИЗАЦИЯ из годового плана
					case 'shurfDetailEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования. из годового плана
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(curRowData && curRowData.ID && eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var preParentFilter = undefined;
							var fullLayerId = '';
							var parentRoughParams = curRowData;
							var parentData = undefined;
							if(gridWidget) {
								preParentFilter = gridWidget.staticParentRoughFilter;
								fullLayerId = gridWidget.fullLayerId;
								parentData = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams : [];
								parentRoughParams.PARENT_FULL_LAYER_ID = fullLayerId.replace('*','#');
								parentRoughParams.PARENT_GRID_TITLE = gridWidget.title;
								parentRoughParams.PARENT_GRID_FILTER = gridWidget.dataAdapter.currentGridDescr.currentFilter;
								parentRoughParams.PARENT_GRID_ROW_ID = dataObj[0].ID;
								parentData.push(parentRoughParams);
								parentRoughFilter = '8=8';
							}
							var panelTitle = gis_gridwidget_136;
							ExternalInteraction.openGrid({
								data: {
									ILI_INSP_FILTER:dataObj[0].ID,
									ILI_LBL:dataObj[0].ILI_LBL//проброс в запрос на получение заголовка грида
								},
								gridId: eventParamsObj.layerid+"_LIST",
								label: panelTitle,
								parentRoughFilter: parentRoughFilter,
								parentRoughParams: parentData,
								staticParentRoughFilter: preParentFilter,
								fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid,
								parentGrid: currentGrid.id,
								position: 1,//2-я по очереди,
								reload: true,
								forceTopFilter: true,
							}, function(childGridId){
								var ch = childGridId+'|'+eventParamsObj.layerid+'|'+curRowData.ID
								$(currentGrid).data('gridChild', ch );
							});
						}
						break;
					//ДЕТАЛИЗАЦИЯ грид шурфовок
					case 'showSheetEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var panelTitle = gis_gridwidget_73;
							var openInSameTab = false;
							var position = 2;
							if(eventParamsObj.layerid === 'PODS_STO_REPAIR_SHEET_RELOAD') {
								panelTitle = gis_gridwidget_74;
								position = -1;
							}
							else {
								//openInSameTab = true;
								position = 2;
							}
							var ili_label = '';
							var lblSelector = $('#btngrouptoolbardiv_'+currentGrid.id);//btngrouptoolbardiv_jqxgridid4504_GRID
							if(lblSelector.length > 0) {
								var titleDiv = lblSelector.parent().find('.toolbar-title-grid');
								if(titleDiv.length){
									ili_label = titleDiv.text();
								}

							}
							var iliInspFilter = undefined;
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "ILI_INSP_FILTER" )
									iliInspFilter = item.value;
							});
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var preParentFilter = undefined;
							var fullLayerId = '';
							var parentRoughParams = curRowData;
							var parentData = undefined;
							if(gridWidget) {
								preParentFilter = gridWidget.staticParentRoughFilter;
								fullLayerId = gridWidget.fullLayerId;
								parentData = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams : [];
								parentRoughParams.PARENT_FULL_LAYER_ID = fullLayerId.replace('*','#');
								parentRoughParams.PARENT_GRID_TITLE = gridWidget.title;
								parentRoughParams.PARENT_GRID_FILTER = gridWidget.dataAdapter.currentGridDescr.currentFilter;
								parentRoughParams.PARENT_GRID_ROW_ID = dataObj[0].ID;
								parentData.push(parentRoughParams);
								parentRoughFilter = '8=8';
							}
							var selectedIndex = GridUtil.getSelectedTab();
							ExternalInteraction.openGrid({
								data: {
									ILI_INSP_FILTER: iliInspFilter, // обязательное условие!
									ILI_INSPECTION_ID: dataObj[0].ILI_INSPECTION_ID,
									BEGIN_MEASURE: dataObj[0].BEGIN_MEASURE,
									END_MEASURE: dataObj[0].END_MEASURE,
									ROUTE_ID: dataObj[0].ROUTE_ID,
									SHEET_ID: dataObj[0].ID,
									STO_ILI_INSP_EVENT_ID:dataObj[0].STO_ILI_INSP_EVENT_ID,
									ROUTE_DESCR:dataObj[0].ROUTE_DESCR,//проброс в запрос на получение заголовка грида
									PARENT_DESCR: ili_label
								},
								gridId: eventParamsObj.layerid+"_LIST",
								label: panelTitle,
								parentRoughFilter: parentRoughFilter,
								parentRoughParams: parentData,
								staticParentRoughFilter: preParentFilter,
								fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid,
								parentGrid: currentGrid.id,
								position: position,//3-я по очереди
								reload: true,
								forceTopFilter: true,
							}, function(childGridId){
								var ch = childGridId+'|'+eventParamsObj.layerid+'|'+curRowData.ID
								$(currentGrid).data('gridChild', ch );
							});
							if(openInSameTab)
								GridUtil.closeTab(selectedIndex);
						}
						break;
					case 'showDetailEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var preParentFilter = undefined;
							var fullLayerId = '';
							var parentRoughParams = curRowData;
							var parentData = undefined;
							if(gridWidget) {
								preParentFilter = gridWidget.staticParentRoughFilter;
								fullLayerId = gridWidget.fullLayerId;
								parentData = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams : [];
								parentRoughParams.PARENT_FULL_LAYER_ID = fullLayerId.replace('*','#');
								parentRoughParams.PARENT_GRID_TITLE = gridWidget.title;
								parentRoughParams.PARENT_GRID_FILTER = gridWidget.dataAdapter.currentGridDescr.currentFilter;
								parentRoughParams.PARENT_GRID_ROW_ID = dataObj[0].ID;
								parentData.push(parentRoughParams)
							}
							var parentRoughFilter = '';
							if(eventParamsObj.layerid.indexOf('SUTSTPA') !== -1){
								var layers = (eventParamsObj.layerid)? eventParamsObj.layerid.split('|'):[];
								var grids = (eventParamsObj.gridid)? eventParamsObj.gridid.split('|'):[];
								var panelTitles = (eventParamsObj.paneltitle)? eventParamsObj.paneltitle.split('|'):[];
								var descrColumns = (eventParamsObj.descrcolumns)? eventParamsObj.descrcolumns.split('|'):[];
								if(descrColumns && descrColumns.length > 0){
									var pFilterArr = [];
									descrColumns.forEach(function(col){
										var val = curRowData[col.toUpperCase()];
										if(val) val = val.xmlEscape();
										if(col=== 'sql_query')
											pFilterArr.push(val);
										else
											pFilterArr.push(col + "='" + val + "'");
										//data[col] = curRowData[col.toUpperCase()];
									})
									if(pFilterArr.length > 0)
										parentRoughFilter = pFilterArr.join(' and ');
								}
								layers.forEach(function(layerName, i){
									var childFullLayerId = layerName;
									if(layerName.indexOf('#') === -1){
										var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(layerName);
										childFullLayerId = (layer && layer.layerQueryId) ? layer.layerQueryId + '#' + layerName : '';
									}
									else layerName = layerName.split('#')[1];
									var gridId = layerName + '_LIST';
									if(grids[i]) gridId = grids[i];
									var panelTitle = (panelTitles[i])?panelTitles[i]:'';
									//удаляем все формы фильтра для дашбордов
									var filterMap = i === 0;
									$('.search-engine-filters__grid').remove();
									ExternalInteraction.openGrid({
										singleTab: true, /// открывать грид только в одной гладке в TabManager
										parentRoughFilter: parentRoughFilter,
										parentRoughParams: parentData,
										staticParentRoughFilter: preParentFilter,
										gridId: gridId,
										label: panelTitle,
										fullLayerId: childFullLayerId,
										parentGrid: currentGrid.id,
										reload: true,
										forceTopFilter: true,
										showDashboard: (WidgetMap && WidgetMap.config && WidgetMap.config.dashboard && WidgetMap.config.dashboard.showDashboard === false)?false:true,
										ignoreLabelColumn: false,
										filterMap: filterMap,
									});
								})
							}
						}
						break;
					case 'showDetailKranSvodEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var parentRoughFilter = '';
							if(eventParamsObj.layerid.indexOf('SUTSTPA') !== -1){
								var layers = (eventParamsObj.layerid)? eventParamsObj.layerid.split('|'):[];
								var panelTitles = (eventParamsObj.paneltitle)? eventParamsObj.paneltitle.split('|'):[];
								var descrColumns = (eventParamsObj.descrcolumns)? eventParamsObj.descrcolumns.split('|'):[];
								if(descrColumns && descrColumns.length > 0){
									var pFilterArr = [];
									descrColumns.forEach(function(col){
										var val = curRowData[col.toUpperCase()];
										if(val) val = val.xmlEscape();
										if(col=== 'sql_query')
											pFilterArr.push(val);
										else
											pFilterArr.push(col + "='" + val + "'");
										//data[col] = curRowData[col.toUpperCase()];
									})
									if(pFilterArr.length > 0)
										parentRoughFilter = pFilterArr.join(' and ');
								}
								//откарываем форму выбора диаметров
								GridUtil.showDiametersDialog(function(diams){
									layers.forEach(function(layerName, i){
										if(diams)
											parentRoughFilter = parentRoughFilter.replace('{DIAM}', diams);
										var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(layerName);
										var fullLayerId = (layer && layer.layerQueryId) ? layer.layerQueryId + '#' + layerName : '';
										var panelTitle = (panelTitles[i])?panelTitles[i]:'';
										var filterMap = i === 0;
										ExternalInteraction.openGrid({
											parentRoughFilter: parentRoughFilter,
											gridId: layerName+"_LIST",
											label: panelTitle,
											fullLayerId: fullLayerId,
											parentGrid: currentGrid.id,
											reload: true,
											forceTopFilter: true,
											filterMap: filterMap,
										});
										GridUtil.centerOnMap(layerName, parentRoughFilter);
									})
								});
							}
						}
						break;
					case 'showDetailKranUselSvodEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var parentRoughFilter = '';
							if(eventParamsObj.layerid.indexOf('SUTSTPA') !== -1){
								var layers = (eventParamsObj.layerid)? eventParamsObj.layerid.split('|'):[];
								var panelTitles = (eventParamsObj.paneltitle)? eventParamsObj.paneltitle.split('|'):[];
								var descrColumns = (eventParamsObj.descrcolumns)? eventParamsObj.descrcolumns.split('|'):[];
								if(descrColumns && descrColumns.length > 0){
									var pFilterArr = [];
									descrColumns.forEach(function(col){
										var val = curRowData[col.toUpperCase()];
										if(val) val = val.xmlEscape();
										if(col=== 'sql_query')
											pFilterArr.push(val);
										else
											pFilterArr.push(col + "='" + val + "'");
										//data[col] = curRowData[col.toUpperCase()];
									})
									if(pFilterArr.length > 0)
										parentRoughFilter = pFilterArr.join(' and ');
								}
								//откарываем форму выбора диаметров
								GridUtil.showLpusDialog(function(lpus){
									layers.forEach(function(layerName, i){
										if(lpus)
											parentRoughFilter = parentRoughFilter.replace('{LPU}', lpus);
										var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(layerName);
										var fullLayerId = (layer && layer.layerQueryId) ? layer.layerQueryId + '#' + layerName : '';
										var panelTitle = (panelTitles[i])?panelTitles[i]:'';
										var filterMap = i === 0;
										ExternalInteraction.openGrid({
											parentRoughFilter: parentRoughFilter,
											gridId: layerName+"_LIST",
											label: panelTitle,
											fullLayerId: fullLayerId,
											parentGrid: currentGrid.id,
											reload: true,
											forceTopFilter: true,
											filterMap: filterMap,
										});
										//GridUtil.centerOnMap(layerName, parentRoughFilter);
									})
								});
							}
						}
						break;
					case 'ShowCarouselEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						var carouselForm = new CarouselForm({data:curRowData, layerName: curDataAdapter.currentGridDescr.layerId});
						carouselForm.build()
						break;
					case 'ShowMapEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						params = [{name:"mdl", value:"main_js.html"}];
						
						if(eventParamsObj.layerid === 'WATERWAY_CROSS'){
							if(curRowData.ZONE_ID !== undefined)
								params.push( {name:"ZONE_ID", value:curRowData.ZONE_ID});
						}
						else{
							//ex. objects=PODS_COMPRESSOR_STATION:13001863
							params.push( {name:"objects", value:eventParamsObj.layerid+':'+dataObj[0].ID});
							params.push( {name:"centering", value: true});
						}
						if(eventParamsObj !== undefined){
							if(eventParamsObj.task !== undefined && eventParamsObj.task !== '')
								taskName = eventParamsObj.task;
						}
							
						if(eventParamsObj.request || eventParamsObj.layerid === 'WATERWAY_CROSS' ){
							GridUtil.checkAvailableShowMap(curRowData.ZONE_ID, eventParamsObj.request, function(res){
								if(res) {
									//upd. 09.02.22 ищем координаты и масштаб водного перехода и передаем ll,z в урл, для точечной центровки в задаче
									MapUtil.getWaterwayGeoById(eventParamsObj.layerid, dataObj[0].ID, function(geo){
										if(geo){
											var minZoom = (App.config.MAP_CENTERING_MIN_ZOOM) ? Number(App.config.MAP_CENTERING_MIN_ZOOM) : 18;
											if (minZoom > 18 /* в 1см 13м */)
												minZoom = 18;
											params.push({name:'ll', value: geo.join()});
											params.push({name:'z', value: minZoom});
											GridUtil.showOnMap(taskName, params);
										}
										else App.confirmDialog(gis_gridwidget_158, null, {title: gis_core_1});
									});
								}
								else App.confirmDialog(gis_gridwidget_158, null, {title: gis_core_1});
							});
						}
						else
							GridUtil.showOnMap(taskName, params)
						
						break;
					case 'ShowCasEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						var stationBegin = curRowData.STATION_BEGIN;
						var stationEnd =  curRowData.STATION_END;
						if( stationBegin === undefined || stationEnd === undefined){
							if(curRowData.STATION !== undefined){
								var station = parseFloat(curRowData.STATION);
								//для километров выставляем +/- 300 метров от station
								stationBegin = (station - 0.3).toFixed(2);
								stationEnd = (station + 0.3).toFixed(2);
							}
							else{
								App.errorReport(gis_gridwidget_46, gis_gridwidget_49, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_64'});
								return;
							}
						}
						if(eventParamsObj && eventParamsObj.task)
							taskName = eventParamsObj.task;
						if(eventParamsObj && eventParamsObj.layerid === 'WATERWAY_CROSS'){
							params = {
								lineId: curRowData.LINE_ID,
								beginKm: stationBegin,
								endKm: stationEnd,
								ZONE_ID: curRowData.ZONE_ID,
								title: gis_head55_4,
							}
							var profileChooserForm  = new CASProfileChooserForm({
								zoneId:  curRowData.ZONE_ID,
								callback: function(profiles){
									//TODO добавить обработку выбранных профилей
									params.PROFILES = encodeURIComponent(JSON.stringify(profiles));
									GridUtil.showOnCas(taskName, params);
								}
							});
							profileChooserForm.build();
						}
						else{
							params = {
								lineId: curRowData.LINE_ID,
								beginKm: stationBegin,
								endKm: stationEnd,
							}
							GridUtil.showOnCas(taskName, params);
						}

						break;
					//вызов задачи 'Отвязать репер' Разрыв связи репера с точкой на карте
					case 'UnlinkReperEvent':
						if(dataObj[0] === undefined || dataObj[0].ID === undefined) break;
						function fault(inputXmlStr){
						}
						function result(inputXmlStr){
						}
						sendingData = '<data ID="' + dataObj[0].ID + '" />';
						var userId = Auth.getUserId();
						var userLogin = Auth.getUserName();
						requestParams = {
							descrId: 'GAZPROM_ADM_SEM.xml#VTD_CORR_UNLINK',
							descrType: 'insert',
							data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' + sendingData + '</root>'
						};
						App.serverQueryXMLNodeWithTries(Services.processQueryNode, requestParams, result, fault);
					break;
					//Выполнение произвольных команд с передачей в них выбранных идентификаторов
					case 'ExecuteQueryEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						var requestId = eventParamsObj['request'];
						var selectedIds = [dataObj[0]["ID"]];
						GridUtil.executeQuery(requestId, 'insert', selectedIds, function(){
							layerId = curDataAdapter.currentGridDescr.layerId;
							var selectedObject = layerId + ':' + selectedIds.join();
							App.syncManager.callSync(selectedObject,'grid', undefined, SyncTypes.TYPE_3);
							App.confirmDialog(gis_gridwidget_157, null, {title:gis_core_1});
						});
						break;
					//Выполнение произвольных запросов с передачей в них выбранных идентификаторов и результат выводить в excel
					case 'ExecuteExcelQueryEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						var requestId = eventParamsObj['request'];
						var selectedIds = [dataObj[0]["ID"]];
						GridUtil.executeExcelQuery(requestId, 'select', selectedIds);
						break;
					//показ окна выбора гридов для "проваливания" внутрь
					case 'ListChooserEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						if(eventParamsObj && eventParamsObj.listrendererparams) {
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var preParentFilter = undefined;
							var fullLayerId = '';
							var parentRoughParams = dataObj[0];
							var parentData = undefined;
							if(gridWidget) {
								preParentFilter = gridWidget.parentRoughFilter;
								fullLayerId = gridWidget.fullLayerId;
								// если был открыт родителем
								parentData = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams : [];
								parentRoughParams.PARENT_FULL_LAYER_ID = fullLayerId.replace('*','#');
								parentRoughParams.PARENT_GRID_TITLE = gridWidget.title;
								parentRoughParams.PARENT_GRID_FILTER = gridWidget.dataAdapter.currentGridDescr.currentFilter;
								parentRoughParams.PARENT_GRID_ROW_ID = dataObj[0].ID;
								parentData.push(parentRoughParams)
							}
							var position = [event.clientX, event.clientY];//[event.x, event.y];

							//отправляем в фильтр значения в колонках в качестве параметров <var>
							GridUtil.showGridListForm(eventParamsObj.listrendererparams, position, function(selectedGridObj){
								//var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(selectedGridObj.layerId);
								var childFullLayerId = selectedGridObj.layerId;
								//upd. 14.02.22 возможность указать отдельный фильтр для каждой кнопки
								parentRoughFilter = GridUtil.composeFilterStrByData(selectedGridObj.filter, dataObj[0]);
								ExternalInteraction.openGrid({
									singleTab: true, /// открывать грид только в одной гладке в TabManager
									parentRoughFilter: parentRoughFilter,
									parentRoughParams: parentData,
									staticParentRoughFilter: preParentFilter,
									gridId: selectedGridObj.gridId,
									label: selectedGridObj.title,
									fullLayerId: childFullLayerId,
									parentGrid: currentGrid.id,
									reload: true,
									forceTopFilter: true,
									showDashboard: (WidgetMap && WidgetMap.config && WidgetMap.config.dashboard && WidgetMap.config.dashboard.showDashboard === false)?false:true,
									ignoreLabelColumn: false,
									filterMap: true,
								});
							});
						}
						break;
				}
			}

			/* ГРУППОВАЯ КНОПКА ГРИДА. Если есть свойство clickevent - значит это вызов с групповой кнопки грида. Нужно обработать вызов согласно clickevent
			 Типы clickevent: ru.corelight.business.events.GridFilterEvent, ru.corelight.business.events.ExportToGPXEvent, ru.corelight.business.events.CreateObjectEvent,
			 ru.corelight.business.events.ShowOnMapEvent, ru.corelight.business.events.ExportToExcelEvent, ru.corelight.business.events.RemoveGridRowEvent
			 */
			if (eventParamsObj.hasOwnProperty('clickevent')) {
				if (GridButtonsWithPopup && GridButtonsWithPopup.indexOf(eventParamsObj['clickevent']) !== -1)
					widgetMoveWindowToPosition('grid','restore_default');
				switch (eventParamsObj['clickevent']) {
					/*началоо задач по шурфовкам*/
					/*грид "годовой план шурфовок"*/
					//ГРУППА.ПЕРЕЙТИ НА УРОВЕНЬ ВВЕРХ из потомка грида
					case 'showDetailFromChildEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования из отдельной ведомости шурфовок
						var ili_label = '';
						var lblSelector = $('#btngrouptoolbardiv_'+currentGrid.id);//btngrouptoolbardiv_jqxgridid4504_GRID
						if(lblSelector.length > 0){
							var titleDiv = lblSelector.parent().find('.toolbar-title-grid');
							if(titleDiv.length)
								ili_label = titleDiv.text();
						}

						var topFilter = curDataAdapter.currentGridDescr.topFilter;
						var duplicateGrid = (WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true)
						if(eventParamsObj){
							var panelTitle = eventParamsObj.paneltitle;
							var parentGrid = $(currentGrid).data('parentGrid');
							var data = {};
							if(topFilter){
								topFilter.forEach(function(item){
									data[item.name] = item.value
									/*if(item.name === "ILI_INSP_FILTER" || item.name === "ILI_INSPECTION_ID")
										iliInspFilter = item.value;*/
									if(item.name === 'PARENT_DESCR')// если пришла шапка от родителя, то в него же и пробрасываем назад
										ili_label = item.value;
								});
							}
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var parentFullLayerId = '', parentLayerId = '';
							if(gridWidget) {
								parentFullLayerId = (gridWidget.parentRoughParams)?gridWidget.parentRoughParams.PARENT_FULL_LAYER_ID:'';
								parentLayerId = parentFullLayerId.split('#')[1];
								panelTitle = (gridWidget.parentRoughParams)?gridWidget.parentRoughParams.PARENT_GRID_TITLE:'';
							}
							var fullLayerId = parentFullLayerId;
							ExternalInteraction.openGrid({
								data: data,
								gridId: parentLayerId+"_LIST",
								label: panelTitle,
								fullLayerId: fullLayerId,
								childGrid: currentGrid.id,
								position: -1,
								reload: true,
								forceTopFilter: true,
							}, function(parentGridId){
								$(currentGrid).data('parentGrid', 'jqxgrid' + parentGridId );
							});
						}
						else
							App.confirmDialog(gis_gridwidget_138)
						break;
					//ГРУППА. Показать всё. Для случая открытия грида из родительского
					case 'showAllDataEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования из отдельной ведомости шурфовок
						GridUtil.emulateShowAllClick(currentGrid.id, false, false);
						break;
					//ГРУППА. Перейти на уровень вверх
					case 'showParentGridEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования из отдельной ведомости шурфовок
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var gridWidget = App.GridManager.getByGridId(widgetElementId);
						var staticParentRoughFilter = undefined;
						var parentFullLayerId = '', parentLayerId = '', panelTitle = '';
						var parentData = undefined;
						var parentGridFilter = undefined;
						var parentGridRowId = undefined;//идентификатор родителя, чтобы его выделить при переходе
						if(gridWidget) {
							staticParentRoughFilter = gridWidget.staticParentRoughFilter;
							//забираем последний элемент - это первый родитель
							var parentParams = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams.pop():{};
							parentData = gridWidget.parentRoughParams;
							parentFullLayerId = parentParams.PARENT_FULL_LAYER_ID || '';
							panelTitle = parentParams.PARENT_GRID_TITLE || '';
							parentGridFilter = parentParams.PARENT_GRID_FILTER;
							parentGridRowId = parentParams.PARENT_GRID_ROW_ID;
							parentLayerId = parentFullLayerId.split('#')[1];
						}
						if(!parentFullLayerId){
							App.confirmDialog(gis_gridwidget_138, null, {title: gis_core_1});
							break;
						}
						//TODO временно тут удаляем прошлый фильтр
						$('.search-engine-filters__grid').remove();
						ExternalInteraction.openGrid({
							gridId: parentLayerId + "_LIST",
							label: panelTitle,
							parentGridFilter: parentGridFilter,
							parentGridRowId: parentGridRowId,
							fullLayerId: parentFullLayerId,
							parentRoughFilter: staticParentRoughFilter,
							parentRoughParams: parentData,
							reload: true,
							forceTopFilter: true,
							singleTab: true,
							showDashboard: (WidgetMap && WidgetMap.config && WidgetMap.config.dashboard && WidgetMap.config.dashboard.showDashboard === false)?false:true,
						});
						break;
					//ГРУППА.ПЕРЕЙТИ НА УРОВЕНЬ ВВЕРХ  из списка ведомостей и списка дефектов у ведомости
					case 'shurfDetailFromSheetEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования из отдельной ведомости шурфовок
						var ili_label = '';
						var lblSelector = $('#btngrouptoolbardiv_'+currentGrid.id);//btngrouptoolbardiv_jqxgridid4504_GRID
						if(lblSelector.length > 0){
							var titleDiv = lblSelector.parent().find('.toolbar-title-grid');
							if(titleDiv.length)
								ili_label = titleDiv.text();
						}
						var topFilter = curDataAdapter.currentGridDescr.topFilter;
						var iliInspFilter = '';
						var yearInspFilter = '';
						if(topFilter){
							topFilter.forEach(function(item){
								if(item.name === "ILI_INSP_FILTER" || item.name === "ILI_INSPECTION_ID"){
									if(item.value)
										iliInspFilter = item.value;
								}
								if(item.name === 'PARENT_DESCR')// если пришла шапка от родителя, то в него же и пробрасываем назад
									ili_label = item.value;
								if(item.name === 'YEAR_INSP')// если пришла шапка от родителя, то в него же и пробрасываем назад
									yearInspFilter = item.value;
							});
						}
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var gridWidget = App.GridManager.getByGridId(widgetElementId);
						var staticParentRoughFilter = undefined;
						var parentFullLayerId = '', parentLayerId = '', panelTitle = '';
						var parentData = undefined;
						if(gridWidget) {
							staticParentRoughFilter = gridWidget.staticParentRoughFilter;
							//забираем последний элемент - это первый родитель
							var parentParams = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams.pop():{};
							parentData = gridWidget.parentRoughParams;
							parentFullLayerId = parentParams.PARENT_FULL_LAYER_ID || '';
							panelTitle = parentParams.PARENT_GRID_TITLE || '';
							parentLayerId = parentFullLayerId.split('#')[1];
						}
						if(!parentFullLayerId){
							App.confirmDialog(gis_gridwidget_138, null, {title: gis_core_1});
							break;
						}
						if(!iliInspFilter) {
							App.confirmDialog(gis_gridwidget_138, null, {title: gis_core_1});
						}
						else{
							var data = {};
							if(parentFullLayerId.indexOf('PODS_STO_SHURF_PLAN') !== -1){
								data.YEAR_INSP = yearInspFilter;
							}
							else{
								data.ILI_INSP_FILTER = iliInspFilter;
								data.ILI_LBL = ili_label;//проброс в запрос на получение заголовка грида,
							}
							ExternalInteraction.openGrid({
								data: data,
								gridId: parentLayerId + "_LIST",
								label: panelTitle,
								parentRoughFilter: staticParentRoughFilter,
								parentRoughParams: parentData,
								fullLayerId: parentFullLayerId,
								childGrid: currentGrid.id,
								position: (parentFullLayerId.indexOf('PODS_STO_SHURF_PLAN') !== -1) ? 0 : 1,
								reload: true,
								forceTopFilter: true,
							}, function(parentGridId){
								$(currentGrid).data('parentGrid', 'jqxgrid' + parentGridId );
							});
						}

						break;
					//ГРУППА.вызов задачи 'Экспорт в эксель в задаче шурфовки'
					case 'exportToExcelFuturePlanEvent':
						//забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
						limitExportExcel = NaN;
						if (curDataAdapter.currentGridDescr.excelMaxExport!==undefined && curDataAdapter.currentGridDescr.excelMaxExport!==null && !isNaN(curDataAdapter.currentGridDescr.excelMaxExport)) {
							limitExportExcel = parseInt(curDataAdapter.currentGridDescr.excelMaxExport);
						} else if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
							limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						// isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
						if (limitExportExcel && !isNaN(limitExportExcel) && dataObj.length > limitExportExcel)
						{
							alertForm.width = 350;
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+gis_gridwidget_18+limitExportExcel+".<br/>"
								+gis_gridwidget_19+limitExportExcel+gis_gridwidget_20,gis_gridwidget_21);
							//Устанавливаем реальный лимит, который прописан в конфиге, чтобы избежать ошибки сервера (во флеше нельзя было выбрать более 1000 записей в принципе)
							dataObj = dataObj.slice(0,limitExportExcel);
						}
						else
						{
							//Вместо dataObj.length выводим общее число записей грида
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+ gis_gridwidget_22,gis_gridwidget_23);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_FUTURE_PLAN_LIST";
								extDataId = "STO_EXPORT.xml#STO_FUTURE_PLAN_LIST";
								ExportUtil.exportShurfToExcel(dataObj, fileName, layerId, extDataId); //excelTemplate для группы всегда "server_export"
							}
						});
						break;
					//ГРУППА.вызов задачи 'Редактировать характеристики трубопровода'
					case 'editRouteOptionsEvent':
						if(dataObj[0] === undefined)
							break;
						var routeIds = [];
						var lineIds = [];
						dataObj.forEach(function(value){
							if(value.ROUTE_ID) routeIds.push(value.ROUTE_ID);
							if(value.LINE_ID) lineIds.push(value.LINE_ID);
						});

						var smallLayerId = 'PODS_STO_PIPE_SEGMENT_PARAMS';
						var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(smallLayerId);
						if (layer !== undefined && layer.filter !== '') {
							var rr = [];
							rr.push({name: "LINE_ID", value: lineIds.join(), layerName: smallLayerId});
							WidgetMap.currentRoughFilter = rr;
							WidgetMap.currentFilter[smallLayerId] = [];
							WidgetMap.currentFilter[smallLayerId].push({
								layerName: smallLayerId,
								filter: 'LINE_ID',
								value: lineIds.join()
							});
							if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
								curDataAdapter.currentGridDescr.layerManager.clearLayer(smallLayerId, true);
								//curDataAdapter.currentGridDescr.layerManager.enableLayer(smallLayerId);
								layer.layer.setVisible(true);
							}
						}

						ExternalInteraction.openGrid({
							data: {
								ROUTE_ID_FILTER:routeIds.join()
							},
							gridId: "PODS_STO_PIPE_SEGMENT_PARAMS_LIST",
							label: 'Опросный лист',
							fullLayerId: 'PODS_INSP_Layers.xml#PODS_STO_PIPE_SEGMENT_PARAMS'
						});
						break;
					//ГРУППА.Сформировать MapInfo-комплект
					case 'createMapInfoShurfEvent':
						if(dataObj[0] === undefined)
							break;
						var inspectionIds = [];
						dataObj.forEach(function(value){
							if(value.ID)
								inspectionIds.push(value.ID);
						});
						ExportUtil.exportAdmPicketingToExcel([{ILI_INSP_FILTER:inspectionIds.join()}], 'server_export', 'STO_EXPORT.xml#STO_ILI_MAPINFO');
						break;
					//ГРУППА.вызов задачи 'Рассчитать срок проведения следующей ВТД'(Удалена)
					case 'calcFutureDateILIEvent':
						alert("вызов задачи 'Рассчитать сок проведения следующей ВТД");
						break;
					//ГРУППА.вызов задачи 'Сформировать сводную таблицу планирования ВТД'(Удалена)
					case 'createILIFormPlanEvent':
						alert("вызов задачи 'Сформировать сводную таблицу планирования ВТД");
						break;

					/*Грид "Ведомость аномалий"*/
					//ГРУППА.задача "добавить дефект"
					case 'addShurfEvent':
						if(curDataAdapter.currentGridDescr !== undefined){
							var rows = GridUtil.getFullRowsData(currentGrid);
							var gridSTOILIDataListForm = new GridSTOILIDataListForm({
								gridId:currentGrid.id,
								dataProvider:'STO_SEM.xml#PODS_STO_ILI_DATA_SHEET_ADD',
								items: rows,
								layerId:curDataAdapter.currentGridDescr.layerId,
								filter:curDataAdapter.currentGridDescr.topFilter,
								applyCallback:function(array){
									var allDatas = array;

									//в цикле сохраняем все записи из грида
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_55,allDatas,that,
										function (obj) {
											//Заведомо обнуляем поля перед сохранением
											delete obj.TYPE;
											delete obj.DESCRIPTION;
											delete obj.COMMENTS;
											//у ремонтов доп. поля
											var prvd = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST';
											if(curDataAdapter.currentGridDescr.layerId === "PODS_STO_REPAIR_SHEET_RELOAD"){
												delete obj.WIDTH;
												delete obj.LENGTH;
												prvd = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
											}
											var reqParams = DBUtil.getReqParams(prvd, DBUtil.serializeData(obj), 'insert');
											BlockingUtil.wait();
											currentMessageId = App.serverQueryXMLNode(Services.processQueryNode, reqParams, onShurfResult, onShurfFault);
										},
										function(){
											refreshGridAfterProcEnd(curDataAdapter.currentGridDescr.layerId, []);
										}, cancelShurfProcess, true);
								}
							});
							gridSTOILIDataListForm.build();
						}
						break;
					//ГРУППА.задача "выполнить анализ для определения дефектов подлежащих шурфовке"
					case 'gridColorFilterEvent':
						var rows = GridUtil.getFullRowsData(currentGrid);
						if(rows.length == 0){
							App.confirmDialog(gis_gridwidget_80);
							break;
						}
						if(curDataAdapter.currentGridDescr !== undefined){
							var сolorFilterForm = new ColorFilterForm({
								items: rows,
								currentGridDescr:curDataAdapter.currentGridDescr,
								currentGrid: currentGrid,
								colorRowValidations: curDataAdapter.currentGridDescr.colorRowValidations,
								colorValidations: curDataAdapter.currentGridDescr.colorValidations,
								closeCallback: that.onColorFilterFormClose,
								gridThat: that
							});
							сolorFilterForm.build(currentGrid.id+'_gridColorFilter');
						}
						break;
					//ГРУППА.вызов задачи 'Сформировать схему шурфовок'
					case 'createShurfSchemaEvent':
						var dObj = {};
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "ILI_INSPECTION_ID" || item.name === "BEGIN_MEASURE" || item.name === "END_MEASURE" ||
									item.name === "ROUTE_ID" || item.name === "SHEET_ID")
									dObj[item.name] = item.value;
							});
						}
						/*params.push({name:'ILI_INSPECTION_ID', value:dObj.ILI_INSPECTION_ID});
						params.push({name:'BEGIN_MEASURE', value:dObj.BEGIN_MEASURE});
						params.push({name:'END_MEASURE', value:dObj.END_MEASURE});
						params.push({name:'ROUTE_ID', value:dObj.ROUTE_ID});
						params.push({name:'EVENT_ID', value:dObj.EVENT_ID});*/
						var ssstr = 'shurf_schema_js.html?task=sto_shurf_schema&mdl=main_js.html&rand=46565.01184217632'
							+'&ILI_INSPECTION_ID='+dObj.ILI_INSPECTION_ID+'&BEGIN_MEASURE='+dObj.BEGIN_MEASURE+'&END_MEASURE='+dObj.END_MEASURE
							+'&ROUTE_ID='+dObj.ROUTE_ID+'&SHEET_ID='+dObj.SHEET_ID
							+'#login=editor&UID=e0e513c6-f802-4ae0-8129-df1d8087bfc2&chk=96383555b5bd11140c528aaade1227b5&ID=1045';
						window.open(ssstr);
						/*App.openTask('sto_shurf_schema', Auth.getAuthStr(),{
							ILI_INSPECTION_ID: dObj.ILI_INSPECTION_ID,
							BEGIN_MEASURE:dObj.BEGIN_MEASURE,
							END_MEASURE:dObj.END_MEASURE,
							ROUTE_ID:dObj.ROUTE_ID,
							SHEET_ID:dObj.SHEET_ID
						});*/
						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость ремонтов'
					case 'exportExcelRepairSheetEvent':
						var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
						var dObj = (firstElement.ID)?GridUtil.getFullRowDataById(currentGrid, firstElement):firstElement;
						var inspectionId = undefined;
						if(!dObj || !dObj.ID)
							break;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;

						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_REPAIR_LIST";
								extDataId = "STO_EXPORT.xml#STO_REPAIR_LIST";
								ExportUtil.exportToExcel([{ID: dObj.SHEET_ID}], fileName, layerId, extDataId);
							}
						});
						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость шурфовок'
					case 'exportExcelShurfSheetEvent':
						var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
						var dObj = (firstElement.ID)?GridUtil.getFullRowDataById(currentGrid, firstElement):firstElement;
						var sheetId = undefined;
						if(!dObj || !dObj.SHEET_ID)
							break;
						sheetId = dObj.SHEET_ID;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail == 1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_ANOM_LIST";
								extDataId = "STO_EXPORT.xml#STO_ANOM_LIST";
								ExportUtil.exportToExcel([{ID:sheetId}], fileName, layerId, extDataId);
							}
						});
						break;
					//ГРУППА.Сохранить вариант ведомости шурфовок
					case 'createExcavateSheetEvent':
						//ищем ILI_INPECTION_ID и EVENT_ID, чтобы передать дальше в панель свойств
						var sheetObj = {};
						var rangeData = {};
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							rangeData = GridUtil.formatTopFilterToObject(curDataAdapter.currentGridDescr.topFilter);
							sheetObj.ILI_INSPECTION_ID = rangeData.ILI_INSPECTION_ID;
							sheetObj.STO_ILI_INSP_EVENT_ID = rangeData.STO_ILI_INSP_EVENT_ID;
						}
						var gridSheetForm = new GridSTOSheetForm({
							data:sheetObj,
							sheetType:'excavate',
							applyCallback:function(sheetId){
								var rows = GridUtil.getFullRowsData(currentGrid);
								var allDatas = rows;
								//добавляем к каждой записи атрибут SHEET_ID для вставки
								allDatas.forEach(function(value){
									value.SHEET_ID = sheetId;
								});
								rangeData.SHEET_ID_OLD = rangeData.SHEET_ID;
								rangeData.SHEET_ID = sheetId;

								var topFilter = curDataAdapter.currentGridDescr.topFilter;
								var ili_label = '';
								if(topFilter){
									topFilter.forEach(function(item){
										if(item.name === 'PARENT_DESCR')// если пришла шапка от родителя, то в него же и пробрасываем назад
											ili_label = item.value;
									});
								}
								var reqParams = DBUtil.getReqParams('STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH_RECREATE', DBUtil.serializeData(rangeData), 'insert');
								App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
									BlockingUtil.ready();
									if (resultXML) {
										var er = HTTPServiceUtil.getError(resultXML);
										if (er !== ""){
											App.errorReport(gis_gridwidget_82, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_50'});
											return;
										}
										var duplicateGrid = (WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true)
										ExternalInteraction.openGrid({
											data: {
												ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
												BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
												END_MEASURE: rangeData.END_MEASURE,
												ROUTE_ID: rangeData.ROUTE_ID,
												SHEET_ID: sheetId,
												STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
												ROUTE_DESCR:rangeData.ROUTE_DESCR,//проброс в запрос на получение заголовка грида
												PARENT_DESCR:rangeData.PARENT_DESCR//проброс в запрос на получение заголовка родительского грида грида
											},
											gridId: eventParamsObj.gridid+"_LIST",
											label: gis_gridwidget_73,
											fullLayerId: 'STO_Layers.xml#'+eventParamsObj.gridid,
											position: 2,
											reload: true,
											forceTopFilter: true,
										});

									}
								}, function (resultXML) {
									BlockingUtil.ready();
									var er = HTTPServiceUtil.getError(resultXML);
									if (er !== "")
										App.errorReport(gis_gridwidget_82, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_51'});
								});
							}
						});
						gridSheetForm.buildNewSheet_();
						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость МТР'
					case 'createMTRSheetEvent':
						if(dataObj[0] === undefined)
							break;
						//Добавляем div панели свойств текущего грида
						//ищем ILI_INPECTION_ID и EVENT_ID, чтобы передать дальше в панель свойств
						var sheetObj = {};
						var rangeData = {};
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							rangeData = GridUtil.formatTopFilterToObject(curDataAdapter.currentGridDescr.topFilter);
							sheetObj.ILI_INSPECTION_ID = rangeData.ILI_INSPECTION_ID;
							sheetObj.STO_ILI_INSP_EVENT_ID = rangeData.STO_ILI_INSP_EVENT_ID;
						}
						var gridSheetForm = new GridSTOSheetForm({
							iliDataId:sheetObj.ILI_INSPECTION_ID,
							data:sheetObj,
							sheetType:'mtr',
							applyCallback:function(sheetId){
								if(sheetId !== undefined){
									App.notSupportedDialog('Нет возможности открыть ведомость созданную МТР, т.к. данный функционал не реализован');
								}
							}
						});
						gridSheetForm.buildNewSheet_();
						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость ремонтов'
					case 'createRepairSheetEvent':
						if(dataObj[0] === undefined)
							break;
						//Добавляем div панели свойств текущего грида
						//ищем ILI_INPECTION_ID и EVENT_ID, чтобы передать дальше в панель свойств
						var sheetObj = {};
						var rangeData = {};
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							rangeData = GridUtil.formatTopFilterToObject(curDataAdapter.currentGridDescr.topFilter);
							sheetObj.ILI_INSPECTION_ID = rangeData.ILI_INSPECTION_ID;
							sheetObj.STO_ILI_INSP_EVENT_ID = rangeData.STO_ILI_INSP_EVENT_ID;
						}
						var gridSheetForm = new GridSTOSheetForm({
							iliDataId:sheetObj.ILI_INSPECTION_ID,
							data:sheetObj,
							sheetType:'repair',
							applyCallback:function(sheetId){
								if(sheetId !== undefined){
									var allDatas = dataObj;
									allDatas.forEach(function(value){
										//value.ILI_DATA_ID = value.ID;
										value.SHEET_ID = sheetId;
									});
									//в цикле сохраняем все записи из грида
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_55,allDatas,that,
										function (obj) {
											//Заведомо обнуляем поля перед сохранением
											delete obj.TYPE;
											delete obj.DESCRIPTION;
											delete obj.COMMENTS;
											//у ремонтов доп. поля
											delete obj.WIDTH;
											delete obj.LENGTH;
											var prvd = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
											var reqParams = DBUtil.getReqParams(prvd, DBUtil.serializeData(obj), 'insert');
											BlockingUtil.wait();
											currentMessageId = App.serverQueryXMLNode(Services.processQueryNode, reqParams, onShurfResult, onShurfFault);
										},
										function(){
											ExternalInteraction.openGrid({
												data: {
													ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
													BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
													END_MEASURE: rangeData.END_MEASURE,
													ROUTE_ID: rangeData.ROUTE_ID,
													SHEET_ID: sheetId,
													STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
													ROUTE_DESCR:rangeData.ROUTE_DESCR//проброс в запрос на получение заголовка грида
												},
												gridId: eventParamsObj.gridid+"_LIST",
												label: gis_gridwidget_74,
												fullLayerId: 'STO_Layers.xml#'+eventParamsObj.gridid,
												position: -1,
												reload: true,
												forceTopFilter: true,
											});
											var clId = 'PODS_STO_REPAIR_SHEET_RELOAD';
											refreshGridAfterDelete(0, 1, false, clId);
											GridWidget.processStatusForm = null;
										}, cancelShurfProcess, true);
								}
							}
						});
						gridSheetForm.buildNewSheet_();

						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость обследовний'
					case 'createInspectionsSheetEvent':
						//забираем SHEET_ID, который пришел извне
						var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
						var dObj = (firstElement.ID)?GridUtil.getFullRowDataById(currentGrid, firstElement):firstElement;
						var sheetId = undefined;
						if((dObj === undefined || dObj.SHEET_ID === undefined) && (curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined)){
							//получаем из фильтра, который пришел от родительского грида
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "SHEET_ID")
									sheetId = item.value;
							});
						}
						if(!sheetId && dObj && dObj.SHEET_ID)
							sheetId = dObj.SHEET_ID;
						if(!sheetId){
							App.errorReport(gis_gridwidget_53, gis_gridwidget_54, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_39'});
							break;
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;

						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_PHYS_INSP_LIST";
								extDataId = "STO_EXPORT.xml#STO_PHYS_INSP_LIST";
								ExportUtil.exportToExcel([{ID:sheetId}], fileName, layerId, extDataId);
							}
						});
						break;
					//ГРУППА.вызов задачи 'Сформировать акт дополнительного дефектоскопического контроля'
					case 'createAdditionalActDefectoscopeControlEvent':
						//забираем SHEET_ID, который пришел извне
						var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
						var dObj = (firstElement.ID)?GridUtil.getFullRowDataById(currentGrid, firstElement):firstElement;
						var sheetId = undefined;
						if((dObj === undefined || dObj.SHEET_ID === undefined) && (curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined)){
							//получаем из фильтра, который пришел от родительского грида
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "SHEET_ID")
									sheetId = item.value;
							});
						}
						if(!sheetId && dObj && dObj.SHEET_ID)
							sheetId = dObj.SHEET_ID;
						if(sheetId === undefined ){
							App.errorReport(gis_gridwidget_53, gis_gridwidget_54, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_40'});
							break;
						}

						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_DOP_PHYS_LIST";
								extDataId = "STO_EXPORT.xml#STO_DOP_PHYS_LIST";
								ExportUtil.exportToExcel([{ID:sheetId}], fileName, layerId, extDataId);
							}
						});
						break;
					//ГРУППА.задача "удалить записи из списка аномалий"
					case 'deleteGroupSheetExcavateListEvent':
						try {
							dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH';
							var clId = 'PODS_STO_ILI_DATA_SHEET_RELOAD';
							if(curDataAdapter.currentGridDescr.layerId === 'PODS_STO_REPAIR_SHEET_RELOAD'){
								dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
								clId = 'PODS_STO_REPAIR_SHEET_RELOAD';
							}

							//добавляем форму выбора "удалить выбранные" либо "удалить не выбранные"
							function removeCheckedRows(){
								deletingArr = [];
								for (i = 0; i < dataObj.length; i++) {
									deletingArr.push(dataObj[i].LIST_ID);
								}
								deleteConfirmationForm = new DeleteConfirmationForm();
								deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
								var deletingIds = {ID:deletingArr.join(',')};
								//Добавляем слушатель закрытия формы
								$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
									$("body").off(CloseEvent.CLOSE);
									if (evt && evt.detail==1) {
										var reqParams = DBUtil.getReqParams('STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH', DBUtil.serializeData(deletingIds), 'delete');
										App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
											BlockingUtil.ready();
											if (resultXML) {
												var er = HTTPServiceUtil.getError(resultXML);
												if (er !== "") {
													App.errorReport(gis_gridwidget_83, gis_gridwidget_8 + er, undefined, {
														filename: gis_filename_243,
														functionname: 'gis_filename_243_52'
													});
													return;
												}
												refreshGridAfterDelete(0, deletingArr.length, false, clId, deletingArr);
											}
										},function (resultXML) {
											BlockingUtil.ready();
											var er = HTTPServiceUtil.getError(resultXML);
											if (er !== "") {
												App.errorReport(gis_gridwidget_83, gis_gridwidget_8 + er, undefined, {
													filename: gis_filename_243,
													functionname: 'gis_filename_243_53'
												});
											}
										},4);
										$(currentGrid).jqxGrid('clearselection');
									}
								});
								closeDialog();
							}
							function removeUnCheckedRows(){
								deletingArr = [];
								var rows = GridUtil.getFullRowsData(currentGrid);
								var allData = rows;
								//dataObj // тут все выбранные объекты
								//проходим по всем выделенным объектам и постепенно удаляем их из массива со всеми данными allData
								for(var item in dataObj){
									var dataId = dataObj[item].ID;
									for(var subItem in allData){
										if(allData[subItem].ID === dataId){
											allData.splice(subItem, 1);
											break;
										}
									}
								}
								for (i = 0; i < allData.length; i++) {
									deletingArr.push(allData[i].LIST_ID);
								}
								deleteConfirmationForm = new DeleteConfirmationForm();
								deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
								var deletingIds = {ID:deletingArr.join(',')};
								//Добавляем слушатель закрытия формы
								$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
									$("body").off(CloseEvent.CLOSE);
									if (evt && evt.detail==1) {
										var reqParams = DBUtil.getReqParams('STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH', DBUtil.serializeData(deletingIds), 'delete');
										App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
											BlockingUtil.ready();
											if (resultXML) {
												var er = HTTPServiceUtil.getError(resultXML);
												if (er !== "") {
													App.errorReport(gis_gridwidget_83, gis_gridwidget_8 + er, undefined, {
														filename: gis_filename_243,
														functionname: 'gis_filename_243_54'
													});
													return;
												}
												refreshGridAfterDelete(0, deletingArr.length, false, clId, deletingArr);
											}
										},function (resultXML) {
											BlockingUtil.ready();
											var er = HTTPServiceUtil.getError(resultXML);
											if (er !== "") {
												App.errorReport(gis_gridwidget_83, gis_gridwidget_8 + er, undefined, {
													filename: gis_filename_243,
													functionname: 'gis_filename_243_55'
												});
											}
										},4);
										//Снимаем выделение, поскольку выделенные элементы будут удалены
										$(currentGrid).jqxGrid('clearselection');
									}
								});
								closeDialog();
							}
							var buttons = [
								{text:gis_gridwidget_77, click:removeCheckedRows},
								{text:gis_gridwidget_78, click:removeUnCheckedRows}
							];
							var dlg = App.confirmDialog(gis_gridwidget_79, buttons, {title:gis_core_1, width:400});

							break;


						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_41'});
						}
						break;
					//ГРУППА.задача "удалить записи из списка"
					case 'deleteGroupSheetListEvent':
						try {
							dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST';
							var clId = 'PODS_STO_SHEET_EXCAVATE_LIST';
							if(curDataAdapter.currentGridDescr.layerId === 'PODS_STO_REPAIR_SHEET_RELOAD'){
								dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
								clId = 'PODS_STO_SHEET_REPAIR_LIST';
							}
							deletingArr = [];
							for (i = 0; i < dataObj.length; i++) {
								deletingObject = {rowData:dataObj[i], classId:clId, objectId:dataObj[i].LIST_ID, provider:dataRequest, propertyPanelName:""};
								deletingArr.push(deletingObject);
							}
							//SHEET_ID забираем из верхнего фильтра, который пришел извне
							//если нет SHEET_ID, то это новая ведомость и удаляем только строку
							//если есть - удаляем из БД
							var sheetId = undefined;
							if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
								//получаем из фильтра, который пришел от родительского грида
								curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
									if(item.name === "SHEET_ID"){
										sheetId = item.value;
									}
								});
							}
							if(sheetId === undefined){
								var rowindexes = $(currentGrid).jqxGrid('getselectedrowindexes');
								$(currentGrid).jqxGrid('deleterow', rowindexes);
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_28,deletingArr,that,that.deleteObject,
										refreshGridAfterDelete, null, true);
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_41'});
						}
						break;

					/*ГРУППА.конец задачи по шурфовкам*/
					/*ГРУППА */
					case 'ManageColumnsEvent'://заглушка на добавление 1-й колонки
						var da = $(currentGrid).jqxGrid('source');
						if(da.currentGridDescr !== undefined){
							var columns = GridUtil.getGridColumns(currentGrid);
							try{
								//пробуем отменить редактирование ячейки, если было начато.
								$(currentGrid).jqxGrid('endcelledit', 0, columns[0].name, true);
							}
							catch(ex){}
							var manageGridColumnsForm = new ManageGridColumnsForm({
								columns: columns,
								applyCallback: function(columns){
									that.updateDataWithColumns(currentGrid, columns);
								}
							});
							manageGridColumnsForm.build(currentGrid.id+'_manageColumns');
						}
						break;
					//ГРУППА. обвновленная версия фильтра, которая будет отображать окошко левее с гридом
					case 'ru.corelight.business.events.ExtendedGridFilterEvent':

						break;
					case 'ru.corelight.business.events.GridFilterEvent':
						//Фильтрация грида
						var da = $(currentGrid).jqxGrid('source');
						if(da.currentGridDescr !== undefined){
							curLayerObj = da.currentGridDescr.layerManager.getLayerByName(curDataAdapter.currentGridDescr.layerId);
							var showFirstBottomFilterMessage = false;
							var gw = GridUtil.getGridWidget(currentGrid);
							if(gw) {
								showFirstBottomFilterMessage = gw.showFirstBottomFilterMessage;
								gw.showFirstBottomFilterMessage = false;
							}
							var bottomFilterForm = new BottomFilterForm();
							bottomFilterForm.showFirstBottomFilterMessage = showFirstBottomFilterMessage;
							bottomFilterForm.currentGridDescr = da.currentGridDescr;
							bottomFilterForm.currentGrid = currentGrid;
							bottomFilterForm.currentFilters = da.currentGridDescr.currentFilter;
							bottomFilterForm.topFilters = da.currentGridDescr.topFilter;
							bottomFilterForm.roughFilters = da.currentGridDescr.roughFilter;
							if (curLayerObj && curLayerObj.dataProvider && !curLayerObj.dataProvider.spatial
								|| !curLayerObj || !curLayerObj.dataProvider)
								bottomFilterForm.hasSpatial = false;
							bottomFilterForm.build(currentGrid.id+'_bottomFilter');

							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, that.onBottomFilterFormClose);
						}
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.ExportToGPXEvent':
						filterStr = undefined;
						if(dataObj.length){
							var ids = [];
							dataObj.forEach(function(curObj){
								ids.push(curObj.ID);
							})
							filterStr =  'ID IN (' + ids.join(',') + ')';
						}
						//upd. 29.10.21 сказано использовать данное событие вместо самостоятельного, чтобы не менять гриды
						GridWidget.prototype.exportImportObjectsToGpxKml(filterStr, curDataAdapter.currentGridDescr, currentGrid.id);
						break;
					//ГРУППА. Импорт/Экспорт GPX/KML
					case 'ImportExportGpxKmlEvent':
						filterStr = undefined;
						if(dataObj.length){
							var ids = [];
							dataObj.forEach(function(curObj){
								ids.push(curObj.ID);
							})
							filterStr =  'ID IN (' + ids.join(',') + ')';
						}
						GridWidget.prototype.exportImportObjectsToGpxKml(filterStr, curDataAdapter.currentGridDescr, currentGrid.id);
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.CreateObjectEvent':
						//Создаем панель свойств по классу объекта - она сохраняет новый объект
						var curObjectId = eventParamsObj["layerid"];
						var bindDataTypes = (App.config.MAP_BIND_CLASSES && App.config.MAP_BIND_CLASSES.length > 0) ? App.config.MAP_BIND_CLASSES.split(',') : [];
						if (bindDataTypes.length > 0 && bindDataTypes.indexOf(curObjectId) != -1) {
							map.controls.AddObjectControl.showBindToLineForm(curObjectId, undefined, curDataAdapter.currentGridDescr.layerManager, function(){
								GridWidget.refreshGrid(currentGrid.id, false)
							});
						}
						else{

							//Добавляем div панели свойств текущего грида
							var gridPropPanelId = 'divPPanel' + currentGrid.id;
							var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
							$('#' + gridPropPanelId).remove();
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var opener = "#" + widgetElementId;
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
								opener = 'body';
								$('body').append(gridPropPanelDiv);
							}
							else{
								$('#' + widgetElementId).append(gridPropPanelDiv);
							}
							var parentParams = undefined;
							if(gridWidget){
								if(gridWidget.parentRoughParams && gridWidget.parentRoughParams.length > 0){
									parentParams = gridWidget.parentRoughParams[gridWidget.parentRoughParams.length -1];
								}
							}
							//Создаем панель свойств для текущего объекта
							$('#' + gridPropPanelId).myPropertiesPanel({
								zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
								objects:[{id: curObjectId, label: ''}],
								opener: opener,
								data: parentParams,
								openerType: 'grid',
								//panelSize: {propPanelWidth:curDataAdapter.currentGridDescr.propPanelWidth, propPanelHeight:curDataAdapter.currentGridDescr.propPanelHeight},
								handlers:{
									calculateObjectSizeCallback: function(params){

									},
									semanticCallback: function (dataObject) {
										if(dataObject.retObj && dataObject.success == true){
											var layerName = dataObject.retObj.layerId;
											var semId = dataObject.retObj.id;
											var selectedObject = layerName;
											if(semId){
												selectedObject += ':' + semId;
												//СИНХРОНИЗАЦИЯ #R5
												//25.11.2021 исправлени в рамках инц 2565
												App.syncManager.callSync(selectedObject,'grid_refresh', undefined, SyncTypes.TYPE_3);
											}
										}
									},
								}
							});
						}
						break
					//ГРУППА.
					case 'ru.corelight.business.events.CreateObjectFromMapEvent':
						//Создаем панель свойств по классу объекта - она сохраняет новый объект
						var curObjectId = eventParamsObj["layerid"];
						try{
							var roughFilter = curDataAdapter.currentGridDescr.roughFilter;
							if(WidgetMap.addObjectControl)
								WidgetMap.addObjectControl.handleAddObjectClick_({addFromTree: true, layerName: curObjectId, roughFilter:roughFilter});
						}
						catch(ex){}
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.ShowOnMapEvent':
						try {
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							if (curLayerObj==undefined || curLayerObj==null)
								break;
							//Формируем параметры для вызова функции центровки
							objectsStr = eventParamsObj["layerid"] + ":";
							var selectedItemsCount = dataObj.length;
							if(App.syncEnabled && dataObj.length > 150)//количество доступных идентификаторов для хранения в куках
								selectedItemsCount = 150;
							for (i = 0; i < selectedItemsCount; i++) {
								objectsStr += dataObj[i]["ID"];
								//К последнему ID сзади запятую не добавляем
								if (i < dataObj.length - 1) {
									objectsStr += ",";
								}
							}
							funcName = "showObjects";
							params = [{name: "objects", value: objectsStr}, {name: "select", value: true}, {name: "centering", value: true}, {name: "gridCenteringResultFunction", value: gridCenteringResultFunction},{name: "isGroupButton", value: true}];

							if(!App.syncEnabled){
								//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
								ExternalInteraction.callFunction(windowId, funcName, params);
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								widgetMoveWindowToPosition('grid');
							}
							else {
								/*var syncObjectFromCookie = App.getCookie('gis_web77_sync_select_object');
								if(syncObjectFromCookie && syncObjectFromCookie.indexOf('$') !== -1){
									var uniqueWindowId = syncObjectFromCookie.split('$')[0];
									if(uniqueWindowId === App.UNIQUE_ID);
										widgetMoveWindowToPosition('grid');
								}*/

								//1. для клика из самой вкладки делаем первоначальною центровку
								//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
								//ExternalInteraction.callFunction(windowId, funcName, params);
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								widgetMoveWindowToPosition('grid');
								//2. и параллельно отправляем событие на центровку через синхронизацию
								//СИНХРОНИЗАЦИЯ #T6
								//СИНХРОНИЗАЦИЯ #T7
								//СИНХРОНИЗАЦИЯ #T8
								var selectedObject = objectsStr;
								if (selectedObject)
									App.syncManager.callSync(selectedObject, 'grid', undefined, SyncTypes.TYPE_2);
								if(selectedItemsCount !== dataObj.length)
									App.confirmDialog(gis_gridwidget_139, null, {title:gis_core_1, width:400, html: true});
							}


						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_23'});
						}
						break;

					//ГРУППА. персональный групповой экспорт в эксель. Из кнопки передается идентификатор шаблона, в который требуется выгружать данные
					// эмуляция строчной кнопки грида
					case 'ru.corelight.business.events.GroupExportToExcelEvent':
						fileName = App.generateUUID() + ".xls";
						extDataId =  eventParamsObj.request;
						ExportUtil.exportToExcel(dataObj, fileName, eventParamsObj.layerid, extDataId, undefined, true);
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.ExportToExcelEvent':
						//забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
						limitExportExcel = NaN;
						if (curDataAdapter.currentGridDescr.excelMaxExport!==undefined && curDataAdapter.currentGridDescr.excelMaxExport!==null && !isNaN(curDataAdapter.currentGridDescr.excelMaxExport)) {
							limitExportExcel = parseInt(curDataAdapter.currentGridDescr.excelMaxExport);
						} else if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
							limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						// isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
						if (limitExportExcel && !isNaN(limitExportExcel) && dataObj.length > limitExportExcel)
						{
							alertForm.width = 350;
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+gis_gridwidget_18+limitExportExcel+".<br/>"
								+gis_gridwidget_19+limitExportExcel+gis_gridwidget_20,gis_gridwidget_21);
							//Устанавливаем реальный лимит, который прописан в конфиге, чтобы избежать ошибки сервера (во флеше нельзя было выбрать более 1000 записей в принципе)
							dataObj = dataObj.slice(0,limitExportExcel);
						}
						else
						{
							//Вместо dataObj.length выводим общее число записей грида
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+ gis_gridwidget_22,gis_gridwidget_23);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								extDataId = curDataAdapter.currentGridDescr.excelDataRequest;
								ExportUtil.exportToExcel(dataObj, fileName, "server_export", extDataId); //excelTemplate для группы всегда "server_export"
							}
						});
						break;
					//ГРУППА.
					case 'CopyToExcelEvent':
						try {
							if (dataObj[0] === undefined) {
								App.confirmDialog(gis_gridwidget_129);
								break;
							}
							var idColumn = 'ID';
							var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
							if(gridWidget) {
								idColumn = gridWidget.primaryKeyField || 'ID';
							}
							GridUtil.copyToExcelEvent(curDataAdapter.currentGridDescr.gridColumns, dataObj, idColumn );
						}
						catch(ex){
						}
						break;
					//ГРУППА.
					case 'PasteFromExcelEvent':
						try {
							//jqxGridId, gridElem, dataAdapter, event
							var syncMap = (eventParamsObj && eventParamsObj.syncmap === 'true');

							that.pasteFromExcelDialog(currentGrid, curDataAdapter, syncMap);
						}
						catch(ex){
						}
						break;
					//ГРУППА.
					case 'ApplyUpdatedCellEvent':
						try {
							var syncMap = (eventParamsObj && eventParamsObj.syncmap === 'true');
							that.saveUpdatedCellDialog(currentGrid, curDataAdapter, syncMap);
						}
						catch(ex){
						}
						break;
					//ГРУППА.
					case 'TestEvent':
						var obj = dataObj;
						$(currentGrid).jqxGrid('selectrow', 31);
						$(currentGrid).jqxGrid('ensureRowVisible', 31);
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.RemoveGridRowEvent':
						try {
							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							var syncMap = (eventParamsObj && eventParamsObj.syncmap === 'true');
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							if (curLayerObj==undefined || curLayerObj==null) {
								//Если слоя нет - делаем как во флеше (там ничего не происходило, даже запрос не отправлялся, здесь Володя сказал должна быть форма с сообщением)
								alertForm = new AlertForm();
								alertForm.build("gridDeleteNoLayerAlertForm",gis_gridwidget_24,gis_gridwidget_25,AlertForm.OK);
								//Чистим выделение в гриде
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							//удаление ТОЛЬКО СЕМАНТИКИ (исправить provider на dataRequest = "", чтобы прошел полный алгоритм удаления сначала геометрии затем семантики)
							dataRequest = curLayerObj.dataProvider.semantic;
							deletingArr = [];
							for (i = 0; i < dataObj.length; i++) {
								deletingObject = {rowData:dataObj[i], classId:layerId, objectId:dataObj[i]["ID"], provider:dataRequest, propertyPanelName:""};
								deletingArr.push(deletingObject);
							}

							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function (evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_28,deletingArr,that,(syncMap)?that.deleteObjectWithSyncMap:that.deleteObject,
										(syncMap)?refreshGridAfterDeleteWithSyncMap:refreshGridAfterDelete, null, true);
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_24'});
						}
						break;
					//ГРУППА.
					case 'showPPanelEvent':
						//Формируем параметры для вызова функции центровки
						if (dataObj[0] === undefined) break;
						break;
					//Административные задачи
					//ГРУППА.Привязать отчет к трубе
					case 'gridAdmIliBindToRoute':
						//В форме один комбобокс начинает заполняться только после выбора значения в другом, пока такой логики в панели свойств нет
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliBindToRouteForm";
						var gridAdmIliBindToRouteForm = new GridAdmIliBindToRouteForm();
						gridAdmIliBindToRouteForm.build(gridPropPanelId);
						var sendingData,requestParams,currentTemplate;
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function onGridAdmIliBindToRouteFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							//Для этой формы в evt.detail при отмене придет -1, при ошибке выбора комбобокса придет 0 или корректное значение curRouteId в остальных случаях
							if (evt && evt.detail != -1) {
								if (evt.detail == 0)
									App.errorReport(gis_gridwidget_5, gis_gridwidget_29, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_25'});
								else {
									var curRouteId = evt.detail;
									sendingData = '<data ILI_INSPECTION_ID="' + dataObj[0].ID.xmlEscape() + '" ROUTE_ID="' + curRouteId.xmlEscape() + '"/>';
									//Получаем параметры для запроса и исправляем их на нужные нам
									var userId = Auth.getUserId();
									var userLogin = Auth.getUserName();
									requestParams = {
										descrId: 'GAZPROM_ADM_SEM.xml#BIND_ILI_INSPECTION_TO_ROUTE',
										descrType: 'update',
										data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' + sendingData + '</root>'
									};
									//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
									currentTemplate = "gridAdmIliBindToRoute";
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
								}
							}
						});
						break;
					//ГРУППА.Привязка отчета к трубе(Интенсивы)
					case 'gridAdmPiCPBindToLine':
						if (dataObj.length > 0){
							GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_141, dataObj, that,
								function processSingleBinding(curObj){
									if (curObj && curObj.hasOwnProperty("ID")){
										var userId = Auth.getUserId();
										var userLogin = Auth.getUserName();
										sendingData = '<data REPORT_ID="'+curObj.ID+'" LINE_ID="'+curObj.LINE_ID+'" STATION_BEGIN="'+curObj.STATION_BEG+'" STATION_END="'+curObj.STATION_END+'"/>';
										//Получаем параметры для запроса и исправляем их на нужные нам
										requestParams = { getSchema: false, descrId: 'UTE_SEM.xml#CALC_CALC_CP', toElements: false, descrType: 'update',
											data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" >' + sendingData + '</root>' };
										//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
										currentTemplate = "gridAdmPiCPBindToLine";
										//Устанавливаем курсор ожидания
										BlockingUtil.wait();
										App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
									}else if (GridAdmWidget.processStatusForm)
										GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
								},
								endProcess, cancelProcess, true);
						}else {
							App.errorReport(gis_gridwidget_5, gis_gridwidget_140, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_49'});
						}
						break;
					//ГРУППА.Привязка отчета к трубе(КИП)
					case 'gridAdmPiCISBindToLine':
						if (dataObj.length > 0){
							GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_141, dataObj, that,
								function processSingleBinding(curObj){
									if (curObj && curObj.hasOwnProperty("ID")){
										var userId = Auth.getUserId();
										var userLogin = Auth.getUserName();
										sendingData = '<data REPORT_ID="'+curObj.ID+'" ROUTE_ID="'+curObj.ROUTE_ID+'"/>';
										//Получаем параметры для запроса и исправляем их на нужные нам
										requestParams = { getSchema: false, descrId: 'UTE_SEM.xml#CALC_CALC_CIS', toElements: false, descrType: 'update',
											data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" >' + sendingData + '</root>' };
										//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
										currentTemplate = "gridAdmPiCISBindToLine";
										//Устанавливаем курсор ожидания
										BlockingUtil.wait();
										App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
									}else if (GridAdmWidget.processStatusForm)
										GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
								},
								endProcess, cancelProcess, true);
						}else {
							App.errorReport(gis_gridwidget_5, gis_gridwidget_140, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_49'});
						}
						break;
					//ГРУППА. Задача "ВТД. Коррекция". Пересчет отчетов.
					case 'IliReportCalcCorrEvent':
						var fakeObj = [{rowData: {ID:1}, classId:'fakeClass', objectId:'fakeId', provider:'fakeRequest', propertyPanelName:""}];
						GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_160, fakeObj, that,
							function (curObj){
								if(curObj){
									var guid = GridAdmInternal.generateProcessGUID();
									var processGuid = guid;//'78e29bcf';
									var iliInpectionId = MapUtil.getTopFilterByName('ILI_INSP_FILTER');
									if(iliInpectionId)
										iliInpectionId = iliInpectionId.value;
									var sendingData = GridAdmInternal.convertSimpleObjectToXml_({
										inspection_id: iliInpectionId, link_repers: 'N', ps_idx: 'N', process_id: processGuid,
									}); /*'<input/>';*/
									currentTemplate = "IliReportCalcCorrTemplate";
									var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
									BlockingUtil.wait();
									var currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliInspCalc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
									GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId,onResult, onFault, GridAdmInternal.cancelRequest, true);
								}
								else if (GridAdmWidget.processStatusForm)
									GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_155);
							},
							endProcess, cancelProcess, true);
						break;
					//ГРУППА. Задача "ВТД. Коррекция". Развернуть отчет ВТД и выполнить пересчет
					case 'IliReportReverseEvent':
						try{
							var iliInpectionId = MapUtil.getTopFilterByName('ILI_INSP_FILTER');
							if(iliInpectionId)
								iliInpectionId = iliInpectionId.value;
							var dataRequest = 'GAZPROM_ADM_SEM.xml#VTD_CORR_REVERSE';
							var descrType = 'insert';
							var dto = {
								ILI_INSPECTION_ID: iliInpectionId,
							}
							var alertForm = new AlertForm();
							alertForm.alertOkButtonText = gis_core_4;
							alertForm.alertCancelButtonText = gis_core_5;
							alertForm.build("btnReportReverseAlertForm",gis_gridwidget_161, gis_gridwidget_162);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function btnReportReverseAlertFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail == 1) {
									var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(dto), descrType);
									App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
										if (resultXML) {
											var er = HTTPServiceUtil.getError(resultXML);
											if (er !== "") {
												App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_69'})
												return;
											}
											var guid = GridAdmInternal.generateProcessGUID();
											var processGuid = guid;//'78e29bcf';
											var sendingData = GridAdmInternal.convertSimpleObjectToXml_({
												inspection_id: iliInpectionId,
												link_repers: 'Y',
												ps_idx: 'N',
												process_id: processGuid,
											}); /*'<input/>';*/
											currentTemplate = "ILI_INSP_ProcRevert.xml";
											var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
											BlockingUtil.wait();
											var currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliInspLink, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
											GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
										}
									}, function (resultXML) {
										var er = HTTPServiceUtil.getError(resultXML);
										if (er === "") er = resultXML;
										App.errorReport(gis_core_error_7, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_69'})
									});
								}
							});


						}catch(ex){
							App.errorReport(gis_core_error_7, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_69'})
						}

						break;
					//ГРУППА. Задача "ВТД. Коррекция". вызов задачи 'Отвязать репер' Разрыв связи репера с точкой на карте
					case 'UnlinkReperEvent':
						if (dataObj.length > 0){
							GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_154, dataObj, that,
								function (curObj){
									if (curObj && curObj.ID){
										var userId = Auth.getUserId();
										var userLogin = Auth.getUserName();
										sendingData = '<data ID="'+curObj.ID+'" />';
										//Получаем параметры для запроса и исправляем их на нужные нам
										requestParams = { descrId: 'GAZPROM_ADM_SEM.xml#VTD_CORR_UNLINK', descrType: 'insert',
											data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" >' + sendingData + '</root>' };
										//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
										currentTemplate = 'UnlinkReperTemplate';
										//Устанавливаем курсор ожидания
										BlockingUtil.wait();
										App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
									}else if (GridAdmWidget.processStatusForm)
										GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_155);
								},
								endProcess, cancelProcess, true);
						}else {
							App.errorReport(gis_gridwidget_5, gis_gridwidget_140, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_49'});
						}
						break;
					//ГРУППА. Задача "ВТД. Коррекция". вызов задачи 'Добавить репер' Связывание репера с точкой на карте
					case 'LinkReperEvent':
						var buttons = [
							{
								text: gis_core_12, click: function () {
									App.destroyDialog(undefined, this);
									var layerId = curDataAdapter.currentGridDescr.layerId;
									//Вызываем функцию создания объекта на карте(эмулируем)
									if (WidgetMap && WidgetMap.addObjectControl) {
										widgetMoveWindowToPosition('grid');
										var routeId = undefined;
										var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
										if(firstElement )
											routeId = firstElement.ROUTE_ID;
										var iliInpectionId = MapUtil.getTopFilterByName('ILI_INSP_FILTER');
										if(iliInpectionId)
											iliInpectionId = iliInpectionId.value;
										WidgetMap.addObjectControl.emulateHandleAddOnMapObjectClick({
											routeId: routeId,
											layerName: layerId,
											inspectionId: iliInpectionId,
											callback: function(semId){
												refreshDataAfterProcEnd(layerId, [semId]);
											}
										});
									}
								}
							},
							{
								text: gis_core_6, click: function () {
									App.destroyDialog(undefined, this);
								}
							}
						];
						App.confirmDialog(gis_gridwidget_159, buttons, {title:gis_core_1});
						break;
					
					//ГРУППА.Пересчет отчетов
					case 'gridAdmIliCalc':
						gridPropPanelId = 'divFormPPanel_gridAdmIliCalc';
						gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects:[{id: "ADM_ILI_INSP_PROC", label: gis_gridadmwidget_82}],
							handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
									if (dataObject) {
										iliCalcArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_68,iliCalcArray,that,
											function processSingleInspection(inspection) {
												if (inspection && inspection.hasOwnProperty("ID")){
													var guid = GridAdmInternal.generateProcessGUID();
													var processGuid = guid;//'78e29bcf';
													var sendingData = GridAdmInternal.convertSimpleObjectToXml_(dataObject); /*'<input/>';*/
													sendingData = sendingData.replace('/>',' inspection_id="'+inspection.ID+'" process_id="'+processGuid+'" />');
													var currentTemplate = "ILI_INSP_Proc.xml";
													var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													BlockingUtil.wait();
													currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliInspCalc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
													GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridadmwidget_72, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_80'});
									}
								}}
						});
						break;
					//ГРУППА.1. Группировка дефектов в кластеры
					case 'gridAdmIliCalcCluster':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcCluster";
						gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects: [{id: "ADM_ILI_CLUSTER", label:gis_gridwidget_34 }],
							handlers: {
								getFormDataCallback: function getFormDataCallback(dataObject) {
									if (dataObject) {
										iliCalcClusterArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_35, iliCalcClusterArray, that,
											function processSingleInspectionCluster(inspectionCluster) {
												if (inspectionCluster && inspectionCluster.hasOwnProperty("ID")) {
													sendingData = convertSimpleObjectToXml(dataObject);
													/*'<input/>';*/
													sendingData = sendingData.replace('/>', ' inspection_id="' + inspectionCluster.ID + '"/>');
													currentTemplate = "ILI_Cluster.xml";
													requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													//BlockingUtil.blockApplication();
													currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_31);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridwidget_36, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_26'});
									}
								}
							}
						});
						break;
					//ГРУППА.2. Расчет точечных показателей в соответствии с СТО 112, 173, 292, 401, 595
					case 'gridAdmIliCalcPressure':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcPressure";
						gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects: [{
								id: "ADM_ILI_PRESSURE",
								label: gis_gridwidget_37
							}],
							handlers: {
								getFormDataCallback: function getFormDataCallback(dataObject) {
									if (dataObject) {
										iliCalcPressureArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_38, iliCalcPressureArray, that,
											function processSingleInspectionCluster(inspectionPressure) {
												if (inspectionPressure && inspectionPressure.hasOwnProperty("ID")) {
													_baseOutputData = '<input inspection_id="1300497" pressure="7.36" breaking_point="588" yielding_limit="490" elastic_modulus="206000" ' +
														'safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" ' +
														'safety_factor_of_destination="1.34" route_category="4" thickness="16" calc_sto_2_2_3_112_2007="true" calc_sto_2_2_3_173_2007="true" ' +
														'calc_sto_2_2_3_292_2009="true" calc_sto_2_2_3_401_2009="true" calc_sto_2_2_3_595_2011="true" calc_sto_2_2_3_620_2011="true" calc_sto_ltg="true" />';
													sendingData = convertSimpleObjectToXml($.extend(convertXmlToSimpleObject(_baseOutputData), dataObject));
													sendingData = sendingData.replace(' inspection_id="1300497"', ' inspection_id="' + inspectionPressure.ID + '"');
													currentTemplate = "ILI_Pressure.xml";
													requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													//BlockingUtil.blockApplication();
													currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_31);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridwidget_39, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_27'});
									}
								}
							}
						});
						break;
					//ГРУППА.3. Расчет линейных показателей в соответствии с СТО 095, 292, 401
					case 'gridAdmIliCalcSTO':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcSTO";
						gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects: [{
								id: "ADM_ILI_STO",
								label: gis_gridwidget_40
							}],
							handlers: {
								getFormDataCallback: function getFormDataCallback(dataObject) {
									if (dataObject) {
										iliCalcSTOArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_41, iliCalcSTOArray, that,
											function processSingleInspectionCluster(inspectionSTO) {
												if (inspectionSTO && inspectionSTO.hasOwnProperty("ID")) {
													_baseOutputData = '<input calc_line_events="true" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {INSPECTION_ID}" ' +
														'calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" regular_intervals_distance="100" pressure="7.36" ' +
														'breaking_point="588" safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" safety_factor_of_destination="1.34" ' +
														'thickness="16" lifetime="25" average_cost_of_responding="150" cost_of_replacing_a_pipe="0.6" cost_of_the_ILI_per_km="0.1" cost_per_hole="0.2" cost_of_repair_per_km="23.8" ' +
														'calc_sto_2_2_3_292_2007="true" calc_sto_2_2_3_401_2003="true" calc_sto_2_2_3_095_2007="true" calc_sto_xxx="true" />';

													sendingData = convertSimpleObjectToXml($.extend(convertXmlToSimpleObject(_baseOutputData), dataObject));
													//sendingData = sendingData.replace('calc_line_events="true"','calc_line_events="True"');
													//sendingData = sendingData.replace('calc_line_events="false"','calc_line_events="False"');
													//Добавляем inspectionSTO.ID также в текст запроса line_events_query
													sendingData = sendingData.replace('{INSPECTION_ID}', inspectionSTO.ID);
													sendingData = sendingData.replace('/>', ' inspection_id="' + inspectionSTO.ID + '"/>');
													currentTemplate = "STO_ILI_INSP_Proc.xml";
													requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													//BlockingUtil.blockApplication();
													currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_31);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridwidget_42, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_28'});
									}
								}
							}
						});
						break;
					//ГРУППА.4. Расчет линейных показателей в соответствии с инструкцией ВНИИГАЗ 2004
					case 'gridAdmIliCalcSTOforEHZ':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcSTOforEHZ";
						gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects: [{
								id: "ADM_ILI_STO_FOR_EHZ",
								label: gis_gridwidget_43
							}],
							handlers: {
								getFormDataCallback: function getFormDataCallback(dataObject) {
									if (dataObject) {
										iliCalcSTOforEHZArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_44, iliCalcSTOforEHZArray, that,
											function processSingleInspectionCluster(inspectionSTOforEHZ) {
												if (inspectionSTOforEHZ && inspectionSTOforEHZ.hasOwnProperty("ID")) {
													_baseOutputData = '<input calc_line_events="true" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {INSPECTION_ID}" ' +
														'calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" ' +
														'regular_intervals_distance="100" install_date="06.11.2002" calc_sto_xxx="true" />';

													sendingData = convertSimpleObjectToXml($.extend(convertXmlToSimpleObject(_baseOutputData), dataObject));
													//sendingData = sendingData.replace('calc_line_events="true"','calc_line_events="True"');
													//sendingData = sendingData.replace('calc_line_events="false"','calc_line_events="False"');
													//Добавляем inspectionSTOforEHZ.ID также в текст запроса line_events_query
													sendingData = sendingData.replace('{INSPECTION_ID}', inspectionSTOforEHZ.ID);
													sendingData = sendingData.replace('/>', ' inspection_id="' + inspectionSTOforEHZ.ID + '"/>');
													currentTemplate = "STO_EHZ_INSP_Proc.xml";
													requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_31);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridwidget_45, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_29'});
									}
								}
							}
						});
						break;
					//ГРУППА Отображение дашбордов
					case 'ShowDashboardEvent':
						var curRowData = dataObj[0];
						//Фильтрация грида
						var da = $(currentGrid).jqxGrid('source');
						if(da.currentGridDescr !== undefined){
							//TODO хардод. избавиться
							$('.search-engine-filters__grid').remove();
							if($('#searchEngine_'+currentGrid.id).length > 0){
								$('#searchEngine_'+currentGrid.id).toggle();
							}
							else{
								$('.search-engine-filters__grid').remove();
								var fltrs = GridUtil.formatFilters2SearchFrom(da.currentGridDescr.gridColumns, function(filters){
									var filterView = new SearchEngineGridFiltersForm({
										opener: 'grid',
										openerId: currentGrid.id,
										curDataAdapter: da,
										currentGrid: currentGrid,
										layerName: da.currentGridDescr.layerId,
										settings:{
											noTitle:true,
										},
										config: filters,
										applyCallback: function(filters, boolFilters, dateFilters){
											//применяем фильтр
											var curFilter = GridUtil.reformatFilters(filters, boolFilters, dateFilters);

											da.currentGridDescr.currentFilter = curFilter;
											//that.emulateBottomFilter(currentGrid);
											//TODO выставить фильтры в текущие открытые дашборды
										}
									});
									filterView.build();
								});
							}
						}

						break;
					//ГРУППА. Показать легенду в виде светофора для гридов Задачи "СУ ТС ТПА"
					case 'ShowLegendEvent':
						layerId = curDataAdapter.currentGridDescr.layerId;
						var tableName = (layerId.indexOf('КРАНОВЫЙ_УЗЕЛ') !== -1) ? 'structure' : (layerId.indexOf('КРАН') !== -1) ? 'valve' : 'vent_pipe';
						var userId = Auth.getUserId();
						var userLogin = Auth.getUserName();
						var params = {
							descrId: 'SUTSTPA_SEM.xml#RANK_LEGEND',
							descrType: 'select',
							data: '<root USER_ID="' + userId + '" USER_LOGIN="' + userLogin + '" PODS_USER="' + userLogin + '" >' +
								'<data TABLE_NAME="' + tableName + '"/></root>'
						}
						function result(resultXML) {
							try{
								var er = HTTPServiceUtil.getError(resultXML);
								if (er){
									App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_68'});
									return;
								}
								var data = resultXML.find('data')[0];
								var lowLimit = $(data).attr('PERC_15'),
									highLimit = $(data).attr('PERC_50'),
									elementId = currentGrid.id + '_showLegendModal';
								if(!lowLimit) lowLimit = 'Неизвестно';
								if(!highLimit) highLimit = 'Неизвестно';
								var div = '<div id="' + elementId + '" style="padding: 10px">' +
									'<div class="legend_line">' +
										'<div class="legend_line_color" style="background: rgb(0, 255, 0)"></div>' +
										'<span>- Ранг опасности до ' + lowLimit + '</span>' +
									'</div>' +
									'<div class="legend_line">' +
										'<div class="legend_line_color" style="background: rgb(255, 188, 22);"></div>' +
										'<span>- Ранг опасности от ' + lowLimit + ' до ' + highLimit + '</span>' +
									'</div>' +
									'<div class="legend_line">' +
										'<div class="legend_line_color" style="background: rgb(255, 70, 62);"></div>' +
										'<span>- Ранг опасности от ' + highLimit + '</span>' +
									'</div>' +
									'</div>';
								$('body').append(div);
								dlg = $('#'+elementId);
								dlg.dialog({
									modal: true,
									title: 'Легенда светофора',
									dialogClass: 'gsi-zindex__dialog',
									closeOnEscape: true,
									width: 300,
									height: 138,
									resizable: false,
									close: function () {
										App.destroyDialog(null, dlg);
									}
								});
							}catch (ex) {
								App.errorReport(gis_core_error_2, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_67'});
							}
						}
						function fault(resultXML) {
							var er = HTTPServiceUtil.getError(resultXML);
							if (er) App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_66'});
						}
						App.serverQueryNodeWithTries(Services.processQueryNode, params, result, fault);
						break;
					//ГРУППА. показ на карте через открытие отдельного окна браузера/либо через iframe(зависит от настроек конфига задачи)
					case 'ShowMapEvent':
						try {
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							if (curLayerObj==undefined || curLayerObj==null)
								break;
							//Формируем параметры для вызова функции центровки
							objectsStr = eventParamsObj["layerid"] + ":";
							var selectedItemsCount = dataObj.length;
							if(App.syncEnabled && dataObj.length > 150)//количество доступных идентификаторов для хранения в куках
								selectedItemsCount = 150;
							for (i = 0; i < selectedItemsCount; i++) {
								objectsStr += dataObj[i]["ID"];
								//К последнему ID сзади запятую не добавляем
								if (i < dataObj.length - 1) {
									objectsStr += ",";
								}
							}
							params = [{name:"mdl", value:"main_js.html"}, {name: "objects", value: objectsStr}, {name: "select", value: true}, {name: "centering", value: true},{name: "isGroupButton", value: true}];
							if(eventParamsObj && eventParamsObj.task)
								taskName = eventParamsObj.task;
							GridUtil.showOnMap(taskName, params)
						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_23'});
						}
						break;
					//ГРУППА. Выполнение произвольных команд с передачей в них выбранных идентификаторов
					case 'ExecuteQueryEvent':
						var datas = dataObj;
						if(!datas && datas.length === 0)
							datas = [{ID:'NULL'}];
						var requestId = eventParamsObj['request'];
						var selectedIds = datas.map(function (item) {
							return item.ID;
						});
						GridUtil.executeQuery(requestId, 'insert', selectedIds, function(){
							layerId = curDataAdapter.currentGridDescr.layerId;
							var selectedObject = layerId + ':' + selectedIds.join();
							App.syncManager.callSync(selectedObject,'grid', undefined, SyncTypes.TYPE_3);
							App.confirmDialog(gis_gridwidget_157, null, {title:gis_core_1});
						});
						break;
					//ГРУППА. Выполнение произвольных запросов с передачей в них выбранных идентификаторов и результат выводить в excel
					case 'ExecuteExcelQueryEvent':
						var datas = dataObj;
						if(!datas && datas.length === 0)
							datas = [{ID:'NULL'}];
						var requestId = eventParamsObj['request'];
						var selectedIds = datas.map(function (item) {
							return item.ID;
						});
						GridUtil.executeExcelQuery(requestId, 'select', selectedIds);
						break;
				}

			}
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_30'});
	}
};

/**
 * Сохранение измененных ячеек грида по клику на групповую кнопку
 * @param currentGrid
 * @param dataAdapter
 * @param syncMap  флаг, нужно ли синхронизировать карту по обновленным объектам(удалять старые с карты и перезапрашивать новые)
 */
GridWidget.prototype.saveUpdatedCellDialog = function(currentGrid, dataAdapter, syncMap) {
	var that = this;
	if(dataAdapter && dataAdapter.currentGridDescr && dataAdapter.currentGridDescr.rows4Update) {
		var jqxGridId = currentGrid.id;
		var rows4UpdateObj = dataAdapter.currentGridDescr.rows4Update;
		var rows4UpdateIds = []; // массив всех идентификаторов на обновление
		var rows4Update = [];
		for(var row in rows4UpdateObj){
			rows4Update.push(rows4UpdateObj[row]);
			rows4UpdateIds.push(rows4UpdateObj[row].ID);
		}
		if(rows4Update.length === 0)
			return;
		delete dataAdapter.currentGridDescr.rows4Update;

		that.selectFullDataBeforeUpdateDB(dataAdapter, rows4Update, function(result){
			var rows4UpdateLength = rows4Update.length;
			rows4Update.forEach(function (it, index) {
				//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
				var itemFromDb = result[it.ID];
				var isLastRow = (rows4UpdateLength - 1) === index;
				if(itemFromDb){
					var extIt = $.extend(itemFromDb,it);
					that.updateCellDB(dataAdapter, extIt, syncMap, jqxGridId, isLastRow, rows4UpdateIds);
				}
			});
			//TODO обновлять грид по окончанию загрузки
			//GridWidget.refreshGrid(jqxGridId);
		});
	}
}


GridWidget.prototype.pasteFromExcelDialog = function(currentGrid, dataAdapter, syncMap) {
	var that = this;
	var divv = '<div id="pasteFromExcelDialog">' +
		'<label style="color: #ffffff">' + gis_gridwidget_98 + '</label>'+
		'<textarea id="pasteFromExcelText" style="width:580px;margin: 1px;color: #005d98;height: 55px;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text"></textarea>' +
		'<div style="margin-top:10px; color: #ffffff">' + gis_gridwidget_99 + '</div>'+
		'<div style="margin-top:2px; color: #ffffff;" >' +
		'   <input type="checkbox" id="confirmPasteFromExcelCheckbox">' +
		'   <label style="color: #ffffff;" for="confirmPasteFromExcelCheckbox">' + gis_gridwidget_105 + '</label>' +
		'</div>' +
		'<div style="margin-top:10px; color: #ffffff">' + gis_gridwidget_99_1 + '</div>'+
		'</div>';
	$('body').append(divv);
	var dlg = $('#pasteFromExcelDialog');
	var bts = [
		{
			text: gis_gridwidget_92,
			click: function(){
				var pastedText =  $('#pasteFromExcelText').val();
				if(pastedText === ''){
					App.confirmDialog(gis_gridwidget_109, null, {title:gis_core_1});
					return;
				}
				if(dataAdapter && dataAdapter.currentGridDescr) {
					dataAdapter.currentGridDescr.pasteFromExcelData = pastedText;
					var checked = $('#confirmPasteFromExcelCheckbox').prop('checked');
					that.pasteCells(currentGrid, dataAdapter, checked, syncMap);
				}
				$('#pasteFromExcelDialog').remove();
			}
		},
		{
			text: gis_gridwidget_93,
			click: function(){
				var pastedText =  $('#pasteFromExcelText').val();
				if(pastedText === ''){
					App.confirmDialog(gis_gridwidget_109, null, {title:gis_core_1});
					return;
				}
				else if(!dataAdapter.currentGridDescr.lastEditedCell){
					App.confirmDialog(gis_gridwidget_107, null, {title: gis_core_1});
					return ;
				}
				var pastedText =  $('#pasteFromExcelText').val();
				that.confirmUpdateFromExcel(currentGrid, dataAdapter, pastedText, syncMap);
				$('#pasteFromExcelDialog').remove();
			}
		},
		{
			text: gis_core_8,
			click: function(){
				delete dataAdapter.currentGridDescr.lastEditedCell;
				$('#pasteFromExcelDialog').remove();
			}
		}];
	dlg.dialog({
		modal: true,
		title: gis_gridwidget_87,
		dialogClass: 'ui-dialog-confirm noCloseButton gsi-zindex__dialog',
		closeOnEscape: true,
		width: 595,
		height: 395,
		resizable: false,
		buttons : bts
	});
};

GridWidget.prototype.confirmUpdateFromExcel = function(currentGrid, dataAdapter, text, syncMap) {
	var that = this;
	var label = gis_gridwidget_101;
	if(dataAdapter && dataAdapter.currentGridDescr.lastEditedCell && dataAdapter.currentGridDescr.lastEditedCell.boundIndex !== undefined && dataAdapter.currentGridDescr.lastEditedCell.boundIndex !== null  && dataAdapter.currentGridDescr.lastEditedCell.dataField){
		var columns = dataAdapter.currentGridDescr.gridColumns;
		label = label.replace('{ROW_NUM}', dataAdapter.currentGridDescr.lastEditedCell.rwn);
		columns.forEach(function(it){
			if(it.datafield === dataAdapter.currentGridDescr.lastEditedCell.dataField)
				label = label.replace('{COL_NAME}', (it.text)?it.text.replace(/\\n/g,' '):'');
		});
		dataAdapter.currentGridDescr.pasteFromExcelData = text;
		that.updateCells(currentGrid, dataAdapter, syncMap);
	}
	else{
		App.confirmDialog(gis_gridwidget_107, null, {title: gis_core_1});
	}
};

/**
 * Эмуляция запроса данных в грид при фильтрации, чтобы не блоркировалось содержимое грида
 * @param currentGrid
 * @param curFilter
 * @param selecting
 * @param centering
 */
GridWidget.prototype.emulateRefreshGrid = function (currentGrid, curFilter, selecting, centering) {
	var dataAdapter = $(currentGrid).jqxGrid('source');
	var refreshGridEvt = new GridEvent(GridEvent.FILTER_GRID);
	refreshGridEvt.gridId = currentGrid.id;
	refreshGridEvt.dispatch();
	/*dataAdapter.currentGridDescr.currentFilter = curFilter;
	//Также сохраняем флаги выделения и центровки на карте
	dataAdapter.currentGridDescr.selecting = selecting;
	dataAdapter.currentGridDescr.centering = centering;*/
};


GridWidget.prototype.emulateBottomFilter = function(currentGrid){
	$(currentGrid).jqxGrid('clearselection');
	var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
	if(gridWidget) {
		gridWidget.modified = true;
	}

	//Перезапрашиваем грид
	try {
		GridWidget.refreshGrid(currentGrid.id, true);
	}
	catch(ex){

	}
}

/* Функции фильтрации */
//Слушатель события закрытия формы фильтра нижнего уровня
GridWidget.prototype.onBottomFilterFormClose = function (evt/*CloseEvent*/) {
	$("body").off(CloseEvent.CLOSE);
	if (evt && evt.eventData) {
		var parentRoughFilter = undefined;
		var selecting = evt.eventData.selecting;
		var centering = evt.eventData.centering;
		//Забираем фильтр
		var curFilter = evt.eventData.filter;
		//Сохраняем его в виджет грида и перезапршиваем грид
		var currentGrid = evt.eventData.currentGrid;
		var dataAdapter = $(currentGrid).jqxGrid('source');
		dataAdapter.currentGridDescr.currentFilter = curFilter;
		//Также сохраняем флаги выделения и центровки на карте
		dataAdapter.currentGridDescr.selecting = selecting;
		dataAdapter.currentGridDescr.centering = centering;
		var showError = true;
		//пытаемся очистить на карте прошлый фильтр слоя
		if(dataAdapter.currentGridDescr!=undefined && dataAdapter.currentGridDescr.layerManager!=undefined){
			var layerId = dataAdapter.currentGridDescr.layerId;
			var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
			var layObj = layerManagerInst.getLayerByName(layerId);
			if(layObj !=undefined && layObj.layer != undefined){
				if(layObj.layer.useServerCache)
					showError = false;
				layObj.layer.showAllObjects();
			}
		}
		//чистка выделения при применении фильтрации
		$(currentGrid).jqxGrid('clearselection');
		var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
		var force = true;
		if(gridWidget) {
			gridWidget.modified = true;
			parentRoughFilter = gridWidget.parentRoughFilter;
			force = false;
		}
		//Перезапрашиваем грид
		try {
			GridWidget.refreshGrid(currentGrid.id, force);
		}
		catch(ex){ }

		if(selecting === undefined && centering === undefined)
			return;
		//В связи с проблемой с доступом к контену грида во время фильтрации, эмулируем запросы на кол-во и содержимое
		//если результаты удачны, то заполняем грид
		//this.emulateRefreshGrid(currentGrid,curFilter,selecting,centering);

		var windowId = "";
		var roughFilter = dataAdapter.currentGridDescr.roughFilter;
		//Текущая сортировка (получаем из массива объектов колонок)
		var gridSortStr = GridWidget.prototype.getSortStringFromArr(dataAdapter.currentGridDescr);
		var topFilter = dataAdapter.currentGridDescr.topFilter;
		var funcName = "filterData";
		var params = [{name: "highlight", value: selecting},
			{name: "zoom", value: centering},
			{name: "requestId", value: dataAdapter.currentGridDescr.dataRequest},
			{name: "layer", value: dataAdapter.currentGridDescr.layerId},
			{name:'showError', value:showError},
			{name:'filterXML', value:GridWidget.prototype.makeFilterXMLForCentering(curFilter, gridSortStr, topFilter, roughFilter, parentRoughFilter)}];
		//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
		ExternalInteraction.callFunction(windowId, funcName, params);
	} else {

	}
};



GridWidget.applyExtBottomFilter = function(filters){

}


//Создание строки фильтра для отправки в запрос
GridWidget.prototype.getBottomFilterString = function (filters/*Array*/, parentRoughFilter/*String*/) {
	var _strFilter = "";
	if (filters && filters.length > 0) {
		var res = [];
		var n;
		for (var j = 0; j < filters.length; j++) {
			var f = filters[j];
			if (f.hasOwnProperty("val")) {
				switch (f.op) {
					case 'in': // из списка
						//TODO хардкод если поле YEAR_INSP, то в нижним фильтре игнорируем
						if(f.fld === 'YEAR_INSP')
							break;
						res.push(f.fld + " IN (" + GridWidget.prototype.getArrayDictFilter(f.val)+")");
						break;
					case '=': // число или строка
						//Даты игнорируем (они добавятся в фильтр верхнего уровня как переменные)
						if (f.hasType == 'date') {
							var startDate = f.startDate.toString();
							var endDate = f.endDate.toString();
							if(!startDate) startDate = '01.01.1900';
							if(!endDate) endDate = '01.01.2121';
							startDate += ' 00:00:00';
							endDate += ' 00:00:00';
							if(f.dateformat !== 'number'){
								//ИМЯ_КОЛОНКИ_ДАТЫ between '2020-01-01 00:00:00'::date and '2121-04-02 00:00:00'::date
								res.push(f.fld + " BETWEEN '" + startDate + "'::date and '" + endDate + "'::date ");
							}
							else{
								//парсим строку в Date и получаем миллисекунды
								var startDateArr = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(startDate);//DD.MM.YYYY
								var endDateArr = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(endDate);//DD.MM.YYYY
								//new Date(year, month, day)
								startDate = new Date(Number(startDateArr[3]), Number(startDateArr[2]), Number(startDateArr[1])).getTime();
								endDate = new Date(Number(endDateArr[3]), Number(endDateArr[2]), Number(endDateArr[1])).getTime();
								res.push(f.fld + " >= " + startDate + " and "+f.fld+" <=" + endDate + " ");
							}
							break;
						}
						if (f.hasType == 'number') {
							if((f.val.toString()).indexOf(";")>0) { //тогда имеет место массив чисел и нужен оператор in
								var arr = f.val.toString().split(";");
								res.push(f.fld + " IN (" + GridWidget.prototype.getArrayFilter(arr)+")");
							}  else {
								n = GridWidget.prototype.getNumber(f.val.toString().replace(',','.'));
								if (!isNaN(n))
									res.push(f.fld + " = " + n.toString());
							}
						}
						break;
					case 'likeA':
						if((f.val.toString()).indexOf(";")>=0) { //тогда имеет место массив строк и нужен оператор in
							var arrStr = f.val.toString().split(";");
							//проверяем, все ли элементы в кавычка, если нет, то ставим
							for (var i = 0; i < arrStr.length; i++) {
								//replace (';;',';XZY;') заменяем
								if(arrStr[i].length == 0)
									arrStr[i] = "XZY";
								if(arrStr[i].indexOf("'")==-1) { //т.е. строки данного элемента ещё не обрамлены в кавычки
									if(arrStr[i].length>0)
										arrStr[i] = "UPPER('"+arrStr[i]+"')";
								}
							}
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY')" + " IN (" + GridWidget.prototype.getArrayFilter(arrStr)+")");
						} else {
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
							else
								res.push("UPPER(" + f.fld + ") LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "')");
						}
						break;
					case 'notLikeA':
						if((f.val.toString()).indexOf(";")>=0) { //тогда имеет место массив строк и нужен оператор in
							var arrStr = f.val.toString().split(";");
							//проверяем, все ли элементы в кавычка, если нет, то ставим
							for (var i = 0; i < arrStr.length; i++) {
								//replace (';;',';XZY;') заменяем
								if(arrStr[i].length == 0)
									arrStr[i] = "XZY";
								if(arrStr[i].indexOf("'")==-1) { //т.е. строки данного элемента ещё не обрамлены в кавычки
									if(arrStr[i].length>0)
										arrStr[i] = "UPPER('"+arrStr[i]+"')";
								}
							}
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY')" + "NOT IN (" + GridWidget.prototype.getArrayFilter(arrStr)+")");
						} else {
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
							else
								res.push("UPPER(" + f.fld + ") NOT LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "')");
						}
						break;
					case 'like%A':
						if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
						else
							res.push("UPPER(" + f.fld + ") LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "')");
						break;
					case 'likeA%':
						if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
						else
							res.push("UPPER(" + f.fld + ") LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "%')");
						break;
					case 'like%A%':
						if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
						else
							res.push("UPPER(" + f.fld + ") LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "%')");
						break;
					case 'notLike%A%':
						if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
						else
							res.push("UPPER(" + f.fld + ") NOT LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "%')");
						break;
					default: // только числа
						//тут меняем первую запятую и меняем на точку. Если получится число, то отправляем запрос
						n = GridWidget.prototype.getNumber(f.val.toString().replace(',','.'));
						if (!isNaN(n))
							res.push(f.fld + " " + GridWidget.prototype.validate(f.op) + " " + n.toString());
						break;
				}
			}
		}
		if (res.length > 0) {
			if(parentRoughFilter)
				res.push(parentRoughFilter);
			_strFilter = res.join(" AND ");
		}
	}
	else{
		if(parentRoughFilter)
			_strFilter = parentRoughFilter;
	}
	if (_strFilter == "")
		_strFilter = GridWidget.DEFAULT_FILTER;
	_strFilter =  _strFilter.replace(/&amp;#60;/g, '&amp;lt;');
	return _strFilter;//Фиксим баг #1016 - Если задать условие "<" , то ничего не найдется.
};

//Получение значений с кавычками, если строка и без них, если число. Объединяет значения одного массива в строку через ","
GridWidget.prototype.getArrayDictFilter = function (dict/*Array*/) {
	if (dict && (dict.length > 0)) {
		var res  = [];
		for (var i = 0; i < dict.length; i++) {
			var d = dict[i];
			if (d.hasOwnProperty('CODE')) {
				var v = d.CODE;
				if (typeof v == 'string'){
					//экранируем двойные кавычки, чтобы не рушился формат xml
					var vs = "'"+v.toString().replace(/\"/g,'&quot;')+"'";
					vs = vs.replace(/''/g, "'");
					res.push(vs);
				}
				else
					res.push(v.toString());
			}
		}
		return res.join(", ");
	}
	return 'NULL';
};

//Объединение значений в строку
GridWidget.prototype.getArrayFilter = function (dict/*Array*/) {
	if (dict && (dict.length > 0)) {
		var res = [];
		for (var i = 0; i < dict.length; i++) {
			var d = dict[i];
			if(d.length == 0 || d == " ")
				continue;
			res.push(d);
		}
		return res.toString(); //TODO - проверить что объединяет строки !!!
	}
	return 'NULL';
};

//Получение числа из строки с заменой символа разделителя
GridWidget.prototype.getNumber = function (value/*String*/) {
	var n = parseFloat(value);
	if (!isNaN(n))
		return n;
	return parseFloat(value.replace(",", "."));
};

//Получение числа из строки с заменой символа разделителя
GridWidget.prototype.validate = function (val/*String*/) {
	val = val.replace(/&/g, '&amp;');
	val = val.replace(/<=/g, '&amp;lt;=');
	val = val.replace(/</g, '&amp;lt;');
	val = val.replace(/>=/g, '&amp;gt;=');
	val = val.replace(/>/g, '&amp;gt;');
	val = val.replace(/"/g, '&amp;quot;'); //" просто чтобы форматирование нормально показывалось
	return val;
};
/**/

/* Функции групповой операции удаления */
//Форма процесса групповой операции
GridWidget.processStatusForm = null;
//Функция удаления одной записи
GridWidget.prototype.deleteObject = function (deletingObject) {
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID, this.onObjectDeleteResult);
	$("body").on(OperationEvent.OBJECT_DELETED_BY_ID, this.onObjectDeleteFault);
	//Запускаем удаление
	DBUtil.deleteGeometryFromDB(deletingObject.objectId, deletingObject.classId, deletingObject.provider, deletingObject.propertyPanelName);

	//После удаления нужно будет обновить грид, но пока что не делаем этого
};


//Функция удаления одной записи
GridWidget.prototype.deleteObjectWithSyncMap = function (deletingObject) {
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID, this.onObjectDeleteWithSyncMapResult);
	$("body").on(OperationEvent.OBJECT_DELETED_BY_ID, this.onObjectDeleteFault);
	//Запускаем удаление
	DBUtil.deleteGeometryFromDB(deletingObject.objectId, deletingObject.classId, deletingObject.provider, deletingObject.propertyPanelName);

	//После удаления нужно будет обновить грид, но пока что не делаем этого
};


GridWidget.prototype.insertStoILiDataAdvObject = function (insertingObject) {
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_INSERTED, this.onObjectInsertFault);
	//Запускаем удаление
	DBUtil.insertStoIliDataAdvToDB(insertingObject.rowData, insertingObject.dataAdapter, insertingObject.provider);
};

GridWidget.prototype.insertObject = function (insertingObject) {
	//Запускаем удаление
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_INSERTED, this.onObjectInsertFault);
	DBUtil.insertObjectToDB(insertingObject.rowData, insertingObject.dataAdapter, insertingObject.colTypes);
};

//Функция обработки результата удаления записи
GridWidget.prototype.onObjectDeleteResult = function (evt) {
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
	//Проверяем, есть ли карта и пробуем удалять объект с карты
	if (evt.operationData == "") {//нет ошибки
		if(WidgetMap!=undefined && WidgetMap.layerManager!=undefined){
			var layer = WidgetMap.layerManager.getLayerByName(evt.classId);
			if(layer != undefined && layer.layer != undefined){
				layer.layer.deleteObjectById(evt.objectId);
			}
		}
	}
	GridWidget.processStatusForm.processResultString(evt.operationData);
};

//Функция обработки результата удаления записи
GridWidget.prototype.onObjectDeleteWithSyncMapResult = function (evt) {
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};

//Функция обработки ошибки при удалении записи
GridWidget.prototype.onObjectDeleteFault = function (evt) {
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};

//Функция обработки ошибки при вставке записи
GridWidget.prototype.onObjectInsertFault = function (evt) {
	$("body").off(OperationEvent.OBJECT_INSERTED);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};
//Функция окончания удаления всех записей
GridWidget.prototype.onAllObjectsDeleted = function () {
	//Пока ничего не делаем
};
//Функция отмены удаления (текущее удаление не отменит, но следующие запускать не будет)
GridWidget.prototype.deleteObjectsCancel = function () {
	//Отменяем удаление текущего запроса (если возможно)
};

/**
 *
 * @param reversedObject
 */
GridWidget.prototype.reverseObject = function (reversedObject) {
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_REVERSED_RESULT_BY_ID, this.onObjectReversedResult);
	$("body").on(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID, this.onObjectReversedFault);
	//Запускаем удаление
	DBUtil.reverseObject(reversedObject.rowData, reversedObject.classId);
};

//Функция обработки результата удаления записи
GridWidget.prototype.onObjectReversedResult = function (evt) {
	$("body").off(OperationEvent.OBJECT_REVERSED_RESULT_BY_ID);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};
//Функция обработки ошибки при удалении записи
GridWidget.prototype.onObjectReversedFault = function (evt) {
	$("body").off(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID);
	$("body").off(OperationEvent.OBJECT_REVERSED_BY_ID);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};


/**
 * Обработка кнопки импорта/экспорта объектов в/из GPX, KML
 * @param filterStr
 * @param currentGridDescr
 * @param currentGridId
 * @constructor
 */
GridWidget.prototype.exportImportObjectsToGpxKml = function (filterStr ,currentGridDescr, currentGridId) {
	//Идентификатор запроса геометрии получаем из LayerManager
	if (!currentGridDescr) return;
	var flagImport = filterStr ? false : true;
	var layerId = currentGridDescr.layerId;
	var layerManagerInst = currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	var dataProvider = curLayerObj.dataProvider;
	var requestParams = {};
	if (filterStr !== undefined)//Получаем параметры запроса
		requestParams = GridWidget.prototype.makeLoadGeoDataReqParams(dataProvider.spatial, filterStr);
	//Создаем форму выбора формата экспорта и передаем в нее набор геометрий для экспорта
	var chooseExportImportForm = new ImportExportGpxKmlForm();
	if (requestParams && requestParams.data)
		chooseExportImportForm.requestParams = requestParams.data;
	chooseExportImportForm.dataRequest = dataProvider.spatial;
	chooseExportImportForm.layerName = layerId;
	chooseExportImportForm.dataProvider = dataProvider;
	chooseExportImportForm.currentGridId = currentGridId;
	chooseExportImportForm.flagImport = flagImport;
	chooseExportImportForm.projection = (curLayerObj.layer)? curLayerObj.layer.projection: null;
	chooseExportImportForm.htmlUrl = 'ui/html/ImportExportGpxKmlForm.html';
	chooseExportImportForm.columns = currentGridDescr.gridColumns.filter(function(column) { return column.filtercomparisiontype });
	chooseExportImportForm.build();
};
/* Функции экспорта в GPX/KML */
GridWidget.prototype.exportObjectsToGPX = function (filterStr, currentGridDescr) {
	//Идентификатор запроса геометрии получаем из LayerManager
	var layerId = currentGridDescr.layerId;
	var layerManagerInst = currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	var dataRequest = curLayerObj.dataProvider.spatial;
	var dataProvider = curLayerObj.dataProvider;
	//Получаем параметры запроса
	var requestParams = GridUtil.makeLoadGeoDataReqParams(dataRequest, filterStr);
	//Создаем форму выбора формата экспорта и передаем в нее набор геометрий для экспорта
	var chooseExportForm = new ExportGpxKmlForm();
	chooseExportForm.exportArray = [];
	chooseExportForm.projection = (curLayerObj.layer)? curLayerObj.layer.projection: null;
	chooseExportForm.dataRequest = dataRequest;
	chooseExportForm.requestParams = requestParams.data;
	chooseExportForm.dataProvider = dataProvider;
	chooseExportForm.layerName = layerId;
	//Собственно создаем форму
	chooseExportForm.build();
};



//Сортировка по свойству объекта (c учетом строкового/числового полей)
GridWidget.prototype.dynamicSort = function (property) {
	return function (obj1,obj2) {
		//Исправление для отсутствующего в данных поля - если поля нет, автоматически считаем это значение меньше
		if (obj1==undefined || obj1==null || !obj1.hasOwnProperty(property)) return -1;
		if (obj2==undefined || obj2==null || !obj2.hasOwnProperty(property)) return 1;
		//Внутренняя функция сортировки учитывает, что значения могут быть числовыми
		var value1 = obj1[property].toLowerCase();
		var value2 = obj2[property].toLowerCase();
		try {
			var tmpvalue1 = parseFloat(value1);
			var tmpvalue2 = parseFloat(value2);
			if (!isNaN(tmpvalue1) && !isNaN(tmpvalue2)) {
				if (tmpvalue1 < tmpvalue2) { return -1; }
				if (tmpvalue1 > tmpvalue2) { return 1; }
			} else {
				if (value1 < value2) { return -1; }
				if (value1 > value2) { return 1; }
			}
		} catch (error) {}
		return 0;
	}
};
//Сортировка сразу по нескольким полям
GridWidget.prototype.dynamicSortMultiple = function (fieldsArr) {
	var props = fieldsArr;
	return function (obj1, obj2) {
		var i = 0, result = 0, numberOfProperties = props.length;
		while(result === 0 && i < numberOfProperties) {
			result = GridWidget.prototype.dynamicSort(props[i])(obj1, obj2);
			i++;
		}
		return result;
	}
};

//Функция формирует строку сортировки из массива
GridWidget.prototype.getSortStringFromArr = function (currentGridDescr) {
	var sortStr = "";
	var sortArr = currentGridDescr.currentSort;
	if (sortArr && sortArr !== undefined && sortArr.length > 0) {
		var tmpSortArr = [];
		var i = 0;
		for (i; i < sortArr.length; i++) {
			var sortinformation = sortArr[i];
			//Теперь если мы добавляем сортировку и этот элемент уже был - меняем его (или убираем если сортировка отменена), иначе просто добавляем
			if (sortinformation.sortdirection.ascending || sortinformation.sortdirection.descending) {
				for (var j = 0; j < currentGridDescr.gridColumns.length; j++) {
					//Ищем среди колонок ту, по которой сортируем и забираем значение из ее свойства sortfield
					//Если такого свойста у колонки нет, сортируем по datafield
					var curGridCol = currentGridDescr.gridColumns[j];
					if (curGridCol.hasOwnProperty('datafield') && curGridCol.datafield == sortinformation.sortcolumn) {
						var tmpSortStr = curGridCol.hasOwnProperty('sortfield') && curGridCol.sortfield != undefined ? curGridCol.sortfield : curGridCol.datafield;
						if (sortinformation.sortdirection.descending)
							tmpSortStr += " DESC";
						tmpSortArr.push(tmpSortStr);
					}
				}
			}
		}
		//Собираем получившийся массив в строку, разделенную запятой
		sortStr = tmpSortArr.join(",");
	}
	else {//иначе проходим по колонкам в gridDescription, ищем соответствующие initialSortField поля сортировки
		if (currentGridDescr.columns != undefined) {
			if (currentGridDescr.initialSortField != null) {
				var i = 0;
				var sortArr = [];
				var isf = currentGridDescr.initialSortField.split(',');

				for (i; i < isf.length; i++) {
					var j = 0;
					var found = false;
					for (j; j < currentGridDescr.columns.length; j++) {
						if (isf[i] == currentGridDescr.columns[j].datafield && currentGridDescr.columns[j].sortfield != undefined && currentGridDescr.columns[j].sortfield != '') {
							sortArr.push(currentGridDescr.columns[j].sortfield);
							found = true;
							break;
						}
					}
					if (!found)
						sortArr.push(isf[i]);
				}
				sortStr = sortArr.join(',');
			}
		}
	}
	//по-умолчанию возвращаем первоначальный порядок сортировки
	if (sortStr == "") sortStr = currentGridDescr.initialSortField;
	return sortStr;
};


GridWidget.prototype.onColorFilterFormClose = function (data) {
	var that = this;
	if(data){
		var currentGrid = data.currentGrid;
		var currentGridDescr = data.currentGridDescr;
		currentGridDescr.colorRowValidations = data.colorRowValidations;
		currentGridDescr.colorValidations = data.colorValidations;
		currentGridDescr.colorRowSelectType = data.checkType;
		currentGridDescr.minCriticalColor = data.minCriticalColor;
		currentGridDescr.maxCriticalColor = data.maxCriticalColor;
		//получаем обновленный список цветов и заново рендерим грид
		$(currentGrid).jqxGrid('render');
		$(currentGrid).jqxGrid('clearselection');
		if(data.selectedIndexes && data.selectedIndexes.length > 0){
			for(var item in data.selectedIndexes)
				$(currentGrid).jqxGrid('selectrow', data.selectedIndexes[item] );
		}
	}
};

//Функция обновления грида
GridWidget.refreshGridAfterDelete = function (gridId) {
	//После удаления обновляем грид
	GridWidget.refreshGrid(gridId);
};

/**
 * Функция обновления грида
 * TODO Вынести в общий класс
 * @param gridId
 * @param force необходима ли полное обновление грида(сброс сортировок, фильтров, страниц)
 * @param refreshGridCallback
 * @param opt_options additional options
 */
GridWidget.refreshGrid = function (gridId, force, refreshGridCallback, opt_options) {
	//prepare options
	var options = opt_options || {};
	var ignoreAllFilter = !!options.ignoreAllFilter;

	var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID+"_"+gridId);
	refreshGridEvt.gridId = gridId;
	refreshGridEvt.force = force;
	refreshGridEvt.ignoreAllFilter = ignoreAllFilter;
	refreshGridEvt.refreshGridCallback = refreshGridCallback;
	refreshGridEvt.dispatch();
	//12.10.2021 Vartanian при любом обовление грида, будет востанавливаться грид, если он свернут
	//12.10.2021 Vartanian востановление грида в рамках инц #2536
	widgetMoveWindowToPosition('grid', 'restore');
};

//Функция обновления грида
GridWidget.refreshGridAfterInsert = function (gridId, layerName, syncMap) {
	//После удаления обновляем грид
	GridWidget.refreshGrid(gridId);
	if(syncMap){
		MapUtil.updateLayerData(layerName, [], true);
	}
};

/**
 * Вставка записей из Excel
 * @param currentGrid текущий грид
 * @param curDataAdapter текущий адаптер грида
 * @param isSystemInsert  true - вставка со служебными колонками. false - вставка, как есть, начиная с первой колонки
 */
GridWidget.prototype.pasteCells = function (currentGrid, curDataAdapter, isSystemInsert, syncMap) {
	var that = this;
	try{
		if(currentGrid && curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData){
			var currentGridDescr = curDataAdapter.currentGridDescr;
			var cols = currentGridDescr.gridColumns;
			var colNames = [];
			var colTypes = {};
			var synonyms = {};//массив синонимов колонок в гриде TODO заменить на получение из GridUtils
			cols.forEach(function (it, index) {
				if(it.datafield && !Number.isInteger(it.datafield) && !it.hidden && it.datafield !== 'RWN'){
					colNames.push(it.datafield);
					colTypes[it.datafield] = it.columntype;
				}
				if(it.datafieldsynonym)
					synonyms[it.datafield] = it.datafieldsynonym;
			});
            var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(curDataAdapter.currentGridDescr.layerId);
            if (layer && layer.dataProvider && layer.dataProvider.semantic){
				var params = {
					layerName: curDataAdapter.currentGridDescr.layerId,
					jqxGridId: currentGrid.id,
					isSystemInsert: isSystemInsert,
					syncMap: syncMap,
					currentGridDescr: currentGridDescr,
					curDataAdapter: curDataAdapter,
					colNames: colNames,
					colTypes: colTypes,
					synonyms: synonyms,
					that:that,
				}
                GridUtil.getRequestVariables(layer.dataProvider.semantic, 'update', that.prepareToUpdateCells, params);
            }
		}
	}
	catch(ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_60'});
	}
}
/**
 * @param semanticColTypes - массив с объектами типа: {name: "ID", type: "Int64"}
 * @param params - объект с параметрами
 */
GridWidget.prototype.prepareToUpdateCells = function (semanticColTypes, params) {
	var that = params.that;
	try {
		var isSystemInsert = params.isSystemInsert;
		var layerName = params.layerName;
		var jqxGridId = params.jqxGridId;
		var idColumn = 'ID';
		var gridWidget = App.GridManager.getByGridId(jqxGridId.replace('jqxgrid',''));
		if(gridWidget) {
			idColumn = gridWidget.primaryKeyField || 'ID';
		}

		var syncMap = params.syncMap;
		var colNames = params.colNames;
		var colTypes = params.colTypes;
		var synonyms = params.synonyms;
		var currentGridDescr = params.currentGridDescr;
		var curDataAdapter = params.curDataAdapter;
		var rows = GridUtil.convertPlainExcelDataToTable(currentGridDescr.pasteFromExcelData);
		var rows4Insert = [];
		var rows4Update = [];
		var rows4UpdateIds = [];
		var isInsert = true;// если в данных присутствует колонка ID, то будет происзведено обновление вместо вставки
		var buttons = [
			{
				text: gis_core_4, click: function () {
					App.destroyDialog(undefined, this);
					var foreignKeyField = '';
					//var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
					if(gridWidget && gridWidget.foreignKeyField && gridWidget.filters && gridWidget.filters.length) {
						foreignKeyField = gridWidget.foreignKeyField || [];//{PI_CP_ENEBT_ID:111}
						if(foreignKeyField) {
							foreignKeyField.forEach(function(fc){
								var foreignKeyData = {};
								gridWidget.filters.forEach(function(filterItem){
									if(filterItem.name === fc){
										foreignKeyData[fc] = filterItem.value;
										rows4Insert.forEach(function(dataIns){
											dataIns.rowData = $.extend(dataIns.rowData, foreignKeyData);
										})
									}
								})
							})
						}
					}
					GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_130, (isInsert)?rows4Insert.reverse():rows4Update.reverse(),that,GridWidget.prototype.insertObject,
						function(){
							//записи успешно добавлены
							GridWidget.refreshGridAfterInsert(jqxGridId, layerName, syncMap);
						}, null, true);
				}
			},
			{
				text: gis_core_5, click: function () {
					App.destroyDialog(undefined, this);
				}
			}
		];
		if(isSystemInsert){
			if(rows.length > 0){
				var columns = rows[0];// в служебном режиме 1-я строка - строка с названиями колонок
				if (columns.length > colNames.length){
					var uniqueColumn = columns.filter(function(nameColumn) { return colNames.indexOf(nameColumn) === -1; });
					if (uniqueColumn && uniqueColumn.length){
						uniqueColumn.forEach(function (uniqueCol) {
							semanticColTypes.forEach(function (col) {
								if (col.name === uniqueCol) {
									switch (col.type) {
										case 'Int64':
										case 'Decimal':
											col.type = 'stringnumber';
											break;
										case 'DateTime':
											col.type = 'date';
											break;
										default:
											col.type = 'string';
											break;
									}
									colTypes[col.name] = col.type;
								}
							})
						});
					}
				}
				//если у колонки есть синоним, то заменяем
				rows.forEach(function(row, i){
					if(i !== 0){
						var data = {};
						//имена колонок приводим в upperCase, чтобы совпадали с названиями переменных
						row.forEach(function(val, valIndex){
							var colName;
							if (columns[valIndex])
								colName = columns[valIndex].toUpperCase();
							var columnType = colTypes[colName];
							var preparedVal = GridUtil.prepareValueByDataType2(val, columnType, colName);
							if(preparedVal !== undefined){
								if(synonyms[colName])
									data[synonyms[colName]] = preparedVal;
								else
									data[colName] = preparedVal;// устанавливаем в колонку соответствующее значение. индексы совпадают
							}
						})
						if(data[idColumn]){// если есть в данных ID, то обновление данных
							isInsert = false;
							rows4Update.push({rowData: data, classId:layerName, objectId:data[idColumn],  dataAdapter: curDataAdapter, colTypes: colTypes});
							rows4UpdateIds.push(data);
						}
						else
							rows4Insert.push({rowData: data, classId:layerName, objectId:'',  dataAdapter: curDataAdapter, colTypes: colTypes});
					}
				});
				if(rows4Update.length > 0){
					GridWidget.prototype.selectFullDataBeforeUpdateDB(curDataAdapter, rows4UpdateIds, function(result){
						var rows4UpdateLength = rows4Update.length;
						rows4Update.forEach(function (rowData, index) {
							var it = rowData.rowData;
							if(!it) return;
							//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
							var itemFromDb = result[it[idColumn]];
							var isLastRow = (rows4UpdateLength - 1) === index;
							if(itemFromDb){
								rowData.rowData = $.extend(itemFromDb,it);
							}
						});
						App.confirmDialog(gis_gridwidget_111_1.replace('{ROWS_COUNT}', rows4Update.length), buttons, {title:gis_core_1, html:true});
					});
					return;
				}
			}
		}
		else{
			try{
				rows.forEach(function (row, index) {
					var data = {};
					var valueCounter = 0;
					for(var i = 0; i < colNames.length; i++){
						var colName = colNames[i].toUpperCase();
						var columnType = colTypes[colName];
						if(valueCounter >= row.length ) break;
						var val = row[valueCounter];
						var preparedVal = GridUtil.prepareValueByDataType2(val, columnType, colName);
						if(preparedVal !== undefined)
							data[colName] = preparedVal;
						valueCounter++;
					}
					rows4Insert.push({rowData: data, classId:layerName, objectId:data[idColumn],  dataAdapter: curDataAdapter, colTypes: colTypes});
				});
			}
			catch (ex){
				throw new Error(gis_gridwidget_88);
			}
		}

		if(isInsert)
			App.confirmDialog(gis_gridwidget_111.replace('{ROWS_COUNT}', rows4Insert.length), buttons, {title:gis_core_1, html:true});
		else
			App.confirmDialog(gis_gridwidget_111_1.replace('{ROWS_COUNT}', rows4Update.length), buttons, {title:gis_core_1, html:true});
	}catch (ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_61'});
	}
	finally {
		curDataAdapter.currentGridDescr.pasteFromExcelData = undefined;
	}
}
/**
 * Обновление ячеек грида данными, скопированными из Excel
 * @param currentGrid текущий грид
 * @param curDataAdapter текущий адаптер грида
 */
GridWidget.prototype.updateCells = function (currentGrid, curDataAdapter, syncMap) {
	var that = this;
	try{
		if(currentGrid && curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData && curDataAdapter.currentGridDescr.lastEditedCell){
			var jqxGridId = currentGrid.id;
			var currentGridDescr = curDataAdapter.currentGridDescr;
			var lastEditedCell = currentGridDescr.lastEditedCell;
			var cols = currentGridDescr.gridColumns;
			var colNames = [];
			var colTypes = {};
			var confirmLabel = gis_gridwidget_101;
			//lastEditedCell = { rwn:rwn, boundIndex: rowBoundIndex, dataField: dataField, event: event} ;
			var dataField = lastEditedCell.dataField;
			var rowBoundIndex = lastEditedCell.boundIndex;
			confirmLabel = confirmLabel.replace('{ROW_NUM}', lastEditedCell.rwn);
			cols.forEach(function (it, index) {
				if(it.datafield && !Number.isInteger(it.datafield) && !it.hidden && it.datafield !== 'RWN'){
					colNames.push(it.datafield);
					colTypes[it.datafield] = it.columntype;
					if(it.datafield === currentGridDescr.lastEditedCell.dataField)
						confirmLabel = confirmLabel.replace('{COL_NAME}', (it.text)?it.text.replace(/\\n/g,' '):'');
				}
			});
			//ищем индекс колонки, начиная с которой пойдет заполнение
			var startIndex = colNames.indexOf(dataField);
			if(startIndex !== -1){
				var rows = GridUtil.convertPlainExcelDataToTable(currentGridDescr.pasteFromExcelData);
				//получаем элементы, которые будут обновляться
				var rows4Update = [];
				var rows4UpdateIds = []; // массив всех идентификаторов на обновление
				rows.forEach(function (row, index) {
					var valueCounter = 0;
					var rowBoundElement = $(currentGrid).jqxGrid('getrowdata', rowBoundIndex);
					var data = (rowBoundElement.ID)?GridUtil.getFullRowDataById(currentGrid, rowBoundElement):data;
					if(data){
						for(var i = startIndex; i < colNames.length; i++){
							var colName = colNames[i];

							//добавляем в значение колонки по очереди каждый элемент вставляемой строки
							if(valueCounter >= row.length ) break;
							var columnType = colTypes[colName];
							var preparedVal = GridUtil.prepareValueByDataType2(row[valueCounter++], columnType, colName);
							if(preparedVal !== undefined){
								data[colName] = preparedVal;
							}
							//data[colName] = row[valueCounter++];
						}
						rows4Update.push(data);
						rows4UpdateIds.push(data.ID);
					}
					rowBoundIndex++;
				});

				var buttons = [
					{
						text: gis_core_4, click: function () {
							App.destroyDialog(undefined, this);
							that.selectFullDataBeforeUpdateDB(curDataAdapter, rows4Update, function(result){
								var rows4UpdateLength = rows4Update.length;
								rows4Update.forEach(function (it, index) {
									//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
									var itemFromDb = result[it.ID];
									var isLastRow = (rows4UpdateLength - 1) === index;
									if(itemFromDb){
										var extIt = $.extend(itemFromDb,it);
										that.updateCellDB(curDataAdapter, extIt, syncMap, jqxGridId, isLastRow, rows4UpdateIds);
									}
								});

								//that.updateCellDBWithSync(curDataAdapter, rows4Update, jqxGridId, syncMap);
								//TODO добавить счетчик
								//GridWidget.refreshGrid(jqxGridId);
							});
						}
					},
					{
						text: gis_core_5, click: function () {
							App.destroyDialog(undefined, this);
						}
					}
				];

				confirmLabel = confirmLabel.replace('{ROWS_COUNT}', rows4Update.length).replace('{ALL_ROWS_COUNT}', rows.length);
				App.confirmDialog(confirmLabel, buttons, {title:gis_core_1, html:true})
				return;
			}
			throw new Error(gis_gridwidget_88)
		}
	}
	catch(ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_60'});
	}
	finally {
		delete curDataAdapter.currentGridDescr.lastEditedCell;
		curDataAdapter.currentGridDescr.pasteFromExcelData = undefined;
	}
}


/**
 *
 * @param dataAdapter
 * @param data
 * @param syncMap
 * @param jqxGridId  идентификатор грида, который нужно обновить
 * @param isLastRow  если последняя строка - обновляем грид
 * @param rows4UpdateIds весь массив идентификаторов на обновление
 */
GridWidget.prototype.updateCellDB = function(dataAdapter, data, syncMap, jqxGridId, isLastRow, rows4UpdateIds){
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = (!data.ID) ? 'insert' : 'update';
		//добавляем атрибут SYS_OBJ_ID, т.к. update в панелях свойств использует его
		if(descrType === 'update') {
			//для случая ИУС Т добавляем FILTER, для для случая обновления через панель свойств
			data.FILTER = 'ID=' + data.ID;
			data.SYS_OBJ_ID = data.ID;
		}
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(data), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					var title = GridUtil.getDetailDbError(er);
					App.errorReport(title, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_56'
					});
				}
				/*if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, [data.ID], true);
				}*/
			}
			if(isLastRow){
				if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, rows4UpdateIds, true)
				}
				GridWidget.refreshGrid(jqxGridId)
			}

		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				var title = GridUtil.getDetailDbError(er);
				App.errorReport(title, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_57'
				});
			}
			if(isLastRow){
				if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, rows4UpdateIds, true)
				}
				GridWidget.refreshGrid(jqxGridId)
			}
		},4);
	}
}


GridWidget.prototype.updateCellDBWithSync = function(dataAdapter, data, syncMap, jqxGridId, isLastRow){
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = (!data.ID) ? 'insert' : 'update';
		//добавляем атрибут SYS_OBJ_ID, т.к. update в панелях свойств использует его
		if(descrType === 'update') {
			//для случая ИУС Т добавляем FILTER, для для случая обновления через панель свойств
			data.FILTER = 'ID=' + data.ID;
			data.SYS_OBJ_ID = data.ID;
		}
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(data), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					var title = GridUtil.getDetailDbError(er);
					App.errorReport(title, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_56'
					});
				}
				if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, [data.ID], true);
				}
			}
		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				var title = GridUtil.getDetailDbError(er);
				App.errorReport(title, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_57'
				});
			}
		});
	}
}
/**
 * Функция получает полную детализацию данных, которые собираемся редактировать
 * @param dataAdapter
 * @param {Array}  datas
 * @param {function} successCallback
 */
GridWidget.prototype.selectFullDataBeforeUpdateDB = function(dataAdapter, datas, successCallback){
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = 'select';
		var filterIds = [];
		datas.forEach(function (it) {
			filterIds.push(it.ID);
		});
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData({FILTER:'ID in ('+filterIds.join()+')'}), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					App.errorReport(gis_gridwidget_90, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_58'
					});
				}
				else{
					//парсим данные в объект из ключей идентификаторов и отправляем назад в callabck
					var resDatas = {};
					var xmlData = $.parseXML(resultXML);
					//Сохраняем для переиспользования
					$(xmlData).find("data").each(function () {
						var resData = {};
						for (var curAttrInd = 0; curAttrInd < this.attributes.length; curAttrInd++) {
							resData[this.attributes[curAttrInd].name] = this.attributes[curAttrInd].value;
						}
						if(resData.ID === undefined) resData.ID = resData.CODE;
						resDatas[resData.ID] = resData;
					});
					if(successCallback)
						successCallback(resDatas);
				}
			}
		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				App.errorReport(gis_gridwidget_90, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_59'
				});
			}
		});
	}
}


GridWidget.prototype.pasteFromExcelStoIliDataAdvDialog = function(currentGrid, dataAdapter, rowData) {
	var that = this;
	var divv = '<div id="pasteFromExcelStoIliDataAdvDialog">' +
		'<label style="color: #ffffff">' + gis_gridwidget_122 + '</label><br/>'+
		'<label style="color: #ffffff">' + gis_gridwidget_123 + '</label>'+
		'<textarea id="pasteFromExcelText" style="width:465px;margin: 1px;color: #005d98;height: 55px;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text"></textarea>' +
		'</div>';
	$('body').append(divv);
	var dlg = $('#pasteFromExcelStoIliDataAdvDialog');
	var bts = [
		{
			text: gis_core_12,
			click: function(){
				var pastedText =  $('#pasteFromExcelText').val();
				if(pastedText === ''){
					App.confirmDialog(gis_gridwidget_126, null, {title:gis_core_1});
					return;
				}
				if(dataAdapter && dataAdapter.currentGridDescr) {
					dataAdapter.currentGridDescr.pasteFromExcelData = pastedText;
					var dataRequest = 'STO_SEM.xml#STO_ILI_DATA_ADV';
					GridUtil.getProvDataXml(dataRequest, function(parametersTypes){
						// parametersTypes - переменная, куда заносим типы колонок из файла запросов для данной команды, далее ищем по ключу
						GridUtil.pasteStoIliDataAdvCells(currentGrid, dataAdapter, rowData, dataRequest, parametersTypes, that, true);
					})
				}
				$('#pasteFromExcelStoIliDataAdvDialog').remove();
			}
		},
		{
			text: gis_core_6,
			click: function(){
				$('#pasteFromExcelStoIliDataAdvDialog').remove();
			}
		}];
	dlg.dialog({
		modal: true,
		title: gis_gridwidget_119,
		dialogClass: 'ui-dialog-confirm noCloseButton gsi-zindex__dialog',
		closeOnEscape: true,
		width: 474,
		height: 250,
		resizable: false,
		buttons : bts
	});
};

GridWidget.linkStoDataAdv = function(iliInspectionId, jqxGridId){
	BlockingUtil.wait();
	var reqParams = DBUtil.getReqParams('STO_SEM.xml#STO_ILI_DATA_ADV_LINK', DBUtil.serializeData({ILI_INSPECTION_ID: iliInspectionId}), 'update');
	App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
		BlockingUtil.ready();
		if (resultXML) {
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				var title = GridUtil.getDetailDbError(er);
				App.errorReport(title, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_56'
				});
			}
			else { //обновляем грид
				GridWidget.refreshGrid(jqxGridId);
				App.confirmDialog(gis_gridwidget_128);
			}
		}
	},function (resultXML) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXML);
		if (er !== "") {
			var title = GridUtil.getDetailDbError(er);
			App.errorReport(title, er, undefined, {
				filename: gis_filename_243,
				functionname: 'gis_filename_243_57'
			});
		}
	},4);
}


/**
 * Функция обновления содержимого грида по входящему новому фильтру. Т.к. название слоя, отвечающего за грид совпадает,
 * то для исключения избыточных запросов на загрузку описания грида xml, справочников   перезапрашиваем только данные на основе нового фильтра
 * @param filter
 */
GridWidget.prototype.updateGridContent = function(filter, forceTopFilter, forceRefresh, parentRoughFilter, filterMap, parentRoughParams, staticParentRoughFilter){
	this.filter = filter;
	this.modified = false;
	var gridElem = $("#" + this.id);
	//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
	if (gridElem.length === 0 && !this.dataAdapter)
		return;


	//var dataAdapter = $(gridElem).jqxGrid('source');
	var gridDescription = this.dataAdapter.currentGridDescr;
	/*gridDescription.source = dataAdapter;
	gridElem.jqxGrid(gridDescription);*/

	var curFilter = filter;
	var topFilter = (forceTopFilter !== true) ? gridDescription.topFilter : [];

	var fArr = [];
	//если был верхний фильтр, то параметры заменяем только те, что совпадают по имени
	if(topFilter && topFilter.length > 0){
		topFilter.forEach(function(item){
			var finded = false;
			for(var obj in filter){
				if(item.name === obj){
					fArr.push({name:obj, value:filter[obj]});
					finded = true;
					break;
				}
			}
			if(!finded) {
				fArr.push(item);
			}
		});
	}
	else{
		for(var obj in filter){
			fArr.push({name:obj, value:filter[obj]});
		}
	}
	fArr = GridWidget.removeDuplicateFilterData(fArr);
	this.filters = fArr;

	var gridId = 'jqxgrid'+this.id;
	//Сохраняем его в виджет грида и перезапршиваем грид
	gridDescription.topFilter = fArr;//$.extend( gridDescription.topFilter, filter ); //верхний фильтр
	gridDescription.currentFilter = []; // нижний фильтр
	gridDescription.roughFilter = []; //средний фильтр
	//обнулуляем нижний фильтр
	try{
		$('#'+gridId+'_bottomFilter').remove(); //jqxgridid8254_GRID_bottomFilter
	}
	catch(ex){ }

	//обнуляем сортировку
	gridDescription.currentSort = [];
	//обнуляем закешированные данные
	this.cachedRecords = [];
	this.parentRoughFilter = undefined;
	this.parentRoughParams = undefined;
	this.staticParentRoughFilter = undefined;
	if(parentRoughFilter) this.parentRoughFilter = parentRoughFilter;
	if(parentRoughParams) this.parentRoughParams = parentRoughParams;
	if(staticParentRoughFilter) this.staticParentRoughFilter = staticParentRoughFilter;
	if(filterMap) this.filterMap = filterMap;

	//обнуляем текущее состояние(если скрывали колонки)
	this.currentState = null;
	//Перезапрашиваем грид
	GridWidget.refreshGrid(gridId, forceRefresh === true);//jqxgridid4438_GRID
};

GridWidget.removeDuplicateFilterData = function(filter){
	return filter;
}

/**
 * Функция обновления грида на обснове изменных колонок
 * @param currentGrid
 * @param columns
 */
GridWidget.prototype.updateDataWithColumns = function(currentGrid, columns){
	var gridWidget = App && App.GridManager && App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''))//jqxgridid9860_GRID
	var dataArr = gridWidget.cachedRecords;
	var dataAdapter = gridWidget.dataAdapter;
	gridWidget.columns = columns;
	gridWidget.modified = true;

	//сначала фильтруем начальные данные по видимым колонкам
	var hiddenColumns = [];

	columns.forEach(function (column) {
		if (column.hidden)
			hiddenColumns.push(column);
	})
	dataArr = GridUtil.filterDataFromJson(dataArr, hiddenColumns);
	var visibleDataArr = dataArr;
	if (gridWidget.jqxDataAdapterCallback !== undefined) {
		var resultObj = {
			records: visibleDataArr,
			totalrecords: dataAdapter.totalrecords
		};
		//dataAdapter.localdata = visibleDataArr;
		$(currentGrid).jqxGrid({ columns: columns });
		//Добавляем через имеющуюся функцию обратного вызова плагина jqxDataAdapter
		gridWidget.jqxDataAdapterCallback(resultObj);
		$(currentGrid).jqxGrid('render');
	}
	else {
		/*gridSource.localdata = gridData;
		//Обновляем записи в гриде
		$(currentGrid).jqxGrid({ source: gridSource });*/
	}
}



GridWidget.successIliReportCalcCorr = function(){
	//перезагружаем слои из сценариев на карте
	ExternalInteraction.showLayers(App.scenarioManager.openLayers)
	App.confirmDialog(gis_gridwidget_157, null, {title: gis_core_1});
}

GridWidget.prototype.setLayerId = function(layerId) {
	var lId = layerId;
	if(layerId && layerId.indexOf('#') !== -1){
		this.layerId = layerId.split('#')[1];
		this.fullLayerId = layerId.replace('#', '*');
		lId = this.layerId;
	}
	return lId;
}

var GRID_ADM_PROCESS_STATUS = {
	NO_PROCESS: 0, //нет процесса в файле лога
	LOADING: 1, // задача в процессе выполнения
	ERROR: 2, // в логе возникла ошибка
	DONE: 4, // задача выполнена
	CRITIC_ERROR: 8 // критическая ошибка на строне сервера
};

/**
 * Функции js-виджета грида для административных задач. Серверные вызовы
 */
GridAdmInternal = {};
GridAdmInternal.MonitorManager = {};
GridAdmInternal.MONITOR_INTERVAL = 10000;

//мониторинг процесса
/**
 *
 * @param processGuid
 * @param taskName
 * @param currentMessageId
 * @param onResult
 * @param onFault
 * @param onCancel
 * @param isNodeMonitor флаг, использовать мониторинг нужно в логе uteService или nodejs
 */
GridAdmInternal.monitorProcess = function(processGuid, taskName, currentMessageId, onResult, onFault, onCancel, isNodeMonitor){
	if(!GridAdmInternal.MonitorManager[processGuid]){
		var canHandle = false;// можно ли использовать таймаут старого вызова
		//первый флаг true
		GridAdmInternal.MonitorManager[processGuid] = {
			canHandle : canHandle,
			onResult: onResult,
			onFault: onFault,
			handled: false, //не будет использоваться
			handledUteTimeout: false, // таймаут от ute
			handledUteError: false, //ошибка от ute
			handledUteSuccess: false, // успешный результат от ute
			handledNodeInfo: false,// флаг, что мониторинг невозможет
			handledNodeError: '',//тест ошибки в процессе мониторинга
			currentMessageId: currentMessageId
		}
	}
	var monitor = GridAdmInternal.MonitorManager[processGuid];
	var interval = setInterval(function () {
		monitor.canHandle = false;
		if(monitor.handled){// если обработали успешный результат от ute
			delete GridAdmInternal.MonitorManager[processGuid];
			clearInterval(interval);
			return;
		}
		App.getUTEProcessStatus(processGuid, isNodeMonitor,
		function(res){
			if(res){
				switch (res.status) {
					case GRID_ADM_PROCESS_STATUS.NO_PROCESS:// удалили лог. 
						clearInterval(interval);
						monitor.handledNodeInfo = true;
						GridAdmInternal.handleNodeFault(processGuid, isNodeMonitor);
						break;
					case GRID_ADM_PROCESS_STATUS.DONE:
						try{
							clearInterval(interval);
							if(monitor.currentMessageId){
								var cmId = monitor.currentMessageId;
								cmId.abort();
								BlockingUtil.ready();
								if(onResult){
									var responseText;
									if(cmId.responseText)
										responseText = cmId.responseText.replace(/&apos;/g, "'").replace(/&quot;/g, '"').replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&amp;/g, '&');
									onResult(responseText || cmId.statusText);//если ошибка по таймауту либо другая ошибка сервера, то statusText == undefined
								}
								cmId = undefined;
							}
						}
						catch(ex){
							clearInterval(interval);
							monitor.handledNodeInfo = true;
							GridAdmInternal.handleNodeFault(processGuid, isNodeMonitor);
							LogUtil.sendLog(gis_gridadminternal_6 + ' getUTEProcessStatus success GRID_ADM_PROCESS_STATUS.DONE catch: ' + ex.message, "Data Access", LogUtil.Severity_ERROR);
						}
						break;
					case GRID_ADM_PROCESS_STATUS.LOADING:
						break;
					case GRID_ADM_PROCESS_STATUS.ERROR:
						// monitor.canHandle = true;
						monitor.handledNodeInfo = false;
						monitor.handledNodeError = '<error>'+res.error+'</error>';
						GridAdmInternal.handleNodeFault(processGuid, isNodeMonitor);
						clearInterval(interval);
						break;
					case GRID_ADM_PROCESS_STATUS.CRITIC_ERROR:
						clearInterval(interval);
						monitor.handledNodeInfo = true;
						// monitor.canHandle = true;
						GridAdmInternal.handleNodeFault(processGuid, isNodeMonitor);
						LogUtil.sendLog(gis_gridadminternal_6 + ' getUTEProcessStatus success GRID_ADM_PROCESS_STATUS.CRITIC_ERROR: ' + res.error, "Data Access", LogUtil.Severity_ERROR);
						break;
				}
			}
			else{  //не можем отследить процесс
				clearInterval(interval);
				monitor.handledNodeInfo = true;
				//monitor.canHandle = false;
				GridAdmInternal.handleNodeFault(processGuid, isNodeMonitor);
				LogUtil.sendLog(gis_gridadminternal_6 + ' getUTEProcessStatus success res=undefined: ' + gis_app_55_23, "Data Access", LogUtil.Severity_ERROR);
			}

		},
		function(res){ //nodejs не работает
			// не можем отследить процесс
			clearInterval(interval);
			//monitor.canHandle = false;
			monitor.handledNodeInfo = true;
			GridAdmInternal.handleNodeFault(processGuid, isNodeMonitor);
			LogUtil.sendLog(gis_gridadminternal_6 + ' getUTEProcessStatus fault: ' + res, "Data Access", LogUtil.Severity_ERROR);

		});
	}, GridAdmInternal.MONITOR_INTERVAL);
};


/**
 * Обработка ошибок мониторинга
 * @param processGuid
 * @param isNodeMonitor флаг, что используем задачу, запущенную в nodejs(импорт/экспорт карт)
 */
GridAdmInternal.handleNodeFault = function(processGuid, isNodeMonitor){
	var error = gis_gridadminternal_2; //потеряна связь
	//handledUteTimeout: false, // таймаут от ute
	//handledUteError: false, // ошибка от ute
	//handledUteSuccess: false, // успешный результат от ute
	var isConfirmDialog = false;
	var monitor = GridAdmInternal.MonitorManager[processGuid];
	var onFault = monitor.onFault;
	var isError = true;
	//if(GridAdmInternal.MonitorManager[processGuid].faultData && onFault)
	if(onFault){
		// если ошибка критическая(не доступен nodejs)
		// не можем мониторить и выдаем сообщение
		// если ошибка таймаута была, то выдаем сообщение от node, что не можем отследить процесс
		//Если ute ещё работает, то не показываем сообщений
		if(!monitor.handledNodeInfo && monitor.handledNodeError){
			error = monitor.handledNodeError;
		}
		else if(!monitor.handledUteTimeout){
			if( monitor.handledNodeInfo)
				monitor.canHandle = true;
			if(!isNodeMonitor)
				return;
		}
		if(error)
			onFault(error, isConfirmDialog, isError);
		else if(monitor.faultData)
			onFault(monitor.faultData, isConfirmDialog, isError);
		else if(monitor.resultData)
			onFault(monitor.resultData, isConfirmDialog, isError);
		delete monitor.onFault;
	}
}


/**
 * Коллбек удачного выполнения серверного вызова
 * @param data
 * @param processGuid
 */
GridAdmInternal.onResult = function(data, processGuid){
	var monitor = GridAdmInternal.MonitorManager[processGuid];
	try{
		//если нет результата от ноды
		var onResult = monitor.onResult;
		if(onResult){
			monitor.handled = true;
			onResult(data);
		}
	}
	catch(ex){
	}
}

/**
 * Коллбек удачного выполнения серверного вызова
 * @param data
 * @param processGuid
 */
GridAdmInternal.onNodeResult = function(data, processGuid){
	var monitor = GridAdmInternal.MonitorManager[processGuid];
	try{
		//если нет результата от ноды
		var onResult = monitor.onResult;
		if(onResult){
			monitor.handled = true;

			onResult(data);
		}
	}
	catch(ex){
	}
}

/**
 * Ошибка серверного вызова по вине apache
 * @param data
 * @param processGuid
 */
GridAdmInternal.onFault = function(data, processGuid){
	//return;
	//если таймаут UTE
	var monitor = GridAdmInternal.MonitorManager[processGuid];
	var isTimeoutError = data && data.indexOf(gis_app_55_13) !== -1;
	monitor.handledUteTimeout = isTimeoutError;
	try{
		if(monitor.canHandle){
			var onFault = monitor.onFault;
			if(onFault){
				monitor.handled = true;
				//if(monitor.handledNodeInfo)
				data = '<error>'+gis_gridadminternal_2+'</error>';
				onFault(data);
			}
		}
		else{
			monitor.faultData = data;
		}
	}
	catch(ex){
	}
}

/**
 * Ошибка серверного вызова по вине apache
 * @param data
 * @param processGuid
 */
GridAdmInternal.onNodeFault = function(data, processGuid){
	//return;
	//если таймаут UTE
	var monitor = GridAdmInternal.MonitorManager[processGuid];
	var isTimeoutError = data && data.indexOf(gis_app_55_13) !== -1;
	monitor.handledUteTimeout = isTimeoutError;
	try{
		if(monitor.canHandle){
			var onFault = monitor.onFault;
			if(onFault){
				monitor.handled = true;
				data = '<error>'+gis_gridadminternal_2+'</error>';
				onFault(data);
			}
		}
		else{
			monitor.faultData = data;
		}

	}
	catch(ex){
	}
}




/**********************  Задача администрирования отчетов ВТД ******************/
//Импорт отчетов XML
GridAdmInternal.gridAdmIliImportXML = function(context){
	if(!context) return;
	var guid = GridAdmInternal.generateProcessGUID();
	var processGuid = guid;//'78e29bcf';
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var widgetElementId = context.widgetElementId;
	var dataAdapter = context.dataAdapter;

	//Добавляем div панели свойств для создания формы ввода
	var gridPropPanelId = 'divFormPPanel_gridAdmIliImportXML';
	var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		top: 30,
		opener: "#" + widgetElementId,
		objects:[{id: "ADM_ILI_IMPORT_XML", label: gis_gridadmwidget_65}],
		handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
				if (dataObject) {
					if(dataObject/* && dataObject.ILI_DATA_ADV*/){
						//доп. проверка с сообщением сколько будет добавлено записей с доп. информацией
						/*dataAdapter.currentGridDescr.pasteFromExcelData = dataObject.ILI_DATA_ADV;
						var rows4Insert = GridUtil.convertPlainExcelDataToTable(dataObject.ILI_DATA_ADV, true);
						var buttons = [
							{
								text: gis_core_4, click: function () {
									delete dataObject.ILI_DATA_ADV;*/
									/*var _baseOutputData = '<input process_id="'+processGuid+'" xml_file_name="" do_calc_inspection="true" ' +
										'pipe="" km_start="" km_end="" date="" format="xml" ' +
										'company="" ps_idx="false" />';
									var sendingData = GridAdmInternal.convertSimpleObjectToXml_($.extend(GridAdmInternal.convertXmlToSimpleObject_(_baseOutputData), dataObject));*/
						/*var _baseOutputData = '<input process_id="'+processGuid+'" root_path="" xml_file_name="" do_calc_inspection="True" data_file_name="'+dataObject.xml_file_name+'" pipe="" route_id="" ROUTE_ID="" km_start="" km_end="" date="" format="xml" ' +
							'company="" ps_idx="False" start_odometr="" end_odometr="" tool_type_cl="" model="" sensor_gcl="" sensor_spacing_min="" sensor_spacing_max="" min_temp="" max_temp="" avg_temp="" ' +
							'min_velocity="" max_velocity="" avg_velocity="" sampling_frequency="" resolution="" rated_max_velocity="" rated_max_wt="" cluster_rule_cl="" source_gcl="UNKNOWN" weld_increment="" />';*/

						var _baseOutputData = '<input process_id="'+processGuid+'" root_path="" xml_file_name="" do_calc_inspection="true" data_file_name="'+dataObject.xml_file_name+'" pipe="" route_id="" ROUTE_ID="" km_start="" km_end="" date="" format="xml" ' +
							'company="" ps_idx="false" start_odometr="" end_odometr="" tool_type_cl="" model="" sensor_gcl="" sensor_spacing_min="" sensor_spacing_max="" min_temp="" max_temp="" avg_temp="" ' +
							'min_velocity="" max_velocity="" avg_velocity="" sampling_frequency="" resolution="" rated_max_velocity="" rated_max_wt="" cluster_rule_cl="" source_gcl="UNKNOWN" weld_increment="" />';
						//Путь здесь должен быть таким: sendingData.@zip_file_name = config.UPLOAD_PATH+_model["USER"].uid+"\\"+uploadedFileName;
						var sendingData = GridAdmInternal.convertSimpleObjectToXml_($.extend(GridAdmInternal.convertXmlToSimpleObject_(_baseOutputData), dataObject));
						var uploadPath = App.config && App.config.hasOwnProperty("UPLOAD_PATH") ? App.config['UPLOAD_PATH'] : '';
						//заменяем названия флагов, чтобы шаблоны корректно огбрабатывали их.
						sendingData = sendingData.replace('xml_file_name="','xml_file_name="'+uploadPath)
									var currentTemplate = 'ILI_ZIP_Imp_55.xml';
									//UPD. добавляем в переданные чекбокс
									if(dataObject.do_calc_cluster === 'Y'){
										currentTemplate+='|ILI_Cluster.xml';
										sendingData+='|<input pressure="7.4" thickness="16"  inspection_id="{ILI_INSPECTION_ID}"/>';
										dataAdapter.currentGridDescr.calcClusterData = '<input pressure="7.4" thickness="16"  inspection_id="{ILI_INSPECTION_ID}"/>';
									}
									if(dataObject.do_calc_pressure === 'Y'){
										currentTemplate+='|ILI_Pressure.xml';
										sendingData+='|<input inspection_id="{ILI_INSPECTION_ID}" pressure="7.36" breaking_point="588" yielding_limit="490" elastic_modulus="206000" safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" safety_factor_of_destination="1.34" route_category="4" thickness="16" calc_sto_2_2_3_112_2007="true" calc_sto_2_2_3_173_2007="true" calc_sto_2_2_3_292_2009="true" calc_sto_2_2_3_401_2009="true" calc_sto_2_2_3_595_2011="true" calc_sto_2_2_3_620_2011="true" calc_sto_ltg="true" resilience="142"  />';
										dataAdapter.currentGridDescr.calcClusterPressure = '<input inspection_id="{ILI_INSPECTION_ID}" pressure="7.36" breaking_point="588" yielding_limit="490" elastic_modulus="206000" safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" safety_factor_of_destination="1.34" route_category="4" thickness="16" calc_sto_2_2_3_112_2007="true" calc_sto_2_2_3_173_2007="true" calc_sto_2_2_3_292_2009="true" calc_sto_2_2_3_401_2009="true" calc_sto_2_2_3_595_2011="true" calc_sto_2_2_3_620_2011="true" calc_sto_ltg="true" resilience="142"  />';
									}
									if(dataObject.do_calc_sto === 'Y'){
										currentTemplate+='|STO_ILI_INSP_Proc.xml';
										sendingData+='|<input calc_line_events="True" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {ILI_INSPECTION_ID}" calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" regular_intervals_distance="100" pressure="7.36" breaking_point="588" safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" safety_factor_of_destination="1.34" thickness="16" lifetime="25" average_cost_of_responding="150" cost_of_replacing_a_pipe="0.6" cost_of_the_ILI_per_km="0.1" cost_per_hole="0.2" cost_of_repair_per_km="23.8" calc_sto_2_2_3_292_2007="true" calc_sto_2_2_3_401_2003="true" calc_sto_2_2_3_095_2007="true" calc_sto_xxx="true"  inspection_id="{ILI_INSPECTION_ID}"/>';
										dataAdapter.currentGridDescr.calcSto = '<input calc_line_events="True" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {ILI_INSPECTION_ID}" calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" regular_intervals_distance="100" pressure="7.36" breaking_point="588" safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" safety_factor_of_destination="1.34" thickness="16" lifetime="25" average_cost_of_responding="150" cost_of_replacing_a_pipe="0.6" cost_of_the_ILI_per_km="0.1" cost_per_hole="0.2" cost_of_repair_per_km="23.8" calc_sto_2_2_3_292_2007="true" calc_sto_2_2_3_401_2003="true" calc_sto_2_2_3_095_2007="true" calc_sto_xxx="true"  inspection_id="{ILI_INSPECTION_ID}"/>';
									}
									if(dataObject.do_calc_sto_for_ehz === 'Y'){
										currentTemplate+='|STO_EHZ_INSP_Proc.xml';
										sendingData+='|<input calc_line_events="True" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {ILI_INSPECTION_ID}" calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" regular_intervals_distance="100" install_date="11.6.2002" calc_sto_xxx="true"  inspection_id="{ILI_INSPECTION_ID}"/>';
										dataAdapter.currentGridDescr.calcStoEhz = '<input calc_line_events="True" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {ILI_INSPECTION_ID}" calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" regular_intervals_distance="100" install_date="11.6.2002" calc_sto_xxx="true"  inspection_id="{ILI_INSPECTION_ID}"/>';
									}
									var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
									BlockingUtil.wait();
									var currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliImportXml, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
									GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
									App.destroyDialog(undefined, this);
								/*}
							},
							{
								text: gis_core_5, click: function () {
									App.destroyDialog(undefined, this);
								}
							}
						];
						App.confirmDialog(gis_gridwidget_111.replace('{ROWS_COUNT}', rows4Insert.length), buttons, {title:gis_core_1, html:true});
						*/
					}

				} else {
					App.errorReport(gis_gridwidget_5, gis_gridadmwidget_66, undefined, {filename:gis_filename_188, functionname:'gis_filename_188_41'});
				}
			}}
	});
}
//1. Группировка дефектов в кластеры
GridAdmInternal.gridAdmIliCalcCluster = function(context ){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var dataObj = context.dataObj;
	var currentMessageId;
	var iliCalcClusterArray = dataObj;
	//Добавляем div панели свойств для создания формы ввода
	gridPropPanelId = 'divFormPPanel_gridAdmIliCalcCluster';
	gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects:[{id: "ADM_ILI_CLUSTER", label: gis_gridadmwidget_70}],
		handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
				if (dataObject) {
					GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_71,iliCalcClusterArray,that,
						function processSingleInspectionCluster(inspectionCluster) {
							if (inspectionCluster && inspectionCluster.hasOwnProperty("ID")){
								var guid = GridAdmInternal.generateProcessGUID();
								var processGuid = guid;//'78e29bcf';
								var sendingData = GridAdmInternal.convertSimpleObjectToXml_(dataObject); /*'<input/>';*/
								sendingData = sendingData.replace('/>',' inspection_id="'+inspectionCluster.ID+'" process_id="'+processGuid+'"/>');
								var currentTemplate = "ILI_Cluster.xml";
								var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								BlockingUtil.wait();

								currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliCluster, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
							}
							else if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
						},
						endProcess, cancelProcess, true);
				} else {
					App.errorReport(gis_gridwidget_5, gis_gridadmwidget_72, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_43'});
				}
			}}
	});


}
//2. Расчет точечных показателей в соответствии с СТО 112, 173, 292, 401, 595
GridAdmInternal.gridAdmIliCalcPressure = function(context ){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var dataObj = context.dataObj;
	var currentMessageId;
	var iliCalcPressureArray = dataObj;


	//Добавляем div панели свойств для создания формы ввода
	gridPropPanelId = 'divFormPPanel_gridAdmIliCalcPressure';
	gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects:[{id: "ADM_ILI_PRESSURE", label: gis_gridadmwidget_73}],
		handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
				if (dataObject) {

					GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_74,iliCalcPressureArray,that,
						function processSingleInspectionCluster(inspectionPressure) {
							if (inspectionPressure && inspectionPressure.hasOwnProperty("ID")){
								var processGuid = GridAdmInternal.generateProcessGUID();//'78e29bcf';
								var _baseOutputData = '<input process_id="'+processGuid+'" inspection_id="1300497" pressure="7.36" breaking_point="588" yielding_limit="490" elastic_modulus="206000" ' +
									'safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" ' +
									'safety_factor_of_destination="1.34" route_category="4" thickness="16" calc_sto_2_2_3_112_2007="true" calc_sto_2_2_3_173_2007="true" ' +
									'calc_sto_2_2_3_292_2009="true" calc_sto_2_2_3_401_2009="true" calc_sto_2_2_3_595_2011="true" calc_sto_2_2_3_620_2011="true" calc_sto_ltg="true" />';
								var sendingData =  GridAdmInternal.convertSimpleObjectToXml_($.extend( GridAdmInternal.convertXmlToSimpleObject_(_baseOutputData), dataObject));
								sendingData = sendingData.replace(' inspection_id="1300497"',' inspection_id="'+inspectionPressure.ID+'"');
								var currentTemplate = "ILI_Pressure.xml";
								var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								BlockingUtil.wait();
								currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliPressure, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
							}
							else if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
						},
						endProcess, cancelProcess, true);
				} else {
					App.errorReport(gis_gridwidget_5, gis_gridadmwidget_75, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_44'});
				}
			}}
	});

}
//3. Расчет линейных показателей в соответствии с СТО 095, 292, 401
GridAdmInternal.gridAdmIliCalcSTO = function(context ){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var dataObj = context.dataObj;
	var currentMessageId;
	var iliCalcSTOArray = dataObj;
	//Добавляем div панели свойств для создания формы ввода
	gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcSTO";
	gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects:[{id: "ADM_ILI_STO", label: gis_gridadmwidget_76}],
		handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
				if (dataObject) {

					GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_77,iliCalcSTOArray,that,
						function processSingleInspectionCluster(inspectionSTO) {
							if (inspectionSTO && inspectionSTO.hasOwnProperty("ID")){
								var guid = GridAdmInternal.generateProcessGUID();
								var processGuid = guid;//'78e29bcf';
								var _baseOutputData = '<input process_id="'+processGuid+'" calc_line_events="True" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {INSPECTION_ID}" ' +
									'calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" regular_intervals_distance="100" pressure="7.36" ' +
									'breaking_point="588" safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" safety_factor_of_destination="1.34" ' +
									'thickness="16" lifetime="25" average_cost_of_responding="150" cost_of_replacing_a_pipe="0.6" cost_of_the_ILI_per_km="0.1" cost_per_hole="0.2" cost_of_repair_per_km="23.8" ' +
									'calc_sto_2_2_3_292_2007="true" calc_sto_2_2_3_401_2003="true" calc_sto_2_2_3_095_2007="true" calc_sto_xxx="true" />';
								var sendingData = GridAdmInternal.convertSimpleObjectToXml_($.extend(GridAdmInternal.convertXmlToSimpleObject_(_baseOutputData), dataObject));
								//Добавляем inspectionSTO.ID также в текст запроса line_events_query
								sendingData = sendingData.replace('{INSPECTION_ID}',inspectionSTO.ID);
								sendingData = sendingData.replace('/>',' inspection_id="'+inspectionSTO.ID+'"/>');
								//sendingData = sendingData.replace('calc_line_events="true"','calc_line_events="True"');
								//sendingData = sendingData.replace('calc_line_events="false"','calc_line_events="False"');
								var currentTemplate = "STO_ILI_INSP_Proc.xml";
								var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								BlockingUtil.wait();
								currentMessageId = App.serverQueryXMLGridNewNode(Services.uteStoIliInspProc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true)
							}
							else if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
						},
						endProcess, cancelProcess, true);
				} else {
					App.errorReport(gis_gridwidget_5, gis_gridadmwidget_78, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_45'});
				}
			}}
	});

}
//4. Расчет линейных показателей в соответствии с инструкцией ВНИИГАЗ 2004
GridAdmInternal.gridAdmIliCalcSTOforEHZ = function(context){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var dataObj = context.dataObj;
	var currentMessageId;
	var iliCalcSTOforEHZArray = dataObj;

	//Добавляем div панели свойств для создания формы ввода
	gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcSTOforEHZ";
	gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects:[{id: "ADM_ILI_STO_FOR_EHZ", label: gis_gridadmwidget_79}],
		handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
				if (dataObject) {
					GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_80,iliCalcSTOforEHZArray,that,
						function processSingleInspectionCluster(inspectionSTOforEHZ) {
							if (inspectionSTOforEHZ && inspectionSTOforEHZ.hasOwnProperty("ID")){
								var guid = GridAdmInternal.generateProcessGUID();
								var processGuid = guid;//'78e29bcf';
								var _baseOutputData = '<input process_id="'+processGuid+'" calc_line_events="True" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {INSPECTION_ID}" ' +
									'calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" ' +
									'regular_intervals_distance="100" install_date="06.11.2002" calc_sto_xxx="true" />';
								var sendingData = GridAdmInternal.convertSimpleObjectToXml_($.extend(GridAdmInternal.convertXmlToSimpleObject_(_baseOutputData), dataObject));
								//Добавляем inspectionSTOforEHZ.ID также в текст запроса line_events_query
								sendingData = sendingData.replace('{INSPECTION_ID}',inspectionSTOforEHZ.ID);
								sendingData = sendingData.replace('/>',' inspection_id="'+inspectionSTOforEHZ.ID+'"/>');
								var currentTemplate = "STO_EHZ_INSP_Proc.xml";
								var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								BlockingUtil.wait();

								currentMessageId = App.serverQueryXMLGridNewNode(Services.uteStoEhzInspProc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true)
							}
							else if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
						},
						endProcess, cancelProcess, true);
				} else {
					App.errorReport(gis_gridwidget_5, gis_gridadmwidget_81, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_46'});
				}
			}}
	});
}

//Пересчет отчетов
GridAdmInternal.gridAdmIliCalc = function(context ){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var dataObj = context.dataObj;
	var currentMessageId;
	//Добавляем div панели свойств для создания формы ввода
	gridPropPanelId = 'divFormPPanel_gridAdmIliCalc';
	gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects:[{id: "ADM_ILI_INSP_PROC", label: gis_gridadmwidget_82}],
		handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
				if (dataObject) {
					var iliCalcArray = dataObj;
					GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_68,iliCalcArray,that,
						function processSingleInspection(inspection) {
							if (inspection && inspection.hasOwnProperty("ID")){
								var guid = GridAdmInternal.generateProcessGUID();
								var processGuid = guid;//'78e29bcf';
								var sendingData = GridAdmInternal.convertSimpleObjectToXml_(dataObject); /*'<input/>';*/
								sendingData = sendingData.replace('/>',' inspection_id="'+inspection.ID+'" process_id="'+processGuid+'" />');
								var currentTemplate = "ILI_INSP_Proc.xml";
								var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								BlockingUtil.wait();
								if(dataObject.link_repers === 'Y')
									currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliInspLink, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								else
									currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliInspCalc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
							}
							else if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
						},
						endProcess, cancelProcess, true);
				} else {
					App.errorReport(gis_gridwidget_5, gis_gridadmwidget_72, undefined, {filename:gis_filename_188, functionname:'gis_filename_188_57'});
				}
			}}
	});

}



/**********************  Задача администрирования трубопроводов ******************/
//Пересчет линейной дистанции
GridAdmInternal.gridAdmRoutesLrsCalc = function(context ){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var lrsCalcArray = context.dataObj;
	var currentMessageId;
	GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_49,lrsCalcArray,that,
		function processSingleLrsCalc(route) {
			if (route && route.hasOwnProperty("ID")){
				var guid = GridAdmInternal.generateProcessGUID();
				var processGuid = guid;//'78e29bcf';
				var sendingData = '<input process_id="'+processGuid+'" route_id="'+route.ID+'"/>';
				var currentTemplate = "LRS_ROUTE_Calc.xml";
				var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
				BlockingUtil.wait();
				currentMessageId = App.serverQueryXMLGridNewNode(Services.uteLrsRouteCalc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
				GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
			}
			else if (GridAdmWidget.processStatusForm)
				GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_50);
		},
		endProcess, cancelProcess, true);
}
//Пересчет километража
GridAdmInternal.gridAdmRoutesKmCalc = function( context ){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var kmCalcArray = context.dataObj;
	var currentMessageId;

	GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_51,kmCalcArray,that,
		function processSingleKmCalc(route) {
			if (route && route.hasOwnProperty("ID")){
				var guid = GridAdmInternal.generateProcessGUID();
				var processGuid = guid;//'78e29bcf';
				var sendingData = '<input process_id="'+processGuid+'" route_id="'+route.ID+'"/>';
				var currentTemplate = "KM_ROUTE_Calc.xml";
				var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
				BlockingUtil.wait();

				currentMessageId = App.serverQueryXMLGridNewNode(Services.uteKmRouteCalc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
				GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
			}
			else if (GridAdmWidget.processStatusForm)
				GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_50);
		},
		endProcess, cancelProcess, true);
};


//Группировка пересек. объектов
GridAdmInternal.gridAdmRoutesGroupByRoute = function (context) {
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var dataObj = context.dataObj;
	var currentMessageId;

	//Формируем список routeIds из поля ROUTE_ID
	var groupingByRouteIds = [];
	for (var i = 0; i < dataObj.length; i++) {
		if (groupingByRouteIds && groupingByRouteIds.indexOf(dataObj[i]["ID"]) == -1)
			groupingByRouteIds.push(dataObj[i]["ID"]);
	}
	//Добавляем div панели свойств для создания формы ввода
	gridPropPanelId = 'divFormPPanel_gridAdmRoutesGroupByRoute';
	gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: { saveButton: gis_core_12, cancelButton: gis_core_6 },
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects: [{ id: "ADM_ROUTES_GROUP_BY_ROUTE", label: gis_gridadmwidget_54 }],
		handlers: {
			getFormDataCallback: function getFormDataCallback(dataObject) {
				if (dataObject) {
					var inputGroupingByRouteXML = GridAdmInternal.convertSimpleObjectToXml_(dataObject); /*'<input/>';*/
					GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_115, groupingByRouteIds, that,
						function processSingleOfflineBindingCalc(route) {
							if (route && route !== '') {
								var guid = GridAdmInternal.generateProcessGUID();
								var processGuid = guid;//'78e29bcf';
								var sendingData = inputGroupingByRouteXML;
								sendingData = sendingData.replace('/>', ' route_id="' + route + '" process_id="' + processGuid + '" />');
								var currentTemplate = "GROUP_ROUTE_Idx.xml";
								var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								BlockingUtil.wait();
								currentMessageId = App.serverQueryXMLGridNewNode(Services.uteGroupRouteIdx, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
							} else {
								App.errorReport(gis_gridwidget_5, gis_gridadmwidget_55, undefined, { filename: gis_filename_188, functionname: 'gis_filename_188_35' });
							}
						},
					endProcess, cancelProcess, true);
				}
			}
		}
	});
}

//Привязка вдольтрассовых объектов
GridAdmInternal.gridAdmRoutesOfflineBindingByRoute = function( context ){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var dataObj = context.dataObj;
	var currentMessageId;
	//Формируем список уникальных lineIds из поля LINE_ID
	var offlineBindingByRouteArray = [];
	for (var i = 0; i < dataObj.length; i++) {
		if (offlineBindingByRouteArray && offlineBindingByRouteArray.indexOf(dataObj[i]["LINE_ID"])==-1)
			offlineBindingByRouteArray.push(dataObj[i]["LINE_ID"]);
	}
	//Добавляем div панели свойств для создания формы ввода
	gridPropPanelId = 'divFormPPanel_gridAdmRoutesOfflineBindingByRoute';
	gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects:[{id: "ADM_ROUTES_OFFLINE_BINDING_BY_ROUTE", label: gis_gridadmwidget_56}],
		handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
				if (dataObject) {
					var inputOfflineBindingByRouteXML = GridAdmInternal.convertSimpleObjectToXml_(dataObject);
					//Запускаем процесс обработки полученного массива LINE_ID's
					GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_57,offlineBindingByRouteArray,that,
						function processSingleOfflineBindingCalc(lineId) {
							if (lineId && lineId !== ''){
								var guid = GridAdmInternal.generateProcessGUID();
								var processGuid = guid;//'78e29bcf';
								var sendingData = inputOfflineBindingByRouteXML;
								sendingData = sendingData.replace('/>',' line_id="'+lineId+'" process_id="'+processGuid+'" />');
								var currentTemplate = "OFFLINE_LINE_Idx.xml";
								var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								BlockingUtil.wait();
								currentMessageId = App.serverQueryXMLGridNewNode(Services.uteOfflineRouteIdx, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
							}
							else if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_53);
						},
						endProcess, cancelProcess, true);
				} else {
					App.errorReport(gis_gridwidget_5, gis_gridadmwidget_58, undefined, {filename:gis_filename_188, functionname:'gis_filename_188_36'});
				}
			}}
	});
}

//Привязка трассовых объектов
GridAdmInternal.gridAdmRoutesLineBindingByRoute = function (context) {
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var widgetElementId = context.widgetElementId;
	var gridPropPanelId = context.gridPropPanelId;
	var gridPropPanelDiv = context.gridPropPanelDiv;
	var dataObj = context.dataObj;
	var currentMessageId;
	//Формируем список routeIds из поля ROUTE_ID
	var bindingByRouteIds = [];
	for (var i = 0; i < dataObj.length; i++) {
		if (bindingByRouteIds && bindingByRouteIds.indexOf(dataObj[i]["ID"]) == -1)
			bindingByRouteIds.push(dataObj[i]["ID"]);
	}
	//Добавляем div панели свойств для создания формы ввода
	gridPropPanelId = 'divFormPPanel_gridAdmRoutesLineBindingByRoute';
	gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: { saveButton: gis_core_12, cancelButton: gis_core_6 },
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects: [{ id: "ADM_ROUTES_LINE_BINDING_BY_ROUTE", label: gis_gridadmwidget_59 }],
		handlers: {
			getFormDataCallback: function getFormDataCallback(dataObject) {
				if (dataObject) {
					var inputLineBindingByRouteXML = GridAdmInternal.convertSimpleObjectToXml_(dataObject); /*'<input/>';*/
					GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_114, bindingByRouteIds, that,
						function processSingleOfflineBindingCalc(route) {
							if (route && route !== '') {
								var guid = GridAdmInternal.generateProcessGUID();
								var processGuid = guid;//'78e29bcf';
								var sendingData = inputLineBindingByRouteXML;
								sendingData = sendingData.replace('/>', ' route_id="' + route + '" process_id="' + processGuid + '" />');
								var currentTemplate = "LINE_ROUTE_Idx.xml";
								var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								BlockingUtil.wait();
								currentMessageId = App.serverQueryXMLGridNewNode(Services.uteLineRouteIdx, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
								GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
							} else {
								App.errorReport(gis_gridwidget_5, gis_gridadmwidget_55, undefined, { filename: gis_filename_188, functionname: 'gis_filename_188_37' });
							}
						},
					endProcess, cancelProcess, true);
				}
			}
		}
	});
}
//Разбивка на интервалы
GridAdmInternal.gridAdmRoutesIntervalDividing = function (context){
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var endProcess = context.endProcess;
	var cancelProcess = GridAdmInternal.cancelProcess;
	var dataObj = context.dataObj;
	var currentMessageId;
	var gridAdmRoutesIntervalDividingForm = new GridAdmRoutesIntervalDividingForm();
	gridAdmRoutesIntervalDividingForm.build('divFormPPanel' + "_gridAdmRoutesIntervalDividingForm");
	//Добавляем слушатель закрытия формы
	$("body").on(CloseEvent.CLOSE, function onGridAdmRoutesIntervalDividingFormClose(evt/*CloseEvent*/) {
		$("body").off(CloseEvent.CLOSE);
		if (evt && evt.detail == 1) {
			var dataObject = evt.eventData;
			if (dataObject) {
				GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_52,dataObj,that,
				function (obj) {
					if (obj && obj.ID !== undefined){
						var guid = GridAdmInternal.generateProcessGUID();
						var processGuid = guid;//'78e29bcf';
						//Нужно использовать этот xml в качестве шаблона
						var _baseOutputData = '<input  process_id="'+processGuid+'"  route_id="" regular_intervals="true" regular_intervals_distance="50" feature_types="" construction_element_query="" />';
						var sendingData = '';
						if (dataObject.regular_intervals_distance !== undefined) {
							sendingData = GridAdmInternal.convertSimpleObjectToXml_($.extend(GridAdmInternal.convertXmlToSimpleObject_(_baseOutputData), dataObject));
						} else {
							sendingData = _baseOutputData.replace('regular_intervals="true"','regular_intervals="false"');
							if (dataObject.PODS_FEATURE_TABLE !== undefined) {
								var featureTypesArr = [];
								for (var j = 0; j < dataObject.PODS_FEATURE_TABLE.length; j++) {
									if (dataObject.PODS_FEATURE_TABLE[j].hasOwnProperty("code"))
										featureTypesArr.push(dataObject.PODS_FEATURE_TABLE[j].code);
									}
									sendingData = sendingData.replace('feature_types="','feature_types="'+featureTypesArr.join(","));
							}
							if (dataObject.construction_element_query !== undefined)
								sendingData = sendingData.replace('construction_element_query=""',' construction_element_query="'+dataObject.construction_element_query+'"');
						}
						sendingData = sendingData.replace('route_id=""',' route_id="'+obj.ID+'"');
						var currentTemplate = "Interval_divining_UTE.xml";
						var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
						//Устанавливаем курсор ожидания
						BlockingUtil.wait();
						currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIntervalDivining, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
						GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
					}
					else if (GridAdmWidget.processStatusForm)
						GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_53);
				},
				endProcess, cancelProcess, true);
			} else {
				App.errorReport(gis_gridwidget_5, gis_gridadmwidget_60, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_38'});
			}
		}
	});
}




/***********************  Задача импорта точек/треков             ****************/
GridAdmInternal.importPOI = function(context ){
	if(!context) return;
	var guid = GridAdmInternal.generateProcessGUID();
	var processGuid = guid;//'78e29bcf';
	var onResult = context.onResult;
	var onFault = context.onFault;
	var type = context.type;
	BlockingUtil.wait();
	// sem:'POI_SEM.xml#POI_POINT',
	// geo:'POI_GEO.xml#POI_POINT'
	var sem, geo;
	if(type === 'point'){
		sem = 'POI_SEM.xml#WEB50_POI_POINT';
		geo = 'POI_GEO.xml#WEB50_POI_POINT';
	}
	else{
		sem = 'POI_SEM.xml#WEB50_POI_TRACK';
		geo = 'POI_GEO.xml#WEB50_POI_TRACK';
	}
	App.getJsonTextNode(Services.importGdalNode, {
		process_id: processGuid,
		data: {
			USER_ID: Auth.getUserId(),
			STATUS_ID: 1,
			SOURCE_TYPE: type
		},
		path: Auth.getUid(),
		driver: 'GPX',
		sem: sem,
		geo: geo
	}, onResult, onFault)
}

/***********************  Задача импорта/экспорта карт             ****************/
GridAdmInternal.importMaps = function(context ){
	if(!context) return;
	var guid = GridAdmInternal.generateProcessGUID();
	var processGuid = guid;//'78e29bcf';
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var widgetElementId = context.widgetElementId;
	var dataObj = context.dataObj;
	var currentTemplate = 'IMPORT_MAP';
	//Добавляем div панели свойств для создания формы ввода
	var gridPropPanelId = 'divFormPPanel_gridAdmIliImport';
	var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
	$('#' + gridPropPanelId).remove();
	$("#" + widgetElementId).append(gridPropPanelDiv);
	var sem, geo;
	if (dataObj && dataObj.dataProvider && dataObj.dataProvider.length > 0)
		for (var i = 0; i < dataObj.dataProvider.length; i++) {
			var prov = dataObj.dataProvider[i];
			if (prov.type === 'semantic')
				sem = prov.source;
			if (prov.type === 'spatial')
				geo = prov.source;
		}

	$('#' + gridPropPanelId).myFormPropertiesPanel({
		buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
		zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
		modal: true,
		opener: "#" + widgetElementId,
		objects:[{id: "ADM_MAPS_IMPORT", label: gis_gridadmmapswidget_51}],
		handlers:{getFormDataCallback:function (dataObject){
				if (dataObject) {
					var zip_with_mif_input_path='';
					if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('UPLOAD_PATH')) {
						zip_with_mif_input_path = App.config.UPLOAD_PATH + dataObject.zip_file_name;
					}
					BlockingUtil.wait();
					var currentMessageId = App.getJsonTextNode(Services.importGdalNode, {
						process_id: processGuid,
						data: {
							USER_ID: Auth.getUserId(),
							CLASS_ID: dataObj.uid,
							//PODS_USER: userLogin.xmlEscape()
						},
						options:{
							stop_on_first_error: true,
							ignore_no_geo: !(dataObject.ignore_no_geo === 'N'),
						},
						path: zip_with_mif_input_path,
						driver: 'MapInfo File',
						sem: sem,
						geo: geo
					}, GridAdmInternal.onResult, GridAdmInternal.onFault, processGuid)
					GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);

				}
		}}
	})
}
//Экспорт данных слоя
GridAdmInternal.exportMaps = function(context ){
	if(!context) return;
	var guid = GridAdmInternal.generateProcessGUID();
	var processGuid = guid;//'78e29bcf';
	var onResult = context.onResult;
	var onFault = context.onFault;
	var that = context.that;
	var widgetElementId = context.widgetElementId;
	var dataObj = context.dataObj;
	var currentTemplate = "EXPORT_MAP";
	var sem, geo;
	if (dataObj && dataObj.dataProvider && dataObj.dataProvider.length > 0)
		for (var i = 0; i < dataObj.dataProvider.length; i++) {
			var prov = dataObj.dataProvider[i];
			if (prov.type === 'semantic')
				sem = prov.source;
			if (prov.type === 'spatial')
				geo = prov.source;
		}
	var zip_with_mif_output_path='';
	if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('UPLOAD_PATH')) {
		zip_with_mif_output_path = App.config.UPLOAD_PATH + Auth.getUid() + '/' + dataObj.id + '.zip';
	}
	//Устанавливаем курсор ожидания
	BlockingUtil.wait();
	var currentMessageId = App.getJsonTextNode(Services.exportGdalNode, {
		process_id: processGuid,
		data: {
			USER_ID: Auth.getUserId(),
			CLASS_ID: dataObj.uid
		},
		options:{
			stop_on_first_error: true
		},
		path: zip_with_mif_output_path,
		driver: 'MapInfo File',
		sem: sem,
		geo: geo
	}, GridAdmInternal.onResult, GridAdmInternal.onFault, processGuid)
	GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
}





/********Утилиты**********/

//Простая функция для перевода JSON Object с примитивными атрибутами (без массива) в xml с тегом <input />
GridAdmInternal.convertSimpleObjectToXml_ = function (simpleObj) {
	var resXml = '<input />';
	for (var attrName in simpleObj) {
		var attrValue = (''+simpleObj[attrName]).xmlEscape();
		//Значения "Y" и "N" переводим в true и false для админских серверных задач
		if (attrValue=="Y" || attrValue=="N") attrValue = attrValue=="Y";
		//Добавляем к результирующей строке
		resXml = resXml.replace('/>',attrName+'="'+attrValue+'" />');
	}
	return resXml;
};

//Простая функция для перевода xml с примитивными атрибутами в JSON Object (обязательно надо чтобы заканчивался на '" />' а не '"/>')
GridAdmInternal.convertXmlToSimpleObject_ = function (simpleXml) {
	var resObj = {};
	//root_path="|zip_file_name="|do_calc_inspection="true|do_read_about="true|data_file_name="data.xml"
	simpleXml = simpleXml.replace('<input ','');
	simpleXml = simpleXml.replace('/>','');
	var xmlSplitArr = simpleXml.split('" ');
	for (var i = 0; i < xmlSplitArr.length; i++) {
		var paramSplitArr = xmlSplitArr[i].split('="');
		if (paramSplitArr.length === 2) {
			//Значения true и false переводим в "Y" и "N" для админских серверных задач
			var paramValue = paramSplitArr[1];
			if (paramValue === true || paramValue === false) paramValue = paramValue ? "Y" : "N";
			resObj[paramSplitArr[0]] = paramSplitArr[1];
		}
	}
	return resObj;
};

GridAdmInternal.generateProcessGUID  = function(){
	var d = new Date().getTime();
	var uuid = 'xxxxxxxx'.replace(/[xy]/g, function(c) {
		var r = (d + Math.random()*16)%16 | 0;
		d = Math.floor(d/16);
		return (c=='x' ? r : (r&0x7|0x8)).toString(16);
	});
	return uuid;
};



GridAdmInternal.cancelRequest = function(admReq){
	if(admReq){
		admReq.abort();
		BlockingUtil.ready();
	}
}

//TODO выбрать, этот или  cancelRequestиспользовать. проверить BlockingUtil.ready();
GridAdmInternal.cancelProcess = function (currentMessageId) {
	if (currentMessageId)
		currentMessageId.abort();
	BlockingUtil.ready();
};

//Окончание обработки групповой операции
/*GridAdmInternal.endProcess = function () {
	deleteArray = null;
	// Задача администрирования трубопроводов
	kmCalcArray, lrsCalcArray, makeSrvDistrBndArray, offlineBindingByRouteArray = null;
	// Задача администрирования отчетов ВТД
	iliCalcArray,iliCalcPressureArray,iliCalcPressureInput,iliCalcClusterArray,iliCalcClusterInput,iliCalcSTOArray,iliCalcSTOInput,iliCalcSTOforEHZArray,iliCalcSTOforEHZInput = null;
	// Задача администрирования отчетов ЭХЗ
	cpCalcArray = null;
	// Задача администрирования учетных записей
	addRolesToUsersArray = null;
	// Задача администрирования ролей
	createRolesByLPUArray = null;
	// Задача администрирования политик
	addRolesToPoliciesArray, addPolicyRulesArray = null;
	// Задача администрирования видеомониторинга
	addRoutesToVideosArray = null;
	// Задача администрирования ЛПУ
	addZonesToLpuArray, addNomenclaturesToLpuArray = null;
	// Задача валидачии данных
	bEditControlApplyArray, bEditControlRollbackArray = null;
	//Очищаем форму статуса процесса
	GridAdmWidget.processStatusForm = null;
	//обновляем грид
	refreshGridAfterOperation();
};*/



GridAdmInternal.processPasteFromExcel = function(pastedText, currentGrid, dataAdapter, that){
	if(pastedText === ''){
		App.confirmDialog(gis_gridwidget_126, null, {title:gis_core_1});
		return;
	}
	if(dataAdapter && dataAdapter.currentGridDescr) {
		//dataAdapter.currentGridDescr.pasteFromExcelData = pastedText;
		var dataRequest = 'STO_SEM.xml#STO_ILI_DATA_ADV';
		GridUtil.getProvDataXml(dataRequest, function(parametersTypes){
			// parametersTypes - переменная, куда заносим типы колонок из файла запросов для данной команды, далее ищем по ключу
			GridUtil.scalarReader('UTE_SEM.xml#GET_MAX_INSPECTION_ID', function(inspectionId){
				// parametersTypes - переменная, куда заносим типы колонок из файла запросов для данной команды, далее ищем по ключу
				GridUtil.pasteStoIliDataAdvCells(currentGrid, dataAdapter, {ID:inspectionId}, dataRequest, parametersTypes, that);
			})
		})
	}
}
/**
 * Класс js-виджета грида для административных задач (встраивается функцией build в элемент с id=widgetElementId)
 */
/** не наследуемся от GridWidget, а используем функции его прототипа (класса).
 * в административных задачах не будет постраничности, но запросы и некоторый другой функционал можно использовать */

function GridAdmWidget(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.layerId = '';
	this.fullLayerId = options.fullLayerId;
	this.id = options.id; //ex. id5828_GRID
	//флаг указывает, были ли какие-то манипуляции с контентом грида(фильтрация, сортировка, смена кол-ва записей)
	this.modified = false;
	this.gridDescriptionXml = null;
	this.gridDescriptionJson = null;
	this.dataAdapter = undefined;
	//Функция обратного вызова для передачи данных в плагин jqxDataAdapter после их успешного возвращения
	this.jqxDataAdapterCallback = undefined;
	//фильтр, пришедший извне
	this.filter = options.filter;
	//идентификаторы родительского грида и потомка
	this.parentGrid = options.parentGrid;
	this.childGrid = options.childGrid;
	//начальное состояние настроек грида
	this.defaultState = null;
	//используется для хранения промежуточной информации, например, когда скрываем колонки
	this.currentState = null;

	//перечень колонок грида
	this.columns = [];
	//перечень скрытых на данный момент колонок грида
	this.hiddenColumns = undefined;

	//закэшированные изначальные данные со всеми колонками
	this.cachedRecords = []; //pageSize * 10 = 500 записей

	//массив отображаемых записей в гриде.
	this.cachedContentRecords = [];
};

GridAdmWidget.prototype.build = function(widgetElementId, gridTemplate, fullLayerId, gridTitle) {
	var that = this;
	//Уникальный идентификатор грида формируем на основе идентификатора элемента
	var jqxGridId = "jqxgrid" + widgetElementId;
	//Формируем обертку, в которой будем создавать грид
	var widgetContent =
		'<div id="jqxDockPanel' + jqxGridId + '" style="width: 100%; height: 100%">' +
		'<div dock="left" id="gridButtons' + jqxGridId + '" class="gridButtonsPanel">' +
		'</div>' +
		'<div id="jqxWidget' + jqxGridId + '" dock="right" style="width: 100%; height: 100%;">' +
		'<div id="' + jqxGridId + '" class="mainGrid" data-layerid="' + fullLayerId + '">' + getLocalization('ru').loadtext +
		'</div>' +
		'</div>' +
		'</div>';
	$('#' + widgetElementId).html(widgetContent);
	//Создаем панель с возможностью процентного и фиксированного layout
	$("#jqxDockPanel"+jqxGridId).jqxDockPanel({ width: '100%', height: '100%'});

	//Источник данных текущего грида (сделан публичным для обновления грида)
	var gridSource = {};
	//Функция обратного вызова для передачи данных в плагин jqxDataAdapter после их успешного возвращения
	var jqxDataAdapterCallback;
	//Фильтры верхнего уровня по-умолчанию, которые передаются в запрос
	var filters = [
		{name: 'LPU_ACCESS_FILTER', value: '13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0'}
	];
	//Фильтры среднего уровня по-умолчанию, которые передаются в запрос
	var roughFilters = [];
	//id запроса на данные и количество записей
	var currentGridMessageId; //Это не ID запроса. Это сам текущий запрос на грид, который можно отменить через currentGridMessageId.abort()

	//количество загруженных справочников
	var loadingFilterCount = 0;

	//Сразу парсим и получаем слой грида через LayerManager
	var layerManagerInst;
	//Устанавливаем fullLayerId в нормальный (с разделителем # вместо *)
	var gridFullLayerId = fullLayerId.replace('*','#');
	var gridFullLayerIdArr = gridFullLayerId.split('#');
	var gridLayerFileName = gridFullLayerIdArr[0];
	var gridLayerId = gridFullLayerIdArr[1];
	if (WidgetMap!=undefined && WidgetMap.layerManager!=undefined) {
		layerManagerInst = WidgetMap.layerManager;
		var curLayerObj = layerManagerInst.getLayerByName(gridLayerId);
		if (curLayerObj==undefined)
			layerManagerInst.parseLayersDescr(gridLayerFileName);
	} else {
		layerManagerInst = new LayerManager();
		layerManagerInst.parseLayersDescr(gridLayerFileName);
	}

	var cancelGridProcess = function cancelGridProcess() {
		if (currentGridMessageId) {
			currentGridMessageId.abort();
			currentGridMessageId = undefined;
			//Снимаем курсор ожидания
			BlockingUtil.ready();
			//Не обновляем грид - это делается в endProcess.
		}
	};
	/* Получение описания нашего грида */
	function getGridDescription(gridDescrId) {
		//Получаем объект запроса из описания грида
		var gridDescrRequest = GridWidget.prototype.makeLoadGridDescrReqParams(gridDescrId);
		BlockingUtil.wait();
		return App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, gridDescrRequest, onLoadGridDescrResult, onLoadGridDescrFail);
	}

	//Функция обратного вызова для получения описания грида
	function onLoadGridDescrResult(resultXml) {
		//Снимаем курсор ожидания
		BlockingUtil.ready();
		//BlockingUtil.unblockApplication();
		if (resultXml) {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er != "")
				App.errorReport(gis_gridwidget_3, gis_gridadmwidget_2 + er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_1'});
			else {
				if ($('#' + widgetElementId).length > 0) {
					//Получаем из описания грида необходимые нам переменные и структуру грида
					parseGridDescription(resultXml);
				} else {
					//Иначе это означает, что мы уже закрыли грид до того как пришло его описание
				}
			}
		}
	}

	//Функция обратного вызова для получения описания грида
	function onLoadGridDescrFail(resultXml) {
		//Снимаем курсор ожидания
		BlockingUtil.ready();
		App.errorReport(gis_gridwidget_3, resultXml.toString(), undefined, {filename:gis_filename_187, functionname:'gis_filename_187_2'});
	}


	// Вызов всех необходимых для виджета грида функций
	function callWidgetGridFunctions(layerId) {
		try {
			/*Получаем список фильтров для подстановки в запрос данных
			 Если параметр в массиве params один и это layer - это первоначальный запрос на передачу в грид данных фильтрации,
			 Иначе это вызов из грида фильтрации на карте*/
			var layerObj = {name: 'layer', value: layerId};
			var params = [layerObj];
			//Сохраняем функцию для приема ответа в App.callbackFilter (таким образом получим результат в текущий грид)
			ExternalInteraction.callbackFilter = callbackFilterFnc;
			// Теперь вызываем функцию для начала получения фильтра из виджета карты
			var filterRes = callbackFunction(widgetElementId, 'callbackFilter', params); //ExternalInteraction.callbackFunction(widgetElementId, 'callbackFilter', params);//
			if (filterRes === 0) {
				App.errorReport(gis_gridwidget_5, filterRes, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_3'});
			}
		}
		catch (e) { // Вызов функции не сработал
			App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_4'});
		}
	}

	// Функция обратного вызова для получения результата фильтра верхнего уровня.
	// Называется тоже callbackFilter, 2 параметра - params (массив) и winId (строка).
	function callbackFilterFnc(params) {
		try {
			for (var j = 0; j < params.length; j++) {
				var curParam = params[j];
				if (!curParam.hasOwnProperty('name')) continue;

				var newFilters = [];
				var curFilters;
				switch (curParam['name']) {
					case 'filter':
					case 'roughFilter':
						curFilters = curParam['value'].split('|');
						for (var i = 0; i < curFilters.length; i++) {
							var nameValArr = curFilters[i].split(':');
							if (nameValArr && nameValArr.length >= 2) {
								//для кадастровых районов вида "1:23:23.."
								var nameVal = nameValArr[0];
								nameValArr.splice(0,1);
								var newFilterObj = { name: nameVal, value: nameValArr.join(':') };
								newFilters.push(newFilterObj);
							}
						}

						if (curParam['name'] == 'filter') {
							//Переписываем массив фильтров верхнего уровня, из которых формируются запросы
							filters = newFilters;
						}
						else if (curParam['name'] == 'roughFilter') {
							//Переписываем массив фильтров среднего уровня, из которых формируются запросы
							roughFilters = newFilters;
						}
						break;
				}
			}
		}
		catch (e) { // Вызов функции не сработал
			App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_5'});
		}
	}

	//Парсинг пришедшего описания грида (колонки, запросы и т.д.)
	function parseGridDescription(gridDescription) {
		try {
			if (gridDescription !== undefined && gridDescription !== null) {
				//Получаем описание грида в виде структуры (берем корневой элемент, т.е. grids:Grid)
				var gridDescriptionXml = ($.parseXML(gridDescription)).firstChild;
				//Создаем пока что пустой грид по его описанию
				createGrid(gridDescriptionXml);
			}
		}
		catch (e) { // Распарсить XML не удалось
			App.errorReport(gis_gridwidget_4, e, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_6'});
		}
	}

	//Установка/снятие доступности групповых кнопок грида в зависимости от атрибута "isenabled" кнопки и выбранных записей
	function setEnableToGroupButtons() {
		//Не изменяем доступность кнопок, т.к. иногда событие не приходит и кнопки блокируются при выделенной записи
		return;
		try {
			//Получаем количество выделенных в гриде рядов
			var rowindexes = $("#" + jqxGridId).jqxGrid('getselectedrowindexes'); //Если length==0, то не выбран ни 1 ряд
			var isSelected = rowindexes && rowindexes.length > 0;
			//Получаем список групповых кнопок грида (с групповыми кнопками из тулбара грида)
			var groupButtons = $("[id*=btngrouptoolbar_"+jqxGridId+"],[id*=btngroup_"+jqxGridId+"]");
			for (var i = 0; i < groupButtons.length; i++) {
				var curGroupBtn = $(groupButtons[i]);
				//Обрабатываем атибут доступности согласно выделению в гриде (если == "length" - то доступна если выделен хотя бы 1 объект, иначе всегда доступна)
				if (curGroupBtn.attr("isenabled")=="false") {
					curGroupBtn.jqxButton({ disabled: !isSelected});
				} //Если же кнопка всегда доступна - ничего не делаем, поскольку доступность кнопок меняться не будет
			}
		} catch (e) {
			//Ничего не делаем
			App.errorReport(gis_gridwidget_4, e, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_7'});
		}
	}

	/* Создание грида по полученному описанию грида */
	function createGrid(gridDescriptionXml) {
		that.gridDescriptionXml = gridDescriptionXml;
		//объект, в который сохраняем описание грида
		var currentGridDescr = {};
		//Получаем id слоя для грида (нужен для получения фильтров)
		var layerId = gridDescriptionXml.getAttribute('layerId');
		layerId = that.setLayerId(layerId);
		//Вызываем функции, необходимые для заполнения переменных виджета
		callWidgetGridFunctions(layerId);
		var i = 0;

		//Менеджер фильтров - хранит загруженные справочники для отображения в гриде и фильтрации
		var gridFilterManager = new FilterManager();

		//Получаем запрос данных для грида
		var dataRequest = gridDescriptionXml.getAttribute('dataRequest');
		//Флаг редактирования грида
		var isGridEditable = gridDescriptionXml.getAttribute('editable');
		//Получаем запрос на количество записей в гриде
		var totalRecordsRequest = gridDescriptionXml.getAttribute('totalRecordsRequest');
		//Начальная сортировака колонок
		var initialSortField = gridDescriptionXml.getAttribute('initialSortField');
		//Количество фиксированных колонок
		var lockedColumnCount = gridDescriptionXml.getAttribute('lockedColumnCount');
		//высота колонки
		var columnVertSize = gridDescriptionXml.getAttribute('headerVertSize');
		//заголовок таблицы около нумерации
		var titleGridColumn = gridDescriptionXml.getAttribute('labelColumn');
		//Функция форматирования данных, пришедших с сервера (для перевода xml в нужный формат)
		var formatDataFunction = gridDescriptionXml.getAttribute('formatDataFunction');
		//Дополнительный запрос для экспорта в Excel - если есть, используем его для группового экспорта
		var excelDataRequest = gridDescriptionXml.getAttribute('excelDataRequest');
		if (excelDataRequest==undefined || excelDataRequest==null || excelDataRequest=='') excelDataRequest = dataRequest;
		//Дополнительное ограничение числа записей для экспорта в Excel - если есть, используем его вместо ограничения из конфига
		var excelMaxExport = gridDescriptionXml.getAttribute('excelMaxExport');
		//колонки грида
		var gridColumns = [];
		//Колонки с маппингом данных (для dataAdapter)
		var dataFields = [];

		//количество записей на страницу
		var pageSize = gridDescriptionXml.getAttribute('pageSize');
		var pageSizeOptions =  [25, 50, 100, 500, 1000, 5000];
		if(pageSize === null || pageSize === ''){
			pageSize = 100;
		}
		else{
			pageSize = parseInt(pageSize);
			//если pageSize нет в массиве pageSizeOptions, то помещаем его в него на соответствующее место
			if(pageSizeOptions.indexOf(pageSize) === -1){
				var inserted = false;
				for(var p = 0; p < pageSizeOptions.length; p++){
					if(pageSize < pageSizeOptions[p]){
						pageSizeOptions.splice( p, 0, pageSize );
						inserted = true;
						break;
					}
				}
				if(!inserted)
					pageSizeOptions.push(pageSize);
			}
		}


		//Описание групповых кнопок в тулбаре
		var gridToolbarGroupButtons = [];
		//Получаем описание групповых кнопок грида
		var descrGroupButtons = gridDescriptionXml.getElementsByTagName("picPutton:GridButton");
		if (descrGroupButtons.length == 0) {
			descrGroupButtons = gridDescriptionXml.getElementsByTagName("GridButton");
		}

		//Сохраняем описание грида
		currentGridDescr = {
			layerId: layerId,
			gridLayerId: gridLayerId,
			dataRequest: dataRequest,
			totalRecordsRequest: totalRecordsRequest,
			initialSortField: initialSortField,
			gridColumns: gridColumns,
			dataFields: dataFields,
			descrGroupButtons: descrGroupButtons,
			layerManager: layerManagerInst,
			gridFilterManager: gridFilterManager,
			topFilter: filters,
			roughFilter: roughFilters,
			currentFilter: [],
			currentSort: [],
			selecting: false,
			centering: false,
			formatDataFunction: formatDataFunction,
			excelDataRequest: excelDataRequest,
			excelMaxExport: excelMaxExport
		};
		GlobalGridDescr[jqxGridId] = currentGridDescr;
		for (i = 0; i < descrGroupButtons.length; i++) {
			var curButton = descrGroupButtons[i];
			//Получаем из атрибутов параметры для описания очередной групповой кнопки грида
			//В исходных путях присутствует ненужное указание выхода на директорию из поддиректории '../../' - убираем его (путь формируем от корня сайта)
			var btnSource = curButton.hasAttribute('source') ? curButton.getAttribute('source').replace('../../','') : '';
			var btnTooltip = curButton.hasAttribute('tooltip') ? curButton.getAttribute('tooltip') : '';
			var btnClickEvent = curButton.hasAttribute('clickEvent') ? curButton.getAttribute('clickEvent') : '';
			//Параметр isEnabled принимает значения: 'true' или 'null' - всегда доступна, иначе (в т.ч. если нет этого параметра) - доступна если выбрана хотя бы 1 запись
			var btnIsEnabled = curButton.hasAttribute('isEnabled') && (curButton.getAttribute('isEnabled')=='true' || curButton.getAttribute('isEnabled')=='null');
			var btnDisabled = false; //!btnIsEnabled; //По-умолчанию недоступными будут кнопки, доступность которых регулируется выбором записей грида
			var btnSelectedObjects = curButton.hasAttribute('selectedObjects') ? curButton.getAttribute('selectedObjects') : ''; //Не нужно - доступность групповых кнопок регулируется только через isEnabled
			var btnPosition = curButton.hasAttribute('position') ? curButton.getAttribute('position') : 'left'; //Позиция кнопки - в левой панели ('left') или сверху ('top')
			var btnWidth = curButton.hasAttribute('width') ? curButton.getAttribute('width') : '200'; //Ширина кнопки
			var btnHeight = curButton.hasAttribute('height') ? curButton.getAttribute('height') : '27'; //Высота кнопки

			var curButtonHtml = '<input type="submit" onClick="GridAdmWidget.prototype.groupButtonClick(event,'+jqxGridId+')" class="gridGroupButton"'
				+' style="padding: 10px; '+" background-image: url('./"+btnSource+"');"+'" value=" " title="'+btnTooltip+'" gridlayerid="'+gridLayerId+'"'
				+' id="btngroup_'+jqxGridId+'_'+i+'" layerid="'+layerId+'" clickevent="'+btnClickEvent+'" isenabled="'+btnIsEnabled+'" selectedobjects="'+btnSelectedObjects+'"/>';
			//Добавляем очередную кнопку в панель с групповыми кнопками грида (в левую панель добавляем только обычные для гридов кнопки)
			//Определяем, добавлять или нет кнопку по иконке, потому что события могут отличаться (например есть уникальное событие на создание объекта)
			if (btnPosition.indexOf('top') !== -1) {
				var btnFloat = (btnPosition.split('|').length > 1 && btnPosition.split('|')[1] === 'right')?' float: right; ':' float: left; ';
				var btnText = curButton.hasAttribute('text') ? curButton.getAttribute('text') : btnTooltip;
				//Для административных гридов сохраняем кнопки для верхнего тулбара
				var curButtonFullHtml = '<input type="submit" onClick="GridAdmWidget.prototype.groupButtonClick(event,'+jqxGridId+')" class="myButton"'
					+'value="'+btnText+'" title="'+btnTooltip+'" style="padding: 0px; '+btnFloat+' white-space: normal;" data-btnwidth="'+btnWidth+'" data-btnheight="'+btnHeight+'"'
					+' id="btngrouptoolbar_'+jqxGridId+'_'+gridToolbarGroupButtons.length+'" layerid="'+layerId+'" clickevent="'+btnClickEvent+'" isenabled="'+btnIsEnabled+'" selectedobjects="'+btnSelectedObjects+'"' +
					'" gridlayerid="'+gridLayerId+'" />';
				gridToolbarGroupButtons.push(curButtonFullHtml);
			} else {
				//Пока что любое расположение кроме 'top' считаем групповой кнопкой грида для левой панели
				$('#gridButtons' + jqxGridId).append(curButtonHtml);
				//Делаем нормальную кнопку, в которую добавляем текущее состояние (доступна или нет изначально)
				$('#btngroup_'+jqxGridId+'_'+i).jqxButton({ theme: 'gis-blueorange', disabled: btnDisabled});
			}
		}
		//Не устанавливаем доступность групповых кнопок, она выставлена правильно при создании кнопок
		/*setEnableToGroupButtons();*/

		//Функция-рендерер тулбара административных гридов
		function admGridRenderToolbar(toolbar) {
			try {
				var me = this;
				//Если в тулбаре уже добавлен этот div, 2 раз не добавляем, а также проверяем что кнопки вставляются после постраничности (когда тулбар заполнен чем-то)
				if ($('#btngrouptoolbardiv_'+jqxGridId).length > 0 || toolbar.children().length==0) return;
				var container = $('<div id="btngrouptoolbardiv_'+jqxGridId+'" style="margin: 0px; padding-top: 25px;"></div>');
				toolbar.append(container);
				//var span = $("<span style='float: left; margin-top: 5px; margin-right: 4px;'>Search City: </span>");
				//container.append(span);
				for (var ii = 0; ii < gridToolbarGroupButtons.length; ii++) {
					var curGroupBtnInput = gridToolbarGroupButtons[ii];

					container.append(curGroupBtnInput);
					var curGroupBtn = $('#btngrouptoolbar_'+jqxGridId+'_'+ii);
					var btnWidth = parseInt(curGroupBtn.attr('data-btnwidth')); //ширина кнопки
					if (btnWidth==undefined || btnWidth==null || isNaN(btnWidth)) btnWidth = 200;
					var btnHeight = parseInt(curGroupBtn.attr('data-btnheight')); //высота кнопки
					if (btnHeight==undefined || btnHeight==null || isNaN(btnHeight)) btnHeight = 27;
					var btnDisabled = false; //curGroupBtn.attr('isenabled')!="true";
					curGroupBtn.jqxButton({ width: btnWidth, height: btnHeight, disabled: btnDisabled});
				}
			} catch (e) {
				//Ничего не делаем, возможно, закрыли грид
			}
		}

		//Получаем все имеющиеся описания колонок
		var descrColumns = gridDescriptionXml.getElementsByTagName("columns:GridColumn");
		if (descrColumns.length == 0) {
			descrColumns = gridDescriptionXml.getElementsByTagName("GridColumn");
		}
		var filterCount = [];//количество справочников
		for (i = 0; i < descrColumns.length; i++) {
			var curColumn = descrColumns[i];

			//Определяем тип колонки и что именно она будет рендерить по атрибуту itemRenderer
			if (curColumn===undefined || !curColumn || !curColumn.hasAttribute('itemRenderer')) continue;
			//Обрабатываем атрибут itemRenderer
			var colItemRendererSrc = curColumn.getAttribute('itemRenderer');
			var colItemRendererArr = colItemRendererSrc.split('?'); //В строке itemRenderer тип рендерера отделяется от параметров символом '?';
			var colItemRendererType = 'ru.corelight.view.renderer.StringRenderer'; //по-умолчанию - обычная строка
			var colItemRendererParams = []; //по-умолчанию параметров у рендерера нет
			if (colItemRendererArr && colItemRendererArr.length > 0) {
				//Сохраняем тип рендерера колонки
				colItemRendererType = colItemRendererArr[0];
				//Если у рендерера есть параметры - парсим их в массив параметров colItemRendererParams
				if (colItemRendererArr.length > 1) {
					var paramsArr = colItemRendererArr[1].split(';'); // параметры всегда содержатся во 2 элементе массива и разделяются символом ';'
					for (var j = 0; j < paramsArr.length; j++) {
						var nameValArr = paramsArr[j].split('='); //имя параметра отделяется от его значения символом '='
						if (nameValArr.length > 1) {
							var paramObj = {name: nameValArr[0], value: nameValArr[1]};
							colItemRendererParams.push(paramObj);
						}
					}
				}
			}

			//Рендерер кнопки-иконки
			var imageRenderer = function imageRenderer(row, columnfield, value, defaulthtml, columnproperties) {
				try {
					//В данном случае используем columnfield для определения номера колонки, которая рендерится
					if (columnfield < gridDescription.columns.length && gridDescription.columns[columnfield].hasOwnProperty('colItemRendererParams')) {
						var rendererParams = gridDescription.columns[columnfield]['colItemRendererParams'];
						var paramsObj = {path:'', eventname:'', tooltip:'', layerid:layerId, templatename:'', ext_data_id:'', gridlayerid:gridLayerId}; //Объект для доступа к параметрам рендерера по их имени
						for (var k = 0; k < rendererParams.length; k++) {
							var paramName = rendererParams[k]['name'].toLowerCase(); //Обязательно переводим в нижний регистр!
							var paramValue = rendererParams[k]['value'];
							paramsObj[paramName] = paramValue;
						}
						//Сохраняем в атрибуты кнопки все необходимые значения (path, eventName, toolTip, layerId, templateName, ext_data_id, gridLayerId)
						var imageBtnHtml = '<input type="submit" onClick="GridAdmWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')" class="gridButton"'
							+' style="padding: 0;'+" background-image: url('./"+paramsObj["path"]+"');"+'" value=" " title="'+paramsObj["tooltip"]+'" gridlayerid="'+paramsObj["gridlayerid"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'"' +
							' ext_data_id="'+paramsObj["ext_data_id"]+'"/>';
						return imageBtnHtml;
					}
				} catch (e) {}
				return ''; //не можем отрендерить как картинку
			};

			//Рендерер символьной строки
			var stringRenderer = function stringRenderer(row, columnfield, value, defaulthtml, columnproperties) {
				try {
					var noPaddingsHtml = $(defaulthtml);
					//Убираем ненужные отступы, чтобы было больше места для текста
					noPaddingsHtml.css('margin-left', '2px');
					noPaddingsHtml.css('margin-right', '0px');
					//Добавляем стили для того, чтобы текст внутри был выделяемым
					noPaddingsHtml.css('-moz-user-select', 'text');
					noPaddingsHtml.css('-khtml-user-select', 'auto');
					noPaddingsHtml.css('-webkit-user-select', 'auto');
					noPaddingsHtml.css('-ms-user-select', 'auto');
					noPaddingsHtml.css('user-select', 'auto');
					//Для переноса длинного текста в ячейке на следующую строку
					//noPaddingsHtml.css('white-space', 'normal');
					//17.02.20 Добавлено условие для дат, т.к. нет отдельного обработчика DateRenderer
					//если есть текст "T00:00:00" - отбрасываем правую часть
					//Возвращаем элемент с нужными стилями
					var returnStr = noPaddingsHtml[0].outerHTML;
					if(value && value.indexOf("T00:00:00") !== -1)
						returnStr = returnStr.replace(value.substring(value.indexOf("T00:00:00")),'');
					return returnStr;
				} catch (e) {}
				return ''; //не можем отрендерить
			};

			//Рендерер чисел с округлением до числа знаков после запятой, указанного в параметре buffer рендерера (2 по дефолту)
			var numberRenderer = function numberRenderer(row, columnfield, value, defaulthtml, columnproperties) {
				try {
					var noPaddingsHtml = $(defaulthtml);
					//Убираем ненужные отступы, чтобы было больше места для текста
					noPaddingsHtml.css('margin-left', '2px');
					noPaddingsHtml.css('margin-right', '0px');
					//Добавляем стили для того, чтобы текст внутри был выделяемым
					noPaddingsHtml.css('-moz-user-select', 'text');
					noPaddingsHtml.css('-khtml-user-select', 'auto');
					noPaddingsHtml.css('-webkit-user-select', 'auto');
					noPaddingsHtml.css('-ms-user-select', 'auto');
					noPaddingsHtml.css('user-select', 'auto');
					//Для переноса длинного текста в ячейке на следующую строку
					//noPaddingsHtml.css('white-space', 'normal');
					//Возвращаем элемент с нужными стилями
					var resultHtml = noPaddingsHtml[0].outerHTML;
					var newValue = value;
					if(newValue && newValue.indexOf(',') !== -1)
						newValue = newValue.replace(',','.');
					var numberVal = parseFloat(value);
					if (!isNaN(numberVal)) {
						//Обрезаем число до 6 знаков после запятой (если в рендерере не указан format=<число>)
						var numPrecision = 6;
						var indexColumn;
						//В данном случае используем columnfield для определения номера колонки, которая рендерится
						for(var i=0; i<gridDescription.columns.length; ++i){
							if(gridDescription.columns[i]['datafield'] === columnfield){
								indexColumn = i;
								break;
							}
						}
						if (gridDescription.columns[indexColumn].hasOwnProperty('colItemRendererParams')) {
							for(var i=0; i<gridDescription.columns[indexColumn]['colItemRendererParams'].length; ++i) {
								var rendererParams = gridDescription.columns[indexColumn]['colItemRendererParams'][i];
								if (rendererParams && rendererParams.hasOwnProperty('name') && (rendererParams['name'] === 'format') && rendererParams.hasOwnProperty('value') && !isNaN(parseInt(rendererParams['value']))){
									numPrecision = parseInt(rendererParams['value']);
								}
							}
						}
						var numVal = parseFloat(numberVal.toFixed(numPrecision));
						var numValStr = (isNaN(numVal))?'':numVal.toString();
                        numValStr = numValStr.replace(/\.00$/,"");
						resultHtml = noPaddingsHtml[0].outerHTML;
						resultHtml = resultHtml.replace(">"+value+"<", ">"+numValStr+"<");
					}
					//Возвращаем элемент с нужными стилями
					return resultHtml;
				} catch (e) {}
				return ''; //не можем отрендерить
			};

			//Добавляем особый рендерер, который будет забирать из FilterManager нужное значение для отображения
			var filterCellRenderer = function filterCellRenderer(index, datafield, value, defaulthtml, column, rowdata) {
				try {
					var filterData = [];
					var curFilterRequestiId;
					for (i = 0; i < gridDescription.columns.length; i++) {
						var curCol = gridDescription.columns[i];
						if (curCol.datafield == datafield) {
							curFilterRequestiId = curCol.filterrequestid;
							filterData = gridFilterManager.getArrayData(curCol.filterrequestid);
							break;
						}
					}
					var curDescr = gridFilterManager.EMPTY_NAME;
					//Ищем в полученном справочнике текущее значение и забираем его описание
					if (filterData!=null && filterData.hasOwnProperty('codehash') && filterData.codehash[value]!=undefined && filterData.codehash[value]!=null) {
						curDescr = filterData.codehash[value];
					} else {
						if(filterData == 'loading')
							return defaulthtml.replace(">"+value+"<", "><");
						if(value == '')
							curDescr = value;
						else{
							//Иначе однократно сообщаем, что такого значения в справочнике нет
							if (that.notFoundCodeHash==undefined || !that.notFoundCodeHash.hasOwnProperty(datafield) || !that.notFoundCodeHash[datafield].hasOwnProperty(value)) {
								if (that.notFoundCodeHash==undefined) that.notFoundCodeHash = {};
								if (!that.notFoundCodeHash.hasOwnProperty(datafield)) that.notFoundCodeHash[datafield] = {};
								that.notFoundCodeHash[datafield][value] = value;
								//Показываем однократное сообщение об ошибке, что для этого значения не найдено значение справочника
								//Показываем однократное сообщение об ошибке, что для этого значения не найдено значение справочника
								if(WidgetMap !== undefined && WidgetMap.getShowErrorInGridDictationary() == false){}//если выставлен флаг, то не показываем сообения
								else{
									var guidErrorDict = 'cell_guid_'+App.generateUUID();
									defaulthtml = defaulthtml.replace('class="grid-cell-style"', 'class="grid-cell-style ' + guidErrorDict + '"');
									var confirm = App.infoDialog(gis_gridwidget_142);
									gridFilterManager.reloadDictationary(curCol.filterrequestid, function(arr){
										filterData = gridFilterManager.getArrayData(curCol.filterrequestid);
										if(filterData && filterData.codehash[value]!=undefined && filterData.codehash[value]!=null) {
											//$('.' + guidErrorDict).text(filterData.codehash[value]);
											gridElem.jqxGrid('setcellvalue', index, datafield, value);
										}
										confirm.dialog("close");
									});
								}
							}
						}
					}
					//Заменяем подстроку значения включая > и <, чтобы не заменить где-то кроме самой ячейки
					if(WidgetMap !== undefined && WidgetMap.getShowErrorInGridDictationary() == false && curDescr == gridFilterManager.EMPTY_NAME)
						return defaulthtml.replace(">"+value+"<", ">"+curDescr+":"+value+"<");
					//Заменяем подстроку значения включая > и <, чтобы не заменить где-то кроме самой ячейки
					return defaulthtml.replace(">"+value+"<", ">"+curDescr+"<");
				} catch (e) {}
				return ''; //не можем отрендерить
			};

			//Получаем из атрибутов параметры для маппинга и описания очередной колонки грида
			//В dataField для колонок, которые являются кнопками, сохраняем порядковый номер колонки, иначе просто сохраняем dataField
			var colDataField = curColumn.hasAttribute('dataField') ? curColumn.getAttribute('dataField') : i; //dataField ОБЯЗАТЕЛЬНО должно быть уникальным !
			var colDataFieldSynonym = curColumn.hasAttribute('dataFieldSynonym') ? curColumn.getAttribute('dataFieldSynonym') : undefined; //dataField ОБЯЗАТЕЛЬНО должно быть уникальным !
			var colHeaderText = curColumn.hasAttribute('headerText') ? curColumn.getAttribute('headerText') : '';
			var colWidth = curColumn.hasAttribute('width') ? curColumn.getAttribute('width') : 0; //Если ширина не указана то дефолтная будет = 0
			var colEditable = curColumn.hasAttribute('editable') && curColumn.getAttribute('editable') === 'true' ? true : false; //Если ширина не указана то дефолтная будет = 0

			//Отдельные атрибуты для фильтрации
			var colFilterRequestId = curColumn.hasAttribute('filterRequestId') ? curColumn.getAttribute('filterRequestId') : undefined; //Запрос справочника значений
			var colFilterComparisionType = curColumn.hasAttribute('filterComparisionType') ? curColumn.getAttribute('filterComparisionType') : undefined; //Тип фильтра
			//TODO костыль. Обработка случая фильтра с большим количеством записей(распределители)
			var colFilterInfinite = curColumn.hasAttribute('infinite') ? curColumn.getAttribute('infinite') === 'true' : false; //
			var colSortField = curColumn.hasAttribute('sortField') ? curColumn.getAttribute('sortField') : undefined; //Поле для сортировки справочника
			var colSortable = colFilterComparisionType!=undefined;

			//Скрытая ли колонка
			var colHidden = curColumn.hasAttribute('hidden') ? curColumn.getAttribute('hidden') === 'true' : false; //Запрос справочника значений

			//Маппинг - для маппинга xml-атрибута заключаем в квадратные скобки, для массива - не нужно
			/*var colMapping = '['+curColumn.getAttribute('dataField')+']';*/
			var colMapping = curColumn.hasAttribute('dataField') ? curColumn.getAttribute('dataField') : i;
			//Пока что все считаем строкой, в будущем нужно определять тип колонки по itemRenderer или по filterComparisionType
			var colType = 'string';

			var columnrenderer = function(value, align, columnsheight) {
				var splitted = value.split('\\n');
				var newVal = splitted.join('<br/>');

				return '<div style="text-align: left; margin-top: 2px;">' + newVal + '</div>';
			};

			//pinned - зафиксированная колонка или нет
			var colIsPinned = i < lockedColumnCount-1;
			//Объект с описанием колонки
			var columnObj = {text: colHeaderText,
				editable: colEditable,
				datafield: colDataField, width: colWidth, minwidth: 0, pinned: colIsPinned, hidden: colHidden,
				filterrequestid: colFilterRequestId, filtercomparisiontype: colFilterComparisionType, filterinfinite: colFilterInfinite,
				sortfield: colSortField, sortable: colSortable,
			};

			//В адм задачах запросы не возвращают номер записи, поэтому описание колонки с номером обрабатываем отдельно:
			//<columns:GridColumn headerText="№" width="30" dataField="RWN" sortable="false" itemRenderer="ru.corelight.view.renderer.StringRenderer" editable="false"/>
			if (colDataField === "RWN") {
				columnObj = {
					text: colHeaderText, sortable: false, filterable: false, editable: false, groupable: false, draggable: false, resizable: false, pinned: colIsPinned,
					datafield: '', columntype: 'number', width: colWidth,
					cellsrenderer: function (row, column, value) {
						return "<div style='margin:4px;'>" + (value + 1) + "</div>";
					}
				};
				//Добавляем колонку
				gridColumns.push(columnObj);
				continue;
			}

			//Дефолтный рендерер - убираем избыточные отступы и выдаем просто текст
			columnObj['cellsrenderer'] = stringRenderer;
			columnObj['columntype'] = 'string';
			if(colDataFieldSynonym)
				columnObj['datafieldsynonym'] = colDataFieldSynonym;

			//Если тип рендерера - 'ru.corelight.view.renderer.NumberRenderer', меняем на численный с точностью (параметр format, 2 знака после запятой по дефолту)
			if (colItemRendererType==='ru.corelight.view.renderer.NumberRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['cellsrenderer'] = numberRenderer;
				columnObj['columntype'] = 'stringnumber';
			}
			if (colItemRendererType ==='ru.corelight.view.renderer.StringRenderer' || colItemRendererType.indexOf('StringRenderer') !== -1) {
				if(colDataField === 'RWN')
					columnObj['editable'] = false;
			}

			//Если тип рендерера = 'ru.corelight.view.renderer.ImageRenderer', добавляем рендерер для колонки с кнопкой
			if (colItemRendererType==='ru.corelight.view.renderer.ImageRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				if (columnObj['width'] < 25) {
					columnObj['width'] = 25;
				}
				columnObj['cellsrenderer'] = imageRenderer;
				columnObj['editable'] = false;
				columnObj['columntype'] = 'image';
			} else {
				//Для обычных колонок добавляем функцию для отображения всплывающей подсказки на заголовках колонок грида
				/*columnObj['rendered'] = function tooltipRenderer(element) {
				 $(element).jqxTooltip({position: 'mouse', content: $(element).text(), showDelay: 0 });
				 };*/
			}
			//Если тип рендерера - 'ru.corelight.view.renderer.DateRenderer', убираем возможность редактирования этой колонки
			if (colItemRendererType==='ru.corelight.view.renderer.DateRenderer') {
				columnObj['columntype'] = 'date';
			}

			//Объект маппинга данных
			var dataFieldObj = {name: colDataField, map: colMapping, type: colType};
			if(colDataFieldSynonym)
				dataFieldObj['synonym'] = colDataFieldSynonym;
			//Если есть свойство filterRequestId - добавляем displayfield и запрашиваем значения справочника (они должны быть доступны, когда грид загрузится)
			if (colFilterRequestId!==undefined) {
				//Сразу при создании колонки запрашиваем данные справочника
				//var curFilterData = gridFilterManager.getArrayData(colFilterRequestId);
				//Добавляем особый рендерер, который будет забирать из FilterManager нужное значение для отображения
				columnObj['cellsrenderer'] = filterCellRenderer;
				columnObj['columntype'] = 'filter';
				if(filterCount.indexOf(colFilterRequestId)==-1)
					filterCount.push(colFilterRequestId);
			}
			columnObj['renderer'] = columnrenderer;
			//Добавляем колонку
			that.columns.push(columnObj);
			/*if(columnObj.hidden === true && columnObj.datafield !== 'ID')
				continue;*/
			gridColumns.push(columnObj);
			//Добавляем поля данных (маппинг)
			dataFields.push(dataFieldObj);
		}
		loadingFilterCount = filterCount.length;
		for(var a in filterCount){
			gridFilterManager.getArrayData(filterCount[a],onFilterLoadedCallback);
		}

		//Функция формирует строку сортировки из массива
		var getSortStringFromArr = function getSortStringFromArr(sortArr) {
			var sortStr = "";
			if (sortArr && sortArr!==undefined && sortArr.length>0) {
				var tmpSortArr = [];
				for (var i = 0; i < sortArr.length; i++) {
					var sortinformation = sortArr[i];
					//Теперь если мы добавляем сортировку и этот элемент уже был - меняем его (или убираем если сортировка отменена), иначе просто добавляем
					if (sortinformation.sortdirection.ascending || sortinformation.sortdirection.descending) {
						for (var j = 0; j < currentGridDescr.gridColumns.length; j++) {
							//Ищем среди колонок ту, по которой сортируем и забираем значение из ее свойства sortfield
							//Если такого свойста у колонки нет, сортируем по datafield
							var curGridCol = currentGridDescr.gridColumns[j];
							if (curGridCol.hasOwnProperty('datafield') && curGridCol.datafield==sortinformation.sortcolumn) {
								var tmpSortStr = curGridCol.hasOwnProperty('sortfield') && curGridCol.sortfield!=undefined ? curGridCol.sortfield : curGridCol.datafield;
								if (sortinformation.sortdirection.descending)
									tmpSortStr += " DESC";
								tmpSortArr.push(tmpSortStr);
							}
						}
					}
				}
				//Собираем получившийся массив в строку, разделенную запятой
				sortStr = tmpSortArr.join(",");
			}
			else{//иначе проходим по колонкам в gridDescription, ищем соответствующие initialSortField поля сортировки
				if(gridDescription.columns != undefined){
					if(initialSortField!=null){
						var i=0;
						var sortArr = [];
						var isf = initialSortField.split(',');

						for(i; i<isf.length;i++){
							var j=0;
							var found = false;
							for(j; j<gridDescription.columns.length;j++){
								if(isf[i] == gridDescription.columns[j].datafield && gridDescription.columns[j].sortfield!=undefined && gridDescription.columns[j].sortfield!=''){
									sortArr.push(gridDescription.columns[j].sortfield);
									found = true;
									break;
								}
							}
							if(!found)
								sortArr.push(isf[i]);
						}
						sortStr = sortArr.join(',');
					}
				}
			}
			//по-умолчанию возвращаем первоначальный порядок сортировки
			if (sortStr=="") sortStr = initialSortField;
			return sortStr;
		};

		//Своя функция сортировки для корректной сортировки в зависимости от типа данных и filterComparisionType
		var customSortFunc = function (column, direction) {
			//Перед сортировкой очищаем выделение, иначе чекбокс будет в том же месте, но уже на другой записи.
			$("#"+jqxGridId).jqxGrid('clearselection');

			var currentGridSource = $("#"+jqxGridId).jqxGrid('source');
			if (direction == 'ascending') direction = true;
			if (direction == 'descending') direction = false;
			if (direction != null) {
				var sortdata = [];
				for (i = 0; i < currentGridSource.records.length; i++) {
					sortdata.push(currentGridSource.records[i]);
				}
				//Перед сортировкой колонок с filterComparisionType="array" получаем их справочник, чтобы сортироваться по значениям, а не по кодам
				var filterData = null;
				for (i = 0; i < currentGridSource.currentGridDescr.gridColumns.length; i++) {
					var curColObj = currentGridSource.currentGridDescr.gridColumns[i];
					if (curColObj.datafield==column	&& curColObj.filtercomparisiontype == "array") {
						filterData = gridFilterManager.getArrayData(curColObj.filterrequestid);
						break;
					}
				}
				//Сортируем
				sortdata.sort(function (val1, val2) {
					//Исправление для отсутствующего в данных поля - если поля нет, автоматически считаем это значение меньше
					//Учитываем направление сортировки - если она по возрастанию, нужно считать неопределнное значение большим, чтобы оно было в конце списка
					if (val1==undefined || val1==null || !val1.hasOwnProperty(column)
						|| (filterData!=null && filterData.hasOwnProperty('codehash') && filterData.codehash[val1[column]]==undefined)) return direction ? 1 : -1;
					if (val2==undefined || val2==null || !val2.hasOwnProperty(column)
						|| (filterData!=null && filterData.hasOwnProperty('codehash') && filterData.codehash[val2[column]]==undefined)) return direction ? -1 : 1;
					//Внутренняя функция сортировки учитывает, что значения могут быть числовыми
					var value1 = val1[column].toLowerCase();
					var value2 = val2[column].toLowerCase();
					//Если колонка - справочник, то текущее значение - код, по которому получаем его значение
					if (filterData!=null && filterData.hasOwnProperty('codehash')) {
						value1 = filterData.codehash[val1[column]].toLowerCase();
						value2 = filterData.codehash[val2[column]].toLowerCase();
					}
					try {
						var tmpvalue1 = parseFloat(value1);
						var tmpvalue2 = parseFloat(value2);
						if (!isNaN(tmpvalue1) && !isNaN(tmpvalue2)) {
							if (tmpvalue1 < tmpvalue2) { return -1; }
							if (tmpvalue1 > tmpvalue2) { return 1; }
						} else {
							if (value1 < value2) { return -1; }
							if (value1 > value2) { return 1; }
						}
					} catch (error) {}
					return 0;
				});
				if (!direction) {
					sortdata.reverse();
				}
				//Добавляем полученные данные в грид
				if (that.jqxDataAdapterCallback!=undefined) {
					var resultObj = {
						records: sortdata,
						totalrecords: sortdata.length
					};
					//Добавляем через имеющуюся функцию обратного вызова плагина jqxDataAdapter
					that.jqxDataAdapterCallback(resultObj);
				}
			}
		};

		//описание грида
		//Сохраняем в gridSource, чтобы подставить в него данные после загрузки
		gridSource = {
			datatype: "text",
			datafields: dataFields,
			formatdata: function (data) {
				//Перед отправкой запроса устанавливаем в него нижний и верхний пределы согласно выбранным границам
				var lowLimit = 0; //data.pagenum * data.pagesize + 1;
				var highLimit = 99999999; //(data.pagenum + 1) * data.pagesize;
				var bottomFilters = gridDescription.source.currentGridDescr.currentFilter;
				//Текущая сортировка (получаем из массива объектов колонок)
				var gridSortStr = getSortStringFromArr(gridDescription.source.currentGridDescr.currentSort);
				//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
				return GridWidget.prototype.makeLoadDataReqParams(dataRequest, bottomFilters, gridSortStr, lowLimit, highLimit, filters, roughFilters);
			},
			sort: customSortFunc,
			url: Services.processQueryNode
		};


		//Создаем адаптер данных для грида
		var dataAdapterSettings = { contentType: 'application/xml; charset=utf-8',
			type: "POST",
			formatData: function (data) {
				return data;
			},
			beforeSend: function (jqXHR, settings) {
				return null;
			},
			loadError: function (jqXHR, status, error) {
				onLoadGridDataFail(error);
			},
			beforeLoadComplete: function (records) {
				return records;
			},
			loadComplete: function (data) {
				try {
					//Вызываем функцию центровки только если устанавливали в true флаг selecting или centering при фильтрации
					//Для административного грида НЕ вызываем центровку на карте
				} catch (e) {
					App.errorReport(gis_gridadmwidget_6, e.message, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_9'});
				}

				return data;
			},
			loadServerData: function (serverdata, source, callback) {
				//Показываем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
				try { $("#" + jqxGridId).jqxGrid('showloadelement'); } catch (err) {}
				//Здесь будет непрямая ссылка на callback для отправки результата запроса данных в плагин jqxDataAdapter
				//TODO хак, чтобы грид с конфигом корректно открывался через другой запрос
				that.jqxDataAdapterCallback = callback;
				delete dataAdapter.currentGridDescr.rows4Update;
				if(serverdata && serverdata.descrId === "ADM_SEM.xml#GET_CLIENT_SETTINGS")
					currentGridMessageId = App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, serverdata, onLoadGridDataResult, onLoadGridDataFail);
				else
					currentGridMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, serverdata, onLoadGridDataResult, onLoadGridDataFail, true);
			}
		};

		//В адаптер добавляем параметры, отвечающие за постраничную обработку результата (для админских гридов не используем постраничность!!!)
		var dataAdapter = new $.jqx.dataAdapter(gridSource, dataAdapterSettings);
		dataAdapter.currentGridDescr = currentGridDescr;
		that.dataAdapter = dataAdapter;

		//Создаем описание грида
		/*Пример:
		 var gridDescription = {width: '100%',height: '100%',rowsheight: 20,
		 source: dataAdapter, //источник данных, который обновляется после получения данных
		 columnsresize: true, //можно ли изменять ширину колонок
		 pageable: true, //режим постраничного грида
		 pagesizeoptions: ['25', '50', '100', '500', '1000', '5000'], //число записей на одной странице
		 pagesize: 100, //дефолтное число записей на одной странице
		 localization: getLocalization('ru'), //Локализация грида, сейчас есть 'ru','de','en'
		 selectionmode: 'multiplerowsadvanced', //режим выделения (выбора) строк грида
		 virtualmode: true, //виртуальный режим грида, необходим для постраничности
		 columns: gridColumns, //описание колонок грида
		 theme: 'gis-blueorange' //цветовая тема, применяемая к гриду (файл .css должен быть подключен в main.html)
		 };
		 **/
		var gridDescription = {
			width: '100%',
			height: '100%',
			rowsheight: 20,
			source: [],
			sortable: true,
			sorttogglestates: 1,
			altrows: true,
			columnsresize: true,
			pageable: true,
			pagesizeoptions: pageSizeOptions,
			pagesize: pageSize,
			pagerheight: 1,
			localization: getLocalization('ru'),
            enablebrowserselection: true,//+
            clipboard: false,//+
			virtualmode: true,
			editable: false,//upd. 01.12.20 решено убрать возможность редактирование ячеек
			editmode: 'dblclick',
			selectionmode: 'checkbox',
			rendergridrows: function (args) {
				return args.data;
			},
			ready: function () {
				that.defaultState = $("#" + jqxGridId).jqxGrid('savestate');
				that.currentState = $("#" + jqxGridId).jqxGrid('savestate');;//$.extend({}, that.defaultState);
			},
			showtoolbar: true,
			toolbarheight: 80,
			rendertoolbar: admGridRenderToolbar,
			columns: gridColumns,
			columnsmenu: false,
			theme: 'gis-blueorange'
		};
		if(columnVertSize !== null)
			gridDescription['columnsheight'] = columnVertSize;
		if(titleGridColumn !== null)
			that.titleGridColumn = titleGridColumn;

		//Загружаем общее количество записей - запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
		var gridDataRefresh = function (evt) {
			//перед обновлением грида, отменяем прошлые запросы
			cancelGridProcess();
			//Если id в событии есть но не совпадает с id текущего грида - обновление не запускаем
			if (evt && evt.gridId && evt.gridId==jqxGridId) {
				//устанавливаем фиктивное количество записей
				gridSource.totalrecords = 99999999;
				//Если мы обновляем первый раз
				var gridElem = $("#" + jqxGridId);
				if(evt.force === true) {
					if(that.currentState)
						gridElem.jqxGrid('loadstate', that.currentState);
					else {
						try{
							gridElem.jqxGrid('removesort');
						}
						catch(ex){ }
						gridElem.jqxGrid('loadstate', that.defaultState);
						that.currentState = $("#" + jqxGridId).jqxGrid('savestate');
					}
					gridElem.jqxGrid('clearselection');
					callWidgetGridFunctions(that.layerId);
					return;
				}
				//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
				if (gridElem.length === 0) return;
				//Если грид пересоздается (применили фильтр) - сохраняем информацию постраничности (важно, сколько страниц показываем)
				var paginginformation = gridElem.jqxGrid('getpaginginformation');
				if (paginginformation !== undefined) {
					gridDescription.pagesize = paginginformation.pagesize;
				}
				//Удаляем старые слушатели с элемента грида
				gridElem.off('rowselect');
				gridElem.off('rowunselect');
				gridElem.off('rowclick');
				gridElem.off('pagechanged');
				/*gridElem.off('sort');*/
				gridElem.off('columnresized');
				//Создаем грид только после получения количества записей
				gridDescription.source = dataAdapter;
				gridElem.jqxGrid(gridDescription);
				//Показываем спиннер загрузки данных
				gridElem.jqxGrid('showloadelement');
				/*После создания грида биндимся к нужным событиям*/
				//Биндим события изменения выбора в гриде для установки доступности групповых кнопок
				gridElem.on('rowselect', function (event) {
					setEnableToGroupButtons();
				});
				gridElem.on('rowunselect', function (event) {
					setEnableToGroupButtons();
				});
				gridElem.on('columnresized', function (event) {
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = true;
					if(document.selection !== undefined && document.selection.empty !== undefined)
						document.selection.empty();
				});
				gridElem.on('cellendedit', function (event) {
					// event arguments.
					var args = event.args;
					// cell value
					var value = args.value;
					// cell old value.
					var oldvalue = args.oldvalue;
					var dataField = event.args.datafield;
					// row's bound index.
					var rowBoundIndex = event.args.rowindex;
					var columntype = event.args.columntype;
					var rwn = rowBoundIndex;
					var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', rwn);
					//эмуляция currentGrid, чтобы использовать id грида при поиске
					var fullData = GridUtil.getFullRowDataById({id: widgetElementId}, gridItem);
					gridItem = $.extend(fullData, gridItem);
					if(gridItem && gridItem.RWN)
						rwn = gridItem.RWN;
					dataAdapter.currentGridDescr.lastEditedCell = { rwn:rwn, boundIndex: rowBoundIndex, dataField: dataField, event: event} ;

					if(value === oldvalue){
						//that  - GridWidget
						return;
					}
					//валидируем ячейки
					var validateResult = GridUtil.validateCell(value, columntype);
					var origValue = GridUtil.prepareCellValue(value, columntype)
					value = '' + GridUtil.prepareCellValue(value, columntype);
					if(validateResult !== ''){
						App.confirmDialog(validateResult, null, {title:gis_core_1});
						GridUtil.revertCell(gridElem, event);
						return;
					}

					//сохраняем измененное значение в общий массив измененных записей
					//уникальным считаю ID.
					if(!dataAdapter.currentGridDescr.rows4Update)
						dataAdapter.currentGridDescr.rows4Update = {};
					if(!dataAdapter.currentGridDescr.rows4Update[gridItem.ID]){
						dataAdapter.currentGridDescr.rows4Update[gridItem.ID] = JSON.parse(JSON.stringify(gridItem));//клонируем объект
					}
					//обновляем измененным значением временный список
					var synonym = undefined;
					var gridColumns = dataAdapter.currentGridDescr.gridColumns;
					var fieldName = dataField;
					for (i = 0; i < gridColumns.length; i++) {
						//Так исключаем колонки с иконками, а также колонку с номером
						if (gridColumns[i].datafield === dataField && gridColumns[i].datafieldsynonym)
							fieldName = gridColumns[i].datafieldsynonym;
					}
					dataAdapter.currentGridDescr.rows4Update[gridItem.ID][fieldName] = value;
					dataAdapter.currentGridDescr.rows4Update[gridItem.ID][dataField] = value;
					//gridItem.jqxGrid('setcellvalue', rowBoundIndex, fieldName, origValue);
				});
				//Биндим событие смены страницы для снятия выделения грида при переключении страниц
				gridElem.on('pagechanged', function (event) {
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = true;
					gridElem.jqxGrid('clearselection');
				});
			}
		};

		//Чтобы сразу показались колонки, устанавливаем то же описание грида, но без источника данных.
		var gridElem = $("#" + jqxGridId);
		gridElem.jqxGrid(gridDescription);

		//Добавляем слушатель события обновления грида
		$("body").on(GridEvent.REFRESH_GRID+"_"+jqxGridId, gridDataRefresh);
		//Однократно вызываем обновление для самого первого отображения данных грида
		var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID+'_'+jqxGridId);
		refreshGridEvt.gridId = jqxGridId;
		refreshGridEvt.dispatch();
	}

	//Функция обратного вызова для получения данных грида
	function onLoadGridDataResult(resultXml) {
		try {
			//если справочники ещё не подгрузились - ждём, иначе работаем по прошлой схеме
			if(loadingFilterCount != 0 ){
				//сохраняем в data пришедшие данные
				$("#" + jqxGridId).data('resultXml',resultXml);
				return;
			}
			if(resultXml == undefined)
				return;
			//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
			try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}

			var gridElem = $("#" + jqxGridId);
			//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
			if (gridElem.length==0) return;

			if (resultXml) {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er != "")
					App.errorReport(gis_gridwidget_1, gis_gridadmwidget_2 + er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_13'});
				else {
					var hiddenColumns = [];
					/*if(that.hiddenColumns !== undefined)//если уже устанавливали колонки через управление, то переприсваиваем
						hiddenColumns = that.hiddenColumns;*/
					for(var idx = 0; idx < that.columns.length; idx++){
						if(that.columns[idx].hidden === true && that.columns[idx].datafield !== 'ID')
							hiddenColumns.push(that.columns[idx].datafield);
					}
					var dataArr;
					var currentGridSource = $("#"+jqxGridId).jqxGrid('source');
					var currentGridDescr = currentGridSource.currentGridDescr;
					if (currentGridDescr && currentGridDescr.formatDataFunction && currentGridDescr.formatDataFunction!=undefined
						&& GridAdmWidget.prototype.hasOwnProperty(currentGridDescr.formatDataFunction) && typeof GridAdmWidget.prototype[currentGridDescr.formatDataFunction]==='function') {
						dataArr = GridAdmWidget.prototype[currentGridDescr.formatDataFunction].apply(that, [resultXml]);
					} else {
						dataArr = GridWidget.prototype.getDataFromXmlByAttr(resultXml, 'data');
					}
					that.cachedRecords = dataArr;

					//Если у нас имеется поле начальной сортировки (initialSortField), включаем сортировку грида по первой колонке из initialSortField
					if (currentGridDescr.initialSortField!=undefined && currentGridDescr.initialSortField!=null && currentGridDescr.initialSortField!='') {
						//Запускаем сортировку по начальным полям
						var initialSortFieldArr = currentGridDescr.initialSortField.split(',');
						dataArr.sort(GridWidget.prototype.dynamicSortMultiple(initialSortFieldArr));
					}
					dataArr = GridUtil.filterDataFromJson(dataArr, hiddenColumns);

					//Устанавливаем реальное число записей в грид
					currentGridSource.totalrecords = dataArr.length;
					//Добавляем полученные данные в грид
					if (that.jqxDataAdapterCallback!=undefined) {
						var resultObj = {
							records: dataArr,
							totalrecords: dataArr.length
						};
						//Добавляем через имеющуюся функцию обратного вызова плагина jqxDataAdapter
						that.jqxDataAdapterCallback(resultObj);
					}
					else {
						//Добавляем как обычно, просто массивом (тогда не обрабатывается серверная постраничность)
						addDataToGrid(dataArr);
					}
				}
			}
		} catch (e) {
			//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
			try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}

			App.errorReport(gis_gridwidget_1, resultXml.toString(), undefined, {filename:gis_filename_187, functionname:'gis_filename_187_14'});
		}
	}
	//Функция обратного вызова для получения данных грида
	function onLoadGridDataFail(resultXml) {
		//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
		try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}
		if(currentGridMessageId != true)
			App.errorReport(gis_gridwidget_1, resultXml.toString(), undefined, {filename:gis_filename_187, functionname:'gis_filename_187_15'});
		currentGridMessageId = false;
	}

	//колбек на загрузку каждого справочника
	function onFilterLoadedCallback(){
		--loadingFilterCount;
		if(loadingFilterCount == 0){
			onLoadGridDataResult($("#" + jqxGridId).data('resultXml'));
		}
	}

	/* Добавление в грид полученных данных */
	function addDataToGrid(gridData) {
		gridSource.localdata = gridData;
		//Обновляем записи в гриде
		$("#"+jqxGridId).jqxGrid({ source: gridSource });
	}

	//Запускаем получение описания грида по названию его шаблона
	getGridDescription(gridTemplate);

	//Возвращаем построенный элемент грида
	return $('#'+widgetElementId);
};

//Функция получения из xml с данными массива данных (в виде объектов) для задачи администрирования конфига
GridAdmWidget.prototype.getDataFromSettings = function getDataFromSettings(inputXmlStr) {
	//Строка полностью, с комментариями. Они нам обязательно нужны
	var res = inputXmlStr;
	var resArray = [];
	//массив различных секций
	var sectionsArr = ["clientSettings","appSettings"];
	//Перебираем секции из sectionsArr
	for (var i = 0; i < sectionsArr.length; i++) {
		var section = sectionsArr[i];
		var resStr = res.substring(res.indexOf("<"+section+">") + 16, res.indexOf("</"+section+">"));
		//Переформировываем полученные данные с комментариями и ключами в массив объектов
		var startInd = 0;
		var endInd = 0;
		//Парсим только нужные нам свойства
		while (startInd >= 0)
		{
			var tmpObj = {};
			//Ищем начало и конец строки ключа, чтобы определить комментарии,
			//принадлежащие этому ключу (они всегда будут перед ним)
			startInd = resStr.indexOf('<add',endInd);
			if (startInd==-1)
				break;
			//Сохраняем, в какой секции конфига был ключ
			tmpObj.TYPE = section;
			//До того, как получить новый endInd, нужно получить комментарии следующего ключа
			//Для этого выбираем подстроку от конечного endInd до начала нового ключа
			var commentsStr = resStr.substring(endInd + 2,startInd);
			commentsStr = commentsStr.replace(new RegExp("\r","g"),"");
			commentsStr = commentsStr.replace(new RegExp("\n","g"),"");
			commentsStr = commentsStr.replace(new RegExp("<!--","g"),"");
			commentsStr = commentsStr.replace(new RegExp("-->","g"),"");
			tmpObj.COMMENTS = commentsStr;
			//теперь получаем конец подстроки со следующим ключом
			endInd = resStr.indexOf('/>',startInd + 4);
			//Получаем значение key
			var tmpStartInd = resStr.indexOf('key="',startInd + 4);
			var tmpEndInd = resStr.indexOf('"',tmpStartInd + 5);
			var keyStr = resStr.substring(tmpStartInd + 5,tmpEndInd);
			tmpObj.KEY = keyStr;
			//Получаем значение value
			tmpStartInd = resStr.indexOf('value="',tmpEndInd + 1);
			tmpEndInd = resStr.indexOf('"',tmpStartInd + 7);
			var valueStr = resStr.substring(tmpStartInd + 7,tmpEndInd);
			tmpObj.VALUE = valueStr;
			//добавляем ключ
			if (startInd > 0) {
				resArray.push(tmpObj);
			}
		}
	}
	//Сохраняем неизмененный массив
	return resArray;
};


//Функция переформирования пришедшего списка из нескольких записей с одинаковыми TARGET_ID но разными LINKED_ID в один общий
GridAdmWidget.prototype.getDataFromLinkedList = function getDataFromLinkedList(inputDataStr, targetId, linkedId, linkedDescr) {
	//Ставим дефолтные значения если функция вызвана без доп. значений
	if (targetId==undefined) targetId = "USER_ID";
	if (linkedId==undefined) linkedId = "ROLE_ID";
	if (linkedDescr==undefined) linkedDescr = "ROLE_DESCR";

	var dataArr = [];
	var allUsers = {};

	//Получаем из пришедшей строки массив _dataProvider
	var _dataProvider = [];
	try {
		var xmlData = $.parseXML(inputDataStr);
		$(xmlData).find("data").each(function () {
			var newDataObj = {};
			for (var curAttrInd=0; curAttrInd<this.attributes.length; curAttrInd++) {
				newDataObj[this.attributes[curAttrInd].name] = this.attributes[curAttrInd].value;
			}
			_dataProvider.push(newDataObj);
		});

		for (var i = 0; i < _dataProvider.length; i++) {
			if (_dataProvider[i].hasOwnProperty(targetId)) {
				var tmpRoleId = "";
				var tmpRoleDescr = "";
				if (_dataProvider[i].hasOwnProperty(linkedId)) {
					tmpRoleId = _dataProvider[i][linkedId];
					tmpRoleDescr = _dataProvider[i].hasOwnProperty(linkedDescr) ? _dataProvider[i][linkedDescr] : "";
				}
				var tmpUserId = _dataProvider[i][targetId];
				//Если пользователя с таким USER_ID в объекте еще нет
				if (!allUsers.hasOwnProperty(tmpUserId)) {
					dataArr.push(_dataProvider[i]);
					var obj = {};
					if (tmpRoleId != "") {
						obj[tmpRoleId] = tmpRoleDescr;
					}
					allUsers[tmpUserId] = obj;
				}
				else {
					//Не добавляем пользователя еще раз, но роль сохраняем, если она новая
					if (tmpRoleId != "" && !allUsers[tmpUserId].hasOwnProperty(tmpRoleId)) {
						allUsers[tmpUserId][tmpRoleId] = tmpRoleDescr;
					}
				}
			}
		}
		//Заполняем ROLE_ID и ROLE_DESCR значениями через запятую из allUsers[tmpUserId]
		for (var j = 0; j < dataArr.length; j++) {
			var userToRole = allUsers[dataArr[j][targetId]];
			var roleIds = [];
			var roleDescrs = [];
			for (var propName in userToRole) {
				roleIds.push(propName);
				roleDescrs.push(userToRole[propName]);
			}
			dataArr[j][linkedId+"S"] = roleIds.join(",");
			dataArr[j][linkedDescr+"S"] = roleDescrs.join(",");
		}
	} catch (e) {}
	//если данные пришли, но не удовлетворили условию, выдаем сообщение на проверку корректности данных
	if(dataArr.length == 0 && _dataProvider.length > 0)
		App.errorReport(gis_gridwidget_51, gis_gridwidget_52, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_58'});
	return dataArr;
};

//Функция переформирования пришедшего списка учетных записей (приходит несколько записей с одинаковыми ID но разными ROLE_ID - нужно объединять) для задачи администрирования учетных записей
GridAdmWidget.prototype.getDataFromUsersList = function getDataFromUsersList(inputDataStr) {
	var dataArr = GridAdmWidget.prototype.getDataFromLinkedList(inputDataStr, "USER_ID", "ROLE_ID", "ROLE_DESCR");
	//Добавляем поле внешней авторизации 'EXT_AUTH' со значениями Y/N (в исходных данных его либо нет, либо это число)
	for (var i=0; i<dataArr.length; i++) {
		dataArr[i]['EXT_AUTH'] = dataArr[i].hasOwnProperty('EXT_AUTH') ? 'Y' : 'N';
	}
	return dataArr;
};

//Функция переформирования пришедшего списка политик доступа (приходит несколько записей с одинаковыми ROLE_ID но разными ID - нужно объединять) для задачи администрирования политик
GridAdmWidget.prototype.getDataFromPoliciesList = function getDataFromPoliciesList(inputDataStr) {
	return GridAdmWidget.prototype.getDataFromLinkedList(inputDataStr, "POLICY_ID", "ROLE_ID", "ROLE_DESCR");
};


//Функция обработки щелчка на кнопке в колонке грида
GridAdmWidget.prototype.imageButtonClick = function (event, currentGrid, value, gridTitle) {
	try {
		var imgButton = event.target;
		var idArr = imgButton.id.split('_');
		if (idArr && idArr.length==5) {
			/*var colNum = idArr[1]; //Грид берет колонку не по ее номеру, а по ее dataField, но в dataField колонок с кнопками как раз находятся их номера
			 var curColumn = $(currentGrid).jqxGrid('getcolumn', colNum);*/

			var rowNum = idArr[4];
			//Данные выбранной строки грида
			var curRowData = $(currentGrid).jqxGrid('getrowdatabyid', rowNum);
			//Получаем необходимые значения из атрибутов кнопки
			var paramsObj = {path:'', eventname:'', tooltip:'', layerid:'', templatename:'', ext_data_id:'', gridlayerid:''};
			for (var i = 0; i < imgButton.attributes.length; i++) {
				var curAttr = imgButton.attributes[i];
				var attrName = curAttr.nodeName;
				var attrValue = curAttr.nodeValue;
				if (paramsObj.hasOwnProperty(attrName)) {
					paramsObj[attrName] = attrValue;
				}
			}
			//т.к. часть данных в скрытых колонках, то из cachedRecords забираем весь набор атрибутов для выбраннй записи
			curRowData = GridUtil.getFullRowDataById(currentGrid, curRowData);
			var selectedArr = [curRowData];
			//По содержимому объекта paramsObj будем вызывать соответствующую внешнюю функцию грида на данных selectedArr
			GridAdmWidget.prototype.callExternalGridFunction(paramsObj, selectedArr, currentGrid, gridTitle, rowNum);

			//В dataAdapter в records хранятся все записи. В _source.datafields хранится описание колонок.
			/*var curDataAdapter = $(currentGrid).jqxGrid('source');
			 var curRowData = curDataAdapter.records[rowNum];*/
		} else {
			App.errorReport(gis_gridwidget_5);
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_17'});
	}
};

//Функция обработки щелчка на групповой кнопке грида
GridAdmWidget.prototype.groupButtonClick = function groupButtonClick(event, currentGrid) {
	try {
		var imgGroupButton = event.target;
		var idArr = imgGroupButton.id.split('_');
		if (idArr) {
			//Получаем необходимые значения из атрибутов кнопки
			var paramsObj = {
				source: '',
				clickevent: '',
				tooltip: '',
				isenabled: '',
				selectedobjects: '',
				layerid: '',
				gridlayerid: ''
			};
			var i;
			for (i = 0; i < imgGroupButton.attributes.length; i++) {
				var curAttr = imgGroupButton.attributes[i];
				var attrName = curAttr.nodeName;
				var attrValue = curAttr.nodeValue;
				if (paramsObj.hasOwnProperty(attrName)) {
					paramsObj[attrName] = attrValue;
				}
			}
			//Данные выбранных строк грида
			var selectedArr = [];
			var rowindexes = $(currentGrid).jqxGrid('getselectedrowindexes');
			for (i = 0; i < rowindexes.length; i++) {
				var curRowData = $(currentGrid).jqxGrid('getrowdatabyid', rowindexes[i]);
				//Для еще не подгруженных данных грида элементы массива с недогруженными номерами будут undefined
				if (curRowData !== undefined && curRowData) {
					//т.к. часть данных в скрытых колонках, то из cachedRecords забираем весь набор атрибутов для выбраннй записи
					curRowData = GridUtil.getFullRowDataById(currentGrid, curRowData);
					selectedArr.push(curRowData);
				}
			}
			//Кнопки доступны всегда, поэтому проверяем isenabled - и если он false и в гриде не выбрана ни 1 запись - просим пользователя выделить запись в гриде
			var alertForm;
			if (paramsObj.isenabled != 'true' && rowindexes.length == 0) {
				alertForm = new AlertForm();
				alertForm.build("gridSelectRowAlertForm",gis_gridadmwidget_10,gis_gridadmwidget_11,AlertForm.OK);
			} else {
				//Дополнительно проверяем selectedObjects - если значение установлено в целое число > 0, то проверяем что в гриде выбрали <= этого числа
				var selectedObjectsLimit = parseInt(paramsObj.selectedobjects);
				if (selectedObjectsLimit!=undefined && !isNaN(selectedObjectsLimit) && selectedArr.length>selectedObjectsLimit) {
					alertForm = new AlertForm();
					var alertMessageText = selectedObjectsLimit==1 ? gis_gridadmwidget_12 : gis_gridadmwidget_13+selectedObjectsLimit+gis_gridadmwidget_14;
					alertForm.build("gridSelectRowAlertForm",alertMessageText,gis_gridadmwidget_15,AlertForm.OK);
				} else {
					//По содержимому объекта paramsObj будем вызывать соответствующую внешнюю функцию грида на данных selectedArr
					GridAdmWidget.prototype.callExternalGridFunction(paramsObj, selectedArr, currentGrid);

					//В dataAdapter в records хранятся все записи. В _source.datafields хранится описание колонок.
					/*var curDataAdapter = $(currentGrid).jqxGrid('source');
					 var curRowData = curDataAdapter.records[rowNum];*/
				}
			}
		} else {
			App.errorReport(gis_gridwidget_5);
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_19'});
	}
};

//Функция вызова внешней функции взаимодействия по переданным данным (выбранные ряды грида) и объекту с типом события
//eventParamsObj - объект, полученный от кнопки грида вида {path:'', eventname:'', tooltip:'', layerid:'', templatename:'', ext_data_id:'', gridlayerid:''}
//dataObj - объект с данными (массив выбранных записей грида)
GridAdmWidget.prototype.callExternalGridFunction = function (eventParamsObj, dataObj, currentGrid, gridTitle, rowNum) {
	try {
		var that = this;
		var widgetElementId = currentGrid.id.replace("jqxgrid",'');
		//Если переданы все параметры
		if (eventParamsObj && dataObj) {
			var i = 0, j = 0, k = 0;
			var windowId = "";
			var funcName = "";
			var params = [];
			var objectsStr = "";
			//Дополнительные переменные перед разделением на групповую и строковую операции
			var filterStr, dataRequest, curLayerObj, layerManagerInst, layerId, gridLayerId;
			var curDataAdapter = $(currentGrid).jqxGrid('source');
			var deletingObject, fileName, extDataId, deletingArr, deleteConfirmationForm, limitExportExcel, alertForm, dialog;
			/* переменные для административных задач */
			var deleteArray, currentTemplate;
			var currentMessageId; //Это не ID запроса. Это сам текущий запрос, который можно отменить через currentMessageId.abort()
			var requestParams, sendingData, gridPropPanelId, gridPropPanelDiv, routeIds, curObjectId, _baseOutputData;
			/* Задача администрирования трубопроводов */
			var kmCalcArray, lrsCalcArray, makeSrvDistrBndArray, offlineBindingByRouteArray, groupingByRouteIds, bindingByRouteIds;
			/* Задача администрирования отчетов ВТД */
			var iliCalcArray,iliCalcPressureArray,iliCalcPressureInput,iliCalcClusterArray,iliCalcClusterInput,iliCalcSTOArray,iliCalcSTOInput,iliCalcSTOforEHZArray,iliCalcSTOforEHZInput;
			/* Задача администрирования отчетов ЭХЗ */
			var cpCalcArray;
			/* Задача администрирования учетных записей */
			var addRolesToUsersArray;
			/* Задача администрирования ролей */
			var createRolesByLPUArray;
			/* Задача администрирования политик доступа */
			var addRolesToPoliciesArray, addPolicyRulesArray;
			/* Задача администрирования видеомониторинга */
			var addRoutesToVideosArray;
			/* Задача администрирования ЛПУ */
			var addZonesToLpuArray, addNomenclaturesToLpuArray;
			/* Задача валидачии данных */
			var bEditControlApplyArray, bEditControlRollbackArray;

			//Функция для вызова именно из грида сообщения об ошибке центровки
			var gridCenteringResultFunction = function gridCenteringResultFunction(shortText, fullText) {
				App.confirmDialog(shortText, null, {title:gis_core_1});
			};

			//Функция обновления грида после удаления
			var refreshGridAfterOperation = function refreshGridAfterOperation() {
				//После удаления обновляем грид
				var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID+'_'+currentGrid.id);
				refreshGridEvt.gridId = currentGrid.id;
				refreshGridEvt.dispatch();
			};

			//Окончание обработки групповой операции
			var endProcess = function endProcess() {
				//Не снимаем курсор ожидания - это делают onResult, onFault и cancelProcess
				//BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				deleteArray = null;
				/* Задача администрирования трубопроводов */
				kmCalcArray, lrsCalcArray, makeSrvDistrBndArray, offlineBindingByRouteArray, groupingByRouteIds, bindingByRouteIds  = null;
				/* Задача администрирования отчетов ВТД */
				iliCalcArray,iliCalcPressureArray,iliCalcPressureInput,iliCalcClusterArray,iliCalcClusterInput,iliCalcSTOArray,iliCalcSTOInput,iliCalcSTOforEHZArray,iliCalcSTOforEHZInput = null;
				/* Задача администрирования отчетов ЭХЗ */
				cpCalcArray = null;
				/* Задача администрирования учетных записей */
				addRolesToUsersArray = null;
				/* Задача администрирования ролей */
				createRolesByLPUArray = null;
				/* Задача администрирования политик */
				addRolesToPoliciesArray, addPolicyRulesArray = null;
				/* Задача администрирования видеомониторинга */
				addRoutesToVideosArray = null;
				/* Задача администрирования ЛПУ */
				addZonesToLpuArray, addNomenclaturesToLpuArray = null;
				/* Задача валидачии данных */
				bEditControlApplyArray, bEditControlRollbackArray = null;
				//Очищаем форму статуса процесса
				GridAdmWidget.processStatusForm = null;
				//обновляем грид
				refreshGridAfterOperation();
			};

			//Отмена текущего выполняемого запроса. Особенность - даже при отмене отработает функция onFault с ошибкой abort. abort.
			var cancelProcess = function cancelProcess() {
				if (currentMessageId) currentMessageId.abort();
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				//Не обновляем грид - это делается в endProcess.
			};

			//слушатель результата выполнения задачи
			var onResult = function onResult(resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				if (resultXML)
				{
					var er = HTTPServiceUtil.getError(resultXML);
					var showAlertMessage = function showAlertMessage(alertMsg, alertTitle) {
						if (er != "")
							App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_21'});
						else {
							alertForm = new AlertForm();
							alertForm.width = 320;
							alertForm.build("gridAdmTaskAlertForm", alertMsg, alertTitle, AlertForm.OK);
						}
					};
					switch (currentTemplate)
					{
						/* Задача администрирования трубопроводов */
						case "KM_ROUTE_Calc.xml":
						case "LRS_ROUTE_Calc.xml":
						case "GROUP_ROUTE_Idx.xml":
						case "DISTR_LINE_Idx.xml":
						case "LINE_ROUTE_Idx.xml":
						case "OFFLINE_LINE_Idx.xml":
						case "Interval_divining_UTE.xml":
						/* Задача администрирования отчетов ВТД */
						case "ILI_INSP_Proc.xml":
						case "ILI_Pressure.xml":
						case "ILI_Cluster.xml":
						case "STO_ILI_INSP_Proc.xml":
						case "STO_EHZ_INSP_Proc.xml":
						/* Задача администрирования отчетов ЭХЗ */
						case "CP_INSP_Proc.xml":
						/* Задача администрирования учетных записей */
						case "gridAdmUsersSetRolesToUsers":
						/* Задача администрирования политик */
						case "gridAdmPoliciesSetRolesToPolicies":
						case "gridAdmPoliciesSetRulesToPolicies":
						/* Задача администрирования видеомониторинга */
						case "gridAdmVideomonitorSetRoutesToVideo":
						/* Задача администрирования ЛПУ */
						case "gridAdmLpuSetZonesToLpu":
						case "gridAdmLpuSetNomenclaturesToLpu":
						/* Задача валидации данных */
						case "bEditControlApply":
						case "bEditControlRollback":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							break;
						/* Задача администрирования ролей */
						case "createRolesByLPU":
							//если успешно создали роль - создаем задачи для нее из шаблона в B_ROLE_TO_TASKS.xml
							if (er=='') {
								var idStr = $($.parseXML(resultXML)).find('data').attr('ID');
								if (idStr!=undefined && idStr!='') {
									var userId = Auth.getUserId();
									var userLogin = Auth.getUserName();
									var templateRoleId = '1'; //Идентификатор шаблонной роли для формирования ролей по ЛПУ МГ (по-умолчанию 1, то есть роль USER)
									var sendingDataLpu = '<data file="../UITasks/B_ROLE_TO_TASKS.xml" origId="'+templateRoleId+'" newId="'+idStr+'"/>';
									var requestParamsLpu = { descrType: 'insert', descrId: 'ADM_SEM.xml#COPY_ROLE_TASKS_XML', toElements: false, getSchema: false,
										data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >'+sendingDataLpu+'</root>' };
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
										requestParamsLpu, function onCreateXMLResult(resXML){
										//Снимаем курсор ожидания
										BlockingUtil.ready();
										//BlockingUtil.unblockApplication();
										var erLpu = HTTPServiceUtil.getError(resultXML);
										if (erLpu != "")
											App.errorReport(gis_gridadmwidget_16, erLpu, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_22'});
									}, function onCreateXMLFault(resXML){
										//Снимаем курсор ожидания
										BlockingUtil.ready();
										//BlockingUtil.unblockApplication();
										var erLpu = HTTPServiceUtil.getError(resultXML);
										if (erLpu != "")
											App.errorReport(gis_gridadmwidget_16, erLpu, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_23'});
									});
								}
							}
							//Обрабатываем результат запроса создания новой роли для ЛПУ
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							break;
						/* Задача администрирования трубопроводов */
						case "NET_BAT_Proc.xml":
							showAlertMessage(gis_gridadmwidget_21, gis_gridadmwidget_19);
							break;
						/* Задача администрирования отчетов ВТД */
						case "ILI_ZIP_Imp.xml":
							showAlertMessage(gis_gridadmwidget_22,gis_gridadmwidget_18);
							break;
						case "ILI_ZIP_Imp_55.xml":
							/*if(curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData){
								GridAdmInternal.processPasteFromExcel(curDataAdapter.currentGridDescr.pasteFromExcelData, currentGrid, curDataAdapter, that);
							}*/
							showAlertMessage(gis_gridadmwidget_23,gis_gridadmwidget_18);
							break;
						case "gridAdmIliBindToRoute":
							showAlertMessage(gis_gridadmwidget_24,gis_gridadmwidget_18);
							break;
						/* Задача администрирования отчетов ЭХЗ */
						case "CP_ZIP_Imp.xml":
							showAlertMessage(gis_gridadmwidget_25,gis_gridadmwidget_19);
							break;
						case "gridAdmPiCPBindToLine":
							showAlertMessage(gis_gridadmwidget_26,gis_gridadmwidget_18);
							break;
						/* Задача администрирования учетных записей */
						case "gridAdmUsersBlockUsers":
						case "gridAdmUsersUnblockUsers":
							if (er != "")
								App.errorReport(gis_gridadmwidget_27+gis_gridadmwidget_28, er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_24'});
							else
								refreshGridAfterOperation();
							break;
						/* Задача журнала аудита */
						case "gridAdmAuditClearLog":
							if (er != "")
								App.errorReport(gis_gridadmwidget_29+gis_gridadmwidget_28, er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_25'});
							else
								refreshGridAfterOperation();
							break;
						/* Задача коридоров */
						case "PS_TEMPLATE_Idx.xml":
							showAlertMessage(gis_gridadmwidget_30,gis_gridadmwidget_18);
							break;

						default:
							if (er != "")
								App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_26'});
							break;
					}
				}
			};
			//слушатель результата выполнения задачи
			var onFault = function onFault(resultXML, isConfirmDialog, isError) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				if (resultXML)
				{
					var er = HTTPServiceUtil.getError(resultXML);
					switch (currentTemplate)
					{
						/* Задача администрирования трубопроводов */
						case "KM_ROUTE_Calc.xml":
						case "LRS_ROUTE_Calc.xml":
						case "DISTR_LINE_Idx.xml":
						case "GROUP_ROUTE_Idx.xml":
						case "OFFLINE_LINE_Idx.xml":
						case "LINE_ROUTE_Idx.xml":
						case "Interval_divining_UTE.xml":
						/* Задача администрирования отчетов ВТД */
						case "ILI_INSP_Proc.xml":
						case "ILI_Pressure.xml":
						case "ILI_Cluster.xml":
						case "STO_ILI_INSP_Proc.xml":
						case "STO_EHZ_INSP_Proc.xml":
						/* Задача администрирования отчетов ЭХЗ */
						case "CP_INSP_Proc.xml":
							if (GridAdmWidget.processStatusForm){
								if(isConfirmDialog) er = resultXML;
								if(isError) {
									er = resultXML.replace(/<br\/>/g,'');
								}
								GridAdmWidget.processStatusForm.processResultString(er);
							}

							break;
						/* Задача администрирования учетных записей */
						case "gridAdmUsersSetRolesToUsers":
						/* Задача администрирования ролей */
						case "createRolesByLPU":
						/* Задача администрирования политик */
						case "gridAdmPoliciesSetRolesToPolicies":
						case "gridAdmPoliciesSetRulesToPolicies":
						/* Задача администрирования видеомониторинга */
						case "gridAdmVideomonitorSetRoutesToVideo":
						/* Задача администрирования ЛПУ */
						case "gridAdmLpuSetZonesToLpu":
						case "gridAdmLpuSetNomenclaturesToLpu":
						/* Задача валидации данных */
						case "bEditControlApply":
						case "bEditControlRollback":
							if (GridAdmWidget.processStatusForm){
								if(isConfirmDialog) {
									er = resultXML.replace(/<br\/>/g,'');
								}
								if(isError) {
									er = resultXML.replace(/<br\/>/g,'');
								}
								GridAdmWidget.processStatusForm.processResultString(er);
							}

							//НЕ обновляем грид (обновится в endProcess)
							//refreshGridAfterOperation();
							break;
						/* Задача администрирования трубопроводов */
						case "NET_BAT_Proc.xml":
						/* Задача администрирования отчетов ВТД */
						case "ILI_ZIP_Imp.xml":
						case "ILI_ZIP_Imp_55.xml":
						case "gridAdmIliBindToRoute":
						/* Задача администрирования отчетов ЭХЗ */
						case "CP_ZIP_Imp.xml":
						case "gridAdmPiCPBindToLine":
						/* Задача администрирования учетных записей */
						case "gridAdmUsersBlockUsers":
						case "gridAdmUsersUnblockUsers":
						/* Задача журнала аудита */
						case "gridAdmAuditClearLog":
						/* Задача коридоров */
						case "PS_TEMPLATE_Idx.xml":
						default:
							if(curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData) {
								//GridAdmInternal.processPasteFromExcel(curDataAdapter.currentGridDescr.pasteFromExcelData, currentGrid, curDataAdapter);
								curDataAdapter.currentGridDescr.pasteFromExcelData = undefined;
							}
							if(isConfirmDialog)
								App.confirmDialog(resultXML, undefined,{title:gis_core_1, html:true});
							else{
								if(isError){
									App.errorReport(gis_gridadmwidget_1, resultXML, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_27'});
								}
								else
									App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_27_1'});
							}

							break;
					}
				}
			};

			//Простая функция для перевода JSON Object с примитивными атрибутами (без массива) в xml с тегом <input />
			var convertSimpleObjectToXml = function convertSimpleObjectToXml(simpleObj) {
				var resXml = '<input />';
				for (var attrName in simpleObj) {
					var attrValue = simpleObj[attrName];
					//Значения "Y" и "N" переводим в true и false для админских серверных задач
					if (attrValue=="Y" || attrValue=="N") attrValue = attrValue=="Y";
					//Добавляем к результирующей строке
					resXml = resXml.replace('/>',attrName+'="'+attrValue+'" />');
				}
				return resXml;
			};

			//Простая функция для перевода xml с примитивными атрибутами в JSON Object (обязательно надо чтобы заканчивался на '" />' а не '"/>')
			var convertXmlToSimpleObject = function convertXmlToSimpleObject(simpleXml) {
				var resObj = {};
				//root_path="|zip_file_name="|do_calc_inspection="true|do_read_about="true|data_file_name="data.xml"
				simpleXml = simpleXml.replace('<input ','');
				simpleXml = simpleXml.replace('/>','');
				var xmlSplitArr = simpleXml.split('" ');
				for (var i = 0; i < xmlSplitArr.length; i++) {
					var paramSplitArr = xmlSplitArr[i].split('="');
					if (paramSplitArr.length==2) {
						//Значения true и false переводим в "Y" и "N" для админских серверных задач
						var paramValue = paramSplitArr[1];
						if (paramValue==true || paramValue==false) paramValue = paramValue ? "Y" : "N";
						resObj[paramSplitArr[0]] = paramSplitArr[1];
					}
				}
				return resObj;
			};

			//Обрабатываем полученный объект.
			/* КНОПКА В СТРОКЕ ГРИДА. Если есть свойство eventname - значит это вызов с кнопки для персонального ряда. Нужно обработать вызов согласно eventname
			 Типы eventName: ru.corelight.business.events.ExportToGPXEvent, ru.corelight.business.events.ShowOnMapEvent,
			 ru.corelight.business.events.ExportToExcelEvent, ru.corelight.business.events.RemoveGridRowEvent
			 */
			if (eventParamsObj.hasOwnProperty('eventname')) {
				if(rowNum !== undefined){
					$(currentGrid).jqxGrid('clearselection');
					$(currentGrid).jqxGrid('selectrow', Number(rowNum));
				}

				if (GridButtonsWithPopup && GridButtonsWithPopup.indexOf(eventParamsObj['eventname']) !== -1)
					widgetMoveWindowToPosition('grid','restore_default');
				switch (eventParamsObj['eventname']) {
					case 'ru.corelight.business.events.ExportToExcelPicketingByRouteEvent':
						if(dataObj[0] === undefined) break;
						var rId = undefined;
						var lId = undefined;
						if(dataObj.length>0 && goog.isDef(dataObj[0]["ROUTE_ID"]))
							rId = dataObj[0]["ROUTE_ID"];
						if(dataObj.length>0 && goog.isDef(dataObj[0]["LINE_ID"]))
							lId = dataObj[0]["LINE_ID"];
						extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE';


						function build() {
							//Создаем диалоговую форму
							dlg.dialog({
								modal: true,
								title: gis_gridadmwidget_106,
								dialogClass: 'noCloseButton gsi-zindex__dialog',
								closeOnEscape: true,
								width: 300,
								height: 180
							});

							//Кнопки Ок и отмены
							$("input[name='export']", dlg).click(function () {
								if($('input[id="radioPicketingByRoute"]', dlg).is(':checked'))
									ExportUtil.exportAdmPicketingToExcel([{ROUTE_ID: rId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE');
								else
									ExportUtil.exportAdmPicketingToExcel([{LINE_ID: lId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_LINE');
								$('#exportPicketingToExcelForm').remove();
							});
							$("input[name='cancel']", dlg).click(function () {
								$('#exportPicketingToExcelForm').remove();
							});
						}
						var elementId = 'exportPicketingToExcelForm';
						$('#'+elementId).remove();
						$('body').append('<div id="'+elementId+'"></div>');
						var dlg = $('#'+elementId);
						dlg.load('ui/html/ExportPicketingToExcelForm.html', build);
						break;
					case 'ru.corelight.business.events.ExportToGPXEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						filterStr = "ID = " + dataObj[0]["ID"];
						//Экспортируем объекты
						GridWidget.prototype.exportObjectsToGPX(filterStr, curDataAdapter.currentGridDescr);
						break;
					case 'ru.corelight.business.events.ShowOnMapEvent':
						if(dataObj[0] === undefined) break;
						//Формируем параметры для вызова функции центровки
						try {
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							gridLayerId = curDataAdapter.currentGridDescr.gridLayerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(gridLayerId);
							if (curLayerObj==undefined || curLayerObj==null) break;

							objectsStr = eventParamsObj["layerid"] + ":" + dataObj[0]["ID"];
							funcName = "showObjects";
							params = [{name:"objects", value:objectsStr}, {name:"select", value:true}, {name:"centering", value:true}, {name:"gridCenteringResultFunction", value:gridCenteringResultFunction}];
							//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
							ExternalInteraction.callFunction(windowId, funcName, params);
							//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
							widgetMoveWindowToPosition('grid');
						} catch (e) {
							App.errorReport(gis_gridadmwidget_31, e.message, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_28'});
						}
						break;
					case 'ru.corelight.business.events.ExportToExcelEvent':
						if(dataObj[0] === undefined) break;
						//забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
						limitExportExcel = NaN;
						if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
							limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						// isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
						if (limitExportExcel && dataObj.length > limitExportExcel && false && isNaN(limitExportExcel))
						{
							alertForm.build("gridExportLimitAlertForm",gis_gridadmwidget_32+dataObj.length+".<br/>"
								+gis_gridadmwidget_33+limitExportExcel+".<br/>"
								+gis_gridadmwidget_34+limitExportExcel+gis_gridadmwidget_35,gis_gridadmwidget_36);
						}
						else
						{
							alertForm.build("gridExportLimitAlertForm",gis_gridadmwidget_32+dataObj.length+".<br/>"
								+ gis_gridadmwidget_37,gis_gridadmwidget_38);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								//TODO переделать описание грида, чтобы в нем явно был указан шаблон для выгрузки в Excel (для PODS_ANODE_LIST.XML он например не указан)
								fileName = App.generateUUID() + ".xls";
								//Если вызов экспорта одиночной записи - при отсутствии templatename подставляем tamplate='export'
								layerId = eventParamsObj.hasOwnProperty('templatename') && eventParamsObj.templatename!='' ? eventParamsObj.templatename : eventParamsObj["layerid"];
								extDataId = eventParamsObj.hasOwnProperty('ext_data_id') && eventParamsObj.ext_data_id!='' ? eventParamsObj.ext_data_id : '';
								//Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде "русскоязычный заголовок колонки":value
								if (extDataId=='') {
									var newDataObj = {};
									var gridColArr = curDataAdapter.currentGridDescr.gridColumns;
									for (i = 0; i < gridColArr.length; i++) {
										//Так исключаем колонки с иконками, а также колонку с номером
										if (gridColArr[i].text=='' || gridColArr[i].datafield=="RWN" || !dataObj[0].hasOwnProperty(gridColArr[i].datafield)) continue;
										var curColHeaderText = gridColArr[i].text;
										//upd 27.05.20.заменяем \n в колонках на '', чтобы в excel в названиях не было _n
										curColHeaderText = curColHeaderText.replace(/(\\r\\n|\\n|\\r)/gm,'');
										var repl = /[^0-9a-zA-Zа-яА-Я_]/gi;
										curColHeaderText = curColHeaderText.replace(repl, "_");
										newDataObj[curColHeaderText] = dataObj[0][gridColArr[i].datafield];
									}
									ExportUtil.exportToExcel([newDataObj], fileName, layerId, 'export');
								} else {
									ExportUtil.exportToExcel(dataObj, fileName, layerId, extDataId);
								}
							}
						});
						break;
					case 'ru.corelight.business.events.RemoveGridRowEvent':
						if(dataObj[0] === undefined) break;
						try {
							gridLayerId = curDataAdapter.currentGridDescr.gridLayerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(gridLayerId);
							if (curLayerObj==undefined || curLayerObj==null) {
								//Если слоя нет - делаем как во флеше (там ничего не происходило, даже запрос не отправлялся, здесь Володя сказал должна быть форма с сообщением)
								alertForm = new AlertForm();
								alertForm.build("gridDeleteNoLayerAlertForm",gis_gridadmwidget_39,gis_gridadmwidget_40,AlertForm.OK);
								//Чистим выделение в гриде
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							//удаление ТОЛЬКО СЕМАНТИКИ (исправить provider на dataRequest = "", чтобы прошел полный алгоритм удаления сначала геометрии затем семантики)
							dataRequest = curLayerObj.dataProvider.semantic;
							//выставил PropertyPanelName="" как для случая групповой операции удаления было сделано
							deletingObject = {rowData:dataObj[0], classId:eventParamsObj["layerid"], objectId:dataObj[0]["ID"], provider:dataRequest, propertyPanelName:""};
							deletingArr = [];
							deletingArr.push(deletingObject);

							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									switch (eventParamsObj["layerid"]) {
										case 'WEB50_B_ROLE':
											GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_41,deletingArr,that,
												function deleteAdmRoles(curObj) {
													if (curObj) {
														//Сначала удаляем саму роль, потом удаляем описание роли из B_ROLE_TO_TASKS.xml
														sendingData = '<data ROLE_ID="'+curObj.objectId+'"/>';
														//Получаем параметры для запроса и исправляем их на нужные нам
														var userId = Auth.getUserId();
														var userLogin = Auth.getUserName();
														requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_B_ROLE', toElements: false, descrType: 'delete',
															data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
														//Устанавливаем курсор ожидания
														BlockingUtil.wait();
														//BlockingUtil.blockApplication();
														App.serverQueryXMLGridNode(Services.processQueryNode, requestParams,
															function onDeleteAdmRolesResult(resultXML) {
																//Снимаем курсор ожидания
																BlockingUtil.ready();
																//BlockingUtil.unblockApplication();
																if (resultXML) {
																	var er = HTTPServiceUtil.getError(resultXML);
																	if (er!='') {
																		GridWidget.processStatusForm.processResultString(gis_gridadmwidget_42 + curObj.objectId + gis_gridadmwidget_43 + er);
																	} else {
																		var deleteAdmRolesFromXML = function deleteAdmRolesFromXML(deleteAdmRolesResultXML) {
																			//Снимаем курсор ожидания
																			BlockingUtil.ready();
																			//BlockingUtil.unblockApplication();
																			//Обрабатываем как успешное удаление
																			GridWidget.processStatusForm.processResultString(er);
																		};
																		//Запускаем удаление описания роли из B_ROLE_TO_TASKS.xml
																		sendingData = '<data file="../UITasks/B_ROLE_TO_TASKS.xml" dataId="'+curObj.objectId+'"/>';
																		requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#EDIT_ROLE_TASKS_XML', toElements: false, descrType: 'delete',
																			data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
																		//Устанавливаем курсор ожидания
																		BlockingUtil.wait();
																		App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, requestParams, deleteAdmRolesFromXML, deleteAdmRolesFromXML);
																	}
																} else {
																	GridWidget.processStatusForm.processResultString(gis_gridadmwidget_42 + curObj.objectId);
																}
															},
															function onDeleteAdmRolesFault(resultXML) {
																GridWidget.processStatusForm.processResultString(gis_gridadmwidget_42 + curObj.objectId + gis_gridadmwidget_43 + resultXML);
															}
														);
													}
												},
												refreshGridAfterOperation, refreshGridAfterOperation, true);
											break;
										case 'WEB50_B_POLICY':
											GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_41,deletingArr,that,
												function deleteAdmPolicies(curObj) {
													if (curObj) {
														sendingData = '<data POLICY_ID="'+curObj.objectId+'"/>';
														//Получаем параметры для запроса и исправляем их на нужные нам
														var userId = Auth.getUserId();
														var userLogin = Auth.getUserName();
														requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_B_POLICY', toElements: false, descrType: 'delete',
															data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
														//Устанавливаем курсор ожидания
														BlockingUtil.wait();
														//BlockingUtil.blockApplication();
														App.serverQueryXMLGridNode(Services.processQueryNode, requestParams,
															function onDeleteAdmPoliciesResult(resultXML) {
																//Снимаем курсор ожидания
																BlockingUtil.ready();
																//BlockingUtil.unblockApplication();
																if (resultXML) {
																	var er = HTTPServiceUtil.getError(resultXML);
																	if (er!='') {
																		GridWidget.processStatusForm.processResultString(gis_gridadmwidget_44 + curObj.objectId + gis_gridadmwidget_43 + er);
																	} else {
																		GridWidget.processStatusForm.processResultString(er);
																	}
																} else {
																	GridWidget.processStatusForm.processResultString(gis_gridadmwidget_44 + curObj.objectId);
																}
															},
															function onDeleteAdmRolesFault(resultXML) {
																GridWidget.processStatusForm.processResultString(gis_gridadmwidget_44 + curObj.objectId + gis_gridadmwidget_43 + resultXML);
															}
														);
													}
												},
												refreshGridAfterOperation, refreshGridAfterOperation, true);
											break;
										default:
											var simpleGridWidget = new GridWidget();
											GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_41,deletingArr,simpleGridWidget,simpleGridWidget.deleteObject,
												refreshGridAfterOperation, refreshGridAfterOperation, true);
											break;
									}
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridadmwidget_45, e.message, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_29'});
						}
						break;
					case 'ru.corelight.business.events.ShowOnCASEvent':
						if(dataObj[0] === undefined) break;
						var taskName = "CAS";
						var curObj = dataObj[0];
						var params = {
							lineId: curObj["LINE_ID"],
							beginKm: curObj["STATION_BEG"],
							endKm: curObj["STATION_END"],
						}
						GridUtil.showOnCas(taskName, params);
						break;
					case 'ru.corelight.business.events.ShowVideoEvent':
						/*funcName = "showVideo";
						 params = [{name:"docId", value:dataObj[0]["ID"]}, {name:"videoUrl", value:dataObj[0]["FILE_NAME"]}];
						 //Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
						 ExternalInteraction.callFunction(windowId, funcName, params);*/
						//Вызываем через функцию виджет-взаимодействия js, а не через вызов флеша
						showVideo(dataObj[0]["ID"], dataObj[0]["FILE_NAME"],dataObj[0]["NAME"]);
						//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
						widgetMoveWindowToPosition('grid');
						break;
					case 'ru.corelight.business.events.ExportWRLEvent':
						ExportUtil.exportToWRL(dataObj[0].ID, dataObj[0].FILE_NAME);
						break;
					case 'ru.corelight.business.events.ExportIMGEvent':
						ExportUtil.exportToIMG(dataObj[0].ID, dataObj[0].FILE_NAME);
						break;
					case 'ru.corelight.business.events.BEditControlShowEvent':
						if(dataObj[0] === undefined) break;
						var schema = dataObj[0].TABLE_NAME;
						var owner = dataObj[0].OWNER;
						if(schema !== undefined && owner !== undefined){
							var curObjectId = owner.toUpperCase() +"_"+schema.toUpperCase() + ":" + dataObj[0].KEY_VALUE;
							//Добавляем div панели свойств текущего грида
							var gridPropPanelId = 'divPPanelBEditControlShowEvent';
							var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
							$('#' + gridPropPanelId).remove();
							$('#' + widgetElementId).append(gridPropPanelDiv);
							//Создаем панель свойств для текущего объекта
							$('#' + gridPropPanelId).myPropertiesPanel({
								zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
								objects:[{id: curObjectId, label: '', curRowData:dataObj[0]}],
								opener: "#" + widgetElementId,
								openerType: 'grid',
							});
						}
						break;

					case 'showInfoEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						layerId = curDataAdapter.currentGridDescr.layerId;
						if (curRowData && curRowData.ID || layerId === 'ADM_CONFIG') {
							//Добавляем доп. условие. Если грид годового плана шурфовок, что нужно открывать панель свойств PODS_ILI_INSPECTION
							var currentGridDescr = curDataAdapter.currentGridDescr;
							var curObjectId = layerId + ":" + curRowData.ID;
							var centeringCallback = undefined;
							var addObj = {};//доп.данные для панели свойств
							//Добавляем div панели свойств текущего грида
							var gridPropPanelId = 'divPPanel' +  currentGrid.id;
							var gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
							$('#' + gridPropPanelId).remove();
							$('#' + widgetElementId).append(gridPropPanelDiv);
							var gridCurrentHeight = currentGridDescr.propPanelHeight;
							var gridCurrentWidth = currentGridDescr.propPanelWidth;
							if ($('#' + widgetElementId).outerHeight() < currentGridDescr.propPanelHeight) gridCurrentHeight = $('#' + widgetElementId).outerHeight();
							if ($('#' + widgetElementId).outerWidth() < currentGridDescr.propPanelWidth) gridCurrentWidth = $('#' + widgetElementId).outerWidth();
							switch (layerId) {
								/* Задача редактирования параметров конфигурации */
								case 'ADM_CONFIG':
									//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
									$('#' + gridPropPanelId).myFormPropertiesPanel({
										buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
										zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
										modal: true,
										opener: "#" + widgetElementId,
										objects: [{
											id: "ADM_CONFIG",
											label: gis_gridadmwidget_7,
											attrs: [{name: 'KEY', value: curRowData.KEY}, {
												name: 'VALUE',
												value: curRowData.VALUE
											}, {name: 'COMMENTS', value: curRowData.COMMENTS}]
										}],
										handlers: {
											centeringCallback: centeringCallback,
											getFormDataCallback: function getFormDataCallback(dataObject) {
												if (dataObject && dataObject.hasOwnProperty('VALUE')) {
													var sendingData = '<data key="' + curRowData.KEY + '" data="&lt;add key=&quot;' + curRowData.KEY + '&quot; value=&quot;' + dataObject.VALUE + '&quot; />"/>';
													var requestParams = {
														descrType: 'update',
														descrId: 'ADM_SEM.xml#GET_CLIENT_SETTINGS',
														toElements: false,
														getSchema: false,
														data: '<root USER_ID="' + Auth.getUserId() + '" USER_LOGIN="' + Auth.getUserName() + '" PODS_USER="' + Auth.getUserName() + '" >' + sendingData + '</root>'
													};
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
														requestParams,
														//слушатель результата выполнения задачи
														function onResult(resultXML) {
															//Снимаем курсор ожидания
															BlockingUtil.ready();
															if (resultXML) {
																var er = HTTPServiceUtil.getError(resultXML);
																if (er != "")
																	App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_2 + er, undefined, {
																		filename: gis_filename_187,
																		functionname: 'gis_filename_187_10'
																	});
																else {
																	//Обновляем грид
																	var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID);
																	refreshGridEvt.gridId = currentGrid.id;
																	refreshGridEvt.dispatch();
																}
															}
														},
														function onFault(resultXML) {
															//Снимаем курсор ожидания
															BlockingUtil.ready();
															//BlockingUtil.unblockApplication();
															var er = HTTPServiceUtil.getError(resultXML);
															App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_2 + er, undefined, {
																filename: gis_filename_187,
																functionname: 'gis_filename_187_11'
															});
														}
													);
												} else {
													App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_8, undefined, {
														filename: gis_filename_187,
														functionname: 'gis_filename_187_12'
													});
												}
											}
										}
									});

									break;
								/* Задача администрирования учетных записей */
								case 'WEB50_B_USER_PRIVATE':
									curObjectId = 'ADM_B_USER_PRIVATE:' + curRowData.ID;
									gridTitle = gis_gridadmwidget_9;
								//break; //Продолжаем выполнение - открываем обычную панель свойств, заменив id на правильный
								default:
									//Создаем панель свойств для текущего объекта
									$('#' + gridPropPanelId).myPropertiesPanel({
										zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
										objects: [{id: curObjectId, label: gridTitle, curRowData: curRowData}],
										opener: "#" + widgetElementId,
										openerType: 'grid',
										showSystemInfo: true, /* Всегда показываем даже системные поля - мы под админом */
										editSystemInfo: false, /* Всегда редактируем даже системные поля - мы под админом */
										closeAfterSave: true, /* Закрывать ли панель свойств после обновления */
										buttonsDisabled: {
											btnLeftPSave: false,
											btnLeftPUndo: false,
											btnLeftPDelete: layerId === 'WEB50_B_USER_PRIVATE' || layerId === 'WEB50_B_ROLE' || layerId === 'WEB50_B_POLICY' /*false*/,
											btnLeftPExportNAV: true,
											btnLeftPShowOnMap: true,
											btnLeftPExcel: false,
											btnLeftPBack: true,
											btnLeftPForward: true
										},
										handlers: {
											centeringCallback: centeringCallback,
											successCallback: function (dataObj) {
												//обновляем грид если был успешный insert или update
												if (dataObj && dataObj.hasOwnProperty('params') && dataObj.params.hasOwnProperty('descrType')
													&& (dataObj.params.descrType == 'update' || dataObj.params.descrType == 'insert')) {
													var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID);
													refreshGridEvt.gridId = currentGrid.id;
													refreshGridEvt.dispatch();
												}
											},
											errorHandler: function (dataObj) {
												//не обновляем грид если была ошибка insert или update
											}
										}
									});
									break;
							}
						}
						break;
				}
			}

			/* ГРУППОВАЯ КНОПКА ГРИДА. Если есть свойство clickevent - значит это вызов с групповой кнопки грида. Нужно обработать вызов согласно clickevent
			 Типы clickevent: ru.corelight.business.events.GridFilterEvent, ru.corelight.business.events.ExportToGPXEvent, ru.corelight.business.events.CreateObjectEvent,
			 ru.corelight.business.events.ShowOnMapEvent, ru.corelight.business.events.ExportToExcelEvent, ru.corelight.business.events.RemoveGridRowEvent
			 */
			if (eventParamsObj.hasOwnProperty('clickevent')) {
				if (GridButtonsWithPopup && GridButtonsWithPopup.indexOf(eventParamsObj['clickevent']) !== -1)
					widgetMoveWindowToPosition('grid','restore_default');
				switch (eventParamsObj['clickevent']) {
					/* функции обычного грида */
					/*ГРУППА */
					case 'ManageColumnsEvent'://заглушка на добавление 1-й колонки
						var da = $(currentGrid).jqxGrid('source');
						if(da.currentGridDescr !== undefined){
							var columns = GridUtil.getGridColumns(currentGrid);
							try{
								$(currentGrid).jqxGrid('endcelledit', 0, columns[0].name, true);
							}
							catch(ex){}
							var manageGridColumnsForm = new ManageGridColumnsForm({
								columns: columns,
								applyCallback: function(columns){
									that.updateDataWithColumns(currentGrid, columns);
								}
							});
							manageGridColumnsForm.build(currentGrid.id+'_manageColumns');
						}
						break;
					/*ГРУППА фильтр*/
					case 'ru.corelight.business.events.GridFilterEvent':
						//Фильтрация грида
						var da = $(currentGrid).jqxGrid('source');
						if(da.currentGridDescr!=undefined){
							var bottomFilterForm = new BottomFilterForm();
							bottomFilterForm.currentGridDescr = da.currentGridDescr;
							bottomFilterForm.currentGrid = currentGrid;
							bottomFilterForm.currentFilters = da.currentGridDescr.currentFilter;
							bottomFilterForm.topFilters = da.currentGridDescr.topFilter;
							bottomFilterForm.roughFilters = da.currentGridDescr.roughFilter;
							bottomFilterForm.hasSpatial = false; //Дизэйблим чекбокс для админских задач
							bottomFilterForm.build(currentGrid.id+'_bottomFilter');
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, that.onBottomFilterFormClose);
						}
						break;
					case 'ru.corelight.business.events.ExportToGPXEvent':
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						filterStr = "ID IN (";
						for (i = 0; i < dataObj.length; i++) {
							filterStr += dataObj[i]["ID"];
							//К последнему ID сзади запятую не добавляем
							if (i < dataObj.length-1) {
								filterStr += ",";
							}
						}
						filterStr += ")";
						//Экспортируем объекты
						GridWidget.prototype.exportObjectsToGPX(filterStr, curDataAdapter.currentGridDescr);
						break;
					case 'ru.corelight.business.events.CreateObjectEvent':
						//Создаем панель свойств по классу объекта - она сохраняет новый объект
						curObjectId = eventParamsObj["layerid"];
						//Добавляем div панели свойств текущего грида
						gridPropPanelId = 'divPPanel' + currentGrid.id;
						gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: ''}],
							showSystemInfo: true, /* Всегда показываем даже системные поля - мы под админом */
							buttonsDisabled: {btnLeftPSave:false,btnLeftPUndo:false,btnLeftPDelete:true,btnLeftPExportNAV:true,btnLeftPShowOnMap:true,btnLeftPExcel:true,btnLeftPBack:true,btnLeftPForward:true},
							opener: "#" + widgetElementId,
							openerType: 'grid',
							handlers: {
								successCallback: function (dataObj) {
									//обновляем грид если был успешный insert или update
									if (dataObj && dataObj.hasOwnProperty('params') && dataObj.params.hasOwnProperty('descrType') && (dataObj.params.descrType=='update' || dataObj.params.descrType=='insert'))
									{
										//Создание роли: если после insert вернулся непустой ID - нужно для новой роли скопировать задачи из роли <role id="1046" name="NEW_USER">
										if (dataObj.params.descrType=='insert' && curObjectId=='WEB50_B_ROLE') {
											var createdRoleId = $(dataObj.data).children('string').text();
											var createdRoleIdStart = createdRoleId.indexOf('ID="');
											if (createdRoleIdStart > 0) {
												createdRoleId = createdRoleId.substring(createdRoleIdStart+4,createdRoleId.indexOf('"',createdRoleIdStart+4));
												var createdRoleDescr = dataObj.params.data;
												var createdRoleDescrStart = createdRoleDescr.indexOf('DESCRIPTION="');
												if (createdRoleDescrStart > 0) {
													createdRoleDescr = createdRoleDescr.substring(createdRoleDescrStart+13,createdRoleDescr.indexOf('"',createdRoleDescrStart+13));
												} else
													createdRoleDescr = "";
												//Получаем описание задач для роли <role id="1046" name="NEW_USER"> из B_ROLE_TO_TASKS.xml
												sendingData = '<data file="../UITasks/B_ROLE_TO_TASKS.xml" dataId="1046"/>';
												var userId = Auth.getUserId();
												var userLogin = Auth.getUserName();
												requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#EDIT_ROLE_TASKS_XML', toElements: false, descrType: 'select',
													data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
												//Устанавливаем курсор ожидания
												BlockingUtil.wait();
												App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
													function selectNewUserRoleFromXMLResult(resultXML){
														//Снимаем курсор ожидания
														BlockingUtil.ready();
														//BlockingUtil.unblockApplication();
														if (resultXML) {
															var er = HTTPServiceUtil.getError(resultXML);
															if (er != '') {
																App.errorReport(gis_gridadmwidget_46, er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_30'});
															} else {
																//В полученном тексте роли для нового пользователя меняем на id роли и name на описание новой роли
																var newUserRoleText = resultXML.replace('<root>','').replace('</root>','');
																//Экстравагантная ситуация, но есть возможность, что придет в обратном порядке, т.е. '<role name="NEW_USER" id="1046">', поэтому меняем и тот, и этот вариант
																newUserRoleText = newUserRoleText.replace('<role id="1046" name="NEW_USER">','<role id="'+createdRoleId+'" name="'+createdRoleDescr+'">');
																newUserRoleText = newUserRoleText.replace('<role name="NEW_USER" id="1046">','<role id="'+createdRoleId+'" name="'+createdRoleDescr+'">');
																//заменяем &lt; и &gt; и прочее
																newUserRoleText = newUserRoleText.xmlEscape().replace(new RegExp("&gt;","g"),'>').replace(new RegExp("\\n","g"),'&#xA;'); //Новый сервер работает с '>' вместо '&gt;'
																//Получаем описание задач для роли <role id="1046" name="NEW_USER"> из B_ROLE_TO_TASKS.xml
																sendingData = '<data file="../UITasks/B_ROLE_TO_TASKS.xml" data="'+newUserRoleText+'"/>';
																requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#EDIT_ROLE_TASKS_XML', toElements: false, descrType: 'insert',
																	data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
																//Устанавливаем курсор ожидания
																BlockingUtil.wait();
																App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
																	requestParams,
																	function insertNewUserRoleToXMLResult(resInsertXML) {
																		var er = HTTPServiceUtil.getError(resInsertXML);
																		if (er !== '')
																			App.errorReport(gis_gridadmwidget_46, er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_36'});
																		//Снимаем курсор ожидания
																		BlockingUtil.ready();
																		//BlockingUtil.unblockApplication();
																		
																	},
																	function insertNewUserRoleToXMLFault(resInsertXML) {
																		var er = HTTPServiceUtil.getError(resInsertXML);
																		if (er !== '')
																			App.errorReport(gis_gridadmwidget_46, er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_31'});
																		//Снимаем курсор ожидания
																		BlockingUtil.ready();
																		//BlockingUtil.unblockApplication();	
																	}
																);
															}
														}
													},
													function selectNewUserRoleFromXMLFault(resultXML){
														//Снимаем курсор ожидания
														BlockingUtil.ready();
														//BlockingUtil.unblockApplication();
														App.errorReport(gis_gridadmwidget_46, resultXML, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_32'});
													}
												);
											}
										}
										//Обновляем грид
										refreshGridAfterOperation();
									}
								},
								errorHandler: function (dataObj) {
									//не обновляем грид если была ошибка insert или update
								}
							}
						});
						break;
					case 'ru.corelight.business.events.ShowOnMapEvent':
						try {
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							gridLayerId = curDataAdapter.currentGridDescr.gridLayerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(gridLayerId);
							if (curLayerObj==undefined || curLayerObj==null)
								break;
							//Формируем параметры для вызова функции центровки
							objectsStr = eventParamsObj["layerid"] + ":";
							for (i = 0; i < dataObj.length; i++) {
								objectsStr += dataObj[i]["ID"];
								//К последнему ID сзади запятую не добавляем
								if (i < dataObj.length-1) {
									objectsStr += ",";
								}
							}
							funcName = "showObjects";
							params = [{name:"objects", value:objectsStr}, {name:"select", value:true}, {name:"centering", value:true}, {name:"gridCenteringResultFunction", value:gridCenteringResultFunction}];
							//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
							ExternalInteraction.callFunction(windowId, funcName, params);
							//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
							widgetMoveWindowToPosition('grid');
						} catch (e) {
							App.errorReport(gis_gridadmwidget_47, e.message, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_33'});
						}
						break;
					case 'ru.corelight.business.events.ExportToExcelEvent':
						gridLayerId = curDataAdapter.currentGridDescr.gridLayerId;
						//забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
						limitExportExcel = NaN;
						if (curDataAdapter.currentGridDescr.excelMaxExport!==undefined && curDataAdapter.currentGridDescr.excelMaxExport!==null && !isNaN(curDataAdapter.currentGridDescr.excelMaxExport)) {
							limitExportExcel = parseInt(curDataAdapter.currentGridDescr.excelMaxExport);
						} else if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
							limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						// isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
						if (limitExportExcel && !isNaN(limitExportExcel) && dataObj.length > limitExportExcel)
						{
							alertForm.width = 350;
							alertForm.build("gridExportLimitAlertForm",gis_gridadmwidget_32+dataObj.length+".<br/>"
								+gis_gridadmwidget_33+limitExportExcel+".<br/>"
								+gis_gridadmwidget_34+limitExportExcel+gis_gridadmwidget_35,gis_gridadmwidget_36);
							//Устанавливаем реальный лимит, который прописан в конфиге, чтобы избежать ошибки сервера (во флеше нельзя было выбрать более 1000 записей в принципе)
							dataObj = dataObj.slice(0,limitExportExcel);
						}
						else
						{
							//Вместо dataObj.length выводим общее число записей грида
							alertForm.build("gridExportLimitAlertForm",gis_gridadmwidget_32+dataObj.length+".<br/>"
								+ gis_gridadmwidget_37,gis_gridadmwidget_38);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								//Отдельно делаем экспорт некоторых гридов (например грида конфига) - их выгружаем так, как видим по аналогии с экспортом со строки грида
								if (gridLayerId=='ADM_CONFIG') {
									//Осуществляется просто экспорт (без ext_data_id) - формируем объект данных в виде "русскоязычный заголовок колонки":value
									var dataObjArr = [];
									var gridColArr = curDataAdapter.currentGridDescr.gridColumns;
									for (j = 0; j < dataObj.length; j++) {
										var newDataObj = {'ID': j.toString()};
										for (i = 0; i < gridColArr.length; i++) {
											//Так исключаем колонки с иконками, а также колонку с номером
											if (gridColArr[i].text=='' || gridColArr[i].datafield=="RWN" || !dataObj[0].hasOwnProperty(gridColArr[i].datafield)) continue;
											var curColHeaderText = gridColArr[i].text;
											//upd 27.05.20.заменяем \n в колонках на '', чтобы в excel в названиях не было _n
											curColHeaderText = curColHeaderText.replace(/(\\r\\n|\\n|\\r)/gm,'');
											var repl = /[^0-9a-zA-Zа-яА-Я_]/gi;
											curColHeaderText = curColHeaderText.replace(repl, "_");
											newDataObj[curColHeaderText] = dataObj[j][gridColArr[i].datafield];
										}
										dataObjArr.push(newDataObj);
									}
									ExportUtil.exportToExcel(dataObjArr, fileName, gridLayerId, 'export');
								} else {
									fileName = App.generateUUID() + ".xls";
									extDataId = curDataAdapter.currentGridDescr.excelDataRequest;
									ExportUtil.exportToExcel(dataObj, fileName, "server_export", extDataId); //excelTemplate для группы всегда "server_export"
								}
							}
						});
						break;
					case 'CopyToExcelEvent':
						try {
							if (dataObj[0] === undefined) {
								App.confirmDialog(gis_gridwidget_129);
								break;
							}
							GridUtil.copyToExcelEvent(curDataAdapter.currentGridDescr.gridColumns, dataObj );
						}
						catch(ex){
						}
						break;
					case 'PasteFromExcelEvent':
						try {
							//jqxGridId, gridElem, dataAdapter, event
							that.pasteFromExcelDialog(currentGrid, curDataAdapter);
						}
						catch(ex){
						}
						break;
					case 'ApplyUpdatedCellEvent':
						try {
							that.saveUpdatedCellDialog(currentGrid, curDataAdapter, false);
						}
						catch(ex){
						}
						break;
					case 'ru.corelight.business.events.RemoveGridRowEvent':
						try {
							gridLayerId = curDataAdapter.currentGridDescr.gridLayerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(gridLayerId);
							if (curLayerObj==undefined || curLayerObj==null) {
								//Если слоя нет - делаем как во флеше (там ничего не происходило, даже запрос не отправлялся, здесь Володя сказал должна быть форма с сообщением)
								alertForm = new AlertForm();
								alertForm.build("gridDeleteNoLayerAlertForm",gis_gridadmwidget_39,gis_gridadmwidget_40,AlertForm.OK);
								//Чистим выделение в гриде
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							//удаление ТОЛЬКО СЕМАНТИКИ (исправить provider на dataRequest = "", чтобы прошел полный алгоритм удаления сначала геометрии затем семантики)
							dataRequest = curLayerObj.dataProvider.semantic;
							deletingArr = [];
							for (i = 0; i < dataObj.length; i++) {
								deletingObject = {rowData:dataObj[i], classId:eventParamsObj["layerid"], objectId:dataObj[i]["ID"], provider:dataRequest, propertyPanelName:""};
								deletingArr.push(deletingObject);
							}

							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									switch (eventParamsObj["layerid"]) {
										case 'WEB50_B_ROLE':
											GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_48,deletingArr,that,
												function deleteAdmRoles(curObj) {
													if (curObj) {
														//Сначала удаляем саму роль, потом удаляем описание роли из B_ROLE_TO_TASKS.xml
														sendingData = '<data ROLE_ID="'+curObj.objectId+'"/>';
														//Получаем параметры для запроса и исправляем их на нужные нам
														var userId = Auth.getUserId();
														var userLogin = Auth.getUserName();
														requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_B_ROLE', toElements: false, descrType: 'delete',
															data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
														//Устанавливаем курсор ожидания
														BlockingUtil.wait();
														//BlockingUtil.blockApplication();
														App.serverQueryXMLGridNode(Services.processQueryNode, requestParams,
															function onDeleteAdmRolesResult(resultXML) {
																//Снимаем курсор ожидания
																BlockingUtil.ready();
																//BlockingUtil.unblockApplication();
																if (resultXML) {
																	var er = HTTPServiceUtil.getError(resultXML);
																	if (er!='') {
																		GridWidget.processStatusForm.processResultString(gis_gridadmwidget_42 + curObj.objectId + gis_gridadmwidget_43 + er);
																	} else {
																		var deleteAdmRolesFromXML = function deleteAdmRolesFromXML(deleteAdmRolesResultXML) {
																			//Снимаем курсор ожидания
																			BlockingUtil.ready();
																			//BlockingUtil.unblockApplication();
																			//Обрабатываем как успешное удаление
																			GridWidget.processStatusForm.processResultString(er);
																		};
																		//Запускаем удаление описания роли из B_ROLE_TO_TASKS.xml
																		sendingData = '<data file="../UITasks/B_ROLE_TO_TASKS.xml" dataId="'+curObj.objectId+'"/>';
																		requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#EDIT_ROLE_TASKS_XML', toElements: false, descrType: 'delete',
																			data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
																		//Устанавливаем курсор ожидания
																		BlockingUtil.wait();
																		App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, requestParams, deleteAdmRolesFromXML, deleteAdmRolesFromXML);
																	}
																} else {
																	GridWidget.processStatusForm.processResultString(gis_gridadmwidget_42 + curObj.objectId);
																}
															},
															function onDeleteAdmRolesFault(resultXML) {
																GridWidget.processStatusForm.processResultString(gis_gridadmwidget_42 + curObj.objectId + gis_gridadmwidget_43 + resultXML);
															}
														);
													}
												},
												refreshGridAfterOperation, refreshGridAfterOperation, true);
											break;
										case 'WEB50_B_POLICY':
											GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_41,deletingArr,that,
												function deleteAdmPolicies(curObj) {
													if (curObj) {
														sendingData = '<data POLICY_ID="'+curObj.objectId+'"/>';
														//Получаем параметры для запроса и исправляем их на нужные нам
														var userId = Auth.getUserId();
														var userLogin = Auth.getUserName();
														requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_B_POLICY', toElements: false, descrType: 'delete',
															data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
														//Устанавливаем курсор ожидания
														BlockingUtil.wait();
														//BlockingUtil.blockApplication();
														App.serverQueryXMLGridNode(Services.processQueryNode, requestParams,
															function onDeleteAdmPoliciesResult(resultXML) {
																//Снимаем курсор ожидания
																BlockingUtil.ready();
																//BlockingUtil.unblockApplication();
																if (resultXML) {
																	var er = HTTPServiceUtil.getError(resultXML);
																	if (er!='') {
																		GridWidget.processStatusForm.processResultString(gis_gridadmwidget_44 + curObj.objectId + gis_gridadmwidget_43 + er);
																	} else {
																		GridWidget.processStatusForm.processResultString(er);
																	}
																} else {
																	GridWidget.processStatusForm.processResultString(gis_gridadmwidget_44 + curObj.objectId);
																}
															},
															function onDeleteAdmRolesFault(resultXML) {
																GridWidget.processStatusForm.processResultString(gis_gridadmwidget_44 + curObj.objectId + gis_gridadmwidget_43 + resultXML);
															}
														);
													}
												},
												refreshGridAfterOperation, refreshGridAfterOperation, true);
											break;
										default:
											var simpleGridWidget = new GridWidget();
											GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_48,deletingArr,simpleGridWidget,simpleGridWidget.deleteObject,
												refreshGridAfterOperation, refreshGridAfterOperation, true);
											break;
									}
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridadmwidget_45, e.message, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_34'});
						}
						break;

					/*
					 Задача администрирования трубопроводов
					 * */
					//Пересчет линейной дистанции
					case 'gridAdmRoutesLrsCalc':
						currentTemplate = "LRS_ROUTE_Calc.xml";
						GridAdmInternal.gridAdmRoutesLrsCalc({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj: dataObj,
							onResult:onResult,
							onFault:onFault,
							endProcess:endProcess,
							cancelProcess:cancelProcess,
							that: that
						})
						break;
					//Пересчет километража
					case 'gridAdmRoutesKmCalc':
						currentTemplate = "KM_ROUTE_Calc.xml";
						GridAdmInternal.gridAdmRoutesKmCalc({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj: dataObj,
							onResult:onResult,
							onFault:onFault,
							endProcess:endProcess,
							cancelProcess:cancelProcess,
							that: that
						})
						break;
					//Нарезка магистралей по ЛПУ
						//upd. 31.03.21 принято решение исключить из гридов. В коде оставляем
					case 'gridAdmRoutesMakeSrvDistrBnd':
						makeSrvDistrBndArray = dataObj;
						GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_52,makeSrvDistrBndArray,that,
							function processSingleMakeSrvDistrBndCalc(route) {
								if (route && route.hasOwnProperty("LINE_ID"))
								{
									sendingData = '<input line_id="'+route.LINE_ID+'"/>';
									currentTemplate = "DISTR_LINE_Idx.xml";
									requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
								}
								else
								if (GridAdmWidget.processStatusForm)
									GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_53);
							},
							endProcess, cancelProcess, true);
						break;
					//Заполнение трубопроводной сети
					//upd. 31.03.21 принято решение исключить из гридов. В коде оставляем
					case 'gridAdmRoutesFillNetwork':
						sendingData = '<input/>';
						//Закомментировать эту строчку для отладки, чтобы реально не перезаполнить какую-нибудь БД
						currentTemplate = "NET_BAT_Proc.xml";
						requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
						//Устанавливаем курсор ожидания
						BlockingUtil.wait();
						//BlockingUtil.blockApplication();
						App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
						break;
					//Группировка пересек. объектов
					case 'gridAdmRoutesGroupByRoute':
						currentTemplate = "GROUP_ROUTE_Idx.xml";
						GridAdmInternal.gridAdmRoutesGroupByRoute({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj: dataObj,
							onResult:onResult,
							onFault:onFault,
							endProcess:endProcess,
							cancelProcess:cancelProcess,
							that: that
						})
						break;

					//Привязка вдольтрассовых объектов
					case 'gridAdmRoutesOfflineBindingByRoute':
						currentTemplate = "OFFLINE_LINE_Idx.xml";
						GridAdmInternal.gridAdmRoutesOfflineBindingByRoute({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj: dataObj,
							onResult:onResult,
							onFault:onFault,
							endProcess:endProcess,
							cancelProcess:cancelProcess,
							that: that
						})
						break;
					//Привязка трассовых объектов
					case 'gridAdmRoutesLineBindingByRoute':
						currentTemplate = "LINE_ROUTE_Idx.xml";
						GridAdmInternal.gridAdmRoutesLineBindingByRoute({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj: dataObj,
							onResult:onResult,
							onFault:onFault,
							endProcess:endProcess,
							cancelProcess:cancelProcess,
							that: that
						})
						break;
					//Разбивка на интервалы
					case 'gridAdmRoutesIntervalDividing':
						currentTemplate = "Interval_divining_UTE.xml";
						GridAdmInternal.gridAdmRoutesIntervalDividing({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj: dataObj,
							onResult:onResult,
							onFault:onFault,
							endProcess:endProcess,
							cancelProcess:cancelProcess,
							that: that	
						})
						break;
					//Запрос для экспорта по участку трубопровода
					case 'gridAdmRoutesExportPicketingByRoute':
						//Формируем список routeIds из поля ROUTE_ID
						//используем 1-й route
						routeIds = [];
						if(dataObj.length>0 && goog.isDef(dataObj[i]["ROUTE_ID"]))
							routeIds.push(dataObj[0]["ROUTE_ID"]);
						extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE';
						//Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде "русскоязычный заголовок колонки":value
						ExportUtil.exportAdmPicketingToExcel([{ROUTE_ID:routeIds[0]}], 'server_export', extDataId);
						break;
					//Экспорт пикетажа по всему газопроводу
					case 'gridAdmRoutesExportPicketingByLine':
						//Формируем список routeIds из поля ROUTE_ID
						//используем 1-й route
						routeIds = [];
						if(dataObj.length>0 && goog.isDef(dataObj[0]["LINE_ID"]))
							routeIds.push(dataObj[0]["LINE_ID"]);
						extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_LINE';
						//Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде "русскоязычный заголовок колонки":value
						ExportUtil.exportAdmPicketingToExcel([{LINE_ID:routeIds[0]}], 'server_export', extDataId);
						break;

					/*
					 Задача администрирования карт
					 * */
					//Редактирование карты
					case 'gridAdmMapsEditMap':
						//Создаем панель свойств
						curObjectId = eventParamsObj["layerid"] + ':' + dataObj[0]['ID'];
						//Добавляем div панели свойств текущего грида
						gridPropPanelId = 'divPPanel' + currentGrid.id;
						gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: gis_gridadmwidget_107}],
							showSystemInfo: true, /* Всегда показываем даже системные поля - мы под админом */
							buttonsDisabled: {btnLeftPSave:false,btnLeftPUndo:false,btnLeftPDelete:false,btnLeftPExportNAV:true,btnLeftPShowOnMap:true,btnLeftPExcel:true,btnLeftPBack:true,btnLeftPForward:true},
							opener: "#" + widgetElementId,
							openerType: 'grid',
						});
						break;
					//Управление слоями карт
					case 'gridAdmMapsEditMapLayers':
						try {
							var elementId = "id" + Math.floor(Math.random() * (10000)) + "_GRID";
							var gridTemplate = "ADM_MAP_LAYERS_LIST";
							var fullLayerId = dataObj[0]['LAYERS_FILE_NAME'] + '#' + eventParamsObj["layerid"];
							var gridPopup = new GridWindow();
							gridPopup.build('', elementId, [{name:'mdl', value:'Public/SWF/Grid_55.swf'}, {name:'template', value:gridTemplate}, {name:'title', value:''}, {name:'template', value:gridTemplate}], arrTemplates[windowTemplate]);
							//Загружаем грид для конкретной карты. НУЖНО ПОДУМАТЬ КАК ПЕРЕДАТЬ КАРТУ
							App.loadWidgetGrid(elementId, gridTemplate, fullLayerId, gis_gridadmwidget_61);
						} catch (e) {
							App.errorReport(gis_gridadmwidget_62, e, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_39'});
						}
						break;

					/*
					 Задача администрирования отчетов ВТД
					 * */
					//Импорт отчетов XML
					case 'gridAdmIliImportXML':
						currentTemplate = 'ILI_ZIP_Imp_55.xml';
						GridAdmInternal.gridAdmIliImportXML({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataAdapter: curDataAdapter,
							that: that,
							onResult:onResult,
							onFault:onFault
						})
						break;
					//Привязать отчет к трубе
					case 'gridAdmIliBindToRoute':
						//В форме один комбобокс начинает заполняться только после выбора значения в другом, пока такой логики в панели свойств нет
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliBindToRouteForm";
						var gridAdmIliBindToRouteForm = new GridAdmIliBindToRouteForm();
						gridAdmIliBindToRouteForm.build(gridPropPanelId);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function onGridAdmIliBindToRouteFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							//Для этой формы в evt.detail при отмене придет -1, при ошибке выбора комбобокса придет 0 или корректное значение curRouteId в остальных случаях
							if (evt && evt.detail != -1) {
								if (evt.detail==0)
									App.errorReport(gis_gridwidget_5, gis_gridadmwidget_67, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_42'});
								else {
									var curRouteId = evt.detail;
									sendingData = '<data ILI_INSPECTION_ID="'+dataObj[0].ID+'" ROUTE_ID="'+curRouteId+'"/>';
									//Получаем параметры для запроса и исправляем их на нужные нам
									var userId = Auth.getUserId();
									var userLogin = Auth.getUserName();
									requestParams = { getSchema: false, descrId: 'GAZPROM_ADM_SEM.xml#BIND_ILI_INSPECTION_TO_ROUTE', toElements: false, descrType: 'update',
										data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
									//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
									currentTemplate = "gridAdmIliBindToRoute";
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
								}
							}
						});
						break;
					//Пересчет отчетов
					case 'gridAdmIliCalc':
						currentTemplate = 'ILI_INSP_Proc.xml';
						GridAdmInternal.gridAdmIliCalc({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj:dataObj,
							that:that,
							onResult:onResult,
							onFault:onFault,
							endProcess: endProcess
						})
						break;
					//выгрузить лог UTEService
					case 'gridAdmExportUTELog':
						var win = window.open('./api/log/ute-log', '_blank');
						win.focus();
						break;
					//1. Группировка дефектов в кластеры
					case 'gridAdmIliCalcCluster':
						currentTemplate = 'ILI_Cluster.xml';
						GridAdmInternal.gridAdmIliCalcCluster({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj:dataObj,
							that:that,
							onResult:onResult,
							onFault:onFault,
							endProcess: endProcess
						})
						break;
					//2. Расчет точечных показателей в соответствии с СТО 112, 173, 292, 401, 595
					case 'gridAdmIliCalcPressure':
						currentTemplate = 'ILI_Pressure.xml';
						GridAdmInternal.gridAdmIliCalcPressure({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj:dataObj,
							that:that,
							onResult:onResult,
							onFault:onFault,
							endProcess: endProcess
						})
						break;
					//3. Расчет линейных показателей в соответствии с СТО 095, 292, 401
					case 'gridAdmIliCalcSTO':
						currentTemplate = 'STO_ILI_INSP_Proc.xml';
						GridAdmInternal.gridAdmIliCalcSTO({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj:dataObj,
							that:that,
							onResult:onResult,
							onFault:onFault,
							endProcess: endProcess
						})
						break;
					//4. Расчет линейных показателей в соответствии с инструкцией ВНИИГАЗ 2004
					case 'gridAdmIliCalcSTOforEHZ':
						currentTemplate = 'STO_EHZ_INSP_Proc.xml';
						GridAdmInternal.gridAdmIliCalcSTOforEHZ({
							gridPropPanelId: gridPropPanelId,
							gridPropPanelDiv: gridPropPanelDiv,
							widgetElementId: widgetElementId,
							dataObj:dataObj,
							that:that,
							onResult:onResult,
							onFault:onFault,
							endProcess: endProcess
						})
						break;
					/*
					 Задача администрирования отчетов ЭХЗ
					 * */
					//Пересчет отчетов
					case 'gridAdmPiCPCalc':
						cpCalcArray = dataObj;
						GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_68,cpCalcArray,that,
							function processSingleInspection(inspection) {
								if (inspection && inspection.hasOwnProperty("ID"))
								{
									sendingData = '<input inspection_id="'+inspection.ID+'"/>';
									currentTemplate = "CP_INSP_Proc.xml";
									requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
								}
								else
								if (GridAdmWidget.processStatusForm)
									GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
							},
							endProcess, cancelProcess, true);
						break;
					//Импорт отчетов
					case 'gridAdmPiCPImport':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmPiCPImport";
						gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects:[{id: "ADM_PI_CP_IMPORT", label: gis_gridadmwidget_63}],
							handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
								if (dataObject) {
									//меняем код трубопровода на его название, чтобы в запросе корректно обрабатывалось
									if(dataObject.DESCR !== undefined && dataObject.DESCR_LABEL !== undefined)
										dataObject.DESCR = dataObject.DESCR_LABEL;
									if(dataObject.PRODUCER === "")
										dataObject.PRODUCER = "UNKNOWN";
									/*'<input/>';*/ //Путь здесь должен быть таким: sendingData.@zip_file_name = config.UPLOAD_PATH+"\\"+uploadedFileName;
									sendingData = convertSimpleObjectToXml(dataObject);
									var uploadPath = App.config && App.config.hasOwnProperty("UPLOAD_PATH") ? App.config['UPLOAD_PATH'] : '';
									sendingData = sendingData.replace('zip_file_name="','zip_file_name="'+uploadPath);
									currentTemplate = "CP_ZIP_Imp.xml";
									requestParams = GridAdmWidget.prototype.makeUTEServiceParams(uploadPath, sendingData);
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									//App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
									App.serverQueryXMLGrid(Services.ImportCP, requestParams, onResult, onFault);
								} else {
									App.errorReport(gis_gridwidget_5, gis_gridadmwidget_64, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_47'});
								}
							}}
						});
						break;
					case 'gridAdmPiCPImportZip':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmPiCPImport";
						gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects:[{id: "ADM_PI_CP_IMPORT_ZIP", label: gis_gridadmwidget_63}],
							handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
								if (dataObject) {
									/*'<input/>';*/ //Путь здесь должен быть таким: sendingData.@zip_file_name = config.UPLOAD_PATH+"\\"+uploadedFileName;
									sendingData = convertSimpleObjectToXml(dataObject);
									var uploadPath = App.config && App.config.hasOwnProperty("UPLOAD_PATH") ? App.config['UPLOAD_PATH'] : '';
									sendingData = sendingData.replace('zip_file_name="','zip_file_name="'+uploadPath);
									currentTemplate = "CP_ZIP_Imp.xml";
									requestParams = GridAdmWidget.prototype.makeUTEServiceParams(uploadPath, sendingData);

									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
									//App.serverQueryXMLGrid(Services.ImportCP, requestParams, onResult, onFault);
								} else {
									App.errorReport(gis_gridwidget_5, gis_gridadmwidget_64, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_48'});
								}
							}}
						});
						break;
					//Привязка отчета к трубе
					case 'gridAdmPiCPBindToLine':
						//Добавляем div панели свойств для создания формы ввода
						//upd. 22.03.19 функционал привязки отчетов ЭХЗ такой же, как для ВТД
						gridPropPanelId = 'divFormPPanel' + "_gridAdmPiCPBindToLine";
						var gridAdmIliBindToRouteForm = new GridAdmIliBindToRouteForm();
						gridAdmIliBindToRouteForm.build(gridPropPanelId);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function onGridAdmIliBindToRouteFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							//Для этой формы в evt.detail при отмене придет -1, при ошибке выбора комбобокса придет 0 или корректное значение curRouteId в остальных случаях
							if (evt && evt.detail != -1) {
								if (evt.detail==0)
									App.errorReport(gis_gridwidget_5, gis_gridadmwidget_67, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_49'});
								else {
									var curRouteId = evt.detail;
									sendingData = '<data REPORT_ID="'+dataObj[0].ID+'" ROUTE_ID="'+curRouteId+'"/>';
									//Получаем параметры для запроса и исправляем их на нужные нам
									var userId = Auth.getUserId();
									var userLogin = Auth.getUserName();
									requestParams = { getSchema: false, descrId: 'UTE_SEM.xml#CALC_CALC_CP', toElements: false, descrType: 'update',
										data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
									//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
									currentTemplate = "gridAdmPiCPBindToLine";
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
								}
							}
						});
						break;
					/*
					 Задача администрирования учетных записей
					 * */
					//Зарегистрировать учетную запись
					case 'gridAdmUsersRegisterUser':
						//В гриде административных задач мы можем создавать объекты через панель свойств
						//Создаем панель свойств по классу объекта WEB50_B_USER_PRIVATE_REG - это отдельный класс специально для создания нового пользователя
						curObjectId = 'WEB50_B_USER_PRIVATE_REG';
						//Добавляем div панели свойств текущего грида
						gridPropPanelId = 'divPPanel' + currentGrid.id;
						gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: gis_gridadmwidget_84}],
							showSystemInfo: true, /* Всегда показываем даже системные поля - мы под админом */
							buttonsDisabled: {btnLeftPSave:false,btnLeftPUndo:false,btnLeftPDelete:true,btnLeftPExportNAV:true,btnLeftPShowOnMap:true,btnLeftPExcel:true,btnLeftPBack:true,btnLeftPForward:true},
							opener: "#" + widgetElementId,
							openerType: 'grid',
							handlers: {
								successCallback: function (dataObj) {
									//обновляем грид если был успешный insert или update
									if (dataObj && dataObj.hasOwnProperty('params') && dataObj.params.hasOwnProperty('descrType')
										&& (dataObj.params.descrType=='update' || dataObj.params.descrType=='insert')) {
										refreshGridAfterOperation();
									}
								},
								errorHandler: function (dataObj) {
									//не обновляем грид если была ошибка insert или update
									if (dataObj && dataObj.text){
										App.errorReport(gis_ppanel_26, dataObj.text, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_57'});
									}
								}
							}
						});
						break;
					//Заблокировать учетные записи
					case 'gridAdmUsersBlockUsers':
						alertForm = new AlertForm();
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.build("gridAdmUsersBlockUsersAlertForm",gis_gridadmwidget_85,gis_gridadmwidget_86);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridAdmUsersBlockUsersAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								filterStr = " 1=1 ";
								if (dataObj && dataObj.length>0) {
									for (i = 0; i < dataObj.length; i++) {
										if (dataObj[i].hasOwnProperty("ID")) {
											if (filterStr == " 1=1 ") filterStr = " USER_ID IN (";
											filterStr += dataObj[i]["ID"];
											if (i==dataObj.length-1)
												filterStr += ") ";
											else
												filterStr += ",";
										}
									}
								}
								//формируем запрос с фильтром для блокировки списка USERS
								sendingData = '<data FILTER="'+filterStr+'" STATUS="B"/>';
								//Получаем параметры для запроса и исправляем их на нужные нам
								var userId = Auth.getUserId();
								var userLogin = Auth.getUserName();
								requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_B_USER_PRIVATE', toElements: false, descrType: 'update',
									data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
								//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
								currentTemplate = "gridAdmUsersBlockUsers";
								//Устанавливаем курсор ожидания
								BlockingUtil.wait();
								//BlockingUtil.blockApplication();
								App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
								//Снимаем выделение, поскольку выделенные элементы будут обновлены
								$(currentGrid).jqxGrid('clearselection');
							}
						});
						break;
					//Разблокировать учетные записи
					case 'gridAdmUsersUnblockUsers':
						filterStr = " 1=1 ";
						if (dataObj && dataObj.length>0) {
							for (i = 0; i < dataObj.length; i++) {
								if (dataObj[i].hasOwnProperty("ID")) {
									if (filterStr == " 1=1 ") filterStr = " USER_ID IN (";
									filterStr += dataObj[i]["ID"];
									if (i==dataObj.length-1)
										filterStr += ") ";
									else
										filterStr += ",";
								}
							}
						}
						//формируем запрос с фильтром для разблокировки списка USERS
						sendingData = '<data FILTER="'+filterStr+'" STATUS="A"/>';
						//Получаем параметры для запроса и исправляем их на нужные нам
						var userId = Auth.getUserId();
						var userLogin = Auth.getUserName();
						requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_B_USER_PRIVATE', toElements: false, descrType: 'update',
							data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
						//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
						currentTemplate = "gridAdmUsersUnblockUsers";
						//Устанавливаем курсор ожидания
						BlockingUtil.wait();
						//BlockingUtil.blockApplication();
						App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
						//Снимаем выделение, поскольку выделенные элементы будут обновлены
						$(currentGrid).jqxGrid('clearselection');
						break;
					//Задать пароль пользователю
					case 'gridAdmUsersSetUserPassword':
						//Пока что меняем пароль только одному пользователю, даже если выбрали несколько записей. Изменен пароль будет у первой записи.
						/*dialog = Object.create(ChangePasswordDialog);
						 dialog.changingUserLogin = dataObj[i]["LOGIN"];
						 dialog.build();*/
						dialog = new AdmChangePassForm();
						dialog.userLoginPassChange = dataObj[i]["LOGIN"];
						dialog.userExternalAuth = dataObj[i].hasOwnProperty("EXT_AUTH") && dataObj[i]["EXT_AUTH"]=='Y';
						dialog.build("gridAdmUsersSetUserPasswordForm");
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridAdmUsersSetUserPasswordFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail == 1) {
								//Снимаем выделение, поскольку выделенные элементы будут обновлены
								$(currentGrid).jqxGrid('clearselection');
								//Обновляем грид
								refreshGridAfterOperation();
							}
						});
						break;
					//Назначить роли пользователям
					case 'gridAdmUsersSetRolesToUsers':
						$('#gridAdmUsersSetRolesToUsers').remove();
						$('body').append('<div id="gridAdmUsersSetRolesToUsers"></div>');
						dialog = $('#gridAdmUsersSetRolesToUsers');
						var filterControlId = 'gridAdmUsersSetRolesToUsersFilter';
						var filterControl= "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'>" +
							"<components:FilterPopUpButton width='100%' isDropDown='false' minPopupWidth='610' height='22' title='Установка ролей пользователям' selectAllElements='false'" +
							" minCnt='0' id='"+filterControlId+"' dataProvider='ADM_SEM.xml#WEB50_B_ROLES' /></mx:VBox>";
						dialog.append('<div id="gridAdmUsersSetRolesToUsersFilterDiv"></div>');
						var roughFilterDiv = $('#gridAdmUsersSetRolesToUsersFilterDiv');
						roughFilterDiv.myFilters({dataXML:filterControl,handlers:{
							applyHandler:function(params){
								var resFilterValues = roughFilterDiv.myFilters('getFilterValuesArray');
								var dotSplitArr = resFilterValues[0].values;
								//Убираем диалог выбора ролей
								$('#gridAdmUsersSetRolesToUsers').remove();
								//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
								var rolesArr = [];
								for (j = 0; j < dotSplitArr.length; j++) {
									rolesArr.push(dotSplitArr[j].code);
								}
								//Массив для последующей обработки {юзер,роль,операция}
								addRolesToUsersArray = [];
								//Пробегаемся по всем выбранным пользователям и создаем массив для добавления/удаления ролей
								for (i = 0; i < dataObj.length; i++) {
									var userRolesKeys = {};
									var curUserRoles = dataObj[i]['ROLE_IDS'].split(',');
									//Все бывшие у юзера роли по-умолчанию добавляем в delete
									for (k = 0; k < curUserRoles.length; k++) {
										userRolesKeys[curUserRoles[k]] = {'USER_ID':dataObj[i]['USER_ID'], 'ROLE_ID':curUserRoles[k], 'TYPE':'delete'};
									}
									//Обрабатываем все новые установленные роли
									for (k = 0; k < rolesArr.length; k++) {
										//Если роль уже была - убираем этот ключ, если ее не было - добавляем
										if (userRolesKeys.hasOwnProperty(rolesArr[k])) {
											delete userRolesKeys[rolesArr[k]];
										} else {
											userRolesKeys[rolesArr[k]] = {'USER_ID':dataObj[i]['USER_ID'], 'ROLE_ID':rolesArr[k], 'TYPE':'insert'};
										}
									}
									//Добавляем в массив на обработку имеющиеся для текущего юзера роли
									for (k in userRolesKeys) {
										addRolesToUsersArray.push(userRolesKeys[k]);
									}
								}
								//Запускаем процесс обработки ролей для пользователей
								GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_88,addRolesToUsersArray,that,
									function processSingleUserToRole(userToRole) {
										if (userToRole && userToRole.hasOwnProperty("USER_ID") && userToRole.hasOwnProperty("ROLE_ID") && userToRole.hasOwnProperty("TYPE")) {
											sendingData = '<data M_USER_ID="'+userToRole.USER_ID+'" M_ROLE_ID="'+userToRole.ROLE_ID+'"/>';
											//Получаем параметры для запроса и исправляем их на нужные нам
											var userId = Auth.getUserId();
											var userLogin = Auth.getUserName();
											requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_USER_TO_ROLE', toElements: false, descrType: userToRole.TYPE,
												data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
											//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
											currentTemplate = "gridAdmUsersSetRolesToUsers";
											//Устанавливаем курсор ожидания
											BlockingUtil.wait();
											//BlockingUtil.blockApplication();
											currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
										}
										else
										if (GridAdmWidget.processStatusForm)
											GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_89);
									},
									endProcess, cancelProcess, true);
							},
							cancelHandler:function(params){
								$('#gridAdmUsersSetRolesToUsers').remove();
							}
						}});
						//Ставим в фильтр значения уже установленных для первого пользователя ролей через запятую
						if (dataObj[0].hasOwnProperty('ROLE_IDS')) {
							$('#gridAdmUsersSetRolesToUsersFilterDiv .'+filterControlId).myFilters('updateTopFilter',{obj_ids:dataObj[0]['ROLE_IDS']});
						}
						//Строим диалог и показываем в нем в раскрытом виде список ролей
						dialog.dialog({
							resizable: false,
							modal:     true,
							dialogClass:   'noCloseButton noTitleBar gsi-zindex__dialog',
							width:     605,
							height: 440,
							title: ''
						});
						//Если выбрали > 1 пользователя, показываем диалог с текстом предупреждения
						if (dataObj.length > 1) {
							alertForm = new AlertForm();
							alertForm.height = 140;
							alertForm.build("gridAdmUsersSetRolesToUsersAlertForm",gis_gridadmwidget_90,gis_gridadmwidget_91,AlertForm.OK);
						}
						break;
					//Разослать уведомления пользователям
					case 'gridAdmUsersSendMails':
						dialog = Object.create(AdmSendEmailDialog);
						var usersEmails = [];
						for (i = 0; i < dataObj.length; i++) {
							if (dataObj[i].hasOwnProperty("MAIL")) usersEmails.push(dataObj[i]["MAIL"]);
						}
						dialog.setEmails(usersEmails.join(','));
						dialog.build(true);
						break;

					/*
					 Задача администрирования ролей
					 * */
					//Установить задачу по-умолчанию
					case 'gridAdmRolesSetDefaultTask':
						//Получаем и обрабатываем xml со списком задач для выбранной роли
						sendingData = '<data file="../UITasks/B_ROLE_TO_TASKS.xml" dataId="'+dataObj[0]['ID']+'"/>';
						//Получаем параметры для запроса и исправляем их на нужные нам
						var userId = Auth.getUserId();
						var userLogin = Auth.getUserName();
						requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#EDIT_ROLE_TASKS_XML', toElements: false, descrType: 'select',
							data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
						//Устанавливаем курсор ожидания
						BlockingUtil.wait();
						currentMessageId = App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
							requestParams, function onGetRolesResult(resultXML){
							//Снимаем курсор ожидания
							BlockingUtil.ready();
							//BlockingUtil.unblockApplication();
							if (resultXML) {
								var er = HTTPServiceUtil.getError(resultXML);
								if (er!='') {
									App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_2 + er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_50'});
								} else {
									//Получаем роли и формируем из них форму с комбобоксом для выбора дефолтной
									//Создаем форму выбора роли по-умолчанию
									var gridAdmRolesSetDefaultTaskForm = new GridAdmRolesSetDefaultTaskForm();
									gridAdmRolesSetDefaultTaskForm.role = dataObj[0];
									gridAdmRolesSetDefaultTaskForm.rolesXML = resultXML;
									gridAdmRolesSetDefaultTaskForm.build('gridAdmRolesSetDefaultTaskForm');
									//Добавляем слушатель закрытия формы
									$("body").on(CloseEvent.CLOSE, function gridAdmRolesSetDefaultTaskFormClose(evt/*CloseEvent*/) {
										$("body").off(CloseEvent.CLOSE);
										if (evt && evt.detail == 1) {
											//Снимаем выделение, поскольку выделенные элементы будут обновлены
											$(currentGrid).jqxGrid('clearselection');
											//Обновляем грид
											refreshGridAfterOperation();
										}
									});
								}
							}
						}, function onGetRolesFault(resultXML){
							//Снимаем курсор ожидания
							BlockingUtil.ready();
							//BlockingUtil.unblockApplication();
							if (resultXML) {
								var er = HTTPServiceUtil.getError(resultXML);
								App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_2 + er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_51'});
							}
						});
						break;
					//Установить задачи для роли
					case 'gridAdmRolesSetTaskToRole':
						//Получаем и обрабатываем xml со списком задач для выбранной роли
						sendingData = '<data file="../UITasks/B_ROLE_TO_TASKS.xml" dataId="'+dataObj[0]['ID']+'"/>';
						//Получаем параметры для запроса и исправляем их на нужные нам
						var userId = Auth.getUserId();
						var userLogin = Auth.getUserName();
						requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#EDIT_ROLE_TASKS_XML', toElements: false, descrType: 'select',
							data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
						//Устанавливаем курсор ожидания
						BlockingUtil.wait();
						currentMessageId = App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
							requestParams, function onGetRolesResult(resultXML){
							//Снимаем курсор ожидания
							BlockingUtil.ready();
							if (resultXML) {
								var er = HTTPServiceUtil.getError(resultXML);
								if (er!='') {
									App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_2 + er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_52'});
								} else {
									//Создаем форму установки задач для роли
									var gridAdmRolesSetTaskToRoleForm = new GridAdmRolesSetTaskToRoleForm();
									gridAdmRolesSetTaskToRoleForm.role = dataObj[0];
									gridAdmRolesSetTaskToRoleForm.roles = dataObj;
									gridAdmRolesSetTaskToRoleForm.rolesXML = resultXML;
									gridAdmRolesSetTaskToRoleForm.build('gridAdmRolesSetTaskToRoleForm');
									//Добавляем слушатель закрытия формы
									$("body").on(CloseEvent.CLOSE, function gridAdmRolesSetTaskToRoleFormClose(evt/*CloseEvent*/) {
										$("body").off(CloseEvent.CLOSE);
										if (evt && evt.detail == 1) {
											//Снимаем выделение, поскольку выделенные элементы будут обновлены
											$(currentGrid).jqxGrid('clearselection');
											//Обновляем грид
											refreshGridAfterOperation();
										}
									});
								}
							}
						}, function onGetRolesFault(resultXML){
							//Снимаем курсор ожидания
							BlockingUtil.ready();
							//BlockingUtil.unblockApplication();
							if (resultXML) {
								var er = HTTPServiceUtil.getError(resultXML);
								App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_2 + er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_53'});
							}
						});
						break;
					//Создать роли по ЛПУ
					case 'gridAdmRolesCreateRolesByLPU':
						var userId = Auth.getUserId();
						var userLogin = Auth.getUserName();
						requestParams = { getSchema: false, descrId: 'GAZPROM_ADM_SEM.xml#ADM_ROLES_SRV_DISTRICT', toElements: false, descrType: 'select',
							data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" ><data /></root>' };
						//Устанавливаем курсор ожидания
						BlockingUtil.wait();
						//BlockingUtil.blockApplication();
						currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, function onGetRolesSrvDistrictResult(resultXML){
							//Снимаем курсор ожидания
							BlockingUtil.ready();
							//BlockingUtil.unblockApplication();
							if (resultXML) {
								var er = HTTPServiceUtil.getError(resultXML);
								if (er!='') {
									App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_2 + er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_54'});
								} else {
									var xmlData = $.parseXML(resultXML);
									//По массиву полученных ЛПУ создаем роли
									currentTemplate = "createRolesByLPU";
									createRolesByLPUArray = [];
									$(xmlData).find('data').each(function(){
										var curSrvDistrObj = {CODE:$(this).attr('CODE'), DESCR:$(this).attr('DESCR')};
										createRolesByLPUArray.push(curSrvDistrObj);
									});
									GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_92,createRolesByLPUArray,that,
										function createSingleRoleByLPU(srvDistrObj) {
											if (srvDistrObj && srvDistrObj.hasOwnProperty("CODE"))
											{
												sendingData = '<data SRV_DISTRICT_ID="'+srvDistrObj.CODE+'" DESCRIPTION="'+srvDistrObj.DESCR+'"/>';
												requestParams = { descrType: 'insert', descrId: 'GAZPROM_ADM_SEM.xml#CREATE_ROLE_BY_LPU', toElements: false, getSchema: false,
													data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >'+sendingData+'</root>' };
												//Устанавливаем курсор ожидания
												BlockingUtil.wait();
												//BlockingUtil.blockApplication();
												currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
											}
											else
											if (GridAdmWidget.processStatusForm)
												GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_93);
										},
										endProcess, cancelProcess, true);
								}
							}
						}, function onGetRolesSrvDistrictFault(resultXML){
							//Снимаем курсор ожидания
							BlockingUtil.ready();
							//BlockingUtil.unblockApplication();
							if (resultXML) {
								var er = HTTPServiceUtil.getError(resultXML);
								App.errorReport(gis_gridadmwidget_1, gis_gridadmwidget_2 + er, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_55'});
							}
						});
						break;

					/*
					 Задача администрирования политик доступа
					 * */
					//Правила политики
					case 'gridAdmPoliciesPolicyRules':
						//Создаем форму с правилами выбранной политики доступа (на закрытие слуушателя не требуется)
						var gridAdmPoliciesPolicyRulesForm = new GridAdmPoliciesPolicyRulesForm();
						gridAdmPoliciesPolicyRulesForm.policy = dataObj[0];
						gridAdmPoliciesPolicyRulesForm.policies = dataObj;
						gridAdmPoliciesPolicyRulesForm.build('gridAdmPoliciesPolicyRulesForm');
						//Если выбрали > 1 политики, показываем диалог с текстом предупреждения
						if (dataObj.length > 1) {
							alertForm = new AlertForm();
							alertForm.height = 140;
							alertForm.build("gridAdmPoliciesPolicyRulesAlertForm",gis_gridadmwidget_94,gis_gridadmwidget_91,AlertForm.OK);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridAdmPoliciesPolicyRulesFormClose(evt/*CloseEvent*/) {
							if (!evt || evt.parent!=gridAdmPoliciesPolicyRulesForm) return;
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail == 1) {
								//Если dataObj.length>1 и есть eventData - нужно у всех ролей кроме первой удалить правила, а затем выставить создать правила, аналогичные первой роли
								if (dataObj.length > 1 && evt.eventData!=null) {
									addPolicyRulesArray = [];
									//Массив со списком правил, которые есть у первой роли
									var firstPolicyRulesArr = [];
									for (i = 0; i < evt.eventData.length; i++) {
										if (!evt.eventData[i].hasOwnProperty('DESCRIPTION')) evt.eventData[i]['DESCRIPTION'] = '';
										if (evt.eventData[i]['POLICY_ID']==dataObj[0]['POLICY_ID']) {
											firstPolicyRulesArr.push(evt.eventData[i]);
										} else {
											//Если нужно удалить имеющиеся правила перед установкой новых, этот код нужно выполнять. Если не нужно - закомментировать.
											evt.eventData[i]['TYPE'] = 'delete'; //Иначе помечаем как правило для удаления
											addPolicyRulesArray.push(evt.eventData[i]);
										}
									}
									//Теперь проходим по массиву всех политик, кроме первой и для каждой добавляем правила первой политики
									for (i = 1; i < dataObj.length; i++) {
										for (j = 0; j < firstPolicyRulesArr.length; j++) {
											//Копируем атрибуты (кроме ID и POLICY_ID) из очередной политики первой роли
											var newRuleObj = {'POLICY_ID':dataObj[i]['ID'], 'TYPE':'insert'};
											for (var attrName in firstPolicyRulesArr[j]) {
												if (attrName!='POLICY_ID') newRuleObj[attrName] = firstPolicyRulesArr[j][attrName];
											}
											addPolicyRulesArray.push(newRuleObj);
										}
									}
									//Запускаем процесс обработки ролей для пользователей
									GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_95,addPolicyRulesArray,that,
										function processSinglePolicyRule(policyRule) {
											if (policyRule && policyRule.hasOwnProperty("POLICY_ID") && policyRule.hasOwnProperty("RULE_ID") && policyRule.hasOwnProperty("TYPE")
												&& policyRule.hasOwnProperty("CLASS_ID") && policyRule.hasOwnProperty("DESCRIPTION") && policyRule.hasOwnProperty("SELECT_PERMITTED")
												&& policyRule.hasOwnProperty("INSERT_PERMITTED") && policyRule.hasOwnProperty("UPDATE_PERMITTED") && policyRule.hasOwnProperty("DELETE_PERMITTED")) {
												//sendingData одинаковая для insert и delete, потому что в insert игнорируется поле RULE_ID, а в delete нужно только RULE_ID
												sendingData = '<data POLICY_ID="'+policyRule['POLICY_ID']+'" RULE_ID="'+policyRule['RULE_ID']+'" CLASS_ID="'+policyRule['CLASS_ID']+'"' +
													' DESCRIPTION="'+policyRule['DESCRIPTION']+'" SELECT_PERMITTED="'+policyRule['SELECT_PERMITTED']+'" INSERT_PERMITTED="'+policyRule['INSERT_PERMITTED']+'"' +
													' UPDATE_PERMITTED="'+policyRule['UPDATE_PERMITTED']+'" DELETE_PERMITTED="'+policyRule['DELETE_PERMITTED']+'" />';
												//Получаем параметры для запроса и исправляем их на нужные нам
												var userId = Auth.getUserId();
												var userLogin = Auth.getUserName();
												requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_B_POLICY_RULES', toElements: false, descrType: policyRule.TYPE,
													data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
												//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
												currentTemplate = "gridAdmPoliciesSetRulesToPolicies";
												//Устанавливаем курсор ожидания
												BlockingUtil.wait();
												//BlockingUtil.blockApplication();
												currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
											}
											else
											if (GridAdmWidget.processStatusForm)
												GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_96);
										},
										endProcess, cancelProcess, true);
								}
							}
						});
						break;
					//Установка политик ролям
					case 'gridAdmPoliciesSetRoleToPolicy':
						$('#gridAdmPoliciesSetRoleToPolicy').remove();
						$('body').append('<div id="gridAdmPoliciesSetRoleToPolicy"></div>');
						dialog = $('#gridAdmPoliciesSetRoleToPolicy');
						var filterControlId = 'gridAdmPoliciesSetRoleToPolicyFilter';
						var filterControl= "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'>" +
							"<components:FilterPopUpButton width='100%' isDropDown='false' minPopupWidth='610' height='22' title='Установка политик доступа ролям' selectAllElements='false'" +
							" minCnt='0' id='"+filterControlId+"' dataProvider='ADM_SEM.xml#WEB50_B_ROLES' /></mx:VBox>";
						dialog.append('<div id="gridAdmPoliciesSetRoleToPolicyFilterDiv"></div>');
						var roughFilterDiv = $('#gridAdmPoliciesSetRoleToPolicyFilterDiv');
						roughFilterDiv.myFilters({dataXML:filterControl,handlers:{
							applyHandler:function(params){
								var resFilterValues = roughFilterDiv.myFilters('getFilterValuesArray');
								var dotSplitArr = resFilterValues[0].values;
								//Убираем диалог выбора ролей
								$('#gridAdmPoliciesSetRoleToPolicy').remove();
								//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
								var rolesArr = [];
								for (j = 0; j < dotSplitArr.length; j++) {
									rolesArr.push(dotSplitArr[j].code);
								}
								//Массив для последующей обработки {политика,роль,операция}
								addRolesToPoliciesArray = [];
								//Пробегаемся по всем выбранным политикам и создаем массив для добавления/удаления ролей
								for (i = 0; i < dataObj.length; i++) {
									var policyRolesKeys = {};
									var curPolicyRoles = dataObj[i]['ROLE_IDS'].split(',');
									//Все бывшие у политики роли по-умолчанию добавляем в delete
									for (k = 0; k < curPolicyRoles.length; k++) {
										policyRolesKeys[curPolicyRoles[k]] = {'POLICY_ID':dataObj[i]['POLICY_ID'], 'ROLE_ID':curPolicyRoles[k], 'TYPE':'delete'};
									}
									//Обрабатываем все новые установленные роли
									for (k = 0; k < rolesArr.length; k++) {
										//Если роль уже была - убираем этот ключ, если ее не было - добавляем
										if (policyRolesKeys.hasOwnProperty(rolesArr[k])) {
											delete policyRolesKeys[rolesArr[k]];
										} else {
											policyRolesKeys[rolesArr[k]] = {'POLICY_ID':dataObj[i]['POLICY_ID'], 'ROLE_ID':rolesArr[k], 'TYPE':'insert'};
										}
									}
									//Добавляем в массив на обработку имеющиеся для текущей политики роли
									for (k in policyRolesKeys) {
										addRolesToPoliciesArray.push(policyRolesKeys[k]);
									}
								}
								//Запускаем процесс обработки ролей для пользователей
								GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_97,addRolesToPoliciesArray,that,
									function processSinglePolicyToRole(policyToRole) {
										if (policyToRole && policyToRole.hasOwnProperty("POLICY_ID") && policyToRole.hasOwnProperty("ROLE_ID") && policyToRole.hasOwnProperty("TYPE")) {
											sendingData = '<data M_POLICY_ID="'+policyToRole.POLICY_ID+'" M_ROLE_ID="'+policyToRole.ROLE_ID+'"/>';
											//Получаем параметры для запроса и исправляем их на нужные нам
											var userId = Auth.getUserId();
											var userLogin = Auth.getUserName();
											requestParams = { getSchema: false, descrId: 'ADM_SEM.xml#WEB50_ROLE_TO_POLICY', toElements: false, descrType: policyToRole.TYPE,
												data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
											//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
											currentTemplate = "gridAdmPoliciesSetRolesToPolicies";
											//Устанавливаем курсор ожидания
											BlockingUtil.wait();
											//BlockingUtil.blockApplication();
											currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
										}
										else
										if (GridAdmWidget.processStatusForm)
											GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_98);
									},
									endProcess, cancelProcess, true);
							},
							cancelHandler:function(params){
								$('#gridAdmPoliciesSetRoleToPolicy').remove();
							}
						}});
						//Ставим в фильтр значения уже установленных для первой политики ролей через запятую
						if (dataObj[0].hasOwnProperty('ROLE_IDS') && dataObj[0]['ROLE_IDS']!='') {
							$('#gridAdmPoliciesSetRoleToPolicyFilterDiv .'+filterControlId).myFilters('updateTopFilter',{obj_ids:dataObj[0]['ROLE_IDS']});
						}
						//Строим диалог и показываем в нем в раскрытом виде список ролей
						dialog.dialog({
							resizable: false,
							modal:     true,
							dialogClass:   'noCloseButton noTitleBar gsi-zindex__dialog',
							width:     605,
							height: 440,
							title: ''
						});
						//Если выбрали > 1 политики, показываем диалог с текстом предупреждения
						if (dataObj.length > 1) {
							alertForm = new AlertForm();
							alertForm.height = 140;
							alertForm.build("gridAdmPoliciesSetRoleToPolicyAlertForm",gis_gridadmwidget_99,gis_gridadmwidget_91,AlertForm.OK);
						}
						break;

					/* Задача видеомониторинга */
					//Установка связи видео с трубопроводами
					case 'gridAdmVideomonitorSetRoutesToVideo':
						var gridAdmVideomonitorSetRoutesToVideoForm = new GridAdmVideomonitorSetRoutesToVideoForm();
						gridAdmVideomonitorSetRoutesToVideoForm.curVideo = dataObj[0];
						gridAdmVideomonitorSetRoutesToVideoForm.build();
						break;
					//Установка связи видео с треком
					case 'gridAdmVideomonitorSetTrackToVideo':
						var gridAdmVideomonitorSetTrackToVideoForm = new GridAdmVideomonitorSetTrackToVideoForm();
						gridAdmVideomonitorSetTrackToVideoForm.curVideo = dataObj[0];
						gridAdmVideomonitorSetTrackToVideoForm.build();
						break;

					/* Задача журнала аудита*/
					//Очистка журнала
					case 'gridAdmAuditClearLog':
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.build("gridAdmAuditClearLogAlertForm",gis_gridadmwidget_100,gis_gridadmwidget_101);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridAdmAuditClearLogAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								//Получаем параметры для запроса и исправляем их на нужные нам
								var userId = Auth.getUserId();
								var userLogin = Auth.getUserName();
								requestParams = { descrType: 'delete', descrId: 'ADM_SEM.xml#WEB50_B_AUDIT_EVENT', toElements: false, getSchema: false,
									data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" ><data FILTER=" 1=1 "/></root>' };
								//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
								currentTemplate = "gridAdmAuditClearLog";
								//Устанавливаем курсор ожидания
								BlockingUtil.wait();
								//BlockingUtil.blockApplication();
								currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
							}
						});
						break;

					/* Задача коридоров */
					//Индексация
					//upd. 31.03.21 принято решение исключить из гридов. В коде оставляем
					case 'gridAdmPipeSystemIndexing':
						//Создаем форму с правилами выбранной политики доступа
						var gridAdmPipeSystemIndexingForm = new GridAdmPipeSystemIndexingForm();
						gridAdmPipeSystemIndexingForm.build('gridAdmPipeSystemIndexingForm');
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridAdmPipeSystemIndexingFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								var templateIds = evt.eventData;
								var pipeSystemIds = [];
								for (i = 0; i < dataObj.length; i++) {
									pipeSystemIds.push(dataObj[i]['ID']);
								}
								sendingData = '<input template_id="'+templateIds+'" pipe_system_id="'+pipeSystemIds.join(',')+'"/>';
								//Закомментировать эту строчку для отладки, чтобы реально не перезаполнить какую-нибудь БД
								currentTemplate = "PS_TEMPLATE_Idx.xml";
								requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
								//Устанавливаем курсор ожидания
								BlockingUtil.wait();
								//BlockingUtil.blockApplication();
								App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
							}
						});
						break;
					//Установка газопроводов
					case 'gridAdmPipeSystemSetRoutes':
						//Создаем форму с правилами выбранной политики доступа
						var gridAdmPipeSystemRoutesForm = new GridAdmPipeSystemRoutesForm();
						gridAdmPipeSystemRoutesForm.pipeSystem = dataObj[0];
						gridAdmPipeSystemRoutesForm.build('gridAdmPipeSystemRoutesForm');
						break;

					/* Задача администрирования ЛПУ */
					//Установка зон для ЛПУ
					case 'gridAdmLpuSetZones':
						//Создаем форму с правилами выбранной политики доступа
						var gridAdmLpuSetZonesForm = new GridAdmLpuSetZonesForm();
						gridAdmLpuSetZonesForm.srvDistrict = dataObj[0];
						gridAdmLpuSetZonesForm.build('gridAdmLpuSetZonesForm');
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridAdmLpuSetZonesFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								addZonesToLpuArray = evt.eventData;
								//Запускаем процесс обработки зон для лпу
								GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_102,addZonesToLpuArray,that,
									function processSingleZoneToLpu(zoneToLpu) {
										if (zoneToLpu && zoneToLpu.hasOwnProperty("ZONE_ID") && zoneToLpu.hasOwnProperty("SRV_DISTRICT_ID")
											&& zoneToLpu.hasOwnProperty("ZONELPU_TABLE_SAVE") && zoneToLpu.hasOwnProperty("TYPE")) {
											//Получаем параметры для запроса и исправляем их на нужные нам
											var userId = Auth.getUserId();
											var userLogin = Auth.getUserName();
											sendingData = '<data ZONE_ID="'+zoneToLpu.ZONE_ID+'" SRV_DISTRICT_ID="'+zoneToLpu.SRV_DISTRICT_ID+'" ZONELPU_TABLE_SAVE="'+zoneToLpu.ZONELPU_TABLE_SAVE+'"/>';
											requestParams = { getSchema: false, descrId: 'GAZPROM_ADM_SEM.xml#WEB50_LPU_TO_M_ZONES', toElements: false, descrType: zoneToLpu.TYPE,
												data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
											//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
											currentTemplate = "gridAdmLpuSetZonesToLpu";
											//Устанавливаем курсор ожидания
											BlockingUtil.wait();
											//BlockingUtil.blockApplication();
											currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
										}
										else
										if (GridAdmWidget.processStatusForm)
											GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_103);
									},
									endProcess, cancelProcess, true);
							}
						});
						break;
					//Установка номенклатур для ЛПУ
					case 'gridAdmLpuSetNomenclatures':
						//Создаем форму с правилами выбранной политики доступа
						var gridAdmLpuSetNomenclaturesForm = new GridAdmLpuSetNomenclaturesForm();
						gridAdmLpuSetNomenclaturesForm.srvDistrict = dataObj[0];
						gridAdmLpuSetNomenclaturesForm.build('gridAdmLpuSetNomenclaturesForm');
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridAdmLpuSetNomenclaturesFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								addNomenclaturesToLpuArray = evt.eventData;
								//Запускаем процесс обработки номенклатур для лпу
								GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_104,addNomenclaturesToLpuArray,that,
									function processSingleNomToLpu(nomToLpu) {
										if (nomToLpu && nomToLpu.hasOwnProperty("CODE") && nomToLpu.hasOwnProperty("SRV_DISTRICT_ID")
											&& nomToLpu.hasOwnProperty("NOMLPU_TABLE_SAVE") && nomToLpu.hasOwnProperty("TYPE")) {
											//Получаем параметры для запроса и исправляем их на нужные нам
											var userId = Auth.getUserId();
											var userLogin = Auth.getUserName();
											sendingData = '<data NOM_RES="'+nomToLpu.CODE+'" SRV_DISTRICT_ID="'+nomToLpu.SRV_DISTRICT_ID+'" NOMLPU_TABLE_SAVE="'+nomToLpu.NOMLPU_TABLE_SAVE+'"/>';
											requestParams = { getSchema: false, descrId: 'GAZPROM_ADM_SEM.xml#WEB50_LPU_TO_M_NOMENCLATURES', toElements: false, descrType: nomToLpu.TYPE,
												data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
											//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
											currentTemplate = "gridAdmLpuSetNomenclaturesToLpu";
											//Устанавливаем курсор ожидания
											BlockingUtil.wait();
											//BlockingUtil.blockApplication();
											currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
										}
										else
										if (GridAdmWidget.processStatusForm)
											GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_105);
									},
									endProcess, cancelProcess, true);
							}
						});
						break;

					/* Задача валидации данных */
					case 'bEditControlApply':
						bEditControlApplyArray = dataObj;
						if(bEditControlApplyArray && bEditControlApplyArray.length == 0){
							App.confirmDialog(gis_gridadmwidget_110,null,{title:gis_gridadmwidget_111,width:310,dialogClass: 'noCloseButton'});
							return;
						}
						GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_108,bEditControlApplyArray,that,
							function processSingleItem(item) {
								if (item && item.ID !== undefined)
								{
									var userId = Auth.getUserId();
									sendingData = '<data USER_ID="'+userId+'" ID="'+item.ID+'"/>';
									requestParams = { getSchema: false,
										descrId: 'GAZPROM_ADM_SEM.xml#ADM_B_EDIT_TO_CONTROL_COMMIT',
										toElements: false,
										descrType: 'update',
										data: '<root>' + sendingData + '</root>' };
									currentTemplate = "bEditControlApply";
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
								}
								else
								if (GridAdmWidget.processStatusForm)
									GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_50);
							},
							endProcess, cancelProcess, true);
						break;
					case 'bEditControlRollback':
						bEditControlRollbackArray = dataObj;
						if(bEditControlRollbackArray && bEditControlRollbackArray.length == 0){
							App.confirmDialog(gis_gridadmwidget_110,null,{title:gis_gridadmwidget_111,width:310,dialogClass: 'noCloseButton'});
							return;
						}
						GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_109,bEditControlRollbackArray,that,
							function processSingleItem(item) {
								if (item && item.ID !== undefined)
								{
									var userId = Auth.getUserId();
									sendingData = '<data USER_ID="'+userId+'" ID="'+item.ID+'"/>';
									requestParams = { getSchema: false,
										descrId: 'GAZPROM_ADM_SEM.xml#ADM_B_EDIT_TO_CONTROL_ROLLBACK',
										toElements: false,
										descrType: 'update',
										data: '<root>' + sendingData + '</root>' };
									currentTemplate = "bEditControlRollback";
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									currentMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
								}
								else
								if (GridAdmWidget.processStatusForm)
									GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_50);
							},
							endProcess, cancelProcess, true);
						break;

				}
			}
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_56'});
	}
};

//Форма процесса групповой операции
GridAdmWidget.processStatusForm = null;

// Запрос получения данных геометрии по выбранными ID грида
GridAdmWidget.prototype.makeUTEReqParams = function makeLoadGeoDataReqParams(templateName, inputXml) {
	return {
		templateName: templateName,
		input: inputXml
	};
};
// Запрос получения данных геометрии по выбранными ID грида
GridAdmWidget.prototype.makeUTEServiceParams = function (path, data) {
	return {
		path: path,
		input: data
	};
};

/* Функции фильтрации */
//Слушатель события закрытия формы фильтра нижнего уровня
GridAdmWidget.prototype.onBottomFilterFormClose = function onBottomFilterFormClose(evt/*CloseEvent*/) {
	$("body").off(CloseEvent.CLOSE);
	if (evt && evt.eventData) {
		var selecting = evt.eventData.selecting;
		var centering = evt.eventData.centering;
		//Забираем фильтр
		var curFilter = evt.eventData.filter;
		//Сохраняем его в виджет грида и перезапршиваем грид
		var currentGrid = evt.eventData.currentGrid;
		var dataAdapter = $(currentGrid).jqxGrid('source');
		dataAdapter.currentGridDescr.currentFilter = curFilter;
		//Также сохраняем флаги выделения и центровки на карте
		dataAdapter.currentGridDescr.selecting = selecting;
		dataAdapter.currentGridDescr.centering = centering;
		var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
		if(gridWidget) gridWidget.modified = true;
		//Перезапрашиваем грид
		var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID+"_"+currentGrid.id);
		refreshGridEvt.gridId = currentGrid.id;
		refreshGridEvt.dispatch();
	}
};

/**
 * Сохранение измененных ячеек грида по клику на групповую кнопку
 * @param currentGrid
 * @param dataAdapter
 * @param syncMap  флаг, нужно ли синхронизировать карту по обновленным объектам(удалять старые с карты и перезапрашивать новые)
 */
GridAdmWidget.prototype.saveUpdatedCellDialog = function(currentGrid, dataAdapter, syncMap) {
	var that = this;
	if(dataAdapter && dataAdapter.currentGridDescr && dataAdapter.currentGridDescr.rows4Update) {
		var jqxGridId = currentGrid.id;
		var rows4UpdateObj = dataAdapter.currentGridDescr.rows4Update;
		var rows4UpdateIds = []; // массив всех идентификаторов на обновление
		var rows4Update = [];
		for(var row in rows4UpdateObj){
			rows4Update.push(rows4UpdateObj[row]);
			rows4UpdateIds.push(rows4UpdateObj[row].ID);
		}
		if(rows4Update.length === 0)
			return;
		delete dataAdapter.currentGridDescr.rows4Update;

		that.selectFullDataBeforeUpdateDB(dataAdapter, rows4Update, function(result){
			var rows4UpdateLength = rows4Update.length;
			rows4Update.forEach(function (it, index) {
				//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
				var itemFromDb = result[it.ID];
				var isLastRow = (rows4UpdateLength - 1) === index;
				if(itemFromDb){
					var extIt = $.extend(itemFromDb,it);
					that.updateCellDB(dataAdapter, extIt, jqxGridId, syncMap, isLastRow, rows4UpdateIds);
				}
			});
			/*var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID+"_"+jqxGridId);
			refreshGridEvt.gridId = jqxGridId;
			refreshGridEvt.dispatch();*/
		});
	}
}


GridAdmWidget.prototype.pasteFromExcelDialog = function(currentGrid, dataAdapter) {
	var that = this;
	var divv = '<div id="pasteFromExcelDialog">' +
		'<label style="color: #ffffff">' + gis_gridwidget_98 + '</label>'+
		'<textarea id="pasteFromExcelText" style="width:580px;margin: 1px;color: #005d98;height: 55px;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text"></textarea>' +
		'<div style="margin-top:10px; color: #ffffff">' + gis_gridwidget_99 + '</div>'+
		'<div style="margin-top:2px; color: #ffffff;" >' +
		'   <input type="checkbox" id="confirmPasteFromExcelCheckbox">' +
		'   <label style="color: #ffffff;" for="confirmPasteFromExcelCheckbox">' + gis_gridwidget_105 + '</label>' +
		'</div>' +
		'<div style="margin-top:10px; color: #ffffff">' + gis_gridwidget_99_1 + '</div>'+
		'</div>';
	$('body').append(divv);
	var dlg = $('#pasteFromExcelDialog');
	var bts = [
		{
			text: gis_gridwidget_92,
			click: function(){
				var pastedText =  $('#pasteFromExcelText').val();
				if(pastedText === ''){
					App.confirmDialog(gis_gridwidget_109, null, {title:gis_core_1});
					return;
				}
				if(dataAdapter && dataAdapter.currentGridDescr) {
					dataAdapter.currentGridDescr.pasteFromExcelData = pastedText;
					var checked = $('#confirmPasteFromExcelCheckbox').prop('checked');
					that.pasteCells(currentGrid, dataAdapter, checked)
				}
				$('#pasteFromExcelDialog').remove();
			}
		},
		{
			text: gis_gridwidget_93,
			click: function(){
				var pastedText =  $('#pasteFromExcelText').val();
				if(pastedText === ''){
					App.confirmDialog(gis_gridwidget_109, null, {title:gis_core_1});
					return;
				}
				else if(!dataAdapter.currentGridDescr.lastEditedCell){
					App.confirmDialog(gis_gridwidget_107, null, {title: gis_core_1});
					return ;
				}
				var pastedText =  $('#pasteFromExcelText').val();
				that.confirmUpdateFromExcel(currentGrid, dataAdapter, pastedText);
				$('#pasteFromExcelDialog').remove();
			}
		},
		{
			text: gis_core_8,
			click: function(){
				delete dataAdapter.currentGridDescr.lastEditedCell;
				$('#pasteFromExcelDialog').remove();
			}
		}];
	dlg.dialog({
		modal: true,
		title: gis_gridwidget_87,
		dialogClass: 'ui-dialog-confirm noCloseButton gsi-zindex__dialog',
		closeOnEscape: true,
		width: 595,
		height: 395,
		resizable: false,
		buttons : bts
	});
};



GridAdmWidget.prototype.confirmUpdateFromExcel = function(currentGrid, dataAdapter, text) {
	var that = this;
	var label = gis_gridwidget_101;
	if(dataAdapter && dataAdapter.currentGridDescr.lastEditedCell && dataAdapter.currentGridDescr.lastEditedCell.boundIndex !== undefined && dataAdapter.currentGridDescr.lastEditedCell.boundIndex !== null && dataAdapter.currentGridDescr.lastEditedCell.dataField){
		var columns = dataAdapter.currentGridDescr.gridColumns;
		label = label.replace('{ROW_NUM}', dataAdapter.currentGridDescr.lastEditedCell.rwn);
		columns.forEach(function(it){
			if(it.datafield === dataAdapter.currentGridDescr.lastEditedCell.dataField)
				label = label.replace('{COL_NAME}', (it.text)?it.text.replace(/\\n/g,' '):'');
		});
		dataAdapter.currentGridDescr.pasteFromExcelData = text;
		that.updateCells(currentGrid, dataAdapter);
	}
	else{
		App.confirmDialog(gis_gridwidget_107, null, {title: gis_core_1});
	}
};

/**
 * Вставка записей из Excel
 * @param currentGrid текущий грид
 * @param curDataAdapter текущий адаптер грида
 * @param isSystemInsert  true - вставка со служебными колонками. false - вставка, как есть, начиная с первой колонки
 */
GridAdmWidget.prototype.pasteCells = function (currentGrid, curDataAdapter, isSystemInsert, syncMap) {
	var that = this;
	try{
		if(currentGrid && curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData){
			var layerName = curDataAdapter.currentGridDescr.layerId;
			var jqxGridId = currentGrid.id;
			var currentGridDescr = curDataAdapter.currentGridDescr;
			var cols = currentGridDescr.gridColumns;
			var colNames = [];
			var colTypes = {};
			var synonyms = {};//массив синонимов колонок в гриде TODO заменить на получение из GridUtils

			cols.forEach(function (it, index) {
				if(it.datafield && !Number.isInteger(it.datafield) && !it.hidden && it.datafield !== 'RWN'){
					colNames.push(it.datafield);
					colTypes[it.datafield] = it.columntype;
				}
				if(it.datafieldsynonym)
					synonyms[it.datafield] = it.datafieldsynonym;
			});
			var rows = GridUtil.convertPlainExcelDataToTable(currentGridDescr.pasteFromExcelData);
			var rows4Insert = [];
			var rows4Update = [];
			var rows4UpdateIds = [];
			var isInsert = true;// если в данных присутствует колонка ID, то будет происзведено обновление вместо вставки

			var buttons = [
				{
					text: gis_core_4, click: function () {
						App.destroyDialog(undefined, this);

						GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_130, (isInsert)?rows4Insert.reverse():rows4Update.reverse(),that,that.insertObject,
							function(){
								//записи успешно добавлены
								GridWidget.refreshGridAfterInsert(jqxGridId, layerName, syncMap);
							}, null, true);
					}
				},
				{
					text: gis_core_5, click: function () {
						App.destroyDialog(undefined, this);
					}
				}
			];

			if(isSystemInsert){
				if(rows.length > 0){
					var columns = rows[0];// в служебном режиме 1-я строка - строка с названиями колонок
					//TODO проверить все ли колонки описаны в гриде. Если нет - сигнализировать
					//если у колонки есть синоним, то заменяем
					rows.forEach(function(row, i){
						if(i !== 0){
							var data = {};
							//имена колонок приводим в upperCase, чтобы совпадали с названиями переменных
							row.forEach(function(val, valIndex){
								var colName = columns[valIndex].toUpperCase();
								var columnType = colTypes[colName];
								var preparedVal = GridUtil.prepareValueByDataType2(val, columnType, colName);
								if(preparedVal !== undefined){
									if(synonyms[colName])
										data[synonyms[colName]] = preparedVal;
									else
										data[colName] = preparedVal;// устанавливаем в колонку соответствующее значение. индексы совпадают
								}

							})
							if(data.ID){// если есть в данных ID, то обновление данных
								isInsert = false;
								rows4Update.push({rowData: data, classId:layerName, objectId:data.ID,  dataAdapter: curDataAdapter, colTypes: colTypes});
								rows4UpdateIds.push(data);
							}
							else
								rows4Insert.push({rowData: data, classId:layerName, objectId:'',  dataAdapter: curDataAdapter, colTypes: colTypes});
						}
					});
					if(rows4Update.length > 0){
						that.selectFullDataBeforeUpdateDB(curDataAdapter, rows4UpdateIds, function(result){
							var rows4UpdateLength = rows4Update.length;
							rows4Update.forEach(function (rowData, index) {
								var it = rowData.rowData;
								if(!it) return;
								//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
								var itemFromDb = result[it.ID];
								var isLastRow = (rows4UpdateLength - 1) === index;
								if(itemFromDb){
									rowData.rowData = $.extend(itemFromDb,it);
								}
							});
							App.confirmDialog(gis_gridwidget_111_1.replace('{ROWS_COUNT}', rows4Update.length), buttons, {title:gis_core_1, html:true});
						});
						return;
					}

				}
			}
			else{
				try{
					rows.forEach(function (row, index) {
						var data = {};
						var valueCounter = 0;
						for(var i = 0; i < colNames.length; i++){
							var colName = colNames[i].toUpperCase();
							var columnType = colTypes[colName];
							if(valueCounter >= row.length ) break;
							var val = row[valueCounter];
							var preparedVal = GridUtil.prepareValueByDataType2(val, columnType, colName);
							if(preparedVal !== undefined)
								data[colName] = preparedVal;
							valueCounter++;
						}
						rows4Insert.push({rowData: data, classId:layerName, objectId:data.ID,  dataAdapter: curDataAdapter, colTypes: colTypes});
					});
				}
				catch (ex){
					throw new Error(gis_gridwidget_88);
				}
			}

			if(isInsert)
				App.confirmDialog(gis_gridwidget_111.replace('{ROWS_COUNT}', rows4Insert.length), buttons, {title:gis_core_1, html:true});
			else
				App.confirmDialog(gis_gridwidget_111_1.replace('{ROWS_COUNT}', rows4Update.length), buttons, {title:gis_core_1, html:true});
		}
	}
	catch(ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_60'});
	}
	finally {
		curDataAdapter.currentGridDescr.pasteFromExcelData = undefined;
	}
}

/**
 * Обновление ячеек грида данными, скопированными из Excel
 * @param currentGrid текущий грид
 * @param curDataAdapter текущий адаптер грида
 */
GridAdmWidget.prototype.updateCells = function (currentGrid, curDataAdapter, syncMap) {
	var that = this;
	try{
		if(currentGrid && curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData && curDataAdapter.currentGridDescr.lastEditedCell){
			var jqxGridId = currentGrid.id;
			var currentGridDescr = curDataAdapter.currentGridDescr;
			var lastEditedCell = currentGridDescr.lastEditedCell;
			var cols = currentGridDescr.gridColumns;
			var colNames = [];
			var colTypes = {};
			var confirmLabel = gis_gridwidget_101;
			//lastEditedCell = { rwn:rwn, boundIndex: rowBoundIndex, dataField: dataField, event: event} ;
			var dataField = lastEditedCell.dataField;
			var rowBoundIndex = lastEditedCell.boundIndex;
			confirmLabel = confirmLabel.replace('{ROW_NUM}', lastEditedCell.rwn);
			cols.forEach(function (it, index) {
				if(it.datafield && !Number.isInteger(it.datafield) && !it.hidden && it.datafield !== 'RWN'){
					colNames.push(it.datafield);
					colTypes[it.datafield] = it.columntype;
					if(it.datafield === currentGridDescr.lastEditedCell.dataField)
						confirmLabel = confirmLabel.replace('{COL_NAME}', (it.text)?it.text.replace(/\\n/g,' '):'');
				}
			});
			//ищем индекс колонки, начиная с которой пойдет заполнение
			var startIndex = colNames.indexOf(dataField);
			if(startIndex !== -1){
				var rows = GridUtil.convertPlainExcelDataToTable(currentGridDescr.pasteFromExcelData);
				//получаем элементы, которые будут обновляться
				var rows4Update = [];
				var rows4UpdateIds = []; // массив всех идентификаторов на обновление
				rows.forEach(function (row, index) {
					var valueCounter = 0;
					var rowBoundElement = $(currentGrid).jqxGrid('getrowdata', rowBoundIndex);
					var data = (rowBoundElement.ID)?GridUtil.getFullRowDataById(currentGrid, rowBoundElement):rowBoundElement;
					if(data){
						for(var i = startIndex; i < colNames.length; i++){
							var colName = colNames[i];
							//добавляем в значение колонки по очереди каждый элемент вставляемой строки
							if(valueCounter >= row.length ) break;
							data[colName] = row[valueCounter++];
						}
						rows4Update.push(data);
						rows4UpdateIds.push(data.ID);
					}
					rowBoundIndex++;
				});

				var buttons = [
					{
						text: gis_core_4, click: function () {
							App.destroyDialog(undefined, this);
							that.selectFullDataBeforeUpdateDB(curDataAdapter, rows4Update, function(result){
								var rows4UpdateLength = rows4Update.length;
								rows4Update.forEach(function (it, index) {
									//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
									var itemFromDb = result[it.ID];
									var isLastRow = (rows4UpdateLength - 1) === index;
									if(itemFromDb){
										var extIt = $.extend(itemFromDb,it);
										that.updateCellDB(curDataAdapter, extIt, syncMap, jqxGridId, isLastRow, rows4UpdateIds);
									}
								});
								//TODO добавить счетчик
								/*var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID+"_"+jqxGridId);
								refreshGridEvt.gridId = jqxGridId;
								refreshGridEvt.dispatch();*/
							});
						}
					},
					{
						text: gis_core_5, click: function () {
							App.destroyDialog(undefined, this);
						}
					}
				];

				confirmLabel = confirmLabel.replace('{ROWS_COUNT}', rows4Update.length).replace('{ALL_ROWS_COUNT}', rows.length);
				App.confirmDialog(confirmLabel, buttons, {title:gis_core_1, html:true})
				return;
			}
			throw new Error(gis_gridwidget_88)
		}
	}
	catch(ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_60'});
	}
	finally {
		delete curDataAdapter.currentGridDescr.lastEditedCell;
		curDataAdapter.currentGridDescr.pasteFromExcelData = undefined;
	}
}


GridAdmWidget.prototype.updateCellDB = function(dataAdapter, data, syncMap, jqxGridId, isLastRow, rows4UpdateIds){
	var that = this;
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = (!data.ID) ? 'insert' : 'update';
		//добавляем атрибут SYS_OBJ_ID, т.к. update в панелях свойств использует его
		if(descrType === 'update')
			data.SYS_OBJ_ID = data.ID;
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(data), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					var title = GridUtil.getDetailDbError(er);
					App.errorReport(title, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_56'
					});
				}
			}
			if(isLastRow){
				if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, rows4UpdateIds, true)
				}
				GridWidget.refreshGrid(jqxGridId)
			}
		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				var title = GridUtil.getDetailDbError(er);
				App.errorReport(title, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_57'
				});
			}
			if(isLastRow){
				if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, rows4UpdateIds, true)
				}
				GridWidget.refreshGrid(jqxGridId)
			}
		});
	}
}



/**
 * Функция получает полную детализацию данных, которые собираемся редактировать
 * @param dataAdapter
 * @param {Array}  datas
 * @param {function} successCallback
 */
GridAdmWidget.prototype.selectFullDataBeforeUpdateDB = function(dataAdapter, datas, successCallback){
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = 'select';
		var filterIds = [];
		datas.forEach(function (it) {
			filterIds.push(it.ID);
		});
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData({FILTER:'ID in ('+filterIds.join()+')'}), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					App.errorReport(gis_gridwidget_90, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_58'
					});
				}
				else{
					//парсим данные в объект из ключей идентификаторов и отправляем назад в callabck
					var resDatas = {};
					var xmlData = $.parseXML(resultXML);
					//Сохраняем для переиспользования
					$(xmlData).find("data").each(function () {
						var resData = {};
						for (var curAttrInd = 0; curAttrInd < this.attributes.length; curAttrInd++) {
							resData[this.attributes[curAttrInd].name] = this.attributes[curAttrInd].value;
						}
						resDatas[resData.ID] = resData;
					});
					if(successCallback)
						successCallback(resDatas);
				}
			}
		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				App.errorReport(gis_gridwidget_90, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_59'
				});
			}
		},4);
	}
}


GridAdmWidget.prototype.insertStoILiDataAdvObject = function (insertingObject) {
	//Запускаем удаление
	DBUtil.insertStoIliDataAdvToDB(insertingObject.rowData, insertingObject.dataAdapter, insertingObject.provider);
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_INSERTED, this.onObjectInsertFault);
};

//Функция обработки ошибки при вставке записи
GridAdmWidget.prototype.onObjectInsertFault = function (evt) {
	$("body").off(OperationEvent.OBJECT_INSERTED);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};



/**
 * Функция обновления содержимого грида по входящему новому фильтру. Т.к. название слоя, отвечающего за грид совпадает,
 * то для исключения избыточных запросов на загрузку описания грида xml, справочников   перезапрашиваем только данные на основе нового фильтра
 * @param filter
 */
GridAdmWidget.prototype.updateGridContent = function(filter, forceTopFilter, forceRefresh){
	this.filter = filter;
	this.modified = false;
	var gridElem = $("#" + this.id);
	//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
	if (gridElem.length === 0 && !this.dataAdapter)
		return;


	//var dataAdapter = $(gridElem).jqxGrid('source');
	var gridDescription = this.dataAdapter.currentGridDescr;
	/*gridDescription.source = dataAdapter;
	gridElem.jqxGrid(gridDescription);*/

	var curFilter = filter;
	var topFilter = (forceTopFilter !== true) ? gridDescription.topFilter : [];

	var fArr = [];
	//если был верхний фильтр, то параметры заменяем только те, что совпадают по имени
	if(topFilter && topFilter.length > 0){
		topFilter.forEach(function(item){
			var finded = false;
			for(var obj in filter){
				if(item.name === obj){
					fArr.push({name:obj, value:filter[obj]});
					finded = true;
					break;
				}
			}
			if(!finded) {
				fArr.push(item);
			}
		});
	}
	else{
		for(var obj in filter){
			fArr.push({name:obj, value:filter[obj]});
		}
	}
	fArr = GridWidget.removeDuplicateFilterData(fArr);
	this.filters = fArr;

	var gridId = 'jqxgrid'+this.id;
	//Сохраняем его в виджет грида и перезапршиваем грид
	gridDescription.topFilter = fArr;//$.extend( gridDescription.topFilter, filter ); //верхний фильтр
	gridDescription.currentFilter = []; // нижний фильтр
	gridDescription.roughFilter = []; //средний фильтр
	//обнуляем сортировку
	gridDescription.currentSort = [];
	//обнуляем закешированные данные
	this.cachedRecords = [];

	//обнуляем текущее состояние(если скрывали колонки)
	this.currentState = null;
	//обнулуляем нижний фильтр
	try{
		$('#'+gridId+'_bottomFilter').remove(); //jqxgridid8254_GRID_bottomFilter
	}
	catch(ex){ }
	//Перезапрашиваем грид
	GridWidget.refreshGrid(gridId, forceRefresh === true);//jqxgridid4438_GRID
};

/**
 * Функция получает полную детализацию данных, которые собираемся редактировать
 * @param dataAdapter
 * @param {Array}  datas
 * @param {function} successCallback
 */
GridAdmWidget.prototype.selectFullDataBeforeUpdateDB = function(dataAdapter, datas, successCallback){
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = 'select';
		var filterIds = [];
		datas.forEach(function (it) {
			filterIds.push(it.ID);
		});
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData({FILTER:'ID in ('+filterIds.join()+')'}), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					App.errorReport(gis_gridwidget_90, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_58'
					});
				}
				else{
					//парсим данные в объект из ключей идентификаторов и отправляем назад в callabck
					var resDatas = {};
					var xmlData = $.parseXML(resultXML);
					//Сохраняем для переиспользования
					$(xmlData).find("data").each(function () {
						var resData = {};
						for (var curAttrInd = 0; curAttrInd < this.attributes.length; curAttrInd++) {
							resData[this.attributes[curAttrInd].name] = this.attributes[curAttrInd].value;
						}
						resDatas[resData.ID] = resData;
					});
					if(successCallback)
						successCallback(resDatas);
				}
			}
		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				App.errorReport(gis_gridwidget_90, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_59'
				});
			}
		},4);
	}
}

GridAdmWidget.prototype.insertObject = function (insertingObject) {
	//Запускаем удаление
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_INSERTED, this.onObjectInsertFault);
	DBUtil.insertObjectToDB(insertingObject.rowData, insertingObject.dataAdapter, insertingObject.colTypes);
};

//Функция обработки ошибки при вставке записи
GridAdmWidget.prototype.onObjectInsertFault = function (evt) {
	$("body").off(OperationEvent.OBJECT_INSERTED);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};

/**
 * Функция обновления грида на обснове изменных колонок
 * @param currentGrid
 * @param columns
 */
GridAdmWidget.prototype.updateDataWithColumns = function(currentGrid, columns){
	var gridWidget = App && App.GridManager && App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''))//jqxgridid9860_GRID
	var jqxGridId = gridWidget.id;
	var dataArr = gridWidget.cachedRecords;
	var dataAdapter = gridWidget.dataAdapter;
	//var columns = gridWidget.columns;
	gridWidget.columns = columns;

	//сначала фильтруем начальные данные по видимым колонкам
	var hiddenColumns = [];
	var visibleColumns = [];

	for(var idx = 0; idx < columns.length; idx++){
		if(columns[idx].hidden === true/* && columns[idx].datafield !== 'ID'*/)
			hiddenColumns.push(columns[idx].datafield);
		else {
			visibleColumns.push(columns[idx].datafield);
		}
	}
	//обновляем свойства hidden у колонок в currentState
	//TODO вынести в общую функцию
	if(gridWidget.currentState && gridWidget.currentState.columns){
		for(var hc in gridWidget.currentState.columns){
			if(hiddenColumns.indexOf(hc) !== -1){
				gridWidget.currentState.columns[hc].hidden = true;
			}
			if(visibleColumns.indexOf(hc) !== -1){
				gridWidget.currentState.columns[hc].hidden = false;
			}
		}
	}
	gridWidget.hiddenColumns = hiddenColumns;
	dataArr = GridUtil.filterDataFromJson(dataArr, hiddenColumns);
	var visibleDataArr = dataArr;
	if (gridWidget.jqxDataAdapterCallback !== undefined) {
		var resultObj = {
			records: visibleDataArr,
			totalrecords: dataAdapter.totalrecords
		};

		//dataAdapter.localdata = visibleDataArr;
		$(currentGrid).jqxGrid({ columns: columns });
		//Добавляем через имеющуюся функцию обратного вызова плагина jqxDataAdapter
		gridWidget.jqxDataAdapterCallback(resultObj);
		$(currentGrid).jqxGrid('render');
	}
	else {
		/*gridSource.localdata = gridData;
		//Обновляем записи в гриде
		$(currentGrid).jqxGrid({ source: gridSource });*/
	}
}
GridAdmWidget.prototype.setLayerId = function(layerId) {
	var lId = layerId;
	if(layerId && layerId.indexOf('#') !== -1){
		this.layerId = layerId.split('#')[1];
		this.fullLayerId = layerId.replace('#', '*');
		lId = this.layerId;
	}
	return lId;
}
/*
 * Наследие старой версии
 * 
 * Много разных функций в глобальной области видимости,
 * в основном связанные с взаимодействием между несколькими окнами браузера
 */

//==============================================================================

// Globals
var requiredMajorVersion = 10; // Major version of Flash required
var requiredMinorVersion = 1;  // Minor version of Flash required
var requiredRevision = 0;      // Minor version of Flash required

var arrPage = {};
var arrTemplates = {};

//свойства страницы
var task = "";
var idWnd = "";

//заполнил массив настроек дочерних окон из файла windowTemplates.xml
function loadWindowTemplates(file) {
    $.ajax({
        type: "GET",
        timeout: App.clientRequestTimeout,
        url: file, // путь к файлу, который будем читать
        dataType: "xml", // тип данных, с которыми работаем
        success: function (xml_data) {
            var data = $(xml_data).find('data');
            //цикл по ids
            $(data).each(function()
            {
                var id = $(this).attr('id');
                arrTemplates[id] = $(data).attr('template');
            });
        }
    });
};

function getSessionParams() {
    //return [{"sessionParam1":"value"}];
    return [];
};
function getURL() {
    return document.location.toString().replace(/\?.*/, '');
};

//получает параметры авторизации, пришедшие из флешки, чтобы с ними формировать  урл
function getAutorization(url) {
    var u =  url;
    return u.substring(u.indexOf('#')+1,u.length);
};

function openNewWindow(url, windowTemplate, taskName, params, callback, minimize) {
    var session_params = getSessionParams(); //пустой массив с параметрами сессии
    params = params.concat(session_params);
    // получаем параметры авторизации, если они есть из урл. после "#"
    var authParams = getAutorization(url);

    url = getURL(); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (url.lastIndexOf("#") != -1) {
        url = url.substr(0, url.lastIndexOf("#"));
    }

    //Добавляем полученные параметры в URL
    url += "?task=" + taskName;

    for (var i = 0; i < params.length; i++) {
        url += "&";
        url += params[i]["name"] + "=" + params[i]["value"];
    }
    //генерируем по новому идендификатор, т.к. прошлый вариант с "?" кидал ошибку при открытии окна
    var id = "id" + Math.floor(Math.random() * (10000)) + "_" + taskName;
    var idStr = id.split("_")[0];

    var idWindow;
    try {
        //Открываем на текущей странице браузера, если это грид, который не требует открытия в новом окне
        //добавляем проверку. Если браузер не 8, то имеем возможность работать с многовкладочным гридом
        if (isCanvasSupported() && taskName=='GRID') {
            var gridPopup = new GridWindow();
            //Полученный iframe будем сохранять как окно в общем списке окон
            try{
                if(callback)//прокидываем назад вновь созданный идентификатор грида
                    callback(id);
            }
            catch(ex){ }
            idWindow = gridPopup.build(url+'#'+authParams, id, params, arrTemplates[windowTemplate], minimize);
        }
        else
            idWindow = window.open(url+'#'+authParams, id, arrTemplates[windowTemplate]);
    }
    catch (e) {
        return null;
    }

    try {
        idWindow.task = taskName;
        //А вот id меняем только для окон, для iframe id менять нельзя!
        /*if (idWindow.tagName.toLowerCase() != 'iframe') {
         idWindow.id = idStr;
         } else { //для iframe мы должны вернуть в качестве idStr id фрейма (он генерируется при создании фрейма)
         idStr = idWindow.id;
         }*/
        //Выставил для всех окон id, чтобы корректно работало получение данных для фильтра (при запросе из дочерних окон)
        idWindow.id = idStr;
        arrPage[idStr] = {
            "childWindow": idWindow
        };
    }
    catch (e) {
        return idStr;
    }

    return idStr;
};

function openNewWindowExt(url, windowTemplate, taskName, params, callback) {
    var session_params = getSessionParams(); //пустой массив с параметрами сессии
    params = params.concat(session_params);
    // получаем параметры авторизации, если они есть из урл. после "#"
    var authParams = getAutorization(url);

    url = getURL(); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (url.lastIndexOf("#") != -1) {
        url = url.substr(0, url.lastIndexOf("#"));
    }

    //Добавляем полученные параметры в URL
    url += "?task=" + taskName;

    for (var i = 0; i < params.length; i++) {
        url += "&";
        url += params[i]["name"] + "=" + params[i]["value"];
    }

    var correctW = screen.width;
    var correctH = screen.height;
    correctH -=200;//смещаем чуть ниже
    correctW -= 50;
    var x = 20;
    var y = 80;
    //генерируем по новому идендификатор, т.к. прошлый вариант с "?" кидал ошибку при открытии окна
    var id = "id" + Math.floor(Math.random() * (10000)) + "_" + taskName;
    var idStr = id.split("_")[0];

    var idWindow;
    try {
        //Открываем на текущей странице браузера, если это грид, который не требует открытия в новом окне
        //добавляем проверку. Если браузер не 8, то имеем возможность работать с многовкладочным гридом
        if (isCanvasSupported() && taskName=='GRID') {
            var gridPopup = new GridWindow();
            //Полученный iframe будем сохранять как окно в общем списке окон
            try{
                if(callback)//прокидываем назад вновь созданный идентификатор грида
                    callback(id);
            }
            catch(ex){ }
            idWindow = gridPopup.build(url+'#'+authParams, id, params, arrTemplates[windowTemplate]);
        }
        else
            window.open(url+'#'+authParams, 'EXTRA__' +App.generateUUID(), 'height='+correctH+',width='+correctW+',menubar=no,location=no,directories=no,status=no,resizable=yes,scrollbars=yes,left='+x+',top='+y+'');
            //idWindow = window.open(url+'#'+authParams, id, arrTemplates[windowTemplate]);
    }
    catch (e) {
        return null;
    }

    try {
        idWindow.task = taskName;
        idWindow.id = idStr;
        arrPage[idStr] = {
            "childWindow": idWindow
        };
    }
    catch (e) {
        return idStr;
    }

    return idStr;
};

function getOpener() {
    //Если у окна текущая задача - грид, родителем для iframe-окна будет parent, а opener==undefined
    if (window.opener==undefined || window.opener==null) {
        return window.parent;
    }
    //Для открытых окон возвращаем opener
    return window.opener;
};

function callFunction(windowId, funcName, params) {
    var wnd = getOpener();

    //добавляем id окна, в который opener должен вернуть данные
    if (wnd == "") {
        return -1;
    }
    if (typeof wnd == "string") {
        return wnd;
    }
    if (!wnd) {
        return -1; //окно еще не создавалось
    }
    if (wnd.closed) {
        return -1; //закрыто
    }

    try {
        //так функции вызываются
        //fix
        if(funcName === 'enableLayer' || funcName === 'disableLayer' || funcName === 'updateCacheLayer' ){
            ExternalInteraction.callFunction(windowId, funcName, params);
            return 1;
        }else{
            var fApp = getCurrentFlexApp(wnd,"Client_Main");
            if (fApp != null) {
                fApp[funcName](params);
            }
            wnd.focus();
        }

    }
    catch (e) {
        return 0;
    }

    return 1;
};

function callbackFunction(windowId, funcName, params) {
    var wnd;
    //Добавляем проверку наличия windowId в объекте arrPage - если его нет, значит функцию пробуем вызвать в текущем окне
    var inCurrentWindow = arrPage && arrPage.hasOwnProperty(windowId) ? false : true;
    if(windowId!=='' && windowId!=null && windowId!=undefined && !inCurrentWindow) {
        wnd = arrPage[windowId]["childWindow"]; //получает связанную страницу по id
    }
    else {
        wnd = getOpener();
    }

    //добавляем id окна, в который opener должен вернуть данные
    if (wnd == "") {
        return -1;
    }
    if (typeof wnd == "string") {
        return wnd;
    }

    if (!wnd) {
        return -1; //окно еще не создавалось
    }
    if (wnd.closed)	{
        return -1; //закрыто
    }

    try {
        //Поскольку имена функций вызова и возврата значений могут быть одинаковыми, узнаем что именно нужно делать по содержимому params
        switch (funcName) {
            case 'callbackFilter':
                /*Вызов получения фильтра из грида и возвращение результата с фильтром из карты имеют различия только внутри массива params
                 Если внутри массива единственный элемент и этот элемент - объект {name: 'layer', value: 'PODS_ILI_DATA'} - это вызов из грида
                 Если возвращается объект {name:'filter', value:'LPU_ACCESS_FILTER:13006,13009,13011,13004,13003,13000,13008,13013,13002,13005,13001,13007,0|ILI_DATA_FILTER:130021,130022|OLD_LPU_ACCESS_FILTER:13006,13009,13011,13004,13003,13000,13008,13013,13002,13005,13001,13007,0'}
                 это ответ из карты
                 */
                if (params && params.length > 0) {
                    var firstParam = params[0];
                    //Если пришел результат от флешовой карты - вызываем последнюю сохраненную в App.callbackFilter функцию
                    if (firstParam.hasOwnProperty('name') && firstParam['name']=='filter') {

                        ExternalInteraction.callbackFilter(params);
                        return 1;
                    }
                }
                //Иначе нужно перейти далее к выполнению вызова функции во флеше
                break;
            default:
                break;
        }
        var filter = $('#treeDiv').myCategories('callbackFilter',{params:params});
        // если нет рубрикатора, либо в рубрикаторе нет фильтров, то всегда используем предзагруженный фильтр по ЛПУ
        if (!filter) filter = {
            params: [{
                name: 'filter', value: ''
            }]
        };

        if(filter.params && filter.params.length === 1 && filter.params[0].name === 'filter' && filter.params[0].value === ''){
            //добавляем фильтр по ЛПУ
            /*for(var it in WidgetMap.currentTopFilter){
                if(WidgetMap.currentTopFilter[it].name === 'LPU_ACCESS_FILTER')
                    filter.params[0].value = WidgetMap.currentTopFilter[it].name+':'+WidgetMap.currentTopFilter[it].value;
            }*/
            //добавляем все фильтры верхнего уровня
            var topFilterArr = [];
            for(var it in WidgetMap.currentTopFilter){
                topFilterArr.push(WidgetMap.currentTopFilter[it].name+':'+WidgetMap.currentTopFilter[it].value);
            }
            if(topFilterArr && topFilterArr.length)
            filter.params[0].value = topFilterArr.join('|');
        }
        //добавляем roughFilter в params, если он присутствует
        if(goog.isDef(WidgetMap.currentRoughFilter) && WidgetMap.currentRoughFilter.length > 0){
            var layerName = '';
            if(params && params.length > 0){
                for(var i=0; i < params.length; i++){
                    if(params[i].name === 'layer'){// если нашли в параметрах слой, к которому фильтр относится, то дальше в ищем его в фильтре
                        layerName = params[i].value;
                        break;
                    }
                }
            }
            if(layerName !== ''){
                if(WidgetMap.currentRoughFilter && WidgetMap.currentRoughFilter.length > 0) {
                    if(!WidgetMap.currentRoughFilter[0].layerName){
                        filter.params.push({name:'roughFilter',value:WidgetMap.currentRoughFilter[0].name+':'+WidgetMap.currentRoughFilter[0].value});
                    }
                    else if(WidgetMap.currentRoughFilter[0].layerName === layerName){
                            filter.params.push({name:'roughFilter',value:WidgetMap.currentRoughFilter[0].name+':'+WidgetMap.currentRoughFilter[0].value});
                    }
                }
                ExternalInteraction.callbackFilter(filter.params);
                return 1;
            }
            filter.params.push({name:'roughFilter',value:WidgetMap.currentRoughFilter[0].name+':'+WidgetMap.currentRoughFilter[0].value});
        }
        ExternalInteraction.callbackFilter(filter.params);
        return 1;
    }
    catch (e) {
        return 0;
    }

    return 1;
};

function getCurrentFlexApp(wnd,appName) {
//добавил проверки на то, что окно является фреймом, чтобы иметь возможность достучаться до его контента и получить флешки
    if (navigator.appName.indexOf ("Microsoft") != -1) {
        if(wnd.toString().indexOf('HTMLIFrameElement')!=-1)
        {
            return wnd.contentWindow[appName];
        }
        return wnd.window[appName];
    }
    else {
        if(wnd.toString().indexOf('HTMLIFrameElement')!=-1)
        {
            return wnd.contentDocument[appName];
        }
        return wnd.document[appName];
    }
};

function fillWndProperties() {
    var splittedArr;
    //Если у окна текущая задача - грид, родителем для iframe-окна будет parent, а opener==undefined
    if (window.opener==undefined || window.opener==null) {
        splittedArr = window.name.split("_");
        //Подстрока до первого символа "_" это id окна
        idWnd = splittedArr.shift();
        //Все, что следует после первого символа "_" это название задачи (может содержать символы "_"!)
        task = splittedArr.join("_");
    }
    else
    {
        if (window.name.split("_")[0] == "") {
            idWnd = "id" + Math.floor(Math.random() * (10000));
        }
        else {
            splittedArr = window.name.split("_");
            //Подстрока до первого символа "_" это id окна
            idWnd = splittedArr.shift();
            //Все, что следует после первого символа "_" это название задачи (может содержать символы "_"!)
            task = splittedArr.join("_");
        }
    }
};

// снять этот комментарий в следующем выпуске
$(document).ready(function () {
    // метод, который заполняет id окна и task окна
    fillWndProperties();
    loadWindowTemplates("windowTemplates.xml");
});


//==============================================================================
//Оригинальный заголовок формы, нужен для исправления ошибки IE 6+, при которой title для окна необходимо устанавливать с задержкой, чтобы IE не подставлял в title текущий URL
var originalTitle = document.title;

function getFlexApp(appName) {
    if (navigator.appName.indexOf ("Microsoft") != -1) {
        return window[appName];
    }
    else {
        return document[appName];
    }
};
// Код для исправления ошибки IE 6+, при которой title для окна необходимо устанавливать с задержкой, чтобы IE не подставлял в title текущий URL
function initListeners() {
    var titleEl = document.getElementsByTagName("title")[0];

    if (titleEl && titleEl.addEventListener) {
        titleEl.addEventListener("DOMSubtreeModified", function(evt) {
            var t = evt.target;
            if (t === titleEl || (t.parentNode && t.parentNode === titleEl)) {
                if(document.title !== originalTitle)
                    setTimeout(function () {
                        document.title = originalTitle;
                    }, 1);
            }
        }, false);
    } else {
        document.attachEvent('onpropertychange', function (evt) {
            if (evt.propertyName === 'title' && document.title !== originalTitle) {
                setTimeout(function () {
                    document.title = originalTitle;
                }, 1);
            }
        });
    }
};

initListeners();

function onLogin() {
    var app = getFlexApp("Client_Main");
    if (app != null) {
        try	{
            app.login(loginI.value, passI.value);
        }
        catch (e) {
            setTimeout('onLogin()',5000);
        }
    }
    else {
        setTimeout('onLogin()',5000);
    }
};

/**
 * Открытие карты в iframe
 * @param taskName
 * @param params
 * @param guid
 */
function openMapWithinIframe(taskName, params, guid) {
    guid = guid || '';
    var authStr = Auth.getAuthStr();
    if (authStr === undefined || authStr === null) authStr = "";
    var currentUrl = getURL() + "#" + authStr;
    // получаем параметры авторизации, если они есть из урл. после "#"
    var authParams = getAutorization(currentUrl);
    var url = currentUrl.replace(/\?.*/, ''); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (url.lastIndexOf("#") != -1) {
        url = url.substr(0, url.lastIndexOf("#"));
    }
    //Добавляем полученные параметры в URL
    url += "?task=" + taskName;
    for (var i = 0; i < params.length; i++) {
        url += "&";
        url += params[i]["name"] + "=" + params[i]["value"];
    }
    
    var draftDashboard = App.dashboardManager.getCurrentDashboard();
    var width = 474;
    var height = 360;
    if(WidgetMap && WidgetMap.config && WidgetMap.config.map && WidgetMap.config.map.position){
        var position = getPositionFromConfig(WidgetMap.config.map.position);
        width = position.width;
        height = position.height;
    }
    var dialogId = 'mapWidgetInlineFrameDialog' + guid;
    url += "&dialogId=" + dialogId;
    var siteUrl = url+'#'+authParams;
    var divv = '<div id="' + dialogId +'"><iframe id="mapWidgetInlineFrame"' +
        '    title="' + gis_head55_2 + '"' +
        '    width="100%"' +
        '    height="100%"' +
        '    src="' + siteUrl + '">' +
        '</iframe></div>';

    $('body').append(divv);
    var dlg = $('#'+dialogId);
    dlg.dialog({
        modal: false,
        title: gis_head55_2,
        dialogClass: 'gsi-zindex__map',
        closeOnEscape: false,
        width: width,
        height: height,
        appendTo: '.taskContent',
        close: function(){
            draftDashboard.removeMap(dialogId);
            App.destroyDialog(null, dlg);
        },
        resizable: true,
        buttons : [],
    }).dialogExtend({
        "maximizable" : true,
        "minimizable" : true,
        "minimizeLocation" : "right",
        "icons" : {
            "close" : "ui-icon-gisCloseButton",
            "maximize" : "ui-icon-gisMaximizeButton",
            "minimize" : "ui-icon-gisMinimizeButton",
            "collapse" : "ui-icon-triangle-1-s",
            "restore" : "ui-icon-gisRestoreButton"
        },
    });

    var mapObj = {
        url: url.replace(window.location.origin, ''),
        id: dialogId,
        position: {
            left: 0,
            top: 0,
            width: width + 'px',
            height: height + 'px',
        }
    }
    draftDashboard.addMap(mapObj);

}


function buildMapWithinIframe(config) {
    var guid = config.id;
    var authStr = Auth.getAuthStr();
    if (authStr === undefined || authStr === null) authStr = "";
    var draftDashboard = App.dashboardManager.getCurrentDashboard();
    var position = getPositionFromConfig(config.position);
    var width = position.width;
    var height = position.height;
    var siteUrl = config.url+'#'+authStr;
    var dialogId = 'mapWidgetInlineFrameDialog' + guid;
    var divv = '<div id="' + dialogId +'"><iframe id="mapWidgetInlineFrame"' +
        '    title="' + gis_head55_2 + '"' +
        '    width="100%"' +
        '    height="100%"' +
        '    src="' + siteUrl + '">' +
        '</iframe></div>';

    $('body').append(divv);
    var dlg = $('#'+dialogId);
    dlg.dialog({
        modal: false,
        title: gis_head55_2,
        dialogClass: 'gsi-zindex__map',
        closeOnEscape: false,
        width: width,
        height: height,
        position: [position.left, position.top],
        appendTo: '.taskContent',
        close: function(){
            draftDashboard.removeMap(dialogId);
            App.destroyDialog(null, dlg);
        },
        resizable: true,
        buttons : [],

    }).dialogExtend({
        "maximizable" : true,
        "minimizable" : true,
        "minimizeLocation" : "right",
        "icons" : {
            "close" : "ui-icon-gisCloseButton",
            "maximize" : "ui-icon-gisMaximizeButton",
            "minimize" : "ui-icon-gisMinimizeButton",
            "collapse" : "ui-icon-triangle-1-s",
            "restore" : "ui-icon-gisRestoreButton"
        },
    });
    var mapObj = {
        url: siteUrl.replace(window.location.origin, ''),
        id: dialogId,
        position: position,
    }
    draftDashboard.addMap(mapObj);

}

/**
 * Открытие карты в iframe
 * @param url
 * @param config
 */
function openMapWithinIframeByUrl(url, config) {
    var left = 0, top = 0;
    var width = 474, height = 360;
    var pos = {my: "left top", at: "left top", of: 'body', collision: 'none'};
    var isDashboard = false;
    var closeOnEscape = false, dialogClass = '';
    var resizable = true, draggable = true;
    if(config){
        var position = getPositionFromConfig(config, true);
        width = position.width;
        height = position.height;
        left = position.left;
        top = position.top;
        //pos = {my: "left+" + position.left + " top+" + position.top, at: "left top", of: 'body', collision: 'none'};
        isDashboard = true;
        closeOnEscape = false;
        resizable = false;
        draggable = false;
        dialogClass = 'noCloseButton';
    }
    var siteUrl = url
    var divv = '<div id="mapWidgetInlineFrameDialog"><iframe id="mapWidgetInlineFrame"' +
        '    title="' + gis_head55_2 + '"' +
        '    width="100%"' +
        '    height="100%"' +
        '    src="' + siteUrl + '">' +
        '</iframe></div>';

    $('.taskContent').append(divv);

    var dlg = $('#mapWidgetInlineFrameDialog');
    dlg.dialog({
        modal: false,
        title: gis_head55_2,
        dialogClass: dialogClass,
        closeOnEscape: closeOnEscape,
        width: width,
        height: height,
        position: pos,
        appendTo: '.taskContent',
        close: function(){
            App.destroyDialog(null, dlg);
        },
        resizable: resizable, draggable: draggable,
        buttons : []
    }).dialogExtend({
        "maximizable" : true,
        "minimizable" : true,
        "minimizeLocation" : "right",
        "icons" : {
            "close" : "ui-icon-gisCloseButton",
            "maximize" : "ui-icon-gisMaximizeButton",
            "minimize" : "ui-icon-gisMinimizeButton",
            "collapse" : "ui-icon-triangle-1-s",
            "restore" : "ui-icon-gisRestoreButton"
        },
    });
    if(isDashboard){
        dlg.addClass('hide-dialog');
        setTimeout(function(){
        //    $('html').scrollTop(0);
            pos = {my: "left+" + position.left + " top+" + position.top, at: "left top", of: 'body', collision: 'none'};
            dlg.dialog({ position: pos});
            dlg.removeClass('hide-dialog').addClass('show-dialog');
        }, 4000)

        //$('html').scrollTop(0);
    }
    var mapObj = {
        url: url.replace(window.location.origin, ''),
        id: dialogId,
        position: {
            left: 0,
            top: 0,
            width: width + 'px',
            height: height + 'px',
        }
    }
    draftDashboard.addMap(mapObj);

}

/**
 * Открытие ПКА в iframe
 * @param taskName
 * @param params
 * @param guid
 */
function openCasWithinIframe(taskName, params, guid) {
    guid = guid || '';
    var authStr = Auth.getAuthStr();
    if (authStr === undefined || authStr === null) authStr = "";
    var currentUrl = getURL() + "#" + authStr;
    currentUrl = currentUrl.replace('main_js.html','cas_js.html').replace('main.html','cas_js.html');
    // получаем параметры авторизации, если они есть из урл. после "#"
    var authParams = getAutorization(currentUrl);
    var url = currentUrl.replace(/\?.*/, ''); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (url.lastIndexOf("#") != -1) {
        url = url.substr(0, url.lastIndexOf("#"));
    }
    //Добавляем полученные параметры в URL
    url += "?task=" + taskName+'&mdl=cas_js.html';
    var title = (params && params.title) ? params.title : gis_head55_3;
    delete params.title;
    Object.keys(params).forEach(function(key){
        url += '&' + key + '=' + params[key];
    });
    var width = 1032;
    var height = 560;
    if(WidgetMap && WidgetMap.config && WidgetMap.config.cas && WidgetMap.config.cas.position){
        var position = getPositionFromConfig(WidgetMap.config.cas.position);
        width = position.width;
        height = position.height;
    }

    var siteUrl = url+'#'+authParams;
    var dialogId = 'mapWidgetInlineFrameDialog' + guid;
    var divv = '<div id="' + dialogId +'"><iframe id="mapWidgetInlineFrame"' +
        '    width="100%"' +
        '    height="100%"' +
        '    src="' + siteUrl + '">' +
        '</iframe></div>';

    $('.taskContent').append(divv);
    var dlg = $('#'+dialogId);
    dlg.dialog({
        modal: false,
        title: title,
        dialogClass: 'gsi-zindex__map',
        closeOnEscape: false,
        width: width,
        height: height,
        appendTo: ".taskContent",
        resizable: true,
        buttons : [],
        close: function(){
            App.destroyDialog(null, dlg);
        }
    }).dialogExtend({
        "maximizable" : true,
        "minimizable" : true,
        "minimizeLocation" : "right",
        "icons" : {
            "close" : "ui-icon-gisCloseButton",
            "maximize" : "ui-icon-gisMaximizeButton",
            "minimize" : "ui-icon-gisMinimizeButton",
            "collapse" : "ui-icon-triangle-1-s",
            "restore" : "ui-icon-gisRestoreButton"
        },
    });
}
/*
 * Наследие старой версии
 * Загрузка флеш плеера
 */
App.loadFlash = function(swf) {
    // Version check for the Flash Player that has the ability to start Player Product Install (6.0r65)
    var hasProductInstall = DetectFlashVer(6, 0, 65);

    // Version check based upon the values defined in globals
    var hasRequestedVersion = DetectFlashVer(requiredMajorVersion, requiredMinorVersion, requiredRevision);
    var alternateContent =
        '<div class="main">'+
        '<div class="image"><a href="Public/install/install_flash_player.exe" unselectable="on" ><img src="Public/assets/FlashPlayer_Logo.jpg" width="100" height="100" alt="Установить Adobe Flash Player" unselectable="on" title="Установить Adobe Flash Player"/></a></div>' +
        '<div class="text">Для отображения содержимого страницы необходимо установить <a class="orange" href="Public/install/install_flash_player.exe" title="Установить Adobe Flash Player">Adobe Flash Player</a><br/><br/>' +
        'При возникновении проблем с отображением содержимого скачайте <a class="orange" href="Public/install/uninstall_flash_player.exe" title="Программа удаления Adobe Flash Player">программу удаления Adobe Flash Player</a>' +
        ' и выполните установку <a class="orange" href="Public/install/install_flash_player.exe" title="Установить Adobe Flash Player">повторно</a><br /> </div>' +
        '<div class="whitebg">' +
        '	После инсталляции необходимо повторно открыть страницу в новом окне браузера' +
        '</div>'+
        '</div>';

    /* new version to detect if browser is IE
     // ----------------------------------------------------------
     // If you're not in IE (or IE version is less than 5) then:
     // ie === undefined
     // If you're in IE (>=5) then you can determine which version:
     // ie === 7; // IE7
     // Thus, to detect IE:
     // if (ie) {}
     // And to detect the version:
     // ie === 6 // IE6
     // ie > 7 // IE8, IE9, IE10 ...
     // ie < 9 // Anything less than IE9
     // ----------------------------------------------------------  */
    var IE = (function(){
        var undef,rv = -1; // Return value assumes failure.
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf('MSIE ');
        var trident = ua.indexOf('Trident/');

        if (msie > 0) {
            // IE 10 or older => return version number
            rv = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        } else if (trident > 0) {
            // IE 11 (or newer) => return version number
            var rvNum = ua.indexOf('rv:');
            rv = parseInt(ua.substring(rvNum + 3, ua.indexOf('.', rvNum)), 10);
        }

        return ((rv > -1) ? rv : undef);
    }());

    /* old version to detect if browser is IE */
    /*var IE='\v'=='v';*/
    if(IE!==undefined) {
        alternateContent =
            '<div class="main">'+
            '<div class="image"><a href="Public/install/install_flash_player_ax.exe" unselectable="on" ><img src="Public/assets/FlashPlayer_Logo.jpg" width="100" height="100" alt="Установить Adobe Flash Player" unselectable="on" title="Установить Adobe Flash Player"/></a></div>' +
            '<div class="text">Для отображения содержимого страницы необходимо установить <a class="orange" href="Public/install/install_flash_player_ax.exe" title="Установить Adobe Flash Player">Adobe Flash Player</a><br/><br/>' +
            'При возникновении проблем с отображением содержимого скачайте <a class="orange" href="Public/install/uninstall_flash_player.exe" title="Программа удаления Adobe Flash Player">программу удаления Adobe Flash Player</a>' +
            ' и выполните установку <a class="orange" href="Public/install/install_flash_player_ax.exe" title="Установить Adobe Flash Player">повторно</a><br /> </div>' +
            '<div class="whitebg">' +
            '	После инсталляции необходимо повторно открыть страницу в новом окне браузера' +
            '</div>'+
            '</div>';
    }
    if ( hasProductInstall && !hasRequestedVersion ) {
        $('.content').html(alternateContent);
    }
    else if (hasRequestedVersion) {
        if(swf) {
            // if we've detected an acceptable version
            // embed the Flash Content SWF when all tests are passed
            AC_FL_RunContent(
                "src",                  swf,
                "width",                "100%",
                "height",               "100%",
                "align",                "top",
                "id",                   "web5",
                "quality",              "high",
                "bgcolor",              "#ffffff",
                "name",                 "Client_Main",
                "allowScriptAccess",    "sameDomain",
                "type",                 "application/x-shockwave-flash",
                "pluginspage",          "http://www.adobe.com/go/getflashplayer",
                "wmode",                "opaque"
            );
        }
        else {
            //document.write('no swf');
        }
    }
    else {  // flash is too old or we can't detect the plugin    
        $('.content').html(alternateContent);  // insert non-flash content
    }
};
/* загрузка флешки с доп. параметрами*/
App.loadFlashVideoModule = function(swf) {
    // Version check for the Flash Player that has the ability to start Player Product Install (6.0r65)
    var hasProductInstall = DetectFlashVer(6, 0, 65);

    // Version check based upon the values defined in globals
    var hasRequestedVersion = DetectFlashVer(requiredMajorVersion, requiredMinorVersion, requiredRevision);
    var alternateContent =
        '<div class="main" style="background: #EAEAEA;color: black; height: 100%;width: 100%;">'+
        '<div class="image"><a href="Public/install/install_flash_player.exe" unselectable="on" ><img src="Public/assets/FlashPlayer_Logo.jpg" width="100" height="100" alt="Установить Adobe Flash Player" unselectable="on" title="Установить Adobe Flash Player"/></a></div>' +
        '<div class="text">Для отображения содержимого страницы необходимо установить <a class="orange" href="Public/install/install_flash_player.exe" title="Установить Adobe Flash Player">Adobe Flash Player</a><br/><br/>' +
        'При возникновении проблем с отображением содержимого скачайте <a class="orange" href="Public/install/uninstall_flash_player.exe" title="Программа удаления Adobe Flash Player">программу удаления Adobe Flash Player</a>' +
        ' и выполните установку <a class="orange" href="Public/install/install_flash_player.exe" title="Установить Adobe Flash Player">повторно</a><br /> </div>' +
        '<div class="whitebg">' +
        '	После инсталляции необходимо повторно открыть страницу в новом окне браузера' +
        '</div>'+
        '</div>';

    /* new version to detect if browser is IE
     // ----------------------------------------------------------
     // If you're not in IE (or IE version is less than 5) then:
     // ie === undefined
     // If you're in IE (>=5) then you can determine which version:
     // ie === 7; // IE7
     // Thus, to detect IE:
     // if (ie) {}
     // And to detect the version:
     // ie === 6 // IE6
     // ie > 7 // IE8, IE9, IE10 ...
     // ie < 9 // Anything less than IE9
     // ----------------------------------------------------------  */
    var IE = (function(){
        var undef,rv = -1; // Return value assumes failure.
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf('MSIE ');
        var trident = ua.indexOf('Trident/');

        if (msie > 0) {
            // IE 10 or older => return version number
            rv = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        } else if (trident > 0) {
            // IE 11 (or newer) => return version number
            var rvNum = ua.indexOf('rv:');
            rv = parseInt(ua.substring(rvNum + 3, ua.indexOf('.', rvNum)), 10);
        }

        return ((rv > -1) ? rv : undef);
    }());

    /* old version to detect if browser is IE */
    /*var IE='\v'=='v';*/
    if(IE!==undefined) {
        alternateContent =
            '<div class="main"  style="background: #EAEAEA;color: black; height: 100%;width: 100%;">'+
            '<div class="image"><a href="Public/install/install_flash_player_ax.exe" unselectable="on" ><img src="Public/assets/FlashPlayer_Logo.jpg" width="100" height="100" alt="Установить Adobe Flash Player" unselectable="on" title="Установить Adobe Flash Player"/></a></div>' +
            '<div class="text">Для отображения содержимого страницы необходимо установить <a class="orange" href="Public/install/install_flash_player_ax.exe" title="Установить Adobe Flash Player">Adobe Flash Player</a><br/><br/>' +
            'При возникновении проблем с отображением содержимого скачайте <a class="orange" href="Public/install/uninstall_flash_player.exe" title="Программа удаления Adobe Flash Player">программу удаления Adobe Flash Player</a>' +
            ' и выполните установку <a class="orange" href="Public/install/install_flash_player_ax.exe" title="Установить Adobe Flash Player">повторно</a><br /> </div>' +
            '<div class="whitebg">' +
            '	После инсталляции необходимо повторно открыть страницу в новом окне браузера' +
            '</div>'+
            '</div>';
    }
    if ( hasProductInstall && !hasRequestedVersion ) {
        $('#videoPlayerDiv').html(alternateContent);
    }
    else if (hasRequestedVersion) {
        if(swf) {
            if(App && App.config && App.config.APP_60_SERVER)
                swf = swf.replace('./', App.config.APP_60_SERVER);
            // if we've detected an acceptable version
            // embed the Flash Content SWF when all tests are passed
            AC_FL_RunContentModule(
                "parentElementId",      "videoPlayerDiv",
                "src",                  swf,
                "width",                "100%",
                "height",               "100%",
                "align",                "top",
                "id",                   "videoPlayer55",
                "quality",              "high",
                "bgcolor",              "#ffffff",
                "name",                 "videoPlayer55",
                "allowScriptAccess",    "always",//"sameDomain",
                "type",                 "application/x-shockwave-flash",
                "pluginspage",          "http://www.adobe.com/go/getflashplayer",
                "wmode",                "opaque"
            );
        }
        else {
            //document.write('no swf');
        }
    }
    else {  // flash is too old or we can't detect the plugin
        $('#videoPlayerDiv').html(alternateContent);  // insert non-flash content
    }
};

/*Первоначальная загрузка PRELOAD.xml, чтобы не вылетали ошибки при получении геометрии при асинхонных запросах*/
App.Preload = function(widgetElementId, showMap){
    BlockingUtil.wait();
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
	function getReqLPUParams(request, lpuIds) {
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		return {
			getSchema: false,
			descrId: request,
			toElements: false,
			descrType: 'select',
			data:'<root USER_ID="'+userId.xmlEscape()+
			'" USER_LOGIN="'+userLogin.xmlEscape()+
			'" PODS_USER="'+userLogin.xmlEscape()+
			'" '+ topFiltersStr+''+
			'>'+
			'<data FILTER="'+lpuIds+'"/></root>'
		};
	}
	function faultLPU(resultXml) {
		BlockingUtil.ready();
		App.loadDefaultLpu(widgetElementId, showMap);
	}
	function resultLPU(resultXml) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if(er == ''){
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			var dd = 0;
			var extent = [];
			for (dd; dd < datas.length; dd++) {
				var maxLat = parseFloat(datas[dd].getAttribute('YMAX'));
				var minLat = parseFloat(datas[dd].getAttribute('YMIN'));
				var minLon = parseFloat(datas[dd].getAttribute('XMIN'));
				var maxLon = parseFloat(datas[dd].getAttribute('XMAX'));
				var pnt1= new proj4.toPoint([minLon,minLat]);
				var pnt2= new proj4.toPoint([maxLon,maxLat]);
				var source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
				var dest_ =  new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
				if(App.projection == GeoUtil.PROJS.Pulkovo42){//преобразуем в wgs84
					var p42WgsPnt = GeoUtil.P42WGS(minLat,minLon);
					pnt1= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
					p42WgsPnt = GeoUtil.P42WGS(maxLat,maxLon);
					pnt2 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
                }
				proj4.transform(source_, dest_, pnt1);
				proj4.transform(source_, dest_, pnt2);
                if(isNaN(pnt1.x) || isNaN(pnt1.y) || isNaN(pnt2.x) || isNaN(pnt2.y))
                    continue;
				if(extent.length == 0)
				    extent= [pnt1.x, pnt1.y, pnt2.x, pnt2.y];
				else
					extent = ol.extent.extend(extent,[pnt1.x, pnt1.y, pnt2.x, pnt2.y]);
			}
			 // of ol.Extent `[minx, miny, maxx, maxy]`.
			WidgetMap.LPURestrictExtent = extent;
		}
		App.loadDefaultLpu(widgetElementId, showMap);
	}


    function getReqParams(request, fileName) {
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:'<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
            '<data FILE="'+fileName.xmlEscape()+'"/></root>'
        };
    }
    function fault(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== '')
            App.errorReport(gis_body55_3, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_1'});
        App.loadDefaultLpu(widgetElementId, showMap);
    }
    function result(resultXml) {
        var topFilterLoadedCount = 0;
        function getFilterReqParams(request) {
            return {
                getSchema: false,
                descrId: request,
                toElements: false,
                descrType: 'select',
                data:'<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
                '<data/>'+
                '</root>'
            };
        }
        function faultFilter(resultXml) {
            BlockingUtil.ready();
            --topFilterLoadedCount;
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                App.errorReport(gis_body55_4, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_2'});
            }
            if(topFilterLoadedCount == 0){
                App.loadDefaultLpu(widgetElementId, showMap);
            }
        }
        function resultFilter(resultXml) {
            --topFilterLoadedCount;
            BlockingUtil.ready();
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                App.errorReport(gis_body55_4, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_3'});
            }
            else{
                var filtersXml = ($.parseXML(resultXml)).firstChild;
                var datas = filtersXml.getElementsByTagName("data");
                var resArr = [];
                var lpuArr = [];
                var j = 0;
                for (j; j < datas.length; j++) {
                    var curCode = datas[j].getAttribute('CODE');
                    var curDescr =  datas[j].getAttribute('DESCR');
                    var xmin =  datas[j].getAttribute('XMIN');
                    var xmax =  datas[j].getAttribute('XMAX');
                    var ymin =  datas[j].getAttribute('YMIN');
                    var ymax =  datas[j].getAttribute('YMAX');
                    //#1943 upd. Еслди не пришло descr, то заполняем его ''
                    if(curDescr === undefined)curDescr = '';
                    if (!goog.isNull(curCode)) {
                        resArr.push(curCode);
                        var lpu = {CODE:curCode, DESCR:curDescr, XMIN:xmin, XMAX:xmax, YMIN:ymin, YMAX:ymax };
                        WidgetMap.preloadLpuValuesDict[curCode] = lpu;
                        lpuArr.push(lpu);
                    }
                }
                WidgetMap.currentTopFilter.push({name:'LPU_ACCESS_FILTER',value:resArr.join(',')});
                //заносим список доступных пользователю ЛПУ в массив, чтобы далле его считать из фильтра
                WidgetMap.preloadLpuValues = lpuArr;
            }
            if(topFilterLoadedCount == 0){
                //тут добавляем проверку, если LPU_ACCESS_FILTER заполнен, то запрашиваем рамку контура ЛПУ,
                //для дальнейшего использования при отображении трубопроводной сети по контуру ЛПУ #1673
                //
	            if(goog.isDef(WidgetMap.currentTopFilter) &&  WidgetMap.currentTopFilter.length > 0 && goog.isDef(WidgetMap.LPURestrictZoom)){
                    var k=0;
                    for(;k<WidgetMap.currentTopFilter.length;k++){
                        if(goog.isDef(WidgetMap.currentTopFilter[k].name) && WidgetMap.currentTopFilter[k].name == 'LPU_ACCESS_FILTER'){
                            var lpus = WidgetMap.currentTopFilter[k].value;
	                        App.serverQueryXMLNodeWithTries(Services.processQueryNode, getReqLPUParams('SYS_SEM.xml#GET_LPU_BOUNDS', lpus), resultLPU, faultLPU,4);
                            return;
                        }
                    }

                }
                App.loadDefaultLpu(widgetElementId, showMap);
            }
        }
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.errorReport(gis_body55_5, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_4'});
            App.loadDefaultLpu(widgetElementId, showMap);
        }
        else{
            var filtersXml = ($.parseXML(resultXml)).firstChild;
            var datas = filtersXml.getElementsByTagName("data");
            var i = 0;
            topFilterLoadedCount = datas.length;
            for (i; i < datas.length; i++) {
                var provider = datas[i].getAttribute('provider');
                if(!goog.isNull(provider)){
                    BlockingUtil.wait();
                    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getFilterReqParams(provider), resultFilter, faultFilter,4);
                }
            }
        }
    }
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getReqParams('SYS_SEM.xml#GET_XML_FILE', 'PRELOAD.xml'), result, fault);
};

App.loadMap = function(widgetElementId, showMap) {
    //здесь надо разделить карту, рубрикатор, видеоплеер, панель свойств
    var mainDiv =
        '<div id="mainDiv" style="width: 100%; height: 100%;">' +
        '</div>';
    var mapDiv =
        '<div id="map" class="map" tabindex="0">' +
        '</div>'+
        '<div>' +
            '<div id="treeButtonDiv" class="tree-button-div ol-control" ></div>' +
            '<div class="tree-div-rect collapsed" ></div>' +
            '<div id="treeDiv" class="tree-div collapsed" ></div>' +
        '</div>';

    $('#'+widgetElementId).append(mainDiv)
        .on('resize',
        function (event) {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map)){
                WidgetMap.map.updateSize();
            }
        });

    $("#mainDiv").append(mapDiv);
    var isMaximizeed = WidgetMap.getTreeMaximizedFlag();
    //Процентная ширина рубрикатора относительно карты (тег <treePercentWidth>80</treePercentWidth> в задаче)
    var treePercentWidth = WidgetMap.getTreePercentWidth();
    treePercentWidth = treePercentWidth==-1 || !isMaximizeed ? '36%' : treePercentWidth+'%'; //Также учитываем флаг isMaximizeed (чтобы работало как раньше если он false)
    //без таймаута при ресайзе окна обновления размеров карты не применяются
    var curTimeout;
    $(window).on('resize', function(){
        clearTimeout(curTimeout);
        curTimeout = setTimeout(function() {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map))
                WidgetMap.map.updateSize();
        }, 100);
    });
    if(WidgetMap.treeConfig) {
        $('.tree-button-div').click(function () {
            $('.tree-div').toggleClass('collapsed');
            $('.tree-div-rect').toggleClass('collapsed');
            //добавляем сюда скрытие/показ строки поиска, когда спрятали рубрикатор
            if ($('.tree-div').hasClass('collapsed')) {
                $('div.map-search').removeClass('collapsed');
                $('div.search-view').removeClass('collapsed');
                $('div.search-filters').removeClass('collapsed');
                $('div.search-engine-filters').removeClass('collapsed');
            } else {
                $('div.map-search').addClass('collapsed');
                $('div.search-view').addClass('collapsed');
                $('div.search-filters').addClass('collapsed');
                $('div.search-engine-filters').addClass('collapsed');
            }

        });
        //добавляем дерево всегда
        App.addTree();
    }
    var isTreeVisible = !(WidgetMap && WidgetMap.config && WidgetMap.config.tree && WidgetMap.config.tree.visible === false);
    if(!isTreeVisible)
        $('#treeButtonDiv').parent().hide();

    //TODO обработать флаг canRaster, чтобы забрать из rasterlayers растровые трубы
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    var baseLayersUrl = [].concat(mapConfig.rasterlayers);
    var needBg = (WidgetMap && WidgetMap.config && WidgetMap.config.background);
    if(!checkMapExisting() && needBg){
        //нет карты, выставляем задний фон в виде картинки карты трубопроводной сети
        //TODO рефакторить - в отдельную функцию
        $('.map').addClass('no-map');
        $('.taskContent').css('background-color','transparent');
        $('.panels .panel').css('background-color','transparent');
    }
    //загружаем базовые слои
    if(goog.isDefAndNotNull(showMap) && showMap === true && !goog.isDef(WidgetMap.BaseLayersParser)){
        WidgetMap.BaseLayersParser = new BaseLayersParser({urls: baseLayersUrl});
    }
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    var overviewConfig = mapConfig.overview_map;
    if(overviewConfig !== undefined){
        //получаем параметры
        WidgetMap.overviewMapHeight = (overviewConfig.height !== undefined)? parseFloat(overviewConfig.height): 100;
        WidgetMap.overviewMapWidth = (overviewConfig.width !== undefined)?parseFloat(overviewConfig.width): 150;
        var urls = [];
        for(var i in overviewConfig.urls){
            var ovItem = overviewConfig.urls[i];
            urls.push({
                extension: ovItem.extension,
                useInterimTilesOnError: ovItem.useInterimTilesOnError === true,
                interimTilesOnErrorList: ovItem.interimTilesOnErrorList,
                url: ovItem.url
            });
        }
        WidgetMap.BaseLayersParser.parseOverviewLayers(urls);
    }


    if(WidgetMap && WidgetMap.config && WidgetMap.config.maps && WidgetMap.config.maps.length > 0){
        WidgetMap.config.maps.forEach(function(map){
            var currentDashboard = App.dashboardManager.getCurrentDashboard();
            currentDashboard.buildMap(map);
        })
    }
};


//подгружаем список дефолтных лпу, чтобы при запросе данных проходить по ним и запрашивать данные из бд
App.loadDefaultLpu = function (widgetElementId, showMap) {
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    function getFilterReqParams() {
        return {
            getSchema: false,
            descrId: "PODS_SEM_DICT.xml#PODS_SRV_DISTRICT_GCL",
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="' + userId.xmlEscape() +
                '" USER_LOGIN="' + userLogin.xmlEscape() +
                '" PODS_USER="' + userLogin.xmlEscape() + '" >' +
                '<data />' +
                '</root>'
        };
    }

    function faultFilter(resultXml) {
        App.loadMap(widgetElementId, showMap);
    }

    function resultFilter(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er === '') {
            var filtersXml = ($.parseXML(resultXml)).firstChild;
            var datas = filtersXml.getElementsByTagName("data");
            WidgetMap.defaultLpuIds = [];
            for (var j = 0; j < datas.length; j++) {
                var curCode = datas[j].getAttribute('CODE');
                if (!goog.isNull(curCode)) {
                    WidgetMap.defaultLpuIds.push(""+curCode);
                }
            }
        }
        App.loadMap(widgetElementId, showMap);
    }
    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getFilterReqParams(), resultFilter, faultFilter,4);
};

/*Первоначальная загрузка PRELOAD.xml, чтобы не вылетали ошибки при получении геометрии при асинхонных запросах*/
App.PreloadCAS = function(widgetElementId, showMap){
    BlockingUtil.wait();
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    function getReqParams(request, fileName) {
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:'<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
            '<data FILE="'+fileName+'"/></root>'
        };
    }
    function fault(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== '')
            App.errorReport(gis_body55_3, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_1'});
        App.loadCASMap(widgetElementId, showMap);
    }
    function result(resultXml) {
        var topFilterLoadedCount = 0;
        function getFilterReqParams(request) {
            return {
                getSchema: false,
                descrId: request,
                toElements: false,
                descrType: 'select',
                data:'<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
                '<data/>'+
                '</root>'
            };
        }
        function faultFilter(resultXml) {
            BlockingUtil.ready();
            --topFilterLoadedCount;
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                App.errorReport(gis_body55_4, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_2'});
            }
            if(topFilterLoadedCount == 0){
                App.loadCASMap(widgetElementId, showMap);
            }
        }
        function resultFilter(resultXml) {
            --topFilterLoadedCount;
            BlockingUtil.ready();
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                App.errorReport(gis_body55_4, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_3'});
            }
            else{
                var filtersXml = ($.parseXML(resultXml)).firstChild;
                var datas = filtersXml.getElementsByTagName("data");
                var resArr = [];
                var lpuArr = [];
                var j = 0;
                for (j; j < datas.length; j++) {
                    var curCode = datas[j].getAttribute('CODE');
                    var curDescr =  datas[j].getAttribute('DESCR');
                    var xmin =  datas[j].getAttribute('XMIN');
                    var xmax =  datas[j].getAttribute('XMAX');
                    var ymin =  datas[j].getAttribute('YMIN');
                    var ymax =  datas[j].getAttribute('YMAX');
                    //#1943 upd. Еслди не пришло descr, то заполняем его ''
                    if(curDescr === undefined)curDescr = '';
                    if (!goog.isNull(curCode)) {
                        resArr.push(curCode);
                        var lpu = {CODE:curCode, DESCR:curDescr, XMIN:xmin, XMAX:xmax, YMIN:ymin, YMAX:ymax };
                        WidgetMap.preloadLpuValuesDict[curCode] = lpu;
                        lpuArr.push(lpu);
                    }
                }
                WidgetMap.currentTopFilter.push({name:'LPU_ACCESS_FILTER',value:resArr.join(',')});
                //заносим список доступных пользователю ЛПУ в массив, чтобы далле его считать из фильтра
                WidgetMap.preloadLpuValues = lpuArr;
            }
            if(topFilterLoadedCount == 0){
                App.loadCASMap(widgetElementId, showMap);
            }
        }
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.errorReport(gis_body55_5, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_4'});
            App.loadCASMap(widgetElementId, showMap);
        }
        else{
            var filtersXml = ($.parseXML(resultXml)).firstChild;
            var datas = filtersXml.getElementsByTagName("data");
            var i = 0;
            topFilterLoadedCount = datas.length;
            for (i; i < datas.length; i++) {
                var provider = datas[i].getAttribute('provider');
                if(!goog.isNull(provider)){
                    BlockingUtil.wait();
                    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getFilterReqParams(provider), resultFilter, faultFilter,4);
                }
            }
        }
    }
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getReqParams('SYS_SEM.xml#GET_XML_FILE', 'PRELOAD.xml'), result, fault);
};

App.loadCASMap = function(widgetElementId) {
    var routeNameDiv = '<div id="casRouteNameDiv" class="casRouteNameDiv"><label id="casRouteName" /></div>';

    var vScrollDiv =
        '<div id="vScrollKm">' +
        '</div>';
    var hScrollDiv =
        '<div style="width: 100%; height: 25px;">' +
            '<div id="hScrollBeginKm"/>' +
            '<div id="hScrollKm"></div>' +
            '<div id="hScrollEndKm"/>' +
        '</div>';
    var mainDiv =
        '<div id="mainDiv" style="width: 98%; height: 100%;">' +
        '</div>';
    var mapDiv =
        '<div id="lmap" class="lmap">' +
        '</div>'+
        '<div id="map" class="map" tabindex="0">' +
        '</div>';

    $('#'+widgetElementId).append(routeNameDiv).append(hScrollDiv).append(mainDiv)
        .on('resize',
        function (event) {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map)){
                WidgetMap.map.updateSize();
                WidgetMap.lmap.updateSize();
            }
        }).append(vScrollDiv);

    $("#mainDiv").append(mapDiv);
    $(mapDiv).width( $(window).width()-430);
    //устанавливаем размеры легенды и отступ карты в зависимости от параметра
    //устанавливаем параметры из конфига
    WidgetMap.CAS_LEGEND_WIDTH = 190;
    WidgetMap.getMapDrawParams();
    $('#lmap').css('width', WidgetMap.CAS_LEGEND_WIDTH+'px');
    //смещаем влево на 4, чтобы визуально вертикальный разделитель легенды и карты выглядел норм
    $('#map').css('margin-left', (WidgetMap.CAS_LEGEND_WIDTH)+'px');
    //без таймаута при ресайзе окна обновления размеров карты не применяются
    var curTimeout;
    $(window).on('resize', function(){
        clearTimeout(curTimeout);
        curTimeout = setTimeout(function() {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map)){
                WidgetMap.map.updateSize();
                WidgetMap.lmap.updateSize();
                WidgetMap.mapSizeChanged();
            }
            var slider = $('#hScrollKm');
            var legendSize = 140;
            if(slider.length>0){
                if(goog.isDef(WidgetMap.map)){
                    var mapWidth = WidgetMap.map.getSize()[0]-80+190-8;
                    slider.jqxScrollBar({width:mapWidth});
                }
            }
        }, 100);
    });
    $('#CAS').css('visibility','hidden');
    if(getParameterByName('func') == 'showCAS'){
        WidgetMap.checkExternalParamsFromURL();
    }
    else if(getParameterByName('lineId')!=''){
        WidgetMap.loadLineData();
    }
    else{
        taskReady('showCAS',true);
        //выдать сообщение, что нет line_ID
        //App.errorReport('Ошибка при получении данных.','Не указан идентификатор трубопровода');
    }

};

App.loadMapTech = function(widgetElementId, showMap) {
    //здесь надо разделить карту, рубрикатор, видеоплеер, панель свойств
    var mainDiv =
        '<div id="mainDiv" style="width: 100%; height: 100%;">' +
        '</div>';
    var mapDiv =
        '<div id="map" class="map" tabindex="0" style="background: white;">' +
        '</div>';
    //Рубрикатор для тех. схемы
	if(WidgetMap.treeConfig){
        mapDiv =
            '<div id="map" class="map" tabindex="0" style="background: white;">' +
            '</div>'+
            '<div>' +
            '<div id="treeButtonDiv" class="tree-button-div ol-control" ></div>' +
            '<div class="tree-div-rect collapsed" ></div>' +
            '<div id="treeDiv" class="tree-div collapsed" ></div>' +
            '</div>';
    }



    $('#'+widgetElementId).append(mainDiv);
    //$('#'+widgetElementId).append(propertyDiv);// insert non-flash con
    $('#'+widgetElementId).on('resize',
        function (event) {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map)){
                WidgetMap.map.updateSize();
            }
        });

    $("#mainDiv").append(mapDiv);


    //без таймаута при ресайзе окна обновления размеров карты не применяются
    var curTimeout;
    $(window).on('resize', function(){
        clearTimeout(curTimeout);
        curTimeout = setTimeout(function() {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map))
                WidgetMap.map.updateSize();
        }, 100);
    });
    if(WidgetMap.treeConfig){
        $('.tree-button-div').click(function(){
            $('.tree-div').toggleClass('collapsed');
            $('.tree-div-rect').toggleClass('collapsed');
            //добавляем сюда скрытие/показ строки поиска, когда спрятали рубрикатор
            if($('.tree-div').hasClass('collapsed')){
                $('div.map-search').removeClass('collapsed');
                $('div.search-view').removeClass('collapsed');
                $('div.search-filters').removeClass('collapsed');
            }
            else{
                $('div.map-search').addClass('collapsed');
                $('div.search-view').addClass('collapsed');
                $('div.search-filters').addClass('collapsed');
            }
        });
        //добавляем дерево всегда
        App.addTree();
    }
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    var baseLayersUrl = [].concat(mapConfig.rasterlayers);
    /*if(!baseLayersUrl){
        //нет карты, выставляем задний фон в виде картинки карты трубопроводной сети
        $('.map').addClass('no-map');
        $('.taskContent').css('background-color','transparent');
        $('.panels .panel').css('background-color','transparent');
    }*/
    //загружаем базовые слои
    if(goog.isDefAndNotNull(showMap) && showMap === true && !goog.isDef(WidgetMap.BaseLayersParser)){
        WidgetMap.BaseLayersParser = new BaseLayersParser({urls: baseLayersUrl});
    }
    //TODO добавить preload
    //WidgetMap.preload();
    WidgetMap.init();
};


//Загрузка виджета грида в элемент с переданным ID (widgetElementId) по шаблону грида (gridTemplate)
//typeOfGrid - тип грида (от этого зависит каким классом будем обрабатывать описание грида)
App.loadWidgetGrid = function(widgetElementId, gridTemplate, fullLayerId, gridTitle, gridType, options) {
    var gridWidget;
    //Разделяем загрузку обычных гридов и гридов административных задач
    if (gridType && gridType.toLowerCase()=="gridadmwidget")
        gridWidget = new GridAdmWidget({id:widgetElementId, fullLayerId: fullLayerId});
    else if (gridType && gridType.toLowerCase()=="gridadmfileswidget")
        gridWidget = new GridAdmFilesWidget({id:widgetElementId, fullLayerId: fullLayerId});
    else if (gridType && gridType.toLowerCase()=="gridadmmapswidget")
        gridWidget = new GridAdmMapsWidget({id:widgetElementId, fullLayerId: fullLayerId});
    else{
        var parentGrid, childGrid, parentRoughFilter, parentRoughParams, filterMap, showDashboard, ignoreLabelColumn,
            staticParentRoughFilter, parentGridRowId, parentGridFilter;
        for(var i in options){
            if(options[i].name === "parentGrid"){
                parentGrid = options[i].value;
            }
            if(options[i].name === "parentRoughFilter"){
                parentRoughFilter = options[i].value;
            }
            if(options[i].name === "staticParentRoughFilter"){
                staticParentRoughFilter = options[i].value;
            }
            if(options[i].name === "parentRoughParams"){
                parentRoughParams = options[i].value;
            }
            if(options[i].name === "filterMap"){
                filterMap = options[i].value;
            }
            if(options[i].name === "childGrid"){
                childGrid = options[i].value;
            }
            if(options[i].name === "showDashboard"){
                showDashboard = options[i].value == 'true';
            }
            if(options[i].name === "ignoreLabelColumn"){
                ignoreLabelColumn = options[i].value == 'true';
            }
            if(options[i].name === "parentGridRowId"){
                parentGridRowId = options[i].value;
            }
            if(options[i].name === "parentGridFilter"){
                parentGridFilter = options[i].value;
            }
        }
        var filter = {};
        for(var i in options){
            if(options[i].name === "filter"){
                filter = options[i].value;
                break;
            }
        }
        gridWidget = new GridWidget({
            id: widgetElementId,
            fullLayerId: fullLayerId,
            filter: filter,
            parentGrid: parentGrid,
            childGrid: childGrid,
            parentRoughFilter: parentRoughFilter,
            parentRoughParams: parentRoughParams,
            filterMap: filterMap,
            showDashboard: showDashboard,
            ignoreLabelColumn: ignoreLabelColumn,
            parentGridRowId: parentGridRowId,
            parentGridFilter: parentGridFilter,
            staticParentRoughFilter: staticParentRoughFilter
        });
    }
    if(App && App.GridManager){
        App.GridManager.add(gridWidget);
    }
    //Возвращаем построенный элемент, содержащий виджет грида.
    //Пока что интерфейс загрузки гридов одинаковый, в будущем возможно будет необходимость разделения и здесь
    return gridWidget.build(widgetElementId, gridTemplate, fullLayerId, gridTitle);
};
App.scenarioParams = undefined;

App.addTree = function(){
    if(WidgetMap !== undefined && WidgetMap.getTreeMaximizedFlag()){
        $('.tree-div').removeClass('collapsed');
        $('.tree-div-rect').removeClass('collapsed');
    }

    $('#treeDiv').myCategories({width:'100%',startJson:WidgetMap.treeConfig,
        handlers:{
	        checkHeadRadioHandler:function(params){
                //если ранее не было основной обработки сценариев, то используем старый механизм
                //TODO нужно что-то делать со сценариями, чтобы исключить зависимость от рубрикатора
                if(!App.scenarioParams )
                    ExternalInteraction.treeCallFunction(params, 'loadScenario');
                if(App.scenarioParams && App.scenarioParams.mainScenario === true){
                    params.vars = App.scenarioParams.vars;
                    ExternalInteraction.treeCallFunction(params, 'loadScenario');
                }

            },
            errorHandler:function(params){
	            App.errorReport(gis_categories_6, params.text, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_10'});},
            checkHandler:function(params){ExternalInteraction.treeCallFunction(params,'enableLayer');},
            uncheckHandler:function(params){ExternalInteraction.treeCallFunction(params,'disableLayer');},
            setLayerVisibility:function(params){
                return ExternalInteraction.getLayersVisibility(params);
            },
            contextMenuHandler:
                function(params){ExternalInteraction.treeCallFunction(params,'clickButton');}
        }});
};

App.loadVideoPlayer = function(widgetElementId, docId, videoUrl, videoName, lineId) {
  try {
    //здесь надо разделить карту, рубрикатор, видеоплеер, панель свойств
    //TODO почистить код
    var closeEvt = new VideoPlayerEvent(VideoPlayerEvent.CLOSE);
    var COOKIE_VIDEO_PANEL_WIDTH = 'gis_web55_video_panel_width';
    var COOKIE_VIDEO_PANEL_HEIGHT = 'gis_web55_video_panel_height';
    var COOKIE_VIDEO_PANEL_X = 'gis_web55_video_panel_x';
    var COOKIE_VIDEO_PANEL_Y = 'gis_web55_video_panel_y';


    closeEvt.dispatch();
    if($('#videoWindow').length == 0){
        var videoDiv = '<div id="videoWindow" style="height: auto;">' +
            '<div>Видеоплеер</div><div id="videoPlayerDiv" style="width: 100%; height: 100%;"></div>'+
            '</div>';
        $('body').prepend(videoDiv);
        var videoConfig = WidgetMap.videoConfig;
        var vHeight = '280';
        var vWidth = '440';
        var vX = '5';
        var vY = '460';
        var currResize = [440,280];
        try{
            vHeight = videoConfig.height;
            vWidth = videoConfig.width;
            vX = videoConfig.x;
            vY = videoConfig.y;
        }
        catch(e){
            try{ console.log(e.stack) } catch(err) {};
        }
        //забираем/сохраняем в куки
        App.hasCookie(COOKIE_VIDEO_PANEL_HEIGHT)?vHeight = App.getCookie(COOKIE_VIDEO_PANEL_HEIGHT):App.setCookie(COOKIE_VIDEO_PANEL_HEIGHT,vHeight);
        App.hasCookie(COOKIE_VIDEO_PANEL_WIDTH)?vWidth = App.getCookie(COOKIE_VIDEO_PANEL_WIDTH):App.setCookie(COOKIE_VIDEO_PANEL_WIDTH,vWidth);
        App.hasCookie(COOKIE_VIDEO_PANEL_X)?vX = App.getCookie(COOKIE_VIDEO_PANEL_X):App.setCookie(COOKIE_VIDEO_PANEL_X,vX);
        App.hasCookie(COOKIE_VIDEO_PANEL_Y)?vY = App.getCookie(COOKIE_VIDEO_PANEL_Y):App.setCookie(COOKIE_VIDEO_PANEL_Y,vY);

        var vPosition = '{x:'+vX+', y:'+vY+'}';

        //если в куках было значение "на весь экран"
        var needCollapse = false;
        if(parseFloat(vHeight)>3000 && parseFloat(vWidth)>3000){
            vHeight = '280';
            vWidth = '440';
            needCollapse = true;
            vPosition =  '{x:0, y:0}';
        } else if (parseFloat(vHeight)<50 || parseFloat(vWidth)<50){
            //Обрабатываем ситуацию, когда во флеш-версии были записаны куки со свернутого окна видеоплеера - тогда нужно показывать его в обычном дефолтном положении
            vHeight = '280';
            vWidth = '440';
            vX = '5';
            vY = '460';
        }
        //Создаем окно видеоплеера
        $('#videoWindow').jqxVideoWindow({title:'', height: vHeight, width: vWidth, position: vPosition, showCollapseButton: true, theme:'gis-blue'});

        $('#videoWindow').on('resized', function (event) {
            //если не раскыли на весь экран, а просто за края раздвигали(collapsed == true - значит на весь экран, т.к. функционал кнопки сворачивания исправлялся))
            if(event.args !== undefined && $('#videoWindow').jqxVideoWindow("collapsed") == false){
                App.setCookie(COOKIE_VIDEO_PANEL_HEIGHT,event.args.height);
                App.setCookie(COOKIE_VIDEO_PANEL_WIDTH,event.args.width);
                currResize = [event.args.width,event.args.height];
            }
        });
        $('#videoWindow').on('collapse', function (event) {
            //если не раскыли на весь экран, а просто за края раздвигали(collapsed == true - значит на весь экран, т.к. функционал кнопки сворачивания исправлялся))
                App.setCookie(COOKIE_VIDEO_PANEL_HEIGHT,10000);
                App.setCookie(COOKIE_VIDEO_PANEL_WIDTH,10000);
        });
        $('#videoWindow').on('expand', function (event) {
            App.setCookie(COOKIE_VIDEO_PANEL_HEIGHT,currResize[1]);
            App.setCookie(COOKIE_VIDEO_PANEL_WIDTH,currResize[0]);
        });
        $('#videoWindow').on('moved', function (event) {
            //если не раскыли на весь экран, а просто двигали(collapsed == true - значит на весь экран, т.к. функционал кнопки сворачивания исправлялся))
            if(event.args !== undefined && $('#videoWindow').jqxVideoWindow("collapsed") == false){
                App.setCookie(COOKIE_VIDEO_PANEL_X,event.args.x);
                App.setCookie(COOKIE_VIDEO_PANEL_Y,event.args.y);
            }
        });
        $('#videoWindow').on('close', function (event) {
            try {
                //в таком виде флешки из памяти убираются при закрытии
                $('#videoPlayer55').remove();
                $('#videoWindow').jqxVideoWindow('destroy');
                //$('#videoWindow').remove();
                var closeEvt = new VideoPlayerEvent(VideoPlayerEvent.CLOSE);
                closeEvt.dispatch();
            }
            catch (e) {
                App.errorReport(gis_videoplayerwindow_2, e, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_7'});
            }
        });
        if(needCollapse == true){
            $('#videoWindow').jqxVideoWindow('move',0,0);
            $('#videoWindow').jqxVideoWindow('collapse');
        }
        else
            $('#videoWindow').jqxVideoWindow('move',vX,vY);

    }

    App.loadFlashVideoModule("./Public/SWF/VideoPlayer_55.swf");


    //Функция перезапуска воспроизведения - флешка грузится не сразу, так что делаем отложенный запуск
    function startVideo() {
        var wnd = getOpener();
        var fApp = getCurrentFlexApp(wnd,"videoPlayer55");
        if (fApp != null) {
            try	{
                fApp['showVideo'](docId, videoUrl, lineId);
                if(WidgetMap.startVideoAutoFocusFlag !== undefined)
                    widgetVideoSetAutoFocus(WidgetMap.startVideoAutoFocusFlag,true);
            }
            catch (e) {
                setTimeout(startVideo,5000);
            }
        }
        else {
            setTimeout(startVideo,5000);
        }
    }
    //Запускаем воспроизведение
    startVideo();
  } catch (videoErr) {
      App.errorReport(gis_body55_1, gis_body55_2 + videoErr.message, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_8'});
  }
};


/**
 * Получение информации о пользователе
 * @param panelId
 * @param showMap
 * @constructor
 */
App.PreloadUser = function(panelId, showMap){
    var that = this;
    function getCurrentUserDataParams( ) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: "ADM_SEM.xml#WEB50_B_USER_PRIVATE",
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+
                '">'+
                '<data FILTER="'+' d.USER_ID='+userId+'" />'+
                '</root>'
        };
    }

    function getCurrentUserDataResult(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.loadPanelMap(panelId, showMap);
            return;
        }
        var resultXml = ($.parseXML(resultXml)).firstChild;
        var datas = resultXml.getElementsByTagName("data");
        if(datas.length>0){
            var data = datas[0];
            var themeAttr = goog.isNull(data.getAttribute("THEME"))?'':data.getAttribute("THEME")+'';
            //получаем флаги на режим открытия карты и показ обзорной карты
            if(themeAttr !== ''){
                try{
                    var theme = JSON.parse(themeAttr.replace(/&quot;/g,'"'));
                    var mode = MapUtil.getAvailableMapMode(theme.MAP_MODE);
                    if(WidgetMap !== undefined){
                        MapUtil.applyThemeParams({
                            mapMode: mode,
                            showOverviewMap: theme.SHOW_OVERVIEW_MAP === true,
                            showTree: theme.SHOW_TREE === true,
                            sendCadastreEmail: theme.SEND_CADASTRE_EMAIL === true,
                            showCenterMap: theme.SHOW_CENTER_MAP === true,
                            coordMode: theme.COORD_MODE,
                            useSynchronization: theme.USE_SYNCHRONIZATION === true,
                        },true);
                    }
                }
                catch(e){

                }
            }
            App.loadPanelMap(panelId, showMap);
        }

    }
    function getCurrentUserDataFault(resultXml) {
        App.loadPanelMap(panelId, showMap);
    }
    App.serverQueryXML2Node(Services.processQueryNode, getCurrentUserDataParams(), getCurrentUserDataResult, getCurrentUserDataFault);
};

App.cookieMessageShowed = false;
App.loadPanelMap = function(panelId, showMap){
    //проверяем, что включены куки
    var areCookiesEnabled = App.areCookiesEnabled();//если включены куки
    if(!areCookiesEnabled){
        if(!App.cookieMessageShowed)
            App.showCookieMessage(gis_core_15);
        App.cookieMessageShowed = true;
    }
    switch(panelId){
        case 'adm_lib_doc' :
        case 'MAPSERVICE' :
            App.Preload(panelId,true);
            break;
        case 'MAPSERVICE_ADM_TREE' :
            App.loadMap(panelId,true); //Исправление по адм. задачам - показываем карту
            break;
        case 'MAPTECHSERVICE' :
            App.loadMapTech(panelId, showMap);
            break;
        case 'CAS' :
            App.PreloadCAS(panelId,true);
            break;
    }

    App.UNIQUE_ID = App.generateUUID();
    //включаем режим синхронизации
    if (App.syncManager)
        App.syncManager.turnOn();
    App.addFastAccessButtons(panelId);
}


App.addFastAccessButtons = function(panelId){
    if(WidgetMap && WidgetMap.config && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.fast_buttons && WidgetMap.config.grid.fast_buttons.length > 0 ){
        var faDiv = '<div class="map-fast-task-access_grid ol-unselectable ol-control">' +
           '</div>';
        if(panelId)
            $('#'+panelId).append(faDiv);
        var singleTab = (WidgetMap.config.grid.singleTab) ? WidgetMap.config.grid.singleTab : false;
        WidgetMap.config.grid.fast_buttons.forEach(function(gConfig, i){
            var title = (gConfig.title) ? gConfig.title : '';
            //создаем кнопку ниже версии
            var gLink = '<a class="map-fast-task-access-link_grid" id="faGrid_'+i+'" title="' + title + '" >' + title + '</a>' ;
            $('.map-fast-task-access_grid').append(gLink);
            $('#faGrid_'+i).click(function(event){
                event.preventDefault();
                try{
                    var template = (gConfig.layer) ? gConfig.layer.split('#')[1] : '';
                    ExternalInteraction.openGrid({
                        data: {
                            //ILI_INSP_FILTER:dataObj[0].ID,
                            //ILI_LBL:dataObj[0].ILI_LBL//проброс в запрос на получение заголовка грида
                        },
                        gridId: template + "_LIST",
                        label: title,
                        fullLayerId: gConfig.layer,
                        reload: true,
                        singleTab: singleTab,
                    });
                }
                catch(ex){
                    App.errorReport(gis_app_55_31, ex.message, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_9'});
                }
            })
        });
        //корректировка положения кнопок, чтобы были по центру окна браузера
        var margin = '-'+((WidgetMap.config.grid.fast_buttons.length - 1)*100)+'px';
        $('.map-fast-task-access_grid').css('margin-left', margin);
    }
}
/*
 * Скрипт главной страницы (main.html)
 */
$('.datePicker').datepicker();
//Linux. Счетчик попыток перезапроса данных, если выдается ошибка apache2
App.userTasksLoadErrorCounter = 5;

$(document).ready(function(){
    //проверка версии браузера и перенаправление
    checkBrowserVersion();


    $(document).ready(fixSizes);
    $(window).resize(fixSizes);

    //Получаем и парсим web.config (возвращается ссылка на запрос, по ней можно отменить загрузку)
    App.getClientConfig(function(){
        Auth.Autorization();
    });
});

// Скорректируем размеры
function fixSizes(hasMenus) {
    var h = $(window).height();
    $('.taskContent').height(h);
}

(function ($) {
	var methods = {
		init: function (options) {
			var startJson = options.startJson;
			return this.each(function () {
				var params = {
					divHeadCategories: $('<div class="divHeadCategories"></div>'),
					divCategories: $(this),
					filterGroups: {},
					activeRadio: undefined,
					maximized: 'true',
					idCat: ''
				};
				var handlers = {};
				if (options.handlers != undefined) $.extend(handlers, options.handlers);
				$(this).data('handlers', handlers);
				if(startJson && startJson.filters)
					$(this).data('filtersCount', startJson.filters.length);
				params.divCategories.append(params.divHeadCategories);
				methods.parseConfig(startJson, params);
				if ((params.maximized == 'true') & (params.activeRadio != undefined))
					params.activeRadio.trigger('checked');
				var curTimeout;
				$(window).on('resize', function () {
					clearTimeout(curTimeout);
					curTimeout = setTimeout(function () {
						var id = params.activeRadio.attr('id').split('_')[0];
						methods.calcTreeHeight($('#' + id + '_tree'));
					}, 100);
				});

			});
		},
		serverQueryXML: function (url, params, callbackResult, thisObject) {
			if (thisObject.divTree == undefined) {
				methods.callbackError({
					text: gis_categories_1,
					divTree: thisObject.divTree
				});
			}
			if (params.descrId == undefined) return;
			$.ajax({
				type: 'POST',
				url: url,
				data: params,
				timeout: App.clientRequestTimeout,
				dataType: 'xml',
				success: function (data) {
					var xmlData = $.parseXML($(data).find('string').text());
					$(xmlData).children().each(function () {
						callbackResult($(this), thisObject);
					})
				},
				error: function (jqXHR, textStatus, errorThrown) {
					textStatus = App.prettyCodeError(textStatus, errorThrown);
					methods.callbackError({
						text: gis_categories_2 + '.serverQueryXML. ' + textStatus + '. ' + errorThrown,
						divTree: thisObject.divTree
					});
				}
			});
		},
		serverQueryXmlFileNode: function (url, params, callbackResult, thisObject) {
			url = App.formatNodeServiceUrl(url);
			if (thisObject.divTree === undefined) {
				methods.callbackError({
					text: gis_categories_1,
					divTree: thisObject.divTree
				});
			}
			if (params.descrId === undefined) return;
			App.serverQueryXmlFileNodeWithTries(url, params, 
				function(data){
					var er = HTTPServiceUtil.getError(data);
					if (er !== ''){
						if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
							methods.callbackError({
								text: gis_core_error_1 + '. ' + params.data + '. serverQueryXmlFileNode. success.' + er,
								divTree: thisObject.divTree
							});
						return;
					}
					try{
						var xmlData = $.parseXML(data);
						$(xmlData).children().each(function () {
							callbackResult($(this), thisObject);
						})
					}
					catch(ex){
						methods.callbackError({
							text: gis_core_error_1 + '. ' + params.data + '. serverQueryXmlFileNode. success.' + ex.message,
							divTree: thisObject.divTree
						});	
					}
				},function(data){
					methods.callbackError({
						text: gis_core_error_1 + '. ' + params.data + '. serverQueryXmlFileNode. ' + data + '. ',
						divTree: thisObject.divTree
					});
				}, undefined);
			},
		checkedHeadRadio: function (event) {
			var el = $(this),
				id = el.attr('id').split('_')[0];
			$('.' + el.data('idcat')).addClass('noVisible').removeClass('activeTab');
			$('#' + id + '_tab').removeClass('noVisible').addClass('activeTab');
			if (el.data('loaded') == false) {
				var divTree = $('#' + id + '_tree');
				divTree.jqxRubrTree({
					toggleMode: 'none',
					allowDrag: false,
					allowDrop: false,
					//width: '100%',
					theme: 'myCommon'
				}).on('expand', methods.expandTree);
				methods.serverQueryXmlFileNode(Services.processQueryNodeXml,
					{
						descrId: 'SYS_SEM.xml#GET_XML_FILE',
						descrType: 'select',
						getSchema: false,
						toElements: false,
						data: '<root><data FILE="../../' + el.data('url') + '"/></root>'
					},
					methods.parseTree, {divTree: divTree, parentElement: ''});
				$('#' + id + '_filters .divFilterGroup').each(function (i,el) {
					var scenarioVars = undefined;
					var checkHeadRadioHandler = undefined;
					if(i == 0){
						scenarioVars = methods.getScenarioVars(id);
						checkHeadRadioHandler =  divTree.parent().parent().data('handlers').checkHeadRadioHandler;
					}
					var el = $(this);
					el.myFilters({
						scenarioVars:scenarioVars,
						fromTree: true,
						opener:divTree,
						dataSource: el.data('source'),
						preOpenFilterId: el.data('preopen'),
						handlers: {
							errorHandler: divTree.parent().parent().data('handlers').errorHandler,
							checkHeadRadioHandler:checkHeadRadioHandler
						}
					})
				});
				el.data('loaded', true);
				methods.calcTreeHeight(divTree);
				divTree.jqxRubrTree('refresh');
				if($('#' + id + '_filters .divFilterGroup').length == 0){
					if (divTree.parent().parent().data('handlers').checkHeadRadioHandler !== undefined) {
						var vars = methods.getScenarioVars(id);
						//if (vars !== undefined)
						divTree.parent().parent().data('handlers').checkHeadRadioHandler({vars: vars});
					}
				}
			}
			else {
				var divTree = $('#' + id + '_tree');
				//divTree.jqxRubrTree({width: '100%'});
				divTree.jqxRubrTree('refresh');
				if (divTree.parent().parent().data('handlers').checkHeadRadioHandler !== undefined) {
					var vars = methods.getScenarioVars(id);
					//if (vars !== undefined)
						divTree.parent().parent().data('handlers').checkHeadRadioHandler({vars: vars});
				}
			}
		},
		parseConfig: function (json, obj) {
			obj.idCat = methods.getUniqueId();
			for(var index in json.trees){
				var tree = json.trees[index];
				var visible = 'noVisible',
					id = methods.getUniqueId(),
					radioButton = $('<div id="w' + id + '_checkBox" data-url="" data-loaded="false" data-idcat="' + obj.idCat + '">' + tree.title + '</div>');
				obj.divHeadCategories.append(radioButton);
				if (tree.default !== undefined && tree.default) {
					visible = 'activeTab';
					radioButton.jqxRadioButton({checked: true, groupName: obj.idCat, theme: 'myCommon'});
					obj.activeRadio = radioButton;
				}
				else radioButton.jqxRadioButton({checked: false, groupName: obj.idCat, theme: 'myCommon'});
				radioButton.on('checked', methods.checkedHeadRadio);
				$(obj.divCategories).append('<div id="w' + id + '_tab" class="divTab ' + visible + ' ' + obj.idCat + '"><div id="w' + id + '_filters"></div><div id="w' + id + '_tree" class="divTree"></div></div>');
				//if (tree.topFilterId !== undefined)
					obj.filterGroups[tree.topFilterId] = $('#w' + id + '_filters');
				radioButton.data('url', tree.templateUrl);
				if(tree.startupScenario !== undefined){
					var startupScenario = tree.startupScenario;
					radioButton.data('openLayers',startupScenario.openLayers);
					radioButton.data('openTableInterval',startupScenario.openTableInterval);
					if(startupScenario.filter !== undefined){
						radioButton.data('filterType',startupScenario.filter.type);
						radioButton.data('topFilterSource',startupScenario.filter.topDataSource);
						radioButton.data('middleFilterSource',startupScenario.filter.middleDataSource);
						var id = radioButton.attr('id').replace('_checkBox','');
						var filter = $('#' + id + '_filters');
						var filterType = startupScenario.filter.type;
						var preOpenId = 'undefined';
						if(filterType !== undefined && filterType.indexOf('middle') != -1)
							preOpenId = '';
						//если есть описание верхнего фильтра, то добавляем div.
						if(filter.length > 0 && filterType !== undefined && filterType.indexOf('top') != -1){
							filter.append('<div class="divFilterGroup" data-preopen="' + preOpenId + '" data-source="' + startupScenario.filter.topDataSource + '"></div>');
						}
					}
					if(startupScenario.openTables !== undefined  && startupScenario.openTables.length > 0){
						for(var index in startupScenario.openTables){
							var openTable = startupScenario.openTables[index];
							radioButton.data('openTableTitle',radioButton.data('openTableTitle') + '|' +openTable.title);
							radioButton.data('openTableGridId',radioButton.data('openTableGridId') + '|' + openTable.gridId);
							radioButton.data('openTableLevelParams',radioButton.data('openTableLevelParams') + '|' + openTable.levelParams);
							if(openTable.query !== undefined){
								radioButton.data('querySource',radioButton.data('querySource') + '|' +openTable.query.source);
								radioButton.data('queryLayerId',radioButton.data('queryLayerId') + '|' + openTable.query.LAYER_ID);
								radioButton.data('queryFileName',radioButton.data('queryFileName') + '|' + openTable.query.FILE_NAME);
							}
						}
					}
				}


			}
			for(var index in json.filters){
				var filter = json.filters[index];
				var preOpenId = 'undefined';
				if (filter.preOpenFilterId !== undefined)
					preOpenId = filter.preOpenFilterId;
				obj.filterGroups[filter.id].append('<div class="divFilterGroup" data-preopen="' + preOpenId + '" data-source="' + filter.dataSource + '"></div>');
			}
		},
		getIdCheckBox: function (options) {
			var res = '';
			if (options.divTree != undefined) {
				var levelParams = options.xmlElement.attr('levelParams');
				if ((levelParams != undefined) && (levelParams.indexOf('layerId=') != -1)) {
					var value = levelParams.replace('layerId=', '').split('#');
					if (value.length == 1) res = 'id="' + options.divTree.attr('id') + '-' + value[0].split(';')[0] + '"';
					else res = 'id="' + options.divTree.attr('id') + '-' + value[1].split(';')[0] + '"';
				}
			}
			return res;
		},
		getItemLabel: function (options) {
			var icons = '';
			var checkBox = '<div class="divNoCheckBox"></div>';
				if ((options.xmlElement.attr('icon') !== undefined) & (options.xmlElement.attr('icon') != 'OPENSCALE'))
					icons = '<img src="' + options.xmlElement.attr('icon') + '" alt="' + options.label + '" />';
				var checkBoxType = options.xmlElement.attr('checkbox_type');
				if (checkBoxType != undefined) {
					if (checkBoxType != 'none') {
						if (checkBoxType == 'childBased')
							checkBox = '<div class="checkBoxDisabled myCheckBox"></div>';
						else {
							if ((options.xmlElement[0].getElementsByTagName('on_check').length + options.xmlElement[0].getElementsByTagName('on_uncheck').length) > 0)
								checkBox = '<div ' + methods.getIdCheckBox(options) + ' class="checkBox myCheckBox"></div>';
							else
								checkBox = '<div class="checkBoxDisabled myCheckBox"></div>';
						}
					}
				}
				else {
					if (options.xmlElement[0].tagName != 'Style') {
						if ((options.xmlElement[0].getElementsByTagName('on_check').length + options.xmlElement[0].getElementsByTagName('on_uncheck').length) > 0)
							checkBox = '<div ' + methods.getIdCheckBox(options) + ' class="checkBox myCheckBox"></div>';
						else
							checkBox = '<div class="checkBoxDisabled myCheckBox"></div>';
					}
				}
			return checkBox + '<div class="spContextIcons"></div><span class="spIcon" title="'+options.label+'" >' + icons + '</span><span class="spLabel" title="'+options.label+'" >' + options.label + '</span>';
		},
		calcTreeHeight: function (tree) {
			//5 попыток пересчитать высоту, каждую секунду. Костыль, чтобы не переписывать половину класса фильтра
			var x = 0;
			//20.07.2021 Решено завиксировать ширину рубрикатора.
			var width = $('.divHeadCategories').outerWidth(true)+'px';
			var height = $('body').outerHeight() /*кнопки*/-210-$('.divHeadCategories').outerHeight(true) - /*filters*/$(tree.parent().children()[0]).outerHeight(true)+ 'px';
			tree.jqxRubrTree({
				width:width,
				height: height
			});
			var intervalID = setInterval(function () {
				var heightInternal = $('body').outerHeight() /*кнопки*/-210-$('.divHeadCategories').outerHeight(true) - /*filters*/$(tree.parent().children()[0]).outerHeight(true)+ 'px';
				if(height !== heightInternal ){
					tree.jqxRubrTree({
						width: width,
						height: heightInternal
					});
					height = heightInternal;
				}

				if (++x === 5) {
					window.clearInterval(intervalID);
				}
			}, 1000);
		},
		//добавить jqx чекбокс и листенеры
		applyCheckbox: function (treeNode, tree) {
			var dataItem = treeNode;//tree.divTree.jqxRubrTree('getItem',treeNode.element).value;
			$('#' + treeNode.element.id + ' .myCheckBox:first').each(function () {
				if ($(this).hasClass('checkBox'))
					$(this).jqxCheckBox({theme: 'myCommon'}).on('checked', function () {
						var el = $(this);
						if (el.hasClass('noHandler')) el.removeClass('noHandler');
						else methods.checkTreeNode({tree: tree, dataItem: dataItem.value});
					})
						.on('unchecked', function () {
							var el = $(this);
							if (el.hasClass('noHandler')) el.removeClass('noHandler');
							else methods.uncheckTreeNode({tree: tree, dataItem: dataItem.value});
						});
				if ($(this).hasClass('checkBoxDisabled'))
					$(this).jqxCheckBox({disabled: true, theme: 'myCommon'});
				else
					tree.layerVisibility.push({layer: this.id.split('-')[1]});
			});
			methods.updateLayersVisibility(tree, tree.layerVisibility);
		},
		parseTree: function (xmlElement, tree) {
			switch (xmlElement[0].tagName) {
				case 'root':
				case 'dataset':
					tree.invokes = {};
					xmlElement.children().each(function () {
						methods.parseTree($(this), tree);
					});
					methods.calcTreeHeight(tree.divTree);
					break;
				case 'tree':
					var params = $.extend(tree, {layerVisibility: []});
					xmlElement.children().each(function () {
						methods.parseTree($(this), tree);
					});
					if (params.layerVisibility.length != 0) {
						methods.updateLayersVisibility(tree, params.layerVisibility);
					}
					break;
				case 'group':
					xmlElement.children().each(function () {
						methods.parseTree($(this), tree);
					});
					break;
				case 'level':
					var oldParent = tree.parentElement;
					if (xmlElement.attr('max_items') == undefined)
						xmlElement.attr('max_items', $(xmlElement[0]).parent().attr('max_items'));
					var maxItems = xmlElement.attr('max_items');
					var levelParams = xmlElement.attr('levelParams');
					if (oldParent == '')
						tree.divTree.jqxRubrTree('addTo', {
							html: methods.getItemLabel({
								label: xmlElement.attr('format'),
								xmlElement: xmlElement,
								divTree: tree.divTree
							}),
							value: {
								loaded: false,
								maxItems: maxItems,
								hasQuery: false,
								params: {LOW_LIMIT: 1, HIGH_LIMIT: parseInt(maxItems) + 1, levelParams: levelParams}
							}
						});
					else
						tree.divTree.jqxRubrTree('addTo', {
							html: methods.getItemLabel({
								label: xmlElement.attr('format'),
								xmlElement: xmlElement,
								divTree: tree.divTree
							}),
							value: {
								loaded: false,
								maxItems: maxItems,
								hasQuery: false,
								params: {LOW_LIMIT: 1, HIGH_LIMIT: parseInt(maxItems) + 1, levelParams: levelParams}
							}
						}, tree.parentElement);


					var treeItems = tree.divTree.jqxRubrTree('getItems');
					tree.parentElement = treeItems[treeItems.length - 1].element;

					var treeNode = treeItems[treeItems.length - 1];
					var dataItem = tree.divTree.jqxRubrTree('getItem', tree.parentElement).value;
					$('#' + tree.parentElement.id + ' .myCheckBox:first').each(function () {
						if ($(this).hasClass('checkBox')) $(this).jqxCheckBox({theme: 'myCommon'}).on('checked', function () {
							var el = $(this);
							if (el.hasClass('noHandler')) el.removeClass('noHandler');
							else methods.checkTreeNode({tree: tree, dataItem: dataItem});
						})
							.on('unchecked', function () {
								var el = $(this);
								if (el.hasClass('noHandler')) el.removeClass('noHandler');
								else methods.uncheckTreeNode({tree: tree, dataItem: dataItem});
							});
						if ($(this).hasClass('checkBoxDisabled')) $(this).jqxCheckBox({
							disabled: true,
							theme: 'myCommon'
						});
						else
							tree.layerVisibility.push({layer: this.id.split('-')[1]});
					});
					methods.updateLayersVisibility(tree, tree.layerVisibility);
					if (xmlElement.parent().get(0).tagName == 'tree') {
						var itemData = tree.divTree.jqxRubrTree('getItem', tree.parentElement).value;
						itemData.children = xmlElement.children();
						itemData.tree = tree;
						var hasChildren = xmlElement.children('level').length != 0;
						if (hasChildren == true) {
							//добавляем сюда тестовый див для отображения
							tree.divTree.jqxRubrTree('addTo', {html: gis_categories_3}, tree.parentElement);
						}
						xmlElement.children().each(function () {
							methods.parseLevel($(this), tree.parentElement, tree);
						});
						if (itemData.hasQuery == true) {
							var label = $('#' + tree.parentElement.id + ' .spLabel:first');
							label.data('oldlabel', label.text());
							label.text(gis_categories_3);
							var data = '';
							for (var i in itemData.params)
								data = data + ' ' + i + '="' + itemData.params[i] + '"';
							$(tree.parentElement).addClass('li-disabled');
							$(tree.parentElement).find('*').attr('disabled', true).addClass('readOnly');
							methods.serverQueryXmlFileNode(Services.processQueryNodeXml,
								{
									descrId: itemData.descrId,
									descrType: 'select',
									getSchema: false,
									toElements: false,
									data: '<root><data ' + data + '/></root>'
								}, function (xmlElement, params, parent) {
									methods.parseTreeData(xmlElement, params, parent);
									$(params.treeNode).removeClass('li-disabled');
									$(params.treeNode).find('*').attr('disabled', false).removeClass('readOnly');
								}, {treeNode: tree.parentElement, divTree: tree.divTree});
						}
					}
					tree.parentElement = oldParent;
					break;
				case 'invoke':
					var nameInvoke = xmlElement.attr('id');
					tree.invokes[nameInvoke] = {vars: {}};
					$.each(xmlElement[0].attributes, function () {
						if (this.name != 'id') tree.invokes[nameInvoke][this.name] = this.value;
					});
					xmlElement.children().each(function () {
						methods.parseTree($(this), tree.invokes[nameInvoke].vars);
					});
					break;
				case 'var':
					if (xmlElement.attr('name') == undefined)
						$.each(xmlElement[0].attributes, function () {
							tree[this.name] = this.value;
						});
					else
						tree[xmlElement.attr('name')] = xmlElement.attr('value');
					break;
				case 'context_menu':
					if (tree.invokes[xmlElement.attr('run_invoke')].icon != undefined) {
						var alt = tree.invokes[xmlElement.attr('run_invoke')].tooltip;
						//размеры, как во флеш
						var iconMenu = $('<img style="width:20px;height:20px;" src="' + tree.invokes[xmlElement.attr('run_invoke')].icon + '" alt="' + alt + '"/>');
						$('#' + tree.parentElement.id + ' .spContextIcons:first').append(iconMenu);
						//iconMenu.jqxTooltip({content: alt, theme: 'myCommon'});
						iconMenu.attr('title', alt);
						var dataItem = {};
						$.each(xmlElement[0].attributes, function () {
							if (this.name != 'id') dataItem[this.name] = this.value;
						});
						iconMenu.data('dataItem', dataItem);
						var levelParams = xmlElement.parent().attr('levelParams');
						if (levelParams == undefined) levelParams = '';
						iconMenu.click(function () {
							var dataItem = $(this).data('dataItem');
							methods.contextMenuClick({tree: tree, levelParams: levelParams, dataItem: dataItem});
						});
					}
					break;
				case 'on_check':
					/*var dataItem = {};
					 $.each(xmlElement[0].attributes,function(){if(this.name != 'id')dataItem[this.name] = this.value;});
					 iconMenu.data('dataItem',dataItem);
					 var levelParams = xmlElement.parent().attr('levelParams');
					 if(levelParams == undefined)levelParams = '';*/
					dataItem = tree.divTree.jqxRubrTree('getItem', tree.parentElement).value;
					$.extend(dataItem, {
						on_check: {
							run_invoke: xmlElement.attr('run_invoke'),
							layerParams: xmlElement.attr('layerParams')
						}
					});
					break;
				case 'on_uncheck':
					var dataItem = tree.divTree.jqxRubrTree('getItem', tree.parentElement).value;
					$.extend(dataItem, {
						on_uncheck: {
							run_invoke: xmlElement.attr('run_invoke'),
							layerParams: xmlElement.attr('layerParams')
						}
					});
					break;
				case 'query':
					var dataItem = tree.divTree.jqxRubrTree('getItem', tree.parentElement).value;
					$.extend(dataItem, {descrId: '', hasQuery: true});
					$.each(xmlElement[0].attributes, function () {
						if (this.name == 'source') {
							dataItem.descrId = this.value;
							return;
						}
						if (this.value.indexOf('{') == 0) {
							var el = tree.divTree.jqxRubrTree('getItem', tree.parentElement);
							this.value = tree.divTree.jqxRubrTree('getItem', el.parentElement).value.params[this.name];
						}
						dataItem.params[this.name] = this.value;
					});
					break;
			}
		},
		addChildToParent: function (xmlElement, parent, tree, finderCount) { //finderCount - текущий счетчик чилдрена у парента, чтобы выловить его в getItems
			var itemLabel = undefined;
			switch (xmlElement[0].tagName) {
				case 'level':
					if (xmlElement.attr('max_items') == undefined)
						xmlElement.attr('max_items', $(xmlElement[0]).parent().attr('max_items'));
					var maxItems = xmlElement.attr('max_items');
					var levelParams = xmlElement.attr('levelParams');
					itemLabel = methods.getItemLabel({
						label: xmlElement.attr('format'),
						xmlElement: xmlElement,
						divTree: tree.divTree
					});
					tree.divTree.jqxRubrTree('addTo', {
						html: itemLabel,
						value: {
							loaded: false,
							maxItems: maxItems,
							hasQuery: false,
							params: {LOW_LIMIT: 1, HIGH_LIMIT: parseInt(maxItems) + 1, levelParams: levelParams}
						}
					}, parent);
					var treeItems = tree.divTree.jqxRubrTree('getItems');
					var pI = tree.divTree.jqxRubrTree('getItem', parent);
					var i = 0;
					//вылавливаем добавленный элемент
					var treeNode = pI.nextItem;
					for (i; i < finderCount; i++) {
						treeNode = treeNode.nextItem;
					}
					if (treeNode.value != null) {
						treeNode.value.children = xmlElement.children();
						treeNode.value.tree = tree;
					}
					itemLabel = treeNode.element;
					methods.applyCheckbox(treeNode, tree);
					break;
			}
			return itemLabel;
		},
		parseLevel: function (xmlElement, currentElement, tree) {
			switch (xmlElement[0].tagName) {
				case 'context_menu':
					if (tree.invokes[xmlElement.attr('run_invoke')] != undefined && tree.invokes[xmlElement.attr('run_invoke')].icon != undefined) {
						var alt = tree.invokes[xmlElement.attr('run_invoke')].tooltip;
						//размеры, как во флеш
						var iconMenu = $('<img style="width:20px;height:20px;" src="' + tree.invokes[xmlElement.attr('run_invoke')].icon + '" alt="' + alt + '"/>');
						$('#' + currentElement.id + ' .spContextIcons:first').append(iconMenu);
						//iconMenu.jqxTooltip({content: alt, theme: 'myCommon'});
						iconMenu.attr('title',alt);
						var dataItem = {};
						$.each(xmlElement[0].attributes, function () {
							if (this.name != 'id') dataItem[this.name] = this.value;
						});
						iconMenu.data('dataItem', dataItem);
						var levelParams = xmlElement.parent().attr('levelParams');
						if (levelParams == undefined) levelParams = '';
						iconMenu.click(function () {
							var dataItem = $(this).data('dataItem');
							methods.contextMenuClick({tree: tree, levelParams: levelParams, dataItem: dataItem});
						});
					}
					break;
				case 'on_check':
					var dataItem = tree.divTree.jqxRubrTree('getItem', currentElement).value;
					$.extend(dataItem, {
						on_check: {
							run_invoke: xmlElement.attr('run_invoke'),
							layerParams: xmlElement.attr('layerParams')
						}
					});
					break;
				case 'on_uncheck':
					var dataItem = tree.divTree.jqxRubrTree('getItem', currentElement).value;
					$.extend(dataItem, {
						on_uncheck: {
							run_invoke: xmlElement.attr('run_invoke'),
							layerParams: xmlElement.attr('layerParams')
						}
					});
					break;
				case 'query':
					var dataItem = tree.divTree.jqxRubrTree('getItem', currentElement).value;
					$.extend(dataItem, {descrId: '', hasQuery: true});
					$.each(xmlElement[0].attributes, function () {
						if (this.name == 'source') {
							dataItem.descrId = this.value;
							return;
						}
						if (this.value.indexOf('{') == 0) {
							var el = tree.divTree.jqxRubrTree('getItem', currentElement);
							this.value = tree.divTree.jqxRubrTree('getItem', el.parentElement).value.params[this.name];
						}
						dataItem.params[this.name] = this.value;
					});
					break;
			}
		},
		updateLayersVisibility: function (tree, layerVisibility) {
			var el = $(tree.divTree).parent().parent().data('handlers');
			if (el.setLayerVisibility != undefined) {
				var layerVisibity = el.setLayerVisibility(layerVisibility),
					localId = tree.divTree.attr('id');
				for (var i in layerVisibity)
					if (layerVisibity[i].visible)
						$('#' + localId + '-' + layerVisibity[i].layerName)/*.addClass('noHandler')*/.jqxCheckBox('check');
					else
						$('#' + localId + '-' + layerVisibity[i].layerName).addClass('noHandler').jqxCheckBox('uncheck');
			}
		},
		getUniqueId: function () {
			return 'xxxxxxxx'.replace(/[xy]/g, function (c) {
				var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
				return v.toString(16);
			});
		},
		expandTree: function (event) {
			var divTree = $(event.target);
			var item = divTree.jqxRubrTree('getItem', event.args.element);
			if (item.value.loaded == false) {
				if (item.value.parsed != true) {
					//удаляем "загрузка" и перезаполняем, как при клике
					if (item.nextItem != null && item.nextItem.label == gis_categories_3) {
						divTree.jqxRubrTree('removeItem', item.nextItem);
					}
					var children = item.value.children;
					var counter = 0;

					if (children != undefined)
						children.each(function () {
							if ($(this)[0].nodeName == 'level') {
								if (item.value.tree != undefined) {
									var tree = item.value.tree;
									var currElement = methods.addChildToParent($(this), item.element, tree, counter);
									var hasChildren = $(this).children('level').length != 0;
									if (hasChildren == true) {
										//добавляем сюда тестовый див для отображения
										tree.divTree.jqxRubrTree('addTo', {html: gis_categories_3}, currElement);
										counter++;
									}
									//дизейблим элемент, пока к нему не подгрузились стили
									//tree.divTree.jqxRubrTree('disableItem',currElement);// в этом варианте клики проходят
									$(currElement).addClass('li-disabled');
									//получаем descr, если нет запросов на стили, то не дизейблим
									var hasQuery = false;
									$(this).children().each(function () {
										if ($(this)[0].tagName == 'query')
											hasQuery = true;
										methods.parseLevel($(this), currElement, tree);
									});
									$(currElement).find('*').attr('disabled', true).addClass('readOnly');
									if (hasQuery == false) {
										$(currElement).removeClass('li-disabled');
										$(currElement).find('*').attr('disabled', false).removeClass('readOnly');
									}
									counter++;
								}
							}
						});
					if (item.value.tree != undefined) {
						var tree = item.value.tree;
						var dataItem = tree.divTree.jqxRubrTree('getItem', item.element).value;
						$('#' + item.element.id + ' .myCheckBox:first').each(function () {
							if ($(this).hasClass('checkBox')) $(this).jqxCheckBox({theme: 'myCommon'}).on('checked', function () {
								var el = $(this);
								if (el.hasClass('noHandler')) el.removeClass('noHandler');
								else methods.checkTreeNode({tree: tree, dataItem: dataItem});
							})
								.on('unchecked', function () {
									var el = $(this);
									if (el.hasClass('noHandler')) el.removeClass('noHandler');
									else methods.uncheckTreeNode({tree: tree, dataItem: dataItem});
								});
							if ($(this).hasClass('checkBoxDisabled')) $(this).jqxCheckBox({
								disabled: true,
								theme: 'myCommon'
							});
							else
								tree.layerVisibility.push({layer: this.id.split('-')[1]});
						});
						methods.updateLayersVisibility(tree, tree.layerVisibility);
					}
					item.value.parsed = true;
				}
				item.value.loaded = true;
				var children = $(event.args.element).find('ul:first').children();
				children.each(function () {
					var itemData = divTree.jqxRubrTree('getItem', this).value;
					var label = $('#' + this.id + ' .spLabel:first');
					label.data('oldlabel', label.text());
					if (itemData.descrId != undefined) label.text(gis_categories_3);
					var data = '';
					for (var i in itemData.params)data = data + ' ' + i + '="' + itemData.params[i] + '"';
					methods.serverQueryXmlFileNode(Services.processQueryNodeXml,
						{
							descrId: itemData.descrId,
							descrType: 'select',
							getSchema: false,
							toElements: false,
							data: '<root><data ' + data + '/></root>'
						},
						function (xmlElement, params) {
							var scrollTop = $(document).scrollTop();
							methods.parseTreeData(xmlElement, params);
							//выставляем в enabled элемент с загруженными стилями
							//params.divTree.jqxRubrTree('enableItem',params.treeNode);
							$(params.treeNode).removeClass('li-disabled');
							$(params.treeNode).find('*').attr('disabled', false).removeClass('readOnly');
							$(document).scrollTop(scrollTop);
						}, {treeNode: this, divTree: divTree});
				});
				divTree.jqxRubrTree('refresh');
			}

		},
		addMoreItems: function (params) {
			var item = params.divTree.jqxRubrTree('getItem', params.treeNode);
			if (item.value.loaded == false) {
				item.value.loaded = true;
				var label = $('#' + params.treeNode.id + ' .spLabel:first');
				label.data('oldlabel', label.text());
				label.text(gis_categories_3);
				var itemData = params.divTree.jqxRubrTree('getItem', params.treeNode).value;
				var data = '';
				for (var i in itemData.params)data = data + ' ' + i + '="' + itemData.params[i] + '"';
				methods.serverQueryXmlFileNode(Services.processQueryNodeXml,
					{
						descrId: itemData.descrId,
						descrType: 'select',
						getSchema: false,
						toElements: false,
						data: '<root><data ' + data + '/></root>'
					},
					function (xmlElement, params) {
						var scrollTop = $(document).scrollTop();
						methods.parseTreeData(xmlElement, params);
						$(params.treeNode).removeClass('li-disabled');
						$(params.treeNode).find('*').attr('disabled', false).removeClass('readOnly');
						$(document).scrollTop(scrollTop);
					}, params);
			}
		},
		checkTreeNode: function (params) {
			if (params.dataItem.on_check != undefined) {
				var el = $(params.tree.divTree).parent().parent().data('handlers');
				if (el.checkHandler != undefined)
					el.checkHandler(methods.makeParams({
						invoke: params.tree.invokes[params.dataItem.on_check.run_invoke],
						dataItem: params.dataItem.on_check,
						tree: params.tree,
						levelParams: params.dataItem.params.levelParams
					}));
			}
		},
		uncheckTreeNode: function (params) {
			if (params.dataItem.on_uncheck != undefined) {
				var el = $(params.tree.divTree).parent().parent().data('handlers');
				if (el.uncheckHandler != undefined)
					el.uncheckHandler(methods.makeParams({
						invoke: params.tree.invokes[params.dataItem.on_uncheck.run_invoke],
						dataItem: params.dataItem.on_uncheck
					}));
			}
		},
		contextMenuClick: function (params) {
			if (params.dataItem.run_invoke != undefined) {
				var el = $(params.tree.divTree).parent().parent().data('handlers');
				if (el.contextMenuHandler != undefined)
					el.contextMenuHandler($.extend(methods.makeParams({
						invoke: params.tree.invokes[params.dataItem.run_invoke],
						dataItem: params.dataItem
					}), {levelParams: params.levelParams}));
			}
		},
		makeParams: function (params) {
			var prm = {event_name: params.invoke.event_name, vars: {}, tree: params.tree};
			for (var i in params.invoke.vars)prm.vars[i] = params.invoke.vars[i];
			for (i in params.dataItem)
				if (i != 'run_invoke') prm.vars[i] = params.dataItem[i];
			return prm;
		},
		parseTreeData: function (xmlElement, params, parent) {
			switch (xmlElement[0].tagName) {
				case 'root':
					var data = xmlElement.children();
					if ((data.length == 0) & ($(params.treeNode).text().indexOf(gis_categories_3) != -1))
						params.divTree.jqxRubrTree('removeItem', params.treeNode);
					else {
						var treeNode = params.treeNode;
						data.each(function () {
							methods.parseTreeData($(this), params);
						});
						params.treeNode = treeNode;
						var el = params.divTree.jqxRubrTree('getItem', params.treeNode);
						if (data.length == (el.value.params.HIGH_LIMIT - el.value.params.LOW_LIMIT)) {
							var val = $.extend({}, el.value);
							val.loaded = false;
							val.params.LOW_LIMIT = parseInt(el.value.params.HIGH_LIMIT) + 1;
							val.params.HIGH_LIMIT = parseInt(el.value.params.HIGH_LIMIT) + parseInt(el.value.maxItems) + 1;
							xmlElement.attr('checkbox_type', 'none');
							params.divTree.jqxRubrTree('addTo', {
								html: methods.getItemLabel({
									label: gis_categories_4 + el.value.maxItems + gis_categories_5,
									xmlElement: xmlElement
								}), value: val
							}, el.parentElement);
							var items = $(el.element).parent().children();
							$(items[items.length - 1]).click(function () {
								//Закоментированы для функции подгрузки слоев, дизейблился 1 слой
								//$(params.treeNode).addClass('li-disabled');
								methods.addMoreItems({treeNode: items[items.length - 1], divTree: params.divTree})
								//$(params.treeNode).find('*').attr('disabled', true).addClass('readOnly');
							});
						}
					}
					break;
				case 'Style':
					var icons;
					var label = $('#' + params.treeNode.id + ' .spLabel:first');
					if (label.text().indexOf(gis_categories_3) !== -1) {
						var oldLabel = label.data('oldlabel');
						if ((oldLabel === '{descr}') || (oldLabel.indexOf(gis_categories_4) === 0) || (oldLabel.indexOf(gis_categories_7) === 0)) {
							if (xmlElement.attr('descr'))
								label.text(xmlElement.attr('descr')).attr('title', xmlElement.attr('descr') );
							else
								label.text(gis_categories_7);
						}
						else
							label.text(oldLabel);
						icons = $('#' + params.treeNode.id + ' .spIcon:first');
						icons.children().each(function () {
							var el = $(this);
							if ((el.attr('alt') !== undefined) & (el.attr('alt') === '{descr}')) {
								el.attr('alt', xmlElement.attr('descr'));
							}
						});
					}
					else {
						var el = params.divTree.jqxRubrTree('getItem', params.treeNode);
						params.divTree.jqxRubrTree('addTo', {
							html: methods.getItemLabel({
								label: xmlElement.attr('descr'),
								xmlElement: xmlElement
							}), value: {loaded: false, hasQuery: false}
						}, el.parentElement);
						var lstLi = $(params.treeNode).parent().children();
						icons = $('#' + $(lstLi[lstLi.length - 1]).attr('id') + ' .spIcon:first');
					}
					var config = {first: true, icons: icons, alt: xmlElement.attr('descr')};
					xmlElement.children().each(function () {
						methods.parseTreeData($(this), config, xmlElement);
					});
					var contextMenu = $('#' + params.treeNode.id + ' .spContextIcons:first');
					$.each(xmlElement[0].attributes, function () {
						var itemKey = this.name,
							itemValue = this.value;
						contextMenu.children().each(function () {
							var dataItem = $(this).data('dataItem');
							if (dataItem != undefined)
								for (var i in dataItem)
									dataItem[i] = dataItem[i].replace(new RegExp('{' + itemKey + '}', 'g'), itemValue);
						});
					});
					break;

				case 'LineStyle':
					if (!params.first)return;
					//условие, если у парента есть polyStyle, то продолжаем парсить, чтобы найти polystyle
					if (parent != undefined && parent.children('PolyStyle').length > 0) {
						params.first = true;
					}
					else {
						params.first = false;
						xmlElement.children().each(function () {
							methods.parseTreeData($(this), params);
						});
						//меняем иконки в зависимости от ширины
						var lineWidth = 2;
						lineWidth = parseInt(params.width);
						var iconStyle = 'divIconLineStyle';
						//upd. 09.03.21 Принято решение ВЕЗДЕ! захардкодить в рубрикаторах показ жирной линии одного размера для читаемости
						//Замечание 20 из ПТГ
						//Падуков. Техсхема с планированием каптремонтов. Рубрикатор техсхемы с дефекностью  и капремонтами. Из-за каймы не читаются цвета. Убрать ее.
						iconStyle += '4';
						//если есть у линии канва
						/*if (lineWidth < 4)
							iconStyle += '';
						else if (lineWidth >= 4 && lineWidth < 8)
							iconStyle += '4';
						else
							iconStyle += '8';*/
						if (parent.children('LineStyle').length > 1) {
							iconStyle += 'Border';
						}
						if (params)
							params.icons.append('<div class="divIcon ' + iconStyle + '" style="background-color: ' + params.color + '"></div>');
					}
					break;
				case 'PolyStyle':
					if (!params.first)return;
					params.first = false;
					xmlElement.children().each(function () {
						methods.parseTreeData($(this), params);
					});
					//если нужна кайма, то забираем её из LineStyle
					var polystyleborder = 'border: 1px solid #000000;';
					if (params.outline == '1') {
						if (parent != undefined && parent.children('LineStyle').length > 0) {
							params.lineString = {};
							if (parent.children('LineStyle').length > 0) {
								//забираем 1-й линейный стиль
								$(parent.children('LineStyle')[0]).children().each(function () {
									methods.parseLineStyleData($(this), params.lineString);
								});
								//кайма для полигона
								if (params.lineString.color != undefined) {
									polystyleborder = 'border: 1px solid ' + params.lineString.color + ';';
								}
							}
						}
					}
					else {
						polystyleborder = '';
					}
					if (params.fill == '1') {
						var R = parseInt(params.fullColor.substring(2, 4), 16);
						var G = parseInt(params.fullColor.substring(4, 6), 16);
						var B = parseInt(params.fullColor.substring(6, 8), 16);
						var A = parseInt(params.fullColor.substring(0, 2), 16) / 255;
						//params.icons.append('<div class="divIcon divIconPolyStyle" style="background-color: '+params.color+'"></div>');
						params.icons.append('<div class="divIcon divIconPolyStyle" style="' + polystyleborder + ' background-color: rgba(' + R + ',' + G + ',' + B + ',' + A + ')"></div>');
					}
					else {
						//params.icons.append('<div class="divIcon divIconPolyStyle divIconPolyStyleBorder " ></div>');
						params.icons.append('<div class="divIcon divIconPolyStyle" style="' + polystyleborder + '" ></div>');
					}

					break;
				case 'Icon':
					if (!params.first)return;
					params.first = false;
					xmlElement.children().each(function () {
						methods.parseTreeData($(this), params);
					});
					if (params.href != undefined){
						//02.09.21 fix ie проблемы, что svg не получает корректные размеры
						if(params.href.indexOf('.svg') !== -1)
							params.href = params.href.replace('.svg', '.png');
						params.icons.append('<img src="' + params.href + '" alt="' + params.alt + '"/>');
					}

					break;
				case 'IconStyle':
					if (!params.first)return;
					xmlElement.children().each(function () {
						methods.parseTreeData($(this), params);
					});
					if ((params.form != undefined) & (params.form != 'bitmap'))
						params.icons.append('<div class="divIcon divIconStyle' + params.form + '" style="background-color: ' + params.color + '"></div>');
					break;
				case 'color':
					params['color'] = '#' + xmlElement.text().substr(2);
					params['fullColor'] = xmlElement.text();
					break;//полная строка с цветом и прозрачностью
				case 'fill':
					params['fill'] = xmlElement.text();
					break;
				case 'outline':
					params['outline'] = xmlElement.text();
					break;
				case 'width':
					params['width'] = xmlElement.text();
					break;
				case 'href':
					params['href'] = xmlElement.text();
					break;
				case 'form':
					params['form'] = xmlElement.text();
					break;
			}
		},
		parseLineStyleData: function (xmlElement, params, parent) {//вычленил функцию для отдельного парсинга линейного стиля
			switch (xmlElement[0].tagName) {
				case 'LineStyle':
					if (!params.first)return;
					//условие, если у парента есть polyStyle, то продолжаем парсить, чтобы найти polystyle
					if (parent != undefined && parent.children('PolyStyle').length > 0) {
						params.first = true;
					}
					else {
						params.first = false;
						xmlElement.children().each(function () {
							methods.parseTreeData($(this), params);
						});
						params.icons.append('<div class="divIcon divIconLineStyle" style="background-color: ' + params.color + '"></div>');
					}
					break;
				case 'color':
					params['color'] = '#' + xmlElement.text().substr(2);
					params['fullColor'] = xmlElement.text();
					break;//полная строка с цветом и прозрачностью
				case 'fill':
					params['fill'] = xmlElement.text();
					break;
				case 'outline':
					params['outline'] = xmlElement.text();
					break;
				case 'width':
					params['width'] = xmlElement.text();
					break;
			}
		},
		callbackFilter: function (params) {
			var value = '';
			var idArr = $('#' + this.attr('id') + ' .divTab.activeTab').attr('id');
			if (idArr == undefined) return {windowId: params.windowId, params: [{name: 'filter', value: value}]};
			var id = idArr.split('_')[0];
			$('#' + id + '_filters .divFilter').each(function () {
				value = value + $(this).myFilters('getFilterValuesString') + '|';
			});
			if (value != '') value = value.substr(0, value.length - 1);
			return {windowId: params.windowId, params: [{name: 'filter', value: value}]};
		},
		enableLayer: function (params) {
			var finded = false;
			$('#' + this.attr('id') + ' .divTree').each(function () {
				for (var i in params.params) {
					$('#' + this.id + '-' + params.params[i].value).each(function () {
						var el = $(this);
						if (el.jqxCheckBox('checked') == false) {
							el.jqxCheckBox('check');
							finded = true;
						}
					});
				}
			});
			return finded;
		},
		disableLayer: function (params) {
			$('#' + this.attr('id') + ' .divTree').each(function () {
				for (var i in params.params) {
					$('#' + this.id + '-' + params.params[i].value).each(function () {
						var el = $(this);
						if (el.jqxCheckBox('checked') == true) el.jqxCheckBox('uncheck');
					});
				}
			});
		},
		updateTopFilter: function (params) {
			var data = $($.parseXML(params.params)).children()[0];
			$('#' + this.attr('id') + ' .' + data.getAttribute('TOP_FILTER')).myFilters('updateTopFilter', {obj_ids: data.getAttribute('OBJ_IDS')});
		},
		callbackError: function (params) {
			var el = params.divTree.parent().parent().data('handlers');
			if (el.errorHandler != undefined) el.errorHandler(params);
			else {

				//alert(params.text);
			}
		},
		getScenarioVars: function (id) {
			var vars = undefined;
			/*$('#' + id + '_filters .divFilter').each(function () {
				var el = $(this);
				if (el.data('preopen') == el.data('filterid')) {
					vars = {};
					vars.variableName = el.data('filterid');
					vars.maxCnt = el.data('maxcnt');
					vars.dataProvider = el.data('dataprovider');
					vars.title = el.data('title');
				}
			});*/
			var radio = $('#' + id + '_checkBox');
			if (radio.length > 0) {
				vars = {
					openLayers: radio.data('openLayers'),
					openTables: radio.data('openTables'),
					topFilterSource: radio.data('topFilterSource'),
					middleFilterSource: radio.data('middleFilterSource'),
					openTableInterval: radio.data('openTableInterval'),
					filterType: radio.data('filterType'),
					/*данные для открытия грида*/
					openTableTitle: radio.data('openTableTitle'),
					openTableGridId: radio.data('openTableGridId'),
					openTableLevelParams: radio.data('openTableLevelParams'),
					querySource: radio.data('querySource'),
					queryLayerId: radio.data('queryLayerId'),
					queryFileName: radio.data('queryFileName')

				};
			}
			return vars;
		}
	};


	$.fn.myCategories = function (method) {
		if (methods[method]) {
			return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
		} else if (typeof method === 'object' || !method) {
			return methods.init.apply(this, arguments);
		} else {
			$.error('Method ' + method + ' does not exist on jQuery.fn.myCategories');
		}
	};
})(jQuery);
(function( $ ){
    var methods = {
        init : function( options ) {
            return this.each(function (){
                var handlers = {};
                if(options.handlers !== undefined)$.extend(handlers,options.handlers);
                var scenarioVars = {};
                if(options.scenarioVars !== undefined)$.extend(scenarioVars,options.scenarioVars);
                var el = $(this);
                el.data('handlers', handlers);
                el.data('scenarioVars',scenarioVars);
                el.data('needApply', false);
                el.data('infinite', !!options.infinite);//флаг, является ли фильтр с большим количеством данных, чтобы далее использовать заполнение через спец кнопку
                el.data('opener', options.opener);
                el.data('requestId', options.requestId);
                el.data('fromTree', options.fromTree === true);
	            el.data('loading',true);
                el.data('hideButtons', options.hideButtons);
                //объект со значениями, которые необходимо выбрать в списках
                var selectedItems = {};
                if(options.selectedItems !== undefined)$.extend(selectedItems,options.selectedItems);
                el.data('selectedItems',selectedItems);
                //доп. параметры, которые передаются в запрос в <data>
                if(options.addParams !== undefined)
                    el.data('addParams',options.addParams);
		        el.data('showLoader',options.showLoader === true);

                if(options.addText !== undefined)el.data('addtext','<div class="divTextFilter">'+options.addText+'</div>');
                else el.data('addtext','');
                if(options.dataSource !== undefined){
                    var getUserTasksParams = {
                        descrId: 'SYS_SEM.xml#GET_XML_FILE',
                        descrType: 'select',
                        data:'<root ><data FILE="../../Public/Modules/Form/'+options.dataSource+'.mxml"/></root>'
                    };
                    methods.serverQueryXmlFileNode(Services.processQueryNodeXml, getUserTasksParams,
                        methods.parseTopFilter,{el:el,divFilters:el});
                }
                if(options.dataXML !== undefined) {
                    var xmlData = $.parseXML(options.dataXML);
                    $(xmlData).children().each(function(){methods.parseTopFilter($(this),{el:el,divFilters:el});});
                }
            });
        },
        serverQueryXmlFileNode:function(url,params,callbackResult,thisObject) {
            if(thisObject.divFilters === undefined)
                methods.callbackError({text:gis_filters_1});
            App.serverQueryXmlFileNodeWithTries(url, params, function(data){
                var er = HTTPServiceUtil.getError(data);
                if (er !== ''){
                    if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
                        methods.callbackError({
                            text: gis_core_error_1 + '. ' + params.data + '.filter_serverQueryXmlFileNode success error. ' + data + '. ',
                            divFilters: thisObject.divFilters
                        });
                    return;
                }
                try{
                        var xmlData = $.parseXML(data);
                        $(xmlData).children().each(function(){callbackResult($(this),thisObject);});
                    }catch(ex){
                        methods.callbackError({text:gis_core_error_1 + '. ' + params.data + '. filter_serverQueryXmlFileNode. success. '+ex.message,divFilters:thisObject.divFilters});}
                }, function(data){
                        methods.callbackError({
                            text: gis_core_error_1 + '. ' + params.data + '.filter_serverQueryXmlFileNode. ' + data + '. ',
                            divFilters: thisObject.divFilters
                        });
                    },undefined);
                },
        serverQueryXML1:function(url,params,callbackResult,thisObject) {
             url = App.formatNodeServiceUrl(url);
            if(thisObject.divFilters === undefined)
                methods.callbackError({text:gis_filters_1});
            BlockingUtil.wait();
            App.serverQueryXmlFileNodeWithTries(url, params, function(data){
                BlockingUtil.ready();
                var er = HTTPServiceUtil.getError(data);
                if (er !== ''){
                    if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
                        methods.callbackError({
                            text: gis_core_error_1 + '. ' + params.data + '.filter_serverQueryXML1 success error. ' + data + '. ',
                            divFilters: thisObject.divFilters
                        });
                    return;
                }
                try{
                    //var layerGeoXml = ($.parseXML(data)).firstChild;
                    //var datas = layerGeoXml.getElementsByTagName("root");
                    var datas = $($.parseXML(data)).find("root");
                    callbackResult($(datas),thisObject);
                }
                catch(ex){
                    if(ex.message.indexOf('Invalid jQuery Selector') === -1){//если не ошибка поиска селектора(закрыли панель раньше прихода данных)
                        if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
                            methods.callbackError({text:gis_core_error_1+ '. request:' + params.data + '.filter_serverQueryXML1. success. catch:' + ex.message+'; response:'+data, divFilters:thisObject.divFilters});
                    }
                }
            }, function(data){
                BlockingUtil.ready();
                if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
                    methods.callbackError({
                        text: gis_core_error_1 + '. ' + params.data + '.filter_serverQueryXML1. fail' + data + '. ',
                        divFilters: thisObject.divFilters
                    });
            }, undefined);
        },
        callbackError: function(params){
            var el = params.divFilters.data('handlers');
            var loading = params.divFilters.data('loading');
            if(loading !== undefined)
	            params.divFilters.data('loading', false);
	        if(params.parentParams !== undefined && params.parentParams.showLoader === true)
		        BlockingUtil.ready();
            if(el && el.errorHandler !== undefined)
                el.errorHandler(params);
            else{
                App.errorReport(gis_core_error_1, params.text, undefined, {filename:gis_filename_569, functionname:'gis_filename_569_1'});
            }
            /*else
                alert(params.text);*/
        },
        parseTopFilter: function(xmlElement,divObject){
            switch(xmlElement[0].tagName){
                case 'mx:VBox':xmlElement.children().each(function(){methods.parseTopFilter($(this),divObject.el);});break;
                case 'components:FilterPopUpButton':
                    var addTitle = '(0)',
                        checkDefault = false,
                        isDropDown = true,
                        maxCnt = '-1',
                        minCnt = 1,
                        dataProvider = '',
                        idElement = 'w'+methods.getUniqueId()+'_'+xmlElement.attr('id'),
                        addText = divObject.data('addtext');
                    if(xmlElement.attr('maxCnt') !== undefined)maxCnt=xmlElement.attr('maxCnt');
                    if(xmlElement.attr('minCnt') !== undefined)minCnt=xmlElement.attr('minCnt');
                    if(xmlElement.attr('isDropDown') !== undefined)isDropDown = xmlElement.attr('isDropDown') == 'true';
                    if(xmlElement.attr('dataProvider') !== undefined)dataProvider = xmlElement.attr('dataProvider');
                    if((xmlElement.attr('selectAllElements') === undefined)||(xmlElement.attr('selectAllElements') == 'true')){
                        addTitle = gis_filters_3;
                        checkDefault = true;
                    }
                    else{
                        if(maxCnt != '-1')addTitle = gis_filters_4+maxCnt+')';
                    }
                    if((divObject.data('fromTree') || divObject.data('infinite')) && dataProvider){
                        FilterSourceDataManager[dataProvider] = {
                            selectAllElements: checkDefault
                        };
                    }
                    if((addText == '')&&(maxCnt != '-1')){
                        if(isDropDown == false)
                            addText = '<div class="divTextMiddleFilter" style="display:inline;position:absolute">Убедитесь, что количество выбранных элементов не превышает '+maxCnt+'</div>';
                        else
                            addText = '<div class="divTextFilter" style="display:inline;">Убедитесь, что количество выбранных элементов не превышает '+maxCnt+'</div>';
                    }
	                var datapreopen = '';
                    if(divObject.data('handlers')!==undefined && divObject.data('handlers').checkHeadRadioHandler !==undefined){
                        var vars = {};
                        vars.maxCnt = maxCnt;
                        vars.dataProvider = dataProvider;
                        vars.title = xmlElement.attr('title');
                        vars.variableName = xmlElement.attr('id');
                        if(divObject.data('scenarioVars') !== undefined)$.extend(vars,divObject.data('scenarioVars'));
                        var result = {vars:vars};
                        //костыль. чтобы не вызывался сценарий повторно при след парсинге
                        if(divObject.data('isHeadRadio') != true)
                            divObject.data('handlers').checkHeadRadioHandler(result);
                        divObject.data('isHeadRadio',true);
	                    datapreopen = 'data-preopen="'+divObject.data('preopen')+'"';
                    }
                    var filterDiv = '';
                    var isInfinite = divObject.data('infinite');
                    var fromTreeClass = (divObject.data('fromTree'))?'treeFilter':'';
                    var hideButtons = divObject.data('hideButtons');
                    var hideCancel = 'inline-block', hideApply = 'inline-block';
                    if (hideButtons) {
                        if (hideButtons.indexOf('cancel') !== -1)
                            hideCancel = 'none';
                        else if (hideButtons.indexOf('apply') !== -1)
                            hideApply = 'none';
                    }
                    var lightWeightButton = '';

                    if(!isDropDown) {
                        filterDiv = $('<div id="'+idElement+'" class="divFilter '+xmlElement.attr('id')+'" '+datapreopen+' data-filterid="'+ xmlElement.attr('id')+'" data-title="'+ xmlElement.attr('title')+'" data-dataprovider="'+dataProvider+'" data-getdata=true data-maxcnt='+maxCnt+' data-mincnt='+minCnt+' data-isdropdown='+isDropDown+'>\
                           <div>'+xmlElement.attr('title')+addTitle+'</div>\
                           <div>\
                            <div class="divFilterContent">\
                             <input type="text" id="'+idElement+'_input" data-lastvalue="" class="iFilterSearch"/>\
                             <div id="'+idElement+'_listCheckBoxes" data-checkdefault='+checkDefault+' class="divListCheckBoxes"></div>\
                             <div style="height: 35px;">\
                              <div class="divCheckAllMiddle">\
                               <div id="'+idElement+'_checkAll" class="myCheckBox" data-recalc=1 style="display:inline;"> </div>\
                              </div>\
                              <div class="myCheckBoxMiddle" style="display:inline">Выбрать все</div>\
                              <input type="button" value="Применить" id="'+idElement+'_apply" class="myButton filterButton" style="display: '+hideApply+';"/>\
                              <input type="button" value="Отмена" id="'+idElement+'_cancel" class="myButton filterButton" style="display: '+hideCancel+';"/>'+addText+'\
                             </div>\
                            </div>\
                           </div>\
                          </div>');
                    }
                    else {
                        filterDiv = $('<div id="'+idElement+'" class="divFilter '+xmlElement.attr('id')+'" '+datapreopen+' data-filterid="'+ xmlElement.attr('id')+'" data-title="'+ xmlElement.attr('title')+'" data-dataprovider="'+dataProvider+'" data-getdata=true data-maxcnt='+maxCnt+' data-mincnt='+minCnt+' data-isdropdown='+isDropDown+'>\
                           <div>'+xmlElement.attr('title')+addTitle+'</div>\
                           <div>\
                            <div class="divFilterContent '+fromTreeClass+'">\
                             <input type="text" id="'+idElement+'_input" data-lastvalue="" class="iFilterSearch"/>\
                             <div id="'+idElement+'_listCheckBoxes" data-checkdefault='+checkDefault+' class="divListCheckBoxes"></div>\
                             <div>\
                              <div class="divCheckAll">\
                               <div id="'+idElement+'_checkAll" class="myCheckBox" data-recalc=1>Выбрать все</div>\
                              </div>\
                              <input type="button" value="Применить" id="'+idElement+'_apply" class="myButton filterButton"/>\
                              <input type="button" value="Отмена" id="'+idElement+'_cancel" class="myButton filterButton"/>\
                             </div>'+addText+'\
                            </div>\
                           </div>\
                          </div>');
                    }
                    divObject.append(filterDiv);
                    if(isInfinite){
                        lightWeightButton = '<div style="padding-bottom: 3px;">' +
                                '<div  id="'+idElement+'_lightweightcombo" class="divFilter__fake jqx-widget-header">' +
                                xmlElement.attr('title') + addTitle +
                                '</div>' +
                                '<div id="'+idElement+'_lightweight" class="divFilter__fake-button" ></div>' +
                            '</div>';
                        divObject.append(lightWeightButton);
                    }
                    $('#'+idElement+'_apply').jqxButton({disabled:true}).on('click',function(){
                        var successApply = true;
                        if(filterDiv.data('isdropdown')){
                            //устанавливаем флаг, что именно после этой кнопки надо применять фильтр
                            filterDiv.parent().data('needApply',true);
                            filterDiv.jqxExpander('collapse');
                        }
                        else{
                            //если средний фильтр, то перед выполнением функции applyHandler сначала применяем его, чтобы корректно getSelectedItems вызывался
                            successApply = methods.applyFilter({idFilter:idElement,filterDiv:filterDiv});
                        }
                        if(successApply !== false){
                            var handlers = filterDiv.parent().data('handlers');
                            if(handlers.applyHandler !== undefined)handlers.applyHandler(filterDiv.parent());
                        }
                    });
                    $('#'+idElement+'_cancel').jqxButton({disabled:false}).on('click',function(){
                        methods.cancelEditFilter({idFilter:idElement,filterDiv:filterDiv});
                        if(filterDiv.data('isdropdown')){
                            filterDiv.parent().data('needApply',true);
                            filterDiv.jqxExpander('collapse');
                        }
                        var handlers = filterDiv.parent().data('handlers');
                        if(handlers.cancelHandler !== undefined)
                            handlers.cancelHandler(filterDiv.parent());
                    });
                    $('#'+idElement+'_checkAll').jqxCheckBox({rtl:true,checked:checkDefault,disabled:true,theme:''})
                        .on('checked',function(event){
                            methods.filterCheckAll({event:event,idElement:idElement,checkBoxAll:$(this)});
                        })
                        .on('unchecked',function(event){
                            methods.filterCheckAll({event:event,idElement:idElement,checkBoxAll:$(this)});
                        });
                    $('#'+idElement+'_input').jqxInput({placeHolder: gis_filters_5,width: '100%',disabled:true,theme:'myCommon'})
                        .keyup(function(event){
                            //16-shift, 17-ctrl, 8-backspace, 46-del
                            if((event.keyCode!=16 && event.keyCode!=17 && event.keyCode!=18))
                                methods.inputSearchCheckBoxes({input:$(this),idFilter:idElement});
                    });
                    var addParams = filterDiv.parent().data('addParams');
                    var showLoader = filterDiv.parent().data('showLoader');
                    methods.loadFilterContent({showLoader:showLoader, filterDiv:filterDiv,xmlElement:xmlElement,addParams:addParams});

                    var expParams = {width: '100%',expanded: !isDropDown,theme:'myCommon'};

                    if(isInfinite){
                        $.extend(expParams,{disabled:true,width:'95%', showArrow:false})
                        $('#'+idElement+'_lightweight').on('click',function() {
                            FilterUtil.showLightWeightFilter({
                                filterId: idElement,
                                requestId: filterDiv.parent().data('requestId'),
                            });
                        });
                        $('#'+idElement+'_lightweightcombo').on('click',function() {
                            FilterUtil.showLightWeightFilter({
                                filterId: idElement,
                                requestId: filterDiv.parent().data('requestId'),
                            });
                        });
                        //filterDiv.css('display','inline-block');
                        filterDiv.css('display','none');
                    }
                    if(!isDropDown)$.extend(expParams,{expandAnimationDuration:0,collapseAnimationDuration:0, showArrow:false});
                    filterDiv.jqxExpander(expParams).on('expanding',function(){
                        //раскрывая один фильтр, прячем остальные
                        $('.divFilter').each(
                            function(){
                                var el = $(this);
                                if(el.jqxExpander('expanded'))
                                    el.jqxExpander('collapse');
                            });
                        //Вызываем callback при сворачивании/разворачивании списка
                        var handlers = filterDiv.parent().data('handlers');
                        if(handlers.dropDownOpenCallback != undefined)
                            handlers.dropDownOpenCallback({filterDiv:filterDiv, expanded:true});

                    }).on('collapsed',function(){
                        if(!filterDiv.data('isdropdown'))filterDiv.jqxExpander('expand');
                        else {
                            if(filterDiv.parent().data('needApply') == true)
                                methods.applyFilter({idFilter:idElement,filterDiv:filterDiv});
                            else
                                methods.cancelEditFilter({idFilter:idElement,filterDiv:filterDiv});
                            filterDiv.parent().data('needApply',false);
                            //Вызываем callback при сворачивании/разворачивании списка
                            var handlers = filterDiv.parent().data('handlers');
                            if(handlers.dropDownOpenCallback != undefined)
                                handlers.dropDownOpenCallback({filterDiv:filterDiv, expanded:false});
                        }
                    });
                    //if(!isDropDown)$('#'+idElement+' .jqx-expander-header').addClass('noVisible');
                    break;
            }
        },
        filterCheckAll:function(params){
            if(params.checkBoxAll.data('skip') == true){
                params.checkBoxAll.data('skip',false);
                return;
            }

            //TODO пописать удаление из checked в эдит боксе
            var list = $('#'+params.idElement+'_listCheckBoxes');
            $('#'+params.idElement+'_input').data('lastchecked',list.data('lastchecked').slice());
            if(params.checkBoxAll.data('recalc') == 1){
                var funcName = 'clearSelection';
                var allitems = list.data('currentCodes');//забираем текущие коды
                var lastchecked =  $('#'+params.idElement+'_input').data('lastchecked');
                if(params.event.type =='checked'){
                    lastchecked = allitems;
                    funcName = 'checkAll';
                }
                else{
                    lastchecked = [];
                    funcName = 'uncheckAll';
                }
                $('#'+params.idElement+'_input').data('lastchecked',lastchecked);
                //сначала отписываемся, чтобы установить все, а затем опять подписываемся на события
                if(list.length != 0){
                    list.data('isSingle',false);
                    list.data('recalc',0).data('applyfilter',false).jqxListBox(funcName);
                    list.data('isSingle',true);
                }
                methods.recalcFilterView({idFilter:params.idElement,recalcAll:false,fromSelectAll:true});
            }
            else
                params.checkBoxAll.data('recalc',1);

        },
        parseTopFilterContent: function(xmlElement,params){
        	//устанавливаем флаг, что загрузка данных завершгена
	        var filterDiv = params.divObject.parent().data('loading');
	        if(filterDiv !== undefined)
		        params.divObject.parent().data('loading',false);
            var isInfinite = params.divObject.parent().data('infinite');
            if(isInfinite){
                var handlers = params.divObject.parent().data('handlers');
                var requestId = params.divObject.parent().data('requestId');
                if(handlers.infiniteCallback != undefined)
                    handlers.infiniteCallback(xmlElement, requestId);
                return;
            }
            switch(xmlElement[0].tagName){
                case 'root':
                    var childrenLen = xmlElement.children().length;
                    var idFilter = params.divObject.attr('id');
                    var resArr = [];
                    if(childrenLen != 0){//TODO добавить проверку на существование $('#'+idFilter+'_listCheckBoxes'), когдп пришел результат(например, закрыли форму)
                        var divListCheckBoxes = $('#'+idFilter+'_listCheckBoxes'),
                            maxCnt = params.divObject.data('maxcnt'),
                            checked = divListCheckBoxes.data('checkdefault');
                        divListCheckBoxes.addClass('divListCheckBoxes');
                        var resStrArr = [];//массив из строковых кодов
                        var filters = params.divObject.data('slicefilters');

                        if(filters !== undefined && filters !== ''){
                            var ids = filters.split(',');
                            xmlElement.children().each(function(index){
                                //Проверяем есть ли в полученном объекте и CODE и DESCR - и только если есть оба поля, добавляем в список (аналогично флешовому QueryDataProvider)
                                var curCode = $(this).attr('CODE');
                                var curDescr = $(this).attr('DESCR');
                                //#1943 upd. Еслди не пришло descr, то заполняем его ''
	                            if(curDescr === undefined)curDescr = '';
                                if (curCode !== undefined && curDescr !== undefined) {
                                    var j = 0;
                                    for(; j<=ids.length-1; j++){
                                        if(ids[j] === curCode){
                                            resArr.push({CODE:curCode,DESCR:curDescr});
                                            resStrArr.push(curCode);
                                            break;
                                        }
                                    }
                                }
                            });
                        }
                        else{
                            xmlElement.children().each(function(index){
                                //Проверяем есть ли в полученном объекте и CODE и DESCR - и только если есть оба поля, добавляем в список (аналогично флешовому QueryDataProvider)
                                var curCode = $(this).attr('CODE');
                                var curDescr = $(this).attr('DESCR');
	                            //#1943 upd. Еслди не пришло descr, то заполняем его ''
	                            if(curDescr === undefined)curDescr = '';
                                if (curCode !== undefined && curDescr !== undefined) {
                                    resArr.push({CODE:curCode,DESCR:curDescr});
                                    if(maxCnt == -1)
                                        resStrArr.push(curCode);
                                }
                            });
                        }

                        divListCheckBoxes.jqxListBox({ source: resArr,checkboxes: true, itemHeight:21,
                            displayMember: "DESCR", valueMember: "CODE",width:'100%',height:'100%',
                            theme:'filter',
                            renderer: function (index, label, value) {
                                var table = '<div class="spFilterIndex">['+(index+1)+']</div><span class="spDescr">'+label+'</span></div>';
                                return table;
                            }
                        });
                        divListCheckBoxes.data('allCodes',resStrArr.slice()).data('currentCodes',resStrArr.slice());
                        $('#'+idFilter+'_input').data('lastchecked',resStrArr.slice());//сохраняем все текущие коды
                        divListCheckBoxes.data('lastchecked',resStrArr.slice());
                        if(checked){
                            divListCheckBoxes.data('applyfilter',true);
                            divListCheckBoxes.jqxListBox('checkAll');
                        }
                        else{
                            $('#'+idFilter+'_input').data('lastchecked',[]);//сохраняем все текущие коды
                            divListCheckBoxes.data('lastchecked',[]);
                        }
                        divListCheckBoxes.data('items',resArr);
                        divListCheckBoxes.data('checkedItems',divListCheckBoxes.jqxListBox('getCheckedItems'));
                        divListCheckBoxes.data('isSingle',true);
                        divListCheckBoxes.on('checkChange', function (event) {
                            if(divListCheckBoxes.data('isSingle') == true){
                                //$('#'+idFilter+'_input').data('lastchecked',divListCheckBoxes.jqxListBox('getCheckedItems'));
                                if(event.args != undefined && event.args){
                                    var lastchecked = $('#'+idFilter+'_input').data('lastchecked');
                                    if(event.args.checked == true){
                                        var index = lastchecked.indexOf(event.args.value);
                                        if(index==-1)
                                            lastchecked.push(event.args.value);
                                    }
                                    else{
                                        var index = lastchecked.indexOf(event.args.value);
                                        if(index!=-1)
                                            lastchecked.splice(index, 1);
                                    }
                                    $('#'+idFilter+'_input').data('lastchecked',lastchecked);
                                }
                                methods.recalcFilterView({idFilter:idFilter,recalcAll:false});
                                //если выбрали все, выставляем чекбокс
                                if(divListCheckBoxes.jqxListBox('getCheckedItems').length ==  divListCheckBoxes.data('items').length) {
                                    $('#' + idFilter + '_checkAll').data('skip', true);
                                    $('#' + idFilter + '_checkAll').jqxCheckBox('check');
                                }
                                else{
                                    //и снимаем checked
                                    $('#'+idFilter+'_checkAll').data('skip',true);
                                    $('#'+idFilter+'_checkAll').jqxCheckBox('uncheck');
                                }
                                divListCheckBoxes.data('applyfilter',false);
                            }
                        });
                        //var filters = params.divObject.data('slicefilters');
                        //if(filters != undefined)
                        //    methods.setTopFilterSlice({objIds:filters,id: idFilter});
                        filters = params.divObject.data('filters');
                        if(filters !== undefined)
                            methods.setTopFilterValues({objIds:filters,id: idFilter});
                        if((maxCnt != -1)&&(checked == true)&&(maxCnt < childrenLen)){
                            var textTitle = params.divObject.jqxExpander('getHeaderContent').split('(');
                            params.divObject.jqxExpander('setHeaderContent',textTitle[0]+'('+childrenLen+gis_filters_6+maxCnt+')');
                            params.divObject.addClass('divBadFilter');
                        }
                    }

                    //вызов колбек функц
                    var selectedItems = params.divObject.parent().data('selectedItems');
                    //забираем название поля
                    var dataField = idFilter.substr(idFilter.indexOf('_')+1);
                    if(selectedItems != undefined && selectedItems[dataField] != undefined && selectedItems[dataField].lastSelected != undefined){
                        var filterArr = [];
                        for(var i=0; i<selectedItems[dataField].lastSelected.length;i++){
                            filterArr.push(selectedItems[dataField].lastSelected[i].CODE);
                        }
                        var filterStr = filterArr.join(',');
                        methods.setTopFilterValues({objIds:filterStr,id: idFilter});
                    }
                    params.divObject.data('getdata',false);
                    if(resArr.length > 0){
                        $('#'+idFilter+'_apply').jqxButton({disabled:false});
                        $('#'+idFilter+'_checkAll').jqxCheckBox({disabled:false,theme:'myCommon'});
                    }
                    $('#'+idFilter+'_cancel').jqxButton({disabled:false});
                    $('#'+idFilter+'_input').jqxInput({disabled:false,theme:'myCommon'});
                    break;
            }
        },
        parseLpuFilterContent: function(params){
            //устанавливаем флаг, что загрузка данных завершгена
            var filterDiv = params.divObject.parent().data('loading');
            if(filterDiv !== undefined)
                params.divObject.parent().data('loading',false);
            var idFilter = params.divObject.attr('id');
            var divListCheckBoxes = $('#'+idFilter+'_listCheckBoxes'),
                checked = divListCheckBoxes.data('checkdefault');
            divListCheckBoxes.addClass('divListCheckBoxes');
            var resArr = [];
            var resStrArr = [];//массив из строковых кодов

            params.lpuValues.forEach(function(item){
                resArr.push(item);
                resStrArr.push(item.CODE);
            });
            params.divObject.data('codetype',undefined);
            divListCheckBoxes.jqxListBox({ source: resArr,checkboxes: true, itemHeight:21,
                displayMember: "DESCR", valueMember: "CODE",width:'100%',height:'100%',
                theme:'filter',
                renderer: function (index, label, value) {
                    var table = '<div class="spFilterIndex">['+(index+1)+']</div><span class="spDescr">'+label+'</span></div>';
                    return table;
                }
            });
            divListCheckBoxes.data('allCodes',resStrArr.slice()).data('currentCodes',resStrArr.slice());
            $('#'+idFilter+'_input').data('lastchecked',resStrArr.slice());//сохраняем все текущие коды
            divListCheckBoxes.data('lastchecked',resStrArr.slice());
            if(checked){
                divListCheckBoxes.data('applyfilter',true);
                divListCheckBoxes.jqxListBox('checkAll');
            }
            divListCheckBoxes.data('items',resArr);
            divListCheckBoxes.data('checkedItems',divListCheckBoxes.jqxListBox('getCheckedItems'));
            divListCheckBoxes.data('isSingle',true);
            divListCheckBoxes.on('checkChange', function (event) {
                if(divListCheckBoxes.data('isSingle') == true){
                    //$('#'+idFilter+'_input').data('lastchecked',divListCheckBoxes.jqxListBox('getCheckedItems'));
                    if(event.args != undefined && event.args){
                        var lastchecked = $('#'+idFilter+'_input').data('lastchecked');
                        if(event.args.checked == true){
                            var index = lastchecked.indexOf(event.args.value);
                            if(index==-1)
                                lastchecked.push(event.args.value);

                        }
                        else{
                            var index = lastchecked.indexOf(event.args.value);
                            if(index!=-1)
                                lastchecked.splice(index, 1);
                        }
                        $('#'+idFilter+'_input').data('lastchecked',lastchecked);
                    }

                    methods.recalcFilterView({idFilter:idFilter,recalcAll:false});
                    //если выбрали все, выставляем чекбокс
                    if(divListCheckBoxes.jqxListBox('getCheckedItems').length ==  divListCheckBoxes.data('items').length) {
                        $('#' + idFilter + '_checkAll').data('skip', true);
                        $('#' + idFilter + '_checkAll').jqxCheckBox('check');
                    }
                    else{
                        //и снимаем checked
                        $('#'+idFilter+'_checkAll').data('skip',true);
                        $('#'+idFilter+'_checkAll').jqxCheckBox('uncheck');
                    }
                    divListCheckBoxes.data('applyfilter',false);
                }
            });

            //вызов колбек функц
            var selectedItems = params.divObject.parent().data('selectedItems');
            //забираем название поля
            var dataField = idFilter.substr(idFilter.indexOf('_')+1);
            if(selectedItems != undefined && selectedItems[dataField] != undefined && selectedItems[dataField].lastSelected != undefined){
                var filterArr = [];
                for(var i=0; i<selectedItems[dataField].lastSelected.length;i++){
                    filterArr.push(selectedItems[dataField].lastSelected[i].CODE);
                }
                var filterStr = filterArr.join(',');
                methods.setTopFilterValues({objIds:filterStr,id: idFilter});
            }
            params.divObject.data('getdata',false);
            $('#'+idFilter+'_apply').jqxButton({disabled:false});
            $('#'+idFilter+'_cancel').jqxButton({disabled:false});
            $('#'+idFilter+'_checkAll').jqxCheckBox({disabled:false,theme:'myCommon'});
            $('#'+idFilter+'_input').jqxInput({disabled:false,theme:'myCommon'});
        },
        loadFilterContent:function(params){
            //грузим контент фильтра
            var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
            var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
            var dataStr = '<data/>';
            if(params.addParams!== undefined)
                dataStr = params.addParams;
            //ХАРДКОД. Если фильтр ЛПУ, то забираем его из того, что пришло после PRELOAD.xml
            if(WidgetMap && WidgetMap.preloadLpuValues !== undefined && params.xmlElement.attr('id') === 'LPU_ACCESS_FILTER'){
                methods.parseLpuFilterContent({
                    lpuValues: WidgetMap.preloadLpuValues,
                    divObject: params.filterDiv,
                    divFilters: $('#' + params.filterDiv.attr('id').split('_')[0] + '_tree')
                })
            }
            else{
                //upd.16.04.21 принято решениие для ЭХЗ убрать лоадер. Если будет неудобно - вернуть
                /*if(params.showLoader === true)
                    BlockingUtil.wait();*/
                //TDDO хардкод. Убрать! для задачи су тс тпа нужно подгружать справочники через запрос process-xml
                var serviceName = Services.processQueryNode;
                methods.serverQueryXML1(serviceName,
                    {showLoader:params.showLoader,
                        descrId:params.xmlElement.attr('dataProvider'),
                        descrType:'select',
                        getSchema:true,
                        toElements:false,
                        data:'<root USER_ID="'+userId.xmlEscape()+
                            '" USER_LOGIN="'+userLogin.xmlEscape()+
                            '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
                            dataStr +
                            '</root>'},
                    methods.parseTopFilterContent,{divObject: params.filterDiv,
                        divFilters: $('#'+params.filterDiv.attr('id').split('_')[0]+'_tree')});

            }
        },
        inputSearchCheckBoxes:function(params){
            var value = params.input.val().toLowerCase(),
                oldvalue = params.input.data('lastvalue'),
                listBox = $('#'+params.idFilter+'_listCheckBoxes'),
                lstCheckBoxes = listBox.jqxListBox('getItems'),
                newChecked = listBox.jqxListBox('getCheckedItems');

            var items = listBox.data('items');
            var lstChecked = [];
            if(items.length != newChecked.length){
                lstChecked = newChecked;
            }
            else{
                params.input.data('lastchecked',[]);
            }
            if(oldvalue == value && value == ''){
                return;
            }
            var lastchecked = params.input.data('lastchecked');
            params.input.data('lastvalue',value);
            var newArr = [];

            //listBox.jqxListBox('findItems','АГРС')
            if(value != ''){
                listBox.jqxListBox('clear');
                var currCodes = [];
                for(var i in items){
                    if(items[i].DESCR.toLowerCase().indexOf(value) != -1){
                        newArr.push(items[i]);
                        currCodes.push(items[i].CODE);
                    }
                }

                listBox.jqxListBox({source:newArr});
                listBox.data('currentCodes',currCodes);
                if(lastchecked.length>0){//если были выбраны с прошлого поиска, то их применяем
                    for(var a = 0; a <= newArr.length-1; a++ ){
                        for(var i=0; i <= lastchecked.length-1; i++){
                            if(lastchecked[i] == newArr[a].CODE)
                                listBox.jqxListBox('checkIndex', a );
                        }
                    }
                }
                methods.recalcFilterView({idFilter:params.idFilter,recalcAll:false, fromSearch:true});
            }
            else{
                listBox.jqxListBox({source:items});
                listBox.data('currentCodes',listBox.data('allCodes'));
                if(lstChecked.length>0){
                    for(var a = 0; a <= items.length-1; a++ ){
                        for(var i=0; i <= lastchecked.length-1; i++){
                            if(lastchecked[i] == items[a].CODE)
                                listBox.jqxListBox('checkIndex', a );
                        }
                    }
                }
                else{
                    methods.recalcFilterView({idFilter:params.idFilter,recalcAll:false, fromSearch:true});
                    if(lstChecked.length == 0)
                        methods.cancelEditFilter(params);
                }
            }
            if(listBox.data('currentCodes').length ==  listBox.data('allCodes').length)
                $('#'+params.idFilter+'_checkAll').jqxCheckBox('enable');
            else{
                $('#'+params.idFilter+'_checkAll').jqxCheckBox('disable');
                //и снимаем checked
                $('#'+params.idFilter+'_checkAll').data('skip',true);
                $('#'+params.idFilter+'_checkAll').jqxCheckBox('uncheck');
            }
        },
        cancelEditFilter:function(params){
            var list = $('#'+params.idFilter+'_listCheckBoxes');
            list.data('recalc',0);
            var checkedItems = list.data('lastchecked');
            var items = list.data('items');
            //раздизейбливаем чекбокс "выбрать все"
            $('#'+params.idFilter+'_checkAll').jqxCheckBox('enable');
            list.data('applyfilter',true);
            if(items && items.length < 500)
                list.jqxListBox({source:items});
            list.data('isSingle',false);
            var currentCodes = [];
            var ii=0;
            //если изначально список пустой
            if(items != undefined){
                for(; ii<=items.length-1; ii++){
                    currentCodes.push(items[ii].CODE);
                }
                if(items.length < 500){
                    for(var a = 0; a<=checkedItems.length-1; a++ ){
                        for(var i=0; i<=items.length-1; i++){
                            if(items[i].CODE == checkedItems[a])
                                list.jqxListBox('checkIndex', i );
                        }
                    }
                }

            }
            list.data('currentCodes',currentCodes);
            list.data('isSingle',true);
            $('#'+params.idFilter+'_input').val('');
            methods.recalcFilterView({idFilter:params.idFilter,recalcAll:false,fromCancel:true});
            if((list.data('lastchecked') != undefined && list.data('lastchecked').length ==  list.data('allCodes').length) && list.data('lastchecked').length!=0)
                $('#'+params.idFilter+'_checkAll').data('recalc',0).jqxCheckBox('check');
            else
                $('#'+params.idFilter+'_checkAll').data('recalc',0).jqxCheckBox('uncheck');
        },
        applyFilter:function(params){
            if($('#'+params.idFilter+'_apply').jqxButton('disabled')) return ;
            if($('#'+params.idFilter).hasClass('divBadFilter')){
                methods.cancelEditFilter(params);
                methods.recalcFilterView({idFilter:params.idFilter,recalcAll:true});
                return ;
            }
            var list = $('#'+params.idFilter+'_listCheckBoxes');
            var items = list.data('items');
            //раздизейбливаем чекбокс "выбрать все"
            $('#'+params.idFilter+'_checkAll').jqxCheckBox('enable');
            var checkedItems = $('#'+params.idFilter+'_input').data('lastchecked');//list.data('lastchecked');//list.jqxListBox('getCheckedItems');

            list.data('checkedItems',checkedItems).data('applyfilter',true);
            if(items && items.length < 500)
                list.jqxListBox({source:items});
            list.data('isSingle',false);
            var currentCodes = [];
            var ii=0;
            if(items != undefined){
	            for(; ii<=items.length-1; ii++){
		            currentCodes.push(items[ii].CODE);
	            }
                var lastchecked = [];
                if(items.length < 500) {
                    for (var a = 0; a <= checkedItems.length - 1; a++) {
                        for (var i = 0; i <= items.length - 1; i++) {
                            if (items[i].CODE == checkedItems[a]) {
                                list.jqxListBox('checkIndex', i);
                                lastchecked.push(items[i].CODE);
                            }
                        }
                    }
                }
                else
                    lastchecked = checkedItems;
			}
            if(lastchecked != undefined){
	            $('#'+params.idFilter+'_input').data('lastchecked',lastchecked.slice());
	            list.data('lastchecked',lastchecked.slice());
            }

            //('#'+params.idFilter+'_checkAll').data('recalc',1);
            //возвращаем после применения все элементы, как текущие коды
            list.data('currentCodes',currentCodes);
            $('#'+params.idFilter+'_input').val('');
            list.data('isSingle',true);
            if(checkedItems.length === 0 ) return false;
        },
        recalcFilterView:function(params){
            var divFilter = $('#'+params.idFilter),
                title = divFilter.jqxExpander('getHeaderContent').split('('),
                listBox = $('#'+params.idFilter+'_listCheckBoxes'),
                input = $('#'+params.idFilter+'_input').data('lastchecked'),
                cntChecked = (listBox.jqxListBox('getCheckedItems') != undefined)?listBox.jqxListBox('getCheckedItems').length:0,
                listCheckBoxes = listBox.jqxListBox('getItems'),
                listLastChecked = listBox.data('lastchecked'),
                allCodes = (listBox.data('allCodes') != undefined)?listBox.data('allCodes'):[],
                fromSearch = params.fromSearch,//если пришел запрас на пересчет из поля текстового
                fromCancel = params.fromCancel,
                fromSelectAll = params.fromSelectAll,//от кнопки "отмена"
                maxCnt = divFilter.data('maxcnt'),
                minCnt = divFilter.data('mincnt'),
                addTitle = '';
            if(fromCancel == true && listLastChecked!=undefined)
                cntChecked = listLastChecked.length;
            else if(fromSelectAll == true){
                cntChecked = cntChecked;
            }
            else{
                //если в списке все записи
                if(listBox.data('items') != undefined && listCheckBoxes.length != listBox.data('items').length)
                    cntChecked = input.length;
            }

            //if(fromSearch == true && input != undefined){

            //}
            if(params.addCheck != undefined)cntChecked=cntChecked+params.addCheck;
            if((cntChecked < minCnt)&(params.recalcAll == true)){
                cntChecked = listCheckBoxes.length;
                if(listCheckBoxes.length != 0)listCheckBoxes/*.data('recalc',0)*/.data('applyfilter',true);//.jqxCheckBox('check');
            }
            if(cntChecked == allCodes.length){
                addTitle = gis_filters_3;
                if(maxCnt != 1 && maxCnt != -1)addTitle='('+cntChecked+gis_filters_6+maxCnt+')';
                //$('#'+params.idFilter+'_checkAll').data('recalc',0);//.jqxCheckBox('check');
            }
            else{
                if(maxCnt != 1 && maxCnt != -1)addTitle='('+cntChecked+gis_filters_6+maxCnt+')';
                else addTitle = '('+cntChecked+')';
                //$('#'+params.idFilter+'_checkAll').data('recalc',0);//.jqxCheckBox('uncheck');
            }
            if(((maxCnt != -1)&&((cntChecked>maxCnt)||(cntChecked<minCnt)))){
                divFilter.addClass('divBadFilter');
                addTitle='('+cntChecked+gis_filters_6+maxCnt+')';
                $('#'+params.idFilter+'_apply').jqxButton({disabled: true});
                //if(!divFilter.data('isdropdown'))$('#'+params.idFilter+' .jqx-expander-header').removeClass('noVisible');
            }
            else if(((maxCnt == -1)&&((cntChecked>maxCnt)&&(cntChecked<minCnt)))){  //if(((maxCnt != -1)&(cntChecked>maxCnt))||(cntChecked<minCnt))
                divFilter.addClass('divBadFilter');
                $('#'+params.idFilter+'_apply').jqxButton({disabled: true});
            }
            else{
                //if(!divFilter.data('isdropdown'))$('#'+params.idFilter+' .jqx-expander-header').addClass('noVisible');
                divFilter.removeClass('divBadFilter');
                $('#'+params.idFilter+'_apply').jqxButton({disabled: false});
            }
            divFilter.jqxExpander('setHeaderContent',title[0]+addTitle);
        },
        recalcFilterHeader:function(params){
            var divFilter = $('#'+params.idFilter),
                title = divFilter.jqxExpander('getHeaderContent').split('('),
                maxCnt = divFilter.data('maxcnt'),
                addTitle = '',
                badFilter = false;
            if(params.cntChecked == params.cntAll)addTitle = gis_filters_3;
            else addTitle = '('+params.cntChecked+')';
            if((maxCnt != -1)&(params.cntChecked>maxCnt)){
                badFilter = true;
                divFilter.addClass('divBadFilter');
                addTitle='('+params.cntChecked+gis_filters_6+maxCnt+')';
                params.cntChecked = 0;
            }
            else divFilter.removeClass('divBadFilter');
            divFilter.jqxExpander('setHeaderContent',title[0]+addTitle);
            $('#'+params.idFilter+'_apply').jqxButton({disabled: (params.cntChecked == 0)||badFilter});
        },
        getUniqueId : function(){return 'xxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);return v.toString(16);});},
        callbackFilter:function(params){
            var value = '',
                id = $('#'+this.attr('id')+' .divTab.activeTab').attr('id').split('_')[0];
            $('#'+id+'_filters .divFilter').each(function(){value = value+methods.getFilterValues(this)+'|';});
            if(value != '')value = value.substr(0,value.length-1);
            return {windowId:params.windowId,params:[{name:'filter',value:value}]};
        },
        getFilterDataProviderString:function(){
            var value = '';
            if(this.data('dataprovider')!=undefined && this.data('dataprovider')!='')
                value = this.data('dataprovider');
            return value;
        },
        getFilterValues:function(){
            var value = '';
            $('#'+this.id+' .divFilter').each(function(){value = value+$(this).myFilters('getFilterValuesString')+'|';});
            if(value != '')value = value.substr(0,value.length-1);
            return value;
        },
        getFiltersCount:function(){
            var value = '';
            $('#'+this.id+' .divFilter').each(function(){value = value+$(this).myFilters('getFilterValuesString')+'|';});
            if(value != '')value = value.substr(0,value.length-1);
            return value;
        },
        getFilterValuesString: function(){
            var idFilter = this.attr('id').split('_'),
                value = '';
            idFilter.shift();
            if($('#'+this.attr('id')+'_listCheckBoxes').data('applyfilter') == true){
                var items = $('#'+this.attr('id')+'_listCheckBoxes').jqxListBox('getCheckedItems');
                for(var a in items){
                    value=value+items[a].value+',';
                }
            }
            if(value != '')value = value.substr(0,value.length-1);
            return idFilter.join('_')+':'+value;
        },
        getFilterValuesArray: function(){
            var value = [];
            $('#'+this.attr('id')+' .divFilter').each(function(){
                var idFilter = this.id.split('_'),
                    values = [];
                idFilter.shift();
                var items = $('#'+this.id+'_listCheckBoxes').jqxListBox('getCheckedItems');
                var isCodeStringType = ($(this).data('codetype') !== undefined && $(this).data('codetype') === 'xs:string');
                for(var a in items){
                    values.push({code:(isCodeStringType)?"'"+items[a].value+"'":items[a].value,descr:items[a].label});
                }
                value.push({idFilter:idFilter.join('_'),values:values});
            });
            return value;
        },
        updateTopFilter:function(params){
            if(this.data('getdata') == true)
                this.data('filters',params.obj_ids);
            else
                methods.setTopFilterValues({objIds:params.obj_ids,id: this.attr('id')});
        },
        setTopFilterValues: function(params){
            var ids = params.objIds.split(','),
                list = $('#'+params.id+'_listCheckBoxes'),
                items = list.jqxListBox('getItems');
            list.data('recalc',0);
            if(ids.length>0){
                list.data('isSingle',false);
                list.jqxListBox('uncheckAll');
                list.data('isSingle',true);
                for(var a = 0; a <= items.length-1; a++ ){
                    for(var i=0; i <= ids.length-1; i++){
                        if(ids[i] == items[a].value)
                            list.jqxListBox('checkIndex', a );
                    }
                }
                var checkedItems = list.jqxListBox('getCheckedItems');
                list.data('checkedItems',checkedItems).data('lastchecked',ids);
                $('#'+params.id+'_input').data('lastchecked',ids);
            }
            list.data('applyfilter',true);
            methods.recalcFilterView({idFilter:params.id,recalcAll:false});
        },
        sliceListFilter:function(params){
            if(this.data('getdata') == true)
                this.data('slicefilters',params.obj_ids);
            else
                methods.setTopFilterSlice({objIds:params.obj_ids,id: this.attr('id')});
        },
        setTopFilterSlice: function(params){
            var ids = params.objIds.split(','),
                list = $('#'+params.id+'_listCheckBoxes'),
                items = list.jqxListBox('getItems');
            list.data('recalc',0);
            for(var a = 0; a <= items.length-1; a++ ){
                for(var i=0; i <= ids.length-1; i++){
                    if(ids[i] == items[a].value)
                        list.jqxListBox('checkIndex', i );
                }
            }
            list.data('isSingle',false);
            list.jqxListBox('checkAll');
            list.data('isSingle',true);
            list.data('applyfilter',true);
            methods.recalcFilterView({idFilter:params.id,recalcAll:false});
        }
    };

    $.fn.myFilters = function( method ){
        if(methods[method]) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.fn.myFilters' );
        }
    };
})(jQuery);
//Переменная хранит url для открытия файлов (вида 'http://sitename/')
var pPanelOpenDocPath = window.location.protocol+'//'+window.location.hostname+window.location.pathname.substr(0,window.location.pathname.lastIndexOf('/')+1);

//Глобальный объект, в котором хранятся объекты инициализации предыдущих панелей свойств (для перехода от предыдущего к следующему и перехода по белой стрелочке к связанному объекту)
var pPanelSelectedObjectsHistory = {lastSelectedIndex:-1, historyArray:[]};

(function( $ ){
    var methods = {
        init: function( options ) {
            return this.each(function ()
            {
                if(options.handlers == undefined) $.extend(options,{handlers:{}});
                if(options.tabIndex == undefined) $.extend(options,{tabIndex:0,lastTabIndex:0});
                //Параметром регулируем, скрывать или нет системную информацию (CONFIG.SHOW_SYSTEM_INFO или флаг Show_System_Info, пришедший из задачи)
                if(options.showSystemInfo == undefined)$.extend(options,{showSystemInfo:false});
                //Параметром регулируем, редактировать или нет системную информацию (нужно если мы под администратором)
                if(options.editSystemInfo == undefined)$.extend(options,{editSystemInfo:false});
                //Параметром регулируем, редактировать или нет системную информацию (нужно если мы под администратором)
                if(options.closeAfterSave == undefined)$.extend(options,{closeAfterSave:false});
                if(options.skipValidation == undefined)$.extend(options,{skipValidation:false});
                if(options.position !== undefined)$.extend(options,{position:options.position});
                $.extend(options,{openerType:(options.openerType !== undefined)?options.openerType:getMapType()});
                $.extend(options,{withCtrl:(options.withCtrl !== undefined && options.withCtrl === true)});
                //Сохраняем текущий элемент, генерим локальный id панели свойств, сохраняем опции
                var el = $(this),
                    localId = methods.getUniqueId();
                options.localId = localId;
                el.data('options',options);
                var ppanelWindowContent = '<div class="ui-widget-header ui-corner-all ui-helper-clearfix" style="height:25px; border-top-color: currentColor; border-right-color: currentColor; border-bottom-color: currentColor; border-left-color: currentColor; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; white-space: normal; background-image: none; background-color: transparent;">\
	            <div id="divCoordPanel'+ localId +'" class="divCoordPanel"></div>\
                <div class="ui-dialog-titlebar-buttonpane" style="height: 18px; top: 14px; right: 6px; margin-top: -10px; position: absolute;">\
                    <button id="pPanelTitleCloseBtn_'+localId+'" class="ui-button ui-widget ui-state-default ui-corner-all ui-button-icon-only ui-dialog-titlebar-close" role="button" aria-disabled="false" title="Закрыть" style="position: relative; float: right; top: auto; right: auto; margin: 0px;">\
                        <span class="ui-button-icon-primary ui-icon ui-icon-gisCloseButton"></span>\
                        <span class="ui-button-text">Закрыть</span>\
                    </button>\
                    <a id="pPanelTitleMinimizeBtn_'+localId+'" class="ui-corner-all ui-state-default" href="#" title="Свернуть" role="button" style="width:19px; height:18px; padding:0px; display: block;">\
                        <span class="ui-icon ui-icon-gisMinimizeButton">Свернуть</span>\
                    </a>\
                    <a id="pPanelTitleMaximizeBtn_'+localId+'" class="ui-corner-all ui-state-default" href="#" title="Развернуть" role="button" style="width:19px; height:18px; padding:0px; display: block;">\
                        <span class="ui-icon ui-icon-gisMaximizeButton">Свернуть</span>\
                    </a>\
                    <a id="pPanelTitleRestoreBtn_'+localId+'" class="ui-corner-all ui-state-default" href="#" title="Восстановить" role="button" style="width:19px; height:18px; padding:0px; display: none;">\
                        <span class="ui-icon ui-icon-gisRestoreButton">Восстановить</span>\
                    </a>\
                </div>\
              </div>\
              <div class="ui-widget-content ui-dialog-normal" id="pPanelContent_'+localId+'" style="width: auto; min-height: 0px; max-height: none; height: calc(100% - 25px); background-color: #4C93C2; border-color: #005e9a; background-image: none;">\
                <div style="height:100%">\
                  <div id="divContent_'+localId+'" class="divContent" style="height:100%">\
                        <div class="pPanelTitleContent">\
                        <input type="button" value="<<" id="btnPrevObject_'+localId+'" class="myButton btnTopNavigate" style="padding: 2px;" />\
                        <input type="button" value=">>" id="btnNextObject_'+localId+'" class="myButton btnTopNavigate" style="padding: 2px;" />\
                        <span id="spNameObject_'+localId+'"></span>\
                        <span id="spSizeObject_'+localId+'"></span>\
                    </div>\
                   <div id="divLeftPanel_'+localId+'" class="divLeftPanel">\
                   </div>\
                  <div class="divBottomPanel pPanelTableCell">\
                  </div>\
                 </div>\
              </div>';
                /*<a class="ui-dialog-titlebar-restore ui-corner-all ui-state-default" href="#" role="button" style="display: none; right: 1.4em;"><span class="ui-icon ui-icon-gisRestoreButton">restore</span></a>*/
                el.append(ppanelWindowContent);
                //Дефолтные размеры панели свойств
                var panelWidth = 800;
                var panelHeight = 255+25;//+25 - высота блока с координатами
                if(options.coords){
                    if(WidgetMap.DEFAULT_PROJECTION !== GeoUtil.PROJS['EPSG:5807']){
                        var dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
                        var source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
                        var point = new proj4.toPoint([options.coords[0], options.coords[1]] );
                        proj4.transform(source_, dest_, point);
                        var coord_x = point.x.toPrecision(12);
                        var coord_y = point.y.toPrecision(12);
                        var x_dec = GeoUtil.convertDecimalIntoDegree(coord_x);
                        var y_dec = GeoUtil.convertDecimalIntoDegree(coord_y);
                        //десятичные градусы
                        //var html = gis_mapcenterpointcontrol_3++gis_mapcenterpointcontrol_4+;
                        $('#divCoordPanel'+ localId).text(gis_core_10 + y_dec + '(' + coord_y + '); ' + gis_core_11 + x_dec + '(' + coord_x + ')');
                    }
                }
                if(options.error){
                    $('#btnNextObject_' + localId).addClass('divError').attr('title',gis_mapinfocontrol_1+':'+options.error);
                }

                if (options.hasOwnProperty('panelSize')) {
                    panelWidth = options.panelSize.propPanelWidth;
                    panelHeight = options.panelSize.propPanelHeight;
                } else {
                    $.extend(options,{panelSize: {propPanelWidth:panelWidth, propPanelHeight:panelHeight-5}});
                }
                var prevPanelTopPosition = 200;
                if((panelHeight+5) < 280)//280 дефолтная высота панели свойств
                    prevPanelTopPosition = 30;
                //Отступ слева (350px по дефолту). Высчитываем исходя из размеров родителя
                var panelLeftPosition = options.opener!=undefined>0 && $(options.opener).outerWidth()>panelWidth ? ($(options.opener).outerWidth()-panelWidth)/2 : 50;
                var pPanelMinimizedHeight = 25;

                if(options.position && options.position.length == 2 && !isNaN(options.position[0]) && !isNaN(options.position[1])){
                    panelLeftPosition = options.position[0];
                    prevPanelTopPosition = options.position[1];
                }
                panelWidth = options.opener!=undefined>0 && $(options.opener).outerWidth()<panelWidth ? $(options.opener).outerWidth() -100 : panelWidth;
                el.css({left:panelLeftPosition+'px', top:prevPanelTopPosition+'px', width:panelWidth+'px', height:panelHeight, display:'block', position:'absolute'});
                if (options.zindex!=undefined) {
                    if(options.zindex === 50)
                        el.css({'z-index':150}); /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
                    else
                        el.css({'z-index':options.zindex}); /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
                }
                el.addClass('ui-dialog ui-widget ui-widget-content ui-corner-all ui-front pPanelDialog ui-resizable ui-draggable');
                //Создаем не плавающее окно, а плавающую панель
                el.resizable({minHeight:200, minWidth:600,containment: "parent", alsoResize: '#pPanelContent_'+localId,
                    resize: function( event, ui ) {
                        var tabs = $('#divTabs_'+localId);
                        var divContentHeight = $('#divContent_'+localId).innerHeight();
                        //upd. 05.02.20 по совещанию принято решение просто кнопки не показывать при изменении высоты панели. Если нужно - то расширят панель
                        $('#divLeftPanel_'+localId).css('height',divContentHeight-30);
                        //выставляем высоту для
                        if(tabs.length != 0)tabs.jqxTabs({height: divContentHeight>30 ? divContentHeight-30 : 1}); //-5 отступ, чтобы лучше выглядело при изменении размеров панели свойств
                    }}).draggable({containment: "parent", cancel: '#pPanelContent_'+localId, drag: function(event, ui) {
                        if(options.opener === 'body'){
                            var pos = ui.position;
                            //если панель открыти из карты, то глобально выставляем последнее положение панели
                            if(options.handlers.dragPanelCallback != undefined){
                                options.handlers.dragPanelCallback([pos.left, pos.top]);
                            }
                        }
                    }});
                var overlayDiv = undefined;
                if (options.zindex!=undefined && options.modal!=undefined && options.modal==true) {
                    /* Добавляем к родителю оверлей, закрывающий все под нашей панелью */
                    overlayDiv = $('<div class="applicationBlockOverlay" style="z-index:'+(options.zindex-1).toString()+'"></div>');
                    options.overlayDiv = overlayDiv;
                    el.after(overlayDiv);
                }
                //Создаем действия для кнопки "закрыть"
                $('#pPanelTitleCloseBtn_'+localId).jqxButton().on('click',function(evt) {
                    if (evt) evt.stopImmediatePropagation();
                    if(options.handlers.closeCallback != undefined)
                        options.handlers.closeCallback();
                    //пробуем удалять модальность
                    if(overlayDiv!=undefined)
                        $('.applicationBlockOverlay').remove();
                    methods.destroyPanel(pPanelParams); //el.remove();
                });
                //Создаем действия для кнопки "свернуть"
                $('#pPanelTitleMinimizeBtn_'+localId).jqxButton().on('click',function(evt) {
                    if (evt) evt.stopImmediatePropagation();
                    $('#pPanelTitleMinimizeBtn_'+localId).css('display','none');
                    $('#pPanelContent_'+localId).css('display','none');
                    el.css({height:pPanelMinimizedHeight+'px'});
                    prevPanelTopPosition = parseFloat(el.css('top').replace('px',''));
                    el.css({top:($(options.opener).outerHeight()-pPanelMinimizedHeight)+'px'});
                    $('#pPanelTitleRestoreBtn_'+localId).css('display','block');
                });
                //Создаем действия для кнопки "развернуть на весь экран"
                //Vartanian Добавлена кнопка развернуть, в рамках замечания 150 от 09.12.2021
                //TDOD временно убираем функционал - не корректно работает при открытии вкладок в панели свойств
                $('#pPanelTitleMaximizeBtn_'+localId).jqxButton().on('click',function(evt) {
                    if (evt) evt.stopImmediatePropagation();
                    el.css({height:'70%'});
                    $('#divTabs_'+localId, el).css({height: '94%'});
                    $('.jqx-tabs-content.jqx-tabs-content-myCommon', el).css({height: '100%'});
                });
                //Создаем действия для кнопки "восстановить"
                $('#pPanelTitleRestoreBtn_'+localId).jqxButton().on('click',function(evt) {
                    if (evt) evt.stopImmediatePropagation();
                    $('#pPanelTitleRestoreBtn_'+localId).css('display','none');
                    el.css({height:'auto', top:prevPanelTopPosition+'px'});
                    $('#pPanelContent_'+localId).css('display','block');
                    $('#pPanelTitleMinimizeBtn_'+localId).css('display','block');
                });

                //Выбираем текущим первый объект в списке
                $.extend(options,{curObject:0});
                //Создаем кнопки перехода между объектами, а если объект один - прячем их
                $('#btnPrevObject_'+localId).jqxButton({disabled:true, width:30}).on('click',function(){methods.prevObject({checkSave:true,divProperties:el,localId:localId,options:options});});
                $('#btnNextObject_'+localId).jqxButton({disabled:options.objects.length<=1, width:30}).on('click',function(){methods.nextObject({checkSave:true,divProperties:el,localId:localId,options:options});});
                if(options.objects.length==1) {
                    $('#btnPrevObject_'+localId).addClass('noVisible');
                    $('#btnNextObject_'+localId).addClass('noVisible');
                }
                /*el.dialogExtend({
                    "maximizable" : true,
                    "minimizable" : true,
                    "dblclick" : "maximize",
                    "titlebar" : "transparent",
                    "minimizeLocation" : "right",
                    "icons" : {
                        "close" : "ui-icon-gisCloseButton",
                        "maximize" : "ui-icon-gisMaximizeButton",
                        "minimize" : "ui-icon-gisMinimizeButton",
                        "collapse" : "ui-icon-triangle-1-s",
                        "restore" : "ui-icon-gisRestoreButton"
                    },
                });*/
                //Запускаем получение формы для первого объекта
                var pPanelParams = {divProperties:el,localId:localId,options:options};
                if(options.objects.length!=0)methods.showPanelObject(pPanelParams);
                else{
                    methods.createLeftButton({
                        params: {localId: localId},
                        iconUrl: '',
                        tooltip: gis_ppanel_61,
                        clickEvent:'FindRouteEvent',
                        coords: options.coords
                    });

                }
            });
        },
        destroyPanel:function(params) {
            if (params.options!=undefined && params.options.overlayDiv!=undefined) params.options.overlayDiv.remove();
            //Полностью удаляем слушатели и компоненты
            if (params && params.hasOwnProperty('divProperties') && params.hasOwnProperty('localId')) {
                var localId = params.localId;
                $('#pPanelTitleCloseBtn_' + localId).off();
                $('#pPanelTitleMinimizeBtn_' + localId).off();
                $('#pPanelTitleRestoreBtn_' + localId).off();
                $('#btnLeftPDocs_' + localId).off();
                $('#btnLeftPSave_' + localId).off();
                $('#btnLeftPUndo_' + localId).off();
                $('#btnLeftPDelete_' + localId).off();
                $('#btnLeftPExportNAV_' + localId).off();
                $('#btnLeftPShowOnMap_' + localId).off();
                $('#btnLeftPExcel_' + localId).off();
                $('#btnLeftPBack_' + localId).off();
                $('#btnLeftPForward_' + localId).off();
                $('#btnPrevObject_' + localId).off();
                $('#btnNextObject_' + localId).off();

                try {
                    var listForms = $('#divContent_'+localId+' .frmPanelTab');
                    for (var i = 0; i<listForms.length; i++) {
                        var frmId = 'frm_'+localId+'_'+i;
                        $(listForms[i]).jqxValidator('hide');
                        $('#'+frmId+' .formControl').each(function(){
                            var el = $(this);
                            switch(el.data('typecontrol')) {
                                case 'input': el.off(); el.jqxInput().off(); el.jqxInput('destroy');break;
                                case 'numberinput': el.off(); el.jqxNumberInput().off(); el.jqxNumberInput('destroy');break;
                                case 'checkbox': el.off(); el.jqxCheckBox().off(); el.jqxCheckBox('destroy'); break;
                                case 'combobox': el.off(); el.jqxComboBox().off(); el.jqxComboBox('destroy'); break;
                                case 'date': el.off(); break;
                                case 'file': break;
                                case 'inputfile': break;
                            }
                        });
                    }
                    //Также чистим компонент jqxTabs
                    var tabs = $('#divTabs_'+localId);
                    if(tabs.length != 0) {
                        tabs.off();
                        tabs.jqxTabs.off();
                        tabs.jqxTabs('destroy');
                    }
                } catch (err) {
                    //Ничего не делаем
                }
            }
            params.divProperties.remove(); //Удаляет основной элемент и все его дочерние улементы из DOM, а также чистит слушатели на компонентах внутри
            params.divProperties = null; //На всякий случай убираем из объекта ссылку на divProperties
            //Под конец в IE вызываем сборщик мусора
            if (typeof(CollectGarbage) == "function") CollectGarbage();
            //Под конец в Chrome вызываем сборщик мусора
            if (typeof(gc) == "function") gc();
        },
        successCallback:function(data, url, params,callbackResult,thisObject, isMainSelect){
            try {
                //var dataString = $(data).children('string').text();
                if(thisObject && thisObject.syncMap && MapUtil){
                    if(thisObject.options && thisObject.options.objects && thisObject.options.objects.length > 0){
                        var obj = thisObject.options.objects[thisObject.options.curObject];
                        if(obj && obj.id && obj.id.indexOf(':') !== -1){
                            var layerName = obj.id.split(':')[0];
                            var ids = obj.id.split(':')[1];
                            MapUtil.updateLayerData(layerName, [ids], true);
                        }
                    }
                }
                var dataString = data;
                var er = HTTPServiceUtil.getError(dataString);
                var el = thisObject.divProperties.data('options');
                var selectedObjectStr = thisObject.options.objects[thisObject.options.curObject];
                var selectedObject = {layerId: selectedObjectStr.id.split(':')[0], id: selectedObjectStr.id.split(':')[1]};
                if (er != "") {
                    var errTitle = gis_ppanel_24+gis_ppanel_25;
                    if (params.descrType=='insert' || params.descrType=='update') errTitle = gis_ppanel_26+gis_ppanel_25;
                    App.errorReport(errTitle, er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_8'});
                    if (methods && methods.callbackError!=undefined) methods.callbackError({text:er,divProperties:thisObject.divProperties,url:url,params:params});
                    if (params && params.descrType=='insert' && thisObject && thisObject.indexForm==0 && thisObject.saveMethod=='saveTabForm' && thisObject.hasOwnProperty('divProperties')) {
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:false, requestParams:params, requestUrl:url, retObj: selectedObject,});
                        methods.destroyPanel(thisObject);
                    }//закрываем форму
                    else if (thisObject && thisObject.options!=undefined && thisObject.options.closeAfterSave==true) {
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:false, requestParams:params, requestUrl:url, retObj: selectedObject,});
                        methods.destroyPanel(thisObject);
                    }
                    else{
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:false, requestParams:params, requestUrl:url, retObj: selectedObject,});
                    }
                    return;
                }

                if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.successCallback != undefined)
                    el.handlers.successCallback({url:url,params:params,data:data});
                //thisObject.options.handlers.successCallback({url:url,params:params,data:data});
                //!!!! ВАЖНО! Если пришел флаг создания новой записи, значит  установка всем контролам editable и enabled в true
                //пока это будет флаг label=""  из  thisObject.options.object[0].label или нет идентификатора объекта в thisObject.options.object[0].id
                var xmlData = null;
                try{
                    xmlData = $.parseXML(dataString);
                }
                catch(ex){
                    // BlockingUtil.ready();
                    // App.errorReport(gis_ppanel_65, gis_core_error_3+ex.message, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_21'});
                    // return;
                    xmlData = null;
                }
                var isGetSheetId = false;
                //TODO хардкод. Избавиться!
                isGetSheetId = params && (params.descrId === "STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST" || params.descrId === "STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST" || params.descrId === "STO_SEM.xml#GET_REPAIR_SHEET_ID_BY_ILI_DATA_ID" || params.descrId === "STO_SEM.xml#GET_EXCAVATE_SHEET_ID_BY_ILI_DATA_ID");
                //TODO хак, если нет панели свойств, но node возвращает пустую запись. Функция общая для получения и данных, и описания панели
                if(dataString && dataString.indexOf('<root/></string>') !== -1 && !(params && params.descrType === 'update') && !isGetSheetId){
                    xmlData = null;
                    if (isMainSelect) {
                        App.errorReport(gis_gridwidget_1, gis_ppanel_66, function () {
                            try {
                                var gridPropPanelId = thisObject.divProperties.attr('id');
                                $('#' + gridPropPanelId).remove();
                            } catch (ex) {
                            }
                        }, {filename: gis_filename_568, functionname: 'gis_filename_568_19'});

                        return;
                    }
                }

                /*if (xmlData!=undefined && xmlData!=null) {
                var inputXml = xmlData.firstChild;
                var items = inputXml.getElementsByTagName('data');
                if(items.length === 0)
                    xmlData = null;
            }*/
                //Обрабатываем случай, когда форма не найдена или ошибка при получении
                if (xmlData!=undefined && xmlData!=null) {
                    //!!!!обрабатываем случай для экспорта пикетажа трубопровода
                    var inputXml = xmlData.firstChild;
                    var items = inputXml.getElementsByTagName('data');
                    var isRouteToExport = false;
                    var retObj = {};
                    //если пришли данные, то добавляем их в объект
                    //TODO сделать для всех объектов
                    for (var i = 0; i < items.length; i++) {
                        var curItem = items[i];
                        var attrNameNodeMap = curItem.attributes;
                        for (var j = 0; j < attrNameNodeMap.length; j++) {
                            var node = attrNameNodeMap[j];
                            retObj[node.nodeName.toUpperCase()] = node.nodeValue;
                            if(node.nodeName.toUpperCase() == 'LINE_ID')
                                isRouteToExport = true;
                        }
                    }
                    if (!selectedObject.id)
                        selectedObject.id = retObj.ID;
                    if(isRouteToExport && thisObject &&  thisObject.options && thisObject.options.objects && !thisObject.options.objects[thisObject.options.curObject]['curRowData']){
                        thisObject.options.objects[thisObject.options.curObject]['curRowData'] = retObj;
                    }
                    $(xmlData).children().each(function(){callbackResult($(this),thisObject, isMainSelect);});
                    if (params && params.descrType=='insert' && thisObject && thisObject.indexForm==0 && thisObject.saveMethod=='saveTabForm' && thisObject.hasOwnProperty('divProperties'))
                    {
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:true,result:xmlData,savingData:params.data, requestParams:params, requestUrl:url, retObj: selectedObject,});
                        methods.destroyPanel(thisObject);
                    }//закрываем форму
                    else if (params && params.descrType=='update' && thisObject && thisObject.options!=undefined)
                    {
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:true,result:xmlData,savingData:params.data, requestParams:params, requestUrl:url, retObj: selectedObject,});
                        if(thisObject.options.closeAfterSave==true){
                            methods.destroyPanel(thisObject);
                        }
                    }
                }
                else {
                    //Снимаем курсор ожидания
                    BlockingUtil.ready();
                    //BlockingUtil.unblockApplication();
                    //иначе в случае, если есть запрос на заполнение вкладки, запросим данные и выведем в виде грида свойство-значение
                    var source = {localdata: [],
                        datatype: "array",
                        datafields: [ {name:'CODE', type:'string'}, {name:'DESCR', type:'string'} ]
                    };
                    var dataGridParams = {width:'99%',
                        height:'99%',
                        pageable: false,
                        columnsresize: true,
                        showemptyrow:false,
                        altrows:true,
                        selectionmode: 'singlerow',
                        columns: [
                            {text:gis_ppanel_39, datafield:"CODE", width:'40%'},
                            {text:gis_ppanel_40, datafield:"DESCR", width:'60%',
                                cellsrenderer: function (row, column, value) {
                                    return "<div style='margin:4px;' title='"+value+"'>" + value + "</div>";
                                }}],
                        theme:'myCommon',
                        sortable:false,
                        columnsmenu: false,
                        editable:false,
                        source:source};
                    //Сохраняем описание грида
                    params.source = source;
                    var idTable = 'divTable_'+methods.getUniqueId();
                    var element = $('<div id="'+idTable+'" class="vBox" data-selectscript="'+params.selectScript+'"></div>');
                    thisObject.tabs.jqxTabs('setContentAt', thisObject.selectedIndex, '<div id="divTabContent_'+thisObject.localId+'_'+thisObject.selectedIndex+'" class="pPanelTabContent"></div>');
                    $.extend(thisObject,{div:methods.getDivContent(thisObject),parentClass:'',rules:[],tableReadOnly:true});
                    methods.appendFormElement({params:thisObject,element:element,xmlElement:thisObject.divProperties});

                    if(params.selectScript === "undefined" || params.selectScript === undefined){
                        params.source.localdata = thisObject.options.objects[thisObject.options.curObject].attrs;
                    }

                    element.jqxGrid(dataGridParams);
                    //Делаем запрос
                    var prm = thisObject.options.objects[thisObject.options.curObject].id.split(':'),
                        db= prm[0].split('_'),
                        db_schema = db[0],
                        db_table_id = db.slice(1).join('_');
                    //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                    if (thisObject.hasOwnProperty('curSchema') && thisObject.hasOwnProperty('curTable')) {
                        db_schema = thisObject.curSchema;
                        db_table_id = thisObject.curTable;
                    }
                    if(params.selectScript != "undefined" && params.selectScript !== undefined)
                        methods.serverQueryStringNode(Services.processQueryNode,
                            {descrId:params.selectScript,
                                descrType:'select',
                                data:'<root><data FILTER="ID='+prm[1]+'" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+'" DB_SCHEMA_ID="'+db_schema+
                                    '" DB_TABLE_ID="'+db_table_id+'" SYS_CLASS_ID="'+prm[0]+'" SYS_OBJ_ID="'+prm[1]+'"/></root>'},
                            function setTableData(data,params){
                                try {
                                    var retArr = [];
                                    var resultXml = data;
                                    if (resultXml) {
                                        var er = HTTPServiceUtil.getError(resultXml);
                                        if (er != "") {
                                            App.errorReport(gis_gridwidget_1, gis_ppanel_14 + er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_9'});
                                            return false;
                                        } else {
                                            //Получаем xml с данными в виде структуры (берем корневой элемент, т.е. root)
                                            var inputXml = ($.parseXML(resultXml)).firstChild;
                                            var items = inputXml.getElementsByTagName('data');
                                            //Теоретически на запрос приходит только 1 строка <data />, но мы в гриде будем выводить ВСЕ, если их несколько
                                            for (var i = 0; i < items.length; i++) {
                                                var curItem = items[i];
                                                var attrNameNodeMap = curItem.attributes;
                                                //добавляем в виде объекта со свойствами CODE (имя атрибута) и DESCR (значение атрибута)
                                                for (var j = 0; j < attrNameNodeMap.length; j++) {
                                                    var node = attrNameNodeMap[j];
                                                    var addItem = {CODE:node.nodeName.toUpperCase(), DESCR:node.nodeValue };
                                                    retArr.push(addItem);
                                                }
                                            }
                                        }
                                    }
                                    //Подставляем данные в грид
                                    params.source.localdata = retArr;
                                    var dataAdapter = new $.jqx.dataAdapter(params.source);
                                    $('#'+params.idTable).jqxGrid({source:dataAdapter});
                                    //Сразу после обновления блокируем кнопки в гридах комментариев и прикрепленных документов
                                    methods.setCommentDocGridBtnDisabled(params, true);
                                } catch (err) {
                                    //Ничего не делаем, возможно панель закрыта
                                }
                            },
                            $.extend({divProperties:thisObject.divProperties, source:params.source, idTable:idTable, localId:thisObject.localId})
                        );
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        } ,
        serverQueryNode:function(url,params,callbackResult,thisObject, isMainSelect, handleEmptyFileError) {
            url = App.formatNodeServiceUrl(url);
            if(thisObject.divProperties == undefined)
                App.confirmDialog(gis_ppanel_38);
            App.serverQueryNodeWithTries2(url,params,function(data){
                    if(data){
                        var er = HTTPServiceUtil.getError(data);
                        //TODO нужен рефакторинг, перенести блок с ошибкой в одно место
                        if (er !== ''){
                            try {
                                methods.callbackError({text:gis_ppanel_41+'. '+data,divProperties:thisObject.divProperties,url:url,params:params});
                                if (params && params.descrType=='insert' && thisObject && thisObject.indexForm==0 && thisObject.saveMethod=='saveTabForm' && thisObject.hasOwnProperty('divProperties'))
                                    methods.destroyPanel(thisObject);//закрываем форму
                                else if (params && params.descrType=='update' && thisObject && thisObject.options!=undefined && thisObject.options.closeAfterSave==true)
                                    methods.destroyPanel(thisObject);
                            } catch (err) {
                                //Ничего не делаем, возможно панель закрыта
                            }
                            return;
                        }
                        methods.successCallback(data, url, params,callbackResult,thisObject, isMainSelect);
                    }
                },
                function(data){
                    try {
                        if (data.indexOf(gis_app_55_4) !== -1){
                            App.errorReport(gis_app_55_3, gis_app_55_30, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_24'});
                        }
                        methods.callbackError({text:gis_ppanel_41+'. '+data,divProperties:thisObject.divProperties,url:url,params:params});
                        if (params && params.descrType=='insert' && thisObject && thisObject.indexForm==0 && thisObject.saveMethod=='saveTabForm' && thisObject.hasOwnProperty('divProperties'))
                            methods.destroyPanel(thisObject);//закрываем форму
                        else if (params && params.descrType=='update' && thisObject && thisObject.options!=undefined && thisObject.options.closeAfterSave==true)
                            methods.destroyPanel(thisObject);
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                },4,handleEmptyFileError);
        },
        serverQueryString:function(url,params,callbackResult,thisObject) {
            if(thisObject.divProperties == undefined)App.confirmDialog(gis_ppanel_38);
            App.serverQueryStringWithTries(url, params, function(data){
                    try {
                        var dataString = $(data).children('string').text();
                        var er = HTTPServiceUtil.getError(dataString);
                        if (er != "") {
                            var errTitle = gis_ppanel_24+gis_ppanel_25;
                            if (params.descrType=='insert' || params.descrType=='update') errTitle = gis_ppanel_26+gis_ppanel_25;
                            App.errorReport(errTitle, er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_10'});
                            methods.callbackError({text:er,divProperties:thisObject.divProperties,url:url,params:params});
                            return;
                        }
                        var el = thisObject.divProperties.data('options');
                        if(el.handlers != undefined && el.handlers.successCallback != undefined) el.handlers.successCallback({url:url,params:params,data:data});
                        callbackResult(dataString,thisObject);
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                },
                function(data){
                    try {
                        methods.callbackError({text:gis_ppanel_41+'. '+data,divProperties:thisObject.divProperties,url:url,params:params});
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                });
        },
        serverQueryStringNode:function(url,params,callbackResult,thisObject) {
            if(thisObject.divProperties == undefined)App.confirmDialog(gis_ppanel_38);
            App.serverQueryStringNodeWithTries(url,params, function(data){
                    try {
                        var dataString = data;
                        var er = HTTPServiceUtil.getError(dataString);
                        if (er != "") {
                            var errTitle = gis_ppanel_24+gis_ppanel_25;
                            if (params.descrType=='insert' || params.descrType=='update') errTitle = gis_ppanel_26+gis_ppanel_25;
                            App.errorReport(errTitle, er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_10'});
                            methods.callbackError({text:er,divProperties:thisObject.divProperties,url:url,params:params});
                            return;
                        }
                        var el = thisObject.divProperties.data('options');
                        if(el.handlers != undefined && el.handlers.successCallback != undefined) el.handlers.successCallback({url:url,params:params,data:data});
                        callbackResult(dataString,thisObject);
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                },
                function(data){
                    try {
                        methods.callbackError({text:gis_ppanel_41+'. '+data,divProperties:thisObject.divProperties,url:url,params:params});
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                });
        },
        callbackError: function(params){
            try {
                var el = params.divProperties.data('options');
                if(el.handlers != undefined && el.handlers.errorHandler != undefined)
                    el.handlers.errorHandler(params);
                else
                    App.errorReport(gis_core_error_1 + '. ' + gis_ppanel_25, params.text, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_22'});
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        getUniqueId : function(){return 'xxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);return v.toString(16);});
        },
        openObjectInNewPanel : function(params){
            try {
                /* params = {divProperties:params.divProperties, localId:params.localId, options:{objects:[params.options.objects[params.options.curObject]], curObject:0, handlers:params.options.handlers, opener:params.options.opener}} */
                //Заново создаем панель
                if (params!=undefined && params.hasOwnProperty('divProperties') && params.hasOwnProperty('options')) {
                    //Создаем панель свойств для текущего объекта
                    var gridPropPanelId = params.divProperties.attr('id');
                    $('#' + gridPropPanelId).remove();
                    var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
                    $(params.options.opener).append(gridPropPanelDiv);
                    $('#' + gridPropPanelId).myPropertiesPanel(params.options);
                } else {
                    App.errorReport(gis_ppanel_42,gis_ppanel_43, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_11'});
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        checkPrevNextHistoryBtnEnabled : function(params){
            try {
                //Переключение доступности кнопок вперед/назад истории панелей свойств
                var backDisabled = pPanelSelectedObjectsHistory.lastSelectedIndex <= 0;
                $('#btnLeftPBack'+params.localId).jqxButton({disabled:backDisabled});
                var forwardDisabled = pPanelSelectedObjectsHistory.lastSelectedIndex + 1 >= pPanelSelectedObjectsHistory.historyArray.length;
                $('#btnLeftPForward'+params.localId).jqxButton({disabled:forwardDisabled});
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        prevObject:function (params){
            try {
                //if((params.checkSave == true)&&(!methods.checkSave($.extend(params,{callBack:methods.prevObject}))))return;
                //устанавливаем в false флаг withCtrl, если начинаем переключаться между объектами
                params.options.withCtrl = false;
                params.options.curObject--;
                if(params.options.curObject == 0)$(this).jqxButton({disabled:true});
                //upd.03.11.21 обнуляем сохраненные размеры формы, чтобы не было сбоя при переключении между объектами.
                // высота будет подстраиваться под текущий размер формы
                if(params.options.panelSize)
                    params.options.panelSize.propPanelHeight = undefined
                methods.showPanelObject(params);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        nextObject:function (params){
            try {
                //if((params.checkSave == true)&&(!methods.checkSave($.extend(params,{callBack:methods.nextObject}))))return;
                //устанавливаем в false флаг withCtrl, если начинаем переключаться между объектами
                params.options.withCtrl = false;
                params.options.curObject++;
                //upd.03.11.21 обнуляем сохраненные размеры формы, чтобы не было сбоя при переключении между объектами.
                // высота будет подстраиваться под текущий размер формы
                if(params.options.panelSize)
                    params.options.panelSize.propPanelHeight = undefined
                methods.showPanelObject(params);

            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        showPanelObject:function(params){
            $('#divLeftPanel_'+params.localId).empty();
            try {
                $('#btnPrevObject_'+params.localId).jqxButton({disabled:(params.options.curObject==0)});
                $('#btnNextObject_'+params.localId).jqxButton({disabled:(params.options.curObject==(params.options.objects.length-1))});
                if(params.options.objects.length==1) {
                    $('#btnPrevObject_'+params.localId).addClass('noVisible');
                    $('#btnNextObject_'+params.localId).addClass('noVisible');
                }
                //Не пишем 1 из 1, когда создаем новый объект, но пишем, если получили информацию именно из 1 объекта
                var objectInArrText = params.options.creatingNewObject==true ? '' : (params.options.curObject+1)+gis_ppanel_44+params.options.objects.length;
                var objectLabel = params.options.objects[params.options.curObject].label==undefined ? '' : params.options.objects[params.options.curObject].label;
                $('#spNameObject_'+params.localId).text(objectInArrText+' '+objectLabel);
                //Вызываем callback-функцию центровки если она есть
                if(params.options.handlers.changePanelObjectCallback != undefined) {
                    params.options.handlers.changePanelObjectCallback(params.options.objects[params.options.curObject], params.options.withCtrl);
                }
                if(params.options.handlers.calculateObjectSizeCallback != undefined) {
                    //передаем в коллбек селектор поля, куда надо посчитать длину или площадь объекта выбранного
                    params.options.handlers.calculateObjectSizeCallback({selector:'#spSizeObject_'+params.localId , object:params.options.objects[params.options.curObject]});
                }
                //Устанавливаем признак создания нового объекта, чтобы каждый раз не проверять в каком режиме панель свойств (insert/update)
                $.extend(params.options, {creatingNewObject: (params.options.objects.length==1 && params.options.objects[0].id.indexOf(':')==-1)});
                var curSelectedObjectId = params.options.objects[params.options.curObject].id;
                var curSelectedObjectIdSplitArr = curSelectedObjectId.split(':');
                params.curSchema = curSelectedObjectIdSplitArr[0].substring(0, curSelectedObjectIdSplitArr[0].indexOf('_'));
                params.curTable = curSelectedObjectIdSplitArr[0].substring(curSelectedObjectIdSplitArr[0].indexOf('_')+1);
                //Сохраняем текущий объект в стеке выбранных однажды объектов, если он не только что из стека или если не создаем новый
                if (!pPanelSelectedObjectsHistory.hasOwnProperty(curSelectedObjectId)) {
                    if (curSelectedObjectId.indexOf(':') > 0) {
                        var curSelectedObject = {
                            divProperties:params.divProperties,
                            localId:params.localId,
                            options:{objects:[params.options.objects[params.options.curObject]], curObject:0, handlers:params.options.handlers, opener:params.options.opener}
                        };
                        pPanelSelectedObjectsHistory.historyArray.push(curSelectedObject);
                        pPanelSelectedObjectsHistory[curSelectedObjectId] = curSelectedObjectId; //для быстрой проверки наличия такого объекта в истории добавляем ключ
                        //Увеличиваем индекс последнего выбранного элемента
                        pPanelSelectedObjectsHistory.lastSelectedIndex++;
                        methods.checkPrevNextHistoryBtnEnabled(params);
                    }
                } else {
                    //Пересчитываем и блокируем кнопки перехода к предыдущему/следующему объекту из истории
                    methods.checkPrevNextHistoryBtnEnabled(params);
                }
                //получаем имя класса из *Layers.xml <dataProvider> type="propertiesPanel" source="ALL_PROP_LIST.xml#PODS_S..." />
                var className = params.options.objects[params.options.curObject].id.split(':')[0];
                if (WidgetMap!=undefined && WidgetMap.layerManager!=undefined) {
                    var curLayer = WidgetMap.layerManager.getLayerObjByName(className);
                    if(curLayer !== undefined && curLayer.layer !== undefined && curLayer.layer.dataProvider !== undefined &&
                        curLayer.layer.dataProvider.propertiesPanel !== undefined && curLayer.layer.dataProvider.propertiesPanel != ''){
                        var splitted  = curLayer.layer.dataProvider.propertiesPanel.split('#');
                        className = splitted[splitted.length-1];
                    }
                }
                //Запрашиваем форму
                methods.serverQueryNode(Services.processQueryNodeXml,
                    {descrId:'SYS_PROP.xml#PROP_LIST',
                        descrType:'select',
                        data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="'+className+'"/></root>'},methods.parseTabsPanel,$.extend(params,{loadObject:params.options.curObject,callBack:function(){/*App.confirmDialog('Сохранено!');*/}}),undefined,false);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseTabsPanel:function(xmlElement,params){
            try {
                switch(xmlElement[0].tagName)
                {
                    case 'result':
                    case 'root':
                        if(params.loadObject != params.options.curObject)return;
                        if (xmlElement.children().length>0) {
                            xmlElement.children().each(function(){methods.parseTabsPanel($(this),params);});
                        } else {
                            App.errorReport(gis_ppanel_45,gis_ppanel_46, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_12'});
                        }
                        break;
                    case 'data':
                        var tabs = $('#divTabs_'+params.localId);
                        if(tabs.length != 0)tabs.jqxTabs('destroy');
                        $('#divContent_'+params.localId).append('<div id="divTabs_'+params.localId+'" class="divTabs"><ul id="ulTabs_'+params.localId+'"></ul></div>');
                        tabs = $('#divTabs_'+params.localId);
                        tabs.data('activePage',0);
                        $.extend(params,{tabs:tabs});
                        xmlElement.children().each(function(){methods.parseTabsPanel($(this),params);});
                        var addDocsIndex = -1,
                            commentsIndex = -1;
                        $('#ulTabs_'+params.localId).children().each(function(){
                            var el = $(this);
                            if(el.html() ==gis_ppanel_47) {
                                el.attr('data-source','SYS_DOCUMENT_LIST');
                                addDocsIndex = 0;
                            }
                            if(el.html() ==gis_ppanel_48) {
                                el.attr('data-source','SYS_COMMENT_LIST');
                                commentsIndex = 0;
                                //#1260 - Пытаемся получить реальные schema и table из слоя в layerManager
                                if (WidgetMap!=undefined && WidgetMap.layerManager!=undefined) {
                                    var curSelectedObjectId = params.options.objects[params.options.curObject].id;
                                    if (curSelectedObjectId.indexOf(':') > 0) {
                                        var prm = curSelectedObjectId.split(':');
                                        var curLayer = WidgetMap.layerManager.getLayerByName(prm[0]);
                                        if (curLayer && curLayer.dataProvider && curLayer.dataProvider.spatial!=undefined && curLayer.dataProvider.spatial!='') {
                                            //Получаем и обрабатываем xml с запросом геометрии
                                            var splittedArr = curLayer.dataProvider.spatial.split("#");
                                            var sendingData = '<data file="'+splittedArr[0]+'" dataId="'+splittedArr[1]+'"/>';
                                            //Получаем параметры для запроса и исправляем их на нужные нам
                                            var userId = Auth.getUserId();
                                            var userLogin = Auth.getUserName();
                                            var requestParams = { descrType: 'select', descrId: 'SYS_SEM.xml#GET_DATA_XML',
                                                data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
                                            methods.serverQueryNode(Services.processQueryNodeXml,
                                                requestParams, function onGetSpatialResult(resultXML){
                                                    try {
                                                        if (resultXML) {
                                                            var er = HTTPServiceUtil.getError(resultXML);
                                                            if (er!='') {
                                                                //Ничего не делаем - будем получать все по схеме и таблице, полученной из класса объекта
                                                            } else {
                                                                var schemaStartInd = resultXML.indexOf('schema="') + 8;
                                                                var schemaEndInd = resultXML.indexOf('"',schemaStartInd);
                                                                params.curSchema = resultXML.substring(schemaStartInd, schemaEndInd);
                                                                var tableStartInd = resultXML.indexOf('table="') + 7;
                                                                var tableEndInd = resultXML.indexOf('"',tableStartInd);
                                                                params.curTable = resultXML.substring(tableStartInd, tableEndInd);
                                                            }
                                                        }
                                                    } catch (err) {
                                                        //Ничего не делаем - будем получать все по схеме и таблице, полученной из класса объекта
                                                    }
                                                }, function onGetSpatialFault(resultXML){
                                                    //Ничего не делаем - будем получать все по схеме и таблице, полученной из класса объекта
                                                });
                                        }
                                    }
                                }
                            }
                        });
                        /*if(commentsIndex == -1)
                {
                 $(tabs.children()[0]).append('<li data-source="SYS_COMMENT_LIST">Комментарии</li>');
                 tabs.append('<div></div>');
                }*/
                        /* Прикрепленные документы теперь показываются по нажатию на кнопку, поэтому не добавляем их если вкладки нет в ALL_PROP_LIST */
                        /*if(addDocsIndex == -1 && params.options.creatingNewObject==false) {
                 $(tabs.children()[0]).append('<li data-source="SYS_DOCUMENT_LIST">Прикрепленные документы</li>');
                 tabs.append('<div></div>');
              }*/
                        var activePage = tabs.data('activePage');
                        //var tabsHeight = params.options.panelSize.propPanelHeight - 110;
                        var tabsHeight = $('#divContent_'+params.localId).outerHeight() - 30;
                        /*if(params.options.panelSize.propPanelHeight){
                            tabsHeight = params.options.panelSize.propPanelHeight - 110;
                        }*/
                        tabs.jqxTabs({theme:'myCommon', height:tabsHeight}).on('selected',function(event){
                            //Сразу после выбора другой вкладки блокируем кнопки в гридах комментариев и прикрепленных документов
                            methods.setCommentDocGridBtnDisabled(params, true);
                            if($(event.target).jqxTabs('getContentAt',event.args.item).html() != '')return;
                            var idRequest = $($('#ulTabs_'+params.localId).children()[event.args.item]).data('source');
                            var formDataProvider = $($('#ulTabs_'+params.localId).children()[event.args.item]).data('datarequest');
                            var fileName = '../../Public/Modules/Form/'+idRequest+'.mxml';
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {
                                    descrId: 'SYS_SEM.xml#GET_XML_FILE',
                                    descrType: 'select',
                                    data: '<root ><data FILE="' + fileName + '"/></root>'
                                },
                                methods.parseForm,$.extend(params,{selectedIndex:event.args.item,idRequest:idRequest,saveMethod:'getTabForm'}), undefined, false);
                        }).jqxTabs('select',activePage);
                        tabs.on('selecting',function(event){
                            var frmSelIndex = $(event.target).jqxTabs('selectedItem');
                            var frm = $('#frm_'+params.localId+'_'+frmSelIndex);
                            if(frm.length != 0) {
                                //Ставим фокус на первый компонент во вкладке
                                var formFirstTabIndex = (frmSelIndex + 1)*100 + 1;
                                $('#'+frm.attr('id')+' [tabindex="'+formFirstTabIndex+'"]').focus();
                            }
                            //Убираем выделение в гридах прикрепленных документов и комментариев перед переключением на вкладку
                            $("div[id^='divAddDocsContent_"+params.localId+"']").each(function(){
                                $($(this).children()[0]).jqxGrid('clearselection');
                            });
                            $("div[id^='divCommentContent_"+params.localId+"']").each(function(){
                                $($(this).children()[0]).jqxGrid('clearselection');
                            });
                        });
                        if(activePage == 0) {
                            var idRequest = $($('#ulTabs_'+params.localId).children()[0]).data('source');
                            var formDataProvider = $($('#ulTabs_'+params.localId).children()[0]).data('datarequest');
                            //Устанавливаем курсор ожидания
                            BlockingUtil.wait();
                            var fileName = '../../Public/Modules/Form/'+idRequest+'.mxml';
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {
                                    descrId: 'SYS_SEM.xml#GET_XML_FILE',
                                    descrType: 'select',
                                    data: '<root ><data FILE="' + fileName + '"/></root>',
                                    id:idRequest,
                                    selectScript:formDataProvider
                                },
                                methods.parseForm,$.extend(params,{selectedIndex:0,idRequest:idRequest,saveMethod:'getTabForm'}),undefined, false);
                        }
                        break;
                    case 'panel':
                        //Если  params.options.objects[params.options.curObject].id только указано название слоя, то форма добавления
                        //и необхъодимо пармить только вкладку паспорт
                        var isCreateNewObject = false;
                        if(params.options.objects[params.options.curObject].id.split(':').length == 1)
                            isCreateNewObject = true;
                        var isDefault = false;
                        if((xmlElement.attr('default') != undefined)&&(xmlElement.attr('default') == 'true')){
                            params.tabs.data('activePage',$(params.tabs.children()[0]).children().length);
                            isDefault = true;
                        }
                        //Проверяем вкладки из списка не реализованных, и если они там присутствуют - не добавляем
                        var sourceAttr = xmlElement.attr('source');
                        var requestAttr = xmlElement.attr('dataRequest');
                        if(isCreateNewObject){
                            if(isDefault){
                                $(params.tabs.children()[0]).append('<li data-source="'+sourceAttr+'" data-datarequest="'+requestAttr+'">'+xmlElement.attr('descr')+'</li>');
                                params.tabs.append('<div></div>');
                            }
                        }
                        else{
                            if (sourceAttr!='PODS_EVENT_GROUP_LIST' && sourceAttr!='PODS_OFFLINE_GROUP_LIST' && sourceAttr!='INTEGRATION') {
                                $(params.tabs.children()[0]).append('<li data-source="'+sourceAttr+'" data-datarequest="'+requestAttr+'">'+xmlElement.attr('descr')+'</li>');
                                params.tabs.append('<div></div>');
                            }
                        }
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseForm:function(xmlElement,params){
            try {
                var element,idElement;
                var visible = xmlElement.attr('visible'), addVisibleClass = '';
                //Если из задачи пришел options.showSystemInfo==true, показываем такие поля независимо от значения конфига (мы под админом), иначе - в зависимости от конфига
                if (params.options.showSystemInfo==false) {
                    var confShowFlag = 'SHOW_SYSTEM_INFO'; //Также прячем по значению конфига
                    if (visible!=undefined && visible=='{CONFIG.'+confShowFlag+'}' && App.config && (!App.config.hasOwnProperty(confShowFlag) || App.config[confShowFlag]==false)) visible='false';
                }
                //Если в форме напрямую указано visible="false", полюбому скрываем даже для админов (скрытое поле для отправки в запрос)
                if((visible != undefined)&&(visible == 'false')) addVisibleClass = 'noVisible';
                //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
                var valueFromConfig = null;
                if (xmlElement.attr('text')!=undefined && xmlElement.attr('text').toUpperCase().indexOf('{CONFIG.')==0 && App.config) {
                    var configProp = xmlElement.attr('text').toUpperCase().substring(8,xmlElement.attr('text').length-1);
                    if (App.config.hasOwnProperty(configProp)) {
                        valueFromConfig = App.config[configProp];
                    }
                }
                //Обрабатываем высоту и ширину, если они указаны (в пикселях или процентах)
                var curElementHeight = xmlElement.attr('height')!=undefined && xmlElement.attr('height').indexOf('%')==-1 ? xmlElement.attr('height')+'px' : xmlElement.attr('height');
                var curElementWidth = xmlElement.attr('width')!=undefined && xmlElement.attr('width').indexOf('%')==-1 ? xmlElement.attr('width')+'px' : xmlElement.attr('width');
                //Обрабатываем соответственно названию тега текущего элемента
                var needResize = true;
                if(params.selectedIndex !== 0){
                    needResize = false;
                }
                switch(xmlElement[0].tagName) {
                    case 'DATA_EDIT_FORM':
                        //Снимаем курсор ожидания
                        BlockingUtil.ready();
                        //BlockingUtil.unblockApplication();
                        if(typeof(params.selectedIndex) =='number') {
                            if(params.loadObject != params.options.curObject)return;
                            params.tabs.jqxTabs('setContentAt', params.selectedIndex, '<form id="frm_'+params.localId+'_'+params.selectedIndex+'" class="frmPanelTab" data-waitload="0"><div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTabContent"></div></form>');
                            //После парсинга элементов формы устанавливаем высоту
                            var tabsHeight = $('#divContent_'+params.localId).outerHeight() - 30;
                            if(params.options.panelSize.propPanelHeight)
                                tabsHeight = params.options.panelSize.propPanelHeight - 50;
                            //params.tabs.jqxTabs({height: tabsHeight - 20/*60*/}); /*$('#divContent_'+params.localId).outerHeight()*/
                            if(needResize)
                                params.tabs.jqxTabs({height:tabsHeight}); /**/
                            //var outerWidth = $('#divContent_'+params.localId).outerWidth()
                            //Обрабатываем атрибуты тега DATA_EDIT_FORM
                            var curDivTabContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
                            if (xmlElement.attr('width')!=undefined) methods.setStyleElement({xmlElement:xmlElement[0],element:curDivTabContent});
                            if (xmlElement.attr('title')!=undefined) curDivTabContent.data('title',xmlElement.attr('title'));
                            if (xmlElement.attr('ext_data_id')!=undefined) curDivTabContent.data('ext_data_id',xmlElement.attr('ext_data_id'));
                            if (xmlElement.attr('excelTemplate')!=undefined) curDivTabContent.data('excelTemplate',xmlElement.attr('excelTemplate'));
                            //основной идентификатор, который будет использоваться из объекта вкладки на заполнение. по умолчанию ID
                            (xmlElement.attr('initialId')!=undefined)?curDivTabContent.data('initialId',xmlElement.attr('initialId')):curDivTabContent.data('initialId','ID');
                            //сценарий, содержит связывающее событие с кнопкой
                            (xmlElement.attr('scenario')!=undefined)?curDivTabContent.data('scenario',xmlElement.attr('scenario')):curDivTabContent.data('scenario',undefined);
                        }
                        //Если нет label у панели свойств, берем его из описания формы паспорта. Не пишем 1 из 1, когда создаем новый объект, но пишем, если получили информацию именно из 1 объекта
                        if (params.selectedIndex==0) {
                            var objectInArrText = params.options.creatingNewObject==true ? '' : (params.options.curObject+1)+gis_ppanel_44+params.options.objects.length;
                            var objectLabel = params.options.objects[params.options.curObject].label==undefined ? '' : params.options.objects[params.options.curObject].label;
                            if (objectLabel=='' && xmlElement.attr('title')!=undefined) objectLabel = xmlElement.attr('title');
                            $('#spNameObject_'+params.localId).text(objectInArrText+' '+objectLabel);
                        }
                        if(params.unlockCombo != undefined)
                            params.divProperties.data('unlockCombo',params.unlockCombo);
                        else params.divProperties.data('unlockCombo',0);
                        $.extend(params,{div:methods.getDivContent(params),parentClass:'',rules:[],tableReadOnly:xmlElement.attr('readOnly')=='true'});
                        //Устанавливаем начальный tabIndex для формы как params.selectedIndex*100 (лимит по 100 контролов в каждой вкладке)
                        params.options.tabIndex = (params.selectedIndex + 1)*100;
                        params.options.lastTabIndex = params.options.tabIndex+1; //Запоминаем первый в текущей форме, к нему будем прибавлять новые индексы на каждый контрол
                        //Парсим остальные элементы формы
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        //Ставим валидатор для текущей формы
                        try{
                            $('#frm_'+params.localId+'_'+params.selectedIndex).jqxValidator({
                                rules:params.rules,
                                animation:'none',
                                onError: function (errorArr) {
                                    var fullErrorText = '';
                                    var errObj = {};
                                    for (var j=0; j<errorArr.length; j++) {
                                        var elemId = undefined;
                                        if(errorArr[j][0].attributes['id'])
                                            elemId = errorArr[j][0].attributes['id'].value;
                                        else{
                                            elemId = errorArr[j].selector.split(' ')[0].replace('#','');
                                        }
                                        if (!errObj.hasOwnProperty(elemId)) {
                                            //Изгаляемся, чтобы получить сообщение об ошибке для контрола выбора файла - в нем нет .data('validateErrorText')
                                            var curErrText = $(errorArr[j][0]).data('validateErrorText');
                                            if (curErrText==undefined) {
                                                for (var k=0; k<params.rules.length; k++) {
                                                    if (params.rules[k].input=='#'+elemId) {
                                                        curErrText = params.rules[k].message;
                                                        break;
                                                    }
                                                }
                                            }
                                            if (curErrText!=undefined) {
                                                fullErrorText += curErrText + '<br/>';
                                                errObj[elemId] = elemId;
                                                //$(errorArr[j][0]).addClass('jqx-validator-error-element'); //Добавляем класс валидированного элемента
                                            }
                                        }
                                    }
                                    var alertForm = new AlertForm();
                                    alertForm.build('pPanel_'+params.localId+'_AlertForm', fullErrorText, gis_ppanel_27, AlertForm.OK);
                                }
                            }).data('dataProvider',params.dataProvider);
                        }
                        catch(ex)
                        {
                        }
                        //Если не insert - выполняем запрос на получение данных текущего объекта
                        if(typeof(params.selectedIndex) =='number') {
                            var prm = params.options.objects[params.options.curObject].id.split(':'),
                                db= prm[0].split('_'),
                                db_schema = db[0],
                                db_table_id = db.slice(1).join('_');
                            methods.setAttrsValues(params);
                            if(prm.length > 1 && prm[1] != undefined) {
                                $('#frm_'+params.localId+'_'+params.selectedIndex).data('scriptType','SELECT');
                                var initialId='ID';
                                var idField = prm[0];
                                var idValue = prm[1];
                                var iliDataId = '';
                                var iliTypeField = idField === 'PODS_ILI_CLUSTER'?'ILI_CLUSTER_ID':'ILI_DATA_ID';
                                try{
                                    if(params &&  params.options && params.options.objects){
                                        initialId = params.div.data('initialId');
                                        if( params.options.objects[params.options.curObject]['curRowData']){
                                            if(params.options.objects[params.options.curObject]['curRowData'][initialId])
                                                idValue = params.options.objects[params.options.curObject]['curRowData'][initialId];
                                            iliDataId = params.options.objects[params.options.curObject]['curRowData'][iliTypeField];
                                            if(iliDataId === undefined) iliDataId = '';
                                        }
                                    }
                                }
                                catch(ex){}
                                //доп. проверка, если не нашло LIST_ID, то устанавливаем в NULL
                                if(!idValue) idValue = 'NULL';
                                if(iliDataId === '' )  iliDataId = prm[1];
                                //случай если открываем из кнопки грида у ведомости шурфовок, то извне приходит ili_cluster_id, если работаем с кластером
                                if(params && params.options && params.options.data && params.options.data.ILI_CLUSTER_ID)
                                    iliTypeField = 'ILI_CLUSTER_ID';
                                //iliDataId = params.options.data.ILI_CLUSTER_ID

                                if(initialId === 'LIST_ID'/*&& idValue === 'NULL'*/){
                                    //получаем sheetId, если не нашли, то пустая форма.
                                    //если нашли, то просто за
                                    methods.getSheetId(prm[1],params.idRequest,function(sheetId, stoEventId, type){
                                        if(sheetId === undefined)
                                            sheetId = 'NULL';
                                        methods.serverQueryNode(Services.processQueryNode,
                                            {descrId:params.dataProvider+'#'+$($('#ulTabs_'+params.localId).children()[params.selectedIndex]).data('source'),
                                                descrType:'select',
                                                data: '<root USER_ID="' + Auth.getUserId() + '" USER_LOGIN="' + Auth.getUserName() + '" PODS_USER="' + Auth.getUserName() + '">' +
                                                    '<data FILTER="SHEET_ID=' + sheetId +' AND ' + iliTypeField + '='+iliDataId+
                                                    '" SYS_FULL_ID="' + idField + '/' + idValue +
                                                    '" DB_SCHEMA_ID="' + db_schema +
                                                    '" DB_TABLE_ID="' + db_table_id +
                                                    '" SYS_CLASS_ID="' + idField +
                                                    '" SYS_OBJ_ID="' + idValue + '"/></root>'
                                            }, methods.parseTabValues, params, true);
                                    },params);
                                }
                                else
                                    methods.serverQueryNode(Services.processQueryNode,
                                        {descrId:params.dataProvider+'#'+$($('#ulTabs_'+params.localId).children()[params.selectedIndex]).data('source'),
                                            descrType:'select',
                                            data: '<root USER_ID="' + Auth.getUserId() + '" USER_LOGIN="' + Auth.getUserName() + '" PODS_USER="' + Auth.getUserName() + '">' +
                                                '<data FILTER="ID=' + idValue +
                                                '" SYS_FULL_ID="' + idField + '/' + idValue +
                                                '" DB_SCHEMA_ID="' + db_schema +
                                                '" DB_TABLE_ID="' + db_table_id +
                                                '" SYS_CLASS_ID="' + idField +
                                                '" SYS_OBJ_ID="' + idValue + '"/></root>'
                                        }, methods.parseTabValues, params, true);
                            } else {
                                $('#frm_'+params.localId+'_'+params.selectedIndex).data('scriptType','INSERT');
                                //И только в самом конце, после свойств объекта запрашиваем данные комбобоксов
                                $('#divTabContent_'+params.localId+'_'+params.selectedIndex).find('[data-typecontrol="combobox"]').each(function (){
                                    var element = $(this);
                                    if(element.attr('dataProvider') != undefined) {
                                        var comboDataProvider = new QueryDataProvider({
                                            requestSource: element.attr('dataProvider'),
                                            dataField: element.jqxComboBox('valueMember'),
                                            labelField: element.jqxComboBox('displayMember'),
                                            resultHandler: function(){
                                                methods.setComboBoxDataProvider(this,{comboBox:element,divProperties:params.divProperties,localId:params.localId, options: params.options});
                                            }
                                        });
                                    }
                                });
                                params.divProperties.data('unlockCombo',1);
                                methods.unlockFormControls(params);
                                $('#frm_'+params.localId+'_'+params.selectedIndex+' [tabindex="'+params.options.lastTabIndex+'"]').focus();
                            }
                        } else {
                            //Получаем списки для всплывающих popup создания новых документов (только при вставке нового)
                            if (params.hasOwnProperty('action') && params.action=='insert') {
                                $('#divTabContent_' + params.localId + '_' + params.selectedIndex).find('[data-typecontrol="combobox"]').each(function () {
                                    var element = $(this);
                                    if(element.attr('dataProvider') != undefined) {
                                        var comboDataProvider = new QueryDataProvider({
                                            requestSource: element.attr('dataProvider'),
                                            dataField: element.jqxComboBox('valueMember'),
                                            labelField: element.jqxComboBox('displayMember'),
                                            resultHandler: function(){
                                                methods.setComboBoxDataProvider(this,{comboBox:element,divProperties:params.divProperties,localId:params.localId, options: params.options});
                                            }
                                        });
                                    }
                                });
                            }
                        }
                        methods.checkLeftButtons(params);
                        break;
                    case 'DATA_GRID_FORM':
                        //Снимаем курсор ожидания
                        BlockingUtil.ready();
                        //BlockingUtil.unblockApplication();
                        if(typeof(params.selectedIndex) =='number')
                        {
                            if(params.loadObject != params.options.curObject)return;
                            params.tabs.jqxTabs('setContentAt', params.selectedIndex, '<div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTabContent"></div>');
                        }
                        $.extend(params,{div:methods.getDivContent(params),
                            parentClass:'',
                            rules:[],
                            tableReadOnly:xmlElement.attr('readOnly')=='false'});
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        methods.setAttrsValues(params);
                        methods.checkLeftButtons(params);
                        break;
                    case 'DataGridWithScript':
                        $.extend(params,{dataGrid:{width:'100%',
                                height:'100%',
                                pageable: false,
                                columnsresize: true,
                                showemptyrow:false,
                                altrows:true,
                                selectionmode: 'singlerow',
                                columns: [],
                                theme:'myCommon',
                                sortable:true,
                                columnsmenu: false,
                                editable:params.tableReadOnly},
                            selectScript:'',
                            source:{datatype: 'xml',
                                datafields: [],
                                root: 'root',
                                record: 'data',
                                localdata:''}});
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        var idTable = 'divTable_'+methods.getUniqueId();
                        element = $('<div id="'+idTable+'" class="vBox" data-selectscript="'+params.selectScript+'"></div>');
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        element.jqxGrid(params.dataGrid);
                        var onGridChangeSelect = function onGridChangeSelect(event) {
                            try {
                                var btnDisabled = !event || event.type!='rowselect';
                                methods.setCommentDocGridBtnDisabled(params, btnDisabled);
                            } catch (e) {}
                        };
                        //Привязываемся к событиям смены выделения в гриде, чтобы блокировать/разблокировать кнопки
                        element.on('rowselect', onGridChangeSelect);
                        //Для грида комментариев добавляем слушатель события двойного клика
                        var curElementId = element.parent()!=undefined && element.parent().length>0 ? element.parent().attr('id') : '';
                        if (curElementId=='divCommentContent_'+params.localId+'_'+params.selectedIndex) {
                            element.on('rowdoubleclick', function commentGridDblClick(event) {
                                var divContent = element.parent();
                                $('#btnEditComment_'+curElementId.replace('divCommentContent_','')).jqxButton().click();
                            });
                        }
                        //Для грида прикрепленных документов добавляем слушатель события двойного клика
                        if (curElementId=='divAddDocsContent_'+params.localId+'_'+params.selectedIndex) {
                            element.on('rowdoubleclick', function docGridDblClick(event) {
                                var divContent = element.parent();
                                $('#btnOpenDoc_'+curElementId.replace('divAddDocsContent_','')).jqxButton().click();
                            });
                        }
                        //
                        params.div.data('selectscript',params.selectScript);
                        var prm = params.options.objects[params.options.curObject].id.split(':'),
                            db= prm[0].split('_'),
                            db_schema = db[0],
                            db_table_id = db.slice(1).join('_');
                        //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                        if (params.hasOwnProperty('curSchema') && params.hasOwnProperty('curTable')) {
                            db_schema = params.curSchema;
                            db_table_id = params.curTable;
                        }
                        methods.serverQueryStringNode(Services.processQueryNode,
                            {descrId:params.selectScript,
                                descrType:'select',
                                getSchema:false,
                                toElements:false,
                                data:'<root><data FILTER="ID='+prm[1]+
                                    '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                    '" ID="'+prm[1]+
                                    '" DB_SCHEMA_ID="'+db_schema+
                                    '" DB_TABLE_ID="'+db_table_id+
                                    '" SYS_CLASS_ID="'+prm[0]+
                                    '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.setTableData,
                            $.extend({divProperties:params.divProperties,
                                source:params.source,
                                idTable:idTable,
                                localId:params.localId}));
                        break;
                    case 'columns':
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        var no = params.dataGrid.columns.length - params.source.datafields.length,
                            col = Math.floor((100-5*no)/(xmlElement.children().length-no));
                        $(params.dataGrid.columns).each(function(){
                            if(this.width=='0%')this.width =col+'%';
                        });
                        break;
                    case 'mx:DataGridColumn':
                        var fieldName = xmlElement.attr('dataField');
                        if(fieldName != undefined){
                            var colWidth = '0%';
                            var defaultRenderer = function(row, columnfield, value, defaulthtml, columnproperties){
                                var noPaddingsHtml = $(defaulthtml);
                                //если поле с координатами тип отображения градусы, то конвертируем
                                if(WidgetMap && WidgetMap.COORD_FIELDS && WidgetMap.coordMode === WidgetMap.COORD_MODES.GRAD && WidgetMap.COORD_FIELDS.indexOf(columnfield) !== -1){
                                    var gradCoord = GeoUtil.convertDecimalIntoDegree(value);
                                    return defaulthtml.replace('>'+value+'<','>'+gradCoord+'<' )
                                }
                            }
                            var linkRenderer = function(row, columnfield, value, defaulthtml, columnproperties){
                                //Public/Data/LIB/
                                var newVal = (App.config && App.config.LIB_PATH) ? App.config && App.config.LIB_PATH + value : value;
                                var link = '<a class="" href="'+newVal+'" target="_blank" title="Ссылка" ' +
                                    ' style="width:19px; height:18px; padding:0px; display: block;" >Скачать файл</a>'
                                return (value)?defaulthtml.replace('>'+value+'<','>'+link+'<' ):defaulthtml.replace('>'+value+'<','><' );
                            }

                            var cellRenderer = defaultRenderer;
                            if(xmlElement.attr('itemRenderer') === 'view.controls.renderer.GridLinkItemRenderer'){
                                cellRenderer = linkRenderer;
                            }

                            if(xmlElement.attr('width')){
                                colWidth = Number(xmlElement.attr('width'));
                            }
                            params.dataGrid.columns.push({text: xmlElement.attr('headerText'),datafield: fieldName,width:colWidth,
                                cellsrenderer: cellRenderer
                            });
                            params.source.datafields.push({name: fieldName, map: '['+fieldName+']'});
                        }
                        else
                            params.dataGrid.columns.push({text: xmlElement.attr('headerText'),datafield: "", columntype: 'number',width:'5%'});
                        break;
                    case 'selectScript':params.selectScript=xmlElement.text();break;
                    case 'dataProvider':
                        $.extend(params,{dataProvider:xmlElement.text()});
                        break;
                    case 'mx:VBox':
                        element = $('<div class="vBox '+addVisibleClass+'"></div>');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined && curElementWidth!='50%') element.css('width',curElementWidth); // curElementWidth!='50%' - чтобы растровые бланки не сжимались внутри ячейки
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var oldValues = {div:params.div,oldParentClass:params.parentClass};
                        params.div = element;
                        params.parentClass = '';
                        xmlElement.children().each(function(){methods.parseForm($(this),params)});
                        params.parentClass = oldValues.oldParentClass;
                        params.div = oldValues.div;
                        break;
                    case 'mx:HBox':
                        element = $('<div class="pPanelTable '+addVisibleClass+'"><div class="pPanelTableRow"></div></div>');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined && curElementWidth!='50%') element.css('width',curElementWidth); // curElementWidth!='50%' - чтобы растровые бланки не сжимались внутри ячейки
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var oldValues = {div:params.div,oldParentClass:params.parentClass};
                        params.div = $(element.children()[0]);
                        params.parentClass = 'pPanelTableCell';
                        xmlElement.children().each(function(){methods.parseForm($(this),params)});
                        params.parentClass = oldValues.oldParentClass;
                        params.div = oldValues.div;
                        break;
                    case 'mx:HRule':
                        element = $('<hr/>');
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        break;
                    case 'mx:TextInput':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        var fieldName = idElement.substring(0, idElement.indexOf('_'+params.localId));
                        params.options.tabIndex++;
                        var inputType = xmlElement.attr('displayAsPassword')!=undefined && xmlElement.attr('displayAsPassword')=='true' ? 'password' : 'text';
                        element = $('<input id="'+idElement+'" type="'+inputType+'" data-fieldname="' + fieldName + '" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
                        if (curElementHeight!=undefined) {
                            //Обрабатываем случай, если высота > 30, то считаем что нам нужен textArea для отображения в нескольких строках
                            if (parseFloat(xmlElement.attr('height'))>30) element = $('<textArea id="'+idElement+'" type="text" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
                            element.css('height',curElementHeight);
                        }
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        element.jqxInput({disabled:true,theme:'myCommon'}).on('keyup contextmenu input',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        if(defaultSelectedValue){
                            element.data('selectedvalue', defaultSelectedValue);
                            var data = (params.options && params.options.data)? params.options.data: null;
                            if(data && data[defaultSelectedValue])
                                methods.setControlValue(element, {value: data[defaultSelectedValue] });
                        }
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
                        if (valueFromConfig!=null) element.val(valueFromConfig);
                        if(params.idRequest == 'COSMETIC_OBJECT'){
                            var labelVal = params.options.objects[params.options.curObject][xmlElement.attr('id')];
                            element.val(labelVal)
                        }
                        break;
                    case 'mx:Text':
                        var id = '',text = '&nbsp;';
                        if(xmlElement.attr('text') != undefined)text = xmlElement.attr('text');
                        if(xmlElement.attr('id') != undefined)id = ' id="'+methods.getIdControl({xmlElement:xmlElement,params:params})+'"';
                        methods.appendFormElement({params:params,element:$('<span'+id+' data-typecontrol="label" class="'+addVisibleClass+'">'+text+'</span>'),xmlElement:xmlElement[0]});
                        break;
                    case 'mx:ComboBox':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        params.options.tabIndex++;
                        params.enabledCombo = xmlElement.attr('enabledCombo');
                        element = $('<div id="'+idElement+'" class="noListValues formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-typecontrol="combobox" data-loadvalue=false tabindex="'+params.options.tabIndex+'"></div>');
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var curComboHeight = curElementHeight!=undefined ? parseFloat(xmlElement.attr('height'))-2 : 16;
                        var curComboWidth = curElementWidth!=undefined ? parseFloat(xmlElement.attr('width')) : '100%';
                        var placeHolder = xmlElement.attr('hint')!=undefined ? xmlElement.attr('hint') : '';
                        var valueMember = xmlElement.attr('valueMember')!=undefined ? xmlElement.attr('valueMember') : 'CODE';
                        var displayMember = xmlElement.attr('displayMember')!=undefined ? xmlElement.attr('displayMember') : 'DESCR';
                        var defaultSelectedIndex = xmlElement.attr('selectedIndex')!=undefined ? parseFloat(xmlElement.attr('selectedIndex')) : -1;
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        element.jqxComboBox({valueMember:valueMember,displayMember:displayMember,width:curComboWidth, autoComplete: true, disabled:true, height:curComboHeight,dropDownHeight:130,dropDownWidth:curComboWidth, placeHolder:placeHolder, searchMode: 'containsignorecase',theme:'myCommon'}).on('change',function(){
                            if ($(this).hasClass('noListValues') == false && params.tableReadOnly == false)
                                methods.markChange($.extend(params,{control:$(this)}));
                        });
                        element.attr('defaultSelectedIndex',defaultSelectedIndex);
                        if(defaultSelectedValue)
                            element.data('selectedvalue', defaultSelectedValue)
                        if(xmlElement.attr('dataProvider') != undefined)
                            element.attr('dataProvider',xmlElement.attr('dataProvider'));
                        xmlElement.children().each(function(){methods.parseForm($(this),{options:params.options, comboBox:element});});
                        //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
                        if (valueFromConfig!=null) element.val(valueFromConfig);
                        break;
                    case 'mx:dataProvider':
                        var selectedIndex = -1;
                        var comboDataProv = [];
                        xmlElement.children().each(function(){
                            var curObj = { DESCR: $(this).attr('DESCR'), CODE: $(this).attr('CODE')};
                            comboDataProv.push(curObj);
                        });
                        var disabledCombo = params.comboBox.hasClass('noEditable');
                        var autoDropDownHeight = comboDataProv.length<=5 ? true : false; //При наличии в списках 5 и менее элементов нужно dropdown сжимать по их количеству
                        //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
                        if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1) selectedIndex = 0;
                        params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo,selectedIndex:selectedIndex,autoDropDownHeight:autoDropDownHeight, searchMode: 'containsignorecase', autoComplete: true });
                        params.comboBox.removeClass('noListValues');
                        break;
                    case 'mx:Button':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        element = $('<button id="'+idElement+'"></button>');
                        //По атрибуту styleName разделяем обычные кнопки и кнопки-иконки
                        var title = (xmlElement.attr('toolTip'))? xmlElement.attr('toolTip'): "";
                        if(xmlElement.attr('styleName') != undefined)
                            element = $('<div id="'+idElement+'" class="divIconButton '+xmlElement.attr('styleName')+'Icon '+addVisibleClass+'"></div>');
                        else {
                            var btnLabel = xmlElement.attr('label') != undefined ? xmlElement.attr('label') : '';
                            element = $('<button id="'+idElement+'" class="myButton '+addVisibleClass+'">'+btnLabel+'</button>');
                        }
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        element.attr('title', title);
                        element.attr('selectedField',xmlElement.attr('selectedField')!=undefined ? xmlElement.attr('selectedField') : '');
                        element.attr('btnStyleName',xmlElement.attr('styleName')!=undefined ? xmlElement.attr('styleName') : '');
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        element.jqxButton({theme:'myCommon', disabled: methods.checkEditable(xmlElement,params)=='noEditable'});
                        element.on('click', {elemId:idElement}, function goToLinkedObject(evt) {
                            evt.preventDefault();
                            var clickBtn = $('#'+evt.data.elemId);
                            var selectedField = clickBtn.attr('selectedField');
                            if (selectedField!='') {
                                //Получаем связанный с кнопкой объект
                                var idStr = clickBtn.attr('id');
                                var linkObj;
                                //Не привязываем кнопку к списку, если мы создаем новую запись.
                                if (idStr.substr(0,7)=="BUTTON_" && !params.options.creatingNewObject)
                                    linkObj = $('#'+idStr.substring(7));
                                else if (idStr.substr(0,9)=="BTN_LIST_")
                                    linkObj = $('#'+idStr.substring(9));
                                else if (idStr.substr(0,9)=="BTN_FILE_" && !params.options.creatingNewObject) //Кнопка перехода к файлу активна только если не создаем запись и есть имя файла
                                    linkObj = $('#'+idStr.substring(9));
                                //очищаем btn.data, чтобы если значения в поле нет, не осуществлять переход
                                var btnData = null;
                                var typeControl = '';
                                if (linkObj.length > 0) {
                                    typeControl = linkObj.data('typecontrol');
                                    if (typeControl=='combobox' && linkObj.jqxComboBox('getSelectedItem')!=null)
                                        btnData = selectedField+"/"+linkObj.jqxComboBox('val');
                                    else if (typeControl=='input' && linkObj.val()!='')
                                        btnData = selectedField+"/"+linkObj.val();
                                    else if (typeControl=='numberinput' && linkObj.val()!='')
                                        btnData = selectedField+"/"+linkObj.val();
                                    //если переходим к файлу, в btnData устанавливаем путь к файлу
                                    else if (typeControl=='inputfile' && linkObj.attr('value')!='') {
                                        if (App.config.DATA_PATH === undefined){
                                            App.errorReport(gis_core_17, 'DATA_PATH' + gis_core_18, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_22'});
                                            return;
                                        }
                                        btnData = App.config['DATA_PATH'] + linkObj.data('uploadpath') + linkObj.attr('value');
                                        btnData = btnData.replace(/\\/g,"/");
                                    }
                                }
                                //По нажатию на кнопку может осуществляться: переход к значению из comboBox,
                                //редактирование справочника либо открытие файла
                                //Не переходим по кнопке к файлу, если мы создаем новую запись.
                                if (clickBtn.attr('id').substr(0,9)=="BTN_FILE_" && (typeControl=='inputfile' || typeControl=='input' || typeControl=='numberinput') && !params.options.creatingNewObject && btnData) {
                                    var addIdStr = '_'+params.localId+'_'+params.selectedIndex;
                                    //Для открытия 3D-сцены или IMG-карты проверяем тип прикрепленного документа
                                    var docTypeId = $('#DOC_TYPE_ID'+addIdStr).length>0 ? $('#DOC_TYPE_ID'+addIdStr).val() : '';
                                    if (docTypeId!='' && ($('#DOC_VERSION_ID'+addIdStr).length>0 || $('#DOC_ID'+addIdStr).length>0) && (docTypeId=="37" || docTypeId=="38" || docTypeId=="41")) {
                                        var docObj = {};
                                        docObj.DOC_ID = $('#DOC_VERSION_ID'+addIdStr).length>0 ? $('#DOC_VERSION_ID'+addIdStr).val() : $('#DOC_ID'+addIdStr).val();
                                        docObj.FILE_NAME = linkObj.val(); /*(linkObj is FileInput) ? (linkObj as FileInput).fileLoading.text : (linkObj as TextInput).text;*/
                                        switch (docTypeId) {
                                            case "37":	//3Dсцена
                                                ExportUtil.exportToWRL(docObj.DOC_ID, docObj.FILE_NAME);
                                                break;
                                            case "38":	//IMG-карта
                                                ExportUtil.exportToIMG(docObj.DOC_ID, docObj.FILE_NAME);
                                                break;
                                            case "41":	//Видеофайл
                                                var rowDataObj = {};
                                                rowDataObj.ID = docObj.DOC_ID;
                                                rowDataObj.FILE_NAME = docObj.FILE_NAME;
                                                showVideo(docObj.DOC_ID, docObj.FILE_NAME, $('#NAME'+addIdStr).length>0 ? $('#NAME'+addIdStr).val() : gis_ppanel_49);
                                                //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                                widgetMoveWindowToPosition('grid');
                                                break;
                                        }
                                    } else {
                                        //Если документ не является ни 3D-сценой, ни IMG-картой, ни видеофайлом - открываем его
                                        var fileName = linkObj.attr('value');
                                        HTTPServiceUtil.openFile(btnData, {specificPdfFileName: fileName, parentDir: pPanelOpenDocPath});
                                    }
                                } else if (clickBtn.attr('btnStyleName')=="refList" && typeControl=='combobox') {
                                    //В selectedField "ИМЯ_ФАЙЛА#ИДЕНТИФИКАТОР_ИСТОЧНИКА".
                                    //Точно разделить значение схемы и таблицы невозможно, поэтому считаем что в названии схемы нет символа "_"
                                    var dirForm = new DirectoryEditForm({requestSQL:selectedField,
                                        source:linkObj[0].getAttribute('dataProvider').split('#')[0],
                                        requestSource:linkObj[0].getAttribute('dataProvider')
                                    });
                                    dirForm.build();
                                    /*showDirectoryEditForm(btn.selectedField, (linkObj as ComboBox).id);*/
                                } else if (clickBtn.attr('btnStyleName')=="refObject" && !params.options.creatingNewObject && btnData) {
                                    //Затираем callback-функцию changePanelObjectCallback, чтобы при открытии панели с карты и переходе на объекты без слоя не кидалось сообщение об ошибке
                                    if (params.options.handlers && params.options.handlers.changePanelObjectCallback!=undefined)
                                        params.options.handlers.changePanelObjectCallback = undefined;
                                    //переходим по кнопке к объекту
                                    var linkedObjParams = {
                                        divProperties:params.divProperties,
                                        localId:params.localId,
                                        options:{objects:[{id:btnData.replace('/',':')}], curObject:0, handlers:params.options.handlers, opener:params.options.opener}
                                    };
                                    methods.openObjectInNewPanel(linkedObjParams);
                                }
                            }
                        });
                        break;
                    case 'mx:CheckBox':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        params.options.tabIndex++;
                        //тип чекбокса: принимает значения либо 0|1(случай sqlite) либо Y|N
                        var checkboxValueType = xmlElement.attr('type')=="number"?"number":'boolean';
                        element = $('<div id="'+idElement+'" data-typecontrol="checkbox" data-typevalue="'+checkboxValueType+'" class="formControl myCheckBox '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'"></div>');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var isChecked = xmlElement.attr('selected')=="true" ? true : false;
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        if(defaultSelectedValue)
                            element.data('selectedvalue', defaultSelectedValue)
                        element.jqxCheckBox({disabled:true,checked:isChecked,theme:'myCommon'}).on('change',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        break;
                    case 'mx:RadioButton':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        params.options.tabIndex++;
                        element = $('<div id="'+idElement+'" data-typecontrol="radio" class="formControl myRadio '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'"></div>');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var isChecked = xmlElement.attr('selected')=="true" ? true : false;
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        if(defaultSelectedValue)
                            element.data('selectedvalue', defaultSelectedValue)
                        element.jqxCheckBox({disabled:true,checked:isChecked,theme:'myCommon'}).on('change',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        $("#admRoutesIntervalDividingForm_useIntervalsButton").jqxRadioButton({checked: true, width:120, height:25, groupName:'useRegularIntervalsGroup'}).on('change', function (event) {
                            var checked = event.args.checked;
                            regularIntervalsDistanceInput.jqxInput({disabled: !checked});
                        });
                        $("#admRoutesIntervalDividingForm_dontUseIntervalsButton").jqxRadioButton({width:120, height:25, groupName:'useRegularIntervalsGroup'}).on('change', function (event) {
                            var checked = event.args.checked;
                            //Блокируем поле PODS_FEATURE_TABLE
                            $("div[ data-dataprovider='"+GridAdmRoutesIntervalDividingForm.PODS_FEATURE_TABLE_REQUEST+"']", dlg).each( function (){
                                $(this).jqxExpander({disabled: !checked});
                            });
                        });
                        break;
                    case 'mx:DateField':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        params.div.addClass('mxForm');
                        // Считываем общие аттрибуты
                        var cssWidth;
                        var width = xmlElement.attr('width');
                        if(/^(\d+)%$/) { // А вдруг указаны проценты
                            cssWidth = width;
                        }
                        else if(width > 0) {
                            cssWidth = width + 'px';
                        }
                        var percentWidth = xmlElement.attr('percentWidth');
                        if(percentWidth > 0) {
                            cssWidth = percentWidth*1 + '%';
                        }
                        var cssHeight = xmlElement.attr('height');
                        if(cssHeight) { cssHeight += 'px'; }
                        var formatString = (xmlElement.attr("formatString"))? xmlElement.attr("formatString"): 'dd:mm:yyyy';
                        var element = $('<div id="'+idElement+'" data-typecontrol="date" data-format=' + formatString + ' class="control formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false >' +
                            '<input type="text" class="date" maxlength="12" /></div>');

                        //Добавляем в форму
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});

                        var inp = $('input', element);
                        inp.change(function() {
                            methods.markChange($.extend(params,{control:$(this).parent()}));
                        });
                        if(addVisibleClass=='noEditable') element.attr('readonly', 'readonly').addClass('readOnly');
                        if(cssWidth) { element.css('width', cssWidth); }
                        if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }
                        // Для полей типа даты, которые доступны к редактированию устанавливаем datepicker
                        $('input.date', element).not('.readOnly').datepicker();
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        if(defaultSelectedValue){
                            element.data('selectedvalue', defaultSelectedValue);
                            var data = (params.options && params.options.data)? params.options.data: null;
                            if(data && data[defaultSelectedValue])
                                methods.setControlValue(element, {value: data[defaultSelectedValue] });
                        }

                        params.options.tabIndex++;
                        inp.attr('tabindex', params.options.tabIndex);
                        break;
                    case 'controls:NumberInput':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        var fieldName = idElement.substring(0, idElement.indexOf('_'+params.localId));
                        params.options.tabIndex++;
                        element = $('<input id="'+idElement+'" type="text" data-fieldname="' + fieldName + '" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
                        //element = $('<div id="'+idElement+'" data-typecontrol="numberinput" class="formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        if(defaultSelectedValue)
                            element.data('selectedvalue', defaultSelectedValue);
                        element.jqxInput({disabled:true,theme:'myCommon'}).on('keyup contextmenu input',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
                        if (valueFromConfig!=null) element.val(valueFromConfig);
                        //если поле с координатами тип отображения градусы, то конвертируем
                        if(WidgetMap && WidgetMap.COORD_FIELDS && WidgetMap.coordMode === WidgetMap.COORD_MODES.GRAD && WidgetMap.COORD_FIELDS.indexOf(fieldName) !== -1){
                            break;
                        }
                        //element.jqxNumberInput({decimalDigits: 2, inputMode: 'simple', groupSeparator: "", disabled:true,theme:'myCommon'}).on('keyup',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        //element.jqxNumberInput.val(null);
                        params.rules.push({
                            input: '#'+idElement,
                            message: gis_ppanel_50,
                            action: 'none',
                            rule: function(){var val = $('#'+idElement).val();
                                if(val != '')return /^[+-]?\d*(\.\d+)?$/.test(val);
                                else return true;},
                            hintRender:function(message, input){
                                if (input.length > 0) $(input[0]).data('validateErrorText',message);
                            }
                        });
                        break;
                    case 'validatorsArray':
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        break;
                    case 'controls:DefaultEmailValidator':
                        idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
                        if($('#'+idElement).length == 0)return;
                        params.rules.push({
                            input: '#'+idElement,
                            message: gis_ppanel_51,
                            action: 'none',
                            rule: 'email',
                            hintRender:function(message, input){
                                if (input.length > 0) $(input[0]).data('validateErrorText',message);
                            }
                        });
                        break;
                    case 'controls:DefaultDateValidator':
                    case 'controls:DefaultStringValidator':
                    case 'controls:DefaultNumberValidator':
                        idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
                        if($('#'+idElement).length == 0)return;
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        break;
                    case 'controls:DefaultComboBoxValidator':
                    case 'controls:ComboBoxValidator':
                        idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
                        if($('#'+idElement).length == 0)return;
                        if(xmlElement.attr('required') == 'true'){
                            xmlElement.attr('required','false');
                            xmlElement.attr('requiredcombo','true');
                        }
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        break;
                    case 'controls:FieldComparisonValidator':
                        idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
                        if($('#'+idElement).length == 0)return;
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        break;
                    case 'controls:FileInput':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        var accept = '';
                        if(xmlElement.attr('fileFilterExtension') != undefined)accept = ' accept="'+xmlElement.attr('fileFilterExtension').replace(/\*/g,'')+'"';
                        element = $('<input id="'+idElement+'" type="hidden" value="" data-typecontrol="inputfile" class="formControl" data-loadvalue=true data-uploadpath="'+xmlElement.attr('uploadPath')+'"/>\
                           <div id="divFI_'+idElement+'" class="divFileInput">\
                            <input class="divFileInputName noVisible" />\
                            <input id="iFIText_'+idElement+'" class="divFileInputNameText" />\
                            <form method="POST" id="fr_'+idElement+'" action="" data-action="./api/files/upload?path='+
                            xmlElement.attr('uploadPath')+'" enctype="multipart/form-data" class="frmInputFile" target="ifr_'+idElement+'">\
                             <input id="iFI_'+idElement+'" type="file" data-typecontrol="file" data-filename="" class="iFileInput" name="fileinput" '+accept+'/>\
                            </form>\
                            <iframe id="ifr_'+idElement+'" name="ifr_'+idElement+'" class="noVisible ifDocForm" data-checkload=false></iframe>\
                           </div>');
                        if (!isNaN(curElementHeight)) element.height(curElementHeight);
                        if (!isNaN(curElementWidth)) element.width(curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        $('#ifr_'+idElement).load(function(){methods.uploadComplete($.extend(params,{iframe:this,indexForm:params.selectedIndex,saveMethod:'saveTabForm'}));});
                        $('#iFI_'+idElement).change(methods.setInputFileName);
                        $('#iFIText_'+idElement).change(methods.setInputFileNameText);
                        $('#'+idElement).change(function(){
                            if($(this).data('needSetFileInput') == false){//если редактировали руками название файла
                                if($('#divFI_'+idElement).hasClass('waitLoad')){
                                    $('#divFI_'+idElement).removeClass('waitLoad');
                                    var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                                    frm.data('waitload',Number(frm.data('waitload'))-1);
                                }
                            }
                            else{
                                $('#divFI_'+idElement+' .divFileInputName').val($(this).val());
                                if($('#divFI_'+idElement+' .divFileInputNameText').val() != $(this).val())
                                    $('#divFI_'+idElement+' .divFileInputNameText').val($(this).val());
                                if(!$('#divFI_'+idElement).hasClass('waitLoad'))
                                {
                                    $('#divFI_'+idElement).addClass('waitLoad');
                                    var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                                    frm.data('waitload',Number(frm.data('waitload'))+1);
                                }
                            }
                            $(this).data('needSetFileInput',true);
                            methods.markChange(params);
                        });
                        break;
                    case 'panel:buttons':
                        //params.div = element;
                        //params.parentClass = '';
                        xmlElement.children().each(function(){methods.parseForm($(this),params)});
                        break;
                    case 'picPutton:PanelButton':
                        if (params.options.objects[params.options.curObject].flag === 'import') return;
                        var iconUrl = xmlElement.attr('source');
                        var tooltip = xmlElement.attr('tooltip');
                        var clickEvent = xmlElement.attr('clickEvent');
                        var syncMap = xmlElement.attr('syncMap') === 'true';
                        if(params.selectedIndex === 0) {// если вкладка не 0-я, значит вообще не добавляем кнопки.
                            methods.createLeftButton({
                                params: params,
                                iconUrl: iconUrl,
                                tooltip: tooltip,
                                clickEvent: clickEvent,
                                syncMap: syncMap,
                            });
                        }
                        break;

                    default:
                        //console.log('Unknown tag!!!!!  ',xmlElement[0].tagName);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
                //console.err(err);
            }
        },
        //проверка, установлены ли боковые кнопки, описанные в панели свойств или нет. Если нет, то добавляем все по умолчанию
        checkLeftButtons:function(params){
            var children = $('#divLeftPanel_'+params.localId).children();
            if(children.length == 0 && params.selectedIndex == 0 && !params.options.objects[params.options.curObject].flag){
                var background = '';
                methods.createLeftButton({params:params, clickEvent:'DocsEvent',iconUrl:'',tooltip: gis_ppanel_1});
                methods.createLeftButton({params:params, clickEvent:'SaveEvent',iconUrl:'',tooltip: gis_ppanel_2});
                methods.createLeftButton({params:params, clickEvent:'UndoEvent',iconUrl:'',tooltip: gis_ppanel_3});
                methods.createLeftButton({params:params, clickEvent:'DeleteEvent',iconUrl:'',tooltip: gis_ppanel_12});
                methods.createLeftButton({params:params, clickEvent:'ExportGpxEvent',iconUrl:'',tooltip: gis_ppanel_15});
                methods.createLeftButton({params:params, clickEvent:'ShowOnMapEvent',iconUrl:'',tooltip: gis_ppanel_17});
                methods.createLeftButton({params:params, clickEvent:'FindRouteEvent',iconUrl:'',tooltip: gis_ppanel_61});
                methods.createLeftButton({params:params, clickEvent:'BufferCustomEvent',iconUrl:'',tooltip: gis_bufferzonechoosercontrol_3});
                methods.createLeftButton({params:params, clickEvent:'ExportToExcelEvent',iconUrl:'',tooltip: gis_ppanel_18});
                methods.createLeftButton({params:params, clickEvent:'BackEvent',iconUrl:'',tooltip: gis_ppanel_22});
                methods.createLeftButton({params:params, clickEvent:'ForwardEvent',iconUrl:'',tooltip: gis_ppanel_23});
            }else if(params.options.objects[params.options.curObject].flag){
                var background = '';
                methods.createLeftButton({params:params, clickEvent:'ApplyEvent',iconUrl:'',tooltip: gis_core_7});
                methods.createLeftButton({params:params, clickEvent:'CancelEvent',iconUrl:'',tooltip: gis_core_8});
            }
        },
        createLeftButton:function(options){
            var params = options.params;
            //забираем из конфига запрещенные кнопки. Если из грида открыли, передаём options для получения запрещенных кнопок для панели свойств, открыитой из грида
            var denyButtons = (getDenyPropButtonsByTask) ? getDenyPropButtonsByTask((params && params.options && params.options.openerType) ? params.options.openerType : MAP_TYPE.MAP) : [];
            var buttonName = options.clickEvent.replace('Event','');
            if(denyButtons.indexOf(buttonName) !== -1)
                return;
            var iconUrl = options.iconUrl;
            var background = 'background:url(\''+iconUrl+'\') no-repeat center;';
            //if(iconUrl === undefined || iconUrl === '')
            background = '';
            var tooltip = options.tooltip
            var clickEvent = options.clickEvent;
            var syncMap = options.syncMap;
            var buttonTemplate = '';
            var localId = params.localId;
            var options = params.options;
            /*if(options)
          options.syncMap = syncMap;*/
            var el = params.divProperties;
            var pPanelParams = {divProperties:params.divProperties,localId:localId,options:options, dataProvider:params.dataProvider};
            switch(clickEvent){
                case 'DocsEvent':
                    if($('#btnLeftPDocs_'+params.localId).length > 0)
                        $('#btnLeftPDocs_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPDocs_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'" class="btnLeftPanelIcon btnLeftPanelDocs"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPDocs_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                        if (curSelectedObjectId.indexOf(':')>0) {
                            //Переходим по ссылке на прикрепленные документы текущего объекта
                            var curDocLink = './docList.html?objId=' + curSelectedObjectId;
                        var curRowData = options.objects[options.curObject].curRowData;
                        if(curRowData && curRowData.LG_ATTACH){//хардкод для варианта внешнего источника
                            try{
                                curDocLink = './docList.html?objId=' + curRowData.LG_ATTACH.replace(new RegExp('"','g'),'&quot;');
                            }
                            catch(ex){ }
                        }
                            //Для трубопроводов пытаемся получить также LINE_ID для воспроизведения видеозаписей
                            if (curSelectedObjectId.indexOf('PODS_ROUTE')>=0) {
                                var routeData = methods.serializeForm('frm_'+pPanelParams.localId+'_0');
                                var lineIdInd = routeData.indexOf('LINE_ID="');
                                if (lineIdInd >= 0) {
                                    //Добавляем в ссылку lineId, чтобы было откуда для PODS_ROUTE его брать в окне прикрепленных документов
                                    var lineId = routeData.substring(lineIdInd+9,routeData.indexOf('"',lineIdInd+9));
                                    curDocLink += '&lineId=' + lineId;
                                }
                            }
                            //Открываем ссылку с хешем авторизации
                            var docWnd = window.open(curDocLink + Auth.hash, '_blank');
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'SaveEvent':
                    if($('#btnLeftPSave_'+params.localId).length > 0)
                        $('#btnLeftPSave_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPSave_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelSave"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPSave_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        methods.checkSave({divProperties:el,localId:localId,options:options,callBack:function(){}}, syncMap);
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    //СИНХРОНИЗАЦИЯ. Используются коллбеки в semanticCallback
                    break;
                case 'ApplyEvent':
                    if($('#btnLeftPApply_'+params.localId).length > 0)
                        $('#btnLeftPApply_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPApply_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelApply"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPApply_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        methods.checkSave({divProperties:el,localId:localId,options:options,callBack:function(){}}, syncMap);
                    }).attr('title',tooltip);
                    break;
                case 'CancelEvent':
                    if($('#btnLeftPCancel_'+params.localId).length > 0)
                        $('#btnLeftPCancel_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPCancel_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelCancel"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPCancel_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        methods.destroyPanel(pPanelParams);
                    }).attr('title',tooltip);
                    break;
                case 'UndoEvent':
                    if($('#btnLeftPUndo_'+params.localId).length > 0)
                        $('#btnLeftPUndo_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPUndo_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelUndo"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPUndo_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        methods.showPanelObject({checkSave:false,divProperties:el,localId:localId,options:options});
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    //СИНХРОНИЗАЦИЯ #J5 TYPE_NO ничего не происходит
                    break;
                case 'DeleteEvent':
                    if($('#btnLeftPDelete_'+params.localId).length > 0)
                        $('#btnLeftPDelete_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPDelete_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelDelete"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPDelete_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                            if(options.handlers.deleteCallback != undefined)
                                options.handlers.deleteCallback(methods.getAllFormsObjects(localId));
                            else if (curSelectedObjectId.indexOf(':')>0) {
                                var splittedIdArr = curSelectedObjectId.split(':');
                                //Пытаемся получить нужные для удаления данные (в том числе через layerManager)
                                try {
                                    var layerId = splittedIdArr[0];
                                    var layerManagerInst = WidgetMap!=undefined ? WidgetMap.layerManager : undefined;
                                    //Если нет LayerManager - так и пишем
                                    var curLayerObj = layerManagerInst!==undefined && layerManagerInst.getLayerByName !== undefined ? layerManagerInst.getLayerByName(layerId) : undefined;
                                    var dataRequest = '';
                                    if (curLayerObj==undefined || curLayerObj==null || !curLayerObj.hasOwnProperty('dataProvider') || curLayerObj.dataProvider.semantic=='') {
                                        //Форма может удалить с помощью семантики, если у нее есть dataProvider
                                        if (pPanelParams.dataProvider!=undefined && pPanelParams.dataProvider) {
                                            dataRequest = pPanelParams.dataProvider+'#'+$($('#ulTabs_'+pPanelParams.localId).children()[0]).data('source');
                                        } else {
                                            //Если слоя нет - делаем как во флеше (там ничего не происходило, даже запрос не отправлялся, здесь Володя сказал должна быть форма с сообщением)
                                            alertForm = new AlertForm();
                                            alertForm.build("pPanelDeleteNoLayerAlertForm",gis_ppanel_4,gis_ppanel_5,AlertForm.OK);
                                            return;
                                        }
                                    } else {
                                        //удаление ТОЛЬКО СЕМАНТИКИ (исправить provider на dataRequest = "", чтобы прошел полный алгоритм удаления сначала геометрии затем семантики)
                                        dataRequest = curLayerObj.dataProvider.semantic;
                                    }
                                    //выставил PropertyPanelName="" как для случая групповой операции удаления было сделано
                                    var deletingObject = {classId:layerId, objectId:splittedIdArr[1], provider:dataRequest, propertyPanelName:""};
                                    var alertForm = new AlertForm();
                                    //Меняем кнопки на "Да" и "Нет"
                                    alertForm.alertOkButtonText = gis_ppanel_6;
                                    alertForm.alertCancelButtonText = gis_ppanel_7;
                                    alertForm.width = 330;
                                    alertForm.build("pPanelDeleteConfirmationForm",gis_ppanel_8,gis_ppanel_9);
                                    //Добавляем слушатель закрытия формы
                                    //CloseEvent
                                    $("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt) {
                                        $("body").off(CloseEvent.CLOSE);
                                        if (evt && evt.detail==1) {
                                            if(options.handlers.deleteCASCallback != undefined){
                                                options.handlers.deleteCASCallback(methods.getAllFormsObjects(localId));
                                                return false;
                                            }
                                            DBUtil.deleteGeometryFromDB(deletingObject.objectId, deletingObject.classId, deletingObject.provider, deletingObject.propertyPanelName);
                                            //Функция обработки результата удаления записи
                                            var onObjectDeleteResult = function onObjectDeleteResult(evt) {
                                                $("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
                                                $("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
                                                if (evt.operationData!="") {
                                                    App.errorReport(gis_ppanel_10, evt.operationData, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_1'});
                                                }
                                                else{
                                                    if(MapUtil && syncMap)
                                                        MapUtil.updateLayerData(deletingObject.classId, [deletingObject.objectId], false);
                                                    //если есть колбек после удачного удаления, то
                                                    if(options.handlers.successDeleteCallback != undefined){
                                                        options.handlers.successDeleteCallback({id:deletingObject.objectId,layerName: deletingObject.classId});
                                                    }
                                                }
                                            };
                                            //Функция обработки ошибки при удалении записи
                                            var onObjectDeleteFault = function onObjectDeleteFault(evt) {
                                                $("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
                                                $("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
                                                if (evt.operationData!="") App.errorReport(gis_ppanel_10, evt.operationData, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_2'});
                                            };
                                            //Добавляем слушатель
                                            $("body").on(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID, onObjectDeleteResult);
                                            $("body").on(OperationEvent.OBJECT_DELETED_BY_ID, onObjectDeleteFault);
                                        }
                                    });
                                } catch (e) {
                                    App.errorReport(gis_ppanel_11, e.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_3'});
                                }
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'ExportGpxEvent':
                    if($('#btnLeftPExportNAV_'+params.localId).length > 0)
                        $('#btnLeftPExportNAV_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPExportNAV_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelExNAV"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPExportNAV_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                            if(options.handlers.exportToGpxKmlCallback != undefined)
                                options.handlers.exportToGpxKmlCallback(methods.getAllFormsObjects(localId));
                            else if (curSelectedObjectId.indexOf(':')>0) {
                                var splittedIdArr = curSelectedObjectId.split(':');
                                try {
                                    //Пытаемся получить нужные для экспорта данные (в том числе через layerManager)
                                    var filterStr = "ID = " + splittedIdArr[1];
                                    var layerManagerInst = WidgetMap.layerManager;
                                    var curLayerObj = layerManagerInst.getLayerByName(splittedIdArr[0]);
                                    //Если слоя нет - делаем как во флеше (там ничего не происходило)
                                    if (curLayerObj==undefined || curLayerObj==null) return;
                                    var currentGridDescr = {layerId:splittedIdArr[0], layerManager: layerManagerInst}; //фиктивный объект, сформирован так же, как currentGridDescr в гриде для использования той же функции
                                    GridWidget.prototype.exportObjectsToGPX(filterStr, currentGridDescr);
                                } catch (e) {
                                    App.errorReport(gis_ppanel_10, evt.operationData,undefined, {filename:gis_filename_568, functionname:'gis_filename_568_4'});
                                }
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'ShowOnMapEvent':
                    if($('#btnLeftPShowOnMap_'+params.localId).length > 0)
                        $('#btnLeftPShowOnMap_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPShowOnMap_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelShowOnMap"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPShowOnMap_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            var curObjData = methods.getAllFormsObjects(localId);
                            var opener = options && options.openerType;
                            var sender = (opener === 'grid') ? 'grid_ppanel' : 'ppanel';
                            var selectedObject = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                            var unique = options.objects[options.curObject].uniqueLayerName || undefined;
                            if (options.handlers.centeringCallback != undefined) {
                                //TODO рефакторинг, решить куда вынести синхронизацию: в centeringCallback или оставить здесь
                                widgetMoveWindowToPosition('grid');
                                if (selectedObject) {
                                    //СИНХРОНИЗАЦИЯ #L5
                                    //СИНХРОНИЗАЦИЯ #L6
                                    //СИНХРОНИЗАЦИЯ #L7
                                    //СИНХРОНИЗАЦИЯ #L8
                                    App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                                }
                                options.handlers.centeringCallback(curObjData, options, selectedObject);
                            }
                            else {
                                try {
                                    if (selectedObject) {
                                        var funcName = "showObjects";
                                        var params = [{name:"objects", value:selectedObject}, {name:"select", value:true}, {name:"centering", value:true}, {name:"gridCenteringResultFunction", value:App.errorReport}];
                                        if(!App.syncEnabled){
                                            ExternalInteraction.callFunction("", funcName, params);
                                            //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                            widgetMoveWindowToPosition('grid');
                                        }
                                        else{
                                            //upd. 21.04.21 принято решение, если текущая вкладка, то центровка на карте по-старому без синхронизации
                                            //ExternalInteraction.callFunction("", funcName, params);
                                            //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                            widgetMoveWindowToPosition('grid');
                                            if (selectedObject) {
                                                //СИНХРОНИЗАЦИЯ #L5
                                                //СИНХРОНИЗАЦИЯ #L6
                                                //СИНХРОНИЗАЦИЯ #L7
                                                //СИНХРОНИЗАЦИЯ #L8
                                                App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                                            }
                                        }
                                        //проверка
                                    }
                                } catch (e) {
                                    App.errorReport(gis_ppanel_16, e.message, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_5'});
                                }
                            }
                            var isMapAsIframe = (WidgetMap && WidgetMap.config && WidgetMap.config.map && WidgetMap.config.map.type === 'widget');
                            //TODO хадкод показа на карте объектов су тс тпа для презентации
                            if(isMapAsIframe){
                                var select = true;
                                var centering = true;
                                params = [{name:"mdl", value:"main_js.html"}, {name: "objects", value: selectedObject}, {name: "select", value: select}, {name: "centering", value: centering},{name: "isGroupButton", value: true}];
                                var taskName = (WidgetMap && WidgetMap.config && WidgetMap.config.map && WidgetMap.config.map.task)?WidgetMap.config.map.task:'sutstpa_map';
                                GridUtil.showOnMap(taskName, params);
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',gis_ppanel_17);//.jqxTooltip({content:gis_ppanel_17});
                    break;
                case 'ShowOnMapPipePartEvent':
                    if($('#btnLeftPShowOnMap_'+params.localId).length > 0)
                        $('#btnLeftPShowOnMap_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPShowOnMap_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelShowOnMap"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPShowOnMap_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            var curObjData = methods.getAllFormsObjects(localId);
                            widgetMoveWindowToPosition('grid');
                            if (selectedObject) {
                                //СИНХРОНИЗАЦИЯ #L5
                                //СИНХРОНИЗАЦИЯ #L6
                                //СИНХРОНИЗАЦИЯ #L7
                                //СИНХРОНИЗАЦИЯ #L8
                                App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                            }
                            if (options.handlers.centeringCallback != undefined)
                                options.handlers.centeringCallback(curObjData, options);
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',gis_ppanel_17);//.jqxTooltip({content:gis_ppanel_17});
                    break;
                case 'FindRouteEvent':
                    if($('#btnLeftFindRoute_'+params.localId).length > 0)
                        $('#btnLeftFindRoute_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftFindRoute_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon map-find-route-button"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftFindRoute_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            $('body').append('<div id="findRouteModal" class="findRouteModal">Выберите направление маршрута</div>');
                            var dlg = $('#findRouteModal');
                            var buttons = {};
                            buttons[0] = {
                                text: 'От точки',
                                click: function(){
                                    $('#findRouteModal').remove();
                                    WidgetMap.findRoute.handleFindRouteClick_(true);
                                    var event = {
                                        coordinate: [options.coords[0], options.coords[1]]
                                    };
                                    WidgetMap.findRoute.mapClickHandler_(event);
                                }
                            };
                            buttons[1] = {
                                text: 'До точки',
                                click: function(){
                                    $('#findRouteModal').remove();
                                    WidgetMap.findRoute.handleFindRouteClick_(false);
                                    var event = {
                                        coordinate: [options.coords[0], options.coords[1]]
                                    };
                                    WidgetMap.findRoute.mapClickHandler_(event);
                                }
                            };

                            dlg.dialog({
                                modal : true,
                                title : 'Построение маршрута',
                                width : 300,
                                height: 120,
                                dialogClass: 'gsi-zindex__dialog',
                                buttons: buttons
                            });

                            //WidgetMap.findRoute.handleFindRouteClick_(false);
                            //var event = {
                            //    coordinate: [options.coords[0], options.coords[1]]
                            //};
                            //WidgetMap.findRoute.mapClickHandler_(event);
                            widgetMoveWindowToPosition('grid');
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'BufferCustomEvent':
                    if($('#btnLeftBufferCustom_'+params.localId).length > 0)
                        $('#btnLeftBufferCustom_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftBufferCustom_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon map-buffer-custom"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftBufferCustom_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            if(WidgetMap.bufferZoneControl){
                                //upd. 18.06.20 если не успели подгрузиться данные(растр), выдать сообщение, чтобы подождать
                                if (WidgetMap.mapSelectionLayer.getSource().getFeatures().length == 0){
                                    App.confirmDialog(gis_ppanel_62, null, {
                                        title: gis_bufferzonechoosercontrol_7,
                                        width: 300,
                                        dialogClass: 'noCloseButton'
                                    });
                                    return;
                                }
                                WidgetMap.bufferZoneControl.selectedIds = params.options.objects;
                                WidgetMap.bufferZoneControl.handleBufferClick_('custom',params.options.withCtrl);
                            }

                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'ExportToExcelEvent':
                    if($('#btnLeftPExcel_'+params.localId).length > 0)
                        $('#btnLeftPExcel_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPExcel_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelExcel"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    //проверяем, что слой PODS_ROUTE, значит вместо обычного экспорта - экспорт пикетажа
                    //все трубы будут экспортировать пикетаж из панели свойств
                    if(true || goog.isDef(options.objects[0].id) && options.objects[0].id.indexOf('PODS_ROUTE:')!=-1){
                        $('#btnLeftPExcel_'+params.localId).jqxButton({ theme:'myCommon'}).on('click',function(){
                            if(goog.isDef(options.objects[0].id) && options.objects[0].id.indexOf('PODS_ROUTE:')!=-1){
                                try {
                                    var rId = undefined;
                                    var lId = undefined;
                                    if(goog.isDef(options.objects[0].curRowData["ID"]))
                                        rId = options.objects[0].curRowData["ID"];
                                    if(goog.isDef(options.objects[0].curRowData["LINE_ID"]))
                                        lId = options.objects[0].curRowData["LINE_ID"];
                                    var extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE';


                                    function build() {
                                        //Создаем диалоговую форму
                                        dlg.dialog({
                                            modal: true,
                                            title: gis_ppanel_18,
                                            dialogClass: 'noCloseButton gsi-zindex__dialog',
                                            closeOnEscape: true,
                                            width: 300,
                                            height: 180
                                        });

                                        //Кнопки Ок и отмены
                                        $("input[name='export']", dlg).click(function () {
                                            if($('input[id="radioPicketingByRoute"]', dlg).is(':checked'))
                                                ExportUtil.exportAdmPicketingToExcel([{ROUTE_ID: rId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE');
                                            else
                                                ExportUtil.exportAdmPicketingToExcel([{LINE_ID: lId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_LINE');
                                            $('#exportPicketingToExcelForm').remove();
                                        });
                                        $("input[name='cancel']", dlg).click(function () {
                                            $('#exportPicketingToExcelForm').remove();
                                        });
                                    }
                                    var elementId = 'exportPicketingToExcelForm';
                                    $('#'+elementId).remove();
                                    $('body').append('<div id="'+elementId+'"></div>');
                                    var dlg = $('#'+elementId);
                                    dlg.load('ui/html/ExportPicketingToExcelForm.html', build);
                                } catch (err) {
                                    //Ничего не делаем, возможно панель закрыта
                                }
                            }
                            else{
                                try {
                                    var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                                    if(options.handlers.exportToExcelCallback != undefined)
                                        options.handlers.exportToExcelCallback(methods.getAllFormsObjects(localId));
                                    else if (curSelectedObjectId.indexOf(':')>0) {
                                        var splittedIdArr = curSelectedObjectId.split(':');
                                        try {
                                            var curDivTabContent = $('#divTabContent_'+localId+'_0'); //Всегда берем параметры экспорта (excelTemplate и ext_data_id) из первой вкладки
                                            //Пытаемся получить нужные для экспорта данные
                                            var fileName = App.generateUUID() + ".xls";
                                            //Если вызов экспорта одиночной записи - при отсутствии templatename подставляем template='export'
                                            var excelTemplate = curDivTabContent.length>0 && curDivTabContent.data('excelTemplate')!=undefined ? curDivTabContent.data('excelTemplate') : splittedIdArr[0];
                                            var extDataId = curDivTabContent.length>0 && curDivTabContent.data('ext_data_id')!=undefined ? curDivTabContent.data('ext_data_id') : '';
                                            //if(extDataId == 'disabled') return;
                                            //Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде datafield:value
                                            var newDataObj = methods.getCurrentFormObject('frm_'+localId+'_0');
                                            if (extDataId=='') {
                                                ExportUtil.exportToExcel([newDataObj], fileName, excelTemplate, 'export');
                                            } else {
                                                ExportUtil.exportToExcel([newDataObj], fileName, excelTemplate, extDataId);
                                            }
                                        } catch (e) {
                                            App.errorReport(gis_ppanel_19, gis_ppanel_14 + e.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_6'});
                                        }
                                    }
                                } catch (err) {
                                    //Ничего не делаем, возможно панель закрыта
                                }
                            }

                        }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    }
                    else{
                        $('#btnLeftPExcel_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                            try {
                                var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                                if(options.handlers.exportToExcelCallback != undefined)
                                    options.handlers.exportToExcelCallback(methods.getAllFormsObjects(localId));
                                else if (curSelectedObjectId.indexOf(':')>0) {
                                    var splittedIdArr = curSelectedObjectId.split(':');
                                    try {
                                        var curDivTabContent = $('#divTabContent_'+localId+'_0'); //Всегда берем параметры экспорта (excelTemplate и ext_data_id) из первой вкладки
                                        //Пытаемся получить нужные для экспорта данные
                                        var fileName = App.generateUUID() + ".xls";
                                        //Если вызов экспорта одиночной записи - при отсутствии templatename подставляем template='export'
                                        var excelTemplate = curDivTabContent.length>0 && curDivTabContent.data('excelTemplate')!=undefined ? curDivTabContent.data('excelTemplate') : splittedIdArr[0];
                                        var extDataId = curDivTabContent.length>0 && curDivTabContent.data('ext_data_id')!=undefined ? curDivTabContent.data('ext_data_id') : '';
                                        //Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде datafield:value
                                        var newDataObj = methods.getCurrentFormObject('frm_'+localId+'_0');
                                        if (extDataId=='') {
                                            ExportUtil.exportToExcel([newDataObj], fileName, excelTemplate, 'export');
                                        } else {
                                            ExportUtil.exportToExcel([newDataObj], fileName, excelTemplate, extDataId);
                                        }
                                    } catch (e) {
                                        App.errorReport(gis_ppanel_19, gis_ppanel_14 + e.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_7'});
                                    }
                                }
                            } catch (err) {
                                //Ничего не делаем, возможно панель закрыта
                            }
                        }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    }

                    break;
                case 'BackEvent':
                    if($('#btnLeftPBack_'+params.localId).length > 0)
                        $('#btnLeftPBack_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPBack_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelBack"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPBack_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            if(options.handlers.previousCallback != undefined)options.handlers.previousCallback();
                            if (pPanelSelectedObjectsHistory.lastSelectedIndex > 0 && pPanelSelectedObjectsHistory.historyArray.length > 0) {
                                var curSelectedObject = pPanelSelectedObjectsHistory.historyArray[pPanelSelectedObjectsHistory.lastSelectedIndex - 1];
                                curSelectedObject.options.coords = options.coords;
                                curSelectedObject.options.opener = options.opener; //обязательно меняем opener, чтобы панель переоткрылась в текущем родителе
                                curSelectedObject.divProperties = el; //обязательно меняем divProperties, чтобы панель переоткрылась в текущем родителе
                                //Уменьшаем индекс последнего выбранного элемента
                                pPanelSelectedObjectsHistory.lastSelectedIndex--;
                                //Открываем панель свойств для выбранного элемента
                                methods.openObjectInNewPanel(curSelectedObject);

                                var selectedObject = options.objects[options.curObject].id;
                                var unique = options.objects[options.curObject].uniqueLayerName || undefined;
                                if (selectedObject) {
                                    //СИНХРОНИЗАЦИЯ #O6
                                    App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                                }
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'ForwardEvent':
                    if($('#btnLeftPForward_'+params.localId).length > 0)
                        $('#btnLeftPForward_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPForward_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelForward"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPForward_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            if(options.handlers.nextCallback != undefined)options.handlers.nextCallback();
                            if (pPanelSelectedObjectsHistory.lastSelectedIndex >= 0 && pPanelSelectedObjectsHistory.historyArray.length > 0 && pPanelSelectedObjectsHistory.lastSelectedIndex + 1 < pPanelSelectedObjectsHistory.historyArray.length) {
                                var curSelectedObject = pPanelSelectedObjectsHistory.historyArray[pPanelSelectedObjectsHistory.lastSelectedIndex + 1];
                                curSelectedObject.options.coords = options.coords;
                                curSelectedObject.options.opener = options.opener; //обязательно меняем opener, чтобы панель переоткрылась в текущем родителе
                                curSelectedObject.divProperties = el; //обязательно меняем divProperties, чтобы панель переоткрылась в текущем родителе
                                //Уменьшаем индекс последнего выбранного элемента
                                pPanelSelectedObjectsHistory.lastSelectedIndex++;
                                //Открываем панель свойств для выбранного элемента
                                methods.openObjectInNewPanel(curSelectedObject);
                                var selectedObject = options.objects[options.curObject].id;
                                var unique = options.objects[options.curObject].uniqueLayerName || undefined;
                                if (selectedObject) {
                                    //СИНХРОНИЗАЦИЯ #P6
                                    App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                                }
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
            }
        },
        setCommentDocGridBtnDisabled:function(params, btnDisabled){
            try {
                //Для комментариев
                $("button[id^='btnDeleteComment_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
                $("button[id^='btnEditComment_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
                //Для документов
                $("button[id^='btnOpenDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
                $("button[id^='btnDeleteDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
                $("button[id^='btnEditDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
            } catch(e) {}
        },
        checkEditable:function(xmlElement, params){
            //установка всем контролам editable и enabled в true при создании объекта
            var isNewObject = (params!=undefined && params.options != undefined && params.options.objects != undefined &&
                params.options.objects.length > 0 && params.options.objects[0].id != undefined &&
                params.options.objects[0].id.indexOf(':') == -1)?true:false;
            var addClass = '',
                editable = xmlElement.attr('editable'),
                enabled = true; /*xmlElement.attr('enabled');*/
            if(isNewObject)editable = 'true';
            if((editable!=undefined && editable=='false') || (enabled!=undefined && enabled=='false'))addClass = 'noEditable';
            if (params.options.editSystemInfo==true) addClass=''; //Админ может редактировать любые поля
            if(params.tableReadOnly)//если сама форма readOnly
                addClass = 'noEditable';
            if(params.enabledCombo === 'false')//если сама форма readOnly
                addClass = 'noEditable';
            return addClass;
        },
        getIdControl:function(params){
            return params.xmlElement.attr('id')+'_'+params.params.localId+'_'+params.params.selectedIndex;
        },
        appendFormElement:function(params){
            try {
                if(params.params.parentClass == 'pPanelTableCell')
                    params.params.div.append(methods.tabelCellElement({element:params.element,xmlElement:params.xmlElement}))
                        .append('<div class="pPanelTableCell pPanelTableCellRight">&nbsp;</div>');
                else {
                    methods.setStyleElement({xmlElement:params.xmlElement,element:params.element});
                    params.params.div.append(params.element);
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
                //console.err(err);
            }
        },
        tabelCellElement: function(params){
            try {
                var tableCell = $('<div class="pPanelTableCell"></div>');
                methods.setStyleElement({xmlElement:params.xmlElement,element:tableCell});
                tableCell.append(params.element);
                return tableCell;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setValidateElement:function(params){
            try {
                $.each(params.xmlElement.attributes,function(){
                    var value = this.value;
                    switch(this.name) {
                        case 'maxChars':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: gis_ppanel_52,
                                action: 'none',
                                rule: 'maxLength=' + this.value,
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'minLength':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('tooShortError'),
                                action: 'none',
                                rule: 'minLength='+this.value,
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'requiredFieldError':
                            /*case 'required':*/
                            if(params.xmlElement.getAttribute('required')!='false'){
                                var controlType = $('#'+params.idElement).data('typecontrol');
                                //Для контрола ввода файла отдельное правило - проверяем текст внутреннего div'а
                                if (controlType=='inputfile') {
                                    params.params.rules.push({
                                        input: '#'+params.idElement,
                                        message: params.xmlElement.getAttribute('requiredFieldError'),
                                        action: 'none',
                                        rule: function(){
                                            try {
                                                var curFileNameText = $('#'+params.idElement).parent().find('.divFileInputNameText').val();
                                                return curFileNameText!='';
                                            } catch (e) {
                                                return false;
                                            }
                                        }
                                    });
                                } else
                                if (controlType=='date') {
                                    /* отдельно проверяем поля даты, т.к. в них контрол input завернут в div */
                                    params.params.rules.push({
                                        input: '#'+params.idElement,
                                        message: params.xmlElement.getAttribute('requiredFieldError'),
                                        action: 'none',
                                        rule: function(){
                                            try {
                                                var control = $('#'+params.idElement);
                                                var inputControlValue = $('input.date', control).val();
                                                return inputControlValue!=null && inputControlValue!='';
                                            } catch (e) {
                                                return false;
                                            }
                                        }
                                    });
                                } else {
                                    params.params.rules.push({
                                        input: '#'+params.idElement,
                                        message: params.xmlElement.getAttribute('requiredFieldError'),
                                        action: 'none',
                                        rule: 'required',
                                        hintRender:function(message, input){
                                            if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                        }
                                    });
                                }
                            }
                            break;
                        case 'requiredcombo':
                            params.params.rules.push({
                                input: '#'+params.idElement+' input',
                                message: params.xmlElement.getAttribute('notDefaultError'),
                                action: 'none',
                                rule: function(){
                                    var index = $('#'+params.idElement).jqxComboBox('getSelectedIndex');
                                    if(index !== -1){
                                        var item = $('#'+params.idElement).jqxComboBox('getSelectedItem');
                                        if(item !== undefined && item.originalItem !== undefined){
                                            if(item.originalItem.CODE === '0' || item.originalItem.CODE === 'UNKNOWN'){
                                                index = -1;
                                            }
                                        }
                                    }
                                    return index != -1;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'comparisonError':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('comparisonError'),
                                action: 'none',
                                rule: function(){
                                    try {
                                        var destinationId = params.xmlElement.getAttribute('destination');
                                        destinationId = destinationId.substring(1, destinationId.length-1)+'_'+params.params.localId+'_'+params.params.selectedIndex;
                                        return $('#'+params.idElement).val()==$('#'+destinationId).val();
                                    } catch (err) {}
                                    return false;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'allowNegative':
                            if(this.value == 'false')
                                params.params.rules.push({
                                    input: '#'+params.idElement,
                                    message: params.xmlElement.getAttribute('negativeError'),
                                    action: 'none',
                                    rule: function(){
                                        var val = $('#'+params.idElement).val();
                                        if(val != '')return /^[+]?\d*(\.\d+)?$/.test(val);
                                        else return true;
                                    },
                                    hintRender:function(message, input){
                                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                    }
                                });
                            break;
                        case 'precision':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('precisionError'),
                                action: 'none',
                                rule: function(){
                                    var val = $('#'+params.idElement).val().toString().split('.');
                                    if(val.length >1)return val[1].length <= value;
                                    else return true;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'maxValue':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('exceedsMaxError'),
                                action: 'none',
                                rule: function(){
                                    var val = $('#'+params.idElement).val();
                                    if(val.length >1)return parseFloat(val) <= parseFloat(value);
                                    else return true;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'minValue':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('lowerThanMinError'),
                                action: 'none',
                                rule: function(){
                                    var val = $('#'+params.idElement).val();
                                    if(val.length >1)return parseFloat(val) >= parseFloat(value);
                                    else return true;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'notAllowedValues':
                            if($('#'+params.idElement).data('typecontrol') == 'combobox')
                                params.params.rules.push({
                                    input: '#'+params.idElement+' input',
                                    message: params.xmlElement.getAttribute('notAllowedError'),
                                    action: 'none',
                                    rule: function(){
                                        var val = $('#'+params.idElement).val(),
                                            values = value.split(',');
                                        for(var i = 0;i<values.length;i++)
                                            if(values[i]== val)return false;
                                        return true;
                                    },
                                    hintRender:function(message, input){
                                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                    }
                                });
                            else
                                params.params.rules.push({
                                    input: '#'+params.idElement,
                                    message: params.xmlElement.getAttribute('notAllowedError'),
                                    action: 'none',
                                    rule: function(){
                                        var val = $('#'+params.idElement).val(),
                                            values = value.split(',');
                                        for(var i = 0;i<values.length;i++)
                                            if(values[i]== val)return false;
                                        return true;
                                    },
                                    hintRender:function(message, input){
                                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                    }
                                });
                            break;
                        case 'defaultValue':
                        case 'text':
                            var control = $('#'+params.idElement);
                            switch(control.data('typecontrol')) {
                                case 'input':if(control.data('loadvalue') == false)control.val(value);break;
                                case 'numberinput':if(control.data('loadvalue') == false)control.val(value);break;
                                case 'checkbox':if((control.data('loadvalue') == false)&&(this.value == 'Y'))control.jqxCheckBox('check');break;
                                case 'date':
                                    if(control.data('loadvalue') == false) {
                                        var input = $('input.date', control);
                                        var date;
                                        if(value == 'new Date()') {
                                            value = new Date();
                                            value = value.format('dd.mm.yyyy');
                                            input.val(value);
                                        } else {
                                            input.val(value);
                                        }
                                    }
                                    break;
                                case 'combobox':
                                    if(control.data('loadvalue') == false)
                                        control.data('value',value);
                                    else control.jqxComboBox('val',value);
                                    break;
                            }
                            break;
                    }
                });
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setStyleElement:function(params){
            try {
                $.each(params.xmlElement.attributes,function(){
                    switch(this.name)
                    {
                        case 'width':params.element.css('width',this.value+'px');break;
                        case 'percentWidth':if(this.value != '100')params.element.css('width',this.value+'%');break;
                        case 'textAlign':params.element.addClass(this.value+'TextAlign');break;
                    }
                });
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setComboBoxDataProvider:function(comboDataProv, params){
            if(params.comboBox==undefined || $('#'+params.comboBox.attr('id')).length == 0)return;
            var data = (params.options && params.options.data)? params.options.data: null;
            var selectedIndex = -1;
            var selectedValue = params.comboBox.data('selectedvalue') || null;
            var disabledCombo = params.comboBox.hasClass('noEditable');
            var comboDataValue = params.comboBox!=undefined && params.comboBox.data('value');
            //var comboId = params.comboBox.attr('id').substring(0, params.comboBox.attr('id').indexOf('_'+params.localId));
            //пробуем найти из data
            if(!comboDataValue && selectedValue){
                if (data && data[selectedValue])
                    comboDataValue = data[selectedValue];
            }
            var comboDataValueField = params.comboBox.jqxComboBox('valueMember');
            for (var i=0; i<comboDataProv.length; i++) {
                var curObj = comboDataProv[i];
                //Сразу ищем элемент, данные уже есть
                var val = curObj[comboDataValueField];
                if (comboDataValue!=undefined && val==comboDataValue) selectedIndex = i;
            }
            //проверяем, если есть атрибут defaultSelectedIndex и не выбран уже selectedIndex, то выбираем его
            var defaultSelectedIndex = params.comboBox.attr('defaultselectedindex')? parseInt(params.comboBox.attr('defaultselectedindex')):-1;
            if(selectedIndex == -1 && defaultSelectedIndex < comboDataProv.length){
                selectedIndex = defaultSelectedIndex;
            }
            if(defaultSelectedIndex !== -1)
                params.readonly = true;

            params.comboBox.removeClass('noListValues');
            var autoDropDownHeight = comboDataProv.length<=5 ? true : false; //При наличии в списках 5 и менее элементов нужно dropdown сжимать по их количеству
            //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
            if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1 && params.comboBox.jqxComboBox('placeHolder')=='') selectedIndex = 0;
            if(params.comboBox.data('value') != undefined) {
                params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo,selectedIndex:selectedIndex,autoDropDownHeight:autoDropDownHeight, autoComplete: true});
                params.comboBox.data('loadvalue',true);
            } else {
                if(defaultSelectedIndex === -1)
                    disabledCombo = params.divProperties.data('unlockCombo')!=1;
                params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo,selectedIndex:selectedIndex,autoDropDownHeight:autoDropDownHeight, autoComplete: true});
                params.comboBox.data('loadvalue',true);
            }
            if(!params.readonly)
                params.comboBox.jqxComboBox({disabled:false});
        },
        parseTabValues:function(xmlElement,params, isMainSelect){
            try {
                switch(xmlElement[0].tagName) {
                    case 'string':
                        xmlElement.children().each(function(){methods.parseTabValues($(this),params);});
                        break;
                    case 'result':
                    case 'root':
                        if(params.loadObject != params.options.curObject)return;
                        //если ничего не нашло и запрос - основной по заполнению вкладки, то выставляем флаг для вкладки insert
                        if(xmlElement.children().length == 0 && isMainSelect === true){
                            if(params && params.options)
                                params.options.requestType = 'insert';
                        }
                        //TODO хардкод. т.к. в панели запрос на сохранение не совпадает со вкладкой паспорт
                        if(xmlElement.children().length == 0 && params && params.options && params.idRequest === 'PODS_STO_ILI_INSPECTION_SHEET'){
                            params.options.requestType = 'insert';
                        }
                        xmlElement.children().each(function(){methods.parseTabValues($(this),params);});
                        methods.unlockFormControls(params);
                        //Меняем тип скрипта - если уже запросили данные, будет UPDATE
                        $('#frm_'+params.localId+'_'+params.selectedIndex).data('scriptType','UPDATE');
                        //Ставим фокус на первое поле
                        var formFirstTabIndex = (params.selectedIndex + 1)*100 + 1;
                        $('#frm_'+params.localId+'_'+params.selectedIndex+' [tabindex="'+formFirstTabIndex+'"]').focus();
                        //И только в самом конце, после свойств объекта запрашиваем данные комбобоксов
                        $('#divTabContent_'+params.localId+'_'+params.selectedIndex).find('[data-typecontrol="combobox"]').each(function (){
                            var element = $(this);
                            if(element.attr('dataProvider') != undefined) {
                                var comboDataProvider = new QueryDataProvider({
                                    requestSource: element.attr('dataProvider'),
                                    dataField: element.jqxComboBox('valueMember'),
                                    labelField: element.jqxComboBox('displayMember'),
                                    resultHandler: function(){
                                        methods.setComboBoxDataProvider(this,{readonly:params.tableReadOnly == true,comboBox:element,divProperties:params.divProperties,localId:params.localId, options: params.options});
                                    }
                                });
                            }
                        });
                        break;
                    case 'data':
                        $.each(xmlElement[0].attributes,function(){
                            var control = $('#'+this.name+'_'+params.localId+'_'+params.selectedIndex);
                            if(control.length != 0) {
                                if(control.hasClass('noListValues')) {
                                    control.data('value', this.value);
                                    control.data('orig-value', this.value);
                                }
                                else methods.setControlValue(control,this);
                            } else
                                $('#frm_'+params.localId+'_'+params.selectedIndex).append(
                                    '<input id="'+this.name+'_'+params.localId+'_'+params.selectedIndex+'" type="hidden" value="'+this.value.xmlEscape()+'" data-typecontrol="input" class="formControl" data-loadvalue=true />');
                        });
                        //!!закомментировал это место, потому что для объектов типа cosmetic, уходило в цикл бесконечный всё
                        /*if(xmlElement[0].attributes.length == 1)
            {
             params.options.objects[params.options.curObject].id=params.options.objects[params.options.curObject].id+':'+xmlElement[0].attributes[0].value;
             methods.showPanelObject(params);
            }*/
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setControlValue:function(control,data){
            try {
                var dataValue = data.value.replace(new RegExp("&quot;","g"),'"'); //Заменяем кавычки
                switch(control.data('typecontrol')) {
                    case 'label': control.html(dataValue); break;
                    case 'input':
                        if(WidgetMap && WidgetMap.COORD_FIELDS && WidgetMap.coordMode === WidgetMap.COORD_MODES.GRAD && WidgetMap.COORD_FIELDS.indexOf(control.data('fieldname')) !== -1){
                            var gradCoord = GeoUtil.convertDecimalIntoDegree(dataValue);
                            control.val(gradCoord);
                        }
                        else
                            control.val(dataValue);
                        control.data('loadvalue',true);
                        break;
                    case 'numberinput': control.val(dataValue); control.data('loadvalue',true); break;
                    case 'checkbox':
                        if (dataValue == 'Y' || dataValue == '1') {
                            control.jqxCheckBox('check');
                            control.data('loadvalue', true);
                        }
                        break;
                    case 'combobox':
                        //Если у нас уже есть провайдер комбобокса (например dataProvider задан прямо в форме) - устанавливаем значение
                        var comboDataProv = control.jqxComboBox('source');
                        if (comboDataProv && comboDataProv.length > 0) {
                            var selectedIndex = -1;
                            var comboValueMember = control.jqxComboBox('valueMember');
                            for (var i = 0; i < comboDataProv.length; i++) {
                                if (comboDataProv[i][comboValueMember]==dataValue) {
                                    selectedIndex = i;
                                    break;
                                }
                            }
                            //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
                            if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1 && control.jqxComboBox('placeHolder')=='') selectedIndex = 0;
                            //Если не нашли такого значения в провайдере - ставим selectedIndex==-1, т.е. ничего не выбрано
                            control.jqxComboBox({selectedIndex: selectedIndex});
                        } else {
                            //иначе данные для комбобоксов получаем после данных формы, поэтому включаем в атрибут value пришедшее из запроса значение (оно будет искаться после запроса комбобокса там)
                            control.data('value',dataValue);
                        }
                        control.data('loadvalue',true);
                        break;
                    case 'date':
                        dataValue =  dataValue.split('+')[0];
                        var input = $('input.date', control);
                        var formatString = (control.data('format'))? control.data('format').toLowerCase(): 'dd.mm.yyyy';
                        var date;
                        if(dataValue.indexOf('T')!=-1){
                            dataValue = dataValue.substring(0,dataValue.indexOf('T'));
                            date = new Date(dataValue);
                        }
                        else{
                            //пробуем распарсить
                          var dateArr = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(dataValue);//DD.MM.YYYY
                          if(dateArr !== null)
                                    date = new Date(dateArr[3], dateArr[2]-1,dateArr[1])
                          else{
                              //upd. 03.11.21 проверка случая в задаче су тс тпа, когда из sqlite проходит значение даты вместо NULL значение 0
                              if(dataValue !== '0'){
                                  date = new Date(Number(dataValue));
                              }
                              else {
                                  date = null;
                              }
                              //доп. устанавливаем свойство у контрола, что дата пришла в миллисекундах
                              input.data('type','bigint');
                          }
                      }
                      if(date)
                        date = date.format(formatString);
                        input.val(date);
                        control.data('lodateadvalue',true);
                        break;
                    case 'inputfile':
                        control.val(dataValue);
                        $('#divFI_'+control.attr('id')+' .divFileInputNameText').val(dataValue);
                        control.data('loadvalue',true);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        checkSave: function(params, syncMap){
            try {
                //убираем из выборки флаг frmChanged
                var frmChanged = '.frmChanged';
                var listForms = $('#divContent_'+params.localId+' .frmPanelTab'+frmChanged);
                if(params.options.target == 'moveGeometry' || params.options.target == 'editGeometry'){
                    params.options.target = undefined;
                    frmChanged = '';
                    var passportItem = $('#divContent_'+params.localId+' .frmPanelTab').first();
                    //оставляем 1-й форму в любом случае паспорт, для сохранения семантики и далее геометрии.
                    //и к паспорту добавляем остальные, которые реально редактировались
                    if(passportItem.length !== 0){
                        listForms = $.merge(listForms, passportItem);
                    }
                }

                var count = listForms.length;
                if (count != 0) {// Убрал проверку на колво измененных элементов, чтобы сохранялось, как во флеше, если ничего не менялось
                    for (var i = 0;i<count;i++) {
                        var fullErrorText = '';
                        var curForm = $(listForms[i]);
                        var labelElements = curForm.find('.pPanelTableRow div.rightTextAlign:first-child span[data-typecontrol="label"]');
                        //Получаем комбобоксы и проверяем, выбрано ли в них значение, иначе в БД может передаваться подстрока из поля поиска в списке.
                        curForm.find('[data-typecontrol="combobox"]').each(function(){
                            var selectedIndex = $(this).jqxComboBox('getSelectedIndex');
                            if (selectedIndex==-1) {
                                var labelText = '';
                                for (var j=0; j<labelElements.length; j++) {
                                    var curLabelElem = $(labelElements[j]);
                                    var findComboInLabels = curLabelElem.parent().parent().find('[id="'+this.id+'"]');
                                    if (findComboInLabels.length>0) {
                                        labelText = "'"+curLabelElem.text() + "' ";
                                        break;
                                    }
                                }
                                fullErrorText += gis_ppanel_53+labelText+gis_ppanel_54 + '<br/>';
                            }
                        });
                        if (fullErrorText!='') {
                            var alertForm = new AlertForm();
                            alertForm.build('pPanel_'+params.localId+'_AlertForm', fullErrorText+gis_ppanel_55 , gis_ppanel_27, AlertForm.OK);
                            return true;
                        }
                        //Получаем все поля дат и проверяем их валидность - иначе в БД будет передаваться некорректная строка, что удалит имеющуюся дату
                        //Корректными считаем только даты в формате dd.mm.yyyy или yyyy, даты вида 1.1.2012 считаем некорректными
                        fullErrorText = '';
                        curForm.find('[data-typecontrol="date"]').each(function(){
                            var input = $('input.date', $(this));
                            var value = input.val();
                            //Если ввели только год
                            if (value.length==4 && value.indexOf('.')==-1) value = '01.01.'+value;
                            //Затем проверяем, что формат даты правильный (точки и цифры на своих местах)
                            if (!(value.length==0 || (value.length==10 && value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/)))) {
                                fullErrorText = gis_ppanel_56;
                            }
                        });
                        if (fullErrorText!='') {
                            var alertForm = new AlertForm();
                            alertForm.build('pPanel_'+params.localId+'_AlertForm', fullErrorText+gis_ppanel_57, gis_ppanel_27, AlertForm.OK);
                            return true;
                        }
                        if(!params.options.skipValidation ){
                            //Затем запускаем валидатор
                            try{
                                if (curForm.jqxValidator('validate')==false) {
                                    $('#divTabs_'+params.localId).jqxTabs('select',i);
                                    curForm.jqxValidator('hide'); //Сразу прячем (при этом они останутся в DOM и мы сможем получить их текст)*/
                                    return true;
                                }
                            }
                            catch(e){
                                //console.log('d');
                            }
                        }
                    }
                    //Показываем подтверждение сохранения
                    var alertForm = new AlertForm();
                    //Меняем текст кнопок на "Да" и "Нет"
                    alertForm.alertOkButtonText = gis_ppanel_6;
                    alertForm.alertCancelButtonText = gis_ppanel_7;
                    alertForm.width = 330;
                    if (params.options.objects[params.options.curObject].flag === 'import')
                        alertForm.build("pPanel_"+params.localId+"_AlertForm",gis_ppanel_67,gis_alertform_1);
                    else
                        alertForm.build("pPanel_"+params.localId+"_AlertForm",gis_ppanel_28,gis_ppanel_29);
                    //Добавляем слушатель закрытия формы
                    $("body").on(CloseEvent.CLOSE, function pPanelConfirmSaveDialog(evt/*CloseEvent*/) {
                        $("body").off(CloseEvent.CLOSE);
                        var indexForm = 0;
                        var shurfArray = [];
                        for (var j=0; j<count; j++) {
                            //прохой фикс, но в связи с отказов в дальшейшем от панелей
                            //индекс формы забираем из id frm_123dc34_4
                            try{
                                indexForm = parseInt(listForms[j].id.replace('frm_','').split('_')[1]);
                            }
                            catch(ex){}
                            var reqId = $($('#ulTabs_'+params.localId).children()[indexForm]).data('source');
                            //TODO переработать. Если встрачаем вкладку excavate или repair, то сохраняем по другой схеме
                            //заношу в общий массив панели шурфовок, который надо сохранять через ведомсоти
                            if(reqId === "PODS_STO_SHEET_REPAIR_LIST" || reqId === "PODS_STO_SHEET_EXCAVATE_LIST"){
                                shurfArray.push($.extend(params,{indexForm:indexForm,saveMethod:'saveTabForm', syncMap:syncMap}));
                                methods.saveShurfTabForm(shurfArray);

                            }
                            else
                            if (evt && evt.detail==1){
                                if (params.options.objects[params.options.curObject].flag === 'import'){
                                    var serializedForm = methods.serializeForm('frm_'+params.localId+'_'+indexForm, true);
                                    if(params.options.handlers.applyCallback)
                                        params.options.handlers.applyCallback(serializedForm)
                                    methods.destroyPanel(params);
                                    /*var frm = $('#frm_'+params.localId+'_'+indexForm),
                                        prm = params.options.objects[params.options.curObject].id.split(':'),
                                        db= prm[0].split('_'),
                                        db_schema = db[0],
                                        db_table_id = db.slice(1).join('_'),
                                        descrType = 'insert';
                                    var dataProvider = frm.data('dataProvider')+'#'+reqId;
                                    return params.options.handlers.applyCallback({
                                        requestParams: {
                                            descrId:dataProvider,
                                            descrType:descrType,
                                            data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">' +
                                                '<data FILTER="ID='+prm[1]+
                                                '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                                '" DB_SCHEMA_ID="'+db_schema+
                                                '" DB_TABLE_ID="'+db_table_id+
                                                '" SYS_CLASS_ID="'+prm[0]+
                                                '" SYS_OBJ_ID="'+prm[1]+'" '
                                        },
                                        thisObject: $.extend(params,{loadObject:params.options.curObject}),
                                        layerName: reqId,
                                        attrObj: serializedForm
                                    });*/
                                }
                                else
                                    methods.saveFormNew($.extend(params,{indexForm:indexForm,saveMethod:'saveTabForm', syncMap:syncMap}));
                            }
                            $(listForms[j]).removeClass('frmChanged');
                        }
                        if(shurfArray.length > 0){
                            methods.saveShurfTabForm(shurfArray);
                        }
                        params.checkSave = false;
                    });
                    return false;
                }
                return true;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        getAllFormsObjects:function(localId){ //Получение массива объектов со всех вкладок
            try {
                var resultArray = [];
                var listForms = $('#divContent_'+localId+' .frmPanelTab');
                for(var i = 0; i<listForms.length; i++) {
                    var curObject = methods.getCurrentFormObject('frm_'+localId+'_'+i);
                    if (curObject) resultArray.push(curObject);
                }
                return resultArray;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        getCurrentFormObject:function(frmId){ //Получение объекта со свойствами из одной вкладки
            try {
                var dataObj = {};
                $('#'+frmId+' .formControl').each(function(){
                    var el = $(this),
                        value = '',
                        id = this.id.split('_');
                    id.splice(id.length-2,2);
                    switch(el.data('typecontrol'))
                    {
                        case 'input':value=el.val();break;
                        case 'numberinput':value=el.val();break;
               case 'checkbox':
                   var yVal = 'Y', nVal = 'N';
                   if(el.data('typevalue') === 'number'){
                       yVal = '1';
                       nVal = '0';
                   }
                   if(el.jqxCheckBox('checked'))value=yVal;else value=nVal;
                   break;
               case 'combobox':
                   if(el.jqxComboBox('selectedIndex') == -1){
                            if(el.data('loadvalue')== true)value='NULL';
                            else id = undefined;
                        }
                        else value=el.jqxComboBox('val');
                            break;
                        case 'date':
                            var input = $('input.date', el);
                            var value = input.val();
                            if(value == null || value=='') id = undefined;
                            else {
                                //Если ввели только год
                                if (value.length==4 && value.indexOf('.')==-1) value = '01.01.'+value;
                                //Затем проверяем, что формат даты правильный (точки и цифры на своих местах)
                                if (value.length!=10 || !value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/)) {
                                    id = undefined;
                                }
                                /*else value = value.getDate()+'.'+(value.getMonth()+1)+'.'+value.getFullYear();*/
                            }
                            break;
                        case 'file':value=el.data('filename');
                            break;
                        case 'inputfile':value=el.prop('value');//Это для получения значения из контрола выбора файла
                            break;
                    }
                    if(id != undefined)
                        dataObj[id.join('_')] = value;
                });
                return dataObj;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        serializeForm: function (frmId, toObject) {
            try {
                var serializedData = toObject ? {} : '';
                var scriptType = $('#' + frmId).data('scriptType');
                $('#' + frmId + ' .formControl').each(function () {
                    var el = $(this),
                        value = '',
                        id = this.id.split('_');
                    id.splice(id.length - 2, 2);
                    switch (el.data('typecontrol')) {
                        case 'input':
                            value = el.val();
                            if (el.attr('type') == 'password') value = CryptoJS.MD5(value).toString();
                            break;
                        case 'numberinput':
                            value = el.val();
                            break;
                        case 'checkbox':
                            var yVal = 'Y', nVal = 'N';
                            if (el.data('typevalue') === 'number') {
                                yVal = '1';
                                nVal = '0';
                            }
                            if (el.jqxCheckBox('checked')) value = yVal; else value = nVal;
                            break;
                        case 'combobox':
                            if (el.jqxComboBox('selectedIndex') == -1) {
                                if (el.data('loadvalue') == true) value = 'NULL';
                                else id = undefined;
                            } else {
                                //TODO добавить проверку на el.data('orig-value')
                                value = el.jqxComboBox('val');
                            }
                            break;
                        case 'date':
                            var input = $('input.date', el);
                            var value = input.val();
                            var isBigint = input.data('type') === 'bigint';
                            if (value == null || value == '') id = undefined;
                            else {
                                //Если ввели только год
                                if (value.length == 4 && value.indexOf('.') == -1) value = '01.01.' + value;
                                //Затем проверяем, что формат даты правильный (точки и цифры на своих местах)
                                if (value.length != 10 || !value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/)) {
                                    id = undefined;
                                }

                                if (isBigint) {
                                    value = input.datepicker('getDate').getTime();
                                }
                            }
                            break;
                        case 'file':
                            value = el.data('filename');
                            break;
                        case 'inputfile':
                            value = el.prop('value');//Это для получения значения из контрола выбора файла
                            break;
                    }
                    value = methods.convertToString(value, scriptType);
                    if (id != undefined && value != "NULL") {
                        if (toObject)
                            serializedData[id.join('_')] = value;
                        else
                            serializedData += ' ' + id.join('_') + '="' + value + '"';
                    }
                });
                return serializedData;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        convertToString:function(val, scriptType){
            if(val==null)
                return "NULL";
            var res = val.toString().xmlEscape(); //Заменяем кавычки
            //Изменил условие возврата NULL - мы можем сохранять пустые поля если скрипт - UPDATE
            if (scriptType=="UPDATE") {
                if(res==gis_ppanel_30)
                    return "NULL";
            } else {
                if(res.length==0 || res==gis_ppanel_30)
                    return "NULL";
            }
            return res;
        },
        saveFormNew:function(params){
            try {
                var waitload = $('#frm_'+params.localId+'_'+params.indexForm).data('waitload');
                if(waitload != 0)
                {
                    $('#frm_'+params.localId+'_'+params.indexForm+' .divFileInput.waitLoad').each(function(){
                        var fileName = $('#'+this.id+' .divFileInputName').val();
                        if($('#'+this.id+' .divFileInputNameText').val()!='');
                        fileName = $('#'+this.id+' .divFileInputNameText').val();
                        var allID = this.id.replace('divFI','');
                        var form = $('#fr'+allID);
                        $('#ifr'+allID).data('checkload',true);
                        if(params.options.handlers.setDataLoadingCallback != undefined)params.options.handlers.setDataLoadingCallback(true);
                        form.attr('action',form.data('action')+'&fileNameGUID='+encodeURI(fileName)).submit();
                    });
                }
                else methods[params.saveMethod](params);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        saveTabForm:function(params){
            try {
                var frm = $('#frm_'+params.localId+'_'+params.indexForm),
                    prm = params.options.objects[params.options.curObject].id.split(':'),
                    db= prm[0].split('_'),
                    db_schema = db[0],
                    db_table_id = db.slice(1).join('_'),
                    descrType = 'update';
                var reqId = $($('#ulTabs_'+params.localId).children()[params.indexForm]).data('source');
                if(params.options.requestType === 'insert' && reqId === 'PODS_STO_ILI_INSPECTION_SHEET'){
                    descrType = params.options.requestType;
                    params.options.requestType = undefined;
                }

                if(prm[1] == undefined) {
                    descrType='insert';
                    prm[1] = '';
                }
                //попытка получения атрибута initialId, чтобы узнать, нужно создавать новую запись или обновлять
                var initialId = undefined;
                try{
                    initialId = $('#divTabContent_'+params.localId+'_'+params.indexForm).data('initialId');
                }
                catch(ex){

                }
                var serializedForm = methods.serializeForm('frm_'+params.localId+'_'+params.indexForm);
                if(serializedForm){
                    if(serializedForm.indexOf(' '+initialId+'="undefined"') !== -1 || serializedForm.indexOf(' '+initialId+'=""') !== -1) {
                        descrType = 'insert';
                        if(initialId === 'ADV_ID'){
                            serializedForm = serializedForm.replace(' '+initialId+'=""', ' '+initialId+'="" ILI_DATA_ID="' + prm[1] + '"');
                        }
                    }
                    else {
                        if(prm[1] !== '')
                            descrType = 'update';
                    }
                }
                //Проходимся по options.data(задача шурфовок) и заменяем параметры в сериализованнй форме
                if(params.options.data)
                    for(var item in params.options.data){
                        //если нашли такой атрибут, то его затираем тем, что пришел в форму изначально
                        if(serializedForm.indexOf(' '+item+'="') !== -1 && params.options.data[item]){
                            serializedForm = serializedForm.replace(' '+item+'="',' '+item+'_old="');
                        }
                        //не нашли, то добавляем как новый атрибут
                        if(params.options.data[item])
                            serializedForm += ' '+item+'="'+params.options.data[item]+'" ';
                    }
                var dataProvider = frm.data('dataProvider')+'#'+reqId;//'STO_SEM.xml';
                if(params.options.handlers.saveCallback){
                    params.options.handlers.saveCallback(serializedForm, dataProvider);
                    return;
                }

                //TODO переработать. Если встрачаем вкладку excavate или repair, то сохраняем по другой схеме
                if(reqId === "PODS_STO_SHEET_REPAIR_LIST" || reqId === "PODS_STO_SHEET_EXCAVATE_LIST"){
                    //methods.saveShurfTabForm(params);
                    return;
                }
                methods.serverQueryNode(Services.processQueryNode,
                    {descrId:dataProvider,
                        descrType:descrType,
                        data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">' +
                            '<data FILTER="ID='+prm[1]+
                            '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                            '" DB_SCHEMA_ID="'+db_schema+
                            '" DB_TABLE_ID="'+db_table_id+
                            '" SYS_CLASS_ID="'+prm[0]+
                            '" SYS_OBJ_ID="'+prm[1]+'" '+serializedForm+' /></root>'},methods.parseTabValues,$.extend(params,{loadObject:params.options.curObject}));
                params.callBack(params);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },//сохранение вкладок по шурфовкам
        saveShurfTabForm:function(shurfArray){
            if(shurfArray.length > 0){
                //забираем форму из массива и проводим по ней все действия. Когда с ней всё сделали, работаем со второй
                var params = shurfArray[0];
                shurfArray.shift();
                try {
                    var frm = $('#frm_'+params.localId+'_'+params.indexForm),
                        prm = params.options.objects[params.options.curObject].id.split(':'),
                        descrType = 'update';
                    if(prm[1] == undefined) {
                        descrType='insert';
                        prm[1] = '';
                    }
                    var serializedForm = methods.serializeForm('frm_'+params.localId+'_'+params.indexForm);

                    var hasSheetId = false
                    //Проходимся по options.data(задача шурфовок) и заменяем параметры в сериализованнй форме
                    if(params.options.data)
                        for(var item in params.options.data){
                            if(item === 'SHEET_ID')
                                hasSheetId = true;
                            //если нашли такой атрибут, то его затираем тем, что пришел в форму изначально
                            if(serializedForm.indexOf(' '+item+'="') != -1){
                                serializedForm = serializedForm.replace(' '+item+'="',' '+item+'_old="');
                            }
                            //не нашли, то добавляем как новый атрибут
                            serializedForm += ' '+item+'="'+params.options.data[item]+'" ';
                        }
                    if(serializedForm.indexOf(' LIST_ID="') != -1)
                        descrType = 'update';
                    else
                        descrType = 'insert';
                    //если нет list_id и есть sheet_id, то insert иначе update
                    var reqId = $($('#ulTabs_'+params.localId).children()[params.indexForm]).data('source');
                    var dataProvider = 'STO_SEM.xml';
                    //TODO переработать. Если встрачаем вкладку excavate или repair, то сохраняем по другой схеме
                    if(reqId === "PODS_STO_SHEET_REPAIR_LIST" || reqId === "PODS_STO_SHEET_EXCAVATE_LIST"){
                        //получаем id дефекта и ищем его sheetId в зависимости от выбранной вкладки
                        //если нет weld_number, то предлагаем его ввести, инача обычное сохранение
                        var iliDataId = prm[1];
                        var iliType = prm[0] === 'PODS_ILI_CLUSTER'?'ILI_CLUSTER_ID':'ILI_DATA_ID';
                        if(serializedForm.indexOf(' '+iliType+'="undefined" ') !== -1){
                            //получаем из prm
                            serializedForm = serializedForm.replace(' '+iliType+'="undefined" ',' '+iliType+'="'+iliDataId+'" ');
                        }
                        if(serializedForm.indexOf(' WELD_NUMBER=') === -1 && hasSheetId){
                            if(params.options.handlers.saveCallback){
                                params.options.handlers.saveCallback(serializedForm);
                                return;
                            }
                        }
                        if(serializedForm.indexOf(' '+iliType+'=""') !== -1 ){
                            serializedForm = serializedForm.replace(' '+iliType+'=""', ' '+iliType+'="'+iliDataId+'"');
                        }

                        var dObj = $.extend(params,{loadObject:params.options.curObject});
                        methods.getSheetId(iliDataId,reqId, function(sheetId, stoEventId, type){
                            if(!sheetId || sheetId === ''){//если не нашли sheetId, то предлагаем сохранить ведомость и после этого сохраняем
                                methods.saveSheet(iliDataId, type, function(sheetId, stoEventId, type){
                                    methods.saveList(sheetId,type, serializedForm,dataProvider+'#'+reqId,descrType,dObj, function(listId){
                                        methods.saveShurfTabForm(shurfArray);//повторяем сохранение след. вкладки
                                    })
                                },dObj);
                            }
                            else
                                methods.saveList(sheetId,type, serializedForm,dataProvider+'#'+reqId,descrType,dObj, function(listId){
                                    methods.saveShurfTabForm(shurfArray);//повторяем сохранение след. вкладки
                                });
                        },dObj);
                    }
                } catch (err) {
                    //Ничего не делаем, возможно панель закрыта
                }
            }
        },//вставка/обновление сведений о шурфовках/ремеонте
        saveList:function(sheetId, type, serializedForm, request,descrType, divObject, callback){
            var listId = 'NULL';
            //ищем LIST_ID
            if(serializedForm.indexOf(' LIST_ID="') != -1){
                var sub = serializedForm.substr(serializedForm.indexOf(' LIST_ID="')+10);
                if(sub !== '')
                    listId = sub.substr(0,sub.indexOf('"'));
            }
            if(serializedForm.indexOf(' SHEET_ID="') != -1){
                serializedForm = serializedForm.replace(' SHEET_ID="',' SHEET_ID_old="');
            }
            serializedForm += '  SHEET_ID="'+sheetId+'"';
            methods.serverQueryNode(Services.processQueryNode,
                {descrId:request, descrType:descrType, getSchema:false, toElements:false,
                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">' +
                        '<data FILTER="ID='+listId+'" '+
                        serializedForm+' /></root>'},methods.parseTabValues,divObject);
            if(callback)
                callback();
        },
        //сохранение ведомости
        saveSheet:function(iliDataId, type, callback, divObject){
            //сначала получаем идентификатор обследования и межкранового участка
            methods.serverQueryNode(Services.processQueryNode,
                {descrId:'STO_SEM.xml#GET_INSP_EVENT_ID_BY_ILI_DATA_ID', descrType:'select', getSchema:false, toElements:false,
                    data:'<root><data ILI_DATA_ID="'+iliDataId+'" ILI_CLUSTER_ID="'+iliDataId+'"/></root>'},function(resultXml){
                    var er = HTTPServiceUtil.getError(resultXml);
                    if (er != "") {
                        App.errorReport(gis_core_error_1, gis_ppanel_14 + er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_18'});
                        if(callback)
                            callback();
                        return false;
                    } else {
                        var datas = $(resultXml).find('data');
                        if(datas.length > 0){
                            var inspectionId = datas[0].getAttribute('ILI_INSPECTION_ID');
                            var stoEventId = datas[0].getAttribute('STO_ILI_INSP_EVENT_ID');
                            var gridSheetForm = new GridSTOSheetForm({
                                iliDataId:inspectionId,
                                data:{ILI_INSPECTION_ID:inspectionId,STO_ILI_INSP_EVENT_ID:stoEventId},
                                sheetType:type,
                                applyCallback:function(sheetId){
                                    if(callback)
                                        callback(sheetId,stoEventId,type);
                                }
                            });
                            gridSheetForm.buildNewSheet_();
                        }
                        else
                            App.errorReport(gis_ppanel_63, gis_ppanel_64, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_20'});
                    }
                },divObject);
        },
        //получение ведомости по ili_data_id
        getSheetId:function(iliDataId, type, callback, divObject){
            var request = 'GET_EXCAVATE_SHEET_ID_BY_ILI_DATA_ID';
            if(type === "PODS_STO_SHEET_REPAIR_LIST"){
                request = 'GET_REPAIR_SHEET_ID_BY_ILI_DATA_ID';
                type = 'repair';
            }
            else{
                type = 'excavate'
            }
            methods.serverQueryNode(Services.processQueryNode,
                {descrId:'STO_SEM.xml#'+request, descrType:'select', getSchema:false, toElements:false,
                    data:'<root><data ILI_DATA_ID="'+iliDataId+'"  ILI_CLUSTER_ID="'+iliDataId+'" /></root>'},function(resultXml){
                    var er = HTTPServiceUtil.getError(resultXml);
                    var semId = undefined;
                    var stoEventId = undefined;
                    if (er != "") {
                        App.errorReport(gis_core_error_1, gis_ppanel_14 + er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_17'});
                        return false;
                    } else {
                        var datas = $(resultXml).find('data');
                        if(datas.length > 0){
                            //забираем первый sheetId, как в гриде
                            //semId = datas[0].getAttribute('SHEET_ID');
                            //var stoEventId = datas[0].getAttribute('STO_ILI_INSP_EVENT_ID');
                            semId = datas[datas.length-1].getAttribute('SHEET_ID');
                            stoEventId = datas[datas.length-1].getAttribute('STO_ILI_INSP_EVENT_ID');
                        }
                        if(callback)
                            callback(semId,stoEventId, type);
                    }
                },divObject);
        },
        setTableData:function(data,params){
            try {
                //data = data.replace(/<root/g,"&lt;root").replace(/root>/g,"root&gt;").replace(/<data/g,"&lt;data").replace(/data>/g,"data&gt;");
                var localData = App.convertDataXmlToArray(data, true);
                params.source.localdata = localData;
                var dataAdapter = new $.jqx.dataAdapter(params.source);
                $('#'+params.idTable).jqxGrid({source:dataAdapter});
                //Сразу после обновления блокируем кнопки в гридах комментариев и прикрепленных документов
                methods.setCommentDocGridBtnDisabled(params, true);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        markChange:function(params){
            try {
                if(params.control.data('loadvalue') == true || params.options.creatingNewObject==true) {
                    var selectedIndex = $('#divTabs_'+params.localId).jqxTabs('selectedItem');
                    //var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                    var frm = $('#frm_'+params.localId+'_'+selectedIndex);
                    if(frm.length != 0) {
                        frm.addClass('frmChanged');
                    }
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        unlockFormControls:function(params){
            try {
                $('#divTabContent_'+params.localId+'_'+params.selectedIndex+' .formControl').each(function(){
                    var el = $(this);
                    if(!el.hasClass('noEditable')) {
                        switch(el.data('typecontrol')) {
                            case 'input':
                                var isShurf = (params.idRequest === "PODS_STO_SHEET_EXCAVATE" || params.idRequest === "PODS_STO_SHEET_REPAIR" || params.idRequest === "PODS_STO_SHEET_MTR");
                                if( isShurf && (el.attr('id').indexOf('INSP_DESCRIPTION_'+params.localId+'_') != -1 || el.attr('id').indexOf('INSP_ROUTE_DESCRIPTION_'+params.localId+'_') != -1)){

                                }
                                else
                                    el.jqxInput({disabled:false}); el.data('loadvalue',true);
                                break;
                            case 'numberinput':el.jqxNumberInput({disabled:false}); el.data('loadvalue',true); break;//разблокируем и помечаем как контрол с загруженными данными
                            case 'checkbox':el.jqxCheckBox({disabled:false}); el.data('loadvalue',true); break; //разблокируем и помечаем как контрол с загруженными данными
                            case 'date':
                                el.data('loadvalue',true);
                                break; //разблокируем и помечаем как контрол с загруженными данными
                            case 'combobox':
                                if(!el.hasClass('noListValues')) {
                                    //комбобокс разблокируем и помечаем как контрол с загруженными данными только если в него загружены значения (нет класса noListValues)
                                    //el.data('loadvalue',true);
                                    //el.jqxComboBox({disabled:false});
                                }
                                break;
                        }
                    }
                });
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        getDivContent:function(params){
            try {
                var divContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
                switch(params.idRequest)
                {
                    case 'SYS_COMMENT_LIST':
                        divContent.css('overflow','hidden'); //Добавляем, чтобы скроллов не было видно
                        divContent.append('<div class="pPanelTable width100" style="height: 100%;">\
                                  <div class="pPanelTableRow" style="height: 100%">\
                                   <div id="divCommentContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTableCell" style="height: 100%"></div>\
                                   <div class="pPanelTableCell leftPanelAddDocs" style="height: 100%;">\
                                    <button id="btnNewComment_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Добавить</button>\
                                    <button id="btnDeleteComment_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton " >Удалить</button>\
                                    <button id="btnEditComment_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Редактировать</button>\
                                   </div>\
                                  </div>\
                                 </div>');
                        divContent = $('#divCommentContent_'+params.localId+'_'+params.selectedIndex);
                        $('#btnNewComment_'+params.localId+'_'+params.selectedIndex).jqxButton().on('click',function(){
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {descrId:'SYS_PROP.xml#PROP_LIST',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="PODS_COMMENTS"/></root>'},methods.parseCommentFormDescribe,$.extend(params,{divContent:divContent,action:'insert',idRequest:'CommentForm',idComment:''}));
                        });
                        $('#btnEditComment_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' div[data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {descrId:'SYS_PROP.xml#PROP_LIST',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="PODS_COMMENTS"/></root>'},methods.parseCommentFormDescribe,$.extend(params,{divContent:divContent,action:'update',idRequest:'CommentForm',idComment:$(grid.jqxGrid('source').recordids[selRecord]).attr('COMMENTS_ID')}));
                            //Очищаем выделение в гриде
                            grid.jqxGrid('clearselection');
                        });
                        $('#btnDeleteComment_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' [data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            var alertForm = new AlertForm();
                            alertForm.alertOkButtonText = gis_ppanel_6;
                            alertForm.alertCancelButtonText = gis_ppanel_7;
                            alertForm.build("btnDeleteCommentAlertForm",gis_ppanel_31,gis_ppanel_32);
                            //Добавляем слушатель закрытия формы
                            $("body").on(CloseEvent.CLOSE, function btnDeleteCommentAlertFormClose(evt/*CloseEvent*/) {
                                $("body").off(CloseEvent.CLOSE);
                                if (evt && evt.detail==1) {
                                    var prm = params.options.objects[params.options.curObject].id.split(':'),
                                        db= prm[0].split('_'),
                                        db_schema = db[0],
                                        db_table_id = db.slice(1).join('_');
                                    //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                                    if (params.hasOwnProperty('curSchema') && params.hasOwnProperty('curTable')) {
                                        db_schema = params.curSchema;
                                        db_table_id = params.curTable;
                                    }
                                    methods.serverQueryNode(Services.processQueryNode,
                                        {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENT_LIST',
                                            descrType:'delete',
                                            getSchema:false,
                                            toElements:false,
                                            data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+prm[1]+
                                                '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                                '" DB_SCHEMA_ID="'+db_schema+
                                                '" DB_TABLE_ID="'+db_table_id+
                                                '" SYS_CLASS_ID="'+prm[0]+
                                                '" SYS_OBJ_ID="'+prm[1]+
                                                '" COMMENTS_ID="'+$(grid.jqxGrid('source').recordids[selRecord]).attr('COMMENTS_ID')+'"/></root>'},methods.refreshCommentTable,$.extend(params,{divContent:divContent}));
                                    //Очищаем выделение в гриде
                                    grid.jqxGrid('clearselection');
                                }
                            });
                        });
                        break;
                    case 'SYS_DOCUMENT_LIST':
                        divContent.css('overflow','hidden'); //Добавляем, чтобы скроллов не было видно
                        divContent.append('<div class="pPanelTable width100" style="height: 100%;">\
                                  <div class="pPanelTableRow" style="height: 100%;">\
                                   <div id="divAddDocsContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTableCell" style="height: 100%;">\
                                   </div>\
                                   <div class="pPanelTableCell leftPanelAddDocs" style="height: 100%;">\
                                    <button id="btnOpenDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Открыть</button>\
                                    <button id="btnLoadNewDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Загрузить новый</button>\
                                    <button id="btnDeleteDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Удалить</button>\
                                    <button id="btnEditDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Редактировать</button>\
                                   </div>\
                                  </div>\
                                 </div>');
                        /* Убираем эту кнопку, будет реализовано по-другому: <button id="btnNewDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Добавить</button>\ */
                        divContent = $('#divAddDocsContent_'+params.localId+'_'+params.selectedIndex);
                        $('#btnOpenDoc_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' div[data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            var curDocGridSelectedItem = $(grid.jqxGrid('source').recordids[selRecord]);
                            var idDoc = curDocGridSelectedItem.attr('DOC_ID'),
                                prm = params.options.objects[params.options.curObject].id.split(':'),
                                db= prm[0].split('_'),
                                db_schema = db[0],
                                db_table_id = db.slice(1).join('_');
                            methods.serverQueryNode(Services.processQueryNode,
                                {descrId:'SYS_SEM.xml#DOCUMENT_OPEN',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" DOC_ID="'+idDoc+
                                        '" FILTER="ID='+prm[1]+
                                        '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                        '" DB_SCHEMA_ID="'+db_schema+
                                        '" DB_TABLE_ID="'+db_table_id+
                                        '" SYS_CLASS_ID="'+prm[0]+
                                        '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.loadDoc, $.extend(params, {curDocGridSelectedItem:curDocGridSelectedItem}));
                            //Очищаем выделение в гриде
                            grid.jqxGrid('clearselection');
                        });
                        $('#btnLoadNewDoc_'+params.localId+'_'+params.selectedIndex).jqxButton().on('click',function(){
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {descrId:'SYS_PROP.xml#PROP_LIST',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="WEB50_LIB_DOC"/></root>'},methods.parseFormDescribe,$.extend(params,{divContent:divContent,action:'insert',idRequest:'DocForm'}));
                        });
                        $('#btnDeleteDoc_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' [data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            var alertForm = new AlertForm();
                            alertForm.alertOkButtonText = gis_ppanel_6;
                            alertForm.alertCancelButtonText = gis_ppanel_7;
                            alertForm.build("btnDeleteDocAlertForm",gis_ppanel_31,gis_ppanel_32);
                            //Добавляем слушатель закрытия формы
                            $("body").on(CloseEvent.CLOSE, function btnDeleteDocAlertFormClose(evt/*CloseEvent*/) {
                                $("body").off(CloseEvent.CLOSE);
                                if (evt && evt.detail == 1) {
                                    var prm = params.options.objects[params.options.curObject].id.split(':'),
                                        db= prm[0].split('_'),
                                        db_schema = db[0],
                                        db_table_id = db.slice(1).join('_');
                                    methods.serverQueryNode(Services.processQueryNode,
                                        {descrId:'SYS_SEM.xml#DOCUMENT_LIST',
                                            descrType:'delete',
                                            getSchema:false,
                                            toElements:false,
                                            data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+prm[1]+
                                                '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                                '" DB_SCHEMA_ID="'+db_schema+
                                                '" DB_TABLE_ID="'+db_table_id+
                                                '" SYS_CLASS_ID="'+prm[0]+
                                                '" SYS_OBJ_ID="'+prm[1]+
                                                '" GATE_ID="'+$(grid.jqxGrid('source').recordids[selRecord]).attr('GATE_ID')+'"/></root>'},methods.deleteDocFile,$.extend(params,{divContent:divContent}));
                                    //Очищаем выделение в гриде
                                    grid.jqxGrid('clearselection');
                                }
                            });
                        });
                        $('#btnEditDoc_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' [data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {descrId:'SYS_PROP.xml#PROP_LIST',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="WEB50_LIB_DOC"/></root>'},methods.parseFormDescribe,$.extend(params,{divContent:divContent,action:'update',idRequest:'DocForm',idFile:$(grid.jqxGrid('source').recordids[selRecord]).attr('DOC_ID')}));
                            //Очищаем выделение в гриде
                            grid.jqxGrid('clearselection');
                        });
                        break;
                    case 'DocForm':
                        $('.pPanelModalForm').remove();
                        var docEditFormTitle = params.action=='insert' ? gis_ppanel_59 : '';
                        $('body').append('<div id="divDocForm_'+params.localId+'" class="pPanelModalForm jqx-tabs-content-myCommon">\
                                   <div>\
                                    <form id="frm_'+params.localId+'_'+params.selectedIndex+'" class="frmPanelTab" data-waitload="0">\
                                     <div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTabContent"></div>\
                                    </form>\
                                    <div class="divBottomWindow">\
                                     <button id="btnSaveDocForm_'+params.localId+'" class="btnForm myButton">Сохранить</button>\
                                     <button id="btnCancelDocForm_'+params.localId+'" class="btnForm myButton">Отмена</button>\
                                    </div>\
                                   </div>\
                                  </div>');
                        divContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
                        var dlg = $('#divDocForm_'+params.localId).dialog({
                            dialogClass: "jqx-tabs-content-myCommon",
                            title: docEditFormTitle,
                            closeOnEscape: true,
                            width: 340,
                            height: 200,
                            resizable: false,
                            modal: true
                        });
                        $('#btnCancelDocForm_'+params.localId).jqxButton().on('click',function(){dlg.dialog('destroy').remove();});
                        $('#btnSaveDocForm_'+params.localId).jqxButton().on('click',function(){
                            //Проверяем, что поле выбранного файла не пустое
                            var docFileInput = $('#FILE_NAME_'+params.localId+'_'+params.selectedIndex);
                            if (docFileInput.length > 0  && docFileInput.attr('value')!=undefined && docFileInput.attr('value')!='') {
                                $('#btnSaveDocForm_'+params.localId).jqxButton({disabled:true});
                                methods.saveFormNew($.extend(params,{indexForm:params.selectedIndex,callBack:function(){
                                    }}));
                            } else {
                                App.errorReport(gis_ppanel_33+gis_ppanel_25, gis_ppanel_14 + gis_ppanel_34, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_13'});
                            }
                        });
                        break;
                    case 'CommentForm':
                        $('.pPanelModalForm').remove();
                        var commentEditFormTitle = params.action=='insert' ? gis_ppanel_60 : '';
                        $('body').append('<div id="divCommentForm_'+params.localId+'" class="pPanelModalForm jqx-tabs-content-myCommon">\
                                   <div>\
                                    <form id="frm_'+params.localId+'_'+params.selectedIndex+'" class="frmPanelTab" data-waitload="0">\
                                     <div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'"></div>\
                                    </form>\
                                    <div class="divBottomWindow">\
                                     <button id="btnSaveCommentForm_'+params.localId+'" class="btnForm myButton">Сохранить</button>\
                                     <button id="btnCancelCommentForm_'+params.localId+'" class="btnForm myButton">Отмена</button>\
                                    </div>\
                                   </div>\
                                  </div>');
                        divContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
                        var dlg = $('#divCommentForm_'+params.localId).dialog({
                            dialogClass: "jqx-tabs-content-myCommon",
                            title: commentEditFormTitle,
                            closeOnEscape: true,
                            width: 380,
                            height: 150,
                            resizable: false,
                            modal: true
                        });
                        $('#btnCancelCommentForm_'+params.localId).jqxButton().on('click',function(){dlg.dialog('destroy').remove();});
                        $('#btnSaveCommentForm_'+params.localId).jqxButton().on('click',function(){
                            $('#btnSaveCommentForm_'+params.localId).jqxButton({disabled:true});
                            methods.saveFormNew($.extend(params,{indexForm:params.selectedIndex,callBack:function(){
                                } }));});
                        break;
                }
                return divContent;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setInputFileName:function(){
            try {
                var fileName = $(this).val().split('\\');
                var changedElement = $('#'+this.id.replace('iFI_',''));
                if(fileName.length != 1)fileName = fileName[fileName.length-1].split('.');
                else fileName = fileName[0].split('.');
                fileName[fileName.length-2] = fileName[fileName.length-2]+'-'+methods.getUniqueId();
                fileName = fileName.join('.');
                $(this).data('filename',fileName);
                changedElement.val(fileName);
                changedElement.trigger('change');
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setInputFileNameText:function(){
            try {
                var changedElement = $('#'+this.id.replace('iFIText_',''));
                var fileName = $(this).val();
                if(fileName.indexOf('.pdf#')==-1){
                    var fInput = $('#'+this.id.replace('iFIText_','iFI_')).val();
                    // если после выбора файла вписывали руками путь, то сохраняем этот без разбития пути
                    if(fileName==fInput){
                        fileName = $(this).val().split('\\');
                        if(fileName.length != 1)fileName = fileName[fileName.length-1].split('.');
                        else fileName = fileName[0].split('.');
                        fileName[fileName.length-2] = fileName[fileName.length-2]+'-'+methods.getUniqueId();
                        fileName = fileName.join('.');
                    }
                }
                $(this).data('filename',fileName);
                changedElement.data('needSetFileInput',false);
                changedElement.val(fileName);
                changedElement.trigger('change');
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        saveComment:function(params){
            try {
                var dataFromForm = methods.serializeForm('frm_'+params.localId+'_extForm');
                //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                if (params.hasOwnProperty('curSchema') && params.hasOwnProperty('curTable')) {
                    var tableIdStartIndex = dataFromForm.indexOf('TABLE_ID="') + 10;
                    var tableIdEndIndex = dataFromForm.indexOf('"',tableIdStartIndex);
                    dataFromForm = dataFromForm.replace(dataFromForm.substring(tableIdStartIndex,tableIdEndIndex), params.curTable);
                }
                switch(params.action) {
                    case 'insert':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENTS',
                                descrType:params.action,
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'" ><data SYS_FULL_ID="" SYS_CLASS_ID="PODS_COMMENTS" SYS_OBJ_ID="" DB_SCHEMA_ID="PODS" DB_TABLE_ID="COMMENTS" CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" '+dataFromForm+'/></root>'},
                            methods.refreshCommentTable,params);
                        break;
                    case 'update':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENTS',
                                descrType:params.action,
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'" ><data SYS_FULL_ID="PODS_COMMENTS/'+params.idComment+'" SYS_CLASS_ID="PODS_COMMENTS" SYS_OBJ_ID="'+params.idComment+'" DB_SCHEMA_ID="PODS" DB_TABLE_ID="COMMENTS" CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" '+dataFromForm+'/></root>'},
                            methods.refreshCommentTable,params);
                        break;
                }
                params.callBack(params);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        saveDocFile:function(params){
            try {
                switch(params.action) {
                    case 'insert':
                        var prm = params.options.objects[params.options.curObject].id.split(':'),
                            db= prm[0].split('_'),
                            db_schema = db[0],
                            db_table_id = db.slice(1).join('_');
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'SYS_SEM.xml#WEB50_LIB_DOC',
                                descrType:'insert',
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+prm[1]+
                                    '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                    '" DB_SCHEMA_ID="'+db_schema+
                                    '" DB_TABLE_ID="'+db_table_id+
                                    '" SYS_CLASS_ID="'+prm[0]+
                                    '" SYS_OBJ_ID="'+prm[1]+'" '+methods.serializeForm('frm_'+params.localId+'_extForm')+'/></root>'},methods.parseAddDoc,params);
                        break;
                    case 'update':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'SYS_SEM.xml#WEB50_LIB_DOC',
                                descrType:'update',
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+params.idFile+
                                    '" SYS_FULL_ID="WEB50_LIB_DOC/'+params.idFile+
                                    '" DB_SCHEMA_ID="WEB50" DB_TABLE_ID="LIB_DOC" SYS_CLASS_ID="WEB50_LIB_DOC'+
                                    '" SYS_OBJ_ID="'+params.idFile+'" '+methods.serializeForm('frm_'+params.localId+'_extForm')+'/></root>'},methods.refreshDocTable,params);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        uploadComplete:function(params){
            try {
                if($(params.iframe).data('checkload') == true) {
                    $(params.iframe).data('checkload',false);
                    var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                    frm.data('waitload',Number(frm.data('waitload'))-1);
                    $('#divFI'+params.iframe.id.replace('ifr','')).removeClass('waitLoad');
                    if(params.options.handlers.setDataLoadingCallback != undefined)params.options.handlers.setDataLoadingCallback(false);
                    if(Number(frm.data('waitload')) == 0) methods[params.saveMethod](params);
                }
            } catch (e) {
                App.errorReport(gis_ppanel_35, gis_ppanel_14 + e.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_14'});
            }
        },
        parseAddDoc:function(xmlElement,params) {
            try {
                switch(xmlElement[0].tagName) {
                    case 'root':xmlElement.children().each(function(){methods.parseAddDoc($(this),params);});break;
                    case 'data':
                        switch(params.action)
                        {
                            case 'insert':
                                var prm = params.options.objects[params.options.curObject].id.split(':'),
                                    db= prm[0].split('_'),
                                    db_schema = db[0],
                                    db_table_id = db.slice(1).join('_');
                                methods.serverQueryNode(Services.processQueryNode,
                                    {descrId:'SYS_SEM.xml#DOCUMENT_LIST',
                                        descrType:'insert',
                                        getSchema:false,
                                        toElements:false,
                                        data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+prm[1]+
                                            '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                            '" DB_SCHEMA_ID="'+db_schema+
                                            '" DB_TABLE_ID="'+db_table_id+
                                            '" SYS_CLASS_ID="'+prm[0]+
                                            '" SYS_OBJ_ID="'+prm[1]+
                                            '" LEFT_OBJ_ID="WEB50_LIB_DOC/'+xmlElement.attr('ID')+
                                            '" RIGHT_OBJ_ID="'+prm[0]+'/'+prm[1]+'"/></root>'},methods.refreshDocTable,params);
                                break;
                            case 'update':
                                methods.refreshDocTable(xmlElement, params);
                                break;
                        }
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        refreshDocTable:function(xmlElement,params){
            try {
                var curDocGrid = $('#'+params.divContent.attr('id')+ ' div[data-selectscript="SYS_SEM.xml#DOCUMENT_LIST"]');
                var curDocGridSource = curDocGrid.jqxGrid('source')._source;
                var prm = params.options.objects[params.options.curObject].id.split(':'),
                    db= prm[0].split('_'),
                    db_schema = db[0],
                    db_table_id = db.slice(1).join('_'),
                    idTable = curDocGrid.attr('id');
                methods.serverQueryStringNode(Services.processQueryNode,
                    {descrId:'SYS_SEM.xml#DOCUMENT_LIST',
                        descrType:'select',
                        getSchema:false,
                        toElements:false,
                        data:'<root><data FILTER="ID='+prm[1]+
                            '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                            '" DB_SCHEMA_ID="'+db_schema+
                            '" DB_TABLE_ID="'+db_table_id+
                            '" SYS_CLASS_ID="'+prm[0]+
                            '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.setTableData,
                    $.extend({divProperties:params.divProperties,
                        source:curDocGridSource,
                        idTable:idTable}));
                var form = $('#divDocForm_'+params.localId);
                if(form != undefined && form.length > 0) {
                    form.dialog('destroy').remove();
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        refreshCommentTable:function(xmlElement,params){
            try {
                var curCommentsGrid = $('#'+params.divContent.attr('id')+ ' div[data-selectscript="GAZPROM_SYS_SEM.xml#PODS_COMMENT_LIST"]');
                var curCommentsGridSource = curCommentsGrid.jqxGrid('source')._source;
                var prm = params.options.objects[params.options.curObject].id.split(':'),
                    db= prm[0].split('_'),
                    db_schema = db[0],
                    db_table_id = db.slice(1).join('_'),
                    idTable = curCommentsGrid.attr('id');
                //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                if (params.hasOwnProperty('curSchema') && params.hasOwnProperty('curTable')) {
                    db_schema = params.curSchema;
                    db_table_id = params.curTable;
                }
                methods.serverQueryStringNode(Services.processQueryNode,
                    {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENT_LIST',
                        descrType:'select',
                        getSchema:false,
                        toElements:false,
                        data:'<root><data FILTER="ID='+prm[1]+
                            '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                            '" DB_SCHEMA_ID="'+db_schema+
                            '" DB_TABLE_ID="'+db_table_id+
                            '" SYS_CLASS_ID="'+prm[0]+
                            '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.setTableData,
                    $.extend({divProperties:params.divProperties,
                        source:curCommentsGridSource,
                        idTable:idTable}));
                var form = $('#divCommentForm_'+params.localId);
                if(form != undefined && form.length > 0) {
                    form.dialog('destroy').remove();
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        loadDoc:function(xmlElement,params){
            try {
                switch(xmlElement[0].tagName) {
                    case 'root':xmlElement.children().each(function(){methods.loadDoc($(this),params);});break;
                    case 'data':
                        if (xmlElement.attr('FILE_NAME')!=undefined && xmlElement.attr('PATH')!=undefined) {
                            try {
                                if (params && params.curDocGridSelectedItem!=undefined && params.curDocGridSelectedItem!=null
                                    && params.curDocGridSelectedItem.attr('DOC_ID')!=null && params.curDocGridSelectedItem.attr('DOC_TYPE_ID')!=null) {
                                    //Для открытия 3D-сцены или IMG-карты проверяем тип прикрепленного документа
                                    var docId = params.curDocGridSelectedItem.attr('DOC_ID')!='' ? params.curDocGridSelectedItem.attr('DOC_ID') : '';
                                    var docTypeId = params.curDocGridSelectedItem.attr('DOC_TYPE_ID')!='' ? params.curDocGridSelectedItem.attr('DOC_TYPE_ID') : '';
                                    if (docTypeId!='' && (docTypeId=="37" || docTypeId=="38" || docTypeId=="41")) {
                                        var docObj = {};
                                        docObj.DOC_ID = docId;
                                        docObj.FILE_NAME = xmlElement.attr('FILE_NAME');
                                        /*(linkObj is FileInput) ? (linkObj as FileInput).fileLoading.text : (linkObj as TextInput).text;*/
                                        switch (docTypeId) {
                                            case "37":	//3Dсцена
                                                ExportUtil.exportToWRL(docObj.DOC_ID, docObj.FILE_NAME);
                                                break;
                                            case "38":	//IMG-карта
                                                ExportUtil.exportToIMG(docObj.DOC_ID, docObj.FILE_NAME);
                                                break;
                                            case "41":	//Видеофайл
                                                var rowDataObj = {};
                                                rowDataObj.ID = docObj.DOC_ID;
                                                rowDataObj.FILE_NAME = docObj.FILE_NAME;
                                                //Для трубопроводов пытаемся получить также LINE_ID для воспроизведения
                                                if (params.curTable=='ROUTE') {
                                                    var routeData = methods.serializeForm('frm_'+params.localId+'_0');
                                                    var lineIdInd = routeData.indexOf('LINE_ID="');
                                                    if (lineIdInd >= 0) {
                                                        showVideo(docObj.DOC_ID, docObj.FILE_NAME, gis_ppanel_49, routeData.substring(lineIdInd+9,routeData.indexOf('"',lineIdInd+9)));
                                                    } else {
                                                        showVideo(docObj.DOC_ID, docObj.FILE_NAME, gis_ppanel_49);
                                                    }
                                                } else {
                                                    showVideo(docObj.DOC_ID, docObj.FILE_NAME, gis_ppanel_49);
                                                }
                                                //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                                widgetMoveWindowToPosition('grid');
                                                break;
                                        }
                                    } else {
                                        //Если документ не является ни 3D-сценой, ни IMG-картой, ни видеофайлом - открываем его
                                        window.open(pPanelOpenDocPath + xmlElement.attr('PATH') + xmlElement.attr('FILE_NAME'), '_blank');
                                    }
                                } else {
                                    window.open(pPanelOpenDocPath + xmlElement.attr('PATH') + xmlElement.attr('FILE_NAME'), '_blank');
                                }
                            } catch (e) {
                                App.errorReport(gis_ppanel_24+gis_ppanel_25, gis_ppanel_14 + e.message.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_15'});
                            }
                        } else
                            App.errorReport(gis_ppanel_24+gis_ppanel_25, gis_ppanel_14 + gis_ppanel_36, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_16'});
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseCommentFormDescribe:function(xmlElement,params){
            try {
                switch(xmlElement[0].tagName) {
                    case 'root':xmlElement.children().each(function(){methods.parseCommentFormDescribe($(this),params);});break;
                    case 'data':
                        var fileName = '../../Public/Modules/Form/'+xmlElement.attr('id')+'.mxml';
                        methods.serverQueryNode(Services.processQueryNodeXml,
                            {
                                descrId: 'SYS_SEM.xml#GET_XML_FILE',
                                descrType: 'select',
                                data: '<root ><data FILE="' + fileName + '"/></root>'
                            },
                            methods.parseCommentForm,$.extend(params,{selectedIndex:'extForm',saveMethod:'saveComment'}));
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseCommentForm:function(xmlElement,params){
            try {
                methods.parseForm(xmlElement,params);
                switch(params.action) {
                    case 'insert':
                        var prm = params.options.objects[params.options.curObject].id.split(':'),
                            db= prm[0].split('_'),
                            db_table_id = db.slice(1).join('_'),
                            inputOI = $('#OBJECT_ID_'+params.localId+'_'+params.selectedIndex),
                            inputTI = $('#TABLE_ID_'+params.localId+'_'+params.selectedIndex);
                        if(inputOI.length == 0)
                            $('#frm_'+params.localId+'_'+params.selectedIndex).append(
                                '<input id="OBJECT_ID_'+params.localId+'_'+params.selectedIndex+'" type="hidden" value="'+prm[1]+'" data-typecontrol="input" class="formControl" data-loadvalue=true />');
                        else inputOI.val(prm[1]);
                        if(inputTI.length == 0)
                            $('#frm_'+params.localId+'_'+params.selectedIndex).append(
                                '<input id="TABLE_ID_'+params.localId+'_'+params.selectedIndex+'" type="hidden" value="'+db_table_id+'" data-typecontrol="input" class="formControl" data-loadvalue=true />');
                        else inputTI.val(db_table_id);
                        params.divProperties.data('unlockCombo',1);
                        methods.unlockFormControls(params);
                        break;
                    case 'update':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENTS',
                                descrType:'select',
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+params.idComment+
                                    '" SYS_FULL_ID="PODS_COMMENTS/'+params.idComment+
                                    '" DB_SCHEMA_ID="PODS" DB_TABLE_ID="COMMENTS" SYS_CLASS_ID="PODS_COMMNETS" SYS_OBJ_ID="'+params.idComment+'"/></root>'},methods.parseTabValues,params);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseFormDescribe:function(xmlElement,params){
            try {
                switch(xmlElement[0].tagName) {
                    case 'root':xmlElement.children().each(function(){methods.parseFormDescribe($(this),params);});break;
                    case 'data':
                        var fileName = '../../Public/Modules/Form/'+xmlElement.attr('id')+'.mxml';
                        methods.serverQueryNode(Services.processQueryNodeXml,
                            {
                                descrId: 'SYS_SEM.xml#GET_XML_FILE',
                                descrType: 'select',
                                data: '<root ><data FILE="' + fileName + '"/></root>'
                            },
                            methods.parseDocForm,$.extend(params,{selectedIndex:'extForm',saveMethod:'saveDocFile'}));

                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseDocForm:function(xmlElement,params){
            try {
                methods.parseForm(xmlElement,params);
                switch(params.action) {
                    case 'insert':params.divProperties.data('unlockCombo',1);
                        methods.unlockFormControls(params);
                        break;
                    case 'update':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'SYS_SEM.xml#WEB50_LIB_DOC',
                                descrType:'select',
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+params.idFile+
                                    '" SYS_FULL_ID="WEB50_LIB_DOC/'+params.idFile+
                                    '" DB_SCHEMA_ID="WEB50" DB_TABLE_ID="LIB_DOC" SYS_CLASS_ID="WEB50_LIB_DOC'+
                                    '" SYS_OBJ_ID="'+params.idFile+'"/></root>'},methods.parseTabValues,params);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        deleteDocFile:function(xmlElement,params){
            try {
                methods.refreshDocTable(xmlElement,params);
                var alertForm = new AlertForm();
                alertForm.build("pPanelDeleteDocAlertForm",gis_ppanel_37,"",AlertForm.OK);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setAttrsValues:function(params){
            try {
                if(params.options.objects[params.options.curObject].attrs != undefined)
                {
                    $(params.options.objects[params.options.curObject].attrs).each(function(){
                        var control = $('#'+this.name+'_'+params.localId+'_'+params.selectedIndex);
                        if(control.length != 0)
                            methods.setControlValue(control,this);
                    });
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        //сворачиваем панель
        minimizePanel:function(params){
            //получаем localId и по нему
            var options = $(this).data('options');
            if(options!=undefined && options.localId != undefined && options.localId!=''){
                var localId = options.localId;
                $('#pPanelTitleMinimizeBtn_'+localId).jqxButton().trigger('click');
            }

        },
        updateOptions:function(params){
            var options = $(this).data('options');
            $.extend(options,params);
        }
    };

    $.fn.myPropertiesPanel = function( method ){

        if(methods[method]) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.fn.myPropertiesPanel' );
        }
    };
})(jQuery);
(function( $ ){
  var methods = {
    init: function( options ) {
      return this.each(function ()
         {
          if(options.handlers == undefined)$.extend(options,{handlers:{}});
          if(options.buttonsLabels == undefined)$.extend(options,{buttonsLabels:{saveButton:gis_gridadmmapswidget_5, cancelButton:gis_gridadmmapswidget_6}}); //Текст кнопок
          var el = $(this),
              localId = methods.getUniqueId();
          el.data('options',options);

          el.append('<div class="ui-widget-header ui-corner-all ui-helper-clearfix" style="height:25px; border-top-color: currentColor; border-right-color: currentColor; border-bottom-color: currentColor; border-left-color: currentColor; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; white-space: normal; background-image: none; background-color: transparent;">\
                        <div class="pPanelTitleContent" style="float:left; padding-top:3px; padding-left: 5px;">\
                            <span id="spNameObject_'+localId+'"></span>\
                        </div>\
                     </div>\
                     <div class="ui-widget-content ui-dialog-normal" id="pPanelContent_'+localId+'" style="width: auto; min-height: 0px; max-height: none; background-color: #4C93C2; border-color: #005e9a; background-image: none;">\
                        <div style="height: 100%">\
                            <div id="divContent_'+localId+'">Загрузка формы ...</div>\
                            <div class="divBottomPanel pPanelTableCell">\
                                <button id="btnSave_'+localId+'" class="myButton">'+options.buttonsLabels.saveButton+'</button>\
                                <button id="btnCancel_'+localId+'" class="myButton">'+options.buttonsLabels.cancelButton+'</button>\
                            </div>\
                        </div>\
                     </div>');

          $.extend(options,{curObject:0,btnSave:$('#btnSave_'+localId)});

          //Дефолтные размеры панели свойств
          var panelWidth = 400;
          var panelHeight = 255;
          if (options.hasOwnProperty('panelSize')) {
              panelWidth = options.panelSize.propPanelWidth;
              panelHeight = options.panelSize.propPanelHeight;
          } else {
              $.extend(options,{panelSize: {propPanelWidth:panelWidth, propPanelHeight:panelHeight}});
          }
          var prevPanelTopPosition = 200;
          if(options.top!=undefined && options.top!=null && !isNaN(parseInt(options.top))) prevPanelTopPosition = parseInt(options.top);
          //Отступ слева делаем огромный, чтобы изначально форма не была видна
          var panelLeftPosition = 10000;
          el.css({left:panelLeftPosition+'px', top:prevPanelTopPosition+'px', width:'auto'/*panelWidth+'px'*/, height:'auto'/*panelHeight*/, display:'block', position:'absolute'});
          if (options.zindex!=undefined) el.css({'z-index':options.zindex}); /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
          el.addClass('ui-dialog ui-widget ui-widget-content ui-corner-all ui-front pPanelDialog ui-draggable');
          //Создаем не плавающее окно, а плавающую панель
          el.draggable({containment: "parent", cancel: '#pPanelContent_'+localId});
          if (options.zindex!=undefined && options.modal!=undefined && options.modal==true) {
              /* Добавляем к родителю оверлей, закрывающий все под нашей панелью */
              var overlayDiv = $('<div class="applicationBlockOverlay" style="z-index:'+(options.zindex-1).toString()+'"></div>');
              options.overlayDiv = overlayDiv;
              el.after(overlayDiv);
          }
          //Создаем действия для кнопки "сохранить"
          options.btnSave.jqxButton({disabled:true, width:80, theme:'myCommon'}).click(function(){
              if(pPanelParams && pPanelParams.idRequest === 'ADM_CONFIG'){
                  App.confirmDialog(gis_core_error_0, null,{title:gis_core_1});
                  return false;
              }
              methods.checkSave({divProperties:el,localId:localId,options:options,callBack:function(){
                  //Закрываем форму после сохранения
                  if(options.handlers.closeCallback != undefined)
                      options.handlers.closeCallback();
                  methods.destroyPanel(pPanelParams); //el.remove();
              }});
          });
          //Создаем действия для кнопки "отмена"
          $('#btnCancel_'+localId).jqxButton({width:80, theme:'myCommon'}).click(function(evt) {
              if (evt) evt.stopImmediatePropagation();
              if(options.handlers.closeCallback != undefined)
                  options.handlers.closeCallback();
              methods.destroyPanel(pPanelParams); //el.remove();
          });
          //Загружаем форму
          var pPanelParams = {divProperties:el,localId:localId,options:options};
          if(options.objects.length!=0)
              methods.showPanelObject(pPanelParams);
         });
    },
    destroyPanel:function(params) {
      //Полностью удаляем слушатели и компоненты
      if (params && params.hasOwnProperty('divProperties') && params.hasOwnProperty('localId')) {
          var localId = params.localId;
          if (params.options!=undefined && params.options.overlayDiv!=undefined) params.options.overlayDiv.remove(); /*remove overlay*/
          $('#btnSave_' + localId).off();
          $('#btnCancel_' + localId).off();
          try {
              var listForms = $('#divContent_'+localId+' .frmPanelTab');
              for (var i = 0; i<listForms.length; i++) {
                  var frmId = 'frm_'+localId+'_'+i;
                  $(listForms[i]).jqxValidator('hide');
                  $('#'+frmId+' .formControl').each(function(){
                      var el = $(this);
                      switch(el.data('typecontrol')) {
                          case 'input': el.off(); el.jqxInput().off(); el.jqxInput('destroy');break;
                          case 'checkbox': el.off(); el.jqxCheckBox().off(); el.jqxCheckBox('destroy'); break;
                          case 'combobox': el.off(); el.jqxComboBox().off(); el.jqxComboBox('destroy'); break;
                          case 'date': el.off(); el.jqxDateTimeInput().off(); el.jqxDateTimeInput('destroy'); break;
                          case 'file': break;
                          case 'inputfile': break;
                      }
                  });
              }
              //Также чистим компонент jqxTabs
              var tabs = $('#divTabs_'+localId);
              if(tabs.length != 0) {
                  tabs.off();
                  tabs.jqxTabs.off();
                  tabs.jqxTabs('destroy');
              }
          } catch (err) {
              //Ничего не делаем
          }
      }
      params.divProperties.remove(); //Удаляет основной элемент и все его дочерние улементы из DOM, а также чистит слушатели на компонентах внутри
      params.divProperties = null; //На всякий случай убираем из объекта ссылку на divProperties
      //Под конец в IE вызываем сборщик мусора
      if (typeof(CollectGarbage) == "function") CollectGarbage();
      //Под конец в Chrome вызываем сборщик мусора
      if (typeof(gc) == "function") gc();
    },
    serverQueryNode:function(url,params,callbackResult,thisObject) {
        if(thisObject.divProperties == undefined)App.confirmDialog(gis_formPanel_5);
        App.serverQueryNodeWithTries2(url, params, function(data){
            try{
                var xmlData = $.parseXML(data);
                $(xmlData).children().each(function(){callbackResult($(this),thisObject);});
            }
            catch(ex){
                methods.callbackError({text:gis_formPanel_6+'. success. '+ex.message, divProperties:thisObject.divProperties});
                }
        },
        function(data){
            var errorDetail = gis_formPanel_6+'. '+data;
            if(thisObject && thisObject.sender === 'showPanelObject') { // ошибка загрузки mxml
                if (thisObject.options && thisObject.options.overlayDiv) {
                    thisObject.options.overlayDiv.remove(); /*remove overlay*/
                }
                App.errorReport(gis_formPanel_15, errorDetail, undefined, {
                    filename: gis_filename_560,
                    functionname: 'gis_filename_560_2'
                });
            }
            methods.callbackError({text:errorDetail, divProperties:thisObject.divProperties});
        },4);
    },
    serverQueryString:function(url,params,callbackResult,thisObject) {
       if(thisObject.divProperties == undefined)App.confirmDialog(gis_formPanel_5);
       App.serverQueryStringWithTries(url, params, function(data){
                var er = HTTPServiceUtil.getError(data);
                if (er !== '')
                    methods.callbackError({text:gis_formPanel_6+'. '+data,divProperties:thisObject.divProperties});
                else
                    callbackResult($(data).find('string').text(),thisObject);
            },
            function (data){
                methods.callbackError({text:gis_formPanel_6+'. '+data,divProperties:thisObject.divProperties});
            },4);        
    },
    callbackError: function(params){
      var el = params.divProperties.data('options');
      if(el.handlers.errorHandler !== undefined)el.handlers.errorHandler(params);
    },
   getUniqueId : function(){return 'xxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);return v.toString(16);});
    },
    openObjectInNewPanel : function(params){
      try {
          /* params = {divProperties:params.divProperties, localId:params.localId, options:{objects:[params.options.objects[params.options.curObject]], curObject:0, handlers:params.options.handlers, opener:params.options.opener}} */
          //Заново создаем панель
          if (params!=undefined && params.hasOwnProperty('divProperties') && params.hasOwnProperty('options')) {
              //Создаем панель свойств для текущего объекта
              var gridPropPanelId = params.divProperties.attr('id');
              $('#' + gridPropPanelId).remove();
              var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
              $(params.options.opener).append(gridPropPanelDiv);
              $('#' + gridPropPanelId).myPropertiesPanel(params.options);
          } else {
              App.errorReport(gis_ppanel_42,gis_ppanel_43, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_11'});
          }
      } catch (err) {
          //Ничего не делаем, возможно панель закрыта
      }
   },
   openRoutesPanel : function(params){
      try {
          /* params = {divProperties:params.divProperties, localId:params.localId, options:{objects:[params.options.objects[params.options.curObject]], curObject:0, handlers:params.options.handlers, opener:params.options.opener}} */
          //Заново создаем панель
          if (params!==undefined && params.hasOwnProperty('divProperties') && params.hasOwnProperty('options')) {
              //Создаем панель свойств для текущего объекта
              var gridPropPanelId = params.divProperties.attr('id');
              var gridRoutePanelId = gridPropPanelId+'_routeId';

              var gridAdmIliBindToRouteForm = new GridAdmIliBindToRouteForm();
              gridAdmIliBindToRouteForm.detailedReturn = true;
              gridAdmIliBindToRouteForm.title = gis_gridadmilibindtorouteform_8;
              gridAdmIliBindToRouteForm.build(gridRoutePanelId);
              //Добавляем слушатель закрытия формы
              $("body").on(CloseEvent.CLOSE, function onGridAdmIliBindToRouteFormClose(evt/*CloseEvent*/) {
                  $("body").off(CloseEvent.CLOSE);
                  //Для этой формы в evt.detail при отмене придет -1, при ошибке выбора комбобокса придет 0 или корректное значение curRouteId в остальных случаях
                  if (evt && evt.detail != -1) {
                      if (evt.detail==0)
                          App.errorReport(gis_gridwidget_5, gis_gridadmwidget_67, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_42'});
                      else {
                          var routeObj = evt.detail;
                          //плохой хардкод, но пока не придумано, как обойти
                          if(params.options.objects !== undefined && params.options.objects.length>0){
                              var guid = params.options.objects[params.options.objects.length-1];
                              //ищем поля с трубами и километрами и устанавливаем значения
                              try{
                                  for(var i = 0; i<params.options.objects.length; i++){
                                      if(params.options.objects[i].indexOf('ROUTE_ID') != -1){
                                          $('#'+params.options.objects[i]+guid).val(routeObj.DESCR);
                                      }
                                      if(params.options.objects[i] === 'pipe'){
                                          $('#'+params.options.objects[i]+guid).val(routeObj.CODE);
                                      }
                                      if(params.options.objects[i].indexOf('km_start') != -1){
                                          $('#'+params.options.objects[i]+guid).val(routeObj['НАЧАЛЬНЫЙ_КМ']);
                                      }
                                      if(params.options.objects[i].indexOf('km_end') != -1){
                                          $('#'+params.options.objects[i]+guid).val(routeObj['КОНЕЧНЫЙ_КМ']);
                                      }
                                  }
                              }
                              catch(ex){

                              }

                          }
                      }
                  }
              });


          } else {
              App.errorReport(gis_ppanel_42,gis_ppanel_43, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_11'});
          }
      } catch (err) {
          //Ничего не делаем, возможно панель закрыта
      }
   },
   showPanelObject:function(params){
    $('#spNameObject_'+params.localId).text((params.options.curObject+1)+gis_formPanel_7+params.options.objects.length+' '+params.options.objects[params.options.curObject].label);
    //Запрашиваем форму
       methods.serverQueryNode(Services.processQueryNodeXml,
              {descrId:'SYS_PROP.xml#PROP_LIST',
               descrType:'select',
               getSchema:false,
               toElements:false,
               data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="'+params.options.objects[params.options.curObject].id.split(':')[0]+'"/></root>'},methods.parseTabsPanel,$.extend(params,{sender: 'showPanelObject', loadObject:params.options.curObject,callBack:function(){/*App.confirmDialog('Сохранено!');*/}}));
   },
   parseTabsPanel:function(xmlElement,params){
     switch(xmlElement[0].tagName)
     {
      case 'root':
       if(params.loadObject != params.options.curObject)return;
       xmlElement.children().each(function(){methods.parseTabsPanel($(this),params);});
      break;
      case 'data':
          var tabs = $('#divTabs_'+params.localId);
          if(tabs.length != 0)tabs.jqxTabs('destroy');
          $('#divContent_'+params.localId).html('<div id="divTabs_'+params.localId+'" class="noHead"><ul id="ulTabs_'+params.localId+'"></ul></div>');
          tabs = $('#divTabs_'+params.localId);
          tabs.data('activePage',0);
          $.extend(params,{tabs:tabs});
          xmlElement.children().each(function(){methods.parseTabsPanel($(this),params);});
          var activePage = tabs.data('activePage');
          tabs.jqxTabs({theme:'myCommon'}).on('selected',function(event){
              if($(event.target).jqxTabs('getContentAt',event.args.item).html() != '')return;
              var idRequest = $($('#ulTabs_'+params.localId).children()[event.args.item]).data('source');
              var fileName = '../../Public/Modules/Form/'+idRequest+'.mxml';
              methods.serverQueryNode(Services.processQueryNodeXml,
                  {
                      descrId: 'SYS_SEM.xml#GET_XML_FILE',
                      descrType: 'select',
                      data: '<root ><data FILE="' + fileName + '"/></root>'
                  },
                 methods.parseForm,$.extend(params,{selectedIndex:event.args.item,idRequest:idRequest,saveMethod:'saveTabForm'}));
          }).jqxTabs('select',activePage);
          tabs.on('selecting',function(event){
             var frmSelIndex = $(event.target).jqxTabs('selectedItem');
             var frm = $('#frm_'+params.localId+'_'+frmSelIndex);
             if(frm.length != 0) {
                 event.cancel = !frm.jqxValidator('validate');
                 //Ставим фокус на первый компонент во вкладке
                 var formFirstTabIndex = (frmSelIndex + 1)*100 + 1;
                 $('#'+frm.attr('id')+' [tabindex="'+formFirstTabIndex+'"]').focus();
             }
          });
          if(activePage == 0) {
            var idRequest = $($('#ulTabs_'+params.localId).children()[0]).data('source');
              var fileName = '../../Public/Modules/Form/'+$($('#ulTabs_'+params.localId).children()[0]).data('source')+'.mxml';
              methods.serverQueryNode(Services.processQueryNodeXml,
                  {
                      descrId: 'SYS_SEM.xml#GET_XML_FILE',
                      descrType: 'select',
                      data: '<root ><data FILE="' + fileName + '"/></root>'
                  },
                 methods.parseForm,$.extend(params,{selectedIndex:0,idRequest:idRequest,saveMethod:'saveTabForm'}));
          }
        break;
      case 'panel':
          //Если  params.options.objects[params.options.curObject].id только указано название слоя, то форма добавления
          //и необхъодимо пармить только вкладку паспорт
          var isCreateNewObject = false;
          if(params.options.objects[params.options.curObject].id.split(':').length == 1)
              isCreateNewObject = true;
          var isDefault = false;
          if((xmlElement.attr('default') != undefined)&&(xmlElement.attr('default') == 'true')){
              params.tabs.data('activePage',$(params.tabs.children()[0]).children().length);
              isDefault = true;


          }
          if(isCreateNewObject){
              if(isDefault){
                  $(params.tabs.children()[0]).append('<li data-source="'+xmlElement.attr('source')+'">'+xmlElement.attr('descr')+'</li>');
                  params.tabs.append('<div></div>');
              }
          }
          else{
              $(params.tabs.children()[0]).append('<li data-source="'+xmlElement.attr('source')+'">'+xmlElement.attr('descr')+'</li>');
              params.tabs.append('<div></div>');
          }

       break;
     }
   },
   parseForm:function(xmlElement,params){
     var element,idElement;
     var visible = xmlElement.attr('visible'), addVisibleClass = '';
     //В административных задачах мы должны видеть все параметры, которые явно не скрыты в форме (явно скрытые - у которых visible="false")
     /*
     //Если из задачи пришел options.showSystemInfo==true, показываем такие поля независимо от значения конфига (мы под админом), иначе - в зависимости от конфига
      if (params.options.showSystemInfo==false) {
      var confShowFlag = 'SHOW_SYSTEM_INFO'; //Также прячем по значению конфига
      if (visible!=undefined && visible=='{CONFIG.'+confShowFlag+'}' && App.config && (!App.config.hasOwnProperty(confShowFlag) || App.config[confShowFlag]==false)) visible='false';
      }
      */
      //Если в форме напрямую указано visible="false", полюбому скрываем даже для админов (скрытое поле для отправки в запрос)
      if((visible != undefined)&&(visible == 'false')) addVisibleClass = 'noVisible';

     //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
     var valueFromConfig = null;
     if (xmlElement.attr('text')!=undefined && xmlElement.attr('text').toUpperCase().indexOf('{CONFIG.')==0 && App.config) {
         var configProp = xmlElement.attr('text').toUpperCase().substring(8,xmlElement.attr('text').length-1);
         if (App.config.hasOwnProperty(configProp)) {
             valueFromConfig = App.config[configProp];
         }
     }
     //Обрабатываем высоту и ширину, если они указаны (в пикселях или процентах)
     var curElementHeight = xmlElement.attr('height')!=undefined && xmlElement.attr('height').indexOf('%')==-1 ? xmlElement.attr('height')+'px' : xmlElement.attr('height');
     var curElementWidth = xmlElement.attr('width')!=undefined && xmlElement.attr('width').indexOf('%')==-1 ? xmlElement.attr('width')+'px' : xmlElement.attr('width');
     //Обрабатываем соответственно названию тега текущего элемента
     switch(xmlElement[0].tagName) {
         case 'DATA_EDIT_FORM':
          if(typeof(params.selectedIndex) =='number') {
             if(params.loadObject != params.options.curObject)return;
             params.tabs.jqxTabs('setContentAt', params.selectedIndex, '<form id="frm_'+params.localId+'_'+params.selectedIndex+'" class="frmPanelTab" data-waitload="0"><div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTabContent"></div></form>');
          }
          //Если нет label у панели свойств, берем его из описания формы паспорта. Не пишем 1 из 1, когда создаем новый объект, но пишем, если получили информацию именно из 1 объекта
          if (params.selectedIndex==0) {
              var objectInArrText = '';
              var objectLabel = params.options.objects[params.options.curObject].label==undefined ? '' : params.options.objects[params.options.curObject].label;
              if (objectLabel=='' && xmlElement.attr('title')!=undefined) objectLabel = xmlElement.attr('title');
              $('#spNameObject_'+params.localId).text(objectInArrText+' '+objectLabel);
          }
          if(params.unlockCombo != undefined)
            params.divProperties.data('unlockCombo',params.unlockCombo);
          else params.divProperties.data('unlockCombo',0);
          $.extend(params,{div:methods.getDivContent(params),parentClass:'',rules:[]});
          //Устанавливаем начальный tabIndex для формы как params.selectedIndex*100 (лимит по 100 контролов в каждой вкладке)
          params.options.tabIndex = (params.selectedIndex + 1)*100;
          params.options.lastTabIndex = params.options.tabIndex+1; //Запоминаем первый в текущей форме, к нему будем прибавлять новые индексы на каждый контрол
          //Парсим остальные элементы формы
          xmlElement.children().each(function(){methods.parseForm($(this),params);});
          //Устанавливаем позицию по горизонтали посередине грида
          var panelLeftPosition = params.options.opener!=undefined>0 && $(params.options.opener).outerWidth()>$(params.divProperties).outerWidth() ? ($(params.options.opener).outerWidth()-$(params.divProperties).outerWidth())/2 : 50;
          $(params.divProperties).css({left:panelLeftPosition+'px'});
          //Ставим валидатор для текущей формы
          $('#frm_'+params.localId+'_'+params.selectedIndex).jqxValidator({
              rules:params.rules,
              animation:'none',
              onError: function (errorArr) {
                  var fullErrorText = '';
                  var errObj = {};
                  for (var j=0; j<errorArr.length; j++) {
                      var elemId = errorArr[j][0].attributes['id'].value;
                      if (!errObj.hasOwnProperty(elemId)) {
                          //Изгаляемся, чтобы получить сообщение об ошибке для контрола выбора файла - в нем нет .data('validateErrorText')
                          var curErrText = $(errorArr[j][0]).data('validateErrorText');
                          if (curErrText==undefined) {
                              for (var k=0; k<params.rules.length; k++) {
                                  if (params.rules[k].input=='#'+elemId) {
                                      curErrText = params.rules[k].message;
                                      break;
                                  }
                              }
                          }
                          if (curErrText!=undefined) {
                              fullErrorText += curErrText + '<br/>';
                              errObj[elemId] = elemId;
                              //$(errorArr[j][0]).addClass('jqx-validator-error-element'); //Добавляем класс валидированного элемента
                          }
                      }
                  }
                  var alertForm = new AlertForm();
                  //TODO ПЕРЕРАБОТАТЬ
                  alertForm.build('pPanel_'+params.localId+'_AlertForm', fullErrorText, gis_formPanel_1, AlertForm.OK);
              }
          }).data('dataProvider',params.dataProvider);
          //Если не insert - выполняем запрос на получение данных текущего объекта
          if(typeof(params.selectedIndex) =='number') {
             var prm = params.options.objects[params.options.curObject].id.split(':'),
                 db= prm[0].split('_'),
                 db_schema = db[0],
                 db_table_id = db.slice(1).join('_');
             methods.setAttrsValues(params);
             if(prm[1] != undefined) {
                    $('#frm_'+params.localId+'_'+params.selectedIndex).data('scriptType','SELECT');
                 methods.serverQueryNode(Services.processQueryNode,
                 {descrId:params.dataProvider+'#'+$($('#ulTabs_'+params.localId).children()[params.selectedIndex]).data('source'),
                  descrType:'select',
                  getSchema:false,
                  toElements:false,
                  data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data FILTER="ID='+prm[1]+
                             '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                             '" DB_SCHEMA_ID="'+db_schema+
                             '" DB_TABLE_ID="'+db_table_id+
                             '" SYS_CLASS_ID="'+prm[0]+
                             '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.parseTabValues,params);
             } else {
                    $('#frm_'+params.localId+'_'+params.selectedIndex).data('scriptType','INSERT');
                //И только в самом конце, после свойств объекта запрашиваем данные комбобоксов
                $('#divTabContent_'+params.localId+'_'+params.selectedIndex).find('[data-typecontrol="combobox"]').each(function (){
                    var element = $(this);
                    if(element.attr('dataProvider') != undefined) {
                        var comboDataProvider = new QueryDataProvider({
                            requestSource: element.attr('dataProvider'),
                            dataField: element.jqxComboBox('valueMember'),
                            labelField: element.jqxComboBox('displayMember'),
                            resultHandler: function(){
                                methods.setComboBoxDataProvider(this,{comboBox:element,divProperties:params.divProperties,localId:params.localId});
                            }
                        });
                    }
                });
                params.tabs.addClass('noHead');
                params.divProperties.data('unlockCombo',1);
                methods.unlockFormControls(params);
                $('#frm_'+params.localId+'_'+params.selectedIndex+' [tabindex="'+params.options.lastTabIndex+'"]').focus();
                params.options.btnSave.jqxButton({disabled:false});
             }
          } else {
              //Получаем списки для всплывающих popup создания новых документов (только при вставке нового)
              if (params.hasOwnProperty('action') && params.action=='insert') {
                  $('#divTabContent_' + params.localId + '_' + params.selectedIndex).find('[data-typecontrol="combobox"]').each(function () {
                      var element = $(this);
                      if(element.attr('dataProvider') != undefined) {
                          var comboDataProvider = new QueryDataProvider({
                              requestSource: element.attr('dataProvider'),
                              dataField: element.jqxComboBox('valueMember'),
                              labelField: element.jqxComboBox('displayMember'),
                              resultHandler: function(){
                                  methods.setComboBoxDataProvider(this,{comboBox:element,divProperties:params.divProperties,localId:params.localId});
                              }
                          });
                      }
                  });
              }
          }
        break;
        case 'DATA_GRID_FORM':
          if(typeof(params.selectedIndex) =='number')
            {
             if(params.loadObject != params.options.curObject)return;
             params.tabs.jqxTabs('setContentAt', params.selectedIndex, '<div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTabContent"></div>');
            }
          $.extend(params,{div:methods.getDivContent(params),
                           parentClass:'',
                           rules:[],
                           tableReadOnly:xmlElement.attr('readOnly')=='false'});
          xmlElement.children().each(function(){methods.parseForm($(this),params);});
          methods.setAttrsValues(params);
        break;
        case 'DataGridWithScript':
          $.extend(params,{dataGrid:{width:'100%',
                                     height:'100%',
                                     pageable: false,
                                     columnsresize: true,
                                     showemptyrow:false,
                                     altrows:true,
                                     selectionmode: 'singlerow',
                                     columns: [],
                                     theme:'myCommon',
                                     sortable:true,
                                     columnsmenu: false,
                                     editable:params.tableReadOnly},
                           selectScript:'',
                           source:{datatype: 'xml',
                                   datafields: [],
                                   root: 'root',
                                   record: 'data',
                                   localdata:''}});
            xmlElement.children().each(function(){methods.parseForm($(this),params);});
            var idTable = 'divTable_'+methods.getUniqueId();
            element = $('<div id="'+idTable+'" class="vBox" data-selectscript="'+params.selectScript+'"></div>');
            methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
            element.jqxGrid(params.dataGrid);
            var onGridChangeSelect = function onGridChangeSelect(event) {
                try {
                 var btnDisabled = !event || event.type!='rowselect';
                 methods.setCommentDocGridBtnDisabled(params, btnDisabled);
                } catch (e) {}
            };
            //Привязываемся к событиям смены выделения в гриде, чтобы блокировать/разблокировать кнопки
            element.on('rowselect', onGridChangeSelect);
            //Для грида комментариев добавляем слушатель события двойного клика
            var curElementId = element.parent()!=undefined && element.parent().length>0 ? element.parent().attr('id') : '';
            if (curElementId=='divCommentContent_'+params.localId+'_'+params.selectedIndex) {
                element.on('rowdoubleclick', function commentGridDblClick(event) {
                    var divContent = element.parent();
                    $('#btnEditComment_'+curElementId.replace('divCommentContent_','')).jqxButton().click();
                });
            }
            //Для грида прикрепленных документов добавляем слушатель события двойного клика
            if (curElementId=='divAddDocsContent_'+params.localId+'_'+params.selectedIndex) {
                element.on('rowdoubleclick', function docGridDblClick(event) {
                    var divContent = element.parent();
                    $('#btnOpenDoc_'+curElementId.replace('divAddDocsContent_','')).jqxButton().click();
                });
            }
            //
            params.div.data('selectscript',params.selectScript);
            var prm = params.options.objects[params.options.curObject].id.split(':'),
             db= prm[0].split('_'),
             db_schema = db[0],
             db_table_id = db.slice(1).join('_');
             methods.serverQueryString(Services.processQueryNew,
              {descrId:params.selectScript,
               descrType:'select',
               getSchema:false,
               toElements:false,
               data:'<root><data FILTER="ID='+prm[1]+
                             '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                             '" DB_SCHEMA_ID="'+db_schema+
                             '" DB_TABLE_ID="'+db_table_id+
                             '" SYS_CLASS_ID="'+prm[0]+
                             '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.setTableData,
                 $.extend({divProperties:params.divProperties,
                           source:params.source,
                           idTable:idTable,
                           localId:params.localId}));
        break;
        case 'columns':
          xmlElement.children().each(function(){methods.parseForm($(this),params);});
          var no = params.dataGrid.columns.length - params.source.datafields.length,
          col = Math.floor((100-5*no)/(xmlElement.children().length-no));
          $(params.dataGrid.columns).each(function(){if(this.width=='0%')this.width =col+'%';});
        break;
        case 'mx:DataGridColumn':
          var fieldName = xmlElement.attr('dataField');
          if(fieldName != undefined)
            {
             params.dataGrid.columns.push({text: xmlElement.attr('headerText'),datafield: fieldName,width:'0%'});
             params.source.datafields.push({name: fieldName, map: '['+fieldName+']'});
            }
          else
            params.dataGrid.columns.push({text: xmlElement.attr('headerText'),datafield: "", columntype: 'number',width:'5%'});
        break;
        case 'selectScript':params.selectScript=xmlElement.text();break;
        case 'dataProvider':$.extend(params,{dataProvider:xmlElement.text()});break;
        case 'mx:VBox':
          element = $('<div class="vBox '+addVisibleClass+'"></div>');
          if (curElementHeight!=undefined) element.css('height',curElementHeight);
          if (curElementWidth!=undefined && curElementWidth!='50%') element.css('width',curElementWidth); // curElementWidth!='50%' - чтобы растровые бланки не сжимались внутри ячейки
          methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
          var oldValues = {div:params.div,oldParentClass:params.parentClass};
          params.div = element;
          params.parentClass = '';
          xmlElement.children().each(function(){methods.parseForm($(this),params)});
          params.parentClass = oldValues.oldParentClass;
          params.div = oldValues.div;
        break;
        case 'mx:HBox':
           element = $('<div class="pPanelTable '+addVisibleClass+'"><div class="pPanelTableRow"></div></div>');
           if (curElementHeight!=undefined) element.css('height',curElementHeight);
           if (curElementWidth!=undefined && curElementWidth!='50%') element.css('width',curElementWidth); // curElementWidth!='50%' - чтобы растровые бланки не сжимались внутри ячейки
           methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
           var oldValues = {div:params.div,oldParentClass:params.parentClass};
           params.div = $(element.children()[0]);
           params.parentClass = 'pPanelTableCell';
           xmlElement.children().each(function(){methods.parseForm($(this),params)});
           params.parentClass = oldValues.oldParentClass;
           params.div = oldValues.div;
        break;
        case 'mx:HRule':
           element = $('<hr/>');
           methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
        break;
        case 'mx:TextInput':
           idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
           params.options.tabIndex++;
           var inputType = xmlElement.attr('displayAsPassword') !== undefined && xmlElement.attr('displayAsPassword') === 'true' ? 'password' : 'text';
           element = $('<input id="'+idElement+'" type="'+inputType+'" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
           if (curElementHeight !== undefined) {
               //Обрабатываем случай, если высота > 30, то считаем что нам нужен textArea для отображения в нескольких строках
               if (parseFloat(xmlElement.attr('height'))>30) element = $('<textArea id="'+idElement+'" type="text" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
               element.css('height',curElementHeight);
           }
           if (curElementWidth !== undefined) element.css('width',curElementWidth);
           var disabledInput = false;
           var editableClass = '';
           if(xmlElement.attr('disabled') !== undefined && xmlElement.attr('disabled') === 'true'){
               disabledInput = true;
               editableClass = 'noEditable';
           }

           methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
           element.jqxInput({disabled:disabledInput,theme:'myCommon'}).on('keyup',function(){methods.markChange($.extend(params,{control:$(this)}));});

           methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
           //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
           if (valueFromConfig!=null) element.val(valueFromConfig);
        break;
        case 'mx:Text':
           var id = '',text = '&nbsp;';
           if(xmlElement.attr('text') !== undefined)text = xmlElement.attr('text');
           if(xmlElement.attr('id') !== undefined)id = ' id="'+methods.getIdControl({xmlElement:xmlElement,params:params})+'"';
           methods.appendFormElement({params:params,element:$('<span'+id+' data-typecontrol="label" class="'+addVisibleClass+'">'+text+'</span>'),xmlElement:xmlElement[0]});
        break;
        case 'mx:ComboBox':
           idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
           params.options.tabIndex++;
           element = $('<div id="'+idElement+'" class="noListValues formControl '+methods.checkEditable(xmlElement)+' '+addVisibleClass+'" data-typecontrol="combobox" data-loadvalue=false tabindex="'+params.options.tabIndex+'"></div>');
           methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
           var curComboHeight = curElementHeight!=undefined ? parseFloat(xmlElement.attr('height'))-2 : 16;
           var curComboWidth = curElementWidth!=undefined ? parseFloat(xmlElement.attr('width')) : '100%';
           var placeHolder = xmlElement.attr('hint')!=undefined ? xmlElement.attr('hint') : '';
           var valueMember = xmlElement.attr('valueMember')!=undefined ? xmlElement.attr('valueMember') : 'CODE';
           var displayMember = xmlElement.attr('displayMember')!=undefined ? xmlElement.attr('displayMember') : 'DESCR';
           element.jqxComboBox({valueMember:valueMember,displayMember:displayMember,width:curComboWidth,disabled:true,height:curComboHeight,dropDownHeight:130,dropDownWidth:curComboWidth,placeHolder:placeHolder,theme:'myCommon', searchMode: 'containsignorecase', autoComplete: true}).on('change',function(){
               if ($(this).hasClass('noListValues')==false)
                   methods.markChange($.extend(params,{control:$(this)}));
           });
           if(xmlElement.attr('dataProvider') != undefined)
                element.attr('dataProvider',xmlElement.attr('dataProvider'));
               xmlElement.children().each(function(){methods.parseForm($(this),{options:params.options, comboBox:element});});
           //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
           if (valueFromConfig!=null) element.val(valueFromConfig);
        break;
        case 'mx:dataProvider':
           var selectedIndex = -1;
           var comboDataProv = [];
           xmlElement.children().each(function(){
               var curObj = { DESCR: $(this).attr('DESCR'), CODE: $(this).attr('CODE')};
               comboDataProv.push(curObj);
           });
           var disabledCombo = params.comboBox.hasClass('noEditable');
           var autoDropDownHeight = comboDataProv.length<=5 ? true : false; //При наличии в списках 5 и менее элементов нужно dropdown сжимать по их количеству
           //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
           if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1) selectedIndex = 0;
           params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo, selectedIndex: selectedIndex, autoDropDownHeight:autoDropDownHeight, searchMode: 'containsignorecase', autoComplete: true});
           params.comboBox.removeClass('noListValues');
           break;
        case 'mx:Button':
           idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
           element = $('<button id="'+idElement+'"></button>');
           //По атрибуту styleName разделяем обычные кнопки и кнопки-иконки
           if(xmlElement.attr('styleName') !== undefined){
               var refButtonText = '';
               if(xmlElement.attr('styleName') === 'refButton' && xmlElement.attr('label') !== undefined )
                   refButtonText = xmlElement.attr('label');
               element = $('<div id="'+idElement+'" class="divIconButton '+xmlElement.attr('styleName')+'Icon refButtonText '+addVisibleClass+'">'+refButtonText+'</div>');
           }
           else {
               var btnLabel = xmlElement.attr('label') !== undefined ? xmlElement.attr('label') : '';
               element = $('<button id="'+idElement+'" class="myButton '+addVisibleClass+'">'+btnLabel+'</button>');
           }
           if (curElementHeight!=undefined) element.css('height',curElementHeight);
           if (curElementWidth!=undefined) element.css('width',curElementWidth);
           element.attr('selectedField',xmlElement.attr('selectedField')!=undefined ? xmlElement.attr('selectedField') : '');
           element.attr('btnStyleName',xmlElement.attr('styleName')!=undefined ? xmlElement.attr('styleName') : '');
           methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
           element.jqxButton({theme:'myCommon', disabled: methods.checkEditable(xmlElement)=='noEditable'});
           element.on('click', {elemId:idElement}, function goToLinkedObject(evt) {
                evt.preventDefault();
                var clickBtn = $('#'+evt.data.elemId);
                var selectedField = clickBtn.attr('selectedField');
                if (selectedField!='') {
                    //Получаем связанный с кнопкой объект
                    var idStr = clickBtn.attr('id');
                    var linkObj, linkList;
                    //Не привязываем кнопку к списку, если мы создаем новую запись.

                    if (idStr.substr(0,7) === "BUTTON_" && !params.options.creatingNewObject)
                        linkObj = $('#'+idStr.substring(7));
                    else if (idStr.substr(0,9) === "BTN_LIST_")
                        linkObj = $('#'+idStr.substring(9));
                    else if (idStr.substr(0,9) === "BTN_FILE_" && !params.options.creatingNewObject) //Кнопка перехода к файлу активна только если не создаем запись и есть имя файла
                        linkObj = $('#'+idStr.substring(9));
                    else if (idStr.substr(0,12) === "BUTTONGROUP_"){//группа кнопок. Пример импорта ВТД, чтобы заполнялись трубопровод и километры
                        linkList = [];
                        var inputs = idStr.substring(12).split('__');
                        for(var j=0;j<inputs.length; j++){
                            linkList.push(inputs[j]);
                        }

                    }

                    //очищаем btn.data, чтобы если значения в поле нет, не осуществлять переход
                    var btnData = null;
                    var typeControl = '';
                    if (linkObj !== undefined && linkObj.length > 0) {
                        typeControl = linkObj.data('typecontrol');
                        if (typeControl=='combobox' && linkObj.jqxComboBox('getSelectedItem')!=null)
                            btnData = selectedField+"/"+linkObj.jqxComboBox('getSelectedItem')['CODE'];
                        else if (typeControl=='input' && linkObj.val()!='')
                            btnData = selectedField+"/"+linkObj.val();
                        //если переходим к файлу, в btnData устанавливаем путь к файлу
                        else if (typeControl=='inputfile' && linkObj.attr('value')!='') {
                            if (App.config.DATA_PATH === undefined){
                                App.errorReport(gis_core_17, 'DATA_PATH' + gis_core_18, undefined, {filename:gis_filename_560, functionname:'gis_filename_560_5'});
                                return;
                            }
                            btnData = App.config['DATA_PATH'] + linkObj.data('uploadpath') + linkObj.attr('value');
                            btnData = btnData.replace(/\\/g,"/");
                        }
                    }
                    //По нажатию на кнопку может осуществляться: переход к значению из comboBox,
                    //редактирование справочника либо открытие файла
                    //Не переходим по кнопке к файлу, если мы создаем новую запись.
                    if (clickBtn.attr('id').substr(0,9)=="BTN_FILE_" && (typeControl=='inputfile' || typeControl=='input') && !params.options.creatingNewObject && btnData) {
                        var addIdStr = '_'+params.localId+'_'+params.selectedIndex;
                        //Для открытия 3D-сцены или IMG-карты проверяем тип прикрепленного документа
                        var docTypeId = $('#DOC_TYPE_ID'+addIdStr).length>0 ? $('#DOC_TYPE_ID'+addIdStr).val() : '';
                        if (docTypeId!='' && ($('#DOC_VERSION_ID'+addIdStr).length>0 || $('#DOC_ID'+addIdStr).length>0) && (docTypeId=="37" || docTypeId=="38" || docTypeId=="41")) {
                            var docObj = {};
                            docObj.DOC_ID = $('#DOC_VERSION_ID'+addIdStr).length>0 ? $('#DOC_VERSION_ID'+addIdStr).val() : $('#DOC_ID'+addIdStr).val();
                            docObj.FILE_NAME = linkObj.val(); /*(linkObj is FileInput) ? (linkObj as FileInput).fileLoading.text : (linkObj as TextInput).text;*/
                            switch (docTypeId) {
                                case "37":	//3Dсцена
                                    ExportUtil.exportToWRL(docObj.DOC_ID, docObj.FILE_NAME);
                                    break;
                                case "38":	//IMG-карта
                                    ExportUtil.exportToIMG(docObj.DOC_ID, docObj.FILE_NAME);
                                    break;
                                case "41":	//Видеофайл
                                    var rowDataObj = {};
                                    rowDataObj.ID = docObj.DOC_ID;
                                    rowDataObj.FILE_NAME = docObj.FILE_NAME;
                                    showVideo(docObj.DOC_ID, docObj.FILE_NAME, $('#NAME'+addIdStr).length>0 ? $('#NAME'+addIdStr).val() : gis_formPanel_8);
                                    //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                    widgetMoveWindowToPosition('grid');
                                    break;
                            }
                        } else {
                            //Если документ не является ни 3D-сценой, ни IMG-картой, ни видеофайлом - открываем его
                            window.open(pPanelOpenDocPath + btnData,'_blank');
                        }
                    } else if (clickBtn.attr('btnStyleName')=="refList" && typeControl=='combobox') {
                        //В selectedField "ИМЯ_ФАЙЛА#ИДЕНТИФИКАТОР_ИСТОЧНИКА".
                        //Точно разделить значение схемы и таблицы невозможно, поэтому считаем что в названии схемы нет символа "_"
                        var dirForm = new DirectoryEditForm({requestSQL:selectedField,
                            source:linkObj[0].getAttribute('dataProvider').split('#')[0],
                            requestSource:linkObj[0].getAttribute('dataProvider')
                        });
                        dirForm.build();
                        /*showDirectoryEditForm(btn.selectedField, (linkObj as ComboBox).id);*/
                    } else if (clickBtn.attr('btnStyleName')=="refObject" && !params.options.creatingNewObject && btnData) {
                        //переходим по кнопке к объекту
                        var linkedObjParams = {
                            divProperties:params.divProperties,
                            localId:params.localId,
                            options:{objects:[{id:btnData.replace('/',':')}], curObject:0, handlers:params.options.handlers, opener:params.options.opener}
                        };
                        methods.openObjectInNewPanel(linkedObjParams);
                    }
                    else if (clickBtn.attr('btnStyleName')=="refButton" && !params.options.creatingNewObject) {
                        //переходим по кнопке к объекту
                        var linkedObjParams = {
                            divProperties:params.divProperties,
                            localId:params.localId,
                            options: {
                                objects: linkList,
                                curObject: 0,
                                handlers: params.options.handlers,
                                opener: params.options.opener
                            }
                        };
                        methods.openRoutesPanel(linkedObjParams);
                    }
                }
             });
        break;
        case 'mx:CheckBox':
          idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
          //params.options.tabIndex++;
          element = $('<div id="'+idElement+'" data-typecontrol="checkbox" class="formControl myCheckBox '+methods.checkEditable(xmlElement)+' '+addVisibleClass+'" data-loadvalue=false ></div>');
          if (curElementHeight!=undefined) element.css('height',curElementHeight);
          if (curElementWidth!=undefined) element.css('width',curElementWidth);
          methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
          var isChecked = xmlElement.attr('selected')=="true" ? true : false;
          element.jqxCheckBox({disabled:true,checked:isChecked,theme:'myCommon'}).on('change',function(){methods.markChange($.extend(params,{control:$(this)}));});
        break;
        case 'mx:DateField':
          idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
          element = $('<div id="'+idElement+'" data-typecontrol="date" class="formControl '+methods.checkEditable(xmlElement)+' '+addVisibleClass+'" data-loadvalue=false></div>');
          methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
          var curDateFieldFormat = xmlElement.attr('formatString').replace(/D/g,'d').replace(/Y/g,'y');
          var curDateFieldHeight = curElementHeight!=undefined ? parseFloat(xmlElement.attr('height')) : 16;
          var curDateFieldWidth = curElementWidth!=undefined ? parseFloat(xmlElement.attr('width')) : '100%';
          element.jqxDateTimeInput({theme:'myCommon',value:null,formatString:curDateFieldFormat,disabled:true,width:curDateFieldWidth,height:curDateFieldHeight,culture:'ru-RU'}).on('change',function(){
              methods.markChange($.extend(params,{control:$(this)}));
          });
          params.options.tabIndex++;
          $('#'+idElement+' .jqx-input-content').attr('tabindex', params.options.tabIndex);
        break;
        case 'controls:NumberInput':
          idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
          params.options.tabIndex++;
          element = $('<input id="'+idElement+'" type="text" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
          if (curElementHeight!=undefined) element.css('height',curElementHeight);
          if (curElementWidth!=undefined) element.css('width',curElementWidth);
          methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
          element.jqxInput({disabled:false,theme:'myCommon'}).on('keyup',function(){methods.markChange($.extend(params,{control:$(this)}));});
          methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
          params.rules.push({
                        input: '#'+idElement,
                        message: gis_formPanel_9,
                        action: 'none',
                        rule: function(){var val = $('#'+idElement).val();
                                         if(val != '')return /^[+-]?\d*(\.\d+)?$/.test(val);
                                         else return true;},
                          hintRender:function(message, input){
                              if (input.length > 0) $(input[0]).data('validateErrorText',message);
                          }

          });
          //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
          if (valueFromConfig!=null) element.val(valueFromConfig);
        break;
        case 'validatorsArray':
            xmlElement.children().each(function(){methods.parseForm($(this),params);});
        break;
        case 'controls:DefaultEmailValidator':
         idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
         if($('#'+idElement).length == 0)return;
          params.rules.push({
                        input: '#'+idElement,
                        message: gis_formPanel_10,
                        action: 'none',
                        rule: 'email',
                        hintRender:function(message, input){
                            if (input.length > 0) $(input[0]).data('validateErrorText',message);
                        }
          });
        break;
        case 'controls:DefaultDateValidator':
        case 'controls:DefaultStringValidator':
        case 'controls:DefaultNumberValidator':
          idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
          if($('#'+idElement).length == 0)return;
          methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
        break;
        case 'controls:DefaultComboBoxValidator':
        case 'controls:ComboBoxValidator':
          idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
          if($('#'+idElement).length == 0)return;
          if(xmlElement.attr('required') == 'true'){
             xmlElement.attr('required','false');
             xmlElement.attr('requiredcombo','true');
          }
          methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
        break;
        case 'controls:FieldComparisonValidator':
          idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
          if($('#'+idElement).length == 0)return;
          methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
        break;
        case 'controls:FileInput':
          idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
          var accept = '';
            if(xmlElement.attr('fileFilterExtension') != undefined)accept = ' accept="'+xmlElement.attr('fileFilterExtension').replace(/\*/g,'')+'"';
            element = $('<input id="'+idElement+'" type="hidden" value="" data-typecontrol="inputfile" class="formControl" data-loadvalue=true data-uploadpath="'+xmlElement.attr('uploadPath')+'"/>\
                       <div id="divFI_'+idElement+'" class="divFileInput">\
                        <div class="divFileInputName"></div>\
                        <form method="POST" id="fr_'+idElement+'" action="" data-action="./api/files/upload?path='+
                xmlElement.attr('uploadPath')+'" enctype="multipart/form-data" class="frmInputFile" target="ifr_'+idElement+'">\
                         <input id="iFI_'+idElement+'" type="file" data-typecontrol="file" data-filename="" class="iFileInput" name="fileinput" '+accept+'/>\
                        </form>\
                        <iframe id="ifr_'+idElement+'" name="ifr_'+idElement+'" class="noVisible ifDocForm" data-checkload=false></iframe>\
                       </div>');
          if (!isNaN(curElementHeight)) element.height(curElementHeight);
          if (!isNaN(curElementWidth)) element.width(curElementWidth);
          methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
          $('#ifr_'+idElement).load(function(){methods.uploadComplete($.extend(params,{iframe:this,indexForm:params.selectedIndex}));});
          //Если есть атрибут saveOriginalFileName='true' не добавляем в конец файла uid
          var saveOriginalFileName = xmlElement.attr('saveOriginalFileName')=='true';
          $('#iFI_'+idElement).change(function(){
              try {
                  var fileName = $(this).val().split('\\');
                  var changedElement = $('#'+this.id.replace('iFI_',''));
                  //Не сохраняем оригинальное имя если false
                  if (saveOriginalFileName==false) {
                      if(fileName.length != 1)fileName = fileName[fileName.length-1].split('.');
                      else fileName = fileName[0].split('.');
                      fileName[fileName.length-2] = fileName[fileName.length-2]+'-'+methods.getUniqueId();
                      fileName = fileName.join('.');
                  } else {
                      fileName = fileName[fileName.length-1];
                  }
                  $(this).data('filename',fileName);
                  changedElement.val(fileName);
                  changedElement.trigger('change');
              } catch (err) {
                  //Ничего не делаем, возможно панель закрыта
              }
          });
          $('#'+idElement).change(function(){
              $('#divFI_'+idElement+' .divFileInputName').html($(this).val());
              if(!$('#divFI_'+idElement).hasClass('waitLoad'))
                {
                 $('#divFI_'+idElement).addClass('waitLoad');
                 var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                 frm.data('waitload',Number(frm.data('waitload'))+1);
                }
              methods.markChange(params);
          });
        break;
        default:
         //console.log('Unknown tag!!!!!  ',xmlElement[0].tagName);
        break;
       }
   },
   setCommentDocGridBtnDisabled:function(params, btnDisabled){
       try {
           //Для комментариев
           $("button[id^='btnDeleteComment_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
           $("button[id^='btnEditComment_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
           //Для документов
           $("button[id^='btnOpenDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
           $("button[id^='btnDeleteDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
           $("button[id^='btnEditDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
       } catch(e) {}
   },
   checkEditable:function(xmlElement){
     var addClass = '',
         editable = true,/*xmlElement.attr('editable'),*/
         enabled = true, /*xmlElement.attr('enabled');*/
         disabled = xmlElement.attr('disabled') !== undefined && xmlElement.attr('disabled')!=null && xmlElement.attr('disabled') === 'true';
     if((editable !== undefined && editable === 'false') || (enabled !==undefined && enabled === 'false') || disabled==true) addClass = 'noEditable';
     return addClass;
   },
   getIdControl:function(params){
    return params.xmlElement.attr('id')+'_'+params.params.localId+'_'+params.params.selectedIndex;
   },
   appendFormElement:function(params){
     try {
        if(params.params.parentClass == 'pPanelTableCell')
            params.params.div.append(methods.tabelCellElement({element:params.element,xmlElement:params.xmlElement}))
            .append('<div class="pPanelTableCell pPanelTableCellRight">&nbsp;</div>');
        else {
            methods.setStyleElement({xmlElement:params.xmlElement,element:params.element});
            params.params.div.append(params.element);
        }
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
    },
   tabelCellElement: function(params){
     try {
        var tableCell = $('<div class="pPanelTableCell"></div>');
        methods.setStyleElement({xmlElement:params.xmlElement,element:tableCell});
        tableCell.append(params.element);
        return tableCell;
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   setValidateElement:function(params){
     try {
    $.each(params.xmlElement.attributes,function(){
       var value = this.value;
           switch(this.name) {
              case 'maxChars':
                  params.params.rules.push({
                        input: '#'+params.idElement,
                        message: gis_formPanel_11,
                        action: 'none',
                    rule: 'maxLength='+this.value,
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
          break;
          case 'minLength':
                        params.params.rules.push({
                        input: '#'+params.idElement,
                        message: params.xmlElement.getAttribute('tooShortError'),
                        action: 'none',
                    rule: 'minLength='+this.value,
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
          break;
              case 'requiredFieldError':
              /*case 'required':*/
                  if(params.xmlElement.getAttribute('required')!='false'){
                      //Для контрола ввода файла отдельное правило - проверяем текст внутреннего div'а
                      if ($('#'+params.idElement).data('typecontrol')=='inputfile') {
                          params.params.rules.push({
                              input: '#'+params.idElement,
                              message: params.xmlElement.getAttribute('requiredFieldError'),
                              action: 'none',
                              rule: function(){
                                  try {
                                      var curFileName = $('#'+params.idElement).parent().find('.divFileInputName').html();
                                      return curFileName!='';
                                  } catch (e) {
                                      return false;
                                  }
                              }
                          });
                      } else {
                          params.params.rules.push({
                              input: '#'+params.idElement,
                              message: params.xmlElement.getAttribute('requiredFieldError'),
                              action: 'none',
                              rule: 'required',
                              hintRender:function(message, input){
                                  if (input.length > 0) $(input[0]).data('validateErrorText',message);
                              }
                          });
                      }
                  }
         break;
         case 'requiredcombo':
                    params.params.rules.push({
                        input: '#'+params.idElement+' input',
                        message: params.xmlElement.getAttribute('notDefaultError'),
                        action: 'none',
                        rule: function(){
                            var index = $('#'+params.idElement).jqxComboBox('getSelectedIndex');
                        return index != -1;
                    },
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
         break;
         case 'comparisonError':
              params.params.rules.push({
                input: '#'+params.idElement,
                message: params.xmlElement.getAttribute('comparisonError'),
                action: 'none',
                rule: function(){
                    try {
                        var destinationId = params.xmlElement.getAttribute('destination');
                        destinationId = destinationId.substring(1, destinationId.length-1)+'_'+params.params.localId+'_'+params.params.selectedIndex;
                        return $('#'+params.idElement).val()==$('#'+destinationId).val();
                    } catch (err) {}
                    return false;
                },
                hintRender:function(message, input){
                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                }
              });
         break;
         case 'allowNegative':
           if(this.value == 'false')
                    params.params.rules.push({
                        input: '#'+params.idElement,
                        message: params.xmlElement.getAttribute('negativeError'),
                        action: 'none',
                        rule: function(){
                          var val = $('#'+params.idElement).val();
                          if(val != '')return /^[+]?\d*(\.\d+)?$/.test(val);
                      else return true;
                    },
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
         break;
         case 'precision':
              params.params.rules.push({
                input: '#'+params.idElement,
                message: params.xmlElement.getAttribute('precisionError'),
                action: 'none',
                rule: function(){
                    var val = $('#'+params.idElement).val().toString().split('.');
                    if(val.length >1)return val[1].length <= value;
                        else return true;
                    },
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
        break;
        case 'maxValue':
              params.params.rules.push({
                input: '#'+params.idElement,
                message: params.xmlElement.getAttribute('exceedsMaxError'),
                action: 'none',
                rule: function(){
                    var val = $('#'+params.idElement).val();
                    if(val.length >1)return parseFloat(val) <= parseFloat(value);
                        else return true;
                    },
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
            break;
        case 'minValue':
              params.params.rules.push({
                input: '#'+params.idElement,
                message: params.xmlElement.getAttribute('lowerThanMinError'),
                action: 'none',
                rule: function(){
                    var val = $('#'+params.idElement).val();
                    if(val.length >1)return parseFloat(val) >= parseFloat(value);
                        else return true;
                    },
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
            break;
        case 'notAllowedValues':
          if($('#'+params.idElement).data('typecontrol') == 'combobox')
              params.params.rules.push({
                input: '#'+params.idElement+' input',
                message: params.xmlElement.getAttribute('notAllowedError'),
                action: 'none',
                rule: function(){
                    var val = $('#'+params.idElement).val(),
                        values = value.split(',');
                    for(var i = 0;i<values.length;i++)
                    if(values[i]== val)return false;
                        return true;
                    },
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
          else
              params.params.rules.push({
                input: '#'+params.idElement,
                message: params.xmlElement.getAttribute('notAllowedError'),
                action: 'none',
                rule: function(){
                    var val = $('#'+params.idElement).val(),
                        values = value.split(',');
                    for(var i = 0;i<values.length;i++)
                    if(values[i]== val)return false;
                        return true;
                    },
                    hintRender:function(message, input){
                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                    }
                  });
        break;
        case 'defaultValue':
        case 'text':
           var control = $('#'+params.idElement);
           switch(control.data('typecontrol')) {
              case 'input':if(control.data('loadvalue') == false)control.val(value);break;
              case 'checkbox':if((control.data('loadvalue') == false)&&(this.value == 'Y'))control.jqxCheckBox('check');break;
              case 'date':
                 if(control.data('loadvalue') == false)
                   {
                    if(value == 'new Date()')
                      control.jqxDateTimeInput('setDate',new Date());
                    else
                     {
                      var dt = value.split('.');
                      if(dt.length == 3)
                        control.jqxDateTimeInput('setDate',new Date(dt[2], dt[1]-1,dt[0]));
                     }
                   }
              break;
              case 'combobox':
               if(control.data('loadvalue') == false)
                  control.data('value',value);
               else control.jqxComboBox('val',value);
              break;
           }
           break;
         }
       });
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   setStyleElement:function(params){
     try {
        $.each(params.xmlElement.attributes,function(){
           switch(this.name)
             {
              case 'width':params.element.css('width',this.value+'px');break;
              case 'percentWidth':if(this.value != '100')params.element.css('width',this.value+'%');break;
              case 'textAlign':params.element.addClass(this.value+'TextAlign');break;
             }
           });
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
  setComboBoxDataProvider:function(comboDataProv,params){
      if(params.comboBox==undefined || $('#'+params.comboBox.attr('id')).length == 0)return;
      var selectedIndex = -1;
      var disabledCombo = params.comboBox.hasClass('noEditable');
      var comboDataValue = params.comboBox!=undefined && params.comboBox.data('value');
      var comboDataValueField = params.comboBox.jqxComboBox('valueMember');
      for (var i=0; i<comboDataProv.length; i++) {
          var curObj = comboDataProv[i];
          //Сразу ищем элемент, данные уже есть
          if (comboDataValue!=undefined && curObj[comboDataValueField]==comboDataValue) selectedIndex = i;
      }
      params.comboBox.removeClass('noListValues');
      var autoDropDownHeight = comboDataProv.length<=5 ? true : false; //При наличии в списках 5 и менее элементов нужно dropdown сжимать по их количеству
      //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
      if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1 && params.comboBox.jqxComboBox('placeHolder')=='') selectedIndex = 0;
      if(params.comboBox.data('value') != undefined) {
          params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo,selectedIndex:selectedIndex,autoDropDownHeight:autoDropDownHeight, autoComplete: true});
          params.comboBox.data('loadvalue',true);
      } else {
          disabledCombo = params.divProperties.data('unlockCombo')!=1;
          params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo,selectedIndex:selectedIndex,autoDropDownHeight:autoDropDownHeight, searchMode: 'containsignorecase', autoComplete: true});
          params.comboBox.data('loadvalue',true);
      }
      params.comboBox.jqxComboBox({disabled:false});
  },
  parseTabValues:function(xmlElement,params){
    switch(xmlElement[0].tagName)
    {
     case 'string':
         xmlElement.children().each(function(){methods.parseTabValues($(this),params);});
         break;
     case 'root':
      if(params.loadObject != params.options.curObject)return;
      xmlElement.children().each(function(){methods.parseTabValues($(this),params);});
      methods.unlockFormControls(params);
      var formFirstTabIndex = (params.selectedIndex + 1)*100 + 1;
      $('#frm_'+params.localId+'_'+params.selectedIndex+' [tabindex="'+formFirstTabIndex+'"]').focus();
      //И только в самом конце, после свойств объекта запрашиваем данные комбобоксов
      $('#divTabContent_'+params.localId+'_'+params.selectedIndex).find('[data-typecontrol="combobox"]').each(function (){
          var element = $(this);
          if(element.attr('dataProvider') != undefined) {
              var comboDataProvider = new QueryDataProvider({
                  requestSource: element.attr('dataProvider'),
                  dataField: element.jqxComboBox('valueMember'),
                  labelField: element.jqxComboBox('displayMember'),
                  resultHandler: function(){
                      methods.setComboBoxDataProvider(this,{comboBox:element,divProperties:params.divProperties,localId:params.localId});
                  }
              });
          }
      });
     break;
     case 'data':
      $.each(xmlElement[0].attributes,function(){
       var control = $('#'+this.name+'_'+params.localId+'_'+params.selectedIndex);
       if(control.length != 0) {
          if(control.hasClass('noListValues'))
            control.data('value',this.value);
          else methods.setControlValue(control,this);
       } else
        $('#frm_'+params.localId+'_'+params.selectedIndex).append(
         '<input id="'+this.name+'_'+params.localId+'_'+params.selectedIndex+'" type="hidden" value="'+this.value+'" data-typecontrol="input" class="formControl" data-loadvalue=true />');
      });
      if(xmlElement[0].attributes.length == 1)
        {
         params.options.objects[params.options.curObject].id=params.options.objects[params.options.curObject].id+':'+xmlElement[0].attributes[0].value;
         methods.showPanelObject(params);
        }
     break;
    }
   },
   setControlValue:function(control,data){
     try {
      switch(control.data('typecontrol')) {
          case 'label': control.html(data.value); break;
          case 'input': control.val(data.value); control.data('loadvalue',true); break;
          case 'checkbox': if (data.value == 'Y'){ control.jqxCheckBox('check'); control.data('loadvalue',true); } break;
          case 'combobox':
           //Если у нас уже есть провайдер комбобокса (например dataProvider задан прямо в форме) - устанавливаем значение
           var comboDataProv = control.jqxComboBox('source');
           if (comboDataProv && comboDataProv.length > 0) {
               var selectedIndex = -1;
               var comboValueMember = control.jqxComboBox('valueMember');
               for (var i = 0; i < comboDataProv.length; i++) {
                   if (comboDataProv[i][comboValueMember]==data.value) {
                       selectedIndex = i;
                       break;
                   }
               }
               //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
               if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1 && control.jqxComboBox('placeHolder')=='') selectedIndex = 0;
               //Если не нашли такого значения в провайдере - ставим selectedIndex==-1, т.е. ничего не выбрано
               control.jqxComboBox({selectedIndex: selectedIndex});
           } else {
               //иначе данные для комбобоксов получаем после данных формы, поэтому включаем в атрибут value пришедшее из запроса значение (оно будет искаться после запроса комбобокса там)
               control.data('value',data.value);
           }
           control.data('loadvalue',true);
          break;
          case 'date':control.jqxDateTimeInput('setDate',new Date(data.value)); control.data('loadvalue',true); break;
          case 'inputfile':
              control.val(data.value);
              $('#divFI_'+control.attr('id')+' .divFileInputName').html(data.value);
              control.data('loadvalue',true);
              break;
      }
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   checkSave: function(params){
    var listForms = $('#divContent_'+params.localId+' .frmPanelTab'),
        count = listForms.length;
    if (count != 0) {
       for (var i = 0;i<count;i++) {
           var fullErrorText = '';
           var curForm = $(listForms[i]);
           var labelElements = curForm.find('.pPanelTableRow div.rightTextAlign:first-child span[data-typecontrol="label"]');
           //Получаем комбобоксы и проверяем, выбрано ли в них значение, иначе в БД может передаваться подстрока из поля поиска в списке.
           curForm.find('[data-typecontrol="combobox"]').each(function(){
               var selectedIndex = $(this).jqxComboBox('getSelectedIndex');
               if (selectedIndex==-1) {
                   var labelText = '';
                   for (var j=0; j<labelElements.length; j++) {
                       var curLabelElem = $(labelElements[j]);
                       var findComboInLabels = curLabelElem.parent().parent().find('[id="'+this.id+'"]');
                       if (findComboInLabels.length>0) {
                           labelText = "'"+curLabelElem.text() + "' ";
                           break;
                       }
                   }
                   fullErrorText += gis_formPanel_12+labelText+gis_formPanel_13 + '<br/>';
               }
           });
           if (fullErrorText!='') {
              var alertForm = new AlertForm();
              alertForm.build('pPanel_'+params.localId+'_AlertForm', fullErrorText+gis_formPanel_14 , gis_formPanel_1, AlertForm.OK);
              return true;
           }
           if (curForm.jqxValidator('validate')==false) {
              $('#divTabs_'+params.localId).jqxTabs('select',i);
              curForm.jqxValidator('hide'); //Сразу прячем (при этом они останутся в DOM и мы сможем получить их текст)*/
              return true;
             }
        }
        for (var j=0; j<count; j++) {
            methods.saveFormNew($.extend(params,{indexForm:j,saveMethod:'saveTabForm'}));
            $(listForms[j]).removeClass('frmChanged');
        }
        params.checkSave = false;
       return false;
      }
    return true;
   },
   getAllFormsObjects:function(localId){ //Получение массива объектов со всех вкладок
     try {
       var resultArray = [];
       var listForms = $('#divContent_'+localId+' .frmPanelTab');
       for(var i = 0; i<listForms.length; i++) {
           var curObject = methods.getCurrentFormObject('frm_'+localId+'_'+i);
           if (curObject) resultArray.push(curObject);
       }
       return resultArray;
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   getCurrentFormObject:function(frmId){ //Получение объекта со свойствами из одной вкладки
     try {
        var dataObj = {};
        $('#'+frmId+' .formControl').each(function(){
          var el = $(this),
          value = '',
          id = this.id.split('_');
          id.splice(id.length-2,2);
          switch(el.data('typecontrol'))
            {
             case 'input':value=el.val();break;
             case 'checkbox':if(el.jqxCheckBox('checked'))value='Y';else value='N';break;
             case 'combobox':if(el.jqxComboBox('selectedIndex') == -1)
                              {
                               if(el.data('loadvalue')== true)value='NULL';
                               else id = undefined;
                              }
                              else {
                                 value=el.jqxComboBox('val');
                                 dataObj[id.join('_')+"_LABEL"] = el.jqxComboBox('getSelectedItem').label;
                             }
               break;
             case 'date':value=el.jqxDateTimeInput('getDate');
                        if(value == null)id = undefined;
                        else value = value.getDate()+'.'+(value.getMonth()+1)+'.'+value.getFullYear();
               break;
             case 'file':value=el.data('filename');
               break;
             case 'inputfile':value=el.prop('value');//Это для получения значения из контрола выбора файла
               break;
            }
         if(id != undefined)
             dataObj[id.join('_')] = value;
        });
        return dataObj;
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   serializeForm:function(frmId){
     try {
        var dataXML = '';
        var scriptType = $('#'+frmId).data('scriptType');
        $('#'+frmId+' .formControl').each(function(){
          var el = $(this),
          value = '',
          id = this.id.split('_');
          id.splice(id.length-2,2);
          switch(el.data('typecontrol'))
            {
             case 'input':
                 value=el.val();
                 if (el.attr('type')=='password') value = CryptoJS.MD5(value).toString();
                 break;
             case 'checkbox':if(el.jqxCheckBox('checked'))value='Y';else value='N';break;
             case 'combobox':if(el.jqxComboBox('selectedIndex') == -1)
                              {
                               if(el.data('loadvalue')== true)value='NULL';
                               else id = undefined;
                              }
                             else value=el.jqxComboBox('val');
               break;
             case 'date':value=el.jqxDateTimeInput('getDate');
                        if(value == null)id = undefined;
                        else value = value.getDate()+'.'+(value.getMonth()+1)+'.'+value.getFullYear();
               break;
             case 'file':value=el.data('filename');
               break;
             case 'inputfile':value=el.prop('value');//Это для получения значения из контрола выбора файла
               break;
            }
         value = methods.convertToString(value, scriptType);
         if(id != undefined && value!="NULL")
            dataXML=dataXML+' '+id.join('_')+'="'+value+'"';
        });
        dataXML = dataXML+'/>';
        return dataXML;
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   convertToString:function(val, scriptType){
        if(val==null)
            return "NULL";
        var res = val.toString();
        //Изменил условие возврата NULL - мы можем сохранять пустые поля если скрипт - UPDATE
        if (scriptType=="UPDATE") {
            if(res==gis_formPanel_2)
                return "NULL";
        } else {
            if(res.length==0 || res==gis_formPanel_2)
                return "NULL";
        }
        return res;
   },
   saveFormNew:function(params){
     try {
        var waitload = $('#frm_'+params.localId+'_'+params.indexForm).data('waitload');
        if(waitload != 0)
          {
           $('#frm_'+params.localId+'_'+params.indexForm+' .divFileInput.waitLoad').each(function(){
           var fileName = $('#'+this.id+' .divFileInputName').html(),
               allID = this.id.replace('divFI',''),
               form = $('#fr'+allID);
           $('#ifr'+allID).data('checkload',true);
           if(params.options.handlers.setDataLoadingCallback != undefined)params.options.handlers.setDataLoadingCallback(true);
           form.attr('action',form.data('action')+'&fileNameGUID='+encodeURI(fileName)).submit();
           });
          }
        else methods[params.saveMethod](params);
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   saveTabForm:function(params){
     try {
        var frm = $('#frm_'+params.localId+'_'+params.indexForm),
            prm = params.options.objects[params.options.curObject].id.split(':'),
            db= prm[0].split('_'),
            db_schema = db[0],
            db_table_id = db.slice(1).join('_'),
            descrType = 'update';
        if(prm[1] == undefined) {
           descrType='insert';
           prm[1] = '';
        }
        if(params.options.handlers.getFormDataCallback != undefined) {
            params.options.handlers.getFormDataCallback(methods.getCurrentFormObject('frm_'+params.localId+'_'+params.indexForm));
        }
        params.callBack(params);
        //Закрываем форму, передав все параметры в функцию обратного вызова
        methods.destroyPanel(params); //el.remove();
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   setTableData:function(data,params){
     try {
       params.source.localdata = '<?xml version="1.0" encoding="utf-8"?>'+data;
       var dataAdapter = new $.jqx.dataAdapter(params.source);
       $('#'+params.idTable).jqxGrid({source:dataAdapter});
       //Сразу после обновления блокируем кнопки в гридах комментариев и прикрепленных документов
       methods.setCommentDocGridBtnDisabled(params, true);
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   markChange:function(params){
     try {
         $('#frm_'+params.localId+'_'+params.selectedIndex).addClass('frmChanged');
         params.options.btnSave.jqxButton({disabled:false});
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
    },
   unlockFormControls:function(params){
     try {
       $('#divTabContent_'+params.localId+'_'+params.selectedIndex+' .formControl').each(function(){
        var el = $(this);
        if(!el.hasClass('noEditable')) {
           switch(el.data('typecontrol')) {
              case 'input':el.jqxInput({disabled:false}); el.data('loadvalue',true); break; //разблокируем и помечаем как контрол с загруженными данными
              case 'checkbox':el.jqxCheckBox({disabled:false}); el.data('loadvalue',true); break; //разблокируем и помечаем как контрол с загруженными данными
              case 'date':el.jqxDateTimeInput({disabled:false}); el.data('loadvalue',true); break; //разблокируем и помечаем как контрол с загруженными данными
              case 'combobox':
               if(!el.hasClass('noListValues')) {
                  //комбобокс разблокируем и помечаем как контрол с загруженными данными только если в него загружены значения (нет класса noListValues)
                  //el.data('loadvalue',true);
                  //el.jqxComboBox({disabled:false});
               }
              break;
           }
        }
      });
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   getDivContent:function(params){
     var divContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
     return divContent;
   },
   setInputFileName:function(){
     try {
      var fileName = $(this).val().split('\\');
      var changedElement = $('#'+this.id.replace('iFI_',''));
      if(fileName.length != 1)fileName = fileName[fileName.length-1].split('.');
      else fileName = fileName[0].split('.');
      fileName[fileName.length-2] = fileName[fileName.length-2]+'-'+methods.getUniqueId();
      fileName = fileName.join('.');
      $(this).data('filename',fileName);
      changedElement.val(fileName);
      changedElement.trigger('change');
     } catch (err) {
         //Ничего не делаем, возможно панель закрыта
     }
   },
   uploadComplete:function(params){
    try {
    if($(params.iframe).data('checkload') == true) {
      $(params.iframe).data('checkload',false);
      var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
      frm.data('waitload',Number(frm.data('waitload'))-1);
      $('#divFI'+params.iframe.id.replace('ifr','')).removeClass('waitLoad');
      if(params.options.handlers.setDataLoadingCallback != undefined)params.options.handlers.setDataLoadingCallback(false);
      if(Number(frm.data('waitload')) == 0) methods[params.saveMethod](params);
     }
    } catch (e) {
        App.errorReport(gis_formPanel_3, gis_formPanel_4 + e.toString(), undefined, {filename:gis_filename_560, functionname:'gis_filename_560_1'});
    }
   },
   setAttrsValues:function(params) {
       try {
           if (params.options.objects[params.options.curObject].attrs != undefined) {
               $(params.options.objects[params.options.curObject].attrs).each(function () {
                   var control = $('#' + this.name + '_' + params.localId + '_' + params.selectedIndex);
                   if (control.length != 0)
                       methods.setControlValue(control, this);
               });
           }
       } catch (err) {
           //Ничего не делаем, возможно панель закрыта
       }
   }
  };

  $.fn.myFormPropertiesPanel = function( method ){
    if(methods[method]) {
      return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
    } else if ( typeof method === 'object' || ! method ) {
      return methods.init.apply( this, arguments );
    } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.fn.myFormPropertiesPanel' );
    }
  };
})(jQuery);
/*
 * Глобальные функции для вызова из внешних приложений
 * */

//Эта функция используется как для выполнения операции, так и для возврата значения
//При возврате значения функция вызывается с единственным аргументом со значением true/false
//Поэтому если первый аргумент - true/false, а второй - undefined, значит вызываем внешнюю функцию-результат
function findExternalObject(systemId, objectId, needBind, lineId, beginKm, endKm) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_1, "Data Access", LogUtil.Severity_INFO, gis_externalfunctionsapi_2 + systemId + ", objectId=" + objectId);
		if (systemId != undefined && objectId == undefined) {
			if (window != undefined && window.external != undefined) window.external.findExternalObject(systemId);
			else
				LogUtil.sendLog("window==undefined || window.external==undefined");
		} else {
			var app = getFlexApp("Client_Main");
			if (app != null)
				app.findExternalObject(systemId, objectId);
			else {
				return WidgetMap.findExternalObject(systemId, objectId, needBind, lineId, beginKm, endKm);
			}
		}
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию findExternalObject. error: "+ e.message + ". Вызов функции findExternalObject с параметрами: systemId="+systemId+", objectId="+objectId);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_3 + e.message);
		} catch (err) {
		}
	}
}

//Эта функция используется как для выполнения операции, так и для возврата значения
//При возврате значения функция вызывается с единственным аргументом со значением true/false
//Поэтому если первый аргумент - true/false, а второй - undefined, значит вызываем внешнюю функцию-результат
function findExternalPipeKm(systemId, objectId, km) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_4 + systemId + ", objectId=" + objectId + ", km=" + km);
		if (systemId != undefined && objectId == undefined) {
			if (window != undefined && window.external != undefined) window.external.findExternalPipeKm(systemId);
			else
				LogUtil.sendLog("window==undefined || window.external==undefined");
		} else {
			var app = getFlexApp("Client_Main");
			if (app != null)
				app.findExternalPipeKm(systemId, objectId, km);
			else {
				return WidgetMap.findExternalPipeKm(systemId, objectId, km);
			}
		}
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию findExternalPipeKm. error: "+ e.message + ". Вызов функции findExternalPipeKm с параметрами: systemId="+systemId+", objectId="+objectId+", km="+km);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_5 + e.message);
		} catch (err) {
		}
	}
}

//Эта функция используется как для выполнения операции, так и для возврата значения
//При возврате значения функция вызывается с единственным аргументом со значением true/false
//Поэтому если первый аргумент - true/false, а второй - undefined, значит вызываем внешнюю функцию-результат
function findExternalPipePart(systemId, objectId, km, endKm) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_6 + systemId + ", objectId=" + objectId + ", km=" + km + ", endKm=" + endKm);
		if (systemId != undefined && objectId == undefined) {
			if (window != undefined && window.external != undefined) window.external.findExternalPipePart(systemId);
			else
				LogUtil.sendLog("window==undefined || window.external==undefined");
		} else {
			var app = getFlexApp("Client_Main");
			if (app != null)
				app.findExternalPipePart(systemId, objectId, km, endKm);
			else {
				return WidgetMap.findExternalPipeKm(systemId, objectId, km, endKm);
			}
		}
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию findExternalPipePart. error: "+ e.message + ". Вызов функции findExternalPipePart с параметрами: systemId="+systemId+", objectId="+objectId+", km="+km+", endKm="+endKm);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_7 + e.message);
		} catch (err) {
		}
	}
}

function getMapWidth() {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_8);
		var app = getFlexApp("Client_Main");
		if (app != null)
			return app.getMapWidth();
		else {
			return WidgetMap.getMapWidth();
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_9 + e.message);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_9 + e.message);
		} catch (err) {
		}
	}
}
function getMapCenter() {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_10);
		var app = getFlexApp("Client_Main");
		if (app != null)
			return app.getMapCenter();
		else {
			return WidgetMap.getMapCenter();
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_11 + e.message);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_11 + e.message);
		} catch (err) {
		}
	}
}

function getPosition() {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_12);
		var app = getFlexApp("Client_Main");
		if (app != null)
			return app.getPosition();
		else {
			return WidgetMap.getPosition();
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_13 + e.message);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_13 + e.message);
		} catch (err) {
		}
	}
}

//Эта функция используется как для выполнения операции, так и для возврата значения
//При возврате значения функция вызывается с единственным аргументом со значением true/false
//Поэтому если первый аргумент - true/false, а второй - undefined, значит вызываем внешнюю функцию-результат
function refreshLayer(layerName, params) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_14 + layerName + ", params=" + params);
		if (layerName != undefined && params == undefined) {
			if (window != undefined && window.external != undefined) window.external.refreshLayer(layerName);
			else
				LogUtil.sendLog("window==undefined || window.external==undefined");
		} else {
			var app = getFlexApp("Client_Main");
			if (app != null) {
				app.refreshLayer(layerName, params);
			} else {
				return WidgetMap.refreshLayer(layerName, params);
			}
		}
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию refreshLayer. error: "+ e.message + ". Вызов функции refreshLayer с параметрами: layerName="+layerName+", params="+params);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_15 + e.message);
		} catch (err) {
		}
	}
}

function clearLayer(layerName) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_16 + layerName);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.clearLayer(layerName);
		else {
			return WidgetMap.clearLayer(layerName);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_17 + e.message + gis_externalfunctionsapi_18 + layerName);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_17 + e.message);
		} catch (err) {
		}
	}
}

function refreshModel(modelName, params) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_19 + modelName + ", params=" + params);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.refreshModel(modelName, params);
		else {
			return WidgetMap.refreshModel(modelName, params);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_20, gis_externalfunctionsapi_20 + e.message + gis_externalfunctionsapi_21 + modelName + ", params=" + params, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_5'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_20 + e.message);
		} catch (err) {
		}
	}
}

function clearModel(modelName) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_22 + modelName);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.clearModel(modelName);
		else {
			return WidgetMap.clearModel(modelName);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_26, gis_externalfunctionsapi_26 + e.message + gis_externalfunctionsapi_27 + modelName + ", params=" + params, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_7'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_23 + e.message);
		} catch (err) {
		}
	}
}

function refreshMap(modelName, params) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_25 + modelName + ", params=" + params);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.refreshMap(modelName, params);
		else {
			return WidgetMap.refreshMap(modelName, params);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_26 + e.message + gis_externalfunctionsapi_27 + modelName + ", params=" + params);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_26 + e.message);
		} catch (err) {
		}
	}
}

function clearMap(modelName) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_28 + modelName);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.clearMap(modelName);
		else {
			return WidgetMap.clearMap(modelName);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_29 + e.message + gis_externalfunctionsapi_30 + modelName);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_29 + e.message);
		} catch (err) {
		}
	}
}

function showCAS(type, systemId, objectId, objectName, kmBegin, kmEnd) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_31 + type + ", systemId=" + systemId + ", objectId=" + objectId + ", objectName=" + objectName + ", kmBegin=" + kmBegin + ", kmEnd=" + kmEnd);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.showCAS(type, systemId, objectId, objectName, kmBegin, kmEnd);
		else
			return WidgetMap.showCAS(type, systemId, objectId, objectName, kmBegin, kmEnd);
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_32 + e.message + gis_externalfunctionsapi_33 + type + ", systemId=" + systemId + ", objectId=" + objectId + ", objectName=" + objectName + ", kmBegin=" + kmBegin + ", kmEnd=" + kmEnd);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_32 + e.message);
		} catch (err) {
		}
	}
}

function exportIMG(systemId, objectId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_34 + systemId + ", objectId=" + objectId);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.exportIMG(systemId, objectId);
		else
			LogUtil.sendLog("app == null");
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_35, gis_externalfunctionsapi_35 + e.message + gis_externalfunctionsapi_36 + systemId + ", objectId=" + objectId, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_10'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_35 + e.message);
		} catch (err) {
		}
	}
}

function openVRML(systemId, objectId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_37 + systemId + ", objectId=" + objectId);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.openVRML(systemId, objectId);
		else
			LogUtil.sendLog("app == null");
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_38, gis_externalfunctionsapi_38 + e.message + gis_externalfunctionsapi_39 + systemId + ", objectId=" + objectId, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_11'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_38 + e.message);
		} catch (err) {
		}
	}
}

function exportGPX(systemId, objectId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_40 + systemId + ", objectId=" + objectId);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.exportGPX(systemId, objectId);
		else
			LogUtil.sendLog("app == null");
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_41, gis_externalfunctionsapi_41 + e.message + gis_externalfunctionsapi_42 + systemId + ", objectId=" + objectId, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_12'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_41 + e.message);
		} catch (err) {
		}
	}
}

function exportExcel(systemId, objectId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_43 + systemId + ", objectId=" + objectId);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.exportExcel(systemId, objectId);
		else
			LogUtil.sendLog("app == null");
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_44, gis_externalfunctionsapi_44 + e.message + gis_externalfunctionsapi_45 + systemId + ", objectId=" + objectId, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_13'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_44 + e.message);
		} catch (err) {
		}
	}
}

/* Функция запуска воспроизведения видео по docId и videoUrl */
function showVideo(docId, videoUrl, videoName, lineId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		if(videoUrl != "" && videoUrl.indexOf("'") != -1){
			videoUrl = videoUrl.replace("'","");//удаляем одинарные кавычки, чтобы корректно флешка читала mp4
			videoUrl = videoUrl.replace("'","");
		}

		LogUtil.sendLog(gis_externalfunctionsapi_46 + docId + ", videoUrl=" + videoUrl + ", videoName=" + videoName + ", lineId=" + lineId);

		//Вместо вызова флеша открываем js-окно, в которое будет загружаться виджет видеоплеера
		if (typeof VideoPlayerWindow != 'undefined') {
			var videoPlayerWnd = new VideoPlayerWindow();
			videoPlayerWnd.build('currentVideoPlayer', docId, videoUrl, videoName, lineId);
		} else {
			/* версия с флеш-картой запускала видео так */
			var app = getFlexApp("Client_Main");
			//Параметры для вызова
			var videoParams = [{name: "docId", value: docId}, {name: "videoUrl", value: videoUrl}, {
				name: "lineId",
				value: lineId
			}];
			if (app != null && app['showVideo'] != undefined) {
				app['showVideo'](videoParams);
			} else {
				//Если вызвали функцию со страницы, открытой из грида - перенаправляем вызов в окно карты (видеоплеер находится в нем)
				callFunction('', 'showVideo', videoParams);
			}
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_47 + e.message + gis_externalfunctionsapi_48 + docId + ", videoUrl=" + videoUrl + ", videoName=" + videoName);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_47 + e.message);
		} catch (err) {
		}
	}
}

/* Функция приема из виджета видеоплеера параметра перемещения карты за вертолетиком, если он выходит за рамку карты (true/false) */
function widgetVideoSetAutoFocus(autoFocus, toFlash) {
	try {
		WidgetMap.startVideoAutoFocusFlag = autoFocus;
		if (toFlash !== undefined) {
			var app = getFlexApp("videoPlayer55");
			if (app != null)
				app.widgetVideoSetAutoFocus(autoFocus);
			WidgetMap.isVideoAutoFocus = autoFocus;
			return;
		}
		WidgetMap.isVideoAutoFocus = autoFocus;
		if (autoFocus == true)
			WidgetMap.forceAutoFocus = true;
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию widgetVideoSetAutoFocus");
	}
}

/* Функция приема из виджета видеоплеера трека видеозаписи (приходит в формате xml-строки с геометрией) */
function widgetVideoSetTrack(xmlGeoResult) {
	try {
		var geoRes = xmlGeoResult;
		WidgetMap.showVideo(geoRes);
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_49 + e.message + gis_externalfunctionsapi_50 + xmlGeoResult);
	}
}

/* Функция приема из виджета видеоплеера текущей точки видеозаписи (приходит в формате xml-строки с геометрией) */
function widgetVideoShowOnMap(xmlGeoResult) {
	try {
		var geoRes = xmlGeoResult;
		WidgetMap.videoShowOnMap(geoRes);
	}
	catch (e) {
	}
}

/* Функция установки в виджет видеоплеера текущего времени видеозаписи (целое значение от 0 до длины видео, берется из переданного в функцию widgetVideoSetTrack) */
function widgetVideoSetPlayheadTime(timeValue) {
	try {
		var wnd = getOpener();
		var fApp = getCurrentFlexApp(wnd, "videoPlayer55");
		if (fApp != null) {
			try {
				fApp['widgetVideoSetPlayheadTime'](timeValue);
				//Если вызов прошел - возвращаем true
				return true;
			}
			catch (e) {
				return false;
			}
		} else {
			return false;
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_51 + e.message + gis_externalfunctionsapi_52 + timeValue);
		return false;
	}
}

/* Функция перемотки виджета видеоплеера ко времени точки, ближайшей к переданным координатам (координаты передаются в Пулково-42) */
function widgetVideoMovePlayheadToCoords(pointLon, pointLat) {
	try {
		var wnd = getOpener();
		var fApp = getCurrentFlexApp(wnd, "videoPlayer55");
		if (fApp != null) {
			try {
				fApp['widgetVideoMovePlayheadToCoords'](pointLon, pointLat);
				//Если вызов прошел - возвращаем true
				return true;
			}
			catch (e) {
				return false;
			}
		} else {
			return false;
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_53, gis_externalfunctionsapi_53 + e.message + gis_externalfunctionsapi_54 + pointLon + ", pointLat=" + pointLat, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_17'});
		return false;
	}
}

/* Функция для изменения позиции окна (окна грида, видеоплеера - по специальным идентификаторам)
 * popupWindowId - идентификатор окна либо константа из следующего списка: ['grid','videoplayer']
 * flag - флаг, указывающий что делать с окном. Обрабатываются параметры из следующего списка: ['move','collapse','minimize','maximize','restore','close'].
 * По-умолчанию 'move', т.е. окно будет уменьшено и перемещено так, чтобы верх окна по высоте начинался с 2/3 экрана.
 * */
function widgetMoveWindowToPosition(popupWindowId, flag) {
	try {
		if (!flag || flag == undefined) flag = 'move';
		//Для грида всегда используется контейнер с классом gridTabContent - по нему и находим плавающее окно с гридом
		if (popupWindowId != undefined && popupWindowId && popupWindowId == 'grid') {
			var curGridTabNav = $('.gridTabContent');
			if (curGridTabNav && curGridTabNav.length > 0) {
				switch (flag) {
					case 'move':
						//ТУТ ПРОИСХОДИТ СВОРАЧИВАНИЕ ГРИДА ДО МИНИМАЛЬНЫХ РАЗМЕРОВ
						//upd. 08.04.21 если нет карты, то грид не сворачиваем
						if(!checkMapExisting())
							break;
						var curPos = curGridTabNav.dialog("widget").position();
						var newHeight = $(window).height() / 3;
						curGridTabNav.dialog('option', {"height": newHeight, "position": [curPos.left, newHeight * 2]});
						/*Вызываем события resize как при изменении размеров мышкой*/
						curGridTabNav.trigger("resize");
						curGridTabNav.dialog('option', 'resize').apply(curGridTabNav, [null, null]);
						break;
					case 'collapse':
						curGridTabNav.dialogExtend("collapse");
						break;
					case 'minimize':
						curGridTabNav.dialogExtend("minimize");
						break;
					case 'maximize':
						curGridTabNav.dialogExtend("maximize");
						break;
					case 'restore':
						curGridTabNav.dialogExtend("restore");
						break;
					case 'restore_default':
						curGridTabNav.trigger("resize");
						curGridTabNav.dialog('option', 'resize').apply(curGridTabNav, ['restore_default', null]);
						break;
					case 'close':
						curGridTabNav.dialog("destroy");
						//Возможно нужно тут удалять curGridTabNav, хотя при build нового окна он все равно удалится
						break;
					default:
						break;
				}
			} else {
				//Это на случай, если текущий код находится на странице iframe и нужно вызвать функцию родительского окна
				if (parent && parent.hasOwnProperty('widgetMoveWindowToPosition') && parent.widgetMoveWindowToPosition !== widgetMoveWindowToPosition && parent.$('.gridTabContent').length > 0) {
					parent.widgetMoveWindowToPosition(popupWindowId, flag);
				}
			}
		} else if (popupWindowId != undefined && popupWindowId && popupWindowId == 'videoplayer') {
			//Для видеоплеера еще не создан никакой класс или div с плавающим окном
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_55, gis_externalfunctionsapi_55 + e.message + gis_externalfunctionsapi_56 + popupWindowId + ", flag=" + flag, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_18'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_55 + e.message);
		} catch (err) {
		}
	}
}

/* Это функция обратного вызова */
function taskReady(taskName, success) {
	try {
		//ловим вызов, смотрим, нит ли в url параметров func.
		//если есть, то вызываем функции
		var func = Auth.getParameterByName('func');
		if (func != '') {
			var systemId = Auth.getParameterByName('systemId');
			switch (func) {
				case 'exportGPX':
					exportGPX(systemId, Auth.getParameterByName('objectId'));
					break;
				case 'exportExcel':
					exportExcel(systemId, Auth.getParameterByName('objectId'));
					break;
				case 'exportIMG':
					exportIMG(systemId, Auth.getParameterByName('objectId'));
					break;
				case 'openVRML':
					openVRML(systemId, Auth.getParameterByName('objectId'));
					break;
				case 'showCAS':
					showCAS(Auth.getParameterByName('type'), systemId, Auth.getParameterByName('objectId'), Auth.getParameterByName('objectName'), Auth.getParameterByName('beginKm'), Auth.getParameterByName('endKm'));
					break;
			}
			LogUtil.sendLog(gis_externalfunctionsapi_57 + taskName + ", success=" + success);
			return;
		}

		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_57 + taskName + ", success=" + success);
		if (window != undefined && window.external != undefined) window.external.taskReady(taskName, success);
		else
			LogUtil.sendLog("window==undefined || window.external==undefined");
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию taskReady. error: "+ e.message + ". Вызов функции taskReady с параметрами: taskName="+taskName+", success="+success);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_58 + e.message);
		} catch (err) {
		}
	}
}

/* Это функция обратного вызова с информацией из панели свойств */
function onObjectsInfo(objectsList) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_59 + objectsList.toString());
		if (window != undefined && window.external != undefined) window.external.onObjectsInfo(objectsList);
		else
			LogUtil.sendLog("window==undefined || window.external==undefined");
	}
	catch (e) {
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_60 + e.message);
		} catch (err) {
		}
	}
}

