//Глобальный объект для внешнего взаимодействия (любые интерфейсные взаимодействия для вызова функций)
ExternalInteraction = {};

//константы задач
ExternalInteraction.MAP = "MAP";
ExternalInteraction.MULT_MAIN		= "MULT_MAIN";
ExternalInteraction.GRID 			= "GRID";
ExternalInteraction.CAS 				= "CAS";
ExternalInteraction.PROP 			= "PROP";
ExternalInteraction.EXPORT_EXCEL 	= "EXPORT_EXCEL";
ExternalInteraction.EXPORT_GPX 		= "EXPORT_GPX";
ExternalInteraction.EXPORT_IMG 		= "EXPORT_IMG";
ExternalInteraction.EXPORT_DOC 		= "EXPORT_DOC";
ExternalInteraction.EXPORT_WRL 		= "EXPORT_WRL";

ExternalInteraction.DEFAULT_URL 		= "";
ExternalInteraction.DEFAULT_WINDOW_TEMPLATE 		= "default";

//название функций синхронизации
ExternalInteraction.EXPORT_EXCEL_FUNCTION 			= "exportExcel";
ExternalInteraction.EXPORT_GPX_FUNCTION 				= "exportGPX";
ExternalInteraction.CAS_SHOW_MAP_FUNCTION 			= "showMap";
ExternalInteraction.CAS_SHOW_LINE_FUNCTION 			= "showLine";
ExternalInteraction.FILTER_DATA_FUNCTION 			= "filterData";
ExternalInteraction.FILTER_DATA_FUNCTION_CALLBACK 	= "callbackFilter";
ExternalInteraction.SHOW_OBJECTS_FUNCTION    		= "showObjects";
ExternalInteraction.SHOW_VIDEO_FUNCTION    			= "showVideo";

ExternalInteraction.FUNCTION_ERROR = gis_externalinteraction_1;
ExternalInteraction.FUNCTION_MAP_ERROR = gis_externalinteraction_2;
ExternalInteraction.FUNCTION_ERROR_TITLE = gis_externalinteraction_3;
ExternalInteraction.CALLBACK_FUNCTION_ERROR = gis_externalinteraction_4;
ExternalInteraction.CALLBACK_FUNCTION_ERROR_TITLE = gis_externalinteraction_5;
ExternalInteraction.OPEN_WINDOW_ERROR = gis_externalinteraction_6;
ExternalInteraction.OPEN_WINDOW_ERROR_TITLE = gis_externalinteraction_7;
ExternalInteraction.EXTERNAL_INTERFACE_ERROR = gis_externalinteraction_8;
ExternalInteraction.EXTERNAL_INTERFACE_ERROR_TITLE = gis_externalinteraction_9;

/*Функции для вызова функций взаимодействия (с обработкой результатов вызова)*/

ExternalInteraction.callbackFunction = function (windowId /*String*/, funcName /*String*/, params /*Array*/, showErrorMessage /*Boolean = false*/) {
    /*Сейчас проверки наличия внешнего интерфейса не делаем, однако в будущем нужно проверять наличие интерфейса для функций виджета, если это возможно*/
    if(true /*ExternalInterface.available*/)
    {
        //вызывает открытие окна и результат идентификатор окна или null
        var result = callbackFunction(windowId, funcName, params);
        if(!showErrorMessage)
            return -1;
        if(result == -1)
        {
            App.errorReport(ExternalInteraction.FUNCTION_ERROR_TITLE, ExternalInteraction.FUNCTION_MAP_ERROR, undefined, {filename:gis_filename_118, functionname:'gis_filename_118_1'});
            return -1;
        }
        if(result == 0)
        {
            App.errorReport(ExternalInteraction.FUNCTION_ERROR_TITLE, ExternalInteraction.FUNCTION_ERROR.replace('{0}',funcName), undefined, {filename:gis_filename_118, functionname:'gis_filename_118_2'});
            return 0;
        }
    }
    else
        App.errorReport(ExternalInteraction.EXTERNAL_INTERFACE_ERROR_TITLE, ExternalInteraction.EXTERNAL_INTERFACE_ERROR.replace('{0}',"callbackFunction"), undefined, {filename:gis_filename_118, functionname:'gis_filename_118_3'});
    return -1;
};

//взаимодействие с открытым окном
ExternalInteraction.callFunction = function (windowId /*String*/, funcName /*String*/, params /*Array*/) {
    /*Сейчас проверки наличия внешнего интерфейса не делаем, однако в будущем нужно проверять наличие интерфейса для функций виджета, если это возможно*/
    if(true /*ExternalInterface.available*/)
    {
        //вызывает открытие окна и результат идентификатор окна или null
        //временно перенаправляем вызов на js карту (if widgetMap != undefined или что-то подобное в качестве проверка)
        if(funcName == "showObjects")
            return WidgetMap.showObjects(params);
        if(funcName == "filterData")
            return WidgetMap.filterData(params);
        else if(funcName == "showVideo")
            return WidgetMap.showVideo();
        else if(funcName == "updateCacheLayer")
            return WidgetMap.updateCacheLayer(params);
        else
            return callFunction(windowId, funcName, params);
    }
    App.errorReport(ExternalInteraction.EXTERNAL_INTERFACE_ERROR_TITLE, ExternalInteraction.EXTERNAL_INTERFACE_ERROR.replace('{0}',"callFunction"), undefined, {filename:gis_filename_118, functionname:'gis_filename_118_4'});
    return -1;
};

function BaseDataAdapter(opt_options){
	var options = opt_options !== undefined ? opt_options : {};
	this.updateCompleteHandler = (opt_options.updateCompleteHandler !== undefined)? options.updateCompleteHandler : undefined;
	this.source = (opt_options.source !== undefined || opt_options.source != '')? options.source : 'SYS_SEM.xml';
	this.requestSource = opt_options.requestSource !== undefined ? options.requestSource : '';
	this.sendData = goog.isDef(options.sendData) ? options.sendData : '<data/>';
	this.dataCollection_ = [];
	this.resultHandler_ = opt_options.resultHandler !== undefined ? options.resultHandler : undefined;
	// Запрос на получение данных
	this.selectSQL = opt_options.selectSQL !== undefined ? options.selectSQL : '';
	// Запрос на обновление данных
	this.updateSQL = opt_options.updateSQL !== undefined ? options.updateSQL : '';
	// Запрос на добавление данных
	this.insertSQL = opt_options.insertSQL !== undefined ? options.insertSQL : '';
	// Запрос на удаление данных
	this.deleteSQL = opt_options.deleteSQL !== undefined ? options.deleteSQL : '';


	this.added = opt_options.added !== undefined ? options.added : {};
	this.deleted = opt_options.deleted !== undefined ? options.deleted : {};
	this.modified = opt_options.modified !== undefined ? options.modified : {};
	this.modifiedCnt = 0;

	this.updateInfo = {};
	this.errorsText = '';

	this.currUpdateCnt = 0;
	this.currErrorCnt = 0;

	// Команда на добавление данных
	this.insertProcName = 'insert';
	// Команда на обновление данных
	this.updateProcName = 'update';
	//Команда на удаление данных
	this.deleteProcName = 'delete';


};

BaseDataAdapter.prototype.fill = function(){
	var that = this;
	//Проверяем что requestSource непустой, иначе ничего не запрашиваем.
	if (this.requestSource !== ''){
		BlockingUtil.wait();
		var reqParams = this.getReqParams(this.requestSource,this.sendData,'select',true);
		if(this.requestSource.indexOf('IUST_SEM_DICT.xml') !== -1 || this.requestSource.indexOf('ADM_SEM.xml') !== -1 && requestSource.indexOf('GAZPROM_ADM_SEM.xml') === -1){
			App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,reqParams,function(resultXml){
				BlockingUtil.ready();
				that.result_(resultXml);
			}, function(resultXml){
				BlockingUtil.ready();
				that.fault_(resultXml);
			});
		}
		else {
			App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
				BlockingUtil.ready();
				that.result_(resultXml);
			}, function(resultXml){
				BlockingUtil.ready();
				that.fault_(resultXml);
			});
		}

	}
};

BaseDataAdapter.prototype.getReqParams = function(requestSource, sendData, descrType, schema) {
	if(descrType === undefined)
		descrType = 'select';
	if(schema === undefined)
		schema = false;
	var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
	var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
	var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
	return {
		getSchema: schema,
		descrId: requestSource,
		toElements: false,
		descrType: descrType,
		data:  '<root USER_ID="'+userId.xmlEscape()+
		'" USER_LOGIN="'+userLogin.xmlEscape()+
		'" PODS_USER="'+userLogin.xmlEscape()+
		'" '+ topFiltersStr+''+
		'>'+
		sendData +
		'</root>'
	};
};

BaseDataAdapter.prototype.result_ = function(resultXml){
	var er = HTTPServiceUtil.getError(resultXml);
	this.dataCollection = [];
	this.attrs = [];
	if(er !== ''){
		App.errorReport(gis_basedataadapter_1, er,undefined,{filename:gis_filename_5, functionname:'BaseDataAdapter.prototype.result_'});
		return;
	}
	else{
		var layerGeoXml = ($.parseXML(resultXml)).firstChild;
		var datas = layerGeoXml.getElementsByTagName("data");
		var xsAttrs = $(layerGeoXml).find('xs\\:attribute,attribute');
		var isXsAttrs = false;//была ли схема в запросе
		if(xsAttrs.length>=0){
			isXsAttrs = true;
			for(var a=0; a<xsAttrs.length;a++){
				this.attrs.push(xsAttrs[a].getAttribute('name'));
			}
		}
		//формируем объект с атрибутами и данными
		for (var i = 0; i < datas.length; i++) {
			var obj = {};
			for (var j = 0; j < datas[i].attributes.length; j++) {
				if(i == 0 && isXsAttrs == false)
					this.attrs.push(datas[i].attributes[j].name);
				obj[datas[i].attributes[j].name] = datas[i].attributes[j].value;
			}
			this.dataCollection.push(obj);
		}
	}
	if(this.resultHandler_ !== undefined){
		this.resultHandler_.apply(this,[this.attrs,this.dataCollection]);
	}
};


BaseDataAdapter.prototype.fault_ = function(resultXml){
	var er = HTTPServiceUtil.getError(resultXml);
	if(er !== ''){
		App.errorReport(gis_basedataadapter_1, er,undefined,{filename:gis_filename_5, functionname:'BaseDataAdapter.prototype.fault_'});
	}
};

/** Обновление данных в БД и внешней подсистеме, генерация события с количеством обновленных данных */
BaseDataAdapter.prototype.update = function(){
	this.errorsText = "";
	var uid = '';
	var cnt = 0;
	this.currUpdateCnt = 0;
	this.currErrorCnt = 0;
	this.updateInfo["completed"] = false;
	this.updateInfo["errors"] = 0;
	var hasChanges = false;
	if (this.insertSQL != ""){
		for(uid in this.added){
			this.currUpdateCnt++;
			this.executeCommand_(this.insertProcName, this.insertSQL, this.added[uid]);
			cnt++;
		}
		this.updateInfo["added"] = cnt;

	}
	if(cnt > 0) hasChanges = true;
	cnt = 0;
	if (this.deleteSQL != ""){
		for(uid in this.deleted){
			this.currUpdateCnt++;
			this.executeCommand_(this.deleteProcName, this.deleteSQL, this.deleted[uid]);
			cnt++;
		}
		this.updateInfo["deleted"] = cnt;
	}
	if(cnt > 0) hasChanges = true;
	cnt = 0;
	if (this.updateSQL != ""){
		for(uid in this.modified){
			this.currUpdateCnt++;
			this.executeCommand_(this.updateProcName, this.updateSQL, this.modified[uid]);
			delete this.modified[uid];
			this.modifiedCnt--;
			cnt++;
		}
		this.updateInfo["modified"] = cnt;
	}
	else{
		for(uid in this.modified){
			delete this.modified[uid];
			this.modifiedCnt--;
		}
		delete this.updateInfo["modified"];
	}
	if(cnt > 0) hasChanges = true;
	this.updateInfo["completed"] = true;

};

BaseDataAdapter.prototype.executeCommand_ = function(procName, cmd, item){
	if(cmd !== undefined && cmd.length != 0){
		var fullCmd = this.makeCommand_(cmd, item);
		this.sendCommand_(procName, fullCmd);
	}
};

/**
 * Подстановка в команду параметров вида :xxx,
 * где xxx - имя атирбута узла item
 */
BaseDataAdapter.prototype.makeCommand_ = function(cmd, item){
	var sendData = '<data/>';
	if(cmd !== undefined && cmd.length != 0){
		sendData = '<data ';
		for(var attr in item){
			if(attr == 'uid')
				continue;
			sendData += attr+'="'+item[attr]+'" ';
		}
		sendData += '/>';
	}
	return sendData;
};

/** Отправка команды в БД */
BaseDataAdapter.prototype.sendCommand_ = function(procName, cmd){
	var that = this;
	if(cmd !== undefined && cmd.length != 0  && this.source !== ''){
		switch (procName)
		{
			case this.deleteProcName:
				BlockingUtil.wait();
				var reqParams = this.getReqParams(this.source+"#"+this.deleteSQL, cmd, procName);
				App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
					BlockingUtil.ready();
					that.resultExec_(resultXml);
				}, function(resultXml){
					BlockingUtil.ready();
					that.faultExec_(resultXml);
				},4);
				break;
			case this.insertProcName:
				BlockingUtil.wait();
				var reqParams = this.getReqParams(this.source+"#"+this.insertSQL, cmd, procName);
				App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
					BlockingUtil.ready();
					that.resultExec_(resultXml);
				}, function(resultXml){
					BlockingUtil.ready();
					that.faultExec_(resultXml);
				},4);
				break;
			case this.updateProcName:
				BlockingUtil.wait();
				var reqParams = this.getReqParams(this.source+"#"+this.updateSQL, cmd, procName);
				App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
					BlockingUtil.ready();
					that.resultExec_(resultXml);
				}, function(resultXml){
					BlockingUtil.ready();
					that.faultExec_(resultXml);
				},4);
				break;
			default:
				break;
		}
	}
};

BaseDataAdapter.prototype.resultExec_ = function(resultXml){
	var er = HTTPServiceUtil.getError(resultXml);
	if(er !== ''){
		this.currErrorCnt++;
		this.errorsText += gis_basedataadapter_2+er+"\n";
	}
	this.currUpdateCnt--;
	if (this.currUpdateCnt == 0){
		this.clearAllChanges_();
	}
	if ((this.currUpdateCnt == 0) && (this.updateInfo["completed"] == true)){
		if (this.currErrorCnt>0){
			this.updateInfo["errors"] = this.currErrorCnt;
			if (this.errorsText != ""){
				App.errorReport(gis_basedataadapter_3, er,undefined,{filename:gis_filename_5, functionname:'BaseDataAdapter.prototype.resultExec_'});
			}
		}
		this.dataUpdateComplete_(this.updateInfo);
		this.fill();
	}

};


BaseDataAdapter.prototype.faultExec_ = function(resultXml){
	this.currUpdateCnt--;
	this.currErrorCnt++;
	if (this.currUpdateCnt == 0){
		this.clearAllChanges_();
	}
	if ((this.currUpdateCnt == 0) && (this.updateInfo["completed"] == true)){
		if (this.currErrorCnt>0)
			this.updateInfo["errors"] = this.currErrorCnt;
		this.dataUpdateComplete_(this.updateInfo);
	}
};

//вспомогательная функция для очистки объектов с изменениями
BaseDataAdapter.prototype.clearAllChanges_ = function(resultXml){
	//очищаем список изменений полностью
	var uid;
	for (uid in this.added){
		delete this.added[uid];
	}
	for (uid in this.deleted){
		delete this.deleted[uid];
	}
	for (uid in this.modified){
		delete this.modified[uid];
	}
	this.modifiedCnt = 0;
};


/**
 * Функция обработчки события окончания обновления данных.
 * Отображает информацию об изменениях в данных
 * @param updateInfo
 * @private
 */
BaseDataAdapter.prototype.dataUpdateComplete_ = function(updateInfo){
	if(this.updateCompleteHandler !== undefined){
		this.updateCompleteHandler.apply(this,[updateInfo]);
		return;
	}
};
/**
 * Provider для DataGridWithScript
 */
function GridDataProvider(opt_options){
    var that = this;
    var options = goog.isDef(opt_options) ? opt_options : {};
    var sort_ = goog.isDef(options.sort) ? options.sort : null;
    var type = goog.isDef(options.type) ? options.type : 'sql';
    var requestSource = goog.isDef(options.requestSource) ? options.requestSource : null;
    var sendData = goog.isDef(options.sendData) ? options.sendData : '<data/>';
    this.dataCollection_ = [];
    this.resultHandler_ = goog.isDef(options.resultHandler) ? options.resultHandler : undefined;
    this.currentRequest;
    this.isAborted = false;

    //Проверяем что requestSource непустой, иначе ничего не запрашиваем.
    if (!goog.isNull(requestSource) && requestSource !== ''){
        BlockingUtil.wait();
        var reqParams = this.getReqParams(requestSource,sendData);
        if(requestSource.indexOf('IUST_SEM_DICT.xml') !== -1  || type === 'file'){
            this.currentRequest = App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,reqParams,function(resultXml){
                BlockingUtil.ready();
                that.result_(resultXml);
            }, function(resultXml){
                BlockingUtil.ready();
                if (!that.isAborted)
                    that.fault_(resultXml);
                that.isAborted = false;
            });
        }
        else {
            this.currentRequest = App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXml) {
                BlockingUtil.ready();
                that.result_(resultXml);
            }, function (resultXml) {
                BlockingUtil.ready();
                if (!that.isAborted)
                    that.fault_(resultXml);
                that.isAborted = false;
            });
        }
    }

};


GridDataProvider.prototype.cancelRequest = function(){
    if(this.currentRequest !== undefined){
        try{
            this.isAborted = true;
            this.currentRequest.abort();
        }
        catch(e){}
    }
};

GridDataProvider.prototype.getReqParams = function(requestSource, sendData) {
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
    return {
        getSchema: false,
        descrId: requestSource,
        toElements: false,
        descrType: 'select',
        data:  '<root USER_ID="'+userId.xmlEscape()+
        '" USER_LOGIN="'+userLogin.xmlEscape()+
        '" PODS_USER="'+userLogin.xmlEscape()+
        '" '+ topFiltersStr+''+
        '>'+
        sendData+
        '</root>'
    };
};

GridDataProvider.prototype.result_ = function(resultXml){
    var er = HTTPServiceUtil.getError(resultXml);
    this.dataCollection_ = [];
    if(er !== ''){
        App.errorReport(gis_griddataprovider_1, er,undefined,{filename:gis_filename_6, functionname:'GridDataProvider.prototype.result_'});
        return;
    }
    else{
        try{
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var datas = layerGeoXml.getElementsByTagName("data");
            for (var i = 0; i < datas.length; i++) {
                var wktStr = datas[i].getAttribute("WKT");
                if (!goog.isDefAndNotNull(wktStr) || wktStr== ''){
                    var obj = {};
                    var attrNamesList = datas[i].attributes;
                    for(var j=0; j<attrNamesList.length; j++){
                        var str =  attrNamesList[j].nodeName;
                        obj[str] = attrNamesList[j].nodeValue;
                    }
                    this.dataCollection_.push(obj);
                }
            }
        }
        catch(ex){
            this.dataCollection_ = [];
            App.errorReport(gis_griddataprovider_1, er,undefined,{filename:gis_filename_6, functionname:'gis_filename_6_1'});
        }
        
    }
    if(goog.isDefAndNotNull(this.resultHandler_)){
        this.resultHandler_.apply(this.dataCollection_);
    }
};

GridDataProvider.prototype.fault_ = function(resultXml){
    var er = HTTPServiceUtil.getError(resultXml);
    if(er !== ''){
        App.errorReport(gis_griddataprovider_1, er,undefined,{filename:gis_filename_6, functionname:'GridDataProvider.prototype.fault_'});
    }
};

GridDataProvider.prototype.getCoordsFromWKT = function(WKTString){
    return [];
};
/**
 * Provider для DataGridWithScript
 */
function QueryDataProvider(opt_options){
    var that = this;
    var options = goog.isDef(opt_options) ? opt_options : {};
    var sort_ = goog.isDef(options.sort) ? options.sort : null;
    var requestSource = goog.isDef(options.requestSource) ? options.requestSource : null;
    var sendData = goog.isDef(options.sendData) ? options.sendData : '<data/>';
    this.dataField = goog.isDef(options.dataField) ? options.dataField : 'CODE';
    this.labelField = goog.isDef(options.labelField) ? options.labelField : 'DESCR';
    this.dataCollection_ = [];
    this.resultHandler_ = goog.isDef(options.resultHandler) ? options.resultHandler : undefined;

    //Проверяем что requestSource непустой, иначе ничего не запрашиваем.
    if (!goog.isNull(requestSource) && requestSource !== ''){
        BlockingUtil.wait();
        var reqParams = this.getReqParams(requestSource,sendData);
        if(requestSource.indexOf('IUST_SEM_DICT.xml') !== -1 || requestSource.indexOf('ADM_SEM.xml') !== -1 && requestSource.indexOf('GAZPROM_ADM_SEM.xml') === -1){
            App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,reqParams,function(resultXml){
                that.result_(resultXml);
            }, function(resultXml){
                that.fault_(resultXml);
            });
        }
        else{
            App.serverQueryXMLNodeWithTries(Services.processQueryNode,reqParams,function(resultXml){
                that.result_(resultXml);
            }, function(resultXml){
                that.fault_(resultXml);
            });
        }
    }
};



QueryDataProvider.prototype.getReqParams = function(requestSource, sendData) {
    //TODO избавится от упоминания в запросах других форм AbstractFormDialog.sendUser
    var userId = Auth.getUserId();
    var userLogin = Auth.getUserName();
    var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
    return {
        getSchema: false,
        descrId: requestSource,
        toElements: false,
        descrType: 'select',
        data:  '<root USER_ID="'+userId.xmlEscape()+
        '" USER_LOGIN="'+userLogin.xmlEscape()+
        '" PODS_USER="'+userLogin.xmlEscape()+
        '" '+ topFiltersStr+''+
        '>'+
        sendData+
        '</root>'
    };
};

QueryDataProvider.prototype.result_ = function(resultXml){
    BlockingUtil.ready();
    var er = HTTPServiceUtil.getError(resultXml);
    this.dataCollection_ = [];
    if(er !== ''){
        App.errorReport(gis_querydataprovider_1, er,undefined,{filename:gis_filename_7, functionname:'QueryDataProvider.prototype.result_'});
        //Результат возвращаем в любом случае
        if(goog.isDefAndNotNull(this.resultHandler_)){
            this.resultHandler_.apply(null);
        }
        return;
    }
    else{
        var resArray = [];
        var unknownElem;
        //Если не будет найдено нулевое числовое значение, подставим минимальное из отрицательных чисел.
        var minNegNumUnknown = {num:0, obj:undefined};
        //var layerGeoXml = ($.parseXML(resultXml)).firstChild;
        //var datas = layerGeoXml.getElementsByTagName("data");
        var datas = $(resultXml).find('data');
        var i = 0;
        for (i; i < datas.length; i++) {
            var obj = {};
            var attrNamesList = datas[i].attributes;
            for(var j=0; j<attrNamesList.length; j++){
                var str =  attrNamesList[j].nodeName.toUpperCase();
                obj[str] = attrNamesList[j].nodeValue;
                if(str == this.dataField){
                    if ((obj[str].indexOf("UNKNOWN") == 0) || (obj[str] == '0')
                        || (obj[str] == gis_querydataprovider_2) || (obj[str]==gis_querydataprovider_3)
                        || (!goog.isNumber(parseFloat(obj[str])) && parseFloat(obj[str]) == 0))
                        unknownElem = obj;
                    //Сохраняем элемент как резервный по-умолчанию только если его CODE числовой и <0
                    if ((!goog.isNumber(parseFloat(obj[str]))
                        && parseFloat(obj[str])<minNegNumUnknown.num )){
                        minNegNumUnknown.num = parseFloat(obj[str]);
                        minNegNumUnknown.obj = obj;
                    }
                }
            }
        	//upd. 14.04.18 если на пришло labelField("DESCR"), то заполняем его ''
            if( ! goog.isDef(obj[this.labelField]))
	            obj[this.labelField] = ' ';
            if (goog.isDef(obj[this.dataField]))
                resArray.push(obj);
            else{//если объект без CODE или DESCR, не включаем его в список
                if (unknownElem == obj)
                    unknownElem = undefined;
            }
            //ставим на первое место элемент со свойством "UNKNOWN"
            if (goog.isDef(unknownElem)){
                resArray.splice(resArray.indexOf(unknownElem),1);
                // ставим явно в начало
                resArray.unshift(unknownElem);
            }
            else{
                //подставляем объект с минимальным из числовых отрицательных CODE (если у него num!=0)
                if (goog.isDef(minNegNumUnknown.obj)){
                    resArray.splice(resArray.indexOf(minNegNumUnknown.obj),1);
                    // ставим явно в начало
                    resArray.unshift(minNegNumUnknown.obj);
                }
            }
        }
        if(unknownElem == undefined) {
            //если после обработки данных нет элемента unknown, то его добавляем
	        resArray.unshift({CODE:'0',DESCR:gis_querydataprovider_4});
        }
        this.dataCollection_ = resArray;
    }
    if(goog.isDefAndNotNull(this.resultHandler_)){
        this.resultHandler_.apply(this.dataCollection_);
    }
};


QueryDataProvider.prototype.fault_ = function(resultXml){
    BlockingUtil.ready();
    var er = HTTPServiceUtil.getError(resultXml);
    if(er !== ''){
        App.errorReport(gis_querydataprovider_1, er,undefined,{filename:gis_filename_7, functionname:'QueryDataProvider.prototype.fault_'});
    }
    //Результат возвращаем в любом случае
    if(goog.isDefAndNotNull(this.resultHandler_)){
        //this.resultHandler_.apply(null);
        this.resultHandler_.apply([]);
    }
};
/**
 * Конструктор главного меню 
 */
function UserSettings() {
    this.container = null;
    this.xml = null;    
    this.structure = null;
    this._tasks = {};
    
    this._defaultItem = null;
    this._defaultCount = [];
    this._onChoice = null;
    this.requestUserWithRole = "ADM_SEM.xml#WEB50_B_USER_PRIVATE";
};

/**
 * Установка контейнера для меню 
 */
UserSettings.prototype.setContainer = function(container) {
    this.container = container;
};

/**
 * Установка XML данных
 */
UserSettings.prototype.setXml = function(xml) {
    this.xml = xml;
    this.initStructure();
};

/**
 * Установка обработчика выбора пункта меню 
 */
UserSettings.prototype.onChoice = function(onChoice) {
    this._onChoice = onChoice;
};

/**
 * Загрузка и подготовка структуры меню
 */
UserSettings.prototype.build = function() {
    if(!this.structure) {
        this.initStructure();                    
    }

    this.getCurrentUserData_();
    this._buildMenuElements();
    this._addPopupEvents();
    this._addChoiceEvents();
    this._menuShowEvent();

};
UserSettings.prototype.setDefaultName = function(){
    var userDefaultName = Auth.getUserName();
    $('.user-name').text(userDefaultName).attr('title',userDefaultName);
    //TODO вынести в отдельную обработку
    if(userDefaultName.length <=16)//кол-ва символов, при которых стоит выводить имя и фамилию в 2 строки
        $('.user-name').css('line-height', '4em');
    $('.user-letter').text(userDefaultName[0]);
};
UserSettings.prototype._setDefaultItem = function(defaultItem) {
    this._defaultItem = defaultItem;
};

/*
 * Возвращает имя пункта меню по умолчанию (в виде строки) 
 */
UserSettings.prototype.getDefaultItemName = function() {
    if(this._defaultItem) {
        return this._defaultItem.name;
    }           
    return null;
};

/*
 * Возвращает имя пункта меню по умолчанию (в виде структуры) 
 */
UserSettings.prototype.getDefaultTask = function() {
    if(this._defaultItem) {
        return this._defaultItem;
    }   
    return null;
};


/**
 * Получение информации о пользователе
 */

UserSettings.prototype.getCurrentUserData_ = function() {
    var that = this;
    function getCurrentUserDataParams( request) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '">'+
            '<data FILTER="'+' d.USER_ID='+userId+'" />'+
            '</root>'
        };
    }

    function getCurrentUserDataResult(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            that.setDefaultName();
            return;
        }
        that.longStr = '';
        //делаем разбор пришедших данных и добавляем их в mailMessage.text
        var userFirstName = '';
        var userLastName = '';
        var userFullName = '';

        var resultXml = ($.parseXML(resultXml)).firstChild;
        var datas = resultXml.getElementsByTagName("data");
        if(datas.length>0){
            var data = datas[0];
            userFirstName = goog.isNull(data.getAttribute("FIRSTNAME"))?'':data.getAttribute("FIRSTNAME")+' ';
            userLastName = goog.isNull(data.getAttribute("LASTNAME"))?'':data.getAttribute("LASTNAME");
            userFullName = userFirstName + userLastName;
            var themeAttr = goog.isNull(data.getAttribute("THEME"))?'':data.getAttribute("THEME")+'';
            //получаем флаги на режим открытия карты и показ обзорной карты
            if(themeAttr !== ''){
                try{
                    var theme = JSON.parse(themeAttr.replace(/&quot;/g,'"'));
                    var mode = MapUtil.getAvailableMapMode(theme.MAP_MODE);
                    if(goog.isDef(WidgetMap)){
                        MapUtil.applyThemeParams({
                            mapMode: mode,
                            showOverviewMap: theme.SHOW_OVERVIEW_MAP === true,
                            showTree: theme.SHOW_TREE === true,
                            sendCadastreEmail: theme.SEND_CADASTRE_EMAIL === true,
                            showCenterMap: theme.SHOW_CENTER_MAP === true,
                            coordMode: theme.COORD_MODE,
                            useSynchronization: theme.USE_SYNCHRONIZATION === true,
                        },true);
                    }
                }
                catch(e){

                }
            }
        }
        if(userFullName) {
            $('.user-name').text(userFullName).attr('title',userFullName);
            //TODO вынести в отдельную обработку
	        if(userFullName.length <=16)//кол-ва символов, при которых стоит выводить имя и фамилию в 2 строки
		        $('.user-name').css('line-height', '4em');
            $('.user-letter').text(userFullName[0]);
        }else{
            that.setDefaultName();
        }

    }
    function getCurrentUserDataFault(resultXml) {
        that.setDefaultName();
    }

    App.serverQueryXML2Node(Services.processQueryNode, getCurrentUserDataParams( this.requestUserWithRole ), getCurrentUserDataResult, getCurrentUserDataFault);

};

/**
 * Построение структуры меню из XML данных
 */
UserSettings.prototype.initStructure = function() {
    var that = this;
    // Рекурсивный пробег по структуре меню
    function walkLevel(nodes) {
        var items = [];                   
        
        // Цикл по текущему уровню        
        nodes.each(function(){
            var node = $(this);
            // Это одиночный пункт
            if(node.is('task')) {
                var item = {                        
                    title:  node.attr('descr'),
                    order:  node.attr('order'),
                    format:  node.attr('format'),
	                mask:  node.attr('mask'),
                    name:   node.attr('name'),
                    type:   node.attr('type'),
                    isDefault: node.attr('default') === 'true',
                    mdl:    node.attr('mdl'),
                    newWindow: (node.attr('newWnd') === undefined)?'false':node.attr('newWnd'),
                    auth: (node.attr('auth') === undefined)?'true':node.attr('auth'),
                    group:  false
                };

                // Для начала помечаем самый первый пункт, который не надо открывать в новом окне, как дефолтный                
//                if(!that._defaultItem) {
//                    that._setDefaultItem(item);
//                }

                //игнорируем флэш задачи
                if(item.mdl !== undefined && (item.mdl.indexOf('.swf') != -1 || item.mdl.indexOf('tech_schema.html') != -1 ))
                    return;
                // Не помечен ли этот пункт явно как дефолтный?
                if(node.attr('default') === 'true') {
                    //заносим в отдельный массив все дефолтные
                    that._defaultCount.push(item);
                }
                if(item.type !== undefined)
                    items.push(item);
            }

            // Это группа
            else if(node.is('group')) {
                var children = walkLevel(node.children('task,group'));

                // Какого типа пункты там внутри
                var type = 'main';
                $.each(children, function(i, e){
                    if(e.type === 'user') {
                        type = 'user';
                    }
                });                    

                var itemGroup = {
                    title:    node.attr('descr'),
                    order:    node.attr('order'),
                    format:  node.attr('format'),
	                mask:  node.attr('mask'),
                    children: children,
                    type:     type,
                    group: true// добавляем элемент, чтобы в следующих проверках не дублировать
                };                     
                items.push(itemGroup);
            }            
        }); 
        return items;
    }

    //
    // Второй рекурсивный пробег (чтобы сделать плоский список пунктов меню)
    //
    function walkStruct2(items) {
        $.each(items, function(i, item){
            if(item.name /*&& item.mdl*/) {
                if(item.mdl === 'main_js.html')
                    item.name = item.name.toLowerCase();
                that._tasks[ item.name ] = item;
            }
            if(item.children) {
                walkStruct2(item.children);
            }
        });
    }

    //Начинаем строить меню
    try {
        // Начало рекурсии
        //this.structure = walkLevel(this.xml.children('data').children('task,group'));
        this.structure = walkLevel(this.xml.find('task,group'));

        this._addHardItems();

        walkStruct2(this.structure);
        //Не помечен ли этот пункт явно как дефолтный?
        var i = 0;
        //проходимся по всем дефолтным. Если первая деволтная и в общем списке задач у неё атрибут default = true, то завершаем цикл
        //и выставляем её дефолтной
        for(i;i < this._defaultCount.length; i++){
            if(this._tasks[this._defaultCount[i].name] !== undefined && this._tasks[this._defaultCount[i].name].isDefault){
                this._setDefaultItem(this._tasks[this._defaultCount[i].name]);
                break;
            }
        }
    }
    catch (e) {
        App.errorReport(gis_usersettings_2, e, undefined, {filename:gis_filename_286, functionname:'gis_filename_286_1'});
    }
};



/**
 * Построение меню по структуре
 */
UserSettings.prototype._buildMenuElements = function() {
    var num = 0;
    var container = this.container;
    // уникальные названия задач
    var uniqTasksName = {};

    // Добавляет выпадающее меню
    function addPopup(root, items) {
        num ++;

        var ul = $('<ul class="popup" />').appendTo(container);            
        root.attr('data-popupId', 'popup'+num);
        ul.attr('id', 'popup'+num);
        $.each(items, function(i, item){
            var uniqueName = (item.group)?item.title:item.name;
            if(uniqueName !== undefined)
                uniqTasksName[uniqueName] = uniqueName;
            var li = $('<li />').text(item.title);
            if(item.name) {                    
                li.wrapInner($('<a/>').attr('href', ''+item.name));
            }
            ul.append(li);
        });        
    }

    try {
        container.append(
            '<div class="user-button">' +
                '<span class="user-letter"></span>' +
            '</div>'
        );
        // Построение контейнеров для главного и пользовательского меню
        container.append(
            '<div class="userMenu">' +
            '<div class="user-profile"><div class="user user-letter"> </div><div class="user-name"></div></div>' +
                '<ul class="top">'+
                    '<li class="tasks"><a>Задачи/Приложения</a></li>' +
                '</ul>' +
            '</div>'
        );

        var tasksLi = $('.userMenu ul.top li.tasks', container);
        var userUl = $('.userMenu ul.top', container);
        var tasksList = []; //Для списка пунктов меню, которые будут в popUp для taskLi

        // Добавляем пункты меню
        $.each(this.structure, function(i, item){
            if(item.type === 'user' || item.type === 'main') {
                var uniqueName = (item.group)?item.title:item.name;
                if(uniqTasksName[uniqueName] !== undefined )
                    return;
                if(uniqueName !== undefined)
                    uniqTasksName[uniqueName] = uniqueName;
                var li = $('<li />').text(item.title);
                if(item.name) {
                    li.wrapInner($('<a/>').attr('href', ''+item.name));
                }
                else {
                    li.wrapInner('<a/>');
                }

                if(item.children) {
                    addPopup(li, item.children);
                }

                if(item.type === 'user') {
                    userUl.append(li);
                }
                else {
                    tasksList.push(item)//добавляем пункты задач в список, для добавления в popUp
                }
            }
        });
        if(tasksList.length)
            addPopup(tasksLi, tasksList);//добавляем список задач в popUp
        else{
            tasksLi.remove();
        }
    }
    catch (e) {
        App.errorReport(gis_usersettings_2, e, undefined, {filename:gis_filename_286, functionname:'gis_filename_286_2'});
    }
};

/**
 * Добавление событий выпадающих попапов
 */
UserSettings.prototype._addPopupEvents = function() {
    var timer;
    // Открывание попапов
    $("ul.top > li", this.container).mouseover(function(){
        var id = $(this).attr('data-popupId');
        $('ul.popup', this.container).hide();
        if(id) {
            //var right = $(this).position().right;
            var top = $(this).position().top;
            var right =$('.userMenu').width();//$('#'+id).width();
            right += 15;
            top +=30;

            $('#'+id).css({right:right, top:top}).show();
        }
    });

    // Если мышка покинула, то закрываем попапы через небольшой интервал
    $("ul", this.container).mouseleave(function(){
        timer = window.setInterval(function(){
           $("ul.popup", this.container).hide();
        }, 200);        
    });        

    // Отмена отложенного закрывания попапа, если мышь вернулась в меню
    $("ul", this.container).mouseenter(function(){
        window.clearInterval(timer);
    });   
};
/**
 * Установка события показа меню
 */
UserSettings.prototype._menuShowEvent = function() {
    $('body').click(function () {
        $('.userMenu').hide();
    });
    $('.user-button').click(function (e) {
        e.stopPropagation();
        $('.userMenu').toggle();
    });
    $(".userMenu", this.container).click(function(e){
        e.stopPropagation();
    });
};

/**
 * Установка события выбора пункта меню
 */
UserSettings.prototype._addChoiceEvents = function() {
    var that = this;
    
    $('a[href]', this.container).click(function(event){
        event.preventDefault();
        $("ul.popup", this.container).hide();
        $('.userMenu').hide();
        var name = $(this).attr('href');          
        if(that._onChoice && name) {
            if(that._tasks[name]) {
                that._onChoice(that._tasks[name]);
            }
        }                            
    });           
};


/**
 * Добавление хардкодных пунктов в меню
 */
UserSettings.prototype._addHardItems = function() {
    this.structure.push({
        mdl:   "builtin",
        name:  "USER_CHANGE",
        order: 1,
        title: gis_usersettings_1 +" '" + Auth.getUserName() + "'",
        type:  "user"        
    });    
};

/**
 * Возвращиет заголовок по переданному taskName. Если передан taskName=='', возвращает заголовок текущей задачи
 */
UserSettings.prototype.getTaskTitleByTaskName = function(taskName) {
    var curTask = /task=([^&#^]+)/.exec(window.location.href);
    if(curTask || (taskName && taskName!='')) {
        //Сначала берем текущую задачу
        var curTaskName = curTask[1];
        //Если нужно получить заголовок для конкретной задачи - выбираем ее
        if(taskName && taskName!=''){
            curTaskName = taskName;
        }

        var task = this._tasks[curTaskName];
        if(task && task.title) {
            return task.title;
        }
    }

    return '';
};

/**
 * Устанавливает заголовок окна в соответсвии с тем, какой task указан в url страницы 
 */
UserSettings.prototype.setTitleByCurrentTask = function() {
    var title = this.getTaskTitleByTaskName('');
    if(title && title !=='') {
        var systemName = "";
        //забираем из конфига параметр System_Name для заголовка страницы
        if(App.config !== null && App.config !== undefined)
        {
            if(App.config.hasOwnProperty('SYSTEM_NAME'))
                systemName = App.config.SYSTEM_NAME +". ";
        }
        originalTitle = systemName+title;
        document.title = systemName+title;
    }
};

/**
 * Возвращает MDL. Его значение берется из URL.
 * Если в меню текущего пользователя нет такого task/mdl, то возвращает null
 */
UserSettings.prototype.getMdlFromUrl = function() {
    var m = /task=([^&#^]+)&mdl=([^&#^]+)/.exec(window.location.href);    
    if(m) {
        var task = m[1];
        var mdl  = m[2];
        //Корректируем, если в полученном из текущего url mdl имеется начальный слеш
        if(mdl.charAt(0) === '/') {
            mdl = mdl.substring(1);
        }
        
        var item = this._tasks[task];
        if(item && (mdl === item.mdl)) {
            return item.mdl;
        }
        //если не нашли, то проверяем, мб задача main_js, тогда в нижний регистр её переводим
        if(!item)
            item = this._tasks[task.toLowerCase()];
            if(item && mdl === item.mdl && (item.mdl === 'main_js.html' || item.mdl === 'tech_schema_js.html') ) {
            return item.mdl;
        }
    }
    return null;
};

/**
 * Возвращает TASK. Его значение берется из URL.
 * Если в меню текущего пользователя нет такого task, то возвращает null
 */
UserSettings.prototype.getTaskFromUrl = function() {
    var m = /task=([^&#^]+)/.exec(window.location.href);
    if(m) {
        var task = m[1];
        return task;
    }
    return null;
};

/*
 * Если для выбранной задачи установлен параметр mask, значит для текущего пользователя в текущей задачи будет происходить
 * ограничение по ЛПУ для тайловой подложки с трубопроводами
 */
UserSettings.prototype.setMask = function(task) {
	if(task){
		var item = this._tasks[task];
		if(!item)
            item = this._tasks[task.toLowerCase()];
		 if(item && item.mask && WidgetMap)
			WidgetMap.LPURestrictZoom = item.mask;
	}
};

/*
 * Возвращает тип элемента в меню
 */
UserSettings.prototype.getTaskType = function(task) {
    if(task){
        var item = this._tasks[task];
        if(!item)
            item = this._tasks[task.toLowerCase()];
        if(item)
            return item.type;
    }
    return undefined;
};

/*
 * Возвращает атрибут mdl
 */
UserSettings.prototype.getTaskMdl = function(task) {
    if(task){
        var item = this._tasks[task];
        if(!item)
            item = this._tasks[task.toLowerCase()];
        if(item)
            return item.mdl;
    }
    return null;
};

/*
 * Возвращает тип элемента в меню
 */
UserSettings.prototype.hasTaskAndMdlInMenu = function(task, mdlName) {
    if(task){
        var item = this._tasks[task];
        if(!item)
            item = this._tasks[task.toLowerCase()];
        if(item && item.mdl === mdlName)
            return true;
    }
    return false;
};
/**
 * Класс для экспорта данных в буфер
 */
function CASExportForm(opt_options) {
    var options = opt_options !== undefined ? opt_options : {};
    this.title = (options.title !== undefined)?options.title:gis_casexportform_1;
    this.closeCallback = (options.closeCallback !== undefined)?options.closeCallback:undefined;
    this.htmlUrl = 'ui/html/cas/CASExportForm.html';
    this.layer = (options.layer !== undefined)?options.layer:undefined;

    //Коэффициент растяжения, применяемый в модуле ПКА для того чтобы данные по X растягивались в длину на всю карту
    this.curScaleXCoeff = (options.curScaleXCoeff !== undefined)?options.curScaleXCoeff:1;

    //Текущие значения километров
    this.curMinX = (options.curMinX !== undefined)?options.curMinX:0;
    this.curMaxX = (options.curMaxX !== undefined)?options.curMaxX:0;

    //Начальный и конечный километр (нужны для смещения координат)
    this.minX = (options.minX !== undefined)?options.minX:0;
    this.maxX = (options.maxX !== undefined)?options.maxX:0;
    //Таблица слоев или отдельных feature.data для экспорта
    this.selectedItems = [];
};

CASExportForm.prototype.build = function() {
    var that = this;
    var currDialog = $('#exportDialog');
    if(currDialog.length == 0){
        $('body').append('<div id="exportDialog" style="overflow: hidden;"></div>');
        $('#exportDialog').hide();
        currDialog = $('#exportDialog');
    }

    var dlg = currDialog;
    dlg.load(this.htmlUrl, build);
    function build() {
        dlg.dialog({
            modal: true,
            title: that.title,
            closeOnEscape: false,
            dialogClass: 'noCloseButton gsi-zindex__dialog',
            width: 400,
            height: 220,
            resizable: false
        });
        //Устанавливаем контролы
        that.setDefaultsControls_();
        that.fillData_();
    }
};


CASExportForm.prototype.fillData_ = function(){
    //Устанавливаем минимальное и максимальное значения в поля ввода.
    $('#exportBeginKm').jqxNumberInput('val',this.minX);
    $('#exportEndKm').jqxNumberInput('val',this.maxX);

    //2D линейную диаграмму нужно разложить на отдельные геометрии, чтобы можно было выбирать каждый отдельный отчет
    var resObj = CASUtil.getGeoIfTwoDimension(this.layer);
    if(!(resObj instanceof Array))
        this.selectedItems = [resObj];
    else
        this.selectedItems = resObj;
};

CASExportForm.prototype.setDefaultsControls_ = function(){
    var that = this;
    $('#exportBeginKm').jqxNumberInput({promptChar: "", textAlign: "right",inputMode: 'simple',
        decimalDigits: 2, groupSeparator: "", min:this.minX,max:this.maxX,spinButtons: true, disabled:true,  height: '21px', width: '65px'});
    $('#exportEndKm').jqxNumberInput({promptChar: "", textAlign: "right",inputMode: 'simple',
        decimalDigits: 2, groupSeparator: "", min:this.minX,max:this.maxX,spinButtons: true, disabled:true,  height: '21px', width: '65px'});
    /*$('#exportBeginKm').jqxNumberInput({disabled:true,  height: 21, width: 70, spinButtons: true, min:this.minX,max:this.maxX});
    $('#exportEndKm').jqxNumberInput({disabled:true,  height: 21, width: 70, spinButtons: true, min:this.minX,max:this.maxX});*/
    $('#exportAddKm').jqxCheckBox({checked:true,disabled:false,theme:'cas-export'})
        .on('checked',function(event){

        })
        .on('unchecked',function(event){
        })
        .css('display','inline-block');

    $('#exportAll').change(function() {
        $('#exportBeginKm').jqxNumberInput({disabled:true});
        $('#exportEndKm').jqxNumberInput({disabled:true});
    });
    $('#exportVisible').change(function() {
        $('#exportBeginKm').jqxNumberInput({disabled:true});
        $('#exportEndKm').jqxNumberInput({disabled:true});
    });
    $('#exportCustom').change(function() {
        $('#exportBeginKm').jqxNumberInput({disabled:false});
        $('#exportEndKm').jqxNumberInput({disabled:false});
    });


    //кнопки "Отправить", "Отмена"
    $('#exportApply').on('click',function(){
        that.applyExport_();
        that.close();
    });
    $('#exportCancel').on('click',function(){
        that.close();
    });
};


CASExportForm.prototype.applyExport_ = function () {
    // проверяем, выбрал ли хотя бы 1 график, и экспортируем в таблицу Excel объекты
    CASUtil.getExportDataFromArr(this.selectedItems);
    //Объект, в котором будем сохранять все параметры слоев для возврата в предыдущее положение
    if(goog.isDef(this.layer) && goog.isDef(this.layer.layer)){
        var layer = this.layer.layer;
        var value = $('.exportFormDiv :checked').val();
        var result = '';
        if(value == '1')
            result = CASUtil.layersToHTMLTable(layer, $('#exportAddKm').jqxCheckBox('checked'), this.minX, this.maxX , '', this.selectedItems);
        if(value == '2')
            result = CASUtil.layersToHTMLTable(layer, $('#exportAddKm').jqxCheckBox('checked'), this.curMinX, this.curMaxX, '', this.selectedItems);
        if(value == '3')
            result = CASUtil.layersToHTMLTable(layer, $('#exportAddKm').jqxCheckBox('checked'), $('#exportBeginKm').jqxNumberInput('val'), $('#exportEndKm').jqxNumberInput('val'), '', this.selectedItems);
        if(result != ''){
            //показываем формы, в которую заносим данные, т.к. в буфер нельзя в ie скопировать
            //TODO для новых версий хрома сделать добавление в буфер
            this.showWindow(result);
        }
    }
};

CASExportForm.prototype.showWindow = function(result){
    $('#exportResultDialog').remove();
    var divv = '<div id="exportResultDialog" class="exportResultDialog">'+gis_casexportform_2 +
        '<textarea id="exportResultText" class="cas-export-text">' + result + '</textarea>' +
        '</div>';
    $('body').append(divv);
    var btns = {
        close :gis_linkmapcontrol_3
    };

    var dlg = $('#exportResultDialog');
    // Готовим кнопки, и добавляем обработчики
    var buttons = [];
    $.each(btns, function(name, text){
        buttons.push({
            text: text,
            click: function(){
                $('#exportResultDialog').remove();
            }
        });
    });
    //setTimeout(function() {
    //    WidgetMap.map.updateSize();
    //}, 100);
    dlg.dialog({
        modal: false,
        title: gis_casexportform_3,
        dialogClass: 'noCloseButton gsi-zindex__dialog',
        closeOnEscape: true,
        width: 474,
        height: 360,
        resizable: false,
        buttons : buttons
    });
    $('#exportResultText').select();
};

CASExportForm.prototype.close = function() {
    //Удаляем форму
    $('#exportDialog').remove();
};

CAS_SETTINGS_TYPES = {
    EXPAND : 'expand',
    ALLOW_TEXT : 'allowText',
    LAYERS_ORDER : 'layersOrder',
    EXPORT : 'export',
    NONE : 'none'
};
function CASSettingsForm(opt_options) {
    var options = opt_options !== undefined ? opt_options : {};
    this.title = (options.title !== undefined)?options.title:gis_cassettingsform_1;
    this.htmlUrl = 'ui/html/cas/CASLayersForm.html';
    this.closeCallback = (options.closeCallback !== undefined)?options.closeCallback:undefined;
    this.type = (options.type !== undefined)?options.type:CAS_SETTINGS_TYPES.NONE;


    //Коэффициент растяжения, применяемый в модуле ПКА для того чтобы данные по X растягивались в длину на всю карту
    this.curScaleXCoeff = (options.curScaleXCoeff !== undefined)?options.curScaleXCoeff:1;

    //Текущие значения километров
    this.curMinX = (options.curMinX !== undefined)?parseFloat(options.curMinX.toFixed(2)):0;
    this.curMaxX = (options.curMaxX !== undefined)?parseFloat(options.curMaxX.toFixed(2)):0;

    //Начальный и конечный километр (нужны для смещения координат)
    this.minX = (options.minX !== undefined)?parseFloat(options.minX.toFixed(2)):0;
    this.maxX = (options.maxX !== undefined)?parseFloat(options.maxX.toFixed(2)):0;
};

CASSettingsForm.prototype.build = function() {
    var that = this;
    var currDialog = $('#layersDialog');
    if(currDialog.length == 0){
        $('body').append('<div id="layersDialog" style="overflow: hidden;"></div>');
        $('#layersDialog').hide();
        currDialog = $('#layersDialog');
    }

    var dlg = currDialog;
    dlg.load(this.htmlUrl, build);
    function build() {
        dlg.dialog({
            modal: true,
            title: that.title,
            closeOnEscape: false,
            dialogClass: 'noCloseButton gsi-zindex__dialog' ,
            width: 500,
            height: 400,
            resizable: false
        });
        //заполняем данными элементы
        that.fillLayersGrid_();
        //кнопки "Отправить", "Отмена"
        $('#layersApply').on('click',function(){
            if(that.type == CAS_SETTINGS_TYPES.EXPORT )
                that.export_();
            else if(that.type == CAS_SETTINGS_TYPES.EXPAND)
                that.expand_();
            else
                that.applyLayers_();
            $('#layersDialog').remove();
        });
        $('#layersConcat').on('click',function(){
            if(that.type == CAS_SETTINGS_TYPES.LAYERS_ORDER ){
                that.concatLayers();
            }
            //that.applyLayers_();
            $('#layersDialog').remove();
        });
        $('#layersCancel').on('click',function(){
            $('#layersDialog').remove();
        });
    }
};

/**
 * Заполнение списка слоёв
 * @private
 */
CASSettingsForm.prototype.fillLayersGrid_ = function(){
    var that = this;
    if(goog.isDef(WidgetMap.layerManager)){
        var layers = WidgetMap.layerManager.getAllLayers();
        var treeGridLayers = [];
        var group = [];
        for (var i = 0; i < layers.length; i++) {
            var layerDescr = layers[i].layer.sourceDescr;
            if (layers[i].layer.legendDescr !== '')
                layerDescr = layers[i].layer.legendDescr;
            var obj = {
                LayerId: layers[i].layer.uniqueLayerName,
                LayerName: layerDescr,
                layer: layers[i].layer.name,
                allowText: '' + layers[i].isTextAllow,
                needScale: '' + layers[i].layer.needScale,
                visible: '' + layers[i].visible,
                concating: 'false',
                groupId: undefined,
            };
            if(layers[i].groupId){
                for(;i < layers.length; i++){
                    if(layers[i].groupId){
                        obj.groupId = layers[i].groupId;
                        //obj.group.push(layers[i]);
                        obj.LayerName = gis_cassettingsform_16;
                    }
                    else {
                        i--;
                        break;
                    }
                }
            }
            treeGridLayers.push(obj);
        }

        var source = {
            localdata: treeGridLayers,
            datatype: "array",
            datafields:
                [
                    { name: 'LayerId', type: 'string' },
                    { name: 'LayerName', type: 'string' },
                    { name: 'layer', type: 'string' },
                    { name: 'visible', type: 'string' },
                    { name: 'concating', type: 'string' },
                    { name: 'allowText', type: 'string' },
                    { name: 'editName', type: 'string' },
                    { name: 'needScale', type: 'string' },
                    { name: 'legend', type: 'string' },
                    { name: 'groupId', type: 'string' },
                ]
        };
        var layerNameColumnSize = 410;
        var layerNameColumnTitle = gis_cas_settings_list_header;
        var buttonApplyText = gis_cas_settings_button_apply;
        var buttonApplyWidth = 89;
        var layerNameSize = 62;
        if(this.type == CAS_SETTINGS_TYPES.EXPORT){
            buttonApplyText = gis_cas_exportdata_apply;
            buttonApplyWidth = 108;
            layerNameColumnSize = 490;
            layerNameSize = 82;
            layerNameColumnTitle = gis_cas_exportdata_list_header;
        }
        if(this.type == CAS_SETTINGS_TYPES.ALLOW_TEXT){
            layerNameColumnSize = 420;
            layerNameColumnSize -= 45;
        }
        if(this.type == CAS_SETTINGS_TYPES.EXPAND){
            buttonApplyText = gis_cas_expand_apply;
            buttonApplyWidth = 118;
            layerNameColumnSize = 490;
            layerNameSize = 82;
            layerNameColumnTitle = gis_cas_expand_list_header;
        }
        $('#layersApply').val(buttonApplyText).css('width',buttonApplyWidth);

        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#layersGrid").jqxGrid({
            width: 490,
            height: 330,
            source: dataAdapter,
            pageable: false,
            altRows: false,
            selectionmode:'singlerow',
            columnsResize: true,
            editable: true,
            theme:'gis-blue-grid',
            localization: getLocalization('ru'),
            columns: [
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'concating', columntype: 'string', width: 25,
                    cellsrenderer: function (row, column, value) {
                        if(value === 'true'){
                            return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='CASSettingsForm.prototype.setConcat_(this,"+row+")' checked></div>";
                        }
                        else{
                            return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='CASSettingsForm.prototype.setConcat_(this,"+row+")'></div>";
                        }
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'legend', columntype: 'string', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-legend-img' onclick='CASSettingsForm.prototype.showLegend_(this,"+row+")' title='"+gis_cassettingsform_17+"'></div>";
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'visible', columntype: 'string', width: 25,
                    cellsrenderer: function (row, column, value) {
                        if(value === 'true'){
                            return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='CASSettingsForm.prototype.setVisible_(this,"+row+")' checked></div>";
                        }
                        else{
                            return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='CASSettingsForm.prototype.setVisible_(this,"+row+")'></div>";
                        }
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'export', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-export-img' onclick='CASSettingsForm.prototype.export_(this,"+row+")' title='"+gis_cassettingsform_2+"'></div>";
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'expand', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-expand-img' onclick='that.expand_(this,"+value+")' title='"+gis_cassettingsform_3+"'></div>";
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'allowText', columntype: 'string', width: 25,
                    cellsrenderer: function (row, column, value) {
                        if(value == 'true'){
                            return "<div type='submit' class='cas-img cas-allowtext-img' onclick='CASSettingsForm.prototype.allowText_(this,"+row+")' title='"+gis_cassettingsform_4+"'></div>";
                        }
                        else{
                            return "<div type='submit' style='opacity: 0.3;' class='cas-img cas-allowtext-img' onclick='CASSettingsForm.prototype.allowText_(this,"+row+")' title='"+gis_cassettingsform_5+"'></div>";
                        }
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'editName', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-editname-img' onclick='CASSettingsForm.prototype.editName_(this,"+row+")' title='"+gis_cassettingsform_6+"'></div>";
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'needScale', columntype: 'string', width: 25,
                    cellsrenderer: function (row, column, value) {
                        if(value == 'true'){
                            return "<div type='submit' class='cas-img cas-needscale-img' onclick='CASSettingsForm.prototype.needScale_(this,"+row+")' title='"+gis_cassettingsform_7+"'></div>";
                        }
                        else{
                            return "<div type='submit' style='opacity: 0.3;' class='cas-img cas-needscale-img' onclick='CASSettingsForm.prototype.needScale_(this,"+row+")' title='"+gis_cassettingsform_8+"'></div>";
                        }
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'up', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-up-img' onclick='CASSettingsForm.prototype.upLayer_(this,"+value+")' title='"+gis_cassettingsform_9+"'></div>";
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'down', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-down-img' onclick='CASSettingsForm.prototype.downLayer_(this,"+value+")' title='"+gis_cassettingsform_10+"'></div>";
                    }
                },
                {   text: layerNameColumnTitle, datafield: 'LayerName',
                    sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    columntype: 'string', width: layerNameColumnSize,
                    cellsrenderer: function (row, column, value) {
                        var rValue = value;
                        if(value.length>layerNameSize)//добавляем к названию ...
                            rValue = rValue.substring(0,layerNameSize)+'...';
                        return "<div style='margin:4px;' title='"+value+"'>" + (rValue) + "</div>";
                    }
                }
            ]
        }).on('rowselect', function (event){
            var args = event.args;
            var rowBoundIndex = args.rowindex;
            if(rowBoundIndex!=-1 || that.type == CAS_SETTINGS_TYPES.ALLOW_TEXT || that.type == CAS_SETTINGS_TYPES.LAYERS_ORDER)
                $('#layersApply').attr("disabled", false);
            else
                $('#layersApply').attr("disabled", true);
        });
        switch(this.type){
            case CAS_SETTINGS_TYPES.ALLOW_TEXT:
                $('#layersGrid').jqxGrid('hidecolumn', 'expand');
                $('#layersGrid').jqxGrid('hidecolumn', 'export');
                $('#layersGrid').jqxGrid('hidecolumn', 'up');
                $('#layersGrid').jqxGrid('hidecolumn', 'down');
                $('#layersGrid').jqxGrid('hidecolumn', 'concating');
                $('#layersGrid').jqxGrid('hidecolumn', 'legend');
                $('#layersApply').attr("disabled", false);
                $('#layersConcat').hide();
                break;
            case CAS_SETTINGS_TYPES.EXPAND:
                $('#layersGrid').jqxGrid('hidecolumn', 'allowText');
                $('#layersGrid').jqxGrid('hidecolumn', 'editName');
                $('#layersGrid').jqxGrid('hidecolumn', 'needScale');
                $('#layersGrid').jqxGrid('hidecolumn', 'expand');
                $('#layersGrid').jqxGrid('hidecolumn', 'export');
                $('#layersGrid').jqxGrid('hidecolumn', 'up');
                $('#layersGrid').jqxGrid('hidecolumn', 'down');
                $('#layersGrid').jqxGrid('hidecolumn', 'visible');
                $('#layersGrid').jqxGrid('hidecolumn', 'concating');
                $('#layersGrid').jqxGrid('hidecolumn', 'legend');
                $('#layersApply').attr("disabled", true);
                $('#layersConcat').hide();
                break;
            case CAS_SETTINGS_TYPES.EXPORT:
                $('#layersGrid').jqxGrid('hidecolumn', 'expand');
                $('#layersGrid').jqxGrid('hidecolumn', 'export');
                $('#layersGrid').jqxGrid('hidecolumn', 'needScale');
                $('#layersGrid').jqxGrid('hidecolumn', 'allowText');
                $('#layersGrid').jqxGrid('hidecolumn', 'editName');
                $('#layersGrid').jqxGrid('hidecolumn', 'up');
                $('#layersGrid').jqxGrid('hidecolumn', 'down');
                $('#layersGrid').jqxGrid('hidecolumn', 'visible');
                $('#layersGrid').jqxGrid('hidecolumn', 'concating');
                $('#layersGrid').jqxGrid('hidecolumn', 'legend');
                $('#layersApply').attr("disabled", true);
                $('#layersConcat').hide();
                break;
            case CAS_SETTINGS_TYPES.LAYERS_ORDER:
                $('#layersGrid').jqxGrid('hidecolumn', 'expand');
                $('#layersGrid').jqxGrid('hidecolumn', 'export');
                $('#layersGrid').jqxGrid('hidecolumn', 'needScale');
                $('#layersGrid').jqxGrid('hidecolumn', 'allowText');
                $('#layersGrid').jqxGrid('hidecolumn', 'editName');
                $('#layersGrid').jqxGrid('hidecolumn', 'visible');
                $('#layersApply').attr("disabled", false);
                //добавляем видимость кнопки объединения графиков
                $('#layersConcat').show();
                $('.layersButtons').css('margin-left', '113px');
                break;
        }
    }
};

/**
 * Передвигаем меняем местами график
 * @param elem
 * @param row
 * @private
 */
CASSettingsForm.prototype.upLayer_ = function(elem, index){
    //получаем весь список, там переносим в нужные позиции и заполняем грид
    var rows = $("#layersGrid").jqxGrid('getrows');
    if(index!=0){
        //если это групповой график, то не перемещаем наверх обычные
        var prevRow = rows[index-1];
        if(prevRow && prevRow.groupId){
            return;
        }
        var temp = rows[index];
        rows[index] = rows[index-1];
        rows[index-1] = temp;

        var source ={
            localdata: rows,
            datatype: "array",
            datafields:
                [
                    { name: 'LayerId', type: 'string' },
                    { name: 'LayerName', type: 'string' },
                    { name: 'layer', type: 'string' },
                    { name: 'allowText', type: 'string' },
                    { name: 'concating', type: 'string' }
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#layersGrid").jqxGrid({ source: dataAdapter});
        $("#layersGrid").jqxGrid('selectrow', index-1);
    }
};
/**
 * Передвигаем меняем местами график
 * @param elem
 * @param row
 * @private
 */
CASSettingsForm.prototype.downLayer_ = function(elem, index){
    var rows = $("#layersGrid").jqxGrid('getrows');
    if(index!=rows.length-1){
        //если это групповой график, то игнорируем сдвиг
        var curRow = rows[index];
        if(curRow && curRow.groupId){
            return;
        }
        var temp = rows[index];
        rows[index] = rows[index+1];
        rows[index+1] = temp;

        var source ={
            localdata: rows,
            datatype: "array",
            datafields:
                [
                    { name: 'LayerId', type: 'string' },
                    { name: 'LayerName', type: 'string' },
                    { name: 'layer', type: 'string' },
                    { name: 'allowText', type: 'string' },
                    { name: 'concating', type: 'string' }
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#layersGrid").jqxGrid({ source: dataAdapter});
        $("#layersGrid").jqxGrid('selectrow', index+1);
    }
};

/**
 * Вкл/выкл подписи на карте для слоя
 * @param elem
 * @param rowKey
 */
CASSettingsForm.prototype.allowText_ = function(elem, rowKey){
    //если видимость слоя выключили, то никаких реакций на кнопки не будет
    var opacity = ''+$(elem).css('opacity');
    if(opacity === '0.3')
        $("#layersGrid").jqxGrid('setcellvalue',rowKey,'allowText','true');
    else
        $("#layersGrid").jqxGrid('setcellvalue',rowKey,'allowText','false');
};

/**
 * Функция управления видимостью слоя
 * @param elem
 * @param rowKey
 * @private
 */
CASSettingsForm.prototype.setVisible_ = function(elem, rowKey){
    var isChecked = ''+$(elem).prop('checked');
    $("#layersGrid").jqxGrid('setcellvalue',rowKey,'visible', ''+ isChecked);
};

/**
 * Функция управления слиянием графиков
 * @param elem
 * @param rowKey
 * @private
 */
CASSettingsForm.prototype.setConcat_ = function(elem, rowKey){
    var isChecked = ''+$(elem).prop('checked');
    $("#layersGrid").jqxGrid('setcellvalue',rowKey,'concating', ''+ isChecked);
};


/**
 * Вкл/выкл шкалу с километрами
 * @param img
 * @param rowKey
 */
CASSettingsForm.prototype.needScale_ = function(img, rowKey){
    //если видимость слоя выключили, то никаких реакций на кнопки не будет
    var opacity = ''+$(img).css('opacity');
    if(opacity == '0.3')
        $("#layersGrid").jqxGrid('setcellvalue',rowKey,'needScale','true');
    else
        $("#layersGrid").jqxGrid('setcellvalue',rowKey,'needScale','false');
};

CASSettingsForm.prototype.export1_ = function(elem, row){
    var item = $("#layersGrid").jqxGrid('getrowdata',row);
    var layer = WidgetMap.layerManager.getLayerByName(item.LayerId);
    if(goog.isDef(layer)){
        var casExportForm = new CASExportForm({layer:layer,curScaleXCoeff:this.curScaleXCoeff,curMinX:this.curMinX,curMaxX:this.curMaxX,minX:this.minX,maxX:this.maxX});
        casExportForm.build();
    }
};

CASSettingsForm.prototype.export_ = function(){
    var rowindex = $('#layersGrid').jqxGrid('getselectedrowindex');
    var item = $("#layersGrid").jqxGrid('getrowdata',rowindex);
    var layer = WidgetMap.layerManager.getLayerByName(item.LayerId);
    if(goog.isDef(layer)){
        var casExportForm = new CASExportForm({layer:layer,curScaleXCoeff:layer.layer.scaleXCoeff_,curMinX:this.curMinX,curMaxX:this.curMaxX,minX:this.minX,maxX:this.maxX});
        casExportForm.build();
    }
};

CASSettingsForm.prototype.showLegend_ = function(){
    var rowindex = $('#layersGrid').jqxGrid('getselectedrowindex');
    var item = $("#layersGrid").jqxGrid('getrowdata',rowindex);
    var layers = [];
    if(item.groupId){
        layers = WidgetMap.layerManager.getCasLayerByGroupId(Number(item.groupId));
    }
    else{
        var layObj = WidgetMap.layerManager.getLayerByName(item.LayerId);
        if(layObj) layers.push(layObj);
    }
    $('#cas_showLegendModal').remove();
    var elementId = 'cas_showLegendModal';
    var div = '<div id="' + elementId + '" style="padding: 10px;"><div style="width: 100%; height: 100%; overflow-y: scroll;">';
        layers.forEach(function(layer){
            var groupIndex = (layer.layer.groupIndex !== undefined)? layer.layer.groupIndex : WidgetMap.layerManager.getCasLayerStyleColorByName(item.LayerId);
            //попытка получить иконку
            var layerStyleColor = 'background-color:' + CHART_COLORS[groupIndex];
            var classStyle = 'legend_cas_polygon';
            if(layer.layer.drawTypes.indexOf('polygon') !== -1) {
                classStyle = 'legend_cas_polygon';
                if(!layer.layer.groupId){
                    var feature = layer.layer.featureProjLayer.getSource().getSource().getFeatures()[0];
                    var lId = feature.get('layerId').split('#')[0];
                    var splitted = feature.get('type').split('#');
                    var lType = splitted[0];//из типа надо вычленить уникальный id: от # до первого _
                    var typeStr = '';
                    if(splitted.length>1){
                        var sp = splitted[1].split('_');
                        if(sp.length>1){
                            //удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
                            sp.splice(0,1);
                            typeStr ='_'+sp.join('_');
                            lType += typeStr;
                        }
                    }

                    var origPolygonStyle = WidgetMap.layerManager.getOrigStyleByNameAndType([layer.dataProvider.style + typeStr, lType, lId] ,'Polygon');
                    if(origPolygonStyle && origPolygonStyle.polyObj && origPolygonStyle.polyObj.color && origPolygonStyle.polyObj.color.length === 8){
                        var alpha = parseInt((parseInt('0x0000' + origPolygonStyle.polyObj.color.substr(0, 2), 16) / 255) * 100) / 100;
                        var col = 'rgba(' + parseInt(origPolygonStyle.polyObj.color.substr(2, 2), 16) + ', ' + parseInt(origPolygonStyle.polyObj.color.substr(4, 2), 16) + ', ' + parseInt(origPolygonStyle.polyObj.color.substr(6, 2), 16) + ', ' + alpha + ')';
                        layerStyleColor = 'background-color:'+col;
                    }
                }
                else{
                    var horizontalStyle = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('GROUP_POSITION_HORIZONTAL_' + groupIndex,'Polygon');
                    if(horizontalStyle && horizontalStyle.polyObj && horizontalStyle.polyObj.color && horizontalStyle.polyObj.color.length === 8){
                        var alpha = parseInt((parseInt('0x0000' + horizontalStyle.polyObj.color.substr(0, 2), 16) / 255) * 100) / 100;
                        var col = 'rgba(' + parseInt(horizontalStyle.polyObj.color.substr(2, 2), 16) + ', ' + parseInt(horizontalStyle.polyObj.color.substr(4, 2), 16) + ', ' + parseInt(horizontalStyle.polyObj.color.substr(6, 2), 16) + ', ' + alpha + ')';
                        layerStyleColor = 'background-color:'+col;
                    }
                }
            }
            if(layer.layer.drawTypes.indexOf('line') !== -1) {
                classStyle = 'legend_cas_line';
            }
            if(layer.layer.drawTypes.indexOf('point') !== -1) {
                classStyle = 'legend_cas_point';
            }


            if(classStyle === 'legend_cas_line' && !layer.layer.groupId){
                var feature = layer.layer.featureProjLayer.getSource().getSource().getFeatures()[0];
                var lId = feature.get('layerId').split('#')[0];
                var splitted = feature.get('type').split('#');
                var lType = splitted[0];//из типа надо вычленить уникальный id: от # до первого _
                var typeStr = '';
                if(splitted.length>1){
                    var sp = splitted[1].split('_');
                    if(sp.length>1){
                        //удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
                        sp.splice(0,1);
                        typeStr ='_'+sp.join('_');
                        lType += typeStr;
                    }
                }
                var origLineStringStyle = WidgetMap.layerManager.getOrigStyleByNameAndType([layer.dataProvider.style + typeStr, lType, lId] ,'LineString');
                if(origLineStringStyle && origLineStringStyle.lineObj && origLineStringStyle.lineObj.color && origLineStringStyle.lineObj.color.length === 8){
                    layerStyleColor = 'background-color:#' + origLineStringStyle.lineObj.color.substr(2, 6);
                }
            }
            if(classStyle === 'legend_cas_point'){
                try{
                    var feature = layer.layer.featureProjLayer.getSource().getSource().getFeatures()[0];
                    var lId = feature.get('layerId').split('#')[0];
                    var splitted = feature.get('type').split('#');
                    var lType = splitted[0];//из типа надо вычленить уникальный id: от # до первого _
                    var typeStr = '';
                    if(splitted.length>1){
                        var sp = splitted[1].split('_');
                        if(sp.length>1){
                            //удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
                            sp.splice(0,1);
                            typeStr ='_'+sp.join('_');
                            lType += typeStr;
                        }
                    }
                    var origPointStyle = WidgetMap.layerManager.getOrigStyleByNameAndType([layer.dataProvider.style + typeStr, lType, lId] ,'Point');
                    if(origPointStyle && origPointStyle.pointObj && origPointStyle.pointObj.form === 'bitmap'){
                        classStyle = 'legend_cas_default';
                        layerStyleColor = 'background-image:url(' + origPointStyle.pointObj.href + ');';
                    }
                }
                catch (e) { }
            }

            div += '<div class="legend_cas">' +
                '<div class="' + classStyle + '" style="' + layerStyleColor + '"></div>' +
                '<span style="width: 340px;">' + layer.layer.legendDescr + '</span>' +
                '</div>';
        });
        div += '</div></div>';
    $('body').append(div);
    var dlg = $('#'+elementId);
    dlg.dialog({
        modal: true,
        title: 'Легенда',
        dialogClass: 'gsi-zindex__dialog cas-legend-dialog',
        closeOnEscape: true,
        width: 415,
        height: 238,
        resizable: false,
        close: function () {
            App.destroyDialog(null, dlg);
        }
    });
};



CASSettingsForm.prototype.expand_ = function(){
    var rowindex = $('#layersGrid').jqxGrid('getselectedrowindex');
    var item = $("#layersGrid").jqxGrid('getrowdata',rowindex);
    if(goog.isDef(item)){
        var layer = WidgetMap.layerManager.getLayerByName(item.LayerId);
        this.showExpandWindow_(layer);
    }

};

CASSettingsForm.prototype.showExpandWindow_ = function(layer){
    var that = this;
    $('#expandLayerDialog').remove();
    var divv = '<div id="expandLayerDialog" class="expandLayerDialog">' +
        '<div id="exportResultText" class="cas-expand-text"></div>' +
        gis_cassettingsform_11+'</div>';
    $('body').append(divv);
    var btns = {apply :gis_cassettingsform_12,cancel:gis_cassettingsform_13};

    var dlg = $('#expandLayerDialog');
    // Готовим кнопки, и добавляем обработчики
    var buttons = [];
    $.each(btns, function(name, text){
        buttons.push({
            class:'map-dialog-button',
            text: text,
            click: function(){
                if(name == 'apply'){
                    var expandValue = $('#exportResultText').jqxNumberInput('val');
                    if(layer.layer.groupId)
                        WidgetMap.layerManager.setExpandValueToGroupLayers(expandValue, layer.layer.groupId);
                    else
                        layer.layer.expandValue = expandValue
                    WidgetMap.redrawAllLayers();
                }
                $('#expandLayerDialog').remove();
            }
        });
    });
    $('#exportResultText').jqxNumberInput({promptChar: "", textAlign: "left",inputMode: 'simple',
        decimalDigits: 0, groupSeparator: "", min:0,max:5000,spinButtons: true, height: '25px', width: '65px'});
    $('#exportResultText').jqxNumberInput('val',layer.layer.expandValue);
    dlg.dialog({
        modal: false,
        title: gis_cassettingsform_14,
        dialogClass: 'noCloseButton gsi-zindex__dialog',
        closeOnEscape: true,
        width: 244,
        height: 120,
        resizable: false,
        buttons : buttons
    });
};


CASSettingsForm.prototype.editName_ = function(elem, index){
    var item = $("#layersGrid").jqxGrid('getrowdata',index);
    if(goog.isDef(item)){
        var layer = WidgetMap.layerManager.getLayerByName(item.LayerId);
        this.showEditNameWindow_(layer,index);
    }

};

CASSettingsForm.prototype.showEditNameWindow_ = function(layer,index){
    var that = this;
    $('#editNameLayerDialog').remove();
    var divv = '<div id="editNameLayerDialog" class="expandLayerDialog">' +
        //'<div id="editNameText" contenteditable="true" class="cas-editname-text"></div>';
        '<textarea id="editNameText" class="cas-editname-text"></textarea>';
    $('body').append(divv);
    var btns = {apply :gis_cassettingsform_12,cancel:gis_cassettingsform_13};

    var dlg = $('#editNameLayerDialog');
    // Готовим кнопки, и добавляем обработчики
    var buttons = [];
    $('#editNameText').val(layer.layer.legendDescr);
    $.each(btns, function(name, text){
        buttons.push({
            class:'map-dialog-button',
            text: text,
            click: function(){
                if(name == 'apply'){
                    layer.layer.legendDescr = $('#editNameText').val();
                    $("#layersGrid").jqxGrid('setcellvalue',index,'LayerName',layer.layer.legendDescr);
                }
                $('#editNameLayerDialog').remove();
            }
        });
    });
    dlg.dialog({
        modal: true,
        title: gis_cassettingsform_15,
        dialogClass: 'noCloseButton gsi-zindex__dialog',
        closeOnEscape: true,
        width: 344,
        height: 180,
        resizable: true,
        buttons : buttons
    });
};

/**
 * Применяем видимость и показ подписей к слоям
 * @private
 */
CASSettingsForm.prototype.applyLayers_ = function() {
    var rows = $("#layersGrid").jqxGrid('getrows');
    var i,j;
    var resultLayersArr = [];
    //обновляем легенду
    cashelper.refreshLegend();
    var layersArr = WidgetMap.layerManager.getVectorLayersByMode();
    if(this.type == CAS_SETTINGS_TYPES.ALLOW_TEXT){
        var needRedrawMap = false;// нужно ли перерисовывать всю карту и пересчитывать(когда видимость  слоёв поменялась)
        for(i in rows){
            var layer = WidgetMap.layerManager.getLayerByName(rows[i].LayerId);
            //устанавливаем подписи
            var isCurrAllow = rows[i].allowText === 'true';
            var isCurrVisible = rows[i].visible === 'true';
            if(isCurrAllow !== layer.isTextAllow){
                layer.isTextAllow = isCurrAllow;
                layer.layer.setVisibleText(layer.isTextAllow);
            }
            if(isCurrVisible !== layer.visible){
                needRedrawMap = true;
                layer.visible = isCurrVisible;
                layer.layer.setVisible(layer.visible);
            }
            layer.layer.featureProjLayer.getSource().getSource().changed();
        }
        var needScaleChanged = false;
        for(i in rows){
            var layer = WidgetMap.layerManager.getLayerByName(rows[i].LayerId);
            //устанавливаем флаг
            var needScale = rows[i].needScale === 'true';
            if(needScale === layer.layer.needScale)
                continue;
            needScaleChanged = true;
            layer.layer.needScale = needScale;
        }
        if(needScaleChanged)
            cashelper.refreshXAxis();
        if(needRedrawMap)
            WidgetMap.redrawAllLayers()

    }
    else{
        if(this.type == CAS_SETTINGS_TYPES.LAYERS_ORDER ){
            /*WidgetMap.finalLayers = resultLayersArr;
            cashelper.loadAllLayersData();
            cashelper.loadMapRect();
            var lineData = {
                LINE_ID: WidgetMap.LINE_ID,
                KM_START: WidgetMap.BEGIN_KM,
                KM_END: WidgetMap.END_KM,
            }
            WidgetMap.getLineProfile(lineData);
            return;*/
        }
        for(i in rows){
            for(j in layersArr){
                if(rows[i].LayerId == layersArr[j].layer.uniqueLayerName)
                    resultLayersArr.push(layersArr[j]);
            }
        }
        WidgetMap.layerManager._layers = resultLayersArr;
        WidgetMap.redrawAllLayers();
    }

};



CASSettingsForm.prototype.concatLayers = function() {
    var rows = $("#layersGrid").jqxGrid('getrows');
    var i,j;
    var resultLayersArr = [];
    //var layersArr = WidgetMap.layerManager.getVectorLayersByMode();
    var concatLayers = [];
    var basicLayers = [];
    for (i in rows) {
        var l = WidgetMap.layerManager.getLayerByName(rows[i].LayerId);
        //upd.14.04.22 При нажатии объединить, старое объединение пропадает и создается новый объединенный график
        if(l && l.groupId)
            continue;
        var filterAsParam = undefined;
        var selectedLineObj = undefined;
        if (l && l.layer && l.layer.filterAsParam)
            filterAsParam = l.layer.filterAsParam;
        if (l && l.layer && l.layer.selectedLineObj)
            selectedLineObj = l.layer.selectedLineObj;
        var basicLayer = rows[i];
        basicLayer.filterAsParam = filterAsParam;
        basicLayer.selectedLineObj = selectedLineObj;
        basicLayers.push(basicLayer); //собрали остальные слои
        if (basicLayer.concating === 'true') { //собрали слои для слияния
            var concatLayer = $.extend({}, basicLayer);
            //добавляем этому слою ещё условие с фильтром, чтобы не затиралось
            concatLayers.push(concatLayer);
        }

    }
    if(concatLayers.length < 2){
        App.confirmDialog(gis_cassettingsform_18, null,{title:gis_core_1});
        return;
    }

    var unique = Date.now();
    concatLayers.forEach(function(cLayer, i){
        cLayer.LayerId = cLayer.layer + '#' + Date.now() + '' + i;
        cLayer.groupId = unique;
    });
    resultLayersArr = resultLayersArr.concat(concatLayers, basicLayers);

    //удаляем ненужные слои
    WidgetMap.layerManager.removeAllCASLayers();

    if(concatLayers && concatLayers.length){
        //копируем слои
        var baseLayer = concatLayers[0];
        WidgetMap.layerManager.copyCASLayers(resultLayersArr);
        var newData = {LayerId:baseLayer.LayerId+'#'+unique, LayerName: gis_cassettingsform_16, layer:baseLayer.layer, LayerDescr:gis_cassettingsform_16, groupId: unique};
        $('#layersGrid').jqxGrid('addrow', unique, newData, 'first');
    }
    $("#layersGrid").jqxGrid('clearselection');

    WidgetMap.finalLayers = resultLayersArr;
    var zoneId = getParameterByName('ZONE_ID');
    var lineData = {
        LINE_ID: WidgetMap.LINE_ID,
        KM_START: WidgetMap.BEGIN_KM,
        KM_END: WidgetMap.END_KM,
        ZONE_ID: zoneId,
        START_KM: WidgetMap.BEGIN_KM,
        FINISH_KM: WidgetMap.END_KM,
    }

    $('#CAS').css('visibility','hidden')
    cashelper.loadAllLayersData();
    cashelper.loadMapRect();
    WidgetMap.getLineProfile(lineData, function(){

    });
    //WidgetMap.layerManager._layers = resultLayersArr;
    //WidgetMap.redrawAllLayers();

};
//счетчик количества слоёв для уникальности
CASLayersBaseFormCounter = {};

/**
 * Базовый класс управления слоями. Используется при начальной настройке слоёв ПКА
 * @param opt_options
 * @constructor
 */
function CASLayersBaseForm(opt_options) {
    var options = opt_options !== undefined ? opt_options : {};
    this.title = (options.title !== undefined)?options.title:gis_caslayersform_1;
    this.closeOnEscape = (options.closeOnEscape !== undefined)?options.closeOnEscape:false;
    this.dialogClass = (options.closeOnEscape !== undefined)?options.closeOnEscape:false;
    this.closable = options.closable ? '' : 'noCloseButton';
    this.htmlUrl = 'ui/html/cas/CASManageLayersForm.html';
    this.closeCallback = (options.closeCallback !== undefined)?options.closeCallback:undefined;
    this.startupLayers = ['CAS_DEPTH_OF_COVER','CAS_PROFILE'];
    this.waterwayProfiles = options.waterwayProfiles || [];
    this.applyStartupLayers = false;
    if(options.startupLayers !== undefined && options.startupLayers.length > 0){
        this.startupLayers = options.startupLayers;
        this.applyStartupLayers = true;
    }
};

CASLayersBaseForm.prototype.build = function() {
    var that = this;
    var currDialog = $('#manageLayersDialog');
    if(this.applyStartupLayers){
        this.applyStartupLayers_();
        return;
    }

    if(currDialog.length == 0){
        $('body').append('<div id="manageLayersDialog" overflow: hidden;"></div>');
        $('#manageLayersDialog').hide();
        currDialog = $('#manageLayersDialog');
    }

    var dlg = currDialog;
    dlg.load(this.htmlUrl, build);
    function build() {
        dlg.dialog({
            modal: true,
            title: that.title,
            closeOnEscape: that.closeOnEscape,
            dialogClass: 'gsi-zindex__dialog',
            width: 1023,
            height: 400,
            resizable: false
        });
        //заполняем данными элементы
        that.fillLayersGrid_();
        that.fillResultLayersGrid_();

        $('#manageLayersAdd').on('click',function(){
            var selected = $("#manageLayersGrid").jqxTreeGrid('getSelection');
            if(goog.isDef(selected) && selected.length>0 && selected[0].leaf == true)
                that.addLayer_(undefined,-1,selected[0]);
            return false;
        });
        //кнопки "Отправить", "Отмена"
        $('#manageLayersApply').on('click',function(){
            that.applyLayers_();
        });
    }
};

/**
 * Заполнение списка слоёв
 * @private
 */
CASLayersBaseForm.prototype.fillLayersGrid_ = function(){
    if(goog.isDef(WidgetMap.layerManager)){
        var layers = WidgetMap.layerManager.getAllSortedLayers();
        var treeGridLayers = [];
        for(var i=0; i<layers.length; i++){
            var obj = {LayerId:i, LayerName:layers[i].layer.sourceDescr,
                MapName:layers[i].layer.mapName.replace('\\n',''), layer:layers[i].layer.name,
                add:true};
            treeGridLayers.push(obj);
        }
        var source = {
            dataType: "array",
            dataFields: [
                { name: 'LayerID', type: 'number' },
                { name: 'LayerName', type: 'string' },
                { name: 'MapName', type: 'string' },
                { name: 'layer', type: 'string'},
                { name: 'icon', type: 'string' },
                { name: "add", type: "string" }
            ],
            hierarchy:{groupingDataFields:[{name: "MapName"}]},
            id: 'LayerID',
            localData: treeGridLayers
        };
        var dataAdapter = new $.jqx.dataAdapter(source, {
            loadComplete: function () {
            }
        });
        var columns = [
            { text: "", align: "left", dataField: "empty", width: 35 },
            {
                text: '', dataField: 'add', width: 25,sortable:false,
                cellsRenderer: function (rowKey, dataField, value, data) {
                    return "<div><img style='width:16px;height:16px;' onclick='CASLayersBaseForm.prototype.addLayer_(this,"+rowKey+")' src='./ui/images/addObject.png' title='Добавить график в состав отображаемых' /></div>";
                }
            },
            { text: gis_caslayersform_2, dataField: 'LayerName', width: 420 }
        ];
        $("#manageLayersGrid").jqxTreeGrid(
            {
                source: dataAdapter,
                altRows: true,
                sortable: true,
                width: 490,
                height: 330,
                selectionMode:'singleRow',
                columnsResize: false,
                localization: getLocalization('ru'),
                theme:'gis-blue-treegrid',
                icons: function (rowKey, rowData) {
                    var level = rowData.level;
                    if (level == 0) {
                        return "./ui/images/folder_icon.png";
                    }
                    return false;
                },
                checkboxes: false,
                ready: function () {
                },
                columns: columns
            })
            .on('rowSelect',
            function (event){
                // event args.
                var args = event.args;
                // row data.
                var row = args.row;
                // row key.
                var key = args.key;
                if(row === undefined){
                    var lRow = $(this).jqxTreeGrid('getRow',key);
                    if(lRow.expanded)
                        $(this).jqxTreeGrid('collapseRow',key);
                    else
                        $(this).jqxTreeGrid('expandRow',key);
                }

            });
        $("#manageLayersGrid .iconscontainer").remove();
    }
};


/**
 * Заполнение списка слоёв
 * @private
 */
CASLayersBaseForm.prototype.fillResultLayersGrid_ = function(){
    if(goog.isDef(WidgetMap.layerManager)){
        var treeGridLayers = [];
        var source ={
            localdata: treeGridLayers,
            datatype: "array",
            id: "LayerId",
            datafields:
                [
                    { name: 'LayerId', type: 'string' },
                    { name: 'LayerName', type: 'string' },
                    { name: 'layer', type: 'string' },
                    { name: 'LayerDescr', type: 'string' }
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#manageLayersResultGrid").jqxGrid({
            width: 490,
            height: 330,
            source: dataAdapter,
            pageable: false,
            altRows: false,
            columnsResize: false,
            editable: false,
            theme:'gis-blue-grid',
            localization: getLocalization('ru'),
            columns: [
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'up', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-up-img' onclick='CASLayersBaseForm.prototype.upLayer_(this,"+value+")' title='"+gis_caslayersform_3+"'></div>";
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'down', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-down-img' onclick='CASLayersBaseForm.prototype.downLayer_(this,"+value+")' title='"+gis_caslayersform_4+"'></div>";
                    }
                },
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'delete', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-delete-img' onclick='CASLayersBaseForm.prototype.removeLayer_("+row+")' title='"+gis_caslayersform_5+"'></div>";
                    }
                },
                {   text: gis_caslayersform_6, datafield: 'LayerDescr',
                    sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    columntype: 'string', width: 400,
                    cellsrenderer: function (row, column, value) {
                        var rValue = value;
                        var tValue = value;
                        if(value.length>62)//добавляем к названию ...
                            rValue = rValue.substring(0,62)+'...';
                        if(value.length>400)//добавляем к подсказке ...
                            tValue = tValue.substring(0,400)+'...';
                        return "<div style='margin:4px;' title='"+tValue+"'>" + (rValue) + "</div>";
                    }
                }
            ]
        });

        this.addStartupLayers_();
    }
};

/**
 * Добавление в результирующий список слоёв из сценария задачи
 * @private
 */
CASLayersBaseForm.prototype.addStartupLayers_ = function(){
    var that = this;
    if(this.startupLayers !== undefined && this.startupLayers.length > 0){
        var layerName = this.startupLayers.pop();
        var layer = WidgetMap.layerManager.getLayerByName(layerName);
        var unique = Date.now();
        if(goog.isDef(layer) && goog.isDef(layer.layer)){
            //проверяем, есть ли фильтр
            if(!goog.isDef(layer.layer.spatialVariables) ){
                //если переменные не в процессе загрузки
                if(!layer.layer.inSpatialRequest ){
                    //блокируем приложение, чтобы лишних установок видимости и прочего не происходило
                    layer.layer.loadSpatialCallback = function(lay){
                        var layerDescr = lay.sourceDescr;
                        if(lay.spatialVariables && goog.isDef(lay.spatialVariables.LABEL) && lay.spatialVariables.LABEL != '')
                            layerDescr = lay.spatialVariables.LABEL;
                        layerDescr += that.addCounter(lay);
                        var newData = {LayerId:lay.name+'#'+unique, LayerName:lay.sourceDescr,layer:lay.name, LayerDescr:layerDescr};
                        that.addRow_(newData);
                        that.addStartupLayers_();
                    };
                    layer.layer.loadSpatial();
                }
            }
            else{
                var layerDescr = layer.layer.sourceDescr;
                if(layer.layer.spatialVariables &&  goog.isDef(layer.layer.spatialVariables.LABEL) && layer.layer.spatialVariables.LABEL != '')
                    layerDescr = layer.layer.spatialVariables.LABEL;
                layerDescr += that.addCounter(layer.layer);
                var newData = {LayerId:layer.layer.name+'#'+unique, LayerName:layerDescr,layer:layer.layer.name, LayerDescr:layerDescr};
                that.addRow_(newData);
                that.addStartupLayers_();
            }
        }
    }
    /*else
        if(this.applyStartupLayers)
            this.applyLayers_();*/
};


/**
 * Добавление слоя в результирующий список
 * @param elem
 * @param row
 * @param item
 * @private
 */
CASLayersBaseForm.prototype.addLayer_ = function(elem, row, item){
    var that = this;
    var lineId = WidgetMap.LINE_ID, beginKm = WidgetMap.BEGIN_KM, endKm = WidgetMap.END_KM;
    if(WidgetMap.selectedLineObj){
        lineId = WidgetMap.selectedLineObj.lineId;
        beginKm = WidgetMap.selectedLineObj.lineStartKm;
        endKm = WidgetMap.selectedLineObj.lineEndKm;
    }
    that.addParams = '<data LINE_ID="'+lineId+'" START_KM="'+beginKm+'" FINISH_KM="'+endKm+'" />';
    if(!goog.isDef(item))
        item = $("#manageLayersGrid").jqxTreeGrid('getRow',row);
    var layer = WidgetMap.layerManager.getLayerByName(item.layer);
    var unique = Date.now();
    if(goog.isDef(layer) && goog.isDef(layer.layer)){
        //проверяем, есть ли фильтр
        if(!goog.isDef(layer.layer.spatialVariables) ){
            //если переменные не в процессе загрузки
            if(!layer.layer.inSpatialRequest ){
                //блокируем приложение, чтобы лишних установок видимости и прочего не происходило
                layer.layer.loadSpatialCallback = function(lay){
                    if(goog.isDef(lay) && goog.isDef(lay.spatialVariables) && goog.isDef(lay.spatialVariables.FILTERED_CLASS)){
                        //грузим фильтр и заполняем окошко
                        lay.loadFilterFile(function(layer){
                            var layerDescr = layer.sourceDescr;
                            layerDescr += that.addCounter(layer);
                            layerDescr += that.filterToString(layer.filter);
                            var newData = {LayerId:layer.name+'#'+unique,LayerName:layer.sourceDescr,layer:layer.name,filter:layer.filter,LayerDescr:layerDescr};
                            that.addRow_(newData);
                        },that.addParams);
                    }
                    else{
                        var layerDescr = layer.layer.sourceDescr;
                        if(goog.isDef(layer.layer.spatialVariables.LABEL) && layer.layer.spatialVariables.LABEL != '')
                            layerDescr = layer.layer.spatialVariables.LABEL;
                        layerDescr += that.addCounter(layer.layer);
                        var newData = {LayerId:layer.layer.name+'#'+unique, LayerName:layer.layer.sourceDescr,layer:layer.layer.name, LayerDescr:layerDescr};
                        that.addRow_(newData);
                    }
                };
                layer.layer.loadSpatial();
            }
        }
        else{
            if(goog.isDef(layer.layer.spatialVariables.FILTERED_CLASS)){
                layer.layer.loadFilterFile(function(layer){
                    var layerDescr = layer.sourceDescr;
                    layerDescr += that.addCounter(layer);
                    layerDescr += that.filterToString(layer.filter);
                    var newData = {LayerId:layer.name+'#'+unique, LayerName:layer.sourceDescr,layer:layer.name,filter:layer.filter,LayerDescr:layerDescr};
                    that.addRow_(newData);
                },that.addParams);
            }
            else{
                var layerDescr = layer.layer.sourceDescr;
                if(goog.isDef(layer.layer.spatialVariables.LABEL) && layer.layer.spatialVariables.LABEL != '')
                    layerDescr = layer.layer.spatialVariables.LABEL;
                layerDescr += that.addCounter(layer.layer);
                var newData = {LayerId:layer.layer.name+'#'+unique, LayerName:layerDescr,layer:layer.layer.name, LayerDescr:layerDescr};
                that.addRow_(newData);
            }
        }
    }
};

//добавление графика в грид
CASLayersBaseForm.prototype.addRow_ = function(object){
    $('#manageLayersResultGrid').jqxGrid('addrow', object.LayerId, object);
    //делаем копию casLayer
};

/**
 * Добавление счетчика слоя в названия, чтобы было различие, когда добавляем много одного типа графиков
 * @param layer
 * @returns {string}
 */
CASLayersBaseForm.prototype.addCounter = function(layer){
    if(goog.isDef(CASLayersBaseFormCounter[layer.name]))
        ++CASLayersBaseFormCounter[layer.name];//увеличиваем счетчик
    else
        CASLayersBaseFormCounter[layer.name] = 0;
    if(CASLayersBaseFormCounter[layer.name] == 0)
        return '';
    return '('+CASLayersBaseFormCounter[layer.name]+')';
};

/**
 * Преобразование фильтра в текст
 * @param filter
 * @returns {string}
 */
CASLayersBaseForm.prototype.filterToString = function(filter){
    var filterStr = '';
    for(var i=0; i<filter.length;i++){
        var f = filter[i];
        if(f.op == 'in'){
            filterStr += f.descr+'(';
            var descrs = [];
            for(var j=0;j< f.val.length;j++)
                descrs.push(f.val[j].DESCR);
            filterStr += descrs.join(';')+ '); ';
        }
        else{//скалярные значения
            filterStr += f.descr+f.op+f.val+';';
            filterStr = filterStr.replace('&#60;','<');
        }
    }
    if(filterStr.length>0)
        filterStr = gis_caslayersform_7+filterStr;
    return filterStr;
};

/**
 * Удаляем слой из результирующего списка
 * @param elem
 * @param row
 * @private
 */
CASLayersBaseForm.prototype.removeLayer_ = function(index){
    var rowId= $('#manageLayersResultGrid').jqxGrid('getrowid', index);
    $('#manageLayersResultGrid').jqxGrid('deleterow', rowId);
};

/**
 * Передвигаем меняем местами график
 * @param elem
 * @param row
 * @private
 */
CASLayersBaseForm.prototype.upLayer_ = function(elem, index){
    //получаем весь список, там переносим в нужные позиции и заполняем грид
    var rows = $("#manageLayersResultGrid").jqxGrid('getrows');
    if(index!=0){
        var temp = rows[index];
        rows[index] = rows[index-1];
        rows[index-1] = temp;

        var source ={
            localdata: rows,
            datatype: "array",
            datafields:
                [
                    { name: 'LayerId', type: 'string' },
                    { name: 'LayerName', type: 'string' },
                    { name: 'layer', type: 'string' },
                    { name: 'LayerDescr', type: 'string' }
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#manageLayersResultGrid").jqxGrid({ source: dataAdapter});
        $("#manageLayersResultGrid").jqxGrid('selectrow', index-1);
    }
};
/**
 * Передвигаем меняем местами график
 * @param elem
 * @param row
 * @private
 */
CASLayersBaseForm.prototype.downLayer_ = function(elem, index){
    var rows = $("#manageLayersResultGrid").jqxGrid('getrows');
    if(index!=rows.length-1){
        var temp = rows[index];
        rows[index] = rows[index+1];
        rows[index+1] = temp;

        var source ={
            localdata: rows,
            datatype: "array",
            datafields:
                [
                    { name: 'LayerId', type: 'string' },
                    { name: 'LayerName', type: 'string' },
                    { name: 'layer', type: 'string' },
                    { name: 'LayerDescr', type: 'string' }
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#manageLayersResultGrid").jqxGrid({ source: dataAdapter});
        $("#manageLayersResultGrid").jqxGrid('selectrow', index+1);
    }
};


/**
 * Применяем видимость и показ подписей к слоям
 * @private
 */
CASLayersBaseForm.prototype.applyLayers_ = function() {
    var rows = $("#manageLayersResultGrid").jqxGrid('getrows');
    var i;
    var resultLayersArr = [];
    var layerToStay = [];
    //проходим по исправленным стилям
    for(i in rows){
        var layer = WidgetMap.layerManager.getLayerByName(rows[i].layer);
        //выставляем видимость слоям
        if(goog.isDef(layer)){
            if(layerToStay.indexOf(rows[i].LayerId)==-1)
                layerToStay.push(rows[i].LayerId);
            layer.visible = true;
            resultLayersArr.push(rows[i]);
        }
    }
    if(!resultLayersArr || resultLayersArr.length === 0){
        return;
    }
    //копируем слои
    WidgetMap.layerManager.copyCASLayers(resultLayersArr);
    //удаляем ненужные слои
    WidgetMap.layerManager.removeUnusedCASLayers(layerToStay);

    WidgetMap.finalLayers = resultLayersArr;
    //закрываем форму
    if(goog.isDef(this.closeCallback)){
        this.closeCallback();
    }
    $('#manageLayersDialog').remove();
};


CASLayersBaseForm.prototype.applyStartupLayers_ = function() {
    if(this.applyStartupLayers){
        var i;
        var resultLayersArr = [];
        var layerToStay = [];
        //TODO переработать в общую функцию
        if(this.waterwayProfiles && this.waterwayProfiles.length){
            for(i in this.waterwayProfiles){
                var profile = this.waterwayProfiles[i];
                var layerName = 'CAS_MAIN';
                var layer = WidgetMap.layerManager.getLayerByName(layerName);
                //выставляем видимость слоям
                if(goog.isDef(layer)){
                    var layerNameGUID = layerName + '#'+this.generateGUID();
                    if(layerToStay.indexOf(layerNameGUID) == -1)
                        layerToStay.push(layerNameGUID);
                    layer.visible = true;
                    var filter = {ROUTE_ID: profile.routeId, BEGIN_DATE: profile.beginDate};
                    resultLayersArr.push({LayerId:layerNameGUID, layer:layerName, LayerName: profile.layerDescr, filterAsParam: filter});
                }
            }
        }
        else{
            for(i in this.startupLayers){
                var layerName = this.startupLayers[i];
                var layer = WidgetMap.layerManager.getLayerByName(layerName);
                //выставляем видимость слоям
                if(goog.isDef(layer)){
                    var layerNameGUID = layerName + '#'+this.generateGUID();
                    if(layerToStay.indexOf(layerNameGUID) == -1)
                        layerToStay.push(layerNameGUID);
                    layer.visible = true;
                    resultLayersArr.push({LayerId:layerNameGUID, layer:layerName});
                }
            }
        }

        //копируем слои
        WidgetMap.layerManager.copyCASLayers(resultLayersArr);
        //удаляем ненужные слои
        WidgetMap.layerManager.removeUnusedCASLayers(layerToStay);

        WidgetMap.finalLayers = resultLayersArr;
        //закрываем форму
        if(goog.isDef(this.closeCallback)){
            this.closeCallback();
        }
    }
};

CASLayersBaseForm.prototype.generateGUID  = function(){
    var d = new Date().getTime();
    var uuid = 'xxxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x7|0x8)).toString(16);
    });
    return uuid;
};

function CASLayersForm(opt_options) {
    var options = opt_options !== undefined ? opt_options : {};
    this.title = (options.title !== undefined)?options.title:gis_caslayersform_1;
    this.htmlUrl = 'ui/html/cas/CASManageLayersForm.html';
    this.closeCallback = (options.closeCallback !== undefined)?options.closeCallback:undefined;
    this.startupLayers = ['CAS_DEPTH_OF_COVER','CAS_PROFILE'];
    //в водных переходах выбранный трубопровод перед открытием формы управлением графиков
    this.lineData = (options.lineData !== undefined)?options.lineData:undefined;
    this.applyStartupLayers = false;
    this.closeOnEscape = true;
    this.closable = true;
    this.zoneId = getParameterByName('ZONE_ID');
    if(options.startupLayers !== undefined && options.startupLayers.length > 0){
        this.startupLayers = options.startupLayers;
        this.applyStartupLayers = true;
    }
    //goog.base(this);
}
goog.inherits(CASLayersForm, CASLayersBaseForm);



/**
 * Заполнение списка слоёв
 * @private
 */
CASLayersForm.prototype.fillResultLayersGrid_ = function(){
    if(goog.isDef(WidgetMap.layerManager)){
        var treeGridLayers = [];
        var source ={
            localdata: treeGridLayers,
            datatype: "array",
            id: "LayerId",
            datafields:
                [
                    { name: 'LayerId', type: 'string' },
                    { name: 'LayerName', type: 'string' },
                    { name: 'layer', type: 'string' },
                    { name: 'LayerDescr', type: 'string' },
                    { name: 'LayerLine', type: 'string' },//json str
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#manageLayersResultGrid").jqxGrid({
            width: 490,
            height: 330,
            source: dataAdapter,
            pageable: false,
            altRows: false,
            columnsResize: false,
            editable: false,
            //selectionmode: 'checkbox',
            theme:'gis-blue-grid',
            localization: getLocalization('ru'),
            columns: [
                {
                    text: '', sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    datafield: 'delete', columntype: 'number', width: 25,
                    cellsrenderer: function (row, column, value) {
                        return "<div type='submit' class='cas-img cas-delete-img' onclick='CASLayersForm.prototype.removeLayer_("+row+")' title='"+gis_caslayersform_5+"'></div>";
                    }
                },
                {   text: gis_caslayersform_6, datafield: 'LayerDescr',
                    sortable: false, filterable: false, editable: false,
                    groupable: false, draggable: false, resizable: false,
                    columntype: 'string', width: 400,
                    cellsrenderer: function (row, column, value) {
                        var rValue = value;
                        var tValue = value;
                        if(value.length>62)//добавляем к названию ...
                            rValue = rValue.substring(0,62)+'...';
                        if(value.length>400)//добавляем к подсказке ...
                            tValue = tValue.substring(0,400)+'...';
                        return "<div style='margin:4px;' title='"+tValue+"'>" + (rValue) + "</div>";
                    }
                }
            ]
        });

        this.addVisibleLayers_();
    }
};

/**
 * Заполнение списка слоёв
 * @private
 */
CASLayersForm.prototype.fillLayersGrid_ = function(){
    if(goog.isDef(WidgetMap.layerManager)){
        var zoneId = this.zoneId;
        var layers = WidgetMap.baseLayers;//WidgetMap.layerManager.getAllSortedWeakLayers();
        var treeGridLayers = [];
        for(var i=0; i<layers.length; i++){
            var obj = {LayerId:i, LayerName:layers[i].layer.sourceDescr,
                MapName:layers[i].layer.mapName.replace('\\n',''), layer:layers[i].layer.name,
                add:true};
            treeGridLayers.push(obj);
        }
        var source = {
            dataType: "array",
            dataFields: [
                { name: 'LayerID', type: 'number' },
                { name: 'LayerName', type: 'string' },
                { name: 'MapName', type: 'string' },
                { name: 'layer', type: 'string'},
                { name: 'icon', type: 'string' },
                { name: "add", type: "string" }
            ],
            hierarchy:{groupingDataFields:[{name: "MapName"}]},
            id: 'LayerID',
            localData: treeGridLayers
        };
        var dataAdapter = new $.jqx.dataAdapter(source, {
            loadComplete: function () {
            }
        });
        var columns = [
            { text: "", align: "left", dataField: "empty", width: 35 },
            {
                text: '', dataField: 'add', width: 25,sortable:false,
                cellsRenderer: function (rowKey, dataField, value, data) {
                    return "<div><img style='width:16px;height:16px;' onclick='CASLayersForm.prototype.addLayer_(this,"+rowKey+")' src='./ui/images/addObject.png' title='Добавить график в состав отображаемых' /></div>";
                }
            },
            { text: gis_caslayersform_2, dataField: 'LayerName', width: 420 }
        ];
        $("#manageLayersGrid").jqxTreeGrid(
            {
                source: dataAdapter,
                altRows: true,
                sortable: true,
                width: 490,
                height: 330,
                selectionMode:'singleRow',
                columnsResize: false,
                localization: getLocalization('ru'),
                theme:'gis-blue-treegrid',
                icons: function (rowKey, rowData) {
                    var level = rowData.level;
                    if (level == 0) {
                        return "./ui/images/folder_icon.png";
                    }
                    return false;
                },
                checkboxes: false,
                ready: function () {
                },
                columns: columns
            })
            .on('rowSelect',
                function (event){
                    // event args.
                    var args = event.args;
                    // row data.
                    var row = args.row;
                    // row key.
                    var key = args.key;
                    if(row === undefined){
                        var lRow = $(this).jqxTreeGrid('getRow',key);
                        if(lRow.expanded)
                            $(this).jqxTreeGrid('collapseRow',key);
                        else
                            $(this).jqxTreeGrid('expandRow',key);
                    }

                });
        $("#manageLayersGrid .iconscontainer").remove();
    }
};


/**
 * Добавление слоя в результирующий список
 * @param elem
 * @param row
 * @param item
 * @private
 */
CASLayersForm.prototype.addLayer_ = function(elem, row, item){
    var that = this;
    var zoneId = getParameterByName('ZONE_ID');
    if(zoneId){
        //заполняем данными элементы
        that.loadLinesGrid(function(datas){
            if(datas && datas.length){
                WidgetMap.selectedLineObj = datas[0];
                var dlg = App.confirmDialog(gis_cassettingsform_19.replace('{BASE_LINE}',datas[0].lineDescr),
                    [{text:gis_core_12, click:function(){
                            that.addLayerCallback_(elem, row, item, that);
                            App.destroyDialog(null, dlg);
                    }}], {title:gis_core_1})
            }
        });
        /*this.showSelectLinesForm(function(data){
            that.addLayerCallback_(elem, row, item, that);
        });*/
        return;
    }
    that.addLayerCallback_(elem, row, item, that);
};

CASLayersForm.prototype.addLayerCallback_ = function(elem, row, item, that){
    //добавляем параметры для передачи в фильтр в <data>
    var lineId = WidgetMap.LINE_ID, beginKm = WidgetMap.BEGIN_KM, endKm = WidgetMap.END_KM;
    if(WidgetMap.selectedLineObj){
        lineId = WidgetMap.selectedLineObj.lineId;
        beginKm = WidgetMap.selectedLineObj.lineStartKm;
        endKm = WidgetMap.selectedLineObj.lineEndKm;
    }
    that.addParams = '<data LINE_ID="'+lineId+'" START_KM="'+beginKm+'" FINISH_KM="'+endKm+'" />';
    if(!goog.isDef(item))
        item = $("#manageLayersGrid").jqxTreeGrid('getRow',row);
    var layer = WidgetMap.layerManager.getLayerByName1(item.layer, WidgetMap.baseLayers);


    //TODO если были уже графики какие-то открыты, то не дописываем детали
    /*if(!origLayer && this.lineData && this.lineData.lineDescr){
        layerDescr += '( '+this.lineData.lineDescr+' )';
    }*/
    var unique = Date.now();
    if(goog.isDef(layer) && goog.isDef(layer.layer)){
        //проверяем, есть ли фильтр
        var selectedLine = '';
        if(WidgetMap.selectedLineObj){
            try{
                selectedLine = JSON.stringify($.extend({},WidgetMap.selectedLineObj));
            }
            catch(ex){}
        }
        if(!goog.isDef(layer.layer.spatialVariables) ){
            //если переменные не в процессе загрузки
            if(!layer.layer.inSpatialRequest ){
                //блокируем приложение, чтобы лишних установок видимости и прочего не происходило
                layer.layer.loadSpatialCallback = function(lay){
                    if(goog.isDef(lay) && goog.isDef(lay.spatialVariables) && goog.isDef(lay.spatialVariables.FILTERED_CLASS)){
                        //грузим фильтр и заполняем окошко
                        lay.loadFilterFile(function(layer){
                            var layerDescr = layer.sourceDescr;
                            layerDescr += that.addCounter(layer);
                            layerDescr += that.filterToString(layer.filter);
                            if(WidgetMap.selectedLineObj){
                                layerDescr += '( '+WidgetMap.selectedLineObj.lineDescr+' )';
                            }
                            var newData = {LayerId:layer.name+'#'+unique,LayerName:layer.sourceDescr,layer:layer.name,filter:layer.filter,LayerDescr:layerDescr, LayerLine: selectedLine};
                            that.addRow_(newData);
                        },that.addParams);
                    }
                    else{
                        var layerDescr = layer.layer.sourceDescr;
                        if(goog.isDef(layer.layer.spatialVariables.LABEL) && layer.layer.spatialVariables.LABEL != '')
                            layerDescr = layer.layer.spatialVariables.LABEL;
                        layerDescr += that.addCounter(layer.layer);
                        if(WidgetMap.selectedLineObj){
                            layerDescr += '( '+WidgetMap.selectedLineObj.lineDescr+' )';
                        }
                        var newData = {LayerId:layer.layer.name+'#'+unique, LayerName:layer.layer.sourceDescr,layer:layer.layer.name, LayerDescr:layerDescr, LayerLine: selectedLine};
                        that.addRow_(newData);
                    }
                };
                layer.layer.loadSpatial();
            }
        }
        else{
            if(goog.isDef(layer.layer.spatialVariables.FILTERED_CLASS)){
                layer.layer.loadFilterFile(function(layer){
                    var layerDescr = layer.sourceDescr;
                    layerDescr += that.addCounter(layer);
                    layerDescr += that.filterToString(layer.filter);
                    if(WidgetMap.selectedLineObj){
                        layerDescr += '( '+WidgetMap.selectedLineObj.lineDescr+' )';
                    }
                    var newData = {LayerId:layer.name+'#'+unique, LayerName:layer.sourceDescr,layer:layer.name,filter:layer.filter,LayerDescr:layerDescr, LayerLine: selectedLine};
                    that.addRow_(newData);
                },that.addParams);
            }
            else{
                var layerDescr = layer.layer.sourceDescr;
                if(goog.isDef(layer.layer.spatialVariables.LABEL) && layer.layer.spatialVariables.LABEL != '')
                    layerDescr = layer.layer.spatialVariables.LABEL;
                layerDescr += that.addCounter(layer.layer);
                if(WidgetMap.selectedLineObj){
                    layerDescr += '( '+WidgetMap.selectedLineObj.lineDescr+' )';
                }
                var newData = {LayerId:layer.layer.name+'#'+unique, LayerName:layerDescr,layer:layer.layer.name, LayerDescr:layerDescr, LayerLine: selectedLine};
                that.addRow_(newData);
            }
        }
    }
}

/**
 * Применяем видимость и показ подписей к слоям
 * @private
 */
CASLayersForm.prototype.applyLayers_ = function() {
    var that = this;
    $('#CAS').css('visibility', 'hidden');
    var rows = $("#manageLayersResultGrid").jqxGrid('getrows');
    var i;
    var resultLayersArr = [];
    var layerToStay = [];
    //проходим по исправленным стилям
    for (i in rows) {
        var layerName = rows[i].layer;
        if (rows[i].groupId) {
            //получили все объединенные графики и добавляем их в массив
            var groupLayers = WidgetMap.layerManager.getCasLayerByGroupId(rows[i].groupId);
            groupLayers.forEach(function (groupLayer) {
                var layerNameGUID1 = groupLayer.id + '#' + that.generateGUID();
                layerToStay.push(layerNameGUID1);
                groupLayer.visible = true;
                var filterAsParam = (groupLayer && groupLayer.layer) ? groupLayer.layer.filterAsParam : undefined;
                var selectedLineObj = (groupLayer && groupLayer.layer) ? groupLayer.layer.selectedLineObj : undefined;;
                var layerDescr = groupLayer.layer.legendDescr;
                resultLayersArr.push({
                    LayerId: layerNameGUID1,
                    layer: groupLayer.id,
                    LayerDescr: layerDescr,
                    filterAsParam: filterAsParam,
                    selectedLineObj: selectedLineObj,
                    groupId: rows[i].groupId
                });
            });
        }
        else {
            var layer = WidgetMap.layerManager.getLayerByName1(layerName, WidgetMap.baseLayers);
            var origLayer = WidgetMap.layerManager.getLayerByName(rows[i].LayerId);
            //выставляем видимость слоям
            if (goog.isDef(layer)) {
                var layerNameGUID = layerName + '#' + this.generateGUID();
                if (layerToStay.indexOf(layerNameGUID) == -1)
                    layerToStay.push(layerNameGUID);
                layer.visible = true;
                var filterAsParam = (origLayer && origLayer.layer) ? origLayer.layer.filterAsParam : undefined;
                var selectedLineObj = undefined;
                try {
                    selectedLineObj = JSON.parse(rows[i].LayerLine);
                } catch (ex) {
                }
                var layerDescr = rows[i].LayerDescr;
                resultLayersArr.push({
                    LayerId: layerNameGUID,
                    layer: layerName,
                    filter: rows[i].filter,
                    LayerDescr: layerDescr,
                    filterAsParam: filterAsParam,
                    selectedLineObj: selectedLineObj
                });
            }
        }
    }

    //удаляем ненужные слои
    WidgetMap.layerManager.removeAllCASLayers();
    //копируем слои
    WidgetMap.layerManager.copyCASLayers(resultLayersArr);


    WidgetMap.finalLayers = resultLayersArr;
    //закрываем форму
    if(goog.isDef(this.closeCallback)){
        this.closeCallback();
    }
    $('#manageLayersDialog').remove();
};


CASLayersForm.prototype.applyVisibleLayers_ = function() {
    if(this.applyStartupLayers){
        var i;
        var resultLayersArr = [];
        var layerToStay = [];
        //проходим по исправленным стилям
        for(i in this.startupLayers){
            var layerName = this.startupLayers[i];
            var layer = WidgetMap.layerManager.getLayerByName(layerName);
            //выставляем видимость слоям
            if(goog.isDef(layer)){
                var layerNameGUID = layerName + '#'+this.generateGUID();
                if(layerToStay.indexOf(layerNameGUID) == -1)
                    layerToStay.push(layerNameGUID);
                layer.visible = true;
                resultLayersArr.push({LayerId:layerNameGUID, layer:layerName});
            }
        }
        //копируем слои
        WidgetMap.layerManager.copyCASLayers(resultLayersArr);
        //удаляем ненужные слои
        WidgetMap.layerManager.removeUnusedCASLayers(layerToStay);

        WidgetMap.finalLayers = resultLayersArr;
        //закрываем форму
        if(goog.isDef(this.closeCallback)){
            this.closeCallback();
        }
    }
};


/**
 * Добавление в результирующий список слоёв из сценария задачи
 * @private
 */
CASLayersForm.prototype.addVisibleLayers_ = function(){
    CASLayersBaseFormCounter = {};
    var that = this;
    var layers = WidgetMap.layerManager.getAllLayers();
    if(layers !== undefined && layers.length > 0){
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            if(goog.isDef(layer.layer)){
                var layerDescr = layer.layer.sourceDescr;
                if(layer.layer.spatialVariables && goog.isDef(layer.layer.spatialVariables.LABEL) && layer.layer.spatialVariables.LABEL != '')
                    layerDescr = layer.layer.spatialVariables.LABEL;
                if(layer.layer.legendDescr != '')
                    layerDescr = layer.layer.legendDescr;
                layerDescr += that.addCounter(layer.layer);
                var newData = {
                    LayerId: layer.layer.uniqueLayerName,
                    LayerName: layerDescr,
                    layer: layer.layer.name,
                    filter: layer.layer.filter,
                    LayerDescr: layerDescr,
                    groupId: undefined,
                };
                if (layers[i].groupId) {
                    for (; i < layers.length; i++) {
                        if (layers[i].groupId) {
                            newData.groupId = layers[i].groupId;
                            //obj.group.push(layers[i]);
                            newData.LayerName = gis_cassettingsform_16;
                            newData.LayerDescr = gis_cassettingsform_16;
                        } else {
                            i--;
                            break;
                        }
                    }
                }
                that.addRow_(newData);
            }
        }
    }
};

CASLayersForm.getLayersForFilling = function(){
    if(goog.isDef(WidgetMap.layerManager)) {
        var layers = WidgetMap.layerManager.getAllLayers();
        var treeGridLayers = [];
        for (var i = 0; i < layers.length; i++) {
            var layerDescr = layers[i].layer.sourceDescr;
            if (layers[i].layer.legendDescr !== '')
                layerDescr = layers[i].layer.legendDescr;
            var obj = {
                LayerId: layers[i].layer.uniqueLayerName,
                LayerName: layerDescr,
                layer: layers[i].layer.name,
                groupId: undefined,
            };
            if (layers[i].groupId) {
                for (; i < layers.length; i++) {
                    if (layers[i].groupId) {
                        obj.groupId = layers[i].groupId;
                        //obj.group.push(layers[i]);
                        obj.LayerName = gis_cassettingsform_16;
                    } else {
                        i--;
                        break;
                    }
                }
            }
            treeGridLayers.push(obj);
        }
    }
}

CASLayersForm.prototype.showSelectLinesForm = function(callback){
    var that = this;
    $('#casLineChooserDialog').remove();
    var divv = '<div id="casLineChooserDialog" style="color: white" >' +
        '<div id="casLinesGrid" style="width: 100%; height: 100%; "></div>' +
        '<div style="text-align: center; margin-top: 10px">' +
        '<input type="button" class="map-dialog-button" name="apply"  value="'+ gis_core_16 + '" style="margin-right: 10px">' +
        '<input type="button" class="map-dialog-button" name="cancel" value="'+ gis_core_6 + '" >' +
        '</div>'+
        '</div>';
    $('body').append(divv);
    var dlg = $('#casLineChooserDialog');
    dlg.dialog({
        modal: true,
        title: gis_caslayersform_9,
        closeOnEscape: false,
        dialogClass: 'noCloseButton gsi-zindex__dialog',
        width: 510,
        height: 341,
        resizable: false
    });

    //заполняем данными элементы
    that.loadLinesGrid();

    $('input[name=apply]', dlg).click(function (){
        var selectedIndexes = $("#casLinesGrid").jqxGrid('getselectedrowindexes');
        if (selectedIndexes.length > 0){
            var selectedRowData = $('#casLinesGrid').jqxGrid('getrowdata', selectedIndexes[0]);
            if(selectedRowData.lineMeasureOffset)
                selectedRowData.lineMeasureOffset /= 1000;
            WidgetMap.selectedLineObj = selectedRowData;
            if(callback) callback(selectedRowData);
            App.destroyDialog(null, dlg);
        }
    });
    $('input[name=cancel]', dlg).click(function (){
        App.destroyDialog(null, dlg);
    });
}

CASLayersForm.prototype.loadLinesGrid = function(callback) {
    var that = this;
    function result(resultXml){
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.errorReport(gis_core_error_1, er, undefined, {filename: gis_filename_631, functionname: 'gis_filename_631_1'});
            return;
        }
        var xmlElement = ($.parseXML(resultXml)).firstChild;
        var datas = xmlElement.getElementsByTagName("data");
        var resDatas = [];
        $(datas).each(function (index) {
            var lineId = $(this).attr('LINE_ID');
            var lineDescr = $(this).attr('DESCR');
            var lineStartKm = $(this).attr('START_KM');
            var lineEndKm = $(this).attr('FINISH_KM');
            var lineMeasureOffset = Number($(this).attr('MEASURE_OFFSET'));
            if($(this).attr('MEASURE_OFFSET') === '0')
                resDatas.push({lineId: lineId, lineDescr: lineDescr, lineStartKm:lineStartKm, lineEndKm: lineEndKm, lineMeasureOffset: lineMeasureOffset});
        });
        if(callback) callback(resDatas);
        else that.fillCasLinesGrid(resDatas);
    }
    function fault(resultXml){
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.errorReport(gis_core_error_1, er, undefined, {filename: gis_filename_631, functionname: 'gis_filename_631_2'});
        }
    }
    var zoneId = getParameterByName('ZONE_ID');
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    var params = {
        descrId: 'WATERWAY_SEM.xml#WATERWAY_LINE_LIST',
        descrType: 'select',
        data: '<root USER_ID="' + userId.xmlEscape() +
            '" USER_LOGIN="' + userLogin.xmlEscape() +
            '" PODS_USER="' + userLogin.xmlEscape() + '" >' +
            '<data ZONE_ID="' + zoneId + '"/>' +
            '</root>'
    }
    App.serverQueryXMLNode(Services.processQueryNode, params, result, fault);
}

CASLayersForm.prototype.fillCasLinesGrid = function(datas) {
    var source = {
        localdata: datas,
        datatype: "array",
        id: "casLines",
        datafields:
            [
                { name: 'lineId', type: 'string' },
                { name: 'lineDescr', type: 'string' },
                { name: 'lineStartKm', type: 'string' },
                { name: 'lineEndKm', type: 'string' },
                { name: 'lineMeasureOffset', type: 'number' },
            ]
    };
    var dataAdapter = new $.jqx.dataAdapter(source);
    $("#casLinesGrid").jqxGrid({
        width: 500,
        height: 267,
        source: dataAdapter,
        pageable: false,
        altRows: false,
        columnsResize: false,
        editable: false,
        theme:'gis-blue-grid',
        localization: getLocalization('ru'),
        columns: [
            {   text: gis_caslayersform_8, datafield: 'lineDescr',
                sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                columntype: 'string', width: 475
            },
        ]
    });
    $("#casLinesGrid").css({'margin': 'auto'});
}
/* TEXT CONSTANTS */
var CAS_FILTER_TITLE = gis_casfilterform_1;
var CAS_FILTER_NEW_OPTION_TEXT = gis_casfilterform_2;
var CAS_FILTER_FORM_ERROR = gis_casfilterform_3;

/**
 * Класс всплывающей формы с фильтром слоя ПКА
 */
function CASFilterForm(opt_options) {
    var options = opt_options !== undefined ? opt_options : {};
    this.title = (options.title !== undefined)?options.title:CAS_FILTER_TITLE;
    this.closeCallback = (options.closeCallback !== undefined)?options.closeCallback:undefined;
    this.datas = (options.datas !== undefined)?options.datas:undefined;
    this.layer = (options.layer !== undefined)?options.layer:undefined;
    this.commonFilters = (options.commonFilters !== undefined)?options.commonFilters:undefined;
    this.htmlUrl = 'ui/html/cas/CASFilterForm.html';
    //Источник данных для комбобокса операций
    this.scalarFilterOp = ["=",">","<",">=","<=","!="]; /*["~=","=",">","&#60;",">=","<=","!="];*/
    //доп параметры, которые будут использоваться в запросе в <data>
    this.addParams =(options.addParams !== undefined)?options.addParams:undefined;
    this.elementId = this.layer.name+'_casFilter';
};

CASFilterForm.prototype.build = function() {
    try {
        var that = this;
        //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
        function build() {
            //Создаем диалоговую форму
            dlg.dialog({
                modal: true,
                resizable: false,
                title: that.title,
                dialogClass: 'noCloseButton gsi-zindex__dialog',
                closeOnEscape: false,
                width: 700,
                height: 285
            });
            var fd = '<div id="'+that.elementId+'" style="overflow: hidden;"></div>';
            $('body').append(fd);
            //Уникальный идентификатор грида формируем на основе идентификатора элемента
            var jqxGridId = "jqxgridcasfilter";
            //Формируем обертку, в которой будем создавать грид
            var widgetContent =
                '<div id="jqxDockPanel' + jqxGridId + '" style="width: 100%; height: 100%">' +
                    '<div id="jqxWidget' + jqxGridId + '" dock="right" style="width: 100%; height: 100%;">' +
                        '<div id="' + jqxGridId + '" class="bottomFilter-mainGrid">' + //getLocalization('ru').loadtext +
                        '</div>' +
                    '</div>' +
                '</div>';
            $('.scalarBottomFilterBox').html(widgetContent);
            //Создаем панель с возможностью процентного и фиксированного layout
            $("#jqxDockPanel"+jqxGridId).jqxDockPanel({ width: '100%', height: 200});

            //Создаем панель с динамическими комбобоксами
            var dynamicFilterContent = '<div id="topFilterBox' + jqxGridId + '" style="width: 100%; height: 100%"></div>';
            $('.topFilterBox').html(dynamicFilterContent);
            $('.topFilterBox').addClass('topFilterBoxCas');

            //Данные (установленные пользователем фильтры)
            //Добавляем фильтры, если они есть (передаются в форму через this.currentFilters)
            var data = [];
            //Массив div'ов с динамическими фильтрами
            var currentDynFilters = [];

            //Получение из общего массива фильтров динамического фильтра конкретной колонки (идет в списки)
            var getDynColumnFilter = function getDynColumnFilter(allFiltersArr, curColumn) {
                var curFilter;
                for (var i = 0; i < allFiltersArr.length; i++) {
                    curFilter = allFiltersArr[i];
                    if (curFilter && curFilter.hasOwnProperty('fld') && curFilter['fld']==curColumn.datafield) {
                        return curFilter;
                    }
                }
                return null;
            };
            //Формируем массив для фильтрации по колонкам
            if (goog.isDef(that.datas) && that.datas.length > 0) {
                that.currentGridColumns = [];
                var i = 0;
                for (; i < that.datas.length; i++) {
                    var curCol = that.datas[i];
                    //Добавляем к фильтрации только если в колонке есть параметр типа фильтрации!
                    //Если type==='array', то это динамический комбобокс
                    if (curCol.type === 'array') {
                        //Добавляем контрол динамического фильтра
                        var dynFilterDivId = jqxGridId+'dynFilterBox'+i;
                        var dynFilterDiv = '<div id="'+dynFilterDivId+'" class="dynamicFilterPopupList"/>';
                        $('#topFilterBox'+jqxGridId).append(dynFilterDiv);
                        //Создаем описание динамического комбобокса по описанию колонки
                        var dynFilterXml;//'<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:components="ru.corelight.view.components.*">';
                        if(goog.isDef(curCol.limit))
                            dynFilterXml = '<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:components="ru.corelight.view.components.*">' +
                            '<components:FilterPopUpButton width="100%" minPopupWidth="610" height="22" title="'+curCol.name+'" selectAllElements="false" isDropDown="true" ' +
                            'minCnt="0" maxCnt="'+curCol.limit+'" '+
                            'id="'+curCol.dataField+'" dataProvider="' + curCol.dataProvider + '" /> </mx:VBox>';
                        else
                            dynFilterXml = '<mx:VBox xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:components="ru.corelight.view.components.*">' +
                            '<components:FilterPopUpButton width="100%" minPopupWidth="610" height="22" title="'+curCol.name+'" selectAllElements="true" isDropDown="true" ' +
                            'id="'+curCol.dataField+'" dataProvider="' + curCol.dataProvider + '" /> </mx:VBox>';

                        $('#'+dynFilterDivId).myFilters({
                            dataXML: dynFilterXml,
                            selectedItems:that.commonFilters,
                            addParams:that.addParams
                            });
                        //Сохраняем id div'а с динамическим фильтром (чтобы потом забирать фильтры)
                        currentDynFilters.push({dynFilterDivId:dynFilterDivId, curCol:curCol});
                    } else {
                        that.currentGridColumns.push({text:curCol.name,datafield:curCol.dataField,filtercomparisiontype:curCol.type});
                        //Ищем в массиве that.currentFilters статические фильтры текущей колонки (для выставления выбранных ранее значений)
                        /*for (var k = 0; k < that.currentFilters.length; k++) {
                            var curStatFilter = that.currentFilters[k];
                            if (curStatFilter && curStatFilter.hasOwnProperty('fld') && curStatFilter['fld']==curCol.datafield) {
                                data.push(curStatFilter);
                            }
                        }*/
                    }
                }
            }

            //Увеличиваем высоту диалога на необходимую величину (динамически были добавлены комбобоксы)
            var dlgHeight = dlg.dialog("option","height");
            var topFilterBoxHeight = $('#topFilterBox'+jqxGridId).outerHeight();
            dlg.dialog("option","height", dlgHeight + topFilterBoxHeight);

            var currentGridColumnsAdapter;
            if(!that.currentGridColumns || that.currentGridColumns.length === 0) {
            }
            else{
                currentGridColumnsAdapter = new $.jqx.dataAdapter(that.currentGridColumns, {
                    autoBind: true
                });
                function createEmptyHTML(){
                    var id = jqxGridId+'_'+new Date().getTime();
                    var div = $('<div id="maindiv_'+id+'" class="bottomFilter-scalarFields-row"></div>');
                    var descr = $('<div id="descr_'+id+'" style="display:inline-block;" ></div>');
                    var valDiv =  $('<div style="display:inline-block;" ></div>');
                    var val = $('<input type="text" id="input_'+id+'" class="bottomFilter-scalarFields-row-input"/>');
                    var imageDiv = $('<div class="bottomFilter-scalarFields-row-remove"></div>');
                    var imageBtnHtml = $('<input type="button" class="gridButton bottomFilter-scalarFields-row-input"'
                        +' style="padding: 0;margin-top: 5px;'+" background-image: url('./Public/assets/delete.png');"+'" value=" " title=""'
                        +' id="btn_'+jqxGridId+'_'+id+'" />')
                        .on('click',function(event){
                            event.preventDefault();
                            var baseGridChildren = $("#"+jqxGridId).children();
                            if(baseGridChildren.length >1){
                                //дополнительное условие, если последний ряд пустой с невыбранным descr, то его не удаляем
                                if($('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                                    $('#maindiv_'+id).remove();
                            }
                            return false;
                        });
                    var useAutoDropDownHeight = that.currentGridColumns && that.currentGridColumns.length <= 10;
                    descr.jqxDropDownList({source: currentGridColumnsAdapter, displayMember: 'text', valueMember: 'datafield', selectedIndex: -1,
                        placeHolder: CAS_FILTER_NEW_OPTION_TEXT, autoDropDownHeight: useAutoDropDownHeight, theme: 'gis-blueorange'})
                        .on('change', function (event) {
                            if (event.args && event.args.item) {
                                var item = event.args.item;
                            }
                            return false;
                        });

                    var operation = $('<select id="op_'+id+'" class="bottomFilter-scalarFields-row-opselect" ></div>');
                    var opDiv =  $('<div class="bottomFilter-scalarFields-row-opdiv" ></div>');
                    $.each(that.scalarFilterOp, function(key, value) {
                        var text = value;
                        if(value == "<")text= "&#60;";
                        operation.append($("<option></option>")
                            .attr("value",text)
                            .text(value));
                    });
                    val.jqxInput({height: 25, width: 410,theme:'gis-blueorange'})
                        .on('paste', function (evt) {
                            //Сделано специально для IE, на других браузерах вставка из Excel сама преобразует переносы строк в пробелы
                            try {
                                var replacedText = window.clipboardData.getData('text');
                                replacedText = replacedText.replace(/(\r\n|\n|\r)/gm,';'); //Заменяем переносы строк на ';'
                                setTimeout(function (){
                                    val[0].value = replacedText;
                                },5);
                            } catch (err) {}
                        })
                        .on('focusout',function(evt){
                            //если поле условия выбрано и ряд последний, то новую создаем
                            //заменяем запятые на точки
                            var baseGridChildren = $("#"+jqxGridId).children();
                            if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                                createEmptyHTML();
                        })
                        .on('keyup',function(evt){
                            evt.preventDefault();
                            if (evt.keyCode == 13) {
                                //если поле условия выбрано и ряд последний, то новую создаем
                                var baseGridChildren = $("#"+jqxGridId).children();
                                if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                                    createEmptyHTML();
                            }
                            return false;
                        });

                    opDiv.append(operation);
                    valDiv.append(val);
                    imageDiv.append(imageBtnHtml);
                    div.append(descr).append(opDiv).append(valDiv).append(imageDiv);
                    $("#"+jqxGridId).append(div);
                }
                createEmptyHTML();
            }
            //Функция собирает в общий массив фильтры из формы
            var getFilter = function (){
                var resultFilters = [];
                //Получаем текущий грид со статическими фильтрами
                var gridSource  = $("#"+jqxGridId).children();
                var i;
                for (i = 0; i < gridSource.length; i++) {
                    var newItem = {};
                    //получаем id, начиная с 8, т.к. вначале идёт "maindiv_"
                    var cId = gridSource[i].id.substr(8);
                    //забираем значения полей
                    var descrItem = $('#descr_'+cId).jqxDropDownList('getSelectedItem');
                    if(descrItem!=undefined && descrItem.originalItem != undefined){
                        newItem.hasType = descrItem.originalItem.filtercomparisiontype;
                        newItem.fld = descrItem.originalItem.datafield;
                        newItem.descr = descrItem.originalItem.text;
                        //var opItem = $('#op_'+cId).jqxDropDownList('getSelectedItem');
                        var opItem = $('#op_'+cId).val();
                        if(opItem!=undefined)
                            newItem.op = opItem;//.value;
                        newItem.val = $('#input_'+cId).jqxInput('val');
                        newItem.del = '';
                        //Перед включением условия в запрос проверяем, что оно заполнено по fld, т.е. что колонка для условия выбрана
                        resultFilters.push(newItem);
                    }
                }
                //Добавляем в фильтр выбранные в динамических комбобоксах значения
                for (i = 0; i < currentDynFilters.length; i++) {
                    var dynFilterDivId = currentDynFilters[i]['dynFilterDivId'];
                    var dynFilterCol = currentDynFilters[i]['curCol'];
                    var curDynFilters = [];
                    //Получаем список выбранных записей
                    var resFilterValues = $('#'+dynFilterDivId).myFilters('getFilterValuesArray');
                    var dotSplitArr = resFilterValues[0].values;
                    //Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
                    var checkAllCheckBox = $($('#'+dynFilterDivId+" .divCheckAll")[0].children[0]);
                    if(dotSplitArr.length<=0){
                        curDynFilters.push({CODE:'NULL',DESCR:gis_casfilterform_8});
                    }
                    if ((checkAllCheckBox && checkAllCheckBox.jqxCheckBox('checked'))){
                        curDynFilters.push({CODE:'ALL',DESCR:gis_casfilterform_9});
                        continue;
                    }

                    var j;
                    for (j = 0; j < dotSplitArr.length; j++) {
                        var selectedObj = {CODE:dotSplitArr[j].code, DESCR:dotSplitArr[j].descr};
                        curDynFilters.push(selectedObj);
                    }
                    //Добавляем фильтр по полю, только если в нем что-то выбрано. Если выбраны все записи - условие добавлять не нужно
                    var curDynFilterObj = {hasType:"", del:"", descr:dynFilterCol.name, fld:dynFilterCol.dataField, op:"in", val:curDynFilters};
                    resultFilters.push(curDynFilterObj);
                }

                return resultFilters;
            };

            //Кнопки Ок и отмены
            $("input[name='apply']", dlg).click(function () {
                //Собираем фильтр по имеющимся в форме значениям
                var curFilter = getFilter();
                var hasNull = false;
                //проверяем, есть ли в перечисляемых полях значение null - значит не выбрано обследование
                for(var i in curFilter){
                    var item = curFilter[i];
                    if(item.op == 'in' && goog.isDef(item.val) && item.val.length == 1 && item.val[0].CODE == 'NULL'){
                        hasNull = true;
                        break;
                    }
                }
                if(hasNull){
                    var text = gis_casfilterform_4;
                    var title = gis_casfilterform_5;
                    var buttons = [
                        {text:gis_casfilterform_6,  click:showGridDialog},
                        {text:gis_casfilterform_7, click:closeDialog}
                    ];
                    var dlg = App.confirmDialog(text, buttons, {title:title, width:400});

                    function closeDialog() {
                        dlg.dialog('destroy');
                        dlg.remove();
                    }
                    function showGridDialog() {
                        dlg.dialog('destroy');
                        dlg.remove();
                        that.applyBottomFilter(curFilter);
                        that.close();
                    }
                }
                else{
                    that.applyBottomFilter(curFilter);
                    that.close();
                }

            });
            $("input[name='cancel']", dlg).click(function () {
                that.close();
            });
        }

        var currDialog = $('#CASFilterDialog');
        if(currDialog.length > 0){
            $('#CASFilterDialog').remove();//dialog('destroy').remove();
        }
        /*else{
            $('#CASFilterDialog').dialog('open');
            return;
        }*/

        $('body').append('<div id="CASFilterDialog" style="overflow: hidden;"></div>');
        $('#CASFilterDialog').hide();
        currDialog = $('#CASFilterDialog');
        var dlg = currDialog;
        dlg.load(this.htmlUrl, build);

    } catch (e) {
        App.errorReport(CAS_FILTER_FORM_ERROR, e, undefined, {filename:gis_filename_308, functionname:'gis_filename_308_1'});
    }
};


CASFilterForm.prototype.applyBottomFilter = function (curFilter) {
    //если есть общие фильтры, то заносим туда выбранные значения в комбобоксах
    if(goog.isDef(this.commonFilters)){
        for(var i=0; i<curFilter.length;i++){
            if(curFilter[i].op == 'in' && goog.isDef(this.commonFilters[curFilter[i].fld])){
                if(curFilter[i].val[0] == 'ALL') {//если выбрали все, то удаляем свойство, чтобы в след раз всё было выбрано
                    curFilter[i].val[0].splice(0,1);
                    this.commonFilters[curFilter[i].fld].lastSelected = undefined;
                }
                else
                    this.commonFilters[curFilter[i].fld].lastSelected = curFilter[i].val;
            }
        }
    }
    if(goog.isDef(this.closeCallback)){
        this.closeCallback(this.layer, curFilter);
    }
};

CASFilterForm.prototype.close = function() {
    //Удаляем форму
    $('#CASFilterDialog').remove();//dialog('destroy').remove();
};


//Фильтрация списка значений нижнего фильтра по переданному массиву значений фильтра верхнего или среднего уровня
CASFilterForm.prototype.updateFiltersByArray = function(filterId, dataField) {
    var filterArray = this.commonFilters;
    if (goog.isDef(filterArray) && goog.isDef(filterArray[dataField]) && goog.isDef(filterArray[dataField].lastSelected)) {
        var filterArr = [];
        for(var i=0; i<filterArray[dataField].lastSelected.length;i++){
            filterArr.push(filterArray[dataField].lastSelected[i].CODE);
        }
        var filterStr = filterArr.join(',');
        $('#'+filterId).myFilters('updateTopFilter',{obj_ids:filterStr});
    }
};


/**
 * Класс для выбора в ПКА профилей по годам. Используется в задаче "Профиль водного перехода"
 * @param opt_options
 * @constructor
 */
function CASProfileChooserForm(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.profiles = options.profiles || [];
	this.callback = options.callback;
	this.zoneId = options.zoneId || getParameterByName('ZONE_ID');
	//this.profiles = this.fillStubProfiles();
}


CASProfileChooserForm.prototype.build = function() {
	var that = this;
	$('#casProfileChooserDialog').remove();
	var divv = '<div id="casProfileChooserDialog" style="color: white" >' +
		'<div id="casRoutesDescr" style="padding: 15px 10px 15px;">' + gis_casprofilechooserform_4 + '</div>' +
		'<div id="casRoutesGrid" style="width: 100%; height: 100%;"></div>' +
		'<div style="text-align: center; margin-top: 10px">' +
			'<input type="button" class="map-dialog-button" name="apply"  value="'+ gis_core_16 + '" style="margin-right: 10px">' +
			'<input type="button" class="map-dialog-button" name="cancel" value="'+ gis_core_6 + '" >' +
		'</div>'+
		'</div>';
	$('body').append(divv);
	var dlg = $('#casProfileChooserDialog');
	dlg.dialog({
		modal: true,
		title: gis_casprofilechooserform_1,
		closeOnEscape: false,
		dialogClass: 'noCloseButton gsi-zindex__dialog',
		width: 510,
		height: 428,
		resizable: false
	});

	//заполняем данными элементы
	that.loadRoutesGrid();

	$('input[name=apply]', dlg).click(function (){
		var selectedProfiles = that.getSelectedRows();
		if(!selectedProfiles || selectedProfiles.length === 0)
			return;
		if(that.callback) that.callback(selectedProfiles);
		App.destroyDialog(null, dlg);
	});
	$('input[name=cancel]', dlg).click(function (){
		App.destroyDialog(null, dlg);
	});
}

CASProfileChooserForm.prototype.loadRoutesGrid = function() {
	var that = this;
	function result(resultXml){
		var er = HTTPServiceUtil.getError(resultXml);
		if(er !== ''){
			App.errorReport(gis_core_error_1, er, undefined, {filename: gis_filename_631, functionname: 'gis_filename_631_1'});
			return;
		}
		var xmlElement = ($.parseXML(resultXml)).firstChild;
		var datas = xmlElement.getElementsByTagName("data");
		$(datas).each(function (index) {
			var routeId = $(this).attr('ROUTE_ID');
			var layerDescr = $(this).attr('LAYER_NAME');
			var beginDate = $(this).attr('BEGIN_DATE');
			that.profiles.push({routeId: routeId, layerDescr: layerDescr, beginDate:beginDate})
		});
		that.fillRoutesGrid();
	}
	function fault(resultXml){
		var er = HTTPServiceUtil.getError(resultXml);
		if(er !== ''){
			App.errorReport(gis_core_error_1, er, undefined, {filename: gis_filename_631, functionname: 'gis_filename_631_2'});
		}
	}
	var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
	var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
	var params = {
		descrId: 'CAS_WATERWAY_SEM.xml#CAS_WATERWAY_ROUTES',
		descrType: 'select',
		data: '<root USER_ID="' + userId.xmlEscape() +
			'" USER_LOGIN="' + userLogin.xmlEscape() +
			'" PODS_USER="' + userLogin.xmlEscape() + '" >' +
			'<data ZONE_ID="' + that.zoneId + '"/>' +
			'</root>'
	}
	App.serverQueryXMLNode(Services.processQueryNode, params, result, fault);
}


CASProfileChooserForm.prototype.fillRoutesGrid = function() {
	var source = {
		localdata: this.profiles,
		datatype: "array",
		id: "casProfiles",
		datafields:
			[
				{ name: 'routeId', type: 'string' },
				{ name: 'layerDescr', type: 'string' },
				{ name: 'beginDate', type: 'string' },
			]
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#casRoutesGrid").jqxGrid({
		width: 480,
		height: 294,
		source: dataAdapter,
		pageable: false,
		altRows: false,
		columnsResize: false,
		editable: false,
		selectionmode: 'checkbox',
		theme:'gis-blue-grid',
		localization: getLocalization('ru'),
		columns: [
			{   text: gis_casprofilechooserform_2, datafield: 'layerDescr',
				sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				columntype: 'string', width: 422
			},
		]
	});
	$("#casRoutesGrid").css({'margin': 'auto'});
}
CASProfileChooserForm.prototype.getSelectedRows = function(){
	var rows = [];
	var rowindexes = $("#casRoutesGrid").jqxGrid('getselectedrowindexes');
	for (var i = 0; i < rowindexes.length; i++) {
		var curRowData = $("#casRoutesGrid").jqxGrid('getrowdatabyid', rowindexes[i]);
		rows.push(curRowData);
	}
	 return rows;
}
/**
 * Класс для работы с табнейлами для векторных объектов на карте
 *
*/
function PreviewPopUp(options) {
    //запрос для получения семантики с именем файла и подписью для текущего документа
    this.requestLibDoc = 'LIB_DOC_SEM.xml#LIB_DOC';

    //Страница для запроса иконки в уменьшенном масштабе (табнейла)
    this.requestGetDocPreview = './api/doc-preview?';

    //Подпапка с документами в общей папке с данными пользователей config.DATA_PATH
    this.folder = "LIB/";

    this.defaultImage = "Public/assets/Preview/noImage.png";

    this.map = undefined;

    this.eventParams = {};

    var opt = goog.isDef(options)?options:{};
    if(goog.isDef(opt.requestLibDoc))
        this.requestLibDoc = opt.requestLibDoc;

    if(goog.isDef(opt.defaultImage))
        this.defaultImage = opt.defaultImage;

    if(goog.isDef(opt.eventParams))
        this.eventParams = opt.eventParams;

    if(goog.isDef(opt.map))
        this.map = opt.map;


    this.currentRequest;
};


PreviewPopUp.prototype.build = function(){
    var that = this;
    //создаем таймаут
    var currTime = new Date().getTime();//устанавливаем время в миллисекундах
    var timer;
    var pixel;
    var needShowPopup = false;


    //если карта есть
    if(goog.isDef(this.map)){
        var popupDiv = $('<div  class="map-preview-popup" id="documentPreviewPopup">' +
        '<div  id="documentPreviewPopupDiv" class="map-preview-popup-div">' +
            '<img id="documentPreviewPopupImg" style=""/>' +
            '<label id="documentPreviewPopupLabel"></label>' +
        '</div></div>');
        try{
            $('#map').append(popupDiv);
            popupDiv.hide();
            that.map.on('pointermove', function(e) {
                //обнуляем таймаут
                currTime = new Date().getTime();
                clearTimeout(timer);
                pixel = this.getEventPixel(e.originalEvent);

                var hit = this.hasFeatureAtPixel(pixel,function(layer) {

                    return layer.get('id') == 'LIB_DOC';//layer === vectorLayer;
                });
                if(hit){
                    var feature = this.forEachFeatureAtPixel(pixel, function(feature, layer) {
                        return feature;
                    });
                    if(feature.getGeometry().getType() == ol.geom.GeometryType.POLYGON)
                    return false;
                    var vSearchRad = 24;
                    var leftBottom = that.map.getCoordinateFromPixel([pixel[0]-vSearchRad, pixel[1]-vSearchRad]);
                    var rightTop = that.map.getCoordinateFromPixel([pixel[0]+vSearchRad, pixel[1]+vSearchRad]);
                    var ext = [leftBottom[0],rightTop[1],rightTop[0],leftBottom[1]];
                    var findedObjects = GeoUtil.getIntersectedGeometry(feature,ext);
                    if(findedObjects.length>0){
                        if(!needShowPopup){
                            timer = setTimeout(function(){
                                clearTimeout(timer);
                                //тут по id фичи ищем id геометрии
                                //Загружаем иконку и текст подписи для предпросмотра
                                //запрашиваем по id объекта данные и загружаем в попап
                                that.currentRequest = that.getLibDocById(findedObjects[0].id,function(data){
                                    if(goog.isDef(data) && data.result == true && goog.isDef(data.resultXml)){
                                        var layerGeoXml = ($.parseXML(data.resultXml)).firstChild;
                                        var datas = layerGeoXml.getElementsByTagName("data");
                                        if(datas.length>0){
                                            var fileName = datas[0].getAttribute("FILE_NAME");
                                            var label = datas[0].getAttribute("NAME");
                                            //Показываем панельку, если у нас есть имя файла и подпись к документу
                                            label!=undefined && label!="" ? label : gis_previewpopup_1;
                                            if(true)//showTitle флаг из *_Layers.xml
                                                $('#documentPreviewPopupLabel').text(label).css('display','block');
                                            else{
                                                $('#documentPreviewPopupLabel').css('display','none');
                                            }
                                            popupDiv.show().css('left',(pixel[0]+10)+'px').css('top',(pixel[1]+10)+'px');
                                            //В качестве url картинки передаем страницу aspx для получения превьюшки
                                            if(goog.isDef(fileName) && fileName !=''){
                                                if (App.config.DATA_PATH === undefined) {
                                                    App.errorReport(gis_core_17, 'DATA_PATH' + gis_core_18, undefined, {filename:gis_filename_561, functionname:'gis_filename_561_1'});
                                                    return;
                                                }
                                                var filePath = App.config.DATA_PATH+that.folder+fileName;
                                                //В дополнительных параметрах может быть указан минимальный размер табнейла (imageMinSize)
                                                var imgMinSize = 32;//0;
                                                if(goog.isDef(that.eventParams.imageMinSize) && !isNaN(that.eventParams.imageMinSize))
                                                    imgMinSize = parseInt(that.eventParams.imageMinSize);
                                                //Получаем превью документа
                                                that.getDocumentPreview(filePath, imgMinSize);
                                            }
                                        }
                                        else{
                                            needShowPopup = false;
                                            popupDiv.hide();
                                        }

                                    }
                                    else{
                                        //Вместо отображения ошибки просто убираем панель (если показывали)
                                        needShowPopup = false;
                                        popupDiv.hide();
                                    }

                                });


                                //popupDiv.show().css('left',(pixel[0]+10)+'px').css('top',(pixel[1]+10)+'px');
                                needShowPopup = true;

                            }, 250);
                        }
                    }

                }
                else{
                    that.cancelLibDocRequest();
                    needShowPopup = false;
                    popupDiv.hide();
                }
            });
        }
        catch(er){}
    }

};

/**
 * Отменяем запрос, если по новому объекты надо показывать инфу
 */
PreviewPopUp.prototype.cancelLibDocRequest = function(){
    if(goog.isDef(this.currentRequest))
        this.currentRequest.abort();
};

/**
 * Получение данных по объекту для превью
 * @param objectId идентификатор объекта, по которому необъодимо получить превью
 * @param callback колбек результата
 */
PreviewPopUp.prototype.getLibDocById = function(objectId,callback){
    var that = this;
    function getLibDocByIdParams(objectId, request) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '" '+ topFiltersStr+''+
            '>'+
            '<data FILTER="ID='+objectId+'" />'+
            '</root>'
        };
    }
    function getLibDocByIdResult(resultXml) {
        if(goog.isDef(callback))
            callback({result:true,resultXml:resultXml});
    }

    function getLibDocByIdFault(resultXml) {
        callback({result:false});
    }

    return App.serverQueryXMLNodeWithTries(Services.processQueryNode, getLibDocByIdParams(objectId, that.requestLibDoc), getLibDocByIdResult, getLibDocByIdFault,4);
};

//Для получения preview документа используем DataRequest из openscales (так же как загружаются тайлы)
PreviewPopUp.prototype.getDocumentPreview = function(filePath, imgMinSize){
    var fullUrl = this.requestGetDocPreview;
    //Добавляем переменную с относительным путем к картинке (документу)
    fullUrl += "sourceUrl=" + encodeURIComponent(filePath);
    //Добавляем переменные width и height по-отдельности, один из параметров может быть не задан
    if (!isNaN(imgMinSize) && imgMinSize > 0)
        fullUrl += "&size=" + imgMinSize.toString();
    //fullUrl+='&maxWidth=0&maxHeight=0';
    //Загружаем картинку по полученному fullUrl
    if(fullUrl != '')
        $('#documentPreviewPopupImg').attr({
            src: fullUrl});
    else
        $('#documentPreviewPopupImg').attr({
            src: './'+this.defaultImage});
};
/**
 * Класс всплывающей формы отображения статуса процесса выполнения (груповая обработка)
 */
/* TEXT CONSTANTS */
/**/
var PROCESS_STATUS_FORM_TOTAL_COUNT_TEXT = gis_processstatusform_1;
var PROCESS_STATUS_FORM_PROCESSED_COUNT_TEXT = gis_processstatusform_2;
var PROCESS_STATUS_FORM_ERRORS_COUNT_TEXT = gis_processstatusform_3;

function ProcessStatusForm() {
    this.title = gis_processstatusform_4;
    this.closable = false;
    this.htmlUrl = 'ui/html/ProcessStatusForm.html';

    this.totalCount = 0;
    this.processedCount = 0;
    this.errorsCount = 0;
    this.proceedIds = [];
    this.proceedLayerName = '';

    this.cancelBtnPressed = false;
    //Обрабатываемый массив
    this.objectsArray = [];
    //Объект, от которого выполняются функции (модуль или форма, от которой запустили эту форму)
    this.thisObject;
    //Функция обработки текущего элемента массива и ее аргументы
    this.processFunction = null;
    //Функция, выполняемая при завершении обработки и ее аргументы
    this.endFunction = null;
    //Функция, выполняемая при отмене обработки - обычно в ней будет отменяться текущий выполняемый вызов
    this.cancelFunction = null;

    //Форма выбора действия при возникновении ошибки в операции
    this.actionOnErrorForm;
    //Запомнить ли выбор в форме выбора действия
    this.continueToAll = false;
};

ProcessStatusForm.prototype.build = function(elementId) {
    var that = this;
    //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
    function build() {
        //Функция обновления значения в форме
        that.changeFormValues = function changeFormValues() {
            //Устанавливаем всем элементам формы нужный текст
            $("div[name='totalCountText']").text(PROCESS_STATUS_FORM_TOTAL_COUNT_TEXT + that.totalCount);
            $("div[name='processedCountText']").text(PROCESS_STATUS_FORM_PROCESSED_COUNT_TEXT + that.processedCount);
            $("div[name='errorsCountText']").text(PROCESS_STATUS_FORM_ERRORS_COUNT_TEXT + that.errorsCount);
        };
        //Обновляем значения в полях формы
        that.changeFormValues();
        //Создаем диалоговую форму
        dlg.dialog({
            modal: true,
            title: that.title,
            dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
            closeOnEscape: that.closable,
            width: 410,
            height: 120,
            open: function( event, ui ) {
                that.processArray();
            }
        });

        //Кнопка отмены
        $("input[name='cancel']", dlg).click(function () {
            //that.cancel();
            that.onCancelClick();
        });
    }

    that.elementId = elementId;

    $('#'+elementId).remove();
    //Создаем форму экспорта в GPX или KML
    $('body').append('<div id="'+elementId+'"></div>');
    var dlg = $('#'+elementId);

    dlg.load(this.htmlUrl, build);
};

ProcessStatusForm.prototype.cancel = function() {
    $('#'+this.elementId).remove();
};

ProcessStatusForm.prototype.processArray = function processArray() {
    var that = this;
    //Если в форме статуса нажали кнопку отмены - завершаем операции
    if (that.cancelBtnPressed==true) {
        if (that.endFunction!=null && that.endFunction!=undefined) {
            that.endFunction.apply(that.thisObject,[that.errorsCount,that.processedCount, false, that.proceedLayerName, that.proceedIds]);
            that.endFunction = null; //Результат все равно вернется в callback и сделает processArray(), поэтому убираем функцию чтобы не вызывать дважды
        }
        that.endProcess();
        return;
    }
    if (that.objectsArray && that.objectsArray.length>0) {
        var curObj = that.objectsArray.pop();
        if(curObj){
            that.proceedLayerName = curObj.classId;
            that.proceedIds.push(curObj.objectId);
        }
        if (that.processFunction!=null)
            that.processFunction.apply(that.thisObject,[curObj]);
    } else {
        if (that.endFunction!=null && that.endFunction!=undefined)
            that.endFunction.apply(that.thisObject,[that.errorsCount,that.processedCount, false, that.proceedLayerName, that.proceedIds]);
        that.endProcess();
    }
};
//слушатель результата
ProcessStatusForm.prototype.processResultString = function processResultString(error/*String*/) {
    var that = this;
    if (error != "") {
        that.errorsCount++;
        //Обновляем значения в полях формы
        that.changeFormValues();
        //Если не было формы, реагирующей на ошибку, создаем ее
        if (!that.continueToAll && that.cancelBtnPressed==false) {
            that.actionOnErrorForm = new ActionOnErrorForm();
            that.actionOnErrorForm.parentProcessStatusForm = that;
            that.actionOnErrorForm.fullMessage = error;
            //Создаем форму
            that.actionOnErrorForm.build("actionOnErrorForm");//Форма выбора действия тоже всегда одна!
            //Добавляем слушатель (с дополнительным агрументом, чтобы по завершении иметь возможность вызова функций ProcessStatusForm)
            $("body").on(CloseEvent.CLOSE, that.onActionOnErrorFormClose);
        } else {
            that.processArray();
        }
    } else {
        that.processedCount++;
        //Обновляем значения в полях формы
        that.changeFormValues();
        that.processArray();
    }
};
//Слушатель события закрытия формы - нужно дальше обрабатывать, если detail==1 (продолжили)
ProcessStatusForm.prototype.onActionOnErrorFormClose = function onActionOnErrorFormClose(evt/*CloseEvent*/) {
    var that = this;
    $("body").off(CloseEvent.CLOSE);
    if (evt && evt.eventData) {
        that = evt.eventData.parent;
    }
    if (evt.eventData && evt.eventData['continue']) {
        //Сохраняем ли текущий выбор для следующих ошибок
        that.continueToAll = evt.eventData.saveChoose;
        //Если есть еще объекты для обработки - обрабатываем, иначе заканчиваем обработку
        that.processArray();
    } else {
        if (that.endFunction!=null){
            var isCancel = evt.eventData && evt.eventData['continue'] !== true;
            that.endFunction.apply(that.thisObject,[that.errorsCount,that.processedCount, isCancel, that.proceedLayerName, that.proceedIds]);
        }
        that.endProcess();
    }
};
//По завершении процесса обработки нужно закрывать созданные формы
ProcessStatusForm.prototype.endProcess = function endProcess() {
    var that = this;
    //Убираем форму выбора действия при ошибке
    that.deleteActionOnErrorForm();
    //Убираем форму статуса
    that.onCancel();
};
//Удаляем форму работы с групповыми ошибками, если она есть
ProcessStatusForm.prototype.deleteActionOnErrorForm = function deleteActionOnErrorForm() {
    var that = this;
    if (that.actionOnErrorForm) {
        that.actionOnErrorForm.cancel();
        that.actionOnErrorForm = null;
    }
};

ProcessStatusForm.prototype.onCancelClick = function onCancelClick() {
    var that = this;
    that.cancelBtnPressed = true;
    //2012_12_05 - при нажатии кнопки "Отмена" реально отменяем текущий запрос и заканчиваем работу
    if (that.cancelFunction!=null)
        that.cancelFunction.apply(that.thisObject,[]);
    //Для завершения работы нужно вызвать последнюю обработку - результата текущей операции мы уже не получим
    that.processArray();
};

ProcessStatusForm.prototype.onCancel = function onCancel() {
    var that = this;
    that.removeMe();
};

ProcessStatusForm.prototype.removeMe = function removeMe(hasChanges/*Boolean*/) {
    var that = this;
    /*that.dispatchEvent(new CloseEvent(CloseEvent.CLOSE,false,false,hasChanges ? 1 : -1));*/
    //Закрываем форму
    that.cancel();
    /*PopUpManager.removePopUp(this);*/
};
/**
 * Класс всплывающей формы с экспортом в GPX или KML
 */
/* TEXT CONSTANTS */

var GPX_TITLE = gis_exportgpxkmlform_2;
var KML_TITLE = gis_exportgpxkmlform_3;

function ExportGpxKmlForm() {
    this.closable = true;
    this.htmlUrl = 'ui/html/ExportGpxKmlForm.html';
    this.exportArray = [];
    this.elementId = undefined;
    this.dataRequest = '';
	this.dataProvider = '';
    this.layerName = '';
	this.requestParams = '';
	this.projection = null;
};

ExportGpxKmlForm.prototype.build = function() {
    var that = this;
    try {
        //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
        function build() {
            //Создаем диалоговую форму
            dlg.dialog({
                modal: true,
                title: gis_exportgpxkmlform_2,
                dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
                closeOnEscape: that.closable,
	            width: 320,
	            height: 203,
	            close: function(event, ui){
		            try{
			            $(this).dialog('destroy').remove();
		            }catch(e){}
	            }
            });
	        $('#radioGPX', dlg).prop( "checked" , true);
	        //Кнопки выбора опции
            $('#radioGPX',dlg).click(function () {
	            dlg.dialog('option', 'title',gis_exportgpxkmlform_2);
            });
	        $('#radioKML',dlg).click(function () {
		        dlg.dialog('option', 'title',gis_exportgpxkmlform_3);
            });

	        //Кнопки Ок и отмены
	        $("input[name='export']", dlg).click(function () {
		        that.exportGpxKml();
	        });
	        $("input[name='cancel']", dlg).click(function () {
		        App.destroyDialog(that.elementId);
	        });
        }
	    this.elementId = 'exportGPXKmlDialog_'+parseInt(Math.random()*1000000);
		try{
			$('#'+this.elementId).dialog('destroy').remove();
		}
		catch(e){
		}
	    $('#'+this.elementId).remove();
        //Создаем форму экспорта в GPX или KML
        $('body').append('<div id="'+this.elementId+'"></div>');
        var dlg = $('#'+this.elementId);

        dlg.load(this.htmlUrl, build);

    } catch (e) {
        App.errorReport(gis_exportgpxkmlform_4, e.message, undefined, {filename:gis_filename_310, functionname:'gis_filename_310_1'});
        //Закрываем форму
	    App.destroyDialog(that.elementId);
    }
};

ExportGpxKmlForm.prototype.exportGpxKml = function() {
	var that = this;
	try {
		//условие для обработки замечания "Если объекты не выбраны в гриде, то при нажатии групповой кнопки и затем выборе экспорта выдается ошибка при создании файла при экспорте в GPX."
		if (this.requestParams === ''){
			App.confirmDialog(gis_exportgpxkmlform_9);
			return;
		}
		var dlg = $('#'+that.elementId);
		var dataArr = that.exportArray;
		var fileName, exportTo, encoding;
		//если стоит чекбокс GPX
		if($('input[id="radioGPX"]', dlg).is(':checked')) {
			exportTo = ExportUtil.GPX;
			//Имя файла gpx всегда одно и то же в рамках одной сессии
			fileName =  App.generateUUID() + ".gpx";
		}
		else {
			exportTo = ExportUtil.KML;
			//Имя файла kml всегда одно и то же в рамках одной сессии
			fileName =  App.generateUUID() + ".kml";
		}
		if($('input[id="encodingANSI"]', dlg).is(':checked'))
			encoding = 'cp1251';
		else
			encoding = 'utf8';
			
		BlockingUtil.wait();
		App.getJsonNode(Services.exportGdalNode, {
			descrId : this.dataRequest,
			descrType  : 'select',
			data  : this.requestParams,
			path   : fileName,
			driver: exportTo,
			encoding: encoding,
			projection: this.projection,
			spatial: this.dataProvider.spatial,
			semantic: this.dataProvider.semantic
		},
			function result(res) {
				BlockingUtil.ready();
				var uploadPath = App.config["UPLOAD_PATH"];
				var fileUrl = uploadPath + fileName;
				var exportForm = new ExportForm();
				exportForm.link = fileUrl;
				exportForm.build();
				App.destroyDialog(that.elementId);
		},
			function fault(res) {
				BlockingUtil.ready();
				var errorText = exportTo === ExportUtil.GPX ? gis_exportgpxkmlform_5 : gis_exportgpxkmlform_7;
				App.errorReport(errorText, res.message, undefined, {filename:gis_filename_615, functionname:'gis_filename_615_5'});
				App.destroyDialog(that.elementId);
			});
	} catch (e) {
		//Устанавливаем обычный курсор
		App.errorReport(gis_exportgpxkmlform_4, e, undefined, {filename:gis_filename_310, functionname:'gis_filename_310_6'});
		//Закрываем форму
		App.destroyDialog(that.elementId);
	}
};



// Запрос создания на сервере файла GPX в указанной директории (экспорт из грида)
ExportGpxKmlForm.prototype.makeCreateGPXReqParams = function makeLoadDataCountReqParams(fileName, content) {
    return {
        path: fileName,
        data: content
    };
};
/**
 * Класс всплывающей формы с экспортом/импортом GPX или KML
 */
function ImportExportGpxKmlForm() {
	this.semanticAttrs = [];// массив переменных из команды insert
	this.fileAttrs = [];// массив паарметров из файла gpx,kml
	this.processStatusForm = null;
	//массив объектов для вставки данных после парсинга gpx/kml
	this.features = [];
	this.importedIds = [];
	//массив геометрий
	this.wkts = [];
	//массив параметров, которые исключаются из формы сопоставления атрибутов
	this.excludeVars = {
		fromPpanel: ['ID', 'POLICY', 'USER_ID', 'PODS_USER'],
		fromKml: ['styleUrl', 'timespan', 'styleHash', 'stroke', 'stroke-opacity',
			'stroke-width', 'fill', 'fill-opacity', 'visibility', 'coordTimes', 'styleMapHash']
	};
	goog.base(this);
}
goog.inherits(ImportExportGpxKmlForm, ExportGpxKmlForm);

ImportExportGpxKmlForm.prototype.build = function () {
	var that = this;
	try {
		function build() {
			dlg.dialog({//диалоговая форма для выбора экспорт/импорт
				modal: true,
				title: gis_importexportgpxkmlform_1,
				dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
				closeOnEscape: that.closable,
				resizable: false,
				width: 320,
				height: 244,
				close: function () {
					try {
						$(this).dialog('destroy').remove();
					} catch (e) { }
				}
			});
			$('#radioExport', dlg).click(function () {
				$("input[name='export']", dlg).prop('defaultValue', gis_importexportgpxkmlform_4);
			});
			$('#radioImport', dlg).click(function () {
				$("input[name='export']", dlg).prop('defaultValue', gis_importexportgpxkmlform_3);
			});
			//Кнопки Ок и отмены
			$("input[name='export']", dlg).click(function () {
				if ($("input[name='export']", dlg).prop('defaultValue') === gis_importexportgpxkmlform_4)
					that.exportGpxKml();
				else
					that.importGpxKml();
				App.destroyDialog(that.elementId);
			});
			$("input[name='cancel']", dlg).click(function () {
				App.destroyDialog(that.elementId);
			});

		}
		this.elementId = 'importExportGPXKmlDialog_' + parseInt(Math.random() * 1000000);
		try {
			$('#' + this.elementId).dialog('destroy').remove();
		}
		catch (e) {
		}
		$('#' + this.elementId).remove();
		//Создаем форму экспорта/импорта в GPX или KML
		$('body').append('<div id="' + this.elementId + '"></div>');
		var dlg = $('#' + this.elementId);

		dlg.load(this.htmlUrl+'?'+Math.round(), build);

	} catch (e) {
		App.errorReport(gis_exportgpxkmlform_4, e.message, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_1' });
		App.destroyDialog(that.elementId);
	}
};

/**
 * Функция создания формы для выбора файла и загрузки на сервер
 */
ImportExportGpxKmlForm.prototype.importGpxKml = function () {
	var that = this;
	var fileFormat = $('input[id="radioGPX"]', dlg).is(':checked') ? 'GPX' : 'KML';
	var uploadPath = Auth.getUid();
	function importFile() {
		//Проверяем, что поле выбранного файла не пустое
		if ($("#myElement").val() == '')
			return;
		var form = $('#fr_myElement');
		form.attr('action', form.data('action'));//.submit();
		form.submit();
	}

	function cancel() {
		dlg.dialog('destroy').remove();
	}
	var element = $('<div id="baseFileDivTrack" style="display: block;height: 46px !important;">\
                        <div class="importExportLabel">Нажмите кнопку (...) для выбора файла</div>\
                        <div id="divFI_myElement" class="divFileInput importExportFileInput">\
                        <div class="divFileInputNameTree"><input id="myElement" type="text" disabled value="" data-typecontrol="inputfile" class="formControl importExportFileInputName" data-loadvalue=true /></div>\
                        <form method="POST" id="fr_myElement" action="" data-action="./api/files/upload?path=UploadedFiles/'+
						uploadPath + '" enctype="multipart/form-data" class="frmInputFile" target="ifr_myElement">\
                        <input id="iFI_myElement" type="file" class="iFileInput" style="width:20px" data-typecontrol="file" data-filename="" class="iFileInput" accept=".'+ fileFormat.toLowerCase() +'" name="fileinput" />\
                        </form>\
                        <iframe id="ifr_myElement" name="ifr_myElement" class="noVisible" data-checkload=false></iframe>\
                       </div>\
                        </div>');
	$('body').append(element);

	var buttons = [];
	buttons.push({ text: gis_importutil_8, click: importFile, id: 'iFI_import' });
	buttons.push({ text: gis_core_6, click: cancel });
	var dlg = $(element).dialog({
		title: gis_importutil_9,
		width: 340,
		height: 120,
		resizable: false,
		modal: true,
		buttons: buttons
	});
	$('#ifr_myElement').load(function () {
		if ($("#myElement").val() == '') {
			return;
		}
		$("#myElement").val('');
		that.processImport(fileFormat);
		dlg.dialog('destroy').remove();
	});
	$('#iFI_myElement').change(function () {
		var fileName = $("#iFI_myElement").val().split('\\');
		if (fileName.length != 1) fileName = fileName[fileName.length - 1].split('.');
		else fileName = fileName[0].split('.');
		fileName = fileName.join('.');
		$("#myElement").val(fileName);
		$("#iFI_import").prop('disabled', false);
	});
	$("#iFI_import").prop('disabled', true);
}
/**
 * Функция импорта 
 */
ImportExportGpxKmlForm.prototype.processImport = function (driver) {
	var that = this;
	var guid = GridAdmInternal.generateProcessGUID();
	var processGuid = guid;//'78e29bcf';
	var requestOptions = {
		'method': 'GET',
		'dataType': 'text'
	};
	BlockingUtil.wait();
	App.getJsonTextNode(Services.parseGdalNode, {//Отправляем файл на back-end для парсинга
		process_id: processGuid,
		data: {
			USER_ID: Auth.getUserId(),
			STATUS_ID: 1,
		},
		path: Auth.getUid(),
		driver: driver
	}, function onResult(resultJson) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultJson);
		if (er !== "") {
			App.errorReport(gis_importexportgpxkmlform_6, er, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_3' });
			return;
		}
		try {
			var json = JSON.parse(resultJson);
			that.wkts = json.wktGeo || [];
			that.features = json.features || [];
			if (that.wkts.length > 0 && that.features.length > 0 && that.wkts.length === that.features.length) {
				//показываем форму соотнесения параметров
				that.openMergeForm(that.features);
			} else {
				App.errorReport(gis_importexportgpxkmlform_6, gis_importexportgpxkmlform_10, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_7' });
			}
		} catch (ex) {
			App.errorReport(gis_importexportgpxkmlform_6, ex.message, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_10' });
		}
	}, function onFault(resultJson) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultJson);
		if (er !== "") {
			App.errorReport(gis_importexportgpxkmlform_6, er, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_5' });
		}
	}, undefined, requestOptions);
};

/**
 * Открытие формы сопоставления параметров
 */
ImportExportGpxKmlForm.prototype.openMergeForm = function (features){
	var that  = this;
	if(!this.dataProvider && !this.dataProvider.semantic){
		that.openPropertyPanelForm();
	}
	//this.semanticAttrs = ['NAME', 'DESCR', 'TIME_STAMP', 'COMMENTS', 'SYMBOL', 'STATUS_ID'];
	this.fileAttrs = [];
	if(features && features.length > 0){
		features.forEach(function(feature){
			if(feature.properties){
				for(var p in feature.properties){
					if (that.excludeVars.fromKml.indexOf(p) === -1 && that.fileAttrs.indexOf(p) === -1)
						that.fileAttrs.push(p);
				}
			}
		});
	}
	function getParams() {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var request = that.dataProvider.semantic;
		return {
			descrId: 'SYS_SEM.xml#GET_DATA_XML', descrType: 'select',
			data:  '<root USER_ID="'+userId.xmlEscape() + '" USER_LOGIN="'+userLogin.xmlEscape()+ '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
					'<data file="'+request.split("#")[0]+'" dataId="'+request.split("#")[1]+'" />'+
				   '</root>'
		};
	}
	function result(resultXml) {
		try {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') {
				App.errorReport(gis_importexportgpxkmlform_16, er, undefined, {filename:gis_filename_311, functionname:'gis_filename_311_4'});
			}
			else{
				var insert = resultXml.find("insert");
				if (insert.length > 0 && insert[0].getElementsByTagName("dbCommand").length > 0) {
					var vars = insert[0].getElementsByTagName("dbCommand")[0].getElementsByTagName("var");
					var params = insert[0].getElementsByTagName("dbCommand")[0].getElementsByTagName("param");
					var i=0;
					for(; i < vars.length;i++){
						//Получаем переменные команды insert
						var attrName = vars[i].getAttribute('name');
						if(that.excludeVars.fromPpanel.indexOf(attrName) === -1)
							that.semanticAttrs.push(attrName);
					}
					for(i=0; i < params.length;i++){
						//Получаем переменные команды insert
						var attrName = params[i].getAttribute('name');
						if(that.excludeVars.fromPpanel.indexOf(attrName) === -1)
							that.semanticAttrs.push(attrName);
					}
				}
			}
		}
		catch(ex){ }
		var mergeAttributesForm = new MergeAttributesForm({
			features: features,
			fileAttrs: that.fileAttrs,
			semanticAttrs: that.semanticAttrs,
			applyCallback:function(attrs){
				that.openPropertyPanelForm(attrs);
			}});
		mergeAttributesForm.build();
	}
	function fault(resultXml) {
		App.errorReport(gis_importexportgpxkmlform_16, resultXml, undefined, {filename:gis_filename_311, functionname:'gis_filename_311_4'});
		that.openPropertyPanelForm([]);
	}
	App.serverQueryNodeWithTries(Services.processQueryNodeXml, getParams(), result, fault);
}

/**
 * Соотнесенные атрибуты
 * @param attrs
 */
ImportExportGpxKmlForm.prototype.openPropertyPanelForm = function(attrs){
	var that = this;
	var mapPropPanelId = 'mapPPanel';
	$('#' + mapPropPanelId).remove();
	var mapPropPanelDiv = '<div id="' + mapPropPanelId + '"></div>';
	$('body').append(mapPropPanelDiv);
	//Создаем панель свойств по согласованию Бочкова, чтобы пользователь заполнил нужные ему поля для вставки семантики
	$('#' + mapPropPanelId).myPropertiesPanel({
		objects: [{ id: that.layerName, label: '', flag: 'import' }],
		opener: 'body',
		skipValidation: true,
		handlers: {
			applyCallback: function (serializedData) {
				that.features.forEach(function(feature, i){
					feature.serializedData = serializedData;
					feature.mergedData = attrs;
					feature.wkt = that.wkts[i];
				})
				that.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_importexportgpxkmlform_14, that.features, that, that.insertObject, that.endProcess);
			}
		}
	});
}

ImportExportGpxKmlForm.prototype.convertSimpleObjectToXml_ = function (simpleObj) {
	var resXml = '<data ';
	for (var attrName in simpleObj) {
		var attrValue = simpleObj[attrName];
		if(attrValue){
			try{
				attrValue = attrValue.xmlEscape();
			}
			catch (ex){}
			resXml += attrName + '="' + attrValue  + '" ';
		}
	}
	resXml += ' />';
	return resXml;
};

ImportExportGpxKmlForm.prototype.endProcess = function(errorsCount, processedCount){
	//Очищаем форму статуса процесса
	this.processStatusForm = null;
	if (processedCount){
		//обновляем грид
		if(WidgetMap.layerManager){
			var layer = WidgetMap.layerManager.getLayerByName(this.layerName);
			if(layer && layer.layer){
				if(layer.layer.useServerCache){
					App.confirmDialog(gis_importexportgpxkmlform_11.replace('{ROWS_COUNT}', processedCount), null, {title:gis_core_1, html:true});
				}
				else{
					App.confirmDialog(gis_importexportgpxkmlform_11_1.replace('{ROWS_COUNT}', processedCount), null, {title:gis_core_1, html:true});
					layer.layer.loadDataByIds(this.importedIds);
					/*//чистим слой
					layer.layer.clear();
					layer.layer.dataReady_ = false;
					//перезапрашиваем данные для слоя
					layer.layer.canLoadData = true;
					layer.layer.canFirstTimeCentering = false;
					layer.layer.loadData();*/
				}
			}
		}
		if(GridWidget)
			GridWidget.refreshGrid(this.currentGridId);
	}
};


ImportExportGpxKmlForm.prototype.insertObject = function(data){
	this.insertSemanticObject_(data)
};

ImportExportGpxKmlForm.prototype.insertSemanticObject_ = function(data){
	var that = this;
	var wkt = data.wkt;
	var props = data.properties;
	var serializedData = data.serializedData;
	var mergesData = data.mergedData;
	if(mergesData){
		for(var key in mergesData){
			var propsData = props[mergesData[key]];
			if(propsData !== undefined)
				serializedData[key] = propsData;
			else{
				propsData = props[mergesData[key].toLowerCase()];
				if(propsData !== undefined)
					serializedData[key] = propsData;
			}
		}
	}
	var dataXml = this.convertSimpleObjectToXml_(serializedData);
	var requestParams = {
		descrId: that.dataProvider.semantic,
		descrType: 'insert',
		data:'<root USER_ID="' + Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">' +
			dataXml +'</root>'
	};
	App.serverQueryNodeWithTries2(Services.processQueryNode, requestParams,
		function (data) {
			if (data) {
				var er = HTTPServiceUtil.getError(data);
				if (er !== '') {
					if (that.processStatusForm)
						that.processStatusForm.processResultString(er);
					return;
				}
				try {
					var semId = $($.parseXML(data)).find('data').attr('ID');
					if (semId)
						that.insertSpatialObject_(semId, wkt);
				} catch (ex) {
					if (that.processStatusForm)
						that.processStatusForm.processResultString(ex.message);
				}
			}
		},
		function (data) {
			var er = HTTPServiceUtil.getError(data);
			if (that.processStatusForm)
				that.processStatusForm.processResultString(er);
		}
	);
}

ImportExportGpxKmlForm.prototype.insertSpatialObject_ = function(semId, wktGeo){
	var that = this;
	var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
	var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
	var requestParams = {
		descrId: this.dataProvider.spatial,
		descrType: 'insert',
		data: '<root USER_ID="' + userId.xmlEscape() +
			'" USER_LOGIN="' + userLogin.xmlEscape() +
			'" PODS_USER="' + userLogin.xmlEscape() +
			'">' +
			'<data ID="' + semId + '" WKT="' + wktGeo + '" />' +
			'</root>'
	};
	BlockingUtil.wait();
	App.serverQueryXMLNodeWithTries(Services.processQueryNodeGeo, requestParams,
		function insertGeoResult(resultXml) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXml);
			if(er === '')
				that.importedIds.push(semId);
			if (that.processStatusForm)
				that.processStatusForm.processResultString(er);
		}, function insertGeoFault(resultXml) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXml);
			if (that.processStatusForm){
				that.processStatusForm.processResultString(er);
			}
		});
}
/**
 * Класс всплывающей формы с экспортом/импортом GPX или KML
 */
function MergeAttributesForm(opt_options) {
	var options = opt_options ? opt_options : {};
	this.fileAttrs = (options.fileAttrs) ? options.fileAttrs : [];
	this.features = (options.features)? options.features: [];
	this.semanticAttrs = (options.semanticAttrs) ? options.semanticAttrs : [];
	this.applyCallback = options.applyCallback;
	this.htmlUrl = 'ui/html/MergeAttributesForm.html';
	this.elementId = 'mergeAttributesDialog';
}

MergeAttributesForm.prototype.build = function () {
	var that = this;
	try {
		function build() {
			var visibleRowsHeight = 210;//that.semanticAttrs.length <= 10 ? that.semanticAttrs.length * 25: 10 * 25 ;
			dlg.dialog({
				modal: true,
				resizable: true,
				title: gis_mergeattributesform_1,
				dialogClass: 'noCloseButton gsi-zindex__merge-form',
				closeOnEscape: false,
				width: 580,
				height: (150/*базовая высота*/ + visibleRowsHeight),
			});
			//Кнопки Ок и отмены
			$("input[name='apply']", dlg).click(function () {
				var attrs = [];
				attrs = that.formatAttributes();
				if(that.applyCallback)
					that.applyCallback(attrs);
				App.destroyDialog(that.elementId);
			});
			$("input[name='cancel']", dlg).click(function () {
				App.destroyDialog(that.elementId);
			});
			$('#mergeAttributesInfo').text(gis_mergeattributesform_3 + that.features.length);
			that.fillData_();
		}
		App.destroyDialog(that.elementId);
		$('body').append('<div id="' + this.elementId + '"></div>');
		var dlg = $('#' + this.elementId);
		dlg.load(this.htmlUrl+'?'+Math.round(), build);

	} catch (e) {
		App.errorReport(gis_exportgpxkmlform_4, e.message, undefined, { filename: gis_filename_311, functionname: 'gis_filename_311_1' });
		App.destroyDialog(that.elementId);
	}
};

MergeAttributesForm.prototype.fillData_ = function() {
	var that = this;
	var mergeTable = $('#mergeAttributesTable');
	this.fileAttrs.unshift(gis_mergeattributesform_2);
	var upperFileAttrs = [];
	this.fileAttrs.forEach(function(fileAttr){
		upperFileAttrs.push(fileAttr.toUpperCase());
	});
	this.semanticAttrs.forEach(function(semanticAttr, i){
		var options = '';
		that.fileAttrs.forEach(function(fileAttr){
			options += '<option value="'+fileAttr.toUpperCase()+'">'+fileAttr.toUpperCase()+'</option>';
		})

		var row = $('<div id="mergeAttributesDiv_' + i + '" class="merge-attributes-div">' +
				'   <div id="mergeAttributesFromSemantic_' + i + '" class="merge-attributes-from-semantic">' + semanticAttr + '</div>' +
				'   <div style="display: inline-block"">' +
					'       <select id="mergeAttributesFromFile_' + i + '" class="merge-attributes-from-file">'  +
							options +
					'       </select>' +
				'   </div>' +
				'</div>');
		mergeTable.append(row);
		if(upperFileAttrs.indexOf(semanticAttr) !== -1){
			$("#mergeAttributesFromFile_" + i).val(semanticAttr).change();
		}
	});

}
MergeAttributesForm.prototype.formatAttributes = function() {
	var attrs = {};
	this.semanticAttrs.forEach(function(semanticAttr, i){
		var selected = $('#mergeAttributesFromFile_' + i).val();
		if(selected !== gis_mergeattributesform_2){
			attrs[semanticAttr] = selected;
		}
	});
	return attrs;
}
var CAROUSEL_DATA_REQUEST = 'SYS_SEM.xml#LIB_DOC_COMMENTS_LIST';
//максимальное количество запрашиваемых данных. upd. 22.03.22 добавили лимит 500, т.к. в казани не хватало 50
var CAROUSEL_DATA_COUNT_LIMIT = 500;

var CAROUSEL_AVAILABLE_IMAGES = ['png', 'jpg', 'gif', 'jpeg'];

/**
 * Класс формы отображения галереии в виде карусели библиотекой flickity
 * @see https://flickity.metafizzy.co/
 */
function CarouselForm(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	// объект с данными(строка грида) из которого забирать параметры для формирования запроса на получения списка картинок
	this.layerName = options.layerName;
	this.data = options.data;
}

CarouselForm.prototype.build = function() {
	this.loadData_();
}

/**
 * Загружаем данные для заполнения
 * @private
 */
CarouselForm.prototype.loadData_ = function () {
	var that = this;
	if(!this.data)
		App.errorReport(gis_carouselform_1, gis_carouselform_2, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_1'})
	else{
		var sysFullId = (this.data.LG_ATTACH) ? this.data.LG_ATTACH : this.layerName + '/' + this.data.ID;
		sysFullId = sysFullId.replace(new RegExp('"','g'),'&quot;')
		var requestData = '<root><data  SYS_FULL_ID="' + sysFullId + '" ' +
						'LOW_LIMIT="0" HIGH_LIMIT="' + CAROUSEL_DATA_COUNT_LIMIT + '"/></root>';
		var requestParams = {
			descrType: 'select', descrId: CAROUSEL_DATA_REQUEST,
			data: requestData
		};
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, requestParams, function (resultXML){
			BlockingUtil.ready();
			if (!resultXML)
				App.errorReport(gis_carouselform_1, gis_carouselform_2, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_2'})
			else {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== '') {
					App.errorReport(gis_carouselform_1, er, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_3'})
				} else {
					that.makeData_(resultXML);
				}
			}
		}, function (resultXML){
			BlockingUtil.ready();
			App.errorReport(gis_carouselform_1, resultXML, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_4'})
		});
	}
}

/**
 * Подготавливаем данные для заполенение карусели
 * @param resultXML результат, полученный из БД, содержащий перечень документов
 * @private
 */
CarouselForm.prototype.makeData_ = function (resultXML) {
	var datas = [];
	try{
		var result = $($.parseXML(resultXML));
		result.find('data').each(function (){
			var curdData = $(this);
			var data = {
				FILE_NAME: curdData.attr('FILE_NAME') || '',
				CTIME: curdData.attr('CTIME') || '',
			};
			if(data.FILE_NAME)
				datas.push(data);
		});
		this.buildCarousel_(datas);
	}
	catch(ex){
		App.errorReport(gis_carouselform_1, ex.message, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_5'})
	}
}

/**
 * Заполнение карусели
 * @param {Object} datas
 * @private
 */
CarouselForm.prototype.buildCarousel_ = function (datas) {
	var that = this;
	if(!datas || datas.length === 0)
		App.confirmDialog(gis_carouselform_3,null,{title:''});
		//App.errorReport(gis_carouselform_1, gis_carouselform_3, undefined, {filename:gis_filename_627, functionname:'gis_filename_627_6'})
	else{
		// main div
		var carouselDiv = '<div class="carousel carousel-docs" data-flickity>';
		//preview div
		var carouselNavDiv = '<div class="carousel carousel-nav-docs" data-flickity>';
		//нужен ли блок навигации
		var needNav = datas.length > 1;
		datas.forEach(function(data, i){
			carouselDiv += that.buildCarouselCell_(data, i, datas.length);
			if(needNav)
				carouselNavDiv += that.buildCarouselNavCell_(data);
		});
		carouselDiv +=   '</div>';
		$('#carouselDocs').remove();
		var divv = '<div id="carouselDocs" class="carousel-dialog">' + carouselDiv + carouselNavDiv +'</div>';
		$('body').append(divv);
		var dlg = $('#carouselDocs');
		dlg.dialog({ title: '', modal: false,
			dialogClass: 'ui-dialog-confirm', closeOnEscape: true,
			width: 618, height: (needNav) ? 543 : 445,
			resizable: true, buttons : []
		});
		$('.carousel-docs').flickity({
			prevNextButtons: true,
			wrapAround: true,
			pageDots: false,
			fullscreen: true
		});

		$('.carousel-nav-docs').flickity({
			asNavFor: '.carousel-docs',
			prevNextButtons: false,
			pageDots: false,
			contain: true,
			fullscreen: false,
			lazyload: 5
		});
	}
}

/**
 * Формирование ячейки для галереи
 * @param data
 * @private
 */
CarouselForm.prototype.buildCarouselCell_ = function (data, index, length) {
	var fileName = data.FILE_NAME;
	var libPath = (App.config !== null && App.config.LIB_PATH) ? App.config.LIB_PATH : '';
	var src = libPath + encodeURI(fileName);
	if (data.FILE_NAME.indexOf('pdf#') !== -1){
		fileName = data.FILE_NAME;
		src = Services.pdfPreview + '?maxWidth=290&maxHeight=412&sourceUrl=' + encodeURI(fileName);
	}else{
		fileName = libPath + encodeURI(data.FILE_NAME);
		src = Services.docPreview + '?maxWidth=290&maxHeight=412&sourceUrl=' + fileName + '&rand=' + Math.random();
	}

	//формирование блока с описанием документа
	var smallFileName =  data.FILE_NAME.replace(/^.*[\\\/]/, '');
	var carouselDescriptionDiv = '<div class="carousel-cell-descr" >' +
		'<label class="carousel-cell-descr__page">' + (index + 1) + gis_carouselform_5 + length + '</label>'+
		'<label class="carousel-cell-descr__time">'+gis_carouselform_4 + data.CTIME + '</label>'+
		'<label class="carousel-cell-descr__filename">'+smallFileName + '</label>'+
		/*'<span class="carousel-cell-descr__filelink"><a href="#" onclick="CarouselForm.getFileLink(\'' + src + '\');return false;">' +
		'         <img src="/ui/images/tag.png" style="height: 16px;">Ссылка на файл' +
		'      </a> | ' +
		'</span>' +*/
		'<span class="carousel-cell-descr__openfile"><a href="#" onclick="HTTPServiceUtil.openFile(\'' + fileName + '\'); return false;">' +
				'<img src="/ui/images/save.png" style="height: 16px;">Скачать файл' +
		'      </a>' +
		'</span>' +
		'<span class="carousel-cell-descr__rotateImg"><a href="#" onclick="CarouselForm.rotateImg(); return false;">' +
		'<img src="/ui/images/rotate_right.png" style="height: 16px;" title="'+ gis_carouselform_6 +'">' +
		'      </a>' +
		'</span>' +
		'</div>';
	var fileExtension = fileName.split('.').pop();
	if (fileExtension.indexOf('#') !== -1) fileExtension = fileExtension.split('#').shift();
	var imgSrc = CAROUSEL_AVAILABLE_IMAGES.indexOf(fileExtension.toLowerCase()) !== -1 ? fileName : '';
	var cellHtml = '<div class="carousel-cell" >' +
		'<img class="carousel-cell-image" src="' + fileName + '" data-rotate="0" />' +
		carouselDescriptionDiv +
		'</div>';
	//если картинка и её нет на сервере, запрашиваем ошибочную картинку от сервиса превьюшек
	if(imgSrc && !HTTPServiceUtil.isUrlExists(imgSrc))
		imgSrc = '';
	if(!imgSrc){// случай документов, pdf, страниц pdf
		cellHtml = '<div class="carousel-cell" >' +
			//'<img class="carousel-cell-image__doc" src="' + src.replace('#','$') + '" data-rotate="0" />' +
			'<div class="carousel-cell-image__doc" style="background: url(' + src.replace('#','$') + ') no-repeat center; " ></div>' +
			carouselDescriptionDiv +
			'</div>';
	}
	//var cellHtml = '<div class="carousel-cell" style="background: url(' + src + ') no-repeat center;" ></div>';
	return cellHtml;
}

/**
 * Формирование ячейки для превью
 * @param data
 * @private
 */
CarouselForm.prototype.buildCarouselNavCell_  = function (data) {
	var libPath = (App.config !== null && App.config.LIB_PATH) ? App.config.LIB_PATH : '';
	var src = '';
	if (data.FILE_NAME.indexOf('pdf#') !== -1){
		src = Services.pdfPreview + '?maxWidth=168&maxHeight=88&sourceUrl=' + encodeURI(data.FILE_NAME.replace('pdf#','pdf$'));
	}else {
		src = Services.docPreview + '?maxWidth=168&maxHeight=88&sourceUrl=' + libPath + encodeURI(data.FILE_NAME) + '&rand=' + Math.random();
	}
	var cellHtml = '<div class="carousel-nav-cell" style="background: url(' + src + ') no-repeat center; " ></div>';
	return cellHtml;
};

CarouselForm.rotateImg = function(){
	var carouselSelectedItem =  $('.carousel-cell-image','.carousel-cell.is-selected');
	var deg = carouselSelectedItem.data('rotate') || 0;
	var newDeg = deg === 360 ? 90 :deg + 90;
	var rotate = 'rotate(' + newDeg  + 'deg)';
	var width = carouselSelectedItem.width();
	var height = carouselSelectedItem.height();
	var coef = height / width;
	var scale = (newDeg === 90 || newDeg === 270) ? ' scale(' + coef.toFixed(2) + ') ' : ' scale(1) ';
	carouselSelectedItem.css({
		'-webkit-transform': rotate + scale,
		'-moz-transform': rotate + scale,
		'-o-transform': rotate + scale,
		'-ms-transform': rotate + scale,
		'transform': rotate + scale,
	});
	carouselSelectedItem.data('rotate', newDeg);
};

CarouselForm.getFileLink = function(fileName){
	var link = window.location.protocol+'//'+window.location.host+'/'+fileName;
	$('#getCurPostDocLinkDialog').remove();
	var divv = '<div id="getCurPostDocLinkDialog">' +
		'<textarea id="getCarouselFileLinkText" style="width:265px;margin: 1px;color: #005d98;height: 55px;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text">' + fileName + '</textarea></div>';
	$('body').append(divv);
	var dlg = $('#getCurPostDocLinkDialog');
	var buttons = [];
	buttons.push({
		text: gis_postsloader_4,
		click: function(){
			$('#getCurPostDocLinkDialog').remove();
		}
	});
	dlg.dialog({
		modal: true,
		title: gis_postsloader_1,
		dialogClass: 'gsi-zindex__dialog',
		closeOnEscape: true,
		width: 274,
		height: 140,
		resizable: false,
		//position: {my: "right bottom", at: "right bottom", of: '#postId_'+curPostId},
		buttons : buttons,
		create: function() {
			$(this).closest('div.ui-dialog')
				.find('.ui-dialog-titlebar-close')
				.click(function(e) {
					$('#getCurPostDocLinkDialog').remove();
					e.preventDefault();
				});
		}
	});
	$('#getCarouselFileLinkText').select();
}


var CHART_CONST = {
	COUNT: 'COUNT'
};
var CHART_GROUP_REQUEST = {
	SCALAR: 'ANALYTIC_SEM.xml#ANALYTIC_1', // запрос группировки скалярных типов
	DICT:'ANALYTIC_SEM.xml#ANALYTIC_2', //запрос группировки справочников
}
/**
 * Класс формы для отображения графиков библиотекой Charts.js
 * @see https://www.chartjs.org/
 */
function ChartForm(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	// объект с данными(строка грида) из которого забирать параметры для формирования запроса на получения списка картинок
	this.layerName = options.layerName;
	this.dashboard = options.dashboard;
	this.chartName = options.chartName || '';
	this.chartType = options.chartType;
	this.chartIndex = options.index || 0;
	this.id = App.generateUUID();

	//используется для случая, когда необходимо нарисовать чарт в виде стека
	this.sql =  options.sql || CHART_GROUP_REQUEST.SCALAR;
	//используется для настройки датасетов данных, полученных из this.sql
	this.dataset =  options.dataset;
	//параметры, получаемые из пресетов дашбордов, чтобы передать как есть в переменные запросов аналитики
	this.params = options.params;
	//Пока просто сформированная строка фильтра вида "RANK = 3232323 AND ROOF_IS IN ('1')",
	// соединяющая в себе и выпадающие справочные фильтры, и скалярные.
	//Используется для установки в переменную {FILTER} запроса аналитики
	this.filter = options.filter;
	//Используется для установки в переменную {COLUMN_GOAL} запроса аналитики
	this.goals = options.goals;
	this.hasGoalType2 = false;
	//массив выбранных условий для группировки данных.
	//Используется для установки в переменную {GROUP} запроса аналитики
	/** @type {Array.<Object>} */
	this.groupConditions = options.groupConditions
	//Скалярные условия, используются для доп. фильтрации  по интервалам
	this.scalarConditions = options.scalarConditions;
	//Название схемы, принадлежащей слою. Например, SUTSTPA, PODS,..
	//Используется для установки в переменную {SCHEMA} запроса аналитики
	this.schema = options.schema;
	//Название таблицы, принадлежащей слою. Например, VALVE, VENT_PIPE,..
	//Используется для установки в переменную {TABLE_NANE} запроса аналитики
	this.tableName = options.tableName;
	//TODO временное решение, т.к. нигде не хранятся реальные название таблиц в латинице, как в БД
	if(this.tableName === 'КРАНОВЫЙ_УЗЕЛ') this.tableName = 'structure';
	if(this.tableName === 'КРАН') this.tableName = 'valve';
	if(this.tableName === 'СВЕЧА') this.tableName = 'vent_pipe';
	//идентификатор грида, к котором будут принадлежать открываемые диаграммы.
	this.gridId = options.gridId || null;
	//Диаграмма
	this.myChart = undefined;
	this.position = options.position;

	//переменные, которые передаются для построения диаграммы на сервер
	this.currentSelectData = {};

}

ChartForm.prototype.build = function() {
	var that = this;
	var width = 531;//если pie и справа легенда
	//width = 350;//если bar и справа легенда
	var height = 350;
	//TODO реализовать размещение чартов блоками. На 07.12.21 хардкодим положение каждой диаграммы
	//___________________________________________________________
	//|                 |                   |                   |
	//|     chart5      |       chart6      |       chart1      |
	//|_________________|___________________|___________________|
	//|                 |                   |                   |
	//|     chart2      |       chart3      |       chart4      |
	//|_________________|___________________|___________________|
	//TODO вынести подобные общие проверки для дашбордов/гридов/чартов в отдельную функцию

	var config = {
		draggable: true,
		resizable: true,
		position:{
			width: width,
			height: height,
			left: '0%',
			top: '0%',
		}
	}
	if(WidgetMap && WidgetMap.config && WidgetMap.config.chart)
		config = $.extend(config, WidgetMap.config.chart);
	var position = getPositionFromConfig(config.position);
	var interactive = false;
	if(WidgetMap && WidgetMap.config && WidgetMap.config.interactive)
		interactive = WidgetMap.config.interactive;
	if(this.position) {
		config.position = $.extend(config.position, this.position);
		position = getPositionFromConfig(config.position, true);
		config.draggable = interactive;
		config.resizable = interactive;
	}
	var pos = undefined;
	switch (this.chartType){
		case CHART_TYPE.BAR:
			pos= { my: "bottom", at: "center", of: window};
			break;
		case CHART_TYPE.BAR_Y:
			pos= { my: "top", at: "left", of: window};
			break;
		case CHART_TYPE.PIE:
			pos= { my: "top", at: "center", of: window};
			break;
		case CHART_TYPE.DOUGHNUT:
			pos= { my: "center", at: "left", of: window};
			break;
		case CHART_TYPE.SCATTER:
			pos= { my: "center", at: "center", of: window};
			break;
	}
	var closeOnEscape = true, dialogClass = 'gsi-zindex__chart';
	if(this.position){
		pos = {my: "left+" + position.left + " top+" + position.top, at: "left top", of: 'body', collision: 'none'};
		if(!interactive){
			closeOnEscape = false;
			dialogClass += ' noCloseButton';
		}
	}

	var myChart = '<canvas id="myChart_' + that.id + '" style="display: inline-block" ></canvas>';
	var divv = '<div id="chartDialog_' + that.id + '" class="dashboard-dialog" style="background-color: white;" group="" filter="">' +
		'<div style=" display: inline-block; width: 100%; height:100%">' + myChart + '</div>' +
		'</div>';
	$('body').append(divv);
	var dlg = $('#chartDialog_' + that.id);
	//получаем название чарта из массива групп
	var chartName = (this.chartName)? this.chartName: that.formatChartName(this.groupConditions);
	this.chartName = chartName;
	dlg.dialog({ title: chartName, modal: false,
		dialogClass: dialogClass, closeOnEscape: closeOnEscape,
		width: position.width, height: position.height,
		position: pos,
		draggable: config.draggable,
		resizable: config.resizable,
		buttons : [],
		appendTo: "body",
		close: function(){
			if(that.dashboard)
				that.dashboard.removeChart(that.id);
		}
	});
	that.loadData_();
};

/**
 * Загружаем данные для заполнения
 * @private
 */
ChartForm.prototype.loadData_ = function () {
	var that = this;
	that.currentSelectData = {};
	var dUniqueId = that.id,
		chartType = that.chartType,
		filter = '', goals = '', goalsType2 = '';

	if(this.dashboard.getGoals())
		this.goals = this.dashboard.getGoals().getSelectedItems();
	if(this.goals){
		goals = that.formatAndSaveGoals();
		//если необходима выборка целевой характеристики через 3 переменные, то используем их
		if((that.params && that.params.COLUMN_GOAL_1) || this.hasGoalType2){
			goalsType2 = that.formatAndSaveGoals2();
			this.hasGoalType2 = true;
			delete that.params.COLUMN_GOAL_1;
			delete that.params.COLUMN_GOAL_2;
			delete that.params.COLUMN_GOAL_ORDER;
		}
	}

	//если пришел из дашборда фильтр, то удаляем предустановленный
	if(that.filter && that.params)
		delete that.params.FILTER;
	var groupConditions = that.formatAndSaveGroupConditions(that.groupConditions, that.params);
	//если в параметрах нет фильтра, то получаем его из пришедшего из дашборда
	if(!that.params || !that.params.FILTER) {
		filter = ' FILTER="' + GridWidget.prototype.getBottomFilterString(that.filter) + '"';
		that.currentSelectData = $.extend(that.currentSelectData, {FILTER: GridWidget.prototype.getBottomFilterString(that.filter)});
	}
	//TODO хардкод. добавлено обходное условие невыполнимое если не выбраны целевые характеристики
	if(this.hasGoalType2 && goalsType2 === null){
		goalsType2 = '';
		filter = ' FILTER="1=2" ';
		that.currentSelectData = $.extend(that.currentSelectData, {FILTER: '"1=2"'});
	}
	that.addOverlay_();
	that.currentSelectData = $.extend(that.currentSelectData, {SCHEMA: that.schema, TABLE_NAME: that.tableName});
	BlockingUtil.wait();
	App.serverQueryNodeWithTries(Services.processQueryNode,{
		descrId: that.sql,
		descrType: 'select',
		data: '<root>' +
			'<data SCHEMA="' + that.schema + '" TABLE_NAME="' + that.tableName + '" ' +
			goals +
			goalsType2 +
			filter +
			groupConditions +
			' />' +
			'</root>'
	},function result(resultXml){
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if(er !== ''){
			App.errorReport(gis_core_error_1, er, undefined, {filename: gis_filename_628, functionname: 'gis_filename_628_1'});
			return;
		}
		var params = (that.sql) ? that.parseStubResult(resultXml, chartType) : that.parseResult(resultXml, chartType);
		if(that.sql && that.dataset)
			that.prepareChart(params.labels, undefined, dUniqueId, chartType, params.dataset);
		else
			that.prepareChart(params.labels, params.data, dUniqueId, chartType);
	},function fault(resultXml){
		BlockingUtil.ready();
		App.errorReport(gis_core_error_1, resultXml, undefined, {filename: gis_filename_628, functionname: 'gis_filename_628_2'});
	});
};

/**
 * Форматирование данных для группировки
 * @param groupConditions
 * @param params параметры из пресетов
 */
ChartForm.prototype.formatAndSaveGroupConditions = function(groupConditions, params){
	var that = this;
	var spravSemQuery = [], spravList = [], spravPredicateList = [], group1 = [], group2 = [], order = [];
	var groupStr = '';
	try{
		groupConditions.forEach(function(gCond){
			if(gCond.group_1 === 'TYPE'){
				gCond.group_1 = 'TYPE_RANGE';
				gCond.group_2 = 'TYPE_RANGE';
				gCond.order = 'TYPE_RANGE';
			}
			if(gCond.sprav_sem_query){// Значит справочник
				spravSemQuery.push(gCond.sprav_sem_query);
				spravList.push(gCond.sprav_list);
				spravPredicateList.push(gCond.sprav_predicate_list);
			}
			//TODO если скалярный тип, то формируем строку case when
			group1.push(gCond.group_1);
			group2.push(gCond.group_2);
			order.push(gCond.order);
		});
		var sprav_sem_query = (spravSemQuery.length)? 'with ' + spravSemQuery.join(): '';
		var groupObj = {
			SPRAV_SEM_QUERY: sprav_sem_query,
			SPRAV_LIST: spravList.join(),
			SPRAV_PREDICATE_LIST: spravPredicateList.join(' and '),
			GROUP_1: group1.join(),
			GROUP_2: group2.join(),
			ORDER: order.join()
		}
		that.currentSelectData = $.extend(that.currentSelectData, groupObj);
		groupStr = FilterUtil.getFilterStringFromObject(groupObj);
		return groupStr;
	}
	catch(ex){
		if(params) {// если группы пришли в строковом формате. Временно для презентации и пресетов
			groupStr = FilterUtil.getFilterStringFromObject(params);
			that.currentSelectData = $.extend(that.currentSelectData, params);
			return groupStr;
		}
	}
	return groupStr;
};

ChartForm.prototype.formatAndSaveGoals = function(){
	var goalsFilter = '';
	if(this.goals){
		var goals = [];
		this.goals.forEach(function(item){
			if(item) {
				var goal = item.code + '=1';
				if(item.inverted)
					goal = '1-' + goal;
				goals.push(goal);
			}
		});
		if(goals.length) {
			goalsFilter = ' COLUMN_GOAL="' + goals.join(' and ') + '" ';
			this.currentSelectData = $.extend(this.currentSelectData, {COLUMN_GOAL: '"' + goals.join(' and ') + '"'});
		}
	}
	return goalsFilter;
}

ChartForm.prototype.formatAndSaveGoals2 = function(){
	var goalsFilter = '';
	if(this.goals){
		var goals1 = [], goals2 = [], goalsOrder = [];
		if(this.goals.length === 1 && this.goals[0].descr === 'not_selected')
			return null;
		this.goals.forEach(function(item){
			if(item)  {
				var goal = item.code;
				var unknowmMessage = 'Неизвестно';
				if(item.inverted) goal = '1-' + goal;
				if(item.unknownmessage) unknowmMessage = item.unknownmessage;

				goals1.push("case " + goal + " when 1 then 'Да' when 0 then 'Нет' else '" + unknowmMessage + "' end " + item.code);
				goals2.push(goal);
				goalsOrder.push(item.code);
			}
		});
		if(goalsOrder.length){
			goalsFilter = ' COLUMN_GOAL_1="' + goals1.join(',') + '" ' +
				' COLUMN_GOAL_2="' + goals2.join(',') + '" ' +
				' COLUMN_GOAL_ORDER="' + goalsOrder.join(',') + '" ';
			this.currentSelectData = $.extend(this.currentSelectData, {
				COLUMN_GOAL_1: '"' + goals1.join(',') + '"',
				COLUMN_GOAL_2: '"' + goals2.join(',') + '"',
				COLUMN_GOAL_ORDER: '"' + goalsOrder.join(',') + '"',
			});
		}

	}
	return goalsFilter;
}



/**
 * Форматирование название формы чартов
 * @param groupConditions
 */
ChartForm.prototype.formatChartName = function(groupConditions){
	var groups = [];
	groupConditions.forEach(function(gCond){
		groups.push(gCond.label);
	});
	var chartName = groups.join();
	//TODO 4. Заголовок окна диаграммы ограничить 50 символами, если текст не влез, то добавлять многоточие в конец.
	if(chartName && chartName.length > 50)
		chartName = chartName.substr(0, 50) + '...';
	return chartName;
};


/**
 * Обновление данных
 * @param filter
 */
ChartForm.prototype.updateData = function(filter){
	if(filter) this.filter = filter;
	this.loadData_();
};
/**
* Обработка результата запроса
*/
ChartForm.prototype.parseResult = function (resultXml, chartType){
	var labels = [], data = [];
	var datas = resultXml.find("data");
	if (datas && datas.length > 0){
		this.removeOverlay_();
		for(var j = 0; j < datas.length; j++){
			var attributes = datas[j].attributes;
			var label = [];
			for(var i = 0; i < attributes.length; i++){
				var attr = attributes[i];
				if (attr.name !== CHART_CONST.COUNT) {
					//TODO хардкод для презентации. Если приходит 0 или 1 - меняем на ДА/НЕТ
					var val = attr.value
					if(val === '0') val = 'НЕТ';
					if(val === '1') val = 'ДА';
					if(val === 'RED') val = 'Неисправно';
					if(val === 'YELLOW') val = 'Имеются неисправности';
					if(val === 'GREEN') val = 'Исправно';
					label.push(val);
				}
				else if(chartType === CHART_TYPE.SCATTER) {
					var nVal = Math.round(Number(attr.value) * 100)/100;
					data.push({x: j, y: nVal});
				}else {
					var nVal = Math.round(Number(attr.value) * 100)/100;
					data.push(nVal);
				}
			}
			//TODO 6. Подписи категорий сократить до 30 символов, если текст не влез, то добавлять многоточие в конец.
			var labelStr = label.join();
			if(labelStr.length > 30)
				labels.push(labelStr.substr(0, 30) + '...');
			else
				labels.push(labelStr);
		}
	}
	return {labels: labels, data: data};
};

ChartForm.prototype.parseStubResult = function (resultXml, chartType){
	var labels = [];
	var dataset = {};
	if(this.sql){
		if(this.dataset){
			this.dataset.forEach(function(data){
				var ds = {
					color: data.color,
					title: data.title,
					column: data.column,
					data: [],
				}
				dataset[data.column] = ds;
			});
			var datas = resultXml.find("data");
			if (datas && datas.length > 0){
				this.removeOverlay_();
				for(var j = 0; j < datas.length; j++){
					var attributes = datas[j].attributes;
					var label = [];
					for(var i = 0; i < attributes.length; i++){
						var attr = attributes[i];
						if(dataset[attr.name])
							dataset[attr.name].data.push(Number(attr.value));
						else
							label.push(attr.value);
					}
					//TODO 6. Подписи категрий сократить до 30 символов, если текст не влез, то добавлять многоточие в конец.
					var labelStr = label.join();
					if(labelStr.length > 30)
						labels.push(labelStr.substr(0, 30) + '...');
					else
						labels.push(labelStr);
				}
			}
		}
		else{
			return this.parseResult(resultXml, chartType);
		}

		return {labels: labels, dataset: dataset};
	}
};
/**
 * Генерация массива данных
 */
ChartForm.prototype.prepareChart = function(labels, data, uniqueId, chartType, dataset){
	var chartData, defaultColors = [];
	var options = {
		scales: {
			yAxes: [{
				display: true,
				ticks: {
					beginAtZero: true,
				}
			}]
		},
		maintainAspectRatio: false,
		legend: {
			position: 'top',
			//TODO 5. Убрать заголовок из тела диаграммы.
			display: false
		},
		plugins: {
			labels: {
				render: 'value',
				fontStyle: 'bold',
				fontColor: '#000',
			}
		}
	};
	if(dataset){
		chartData = {
			labels: [],
			datasets: []
		}
		options.legend.display = true;
		for(var key in dataset){
			var dt = dataset[key];
			var ds = {
				backgroundColor: dt.color,
				label: dt.title,
				data: dt.data,
				column: dt.column,
			}
			chartData.datasets.push(ds);
		}
		chartData.labels = labels;
	}
	else{
		defaultColors = this.fillColors_(data.length);
		chartData = {
			labels: labels,
			datasets: [{
				label: this.chartName.substr(0, 50) + '...',
				data: data
			}]
		};
	}


	switch (chartType){
		case CHART_TYPE.BAR:
			//чтобы подписи не были под углом, а вертикально
			/*options.scales.xAxes = [{
				ticks: {
					autoSkip: false,
					maxRotation: 90,
					minRotation: 90
				}
			}]*/
			defaultColors = this.fillColors_(100);
			//chartData.datasets[0].label = dt.title,
			options.layout = {
				padding:{
					top: 20
				}
			}
			chartData.datasets[0].backgroundColor = defaultColors[this.chartIndex];
			if(chartData.datasets.length > 1)
				chartData.datasets[1].backgroundColor = defaultColors[1];
			break;
		case CHART_TYPE.BAR_STACK:
			chartType = 'bar';
			options.scales = {
				xAxes: [{
					stacked: true,
				}],
				yAxes: [{
					stacked: true,
					display: true,
					ticks: {
						beginAtZero: true,
					}
				}]
			}
			break;
		case CHART_TYPE.BAR_STACK_WO_X:
			chartType = 'horizontalBar';
			options.scales = {
				yAxes: [{
					stacked: false,
				}],
				xAxes: [{
					stacked: false,
					display: true,
					ticks: {
						beginAtZero: true,
					}
				}]
			}
			break;
		case CHART_TYPE.BAR_STACK_WO_Y:
			chartType = 'bar';
			options.scales = {
				xAxes: [{
					stacked: false,
				}],
				yAxes: [{
					stacked: false,
					display: true,
					ticks: {
						beginAtZero: true,
					}
				}]
			}
			break;
		case CHART_TYPE.BAR_STACK_Y:
			chartType = 'horizontalBar';
			defaultColors = this.fillColors_(100);
			chartData.datasets[0].backgroundColor = defaultColors[this.chartIndex];
			chartData.datasets[1].backgroundColor = defaultColors[1];
			options.scales = {
				xAxes: [{
					stacked: true,
				}],
				yAxes: [{
					stacked: true,
					display: true,
					ticks: {
						beginAtZero: true,
					}
				}]
			}
			break;
		case CHART_TYPE.BAR_Y:
			chartType = 'horizontalBar';
			defaultColors = this.fillColors_(100);
			chartData.datasets[0].backgroundColor =  defaultColors[this.chartIndex];
			if(chartData.datasets.length > 1)
				chartData.datasets[1].backgroundColor = defaultColors[1];
			break;
		case CHART_TYPE.PIE:
		case CHART_TYPE.DOUGHNUT:
			chartData.datasets[0].backgroundColor = defaultColors;
			options = {
				scales: {
					y: {
						beginAtZero: true
					}
				},
				maintainAspectRatio: false,
				legend: {
					position: 'top'
				},
				plugins: {
					labels: {
						render: 'value',
						fontStyle: 'bold',
						fontColor: '#000'
					}
				}
			};
			break;
		case CHART_TYPE.SCATTER:
			chartData.datasets[0].backgroundColor = defaultColors;
			options =  {
				scales: {
				  x: {
					type: 'linear',
					position: 'bottom'
				  }
				}
			  };
			break;
	}
	if (chartType === 'bar-y') chartType = 'bar';
	var ctx = $('#myChart_' + uniqueId);
	if(!this.myChart){
		this.myChart = new Chart(ctx, {
			type: chartType,
			data: chartData,
			options: options
		});
	}
	else{
		this.updateData_(this.myChart, labels, data, dataset, chartData.datasets[0].backgroundColor);
	}
};

ChartForm.prototype.updateData_ = function (chart, labels, data, dataset, colors) {
	chart.data.labels = labels;
	if(data){
		chart.data.datasets.forEach(function(dataset) {
			dataset.data = data
			if(colors)
				dataset.backgroundColor = colors;
		});
	}
	else{
		chart.data.datasets = [];
		for(var key in dataset){
			var data = dataset[key];
			var ds = {
				backgroundColor: data.color,
				label: data.title,
				data: data.data,
				column: data.column,
			}
			chart.data.datasets.push(ds);
		}
		/*chart.data.datasets.forEach(function(ds) {
			if(dataset[ds.column]) ds.data = data;
		});*/
	}
	chart.update();
}


ChartForm.prototype.addOverlay_ = function(){
	var dlg = $('#chartDialog_' + this.id);
	$('.chart-overlay', dlg).remove();
	var overlay = $('<div class="chart-overlay "></div>');
	dlg.prepend(overlay);
}

ChartForm.prototype.removeOverlay_ = function(){
	var dlg = $('#chartDialog_' + this.id);
	$('.chart-overlay', dlg).remove();
}
ChartForm.prototype.toJson = function(){
	var chart = $('#chartDialog_'+this.id);
	var parent = $('#chartDialog_'+this.id).parent();
	return {
		"title": this.chartName,
		"type": this.chartType,
		"sql": this.sql,
		"params": this.currentSelectData,
		"layerName": this.layerName,
		"position": {
			"left": parent.position().left,
			"top": parent.position().top,
			"width": chart.width(),
			"height": chart.height()
		}
	}
}

/**
 * Формирование массива цветов для использования в отрисовке данных в чарте
 * @param size длина выходящего массива цветов
 */
ChartForm.prototype.fillColors_ = function(size){
	var colorsLength = 25;
	//формируем формируем заведомо большой массив цветов с повторениями от длины colorsLength у базового массива
	var defaultColors = [].concat(CHART_COLORS.slice(0, colorsLength))
		.concat(CHART_COLORS.slice(0, colorsLength))
		.concat(CHART_COLORS.slice(0, colorsLength))
		.concat(CHART_COLORS.slice(0, colorsLength))
		.concat(CHART_COLORS.slice(0, colorsLength))
		.concat(CHART_COLORS.slice(0, colorsLength))
		.concat(CHART_COLORS.slice(0, colorsLength))
		.concat(CHART_COLORS.slice(0, colorsLength))
	defaultColors.length = size;
	return defaultColors;
}


// @see https://www.chartjs.org/docs/
//Все разновидности построений чартов
var CHART_TYPE = {
	BAR: 'bar',                         // вертикальная столбчатая диаграмма
	BAR_STACK: 'bar_stack',             // вертикальная столбчатая диаграмма(стек)
	BAR_STACK_WO_Y: 'bar_stack_wo_y',   // вертикальная столбчатая диаграмма(стек)
	BAR_STACK_WO_X: 'bar_stack_wo_x',   // горизонтальная столбчатая диаграмма(стек)
	PIE: 'pie',                         // круговая диаграмма
	BAR_Y: 'bar_y',                     // горизонтальная столбчатая диаграмма
	BAR_STACK_Y: 'bar_stack_y',         // горизонтальная столбчатая диаграмма(стек)
	LINE: 'line',                       // линейная диаграмма
	RADAR: 'radar',                     //Радарная (способ показать несколько точек данных и различия между ними)
	DOUGHNUT: 'doughnut',               //Кольцевая
	POLARAREA: 'polarArea',             //Полярная (одинаковый угол, радиус, различие в значение)
	BUBBLE: 'bubble',                   //Пузырьковая(используется для одновременного отображения трех измерений данных)
	SCATTER: 'scatter',                 //Точечная
	COMBO: 'combo',                     // смешанная диаграмма(комбинация двух или более разных типов диаграмм)
};
/**
 * Массив типов чартов для выбора дашборда
 *@type - тип построения чарта (обязательный)
 *@icon - путь к файлу с иконкой (обязательный)
 *@title - текст всплывающий при наведение на иконку (обязательный)
 *@className - название класса со стилями (необязательный)
 */
var CHART_TYPES = [
	new ChartType({type: CHART_TYPE.BAR, icon: './Public/assets/bar-chart.png', title: 'Столбчатая'}),
	new ChartType({type: CHART_TYPE.BAR_Y, icon: './Public/assets/bar-chart.png', title: 'Столбчатая', className:'chartstypes-icon__rotate90'}),
	new ChartType({type: CHART_TYPE.PIE, icon: './Public/assets/pie-chart.png', title: 'Круговая'}),
	new ChartType({type: CHART_TYPE.SCATTER, icon: './Public/assets/scatter-chart.png', title: 'Точечная'}),
	new ChartType({type: CHART_TYPE.DOUGHNUT, icon: './Public/assets/doughnut-chart.png', title: 'Кольцевая'})
];

//класс для точечных настроек отдельного вида чартов
function ChartSettings(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.color; //
	this.legendPosition;
	this.type;
	this.labelsRender = 'value';

}

//класс, отвечающий за тип чарта
function ChartType(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.type = /** @type {CHART_TYPE} */ options.type || CHART_TYPE.BAR;
	this.icon = options.icon || '';
	this.id = options.id;
	//название чарта
	this.title =  options.title || 'Без названия';
	//перечень условий, которые используются для отображения диаграммы
	this.groupConditions = options.groupConditions || [];
	//класс для иконки
	this.className = options.className || '';
	this.settings = /** @type {ChartSettings} */ {};
}

/**
 * Класс формы выбора дашбордов
 * @see https://www.chartjs.org/docs/
 */
function ChartChooserForm(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	//Имя слоя
	this.layerName = options.layerName;
	//текущий дашборд, в котором происходит открытие диаграмм
	this.dashboard = options.dashboard
	this.curDataAdapter = options.curDataAdapter;
	this.currentGrid = options.currentGrid;
	//Колонки грида
	this.columns = options.columns;
	this.uniqueId = App.generateUUID();
	this.callback = options.callback;
}

ChartChooserForm.prototype.build = function() {
	var that = this;
	var allColumns = that.columns || [];
	var data = [];
	allColumns.forEach(function (row) {
		if (row.text && row.datafield !== 'RWN') {
			row.text = row.text.replace(/\\n|\n/g, " ");
			if (row.filterrequestid || row.columntype === 'date' || row.columntype === 'string'){//Если справочник, дата либо строковый тип
				data.push({dataField: row.datafield, columnName: row.text, visible: false, type:  row.columntype, filterRequestId: row.filterrequestid});
			}
			/*else {
				data.push({dataField: row.datafield, columnName: row.text+'  (скалярное поле - ' + row.filtercomparisiontype + ')' , visible: false, type: row.filtercomparisiontype});
			}*/
		}
	});
	$('#chartsDialog').remove();
	var divv = '<div id="chartsDialog">' +
		'<div style="margin-top: 5px; margin-left: 10px">' +
		'<span style="color: #ffffff">' + gis_chartchooserform_3 + '</span>' +
		'</div>' +
		'<div id="chartsDiv" class="chartstypes-main__div">'+
		'<span style="color: #ffffff">' + gis_chartchooserform_4 + '</span>'+
		'<div class="chartstypes-chart__img">';

	CHART_TYPES.forEach(function(chartType){
		divv += '<div class="chartstypes-row" >' +
			'<img src="' + chartType.icon + '" width="48" height="48" class="' + chartType.className+ '" title="' + chartType.title + '"/>' +
			'<input type="radio" id="radio_' + chartType.type + '" data-type="' + chartType.type + '" name="chooser_input" />' +
			'</div>'
	});
	divv += '</div>' +
		'<span style="color: #ffffff">' + gis_chartchooserform_5 + '</span>'+
		'<div id="chartColumns" style="width: 100%; height: 120px;"></div>'+
		'</div>' +
		'<div style="display: flex;margin-top: 5px;justify-content: space-around;">' +
		'<input type="button" class="map-dialog-button" name="open" id="dialogButton" value="'+ gis_chartchooserform_2 + '" >' +
		'<input type="button" class="map-dialog-button" name="cancel" value="Отмена">' +
		'</div>';
	$('body').append(divv);
	var dlg = $('#chartsDialog');
	dlg.dialog({
		modal: false,
		title: gis_chartchooserform_1,
		dialogClass: 'gsi-zindex__chart-chooser',
		closeOnEscape: true,
		width: 400,
		height: 388,
		resizable: false,
		close: function () {
			try {
				$(this).dialog('destroy').remove();
			} catch (e) { }
		}
	});

	$('#chartColumns').css('margin-top', 5);
	$('#radio_bar', dlg).prop("checked", true);
	var source = {
		localdata: data,
		datatype: 'array',
		datafields: [
			{name: 'dataField', type: 'string'},
			{name: 'columnName', type: "string"},//название локализованное
			{name: 'visible', type: 'string'},//вкл/выкл чекбокс
			{name: 'type', type: 'string'},//тип данных
			{name: 'filterRequestId', type: 'string'}//Идентификатор запроса на справочные колонки
		]
	}
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#chartColumns").jqxGrid({
		width: 375,
		height: 170,
		source: dataAdapter,
		pageable: false,
		altRows: false,
		selectionmode: 'singlerow',
		columnsResize: true,
		editable: true,
		theme: 'gis-blue-grid',
		localization: getLocalization('ru'),
		columns: [
			{
				text: '',
				sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				datafield: 'visible', columntype: 'string', width: 25,
				cellsrenderer: function (row, column, value) {
					if(value === 'true'){
						return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='ChartChooserForm.prototype.setVisible_(this,"+row+")' checked></div>";
					}
					else{
						return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='ChartChooserForm.prototype.setVisible_(this,"+row+")'></div>";
					}
				},
				renderer: function () {
					return '<div><input type="checkbox" style="margin-left: 5px;margin-top: 5px;" id="manage_columns_all_checkbox" title="Выбрать все"></div>'
				},
				rendered: function (element) {
					var checkbox = $(element).last();
					$(checkbox).on('click', function (event) {
						event.stopPropagation()
					}).on('change', function (event) {
						var checked =  $('#manage_columns_all_checkbox').is(':checked');
						ChartChooserForm.prototype.setAllVisible(checked)
					});
					return true;
				},
			},
			{
				text: '', sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				datafield: 'up', columntype: 'number', width: 25,
				cellsrenderer: function (row, column, value) {
					return "<div type='submit' class='map-img map-up-img' onclick='ChartChooserForm.prototype.upColumn_(this,"+value+")' title='"+gis_cassettingsform_9+"'></div>";
				}
			},
			{
				text: '', sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				datafield: 'down', columntype: 'number', width: 25,
				cellsrenderer: function (row, column, value) {
					return "<div type='submit' class='map-img map-down-img' onclick='ChartChooserForm.prototype.downColumn_(this,"+value+")' title='"+gis_cassettingsform_10+"'></div>";
				}
			},
			{   text: gis_managegridcolumnsform_2, datafield: 'columnName',
				sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				columntype: 'string', width: 277
			}
		]
	});
	$('input[name=open]', dlg).click(function (){
		if(that.callback) {
			var selectedColumns = that.getSelectedColumns();
			if (!selectedColumns || !selectedColumns.length) {
				App.confirmDialog(gis_chartchooserform_6, null, {title:gis_core_1, dialogClass: 'ui-dialog-confirm-300'});
				return;
			}
			var layerObj = (that.curDataAdapter) ? that.curDataAdapter.currentGridDescr.layerManager.getLayerByName(that.curDataAdapter.currentGridDescr.layerId) : undefined;
			var params = {
				chartType: $('input[name=chooser_input]:checked', dlg).data('type'),
				columns: selectedColumns || [],
				tableName: (layerObj && layerObj.layer) ? layerObj.layer.layerTable : '',
				schema: (layerObj && layerObj.layer) ? layerObj.layer.layerSchema : '',
				filter: that.dashboard.filter
			};
			that.callback(params);
		}
		that.hide(dlg);
	});
	$('input[name=cancel]', dlg).click(function (){
		that.hide(dlg);
	});
};

ChartChooserForm.prototype.hide = function (dlg) {
	try {
		dlg.dialog('destroy').remove();
	} catch (e) { }
};


ChartChooserForm.prototype.upColumn_ = function (elem, index) {
	//получаем весь список, там переносим в нужные позиции и заполняем грид
	var rows = $("#chartColumns").jqxGrid('getrows');
	if (index != 0) {
		var temp = rows[index];
		rows[index] = rows[index - 1];
		rows[index - 1] = temp;
		var source = {
			localdata: rows,
			datatype: "array",
			datafields:
				[
					{name: 'dataField', type: 'string'},
					{name: 'columnName', type: 'string'}, //название кириллицей
					{name: 'visible', type: 'string'}, // !hidden
				]
		};
		var dataAdapter = new $.jqx.dataAdapter(source);
		$("#chartColumns").jqxGrid({source: dataAdapter});
		$("#chartColumns").jqxGrid('selectrow', index - 1);
	}
};
ChartChooserForm.prototype.downColumn_ = function (elem, index) {
	var rows = $("#chartColumns").jqxGrid('getrows');
	if (index != rows.length - 1) {
		var temp = rows[index];
		rows[index] = rows[index + 1];
		rows[index + 1] = temp;
		var source = {
			localdata: rows,
			datatype: "array",
			datafields:
				[
					{name: 'dataField', type: 'string'},
					{name: 'columnName', type: 'string'}, //название кирилицей
					{name: 'visible', type: 'string'}, // !hidden
				]
		};
		var dataAdapter = new $.jqx.dataAdapter(source);
		$("#chartColumns").jqxGrid({source: dataAdapter});
		$("#chartColumns").jqxGrid('selectrow', index + 1);
	}
};
/**
 * Функция управления видимостью слоя
 * @param elem
 * @param rowKey
 * @private
 */
ChartChooserForm.prototype.setVisible_ = function(elem, rowKey){
	var isChecked = '' + $(elem).prop('checked');
	$("#chartColumns").jqxGrid('setcellvalue',rowKey,'visible', ''+ isChecked);
	var keys = $("#chartColumns").jqxGrid('getrows');
	var selectAll = true;
	keys.forEach(function(item, i){
		selectAll = selectAll && (item.visible === 'true');
	})
	$('#manage_columns_all_checkbox').prop('checked', selectAll);
};

/**
 * Снимает/добавляет видимость у всех колонок
 * @param checked
 * @private
 */
ChartChooserForm.prototype.setAllVisible = function(checked){
	var keys = $("#chartColumns").jqxGrid('getrows');
	keys.forEach(function(item, i){
		$("#chartColumns").jqxGrid('setcellvalue', i, 'visible', ''+ checked);
	})
};
/**
 * Получение списка колонок, по которым выполнять группировку
 */
ChartChooserForm.prototype.getSelectedColumns = function() {
	var rows = $("#chartColumns").jqxGrid('getrows');
	//формируем обновленный список колонок
	var columns = [];
	rows && rows.forEach(function(row){
		if(row.visible === 'true') {
			columns.push(row);
		}
	});
	return columns;
};
/**
 * Класс формы выбора дашбордов
 * @see https://www.chartjs.org/docs/
 */
function DashboardChooserForm(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.dashboard = options.dashboard;
	this.callback = options.callback;
}

DashboardChooserForm.prototype.build = function() {
	var that = this;
	$('#dashboardDialog').remove();
	var divv = '<div id="dashboardDialog">' +
			'<div id="dashboardColumnsGrid" style="width: 100%; height: 120px; margin: 5px;"></div>'+
		'<div style="display: flex;margin-top: 9px;justify-content: space-around;">' +
		'<input type="button" class="map-dialog-button" name="open" value="'+ gis_chartchooserform_2 + '" >' +
		'<input type="button" class="map-dialog-button" name="save" style="width: 179px;" value="'+ gis_taskofficedialog_2 + '" >' +
		'<input type="button" class="map-dialog-button" name="cancel" value="Отмена">' +
		'</div>'
		'</div>'		;
	$('body').append(divv);
	var dlg = $('#dashboardDialog');
	dlg.dialog({
		modal: false,
		title: gis_dashboardchooserform_1,
		dialogClass: 'gsi-zindex__dashboard-chooser',
		closeOnEscape: true,
		width: 600,
		height: 388,
		resizable: false,
		close: function () {
			try {
				$(this).dialog('destroy').remove();
			} catch (e) { }
		}
	});

	var source = {
		localdata: [],
		datatype: 'array',
		dataFields: [
			{name: 'ID', type: 'number'},
			{name: 'TASK_NAME', type: 'string'},
			{name: 'TASK_DESCRIPTION', type: 'string'},
			{name: 'FILE_NAME', type: 'string'},
			{name: 'CTIME', type: 'date'},
		],
		sortcolumn: 'CTIME',
		sortdirection: 'asc'
	}
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#dashboardColumnsGrid").jqxGrid({
		width: '100%',
		height: 305,
		source: dataAdapter,
		pageable: false,
		altRows: false,
		selectionmode: 'singlerow',
		columnsResize: true,
		editable: true,
		sortable: true,
		theme: 'gis-blue-grid',
		localization: getLocalization('ru'),
		columns: [
			{
				text: gis_drawgeometrycontrol_16, sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				datafield: '', columntype: 'number', width: 25,
				cellsrenderer: function (row, column, value) {
					return "<div style='margin-top: 4px; margin-left:2px;'>" + (value + 1) + "</div>";
				}
			},
			{   text: gis_dashboardchooserform_2, datafield: 'TASK_NAME',
				sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: true,
				columntype: 'string', width: 170
			},
			{   text: gis_dashboardchooserform_4, datafield: 'TASK_DESCRIPTION',
				sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: true,
				columntype: 'string', width: 224
			},
			{   text: gis_dashboardchooserform_5, datafield: 'CTIME',
				sortable: true, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: true,
				columntype: 'string', width: 120
			},
			{
				text: '', sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				datafield: 'delete', columntype: 'number', width: 25,
				cellsrenderer: function (row, column, value) {
					return "<div type='submit' class='map-img map-delete-img' onclick='DashboardChooserForm.prototype.removeTask_("+row+")' title='"+gis_dashboardchooserform_11+"'></div>";
				}
			}
		]
	});
	$('input[name=open]', dlg).click(function (){
		//открываем дашборд в отдельной вкладке
		var selectedIndex = $('#dashboardColumnsGrid').jqxGrid('getselectedrowindex');
		if(selectedIndex !== -1){
			var row = $("#dashboardColumnsGrid").jqxGrid('getrowdata', selectedIndex);
			if(row && row.FILE_NAME){
				that.openTask(row.FILE_NAME);
			}
			else
				App.confirmDialog(gis_dashboardchooserform_7, null, {title:gis_core_1});
		}
		else
			App.confirmDialog(gis_dashboardchooserform_6, null, {title:gis_core_1, width: 125});
	});
	$('input[name=save]', dlg).click(function (){
		var dashboard = App.dashboardManager.getDashboard(null);
		if(dashboard)
			App.dashboardManager.showSaveDashboardForm(dashboard.id);
		App.destroyDialog(null, dlg);
	});
	$('input[name=cancel]', dlg).click(function (){
		App.destroyDialog(null, dlg);
	});

	this.loadGridData();
};

DashboardChooserForm.prototype.removeTask_ = function(rowIndex) {
	var that = this;
	var row = $("#dashboardColumnsGrid").jqxGrid('getrowdata', rowIndex);
	var rowId= $('#dashboardColumnsGrid').jqxGrid('getrowid', rowIndex);
	var alertForm = new AlertForm();
	alertForm.build("deleteDashboardAlertForm", gis_dashboardchooserform_8, gis_dashboardchooserform_9);
	//Добавляем слушатель закрытия формы
	$("body").on(CloseEvent.CLOSE, function (evt/*CloseEvent*/) {
		$("body").off(CloseEvent.CLOSE);
		if (evt && evt.detail == 1) {
			BlockingUtil.wait();
			App.serverQueryNodeWithTries(Services.processQueryNode,{
				descrId: 'SYS_SEM.xml#WEB50_B_USER_PUBLIC_SAVED_TASKS',
				descrType: 'delete',
				data: '<root><data ID="' + row.ID + '" /></root>'
			},function result(resultXml){
				BlockingUtil.ready();
				var er = HTTPServiceUtil.getError(resultXml);
				if(er !== ''){
					App.errorReport(gis_core_error_1, er, undefined, {filename: gis_filename_633, functionname: 'gis_filename_633_3'});
					return;
				}
				$("#dashboardColumnsGrid").jqxGrid('deleterow', rowId);
			},function fault(resultXml){
				BlockingUtil.ready();
				App.errorReport(gis_core_error_1, resultXml, undefined, {filename: gis_filename_633, functionname: 'gis_filename_633_4'});
			});
		}
	});
}

DashboardChooserForm.prototype.openTask = function(taskName, options) {
	var authStr= Auth.getAuthStr()
	var url =
		"main_js.html"+
		"?task="+escape(taskName)+
		"&mdl="+escape(getParameterByName('mdl')) +
		"&rand="+Math.random()*1000000;
	url += '#'+authStr;
	window.open(url, '_blank');
}

DashboardChooserForm.prototype.loadGridData = function() {
	var parentTask = getParameterByName('task');
	var userId = Auth.getUserId();
	App.serverQueryNodeWithTries(Services.processQueryNode,{
		descrId: 'SYS_SEM.xml#WEB50_B_USER_PUBLIC_SAVED_TASKS',
		descrType: 'select',
		data: '<root>' +
			'<data FILTER="user_id=' + userId + ' and parent_task_file_name=\''+parentTask+'\'"  />'+
			'</root>'
	},function result(resultXml){
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if(er !== ''){
			App.errorReport(gis_core_error_1, er, undefined, {filename: gis_filename_633, functionname: 'gis_filename_633_1'});
			return;
		}
		var data = App.convertDataXmlToArray(resultXml);
		var source = {
			dataType: "array",
			localData: data
		};
		var dataAdapter = new $.jqx.dataAdapter(source);
		$("#dashboardColumnsGrid").jqxGrid({source: dataAdapter});

	},function fault(resultXml){
		BlockingUtil.ready();
		App.errorReport(gis_core_error_1, resultXml, undefined, {filename: gis_filename_633, functionname: 'gis_filename_633_2'});
	});
}

/**
 * Получение списка колонок, по которым выполнять группировку
 */
DashboardChooserForm.prototype.getSelectedColumns = function() {
	var rows = $("#dashboardColumnsGrid").jqxGrid('getrows');
	//формируем обновленный список колонок
	var columns = [];
	rows && rows.forEach(function(row){
		if(row.visible === 'true') {
			columns.push(row);
		}
	});
	return columns;
};

/**
 * Класс всплывающей формы с экспортом в Excel
 */
function ProcessExportExcelForm() {
    this.closable = true;
    this.link='';
	this.elementId = undefined;
	this.inputData='';
	this.templateName = 'DATA_LAY_Exp.xml';
	this.requestId;
	this.isCancelRequest = false;
};

ProcessExportExcelForm.prototype.build = function() {
	var that = this;
	function exportExcel(){
		try {
			//Устанавливаем курсор ожидания
			BlockingUtil.wait();
			//Добавляем полученные данные в файл
			var isServerExport = false;
			//nodejs не корректно обрабатывает шаблон server_export.xlsm, поэтому для него xlsx расширение
			isServerExport = that.inputData.indexOf('template="server_export"') !== -1 || that.inputData.indexOf('template="export"') !== -1;

			var requestParams = ExportUtil.makeUTETaskServiceDataReqParams(that.templateName, that.inputData);
			that.requestId = App.serverQueryXMLNode(Services.exportExcelNode, requestParams
				,function exportToExcelResult(resultXml) {
					BlockingUtil.ready();
					var errorString = HTTPServiceUtil.getError(resultXml);
					if (errorString != "") {
						App.errorReport(gis_exportutil_8, resultXml.toString(), undefined, {filename:gis_filename_614, functionname:'gis_filename_614_1'});
					} else {
						var fileUrl = ExportUtil.exportExcelFileName;
						var extension = (isServerExport)?'xlsx':'xlsm';
						fileUrl = fileUrl.substr(0, fileUrl.indexOf('.xls') + 1); // cut .xls... without dot
						fileUrl += extension;
						var exportForm = new ExportForm();
						exportForm.link = fileUrl;
						exportForm.build();
					}
					ExportUtil.exportExcelFileName = "";
					cancel();
				}
				, function exportToExcelFault(resultXml) {
					BlockingUtil.ready();
					if(!that.isCancelRequest)
						App.errorReport(ExportUtil.EXPORT_EXCEL_ERROR, resultXml.toString(), undefined, {filename:gis_filename_614, functionname:'gis_filename_614_2'});
					that.isCancelRequest = false;
					ExportUtil.exportExcelFileName = "";
					cancel();
				}
			);
		} catch (e) {
			//Устанавливаем обычный курсор
			BlockingUtil.ready();
			App.errorReport(gis_exportutil_8, e.message, undefined, {filename:gis_filename_614, functionname:'gis_filename_614_3'});
			cancel();
		}
	}

	function cancel() {
		dlg.dialog('destroy').remove();
	}
	var element = $('<div><form class="smallExportDialogForm">\
						<div class="labelField" name="descriptionText">'+gis_processexportform_1+'</div>\
					</form></div>');
	$('body').append(element);

	var dlg = $(element).dialog({
		title: gis_core_1,
		dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
		closeOnEscape: that.closable,
		width: 320,
		height: 100,
		resizable: false,
		modal: false,
		close: function(event, ui){
			that.isCancelRequest = true;
			if(that.requestId !== undefined)
				that.requestId.abort();
			try{
				$(this).dialog('destroy').remove();
			}catch(e){}
		}
	});
	exportExcel();
};
/**
 * Класс всплывающей формы с экспортом в Excel
 */
function ExportForm() {
    this.closable = true;
    this.link='';
	this.elementId = undefined;
	this.htmlUrl = 'ui/html/ExportForm.html';
};

ExportForm.prototype.build = function() {
    var that = this;
    try {
        //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
        function build() {
            //Создаем диалоговую форму
            dlg.dialog({
                modal: true,
                title: gis_core_1,
                dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
                closeOnEscape: that.closable,
                width: 320,
                height: 120,
	            close: function(event, ui){
		            try{
			            $(this).dialog('destroy').remove();
		            }catch(e){}
		            $('#'+that.elementId).remove();
	            }
            });
	        $('#linkFile',dlg).attr('href',that.link).on('click',function(){
		        that.cancel();
	        });
        }
	    this.elementId = 'exportDialog_'+parseInt(Math.random()*1000000);

	    try{
		    $('#'+this.elementId).dialog('destroy').remove();
	    }
	    catch(e){}
	    $('#'+this.elementId).remove();
        //Создаем форму экспорта в GPX или KML
        $('body').append('<div id="'+this.elementId+'"></div>');
        var dlg = $('#'+this.elementId);

        dlg.load(this.htmlUrl, build);

    } catch (e) {
        App.errorReport(gis_exportutil_8, e.message, undefined, {filename:gis_filename_613, functionname:'gis_filename_613_1'});
        //Закрываем форму
        that.cancel();
    }
};

ExportForm.prototype.cancel = function() {
	try{
		$('#'+this.elementId).dialog('destroy').remove();
	}
	catch(e){
	}
	try{
		$('#'+this.elementId).remove();
	}
	catch(e){
	}
};

/**
 * Класс всплывающей формы для выбора подтвердения удаления записей
 */
/* TEXT CONSTANTS */
var DELETE_CONFIRMATION_FORM_ERROR = gis_deleteconfirmationform_1;
/**/

function DeleteConfirmationForm() {
    this.title = gis_deleteconfirmationform_2;
    this.closable = false;
    this.htmlUrl = 'ui/html/DeleteConfirmationForm.html';
    this.isContinue = false;
    this.parent = null;
};

DeleteConfirmationForm.prototype.build = function(elementId, deletingObjCount) {
    var that = this;

    //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
    function build() {
        //Создаем диалоговую форму
        dlg.dialog({
            modal: true,
            title: that.title,
            dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
            closeOnEscape: that.closable,
            width: 300,
            height: 120
        });

        function onChoose(detail) {
            try {
                var closeEvt = new CloseEvent(CloseEvent.CLOSE);
                closeEvt.detail = detail;
                closeEvt.dispatch();
            } catch (e) {
                App.errorReport(DELETE_CONFIRMATION_FORM_ERROR, e, undefined, {filename:gis_filename_309, functionname:'gis_filename_309_1'});
            }
        }

        if (deletingObjCount && deletingObjCount > 0) {
            var deleteMsgDiv = $(".labelField[name='descriptionTextCount']", dlg);
            if (deleteMsgDiv.length > 0) {
                deleteMsgDiv.text( deleteMsgDiv.text().replace("0.", deletingObjCount+".\n") );
            }

        }

        $("input[name='continue']", dlg).click(function () {
            onChoose(1); //Подтверждаем
            that.cancel();
        });
        $("input[name='cancel']", dlg).click(function () {
            that.isContinue = false;
            onChoose(0); //Отменяем
            that.cancel();
        });
    }

    that.elementId = elementId;

    $('#'+elementId).remove();
    //Создаем форму
    $('body').append('<div id="'+elementId+'"></div>');
    var dlg = $('#'+elementId);

    dlg.load(this.htmlUrl, build);
};

DeleteConfirmationForm.prototype.cancel = function() {
    $('#'+this.elementId).remove();
};

/**
 * Класс всплывающей формы для выбора подтверждения
 */

AlertForm.OK = "AlertForm.OK";
AlertForm.CANCEL = "AlertForm.CANCEL";

function AlertForm(opt_options) {
    var options = opt_options || {};
    this.title = gis_alertform_1;
    //Текст внутри формы сообщения
    this.messageText = gis_alertform_2;
    this.closable = false;
    //Путь шаблона для формы (в шаблоне указывается текст сообщения)
    this.htmlUrl = 'ui/html/AlertForm.html';
    this.isContinue = false;
    this.parent = null;
    this.width = 300;
    this.height = 100;
    this.alertOkButtonText = (options.objectType !== undefined)?options.objectType:gis_core_12;
    this.alertCancelButtonText = gis_core_6;
};

AlertForm.prototype.build = function(elementId, message, title, flags) {
    var that = this;
    that.messageText = message;
    that.title = title;

    //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
    function build() {
        //Создаем диалоговую форму
        dlg.dialog({
            modal: true,
            title: that.title,
            dialogClass: that.closable ? '' : 'noCloseButton',
            closeOnEscape: that.closable,
            width: that.width,
            height: that.height,
            create: function(event, ui) {
                dlg.parent('.ui-dialog').css('z-index', 30004)
                    .nextAll('.ui-widget-overlay').css('z-index', 1003);
            }
        });
        function onChoose(detail) {
            try {
                var closeEvt = new CloseEvent(CloseEvent.CLOSE);
                closeEvt.detail = detail;
                closeEvt.parent = that;
                closeEvt.dispatch();
            } catch (e) {
                App.errorReport(e, e, undefined, {filename:gis_filename_304, functionname:'gis_filename_304_1'});
            }
        }

        //Обрабатываем флаги
        if (flags && flags!=undefined && flags!='') {
            if (flags.indexOf(AlertForm.OK)==-1) $("input[name='continue']", dlg).hide();
            if (flags.indexOf(AlertForm.CANCEL)==-1) $("input[name='cancel']", dlg).hide();
        }

        //Устанавливаем в форму текст из messageText
        $("div[name='descriptionText']", dlg)[0].innerHTML = that.messageText;

        //Корректируем высоту по контенту
        var newDlgHeight = 80 + $("div[name='descriptionText']", dlg).height();
        dlg.dialog("option", "height", newDlgHeight);
        //Устанавливаем текст кнопок
        $("input[name='continue']", dlg).attr('value',that.alertOkButtonText);
        $("input[name='cancel']", dlg).attr('value',that.alertCancelButtonText);

        $("input[name='continue']", dlg).click(function () {
            onChoose(1); //Подтверждаем
            that.cancel();
        });
        $("input[name='cancel']", dlg).click(function () {
            that.isContinue = false;
            onChoose(0); //Отменяем
            that.cancel();
        });
    }

    that.elementId = elementId;

    $('#'+elementId).remove();
    //Создаем форму
    $('body').append('<div id="'+elementId+'"></div>');
    var dlg = $('#'+elementId);

    dlg.load(this.htmlUrl, build);
};

AlertForm.prototype.cancel = function() {
    $('#'+this.elementId).remove();
};

/**
 * Класс формы редактирования справочника
 */
function DirectoryEditForm(opt_options) {
    var that = this;
    var tempSource = 'PODS_SEM_DICT.xml#PODS_DIRECTION_GCL';//'PODS_SEM_DICT.xml#PODS_SHEET_NOTE_LINK_TYPE_CL';//'PODS_SEM_DICT.xml#PODS_SOURCE_GCL';
    var tempSQL = 'PODS_DIRECTION_GCL';//'PODS_SHEET_NOTE_LINK_TYPE_CL';
    var options = opt_options !== undefined ? opt_options : {};
    this.source = (options.source !== undefined)?options.source:'PODS_SEM_DICT.xml';
    this.requestSQL = (options.requestSQL !== undefined)?options.requestSQL:tempSQL;
    this.requestSource = (options.requestSource !== undefined)?options.requestSource:tempSource;
    this.htmlUrl = 'ui/html/DirectoryEditForm.html';
    //массивы объектов, которые менялись
    this.added = {};
    this.modified = {};
    this.deleted = {};
    //Поле для исключения из списка на копирование в эксель
    this.excludeVar = 'uid';


    this.baseDataAdapter = new BaseDataAdapter({
        requestSource: this.requestSource,
        source: this.source,
        added: this.added,
        modified: this.modified,
        deleted: this.deleted,
        updateSQL: this.requestSQL,
        insertSQL: this.requestSQL,
        deleteSQL: this.requestSQL,
        updateCompleteHandler:function(updateInfo){
            //массив объектов
            that.dataUpdateComplete_(updateInfo);
            $('#directoryEditForm').remove();
        },
        resultHandler: function(attrs,datas){
            //массив объектов
            that.fillGrid(attrs,datas);
        }
    });
};

DirectoryEditForm.prototype.build = function() {
    var that = this;

    $('#directoryEditForm').remove();
    //Создаем форму
    $('body').append('<div id="directoryEditForm"></div>');
    var dlg = $('#directoryEditForm');

    function build() {
        dlg.dialog({
            modal: true,
            title: gis_directoryeditform_1,
            dialogClass: 'gsi-zindex__dialog',
            closeOnEscape: true,
            width: 800,
            height: 400,
            resizable: false,
            create: function(event, ui) {
                dlg.parent('.ui-dialog').css('zIndex', 999)
            }
        });
        that.setDefaultsControls_();
    }

    dlg.load(this.htmlUrl,build);
};

/**
 * @param
 * @private
 */
DirectoryEditForm.prototype.setDefaultsControls_ = function() {
    var that = this;

    //контролы переводим к jqx
    $('#directoryAdd').on('click',function(){
        $("#directoryGrid").jqxGrid('addrow', null, {});
    });

    //контролы переводим к jqx
    $('#directoryRemove').on('click',function(){
        var selectedRowIndex = $("#directoryGrid").jqxGrid('getselectedrowindex');
        var rowsCount = $("#directoryGrid").jqxGrid('getdatainformation').rowscount;
        if (selectedRowIndex >= 0 && selectedRowIndex < rowsCount) {
            var id = $("#directoryGrid").jqxGrid('getrowid', selectedRowIndex);
            var rowData = $('#directoryGrid').jqxGrid('getrowdata', selectedRowIndex);
            //если ранее мы не добавляли, то будет запрос на update
            that.deleted[rowData.uid] = rowData;
            //если элемент был в modified и его удалили, то он переходит в объект deleted
            if(that.modified[rowData.uid] !== undefined){
                delete that.modified[rowData.uid];
            }
            //если элемент был добавлен и потом удален, то удаляем его из added и deleted
            if(that.added[rowData.uid] !== undefined){
                delete that.added[rowData.uid];
                delete that.deleted[rowData.uid];
            }
            var commit = $("#directoryGrid").jqxGrid('deleterow', id);
        }
    });

    $('#directoryCopyToExcel').on('click',function(){
        var dataObj = $('#directoryGrid').jqxGrid('getrows');
        var resultExcel = '';
        if(dataObj && dataObj.length){
            var colNames = Object.keys(dataObj[0]);
            //добавляем колонки в шапку
            if (colNames.indexOf(that.excludeVar) !== -1){
                colNames.splice(colNames.indexOf(that.excludeVar),1);
            }
            resultExcel += colNames.join('\t') + '\n';
            dataObj.forEach(function(it){
                var resultItem = '';
                colNames.forEach(function(colName){
                    var val = it[colName];
                    if(val)
                        resultItem += val + '\t';
                    else
                        resultItem += '\t';
                });
                resultItem += '\n';
                resultExcel += resultItem;
            });
            GridUtil.copyToExcelDialog(resultExcel);
        }
    });


    $('#directorySave').on('click',function(){
        that.save_();
        $('#directoryEditForm').remove();
    });

    $('#directoryCancel').on('click',function(){
        $('#directoryEditForm').remove();
    });
    var source ={
        localdata: [],
        datatype: "array"
    };
    var dataAdapter = new $.jqx.dataAdapter(source);
    $("#directoryGrid").jqxGrid({
        width: 785,
        height: 310,
        source: dataAdapter,
        localization: getLocalization('ru'),
        editable: true,
        columnsresize: true,
        theme:'gis-blue-grid',
        selectionmode: 'singlerow'
    });
    $("#directoryGrid").on('cellvaluechanged', function (event) {
        //забираем отредактированный ряд и заносим в объект
        var args = event.args;
        var rowData = $('#directoryGrid').jqxGrid('getrowdata', args.rowindex);
        //если ранее мы не добавляли, то будет запрос на update
        if(that.added[rowData.uid] === undefined)
            that.modified[rowData.uid] = rowData;

    });

    //запрос на заполнение
    this.baseDataAdapter.fill();

};


/**
 * Результат запроса на заполнение грида
 * @param datas
 */
DirectoryEditForm.prototype.fillGrid = function(attrs, datas) {
    var that = this;
    var i;
    var columns = [{text: gis_findroutegridform_2, sortable: false, filterable: false, editable: false,
        groupable: false, draggable: true, resizable: false,
        datafield: '', columntype: 'number', width: 20,
        cellsrenderer: function (row, column, value) {
            return "<div style='margin-left: 5px;margin-top: 2px;'>" + (value + 1) + "</div>";
        }}];
    var datafileds = [{name:'id', type: 'number'}];
	//если данные пришли без схемы(вариант со правочниками iust)
    if(attrs == undefined || attrs.length == 0){
        attrs = [];
        if(datas != undefined && datas.length > 0 ){
            var obj = datas[0];
            for(var o in obj){
	            attrs.push(o);
            }
        }
    }

    //общая ширина - 1-я колонка - место под скролл вертикальный, чтоб не появлялся горизонтальный(-20)
    var wp = (785-20)/attrs.length;
    for (i = 0; i < attrs.length; i++) {
        datafileds.push({name:attrs[i],type:'string'});
        columns.push({
            text: attrs[i],
            datafield: attrs[i],
            width: wp,
            groupable: false,
            draggable: true,
            resizable: true,
            sortable: true,
            sortfield: attrs[i]
        });
    }
    //парсим данные и устанавливаем колонки
    var gridAdapter = new $.jqx.dataAdapter({
        datafields: datafileds,
        id: 'uid',
        localdata: datas,
        addrow: function (rowid, rowdata, position, commit) {
            commit(true);
            if(rowid !== undefined){
                that.added[rowdata.uid] = rowdata;
            }
        }
    });
    try{
        $("#directoryGrid").jqxGrid({
            source: gridAdapter,
            columns: columns,
            sortable:true,
            showsortcolumnbackground:false,
            rowsheight: 19,
            altrows:true,
            columnsresize: true
        });
    }
    catch(e){}
    //$("#directoryGrid").jqxGrid('autoresizecolumns');
};


/**
 * Сохранение текущего состояния справочника
 */
DirectoryEditForm.prototype.save_ = function() {
    this.baseDataAdapter.update();
};

DirectoryEditForm.prototype.exportExcel_ = function(dataObj,layerId) {
    //забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
    var limitExportExcel = NaN;
    if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
        limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
    }
    var alertForm = new AlertForm();
    // isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
    if (limitExportExcel && dataObj.length > limitExportExcel && false && isNaN(limitExportExcel)){
        alertForm.build("gridExportLimitAlertForm",gis_directoryeditform_2+dataObj.length+".<br/>"
        +gis_directoryeditform_3+limitExportExcel+".<br/>"
        +gis_directoryeditform_4+limitExportExcel+gis_directoryeditform_5,gis_directoryeditform_6);
    }
    else{
        alertForm.build("gridExportLimitAlertForm",gis_directoryeditform_2+dataObj.length+".<br/>"
        + gis_directoryeditform_7,gis_directoryeditform_8);
    }
    //Добавляем слушатель закрытия формы
    $("body").on(CloseEvent.CLOSE, function (evt) {
        $("body").off(CloseEvent.CLOSE);
        if (evt && evt.detail==1) {
            //TODO переделать описание грида, чтобы в нем явно был указан шаблон для выгрузки в Excel (для PODS_ANODE_LIST.XML он например не указан)
            var fileName = App.generateUUID() + ".xls";
            var newDataObj = [];
            for ( var i = 0; i < dataObj.length; i++) {
                //удаляем колонку с uid, которую грид генерирует
                if (dataObj[i].uid !== undefined){
                    delete dataObj[i].uid;
                }
                var newData = {};
                for(var item in dataObj[i]){
                    var repl = /[^0-9a-zA-Zа-яА-Я_]/gi;
                    var curColItemText = dataObj[i][item];
                    //upd 27.05.20.заменяем \n в колонках на '', чтобы в excel в названиях не было _n
                    var curColHeaderText = item.replace(/(\\r\\n|\\n|\\r)/gm,'');
                    curColHeaderText = item.replace(repl, "_");
                    newData[curColHeaderText] = curColItemText;

                }
                newDataObj.push(newData);
            }
            ExportUtil.exportToExcelFromDirectory(newDataObj, fileName, layerId, 'export');
        }
    });
};


/**
 * Функция обработчки события окончания обновления данных.
 * Отображает информацию об изменениях в данных
 * @param updateInfo
 * @private
 */
DirectoryEditForm.prototype.dataUpdateComplete_ = function(updateInfo){
    var mess = '';
    var info = updateInfo;
    var hasSuccessfulChanges = false;
    if (info["added"] !== undefined && (info["added"] > 0)){
        mess += gis_directoryeditform_9 + info["added"] + "\n";
    }
    if (info["modified"] !== undefined && (info["modified"] > 0)){
        mess += gis_directoryeditform_10 + info["modified"] + "\n";
    }
    if (info["deleted"] !== undefined && (info["deleted"] > 0)){
        mess += gis_directoryeditform_11 + info["deleted"] + "\n";
    }
    if (mess != ''){
        var errorCnt = 0;
        if (info["errors"] !== undefined && parseInt(info["errors"]) > 0){
            errorCnt = parseInt(info["errors"]);
        }
        //Если ошибок нет - ставим hasSuccessfulChanges = true
        if (errorCnt==0)
        mess += gis_directoryeditform_12 + errorCnt + "\n";
        App.confirmDialog(mess);
    }
   // $('#directoryEditForm').remove();
};
var FIND_ROUTE_TITLE = gis_findroutegridform_1;
/**
 * Класс формы, который показывает маршрут
 */
function FindRouteGridForm(opt_options) {
    var options = opt_options !== undefined ? opt_options : {};
    this.columns = (options.attrs !== undefined)?options.attrs:[];
    this.datas = (options.datas !== undefined)?options.datas:[];
    this.htmlUrl = 'ui/html/FindRouteGridForm.html';
    this.resultCallback = options.resultCallback;
};

FindRouteGridForm.prototype.build = function() {
    var that = this;

    $('#findRouteGridForm').remove();
    $('.map-find-route-hideclose-buttons').remove();
    //Создаем форму
    $('body').append('<div id="findRouteGridForm"></div>');
    var dlg = $('#findRouteGridForm');

    function build() {
        dlg.dialog({
            dialogClass: "map-find-route-hideclose-buttons gsi-zindex__dialog",
            modal: false,
            title: FIND_ROUTE_TITLE,
            closeOnEscape: true,
            width: 757,
            height: 250,
            resizable: false,
            beforeClose: beforeClose
        }).dialogExtend({
                "closable" : true,
                "minimizable" : true,
                "minimizeLocation" : "right"
            });
        that.setDefaultsControls_();
        if(that.columns.length>0)
            that.fillGrid(that.columns,that.datas);

        $('#addPoint').on('click',function(){
            dlg.dialogExtend("minimize");
            if(that.resultCallback){
                that.resultCallback();
            }
        });

        function beforeClose() {
            WidgetMap.infoControl.handleMapInfoClick_();
        }
    }

    dlg.load(this.htmlUrl,build);
};

/**
 * @param
 * @private
 */
FindRouteGridForm.prototype.setDefaultsControls_ = function() {
    var source ={
        localdata: [],
        datatype: "array"
    };
    var dataAdapter = new $.jqx.dataAdapter(source);
    $("#findRouteGrid").jqxGrid({
        width: 745,
        height: 190,
        source: dataAdapter,
        localization: getLocalization('ru'),
        editable: false,
        theme:'gis-blue-grid',
        selectionmode: 'singlerow'
    });
};


/**
 * Результат запроса на заполнение грида
 * @param datas
 */
FindRouteGridForm.prototype.fillGrid = function(attrs, datas) {
    var i;
    var columns = [{text: gis_findroutegridform_2, sortable: false, filterable: false, editable: false,
         groupable: false, draggable: true, resizable: false,
         datafield: '', columntype: 'number', width: 30,
         cellsrenderer: function (row, column, value) {
             return "<div style='margin-left: 5px;margin-top: 2px;'>" + (value + 1) + "</div>";
    }}];
    var datafileds = [{name:'id', type: 'number'}];
    //общая ширина - 1-я колонка - место под скролл вертикальный, чтоб не появлялся горизонтальный(-20)
    var wp = (785-20)/attrs.length;
    for (i = 0; i < attrs.length; i++) {
        datafileds.push({name:attrs[i].name,type:'string'});
        columns.push({text:attrs[i].value, datafield:attrs[i].name,width:attrs[i].width, groupable: false, draggable: true, resizable: false, sortable: true, sortfield: attrs[i].name});
    }
    //парсим данные и устанавливаем колонки
    var gridAdapter = new $.jqx.dataAdapter({
        datafields: datafileds,
        id: 'uid',
        localdata: datas
    });

    $("#findRouteGrid").jqxGrid({
        source: gridAdapter,
        columns: columns,
        showsortcolumnbackground:false,
        rowsheight: 22,
        sortable:true,
        altrows:true,
        columnsresize: true
    });
};

/**
 * Класс всплывающей формы с фильтром нижнего уровня
 */
function BottomFilterForm(elementId) {
    this.title = gis_bottomfilterform_1;
    this.closable = true;
    this.htmlUrl = 'ui/html/BottomFilterForm.html';
    //Источник данных для комбобокса операций
    this.scalarFilterOp = ["=",">","<",">=","<=","!=", "likeA", "notLikeA", "likeA%", "like%A", "like%A%", "notLike%A%"]; /*["~=","=",">","&#60;",">=","<=","!="];*/
    //переменные устанавливаются извне при инициализации формы до вызова build()
    this.currentGrid = null;
    this.currentGridDescr = null;
    this.currentGridColumns = [];
    this.currentGridColumns1 = [];
    this.currentFilters = [];
    this.topFilters = [];
    this.roughFilters = [];
    this.hasSpatial = true;
    this.elementId = elementId;
    this.showFirstBottomFilterMessage = false;
}

BottomFilterForm.prototype.build = function(elementId) {
    try {
        var that = this;
        //После загрузки html-описания формы устанавливаем все умолчания и слушатели элементам
        function build() {
            //Создаем диалоговую форму
            dlg.dialog({
                modal: true,
                resizable: false,
                title: that.title,
                dialogClass: that.closable ? 'gsi-zindex__dialog' : 'noCloseButton gsi-zindex__dialog',
                closeOnEscape: that.closable,
                width: 825,
                height: that.hasSpatial ? 528 : 425
            });

            //Уникальный идентификатор грида формируем на основе идентификатора элемента
            var jqxGridId = "jqxgrid" + that.elementId;
            //Формируем обертку, в которой будем создавать грид
            var widgetContent =
                '<div id="jqxDockPanel' + jqxGridId + '" style="width: 100%; height: 100%">' +
                '<div id="jqxWidget' + jqxGridId + '" dock="right" style="width: 100%; height: 100%;">' +
                '<div id="' + jqxGridId + '" class="bottomFilter-mainGrid">' + //getLocalization('ru').loadtext +
                '</div>' +
                '</div>' +
                '</div>';
            $('#'+that.elementId+' .scalarBottomFilterBox').html(widgetContent)

            if(!that.hasSpatial)
                $('#'+that.elementId+' .topFilterBox').addClass('topFilterBox__no-spatial');
            //Создаем панель с возможностью процентного и фиксированного layout
            $("#jqxDockPanel"+jqxGridId).jqxDockPanel({ width: '100%', height: 170});

            //Создаем панель с динамическими комбобоксами
            var dynamicFilterContent = '<div id="topFilterBox' + jqxGridId + '" style="width: 100%; height: 100%"></div>';
            $('#'+that.elementId+' .topFilterBox').html(dynamicFilterContent);

            //Данные (установленные пользователем фильтры)
            //Добавляем фильтры, если они есть (передаются в форму через this.currentFilters)
            var data = [];

            //Массив div'ов с динамическими фильтрами
            var currentDynFilters = [];

            //Получение из общего массива фильтров динамического фильтра конкретной колонки (идет в списки)
            var getDynColumnFilter = function getDynColumnFilter(allFiltersArr, curColumn) {
                var curFilter;
                for (var i = 0; i < allFiltersArr.length; i++) {
                    curFilter = allFiltersArr[i];
                    if (curFilter && curFilter.hasOwnProperty('fld') && curFilter['fld']==curColumn.datafield) {
                        return curFilter;
                    }
                }
                return null;
            };

            //Фильтрация списка значений нижнего фильтра по переданному массиву значений фильтра верхнего или среднего уровня
            function sliceFiltersByArray(filterArray, dynFilterDivId, innerFilterDivId, dataProvider) {
                //return;
                if (filterArray!=undefined && filterArray && filterArray.length > 0) {
                    for (var jj = 0; jj < filterArray.length; jj++) {
                        var curTopFilterObj = filterArray[jj];
                        var curTopFilterDataProvider = $('.'+curTopFilterObj.name).myFilters('getFilterDataProviderString');
                        //Сравниваем сначала по провайдеру, и только если они не совпадают сравниваем по названию фильтра
                        if (curTopFilterObj && curTopFilterObj.hasOwnProperty('name') &&
                            (curTopFilterDataProvider==dataProvider || curTopFilterDataProvider+'_GRID'==dataProvider || curTopFilterObj.name==innerFilterDivId.toUpperCase()+'_FILTER')) {
                            //Значение фильтра верхнего уровня хранится в виде строки идентификаторов, разделенных запятой в свойстве value
                            //TODO хардкод. Если год обследования из задачи шурфовок, то показываем все годы
                            if(innerFilterDivId === 'YEAR_INSP')
                                $('#'+dynFilterDivId+' .'+innerFilterDivId).myFilters('updateTopFilter',{obj_ids:curTopFilterObj.value});
                            else
                                $('#'+dynFilterDivId+' .'+innerFilterDivId).myFilters('sliceListFilter',{obj_ids:curTopFilterObj.value});
                        }
                    }
                }
            }

            //Формируем массив для фильтрации по колонкам
            if (that.currentGridDescr && that.currentGridDescr.gridColumns && that.currentGridDescr.gridColumns.length > 0) {
                that.currentGridColumns = [];
                that.currentGridColumns1 = [];
                for (var i = 0; i < that.currentGridDescr.gridColumns.length; i++) {
                    var curCol = that.currentGridDescr.gridColumns[i];
                    //Добавляем к фильтрации только если в колонке есть параметр типа фильтрации!
                    if (curCol.filtercomparisiontype!==undefined) {
                        //Если curCol.filtercomparisiontype==='array', то это динамический комбобокс
                        if (curCol.filtercomparisiontype==='array') {
                            //Добавляем контрол динамического фильтра
                            var dynFilterDivId = jqxGridId+'dynFilterBox'+i;
                            var dynFilterDiv = '<div id="'+dynFilterDivId+'" class="dynamicFilterPopupList"/>';
                            var isInfinite = curCol.filterinfinite;
                            var selectAllElements = (!(FilterSourceDataManager && FilterSourceDataManager[curCol.filterrequestid] && FilterSourceDataManager[curCol.filterrequestid].selectAllElements === false));
                            $('#topFilterBox'+jqxGridId).append(dynFilterDiv);
                            //Создаем описание динамического комбобокса по описанию колонки
                            var dynFilterXml = "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'>" +
                                "<components:FilterPopUpButton width='100%' minPopupWidth='610' height='22' title='"+curCol.text.replace(/\\n/g, ' ')+"' selectAllElements='"+selectAllElements+"' minCnt='1' " +
                                "id='"+curCol.datafield+"' dataProvider='"+curCol.filterrequestid+ "' /> </mx:VBox>";
                            if(isInfinite){
                                $('#'+dynFilterDivId).myFilters({
                                    dataXML: dynFilterXml,
                                    infinite: isInfinite,
                                    requestId: curCol.filterrequestid,
                                    handlers:{
                                        infiniteCallback: function(xmlElement, requestId){
                                            var datas = App.convertDataXmlToArray(xmlElement);
                                            FilterSourceDataManager[requestId].datas = datas;
                                        },
                                    }
                                });
                                currentDynFilters.push({'dynFilterDivId':dynFilterDivId, 'curCol':curCol});
                            }
                            else{
                                $('#'+dynFilterDivId).myFilters({dataXML:dynFilterXml});
                                //Фильтруем список значений, если в фильтрах верхнего или среднего уровня есть такие фильтры (сравниваем по ID и по dataProvider)
                                sliceFiltersByArray(that.topFilters, dynFilterDivId, curCol.datafield, curCol.filterrequestid);
                                sliceFiltersByArray(that.roughFilters, dynFilterDivId, curCol.datafield, curCol.filterrequestid);
                                //Сохраняем id div'а с динамическим фильтром (чтобы потом забирать фильтры)
                                currentDynFilters.push({'dynFilterDivId':dynFilterDivId, 'curCol':curCol});
                                //Ищем в массиве that.currentFilters динамический фильтр текущей колонки (для выставления выбранных ранее значений)
                                var curDynFilter = getDynColumnFilter(that.currentFilters, curCol);
                                if (curDynFilter && curDynFilter.hasOwnProperty('val') && curDynFilter.val.length > 0) {
                                    var selFilterIds = [];
                                    for (var j = 0; j < curDynFilter.val.length; j++) {
                                        selFilterIds.push(curDynFilter.val[j]['CODE']);
                                    }
                                    $('#'+dynFilterDivId+' .'+curCol.datafield).myFilters('updateTopFilter',{obj_ids:selFilterIds.join(",")});
                                }
                            }

                        } else {
                            that.currentGridColumns.push(curCol);
                            that.currentGridColumns1.push({
                                text: curCol.text.replace(/\\n/g, ' '),
                                datafield: curCol.datafield,
                                filtercomparisiontype: curCol.filtercomparisiontype,
                                dateformat: curCol.dateformat,
                            });
                            //Ищем в массиве that.currentFilters статические фильтры текущей колонки (для выставления выбранных ранее значений)
                            for (var k = 0; k < that.currentFilters.length; k++) {
                                var curStatFilter = that.currentFilters[k];
                                if (curStatFilter && curStatFilter.hasOwnProperty('fld') && curStatFilter['fld']==curCol.datafield) {
                                    data.push(curStatFilter);
                                }
                            }
                        }
                    }
                }
            }
            var hasDictFilters = currentDynFilters.length !== 0;
            if(!hasDictFilters){
                var dynFilterDivIdFake = jqxGridId + 'dynFilterBox' + 'Fake';
                var dynFilterDivFake = '<div id="'+dynFilterDivIdFake+'" class="dynamicFilterPopupList"/>';
                $('#topFilterBox'+jqxGridId).append(dynFilterDivFake);
                var dynFilterXmlFake = "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'>" +
                    "<components:FilterPopUpButton width='100%' minPopupWidth='610' height='0' title='"+gis_bottomfilterform_4+"' selectAllElements='true' minCnt='1' " +
                    "id='fake_filter' dataProvider='none' /> </mx:VBox>";
                $('#'+dynFilterDivIdFake).myFilters({dataXML:dynFilterXmlFake});
                $('#'+dynFilterDivIdFake).hide();
                $('.dynamicFilterPopupList');
                $('#'+that.elementId+' .topFilterBox').css('width', '0px');
                $('#jqxWidget' + jqxGridId).css('width', '810px');
                $('#'+that.elementId+' .scalarBottomFilterBox').css('width', '810px');
            }
            else{
                $('#'+that.elementId+' .scalarBottomFilterBox').css('width', '430px');
            }
            //Увеличиваем высоту диалога на необходимую величину (динамически были добавлены комбобоксы)
            var dlgHeight = dlg.dialog("option","height");
            var topFilterBoxHeight = $('#topFilterBox'+jqxGridId).outerHeight();
            /*var maxHeight = $('.bottomFilterForm .topFilterBox').css('max-height');
            if(maxHeight){
                maxHeight = Number(maxHeight.replace('px',''));
                if(maxHeight <= topFilterBoxHeight)
                    topFilterBoxHeight = maxHeight;
            }
            if(topFilterBoxHeight !== 0)
                dlg.dialog("option","height", dlgHeight + topFilterBoxHeight);*/
            var currentGridColumnsAdapter = new $.jqx.dataAdapter(that.currentGridColumns1, {
                autoBind: true
            });

            function createEmptyHTML(hasDictFilters){
                var prefix = (!hasDictFilters)? '__nodict': '';
                var descrWidth = 125, valWidth = 160, opWidth = 100, dateClass = 'filter-datepicker_text';
                if(!hasDictFilters){
                    descrWidth = 250;
                    valWidth = 370;
                    opWidth = 140;
                    dateClass= 'filter-datepicker_text-nodict';
                }
                var id = jqxGridId+'_'+new Date().getTime();
                var div = $('<div id="maindiv_'+id+'" class="bottomFilter-scalarFields-row"></div>');
                var descr = $('<div id="descr_'+id+'" style="display:inline-block;" ></div>');
                var valDiv =  $('<div style="display:inline-block;" ></div>');
                var val = $('<input type="text" id="input_'+id+'" class="bottomFilter-scalarFields-row-input"/>');
                var valDate =  $('<div style="display:inline-block; float: left; height: 25px;">' +
                    '<input type="text" id="inputdate1_'+id+'" class="' + dateClass + ' bottomFilter-scalarFields-row-input"/>' +
                    '<input type="text" id="inputdate2_'+id+'" class="' + dateClass + ' bottomFilter-scalarFields-row-input"/>' +
                    '</div>');
                var imageDiv = $('<div class="bottomFilter-scalarFields-row-remove"></div>');
                var imageBtnHtml = $('<input type="button" class="gridButton bottomFilter-scalarFields-row-input"'
                +' style="padding: 0;margin-top: 5px;'+" background-image: url('./Public/assets/delete.png');"+'" value=" " title=""'
                +' id="btn_'+jqxGridId+'_'+id+'" />')
                    .on('click',function(event){
                        event.preventDefault();
                        var baseGridChildren = $("#"+jqxGridId).children();
                        if(baseGridChildren.length >1){
                            //дополнительное условие, если последний ряд пустой с невыбранным descr, то его не удаляем
                            if($('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                                $('#maindiv_'+id).remove();
                        }
                        return false;
                    });
                var useAutoDropDownHeight = that.currentGridColumns1 && that.currentGridColumns1.length <= 10;
                /*$.each(that.currentGridColumns1, function(key, value) {
                    descr.append($("<option></option>")
                            .attr("value",value.datafield)
                            .text(value.text));
                });*/

                descr.jqxDropDownList({source: currentGridColumnsAdapter, width: descrWidth, displayMember: 'text', valueMember: 'datafield', selectedIndex: -1,
                    placeHolder: gis_bottomfilterform_2, autoDropDownHeight: useAutoDropDownHeight, theme: 'gis-blueorange'})
                .on('change', function (event) {
                    if (event.args && event.args.item) {
                        var item = event.args.item;
                        var firstOption = $('#op-base_'+id+' option')[0];
                        //$("#"+jqxGridId).jqxGrid('source').records[curRow]['fld'] = item.value;
                        //Добавляем в hasType тип сравнения колонки - по нему строится строка запроса фильтра
                        if (item.hasOwnProperty('originalItem') && item.originalItem.hasOwnProperty('filtercomparisiontype') && item.originalItem.filtercomparisiontype!=undefined ) {
                            //если тип строковый, то дизейблим
                            val.show();
                            valDate.hide();
                            if(item.originalItem.filtercomparisiontype == 'date'){
                                $('#op-base_'+id).attr ('disabled', 'disabled').css('display','block');
                                $('#op-str_'+id).attr ('disabled', 'disabled').css('display','none');
	                            firstOption.selected = true;
                                val.hide();
                                valDate.show();
                                //устанавливаем формат даты, в которой нужно отправлять фильтр на сервер(миллисекунды или в текстовом виде yyyy.mm....)
                                $('#inputdate1_'+id).data('dateformat', item.originalItem.dateformat);
                                $('#inputdate2_'+id).data('dateformat', item.originalItem.dateformat);
                            }
                            else if (item.originalItem.filtercomparisiontype == 'string'){
                                $('#op-base_'+id).attr ('disabled', 'disabled').css('display','none');
                                $('#op-str_'+id).removeAttr('disabled').css('display','block');
                            }else{
                                $('#op-base_'+id).removeAttr('disabled').css('display','block');
                                $('#op-str_'+id).attr ('disabled', 'disabled').css('display','none');
                            }

                            //$("#"+jqxGridId).jqxGrid('source').records[curRow]['hasType'] = item.originalItem.filtercomparisiontype;
                        }
                    }
                });

                //Создаём 2 селекта для операций с числами и строками, один всегда имеет display: none (для тэга option display: none не работает в IE)
                var operationBase = $('<select id="op-base_'+id+'" class="bottomFilter-scalarFields-row-opselect bottomFilter-operation-base" disabled style="width: ' + opWidth +'px"></div>');
                var operationStr = $('<select id="op-str_'+id+'" class="bottomFilter-scalarFields-row-opselect bottomFilter-operation-str" disabled style="display:none; width: ' + opWidth +'px"></div>');
                var opDiv =  $('<div class="bottomFilter-scalarFields-row-opdiv" ></div>');
                $.each(that.scalarFilterOp, function(key, value) {
                    var text = value;//"likeA", "notLikeA", "like%A", "likeA%", "like%A%", "notLike%A%"
                    if(value === "<")text= "&#60;";
                    if(value === "likeA") value= "равно...";
                    if(value === "notLikeA")value= "не равно...";
                    if(value === "likeA%")value= "начинается с...";
                    if(value === "like%A")value= "заканчивается на...";
                    if(value === "like%A%")value= "содержит...";
                    if(value === "notLike%A%")value= "не содержит...";
                    if(key <= 5) {
                        operationBase.append($('<option class="bottomFilter-base-option"></option>')
                            .attr("value", text)
                            .text(value));
                    }else{
                        operationStr.append($('<option class="bottomFilter-str-option"></option>')
                            .attr("value", text)
                            .text(value));
                    }
                });
                val.jqxInput({height: 25, width: valWidth, theme:'gis-blueorange'})
                    .on('paste', function (evt) {
                        //Сделано специально для IE, на других браузерах вставка из Excel сама преобразует переносы строк в пробелы
                        try {
                            var replacedText = window.clipboardData.getData('text');
                            replacedText = replacedText.replace(/(\r\n|\n|\r)/gm,';'); //Заменяем переносы строк на ';'
                            setTimeout(function (){
                                val[0].value = replacedText;
                            },5);
                        } catch (err) {}
                    })
                    .on('focusout',function(evt){
                        //если поле условия выбрано и ряд последний, то новую создаем
                        //заменяем запятые на точки
                        var baseGridChildren = $("#"+jqxGridId).children();
                        if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                            createEmptyHTML(hasDictFilters);
                    })
                    .on('keyup',function(evt){
                        if (evt.keyCode === 13) {
                            //если поле условия выбрано и ряд последний, то новую создаем
                            var baseGridChildren = $("#"+jqxGridId).children();
                            if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                                createEmptyHTML(hasDictFilters);
                        }
                    });

                opDiv.append(operationBase);
                opDiv.append(operationStr);
                valDiv.append(val);
                valDiv.append(valDate);
                imageDiv.append(imageBtnHtml);
                div.append(descr).append(opDiv).append(valDiv).append(imageDiv);
                $("#"+jqxGridId).append(div);
                $('#inputdate1_'+id).datepicker().on('focusout',function(evt){
                    //если поле условия выбрано и ряд последний, то новую создаем
                    //заменяем запятые на точки
                    var baseGridChildren = $("#"+jqxGridId).children();
                    if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                        createEmptyHTML(hasDictFilters);
                })
                .on('keyup',function(evt){
                    if (evt.keyCode === 13) {
                        //если поле условия выбрано и ряд последний, то новую создаем
                        var baseGridChildren = $("#"+jqxGridId).children();
                        if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                            createEmptyHTML(hasDictFilters);
                    }
                });
                $('#inputdate2_'+id).datepicker().on('focusout',function(evt){
                    //если поле условия выбрано и ряд последний, то новую создаем
                    //заменяем запятые на точки
                    var baseGridChildren = $("#"+jqxGridId).children();
                    if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                        createEmptyHTML(hasDictFilters);
                })
                .on('keyup',function(evt){
                    if (evt.keyCode === 13) {
                        //если поле условия выбрано и ряд последний, то новую создаем
                        var baseGridChildren = $("#"+jqxGridId).children();
                        if( ('maindiv_'+id) == baseGridChildren[baseGridChildren.length-1].id &&  $('#descr_'+id).jqxDropDownList('getSelectedIndex')!=-1)
                            createEmptyHTML();
                    }
                });
                //val.hide();
                valDate.hide();
            }
            createEmptyHTML(hasDictFilters);
            if(that.showFirstBottomFilterMessage){
                App.confirmDialog(gis_grid_bottomfilter_2,null,{title:gis_core_1});
            }

	        //Функция проверки корректности введенных данных(пока только тип Date)
	        var checkFilter = function checkFilter(filter){
                var i=0;
                var result = true;
		        for(;i<filter.length;i++){
		            var item = filter[i];
                    if(item.hasType == 'date' && item.startDate != undefined && item.endDate != undefined){
                        var matchStr1 = /^(\d{1,2})[.\/](\d{1,2})[.\/](\d{4})$/;
                        var matchStr2 = /^(\d{1,2})[.\/](\d{4})$/;
                        var matchStr3 = /^(\d{4})$/;
	                    var matches = matchStr1.exec(item.startDate);
	                    if (matches == null) {
		                    matches = matchStr2.exec(item.startDate);
		                    if (matches == null) {
			                    matches = matchStr3.exec(item.startDate);
			                    if (matches == null)
			                        result = false;
			                    else
                                    item.startDate = '01.01.' + item.startDate;//дописываем месяц и день
                            }
		                    else
                                item.startDate = '01.' + item.startDate; //дописываем день
	                    }
                        matches = matchStr1.exec(item.endDate);
                        if (matches == null) {
                            matches = matchStr2.exec(item.endDate);
                            if (matches == null) {
                                matches = matchStr3.exec(item.endDate);
                                if (matches == null)
                                    result = false;
                                else
                                    item.endDate = '31.12.' + item.endDate;//дописываем месяц и день
                            }
                            else{
                                try{
                                    var days = daysInMonth(matches[1],matches[2]);
                                    item.endDate = days + '.' + item.endDate; //дописываем день
                                }
                                catch(ex){
                                    item.endDate = '28.' + item.endDate; //дописываем день. Если ошибка парсинга, то выставляем нижнюю границу 28 дней, чтобы не было ошибки БД
                                }

                            }

                        }
                    }
                }
	            return result;
	        };
            var daysInMonth = function daysInMonth (month, year) {
                return new Date(year, month, 0).getDate();
            }
            //Функция собирает в общий массив фильтры из формы
            var getFilter = function getFilter(){
                var resultFilters = [];
                //Получаем текущий грид со статическими фильтрами
                var gridSource  = $("#"+jqxGridId).children();
                var i;
                for (i = 0; i < gridSource.length; i++) {
                    var newItem = {};
                    //получаем id, начиная с 8, т.к. вначале идёт "maindiv_"
                    var cId = gridSource[i].id.substr(8);
                    //забираем значения полей
                    var descrItem = $('#descr_'+cId).jqxDropDownList('getSelectedItem');
                    if(descrItem!=undefined && descrItem.originalItem != undefined){
                        newItem.hasType = descrItem.originalItem.filtercomparisiontype;
                        newItem.fld = descrItem.originalItem.datafield;
                        newItem.descr = descrItem.originalItem.text;
                        var opItem = $('#op-base_'+cId).is(':visible')? $('#op-base_'+cId).val(): $('#op-str_'+cId).val();
                        if(opItem!=undefined)
                            newItem.op = opItem;//.value;
                        if(descrItem.originalItem.filtercomparisiontype !== 'date')
                            newItem.val = $('#input_'+cId).jqxInput('val');
                        else{
                            var startDate = $('#inputdate1_'+cId).val();
                            var endDate = $('#inputdate2_'+cId).val();
                            if(!startDate) startDate = '01.01.1900';
                            if(!endDate) endDate = '01.01.2121';
                            newItem.startDate = startDate;
                            newItem.endDate = endDate;

                            newItem.dateformat = $('#inputdate1_'+cId).data('dateformat');
                            newItem.val = 'none';//оставляем, чтобы не порушилась функция формирования нижнего фильтра GridWidget.prototype.getBottomFilterString
                        }
                        newItem.del = '';
                        //Перед включением условия в запрос проверяем, что оно заполнено по fld, т.е. что колонка для условия выбрана
                        resultFilters.push(newItem);
                    }
                }
                //Добавляем в фильтр выбранные в динамических комбобоксах значения
                for (i = 0; i < currentDynFilters.length; i++) {
                    var dynFilterDivId = currentDynFilters[i]['dynFilterDivId'];
                    var dynFilterCol = currentDynFilters[i]['curCol'];
                    var curDynFilters = [];
                    //Получаем список выбранных записей
                    var resFilterValues = $('#'+dynFilterDivId).myFilters('getFilterValuesArray');
                    var dotSplitArr = resFilterValues[0].values;
                    //Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию либо тип фильтр не infinite(с большим)
                    var checkAllCheckBox = $($('#'+dynFilterDivId+" .divCheckAll")[0].children[0]);
                    if (dotSplitArr.length<=0 || (checkAllCheckBox && checkAllCheckBox.jqxCheckBox('checked') && !checkAllCheckBox.data('infinite'))) continue;
                    var j;
                    for (j = 0; j < dotSplitArr.length; j++) {
                        var selectedObj = {'CODE':dotSplitArr[j].code};
                        curDynFilters.push(selectedObj);
                    }
                    //Добавляем фильтр по полю, только если в нем что-то выбрано. Если выбраны все записи - условие добавлять не нужно
                    var curDynFilterObj = {'hasType':"", 'del':"", 'descr':dynFilterCol.text, 'fld':dynFilterCol.datafield, 'op':"in", 'val':curDynFilters};
                    resultFilters.push(curDynFilterObj);
                }

                return resultFilters;
            };

            //создаем радиобатоны
            //21.07.2020 Добавлена правка,если приходит false, значит слой не имеет геокоординат
            if (that.hasSpatial){
                $('#'+that.elementId+' .bottomFilterHighlight').jqxRadioButton({width: 20, checked: true,});
                $('#'+that.elementId+' .bottomFilterSlice').jqxRadioButton({width: 20, checked: false });
                //Создаем чекбоксы
                //$("#bottomFilterSelectingCheckbox").jqxCheckBox({width: 120, height: 20, checked: true});
                $('#'+that.elementId+' .bottomFilterCenteringCheckbox').jqxCheckBox({width: 120, height: 20, checked: true});
            }else {
                $('#'+that.elementId+' .bottomFilterHighlight').remove();
                $('#'+that.elementId+' .bottomFilterSlice').remove();
                $('#'+that.elementId+' .bottomFilterCenteringCheckbox').remove();
                $('#'+that.elementId).find('label').last().remove();
            }

            //Кнопки Ок и отмены
            $("input[name='apply']", dlg).click(function () {
                //Собираем фильтр по имеющимся в форме значениям
                var curFilter = getFilter();
                //проверка на корректность ввода типа Даты
                if(checkFilter(curFilter)){
                    //если false - оставялем на карте выбранные объекты
                    var selecting, centering;
                    if (that.hasSpatial){
                        selecting =  $('#'+that.elementId+' .bottomFilterHighlight').jqxRadioButton('checked');
                        centering = $('#'+that.elementId+' .bottomFilterCenteringCheckbox').jqxCheckBox('checked');
                    }
                    that.applyBottomFilter(curFilter, that.currentGrid, selecting, centering);
                }else
                    App.confirmDialog(gis_grid_bottomfilter_1,null,{title:gis_core_1});
            });
            $("input[name='cancel']", dlg).click(function () {
                that.close();
            });
        }

        that.elementId = elementId;

        if($('#'+elementId).length>0){
            that.open();
        }
        else{
            //Создаем форму
            $('body').append('<div id="'+elementId+'"></div>');
            var dlg = $('#'+elementId);
            dlg.load(this.htmlUrl+'?'+Math.random(), build);
        }

        //$('#'+elementId).remove();

    } catch (e) {
        App.errorReport(gis_bottomfilterform_3, e, undefined, {filename:gis_filename_307, functionname:'gis_filename_307_1'});
    }
};

BottomFilterForm.prototype.sendCloseEvent = function sendCloseEvent(detail, curFilter, currentGrid, selecting, centering) {
    var closeEvt = new CloseEvent(CloseEvent.CLOSE);
    closeEvt.detail = detail;
    if (curFilter && curFilter!=undefined) {
        closeEvt.eventData = {filter: curFilter, currentGrid: currentGrid, "selecting": selecting, "centering": centering};
    }
    closeEvt.dispatch();
};

BottomFilterForm.prototype.applyBottomFilter = function applyBottomFilter(curFilter, currentGrid, selecting, centering, highlight) {
    //Генерируем событие закрытия формы с сохранением
    BottomFilterForm.prototype.sendCloseEvent(1, curFilter, currentGrid, selecting, centering, highlight);
    //Удаляем форму (с небольшой задержкой, чтобы успели отработать все функции получения фильтров до закрытия формы)
    var curElemId = this.elementId;
    setTimeout(function(){
        $('#'+curElemId).dialog('close');//.remove();
    },100);
};

BottomFilterForm.prototype.cancel = function() {
    //Генерируем событие закрытия формы без сохранения
    BottomFilterForm.prototype.sendCloseEvent(0);
    //Удаляем форму
    $('#'+this.elementId).remove();
};

BottomFilterForm.prototype.close = function() {
    //Генерируем событие закрытия формы без сохранения
    BottomFilterForm.prototype.sendCloseEvent(0);
    //Удаляем форму
    $('#'+this.elementId).dialog('close');
};

BottomFilterForm.prototype.open = function() {
    $('#'+this.elementId).dialog('open');
};




/**
 * Класс для управления видимостями и положением колонок грида
 * @param opt_options
 * @constructor
 */
function ManageGridColumnsForm(opt_options) {
    var options = opt_options !== undefined ? opt_options : {};
    this.columns = (options.columns !== undefined)?options.columns:[];
    this.htmlUrl = 'ui/html/grid/ManageGridColumnsForm.html';
    this.applyCallback = (options.applyCallback !== undefined)?options.applyCallback:undefined;
};

ManageGridColumnsForm.prototype.build = function() {
    var that = this;
    var currDialog = $('#gridColumnsDialog');
    if(currDialog.length == 0){
        $('body').append('<div id="gridColumnsDialog" style="overflow: hidden;"></div>');
        $('#gridColumnsDialog').hide();
        currDialog = $('#gridColumnsDialog');
    }
    var dlg = currDialog;
    dlg.load(this.htmlUrl, build);
    function build() {
        dlg.dialog({
            modal: true,
            title: gis_managegridcolumnsform_1,
            closeOnEscape: false,
            dialogClass: 'noCloseButton gsi-zindex__dialog',
            width: 500,
            height: 400,
            resizable: false
        });
        //заполняем данными элементы
        that.fillGridColumnsGrid_();
        //кнопки "Применить", "Отмена"
        $('#gridColumnsApply').on('click',function(){
            that.applyColumns_();
            $('#gridColumnsDialog').remove();
        });
        $('#gridColumnsCancel').on('click',function(){
            $('#gridColumnsDialog').remove();
        });
    }
};

/**
 * Заполнение списка колонок
 * @private
 */
ManageGridColumnsForm.prototype.fillGridColumnsGrid_ = function(){
    var that = this;
    var columnsdata = [];
    var selectAll = true;
    for (var i = 0; i < this.columns.length; i++) {
        var column = this.columns[i];
        if(!column.text || column.datafield === 'RWN')
            continue;
        var obj = {
            dataField: column.datafield,
            columnName: column.text.replace(/\\n/g,' '),
            visible: !column.hidden,
        };
        selectAll = selectAll && !column.hidden;
        columnsdata.push(obj);
    }

    var source = {
        localdata: columnsdata,
        datatype: "array",
        datafields:
            [
                { name: 'dataField', type: 'string' },
                { name: 'columnName', type: 'string' }, //название кирилицей
                { name: 'visible', type: 'string' }, // !hidden
            ]
    };
    var layerNameSize = 62;
    $('#gridColumnsApply').css('width', 89);

    var dataAdapter = new $.jqx.dataAdapter(source);
    $("#gridColumnsGrid").jqxGrid({
        width: 490,
        height: 330,
        source: dataAdapter,
        pageable: false,
        altRows: false,
        selectionmode:'singlerow',
        columnsResize: true,
        editable: true,
        theme:'gis-blue-grid',
        localization: getLocalization('ru'),
        columns: [
            {
                text: '',
                sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                datafield: 'visible', columntype: 'string', width: 25,
                cellsrenderer: function (row, column, value) {
                    if(value === 'true'){
                        return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='ManageGridColumnsForm.prototype.setVisible_(this,"+row+")' checked></div>";
                    }
                    else{
                        return "<div><input type='checkbox' style='margin-left: 5px;margin-top: 5px;' onchange='ManageGridColumnsForm.prototype.setVisible_(this,"+row+")'></div>";
                    }
                },
                renderer: function () {
                    return '<div><input type="checkbox" style="margin-left: 5px;margin-top: 5px;" id="manage_grid_columns_all_checkbox"></div>'
                },
                rendered: function (element) {
                    var checkbox = $(element).last();
                    $(checkbox).on('click', function (event) {
                        event.stopPropagation()
                    }).on('change', function (event) {
                        var checked =  $('#manage_grid_columns_all_checkbox').is(':checked');
                        ManageGridColumnsForm.prototype.setAllVisible(checked)
                    });
                    return true;
                },
            },
            {
                text: '', sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                datafield: 'up', columntype: 'number', width: 25,
                cellsrenderer: function (row, column, value) {
                    return "<div type='submit' class='map-img map-up-img' onclick='ManageGridColumnsForm.prototype.upColumn_(this,"+value+")' title='"+gis_cassettingsform_9+"'></div>";
                }
            },
            {
                text: '', sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                datafield: 'down', columntype: 'number', width: 25,
                cellsrenderer: function (row, column, value) {
                    return "<div type='submit' class='map-img map-down-img' onclick='ManageGridColumnsForm.prototype.downColumn_(this,"+value+")' title='"+gis_cassettingsform_10+"'></div>";
                }
            },
            {   text: gis_managegridcolumnsform_2, datafield: 'columnName',
                sortable: false, filterable: false, editable: false,
                groupable: false, draggable: false, resizable: false,
                columntype: 'string', width: 390
            }
        ]
    });

    $('#manage_grid_columns_all_checkbox').prop('checked', selectAll);
};

/**
 * Передвигаем меняем местами график
 * @param elem
 * @param row
 * @private
 */
ManageGridColumnsForm.prototype.upColumn_ = function (elem, index) {
    //получаем весь список, там переносим в нужные позиции и заполняем грид
    var rows = $("#gridColumnsGrid").jqxGrid('getrows');
    if (index != 0) {
        var temp = rows[index];
        rows[index] = rows[index - 1];
        rows[index - 1] = temp;

        var source = {
            localdata: rows,
            datatype: "array",
            datafields:
                [
                    {name: 'dataField', type: 'string'},
                    {name: 'columnName', type: 'string'}, //название кирилицей
                    {name: 'visible', type: 'string'}, // !hidden
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#gridColumnsGrid").jqxGrid({source: dataAdapter});
        $("#gridColumnsGrid").jqxGrid('selectrow', index - 1);
    }
};
/**
 * Передвигаем меняем местами график
 * @param elem
 * @param row
 * @private
 */
ManageGridColumnsForm.prototype.downColumn_ = function (elem, index) {
    var rows = $("#gridColumnsGrid").jqxGrid('getrows');
    if (index != rows.length - 1) {
        var temp = rows[index];
        rows[index] = rows[index + 1];
        rows[index + 1] = temp;

        var source = {
            localdata: rows,
            datatype: "array",
            datafields:
                [
                    {name: 'dataField', type: 'string'},
                    {name: 'columnName', type: 'string'}, //название кирилицей
                    {name: 'visible', type: 'string'}, // !hidden
                ]
        };
        var dataAdapter = new $.jqx.dataAdapter(source);
        $("#gridColumnsGrid").jqxGrid({source: dataAdapter});
        $("#gridColumnsGrid").jqxGrid('selectrow', index + 1);
    }
};


/**
 * Функция управления видимостью слоя
 * @param elem
 * @param rowKey
 * @private
 */
ManageGridColumnsForm.prototype.setVisible_ = function(elem, rowKey){
    var isChecked = '' + $(elem).prop('checked');
    $("#gridColumnsGrid").jqxGrid('setcellvalue',rowKey,'visible', ''+ isChecked);
    var keys = $("#gridColumnsGrid").jqxGrid('getrows');
    var selectAll = true;
    keys.forEach(function(item, i){
        selectAll = selectAll && (item.visible === 'true');
    })
    $('#manage_grid_columns_all_checkbox').prop('checked', selectAll);
};

/**
 * Снимает/добавляет видимость у всех колонок
 * @param checked
 * @private
 */
ManageGridColumnsForm.prototype.setAllVisible = function(checked){
    var keys = $("#gridColumnsGrid").jqxGrid('getrows');
    keys.forEach(function(item, i){
        $("#gridColumnsGrid").jqxGrid('setcellvalue', i, 'visible', ''+ checked);
    })
};


/**
 * Применяем видимость и показ подписей к слоям
 * @private
 */
ManageGridColumnsForm.prototype.applyColumns_ = function() {
    var that = this;
    var rows = $("#gridColumnsGrid").jqxGrid('getrows');
    var fakeRows = rows.slice(0);
    var allColumns = that.columns;
    var lastFakeColumn;
    var counterPinned = 0;
    //формируем обновленный список колонок
    var newColumns = [];

    for (var i = 0; i < allColumns.length; i++){
        var column = allColumns[i];
        if (column.text && column.datafield !== 'RWN'){
            var row = fakeRows.shift();
            if (column.pinned) {
                counterPinned++;
                column.pinned = false;
            }
            if (column.datafield === row.dataField){
                column.hidden = !(row.visible === 'true');
                newColumns.push(column);
            }else {
                allColumns.forEach(function (columnI){
                    if (columnI.datafield === row.dataField){
                        columnI.hidden = !(row.visible === 'true');
                        newColumns.push(columnI);
                    }
                });
            }
        }else {
            if (column.width != '20')
                newColumns.push(column);
            else
                lastFakeColumn = column;
        }
    }
    newColumns.forEach(function (column) {
        if (column.text && column.datafield !== 'RWN'){
            if (counterPinned > 0){
                column.pinned =true;
                counterPinned--;
            }
        }
    });
    if (lastFakeColumn)
        newColumns.push(lastFakeColumn);
    if(this.applyCallback)
        this.applyCallback(newColumns);

};
/* Глобальный объект с функциями для ПКА */
CASUtil = {};
//разделитель таблиц - просто свободная колонка
CASUtil.DIVIDER = '<td></td>';
CASUtil.BEGIN_DIVIDER = '<td>';
CASUtil.END_DIVIDER = '</td>';
//Поле в объекте, в котором хранится подпись
CASUtil.idField = 'ID';
CASUtil.labelField = 'LABEL';
CASUtil.geoField = 'geo';
//Имена свойств с координатами x и y
CASUtil.xField = 'x';
CASUtil.yField = 'y';

CASUtil.kmDataAttributeName = 'x';
CASUtil.lineDistDataAttributeName = 'x';



//Функция проверяет что CASLayer является ЛИНЕЙНОЙ 2D диаграммой (для точечных выводим как обычно, там нет группировки по отчетам).
//Если является, возвращает объект, в котором в children содержатся все типизированные Features
//Если не является, возвращает переданный объект (слой) без изменений
CASUtil.getGeoIfTwoDimension = function(layObj){
	//Получаем CASLayer из обертки
	//Если диаграмма 2D и хотя бы 1 диаграмма имеет собственную подпись - считаем что каждую линию нужно выгружать отдельно
	var casLay = layObj.layer;

	var container = {layer:casLay, mapName:casLay.mapName, layerName:casLay.sourceDescr,order:parseInt(casLay.order)};

	if (goog.isDef(casLay) && goog.isDef(casLay.spatialVariables) && goog.isDef(casLay.spatialVariables.TYPE) && (casLay.spatialVariables.TYPE=="2D" || casLay.spatialVariables.TYPE=="interval")
		&& casLay.featureProjLayer.getSource().getSource().getFeatures().length>0 && casLay.featureProjLayer.getSource().getSource().getFeatures()[0].getGeometry() instanceof ol.geom.MultiLineString){
		var hasLabel = false;
		var features = casLay.featureProjLayer.getSource().getSource().getFeatures();
		var labelObjs = features[0].get('labelsObj');
		for(var i in labelObjs){
			if(labelObjs[i].label !=''){
				hasLabel = true;
				break;
			}
		}
		//Если ни у одной из линий в MultiLineStringFeature нет подписи - это не отдельные отчеты, а обычная линейная 2D диаграмма !!!
		if (!hasLabel)
			return container;

		//Генерируем и сохраняем обертки в children
		var arr = [];
		//Создаем обертки для каждой геометрии из каждой feature и добавляем в массив
		for (var i = 0 ; i<features.length; i++){
			var dataObj = features[i].get('labelsObj');
			for (var idStr in dataObj){
				var obj = dataObj[idStr];
				//Если границы геометрии целиком находятся в отрицательных координатах - это фиктивные объекты, не включаем их в экспорт

				if (goog.isDef(obj.geo) && obj.geo.getExtent()[0]<0 && obj.geo.getExtent()[2]<0)
						continue;

				var geomData = {};
				geomData.obj = obj;
				geomData.layer = casLay;
				geomData.mapName = casLay.sourceDescr;
				geomData.layerName = goog.isDef(obj.label) ? obj.label : gis_casutil_1;
				//В order здесь будем хранить ID каждой отдельной геометрии !!!
				geomData.order = parseInt(obj.id);
				//Сохраняем в общий массив
				arr.push(geomData);
			}
		}
		//Возвращаем массив отдельных оберток
		return arr;
	}
	return container;
};

//Функция возвращает массив с данными для экспорта по переданному массиву контейнеров
CASUtil.getExportDataFromArr = function(srcArr){
	//var resArray = [];
	for(var i in srcArr){
		var container = srcArr[i];
		var casLay = container.layer;
		casLay.selectedObjects = [];
		//var geomData:MapLayerContainer = new MapLayerContainer(casLay);
		//Если имя базы слоя не совпадает с layerName обертки, значит это обертка конкретного объекта, а не всего слоя
		if (container.layerName != casLay.sourceDescr){
			//Добаляем текущий объект в выбранные
			if (goog.isDef(container.obj) && goog.isDef(container.obj.geo))
				casLay.selectedObjects.push(container.obj);
		}
		//if (resArray.indexOf(casLay)<0)
		//	resArray.push(casLay);
	}
	//return resArray;
};


/**
 * Переводим данные в слое в структуру html
 * @param {array} layer
 * @param {boolean} addKmField
 * @param {number} minX
 * @param {number} maxX
 * @param {string} replacementLabel
 */
CASUtil.layersToHTMLTable = function (layer, addKmField, minX, maxX, replacementLabel, selectedObjects) {
	try{
		//maxX = 1700;
		//minX = 1593.7;
		var result = '<html><body>';
		var outer_table = false;
		if (!goog.isDef(layer))
			return '';

		var cursorsList = [];
		var commonX = [];
		var dp;
		var xAttr = CASUtil.xField;
		var obj;
		var xVal;
		var showXCoordinate = false;

		//Массив слоев в которых есть только участки
		var barLayer = CASUtil.getBarLayer(layer,selectedObjects);

		if (goog.isDef(barLayer)) {
			// добавляем еще табличку, чтобы они располагались при выводе
			// последовательно по горизонтали, а не друг под другом
			result += "<table><tr>";
			outer_table = true;
		}

		if(!goog.isDef(barLayer)){
			//Дополнительная строка, в которой число ячеек будет соответствовать количеству отдельных feature
			//Закрывающий тек спереди для закрытия заголовочной строки таблицы (строка с типами будет следующей за ней)
			var stringOfTypes = "</tr><tr>";
			if (outer_table){
				result += CASUtil.BEGIN_DIVIDER;
			}
			result += "<table><thead><tr>";
			if (addKmField){
				result += "<th>КИЛОМЕТР</th>";
				stringOfTypes += "<th></th>";
			}
			if (showXCoordinate){
				result += "<th>АБСОЛЮТНАЯ ЛИНЕЙНАЯ ДИСТАНЦИЯ</th>";
				stringOfTypes += "<th></th>";
			}

			//lay - это слой, из которого нужно получать объекты из feature.data, где хранится id объекта, геометрия, подпись и тип
			var lay = layer;
			var s_sort;
			var s_sField;
			//Не обрабатываем слои из barLayersArr
			var i,j;
			var featuresGeomArr;
			//У слоев с непустым массивом lay.selectedObjects мы должны включать только объекты из этого массива
			//Если слой пустой - значит мы должны экспортировать его полностью (не должно быть разбиения на отдельные графики)
			//2013_02_04. Замечание - чтобы не было каши из дефектов и прочих точек, нужно распределять геометрии по типам.
			//Тип, содержащийся в feature
			var featureType = "";
			if (lay.selectedObjects.length==0){
				//Здесь заполняем dp точками, из которых состоит геометрия слоя
				var features = lay.featureProjLayer.getSource().getSource().getFeatures();
				for (i in features){
					var ftr = features[i];
					//Для разделения по типам мы должны каждую отдельную feature выводить в своем столбце
					featuresGeomArr = [];
					var dataObj = ftr.get('labelsObj');
					var dataObjSorted = dataObj.sort(function(a, b){
						if(a.id < b.id) return -1;
						if(a.id > b.id) return 1;
						return 0;
					});
					for (j in dataObjSorted){
						var ftrData = dataObjSorted[j];
						//У слоев с непустым массивом lay.selectedObjects мы должны включать только объекты из этого массива
						if (goog.isDef(ftrData[CASUtil.geoField]) && (lay.selectedObjects.length==0 || lay.selectedObjects.indexOf(ftrData)>=0)){
							var fCoords = ftrData[CASUtil.geoField].getFlatCoordinates();
							var pp = 0;
							var cLength = fCoords.length;
							if(ftrData[CASUtil.geoField] instanceof ol.geom.Polygon)//не включаем последнюю точку, т.к. совпадает с первой для замыкания
								cLength = fCoords.length-2;
							for (; pp < cLength; pp += 2) {
								featuresGeomArr.push({x: fCoords[[pp]], y: fCoords[pp + 1]});
							}
							//featuresGeomArr = featuresGeomArr.concat({x:fCoords[0],y:fCoords[1]});
							//Сохраняем тип, хранящийся в ftrData[geoField]
							featureType = '';
							var lt = ftr.get('labelType').split('/');
							if(lt.length>1)
								featureType = lt[1];
							//ftrData.hasOwnProperty(lay.typeField) ? ftrData[lay.typeField] : "";
						}
					}

					//Если данных нет - не создаем столбец для такой feature, в ней нет выбранных или валидных данных
					if (featuresGeomArr.length==0)
						continue;

					//счетчик, чтобы посчитать количество элементов, которые попали в итоговый массив
					//мнимые могут быть, могут не быть, поэтому проверку изначально не делаю на кол-во элементов
					var counter = 0;
					//сортируем
					featuresGeomArr.sort(function(a,b) {
						return a.x - b.x;
					});
					//собираем данные
					for (j = 0 ;j< featuresGeomArr.length; j++){
						xVal = featuresGeomArr[j].x;
						//Ограничиваем данные по заданным minX и maxX
						if (commonX.indexOf(xVal) < 0 && xVal >= 0 && xVal <= maxX - minX){
							commonX.push(xVal);
							++counter;
						}
					}
					//Добавляем к строке типов очередной тип
					if(counter>0){
						stringOfTypes += "<th>"+featureType+"</th>";
						//Создаем курсор после сортировки, чтобы он указывал на начальный элемент
						//cursorsList.push(featuresGeomArr);
						cursorsList.push(new CASCursor(featuresGeomArr));
					}
				}
				//Соединяем количество ячеек, равное количеству features в слое
				if (lay.sourceDescr!=""){
					if(replacementLabel && replacementLabel.length > 0)
						result += "<th colspan='"+cursorsList.length+"'>"+ replacementLabel + "</th>";
					else
						result += "<th colspan='"+cursorsList.length+"'>"+ lay.sourceDescr + "</th>";
				}
				else{
					result += "<th colspan='"+cursorsList.length+"'> [БЕЗ ИМЕНИ] </th>";
				}
			}
			else {
				featuresGeomArr = [];
				for (var f = 0; f < lay.selectedObjects.length; f++) {
					ftrData = lay.selectedObjects[f];
					//Среди таких объектов могут быть отрезки с одинаковым Y, их нужно выводить отдельным способом
					var laySourceName = lay.sourceDescr != "" ? lay.sourceDescr : " [БЕЗ ИМЕНИ] ";
					var ftrLabel = ftrData.label != "" ? ftrData.label : "";
					result += "<th>" + laySourceName + "\n " + ftrLabel + "</th>";
					//Здесь заполняем dp точками, из которых состоит геометрия слоя
					var fCoords = ftrData[CASUtil.geoField].getFlatCoordinates();
					var pp = 0;
					for (; pp < fCoords.length; pp += 2) {
						featuresGeomArr = featuresGeomArr.push({x: fCoords[[pp]], y: fCoords[pp + 1]});
					}

					//Создаем курсор после сортировки, чтобы он указывал на начальный элемент
					cursorsList.push(new CASCursor(featuresGeomArr));

					//Тип, содержащийся в этой feature
					featureType = '';
					var lt = ftrData.get('labelType').split('/');
					if(lt.length>0)
						featureType = lt[1];
					//goog.isDef(ftrData[lay.typeField]) ? ftrData[lay.typeField] : "";
					//счетчик, чтобы посчитать количество элементов, которые попали в итоговый массив
					//мнимые могут быть, могут не быть, поэтому проверку изначально не делаю на кол-во элементов
					var counter = 0;
					//сортируем
					featuresGeomArr.sort(function (a, b) {
						return a.x - b.x;
					});
					// собираем данные
					for (j = 0; j < featuresGeomArr.length; j ++) {
						xVal = featuresGeomArr[j].x;
						//Ограничиваем данные по заданным minX и maxX
						if (commonX.indexOf(xVal) < 0 && xVal >= 0 && xVal <= maxX - minX) {
							commonX.push(xVal);
							++counter;
						}
					}
					//Добавляем к строке типов очередной тип
					stringOfTypes += "<th>" + featureType + "</th>";
				}
			}
			//Перед закрытием заголовка таблицы добавляем строку с типами
			result += stringOfTypes;
			result += "</tr></thead><tbody>";

			function sortNumber(a,b) {
				return a - b;
			}
			commonX = commonX.sort(sortNumber);

			// теперь по X генерируем общую табличку
			var k,s_id, i,xi,yi,curi;
			var kk = 0;
			var prev_k = NaN;
			for (;kk< commonX.length;kk++){
				k = commonX[kk];
				prev_k = k;
				if (k < 0)
					continue;
				// по курсорам пройти все данные и собрать табличку
				//В массив буду сохранять все значения Y для одинаковых X
				var tmpRowsTable = [];
				var maxRowsLength = 0;
				for (i=0; i<cursorsList.length; i++){
					//Для каждого курсора заводим массив
					tmpRowsTable.push([]);
					curi = cursorsList[i];
					if (curi.beforeFirst())
						curi.moveNext();

					if (!curi.afterLast()){
						xi = curi.current[CASUtil.xField];
						//Если в текущем массиве координаты <0, перебираем их до значений >=0
						if (!isNaN(minX) && (xi < 0)){
							while (xi < 0){
								curi.moveNext();
								if (!curi.afterLast())
									xi = curi.current[CASUtil.xField];
								else
									xi = NaN;
							}
						}
						//Если значение совпадает - заполняем массив значениями Y
						if (xi == k){
							var sameXCol = 0;
							while (xi == k){
								//Увеличиваем число Y с одинаковыми X
								sameXCol++;
								var yValue = curi.current[CASUtil.yField];
								//В массив, который находится в текущем подмассиве добавляем новое значение Y
								tmpRowsTable[i].push(yValue);
								curi.moveNext();
								if (!curi.afterLast())
									xi = curi.current[CASUtil.xField];
								else
									xi = NaN;
							}
							if (sameXCol>maxRowsLength)
								maxRowsLength = sameXCol;
						}
					}
					//Передвигаем курсор до тех пор пока текущее значение X не станет > текущего k либо пока не выйдем за пределы
					//Это нужно чтобы если у текущего курсора нет такого значения X, он передвинулся к следующему по порядку
					while (xi < k && !curi.afterLast())
					{
						curi.moveNext();
						if(curi && goog.isDef(curi.current))
							xi = curi.current[CASUtil.xField];
					}
				}

				//Теперь пробегаемся по массиву, чтобы построить все ряды с одинаковыми X но разными Y
				for (var ii=0; ii<maxRowsLength; ii++){
					result += "<tr>";
					if (addKmField){
						var curKmText = parseFloat((k + minX).toFixed(3));
						//Если в подписи целое число - не выводить ".000"
						curKmText = curKmText.toString();
						result += "<td>" + curKmText.replace(".",",") + "</td>";
					}
					if (showXCoordinate){
						result += "<td>" + parseFloat(k.toFixed(3)).toString().replace(".",",") + "</td>";
					}
					//Добавляем ячейки данных
					for (var j=0; j<tmpRowsTable.length; j++){
						var tmpArr = tmpRowsTable[j];
						//Если в массиве есть значения на этом уровне - заполняем, иначе добавляем пустую ячейку
						if (tmpArr && tmpArr.length>=ii && !isNaN(tmpArr[ii])){
							//Добавляем ячейку с данными
							var yVal = tmpArr[ii];
							result += "<td>" + parseFloat(yVal.toFixed(3)).toString().replace(".",",") + "</td>";
						}
						else{
							//Добавляем пустую ячейку
							result += "<td></td>";
						}
					}
					result += "</tr>";
				}
			}
			result += "</tbody></table>";
			if (outer_table){
				result += CASUtil.END_DIVIDER;
				result += CASUtil.DIVIDER;
			}
		}

		//обрабатываем barLayersArr
		if(goog.isDef(barLayer))
			for (var i in selectedObjects){
				result += CASUtil.BEGIN_DIVIDER;
				result += CASUtil.convertBarDataToTable(layer, selectedObjects[i], addKmField, minX, maxX);
				result += CASUtil.END_DIVIDER;
				result += CASUtil.DIVIDER;
			}

		result += "</body></html>";
		return result;
	}
	catch(ex){

	}
	return '';
};

/**
 * @private
 * Преобразование в строку с табличной разметкой HTML переданных данных из CASLayer (выводится начало и конец участка)
 *
 * @param ftrData преобразуемые данные (объект с геометрией и подписью)
 * @param addKm Флаг добавления километровой отметки
 * @return {string} Строка с таблицей данных в формате HTML
 *
 */
CASUtil.convertBarDataToTable = function(casLay, ftrData, addKm, minX, maxX){
	var showX = false;
	if (goog.isDef(casLay) && goog.isDef(ftrData) && goog.isDef(ftrData.obj) && goog.isDef(ftrData.obj.geo) && !isNaN(minX) && !isNaN(maxX) && (addKm || showX)){
		var count_col = 0;
		count_col += (addKm) ? 2:0;
		count_col += (showX) ? 2:0;

		var laySourceName = casLay.sourceDescr!="" ? casLay.sourceDescr : " [БЕЗ ИМЕНИ] ";
		var ftrLabel = goog.isDef(ftrData.obj.label) && ftrData.obj.label!='' ? ftrData.obj.label : '';
		var result = "<table><thead><tr><th colspan='"+count_col+"'>" +
					laySourceName + "\n " + ftrLabel + "</th></tr><tr>";
		if (addKm){
			result += "<th>от [км.]</th>";
			result += "<th>до [км.]</th>";
		}
		if (showX){
			result += "<th>от</th>";
			result += "<th>до</th>";
		}
		result += "</tr></thead>";
		// заголовок завершен
		result += "<tbody>";
		var geo = ftrData.obj.geo;// as Geometry;
		var geoExtent = geo.getExtent();
		//Просто выводим границы, причем если они выходят за минимальную - обрезаем по минимуму
		var minValue = geoExtent[0] < 0 ? minX : geoExtent[0] + minX;
		var maxValue = geoExtent[2] >= maxX ? maxX : geoExtent[2] + minX;
		//Формируем результат
		result += "<tr>";
		if (addKm){
			result += "<td>" + minValue + "</td>";
			result += "<td>" + maxValue + "</td>";
		}
		if (showX){
			result += "<td>" + minValue + "</td>";
			result += "<td>" + maxValue + "</td>";
		}
		result += "</tr>";
		result += "</tbody></table>";
		return result;
	}
	return '';
};

//Функция выбирает из списка слоев те, в которых все геометрии являются участками и возвращает массив таких слоев
CASUtil.getBarLayer = function(layer, selectedObjects){
	if (selectedObjects.length>0){
		var layIsBar = true;
		//Каждая отдельная геометрия слоя с участками должна быть участком (т.е. ее bounds.top и bounds.bottom должны совпадать)
		for(var i in selectedObjects){
			var ftrObj = selectedObjects[i];
			if (!goog.isDef(ftrObj.obj) || !goog.isDef(ftrObj.obj.geo) || ol.extent.getHeight(ftrObj.obj.geo.getExtent()!=0)){
				layIsBar = false;
				break; //если нашли хотя бы 1 геометрию с ненулевой высотой - обрабатываем следующий слой, текущий слой уже не интервальный
			}

		}
		//Если дошли до этого места - все графики в слое являются интервальными, добавляем слой в интервальный
		if(layIsBar)
			return layer;
	}
	return undefined;
};

//эмуляция курсора
CASCursor = function(array){
	this.array = array;
	this.index = -1;
	this.current = {};//{x:array[0],y:array[1]};
};
CASCursor.prototype.moveNext = function(){
	++this.index;
	var i = this.index;
	if(this.index<this.array.length)
		this.current = this.array[i];//{x:this.array[i],y:this.array[i+1]};
};

CASCursor.prototype.afterLast = function(){
	return this.index>this.array.length-1;
};


CASCursor.prototype.beforeFirst = function(){
	return this.index<0;
};


//Глобальный объект
ExportUtil = {};

//константы
ExportUtil.GPX = gis_exportutil_1;
ExportUtil.KML = gis_exportutil_2;
ExportUtil.RESULT_TITLE_TEXT = gis_exportutil_3;
ExportUtil.RESULT_GPX_TEXT = gis_exportutil_4;

ExportUtil.RESULT_KML_TEXT = gis_exportutil_5;

ExportUtil.NO_GEO = gis_exportutil_6;
ExportUtil.INCORRECT_GEO = gis_exportutil_7;

ExportUtil.EXPORT_EXCEL_ERROR = gis_exportutil_8;
ExportUtil.EXPORT_EXCEL_EMPTY_DATA_ERROR = gis_exportutil_9;
ExportUtil.EXPORT_WRL_ERROR = gis_exportutil_10;
ExportUtil.EXPORT_IMG_ERROR = gis_exportutil_11;
ExportUtil.PACK_IMG_ERROR = gis_exportutil_12;
ExportUtil.PACK_FILES_AND_DIRS_ERROR = gis_exportutil_13;

/**
 * Общие функции для экспорта
 * */
//Формирование запроса для вызова UTEService
ExportUtil.makeUTETaskServiceDataReqParams = function makeUTETaskServiceDataReqParams(templateName, inputData) {
    return {
        templateName: templateName,
        input: inputData
    };
};
//Формирование запроса для вызова PackIMG
ExportUtil.makePackIMGServiceDataReqParams = function makePackIMGServiceDataReqParams(fileName, imgRelatePath) {
    return {
        outFile: fileName,
        inList: imgRelatePath
    };
};
//Формирование запроса для вызова PackFiles (упаковка файлов и директорий в один архив)
//Пример строки файлов для выгрузки: "LIB\МГ Миннибаево-Казань\Переезды через газопровод.pdf@LIB\МГ Миннибаево-Казань\Приказы на присвоении клейма сварщикам, списки сварщиков.pdf"
ExportUtil.makePackFilesServiceDataReqParams = function makePackFilesServiceDataReqParams(inFilesOrDirs, outFile) {
    return {
        inFilesOrDirs: inFilesOrDirs,
        outFile: outFile
    };
};
//Получение адреса сайта без html-страницы, т.е. 'http://site_address/'
ExportUtil.getCurrentUrl = function getCurrentUrl() {
    var curUrl = getURL(); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (curUrl.lastIndexOf("#") != -1) curUrl = curUrl.substr(0, curUrl.lastIndexOf("#"));
    //Убираем последнюю ссылку на html-страницу, нам нужен путь, оканчивающийся на /
    curUrl = curUrl.substr(0, curUrl.lastIndexOf("/") + 1);
    return curUrl;
};

/**
 * Функции для экспорта в GPX или KML
 * */
ExportUtil.exportFinalObjectsFromXML = function(objs /*XMLList, но тут наверняка будет array*/, type /*String = ExportUtil.GPX*/) {
    if (objs.length > 0){
        // если получили идентификаторы, то выгружаем их
        var gpx = null;
        var kml = null;
        var boundsObj = {};
        boundsObj.minX = Number.POSITIVE_INFINITY;
        boundsObj.minY = Number.POSITIVE_INFINITY;
        boundsObj.maxX = Number.NEGATIVE_INFINITY;
        boundsObj.maxY = Number.NEGATIVE_INFINITY;

        var today = new Date();
        //Формат даты - 'YYYY-MM-DDT00:00:00Z'
        function pad(number) {
            if ( number < 10 ) {
                return '0' + number;
            }
            return number;
        }
        //Получаем собственно время в нужном формате
        //upd06.06.18 решено выставлять дату всегда одну дату 10:00:00
        var time = today.getUTCFullYear() + '-' + pad( today.getUTCMonth() + 1 ) + '-' + pad( today.getUTCDate() )
            + 'T10:00:00'
            /*+ '.' + (today.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5)*/ /*раскомментировать, если нужно уточнение до 'YYYY-MM-DDT00:00:00.000Z'*/
            + 'Z';

        var ii;
        switch(type)
        {
            case ExportUtil.GPX:
            {
                var finalGpx = '<gpx xmlns="http://www.topografix.com/GPX/1/1" creator="MapSource 6.11.6" version="1.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">';
                for (ii = 0; ii < objs.length; ii++)
                {
                    var xmlObj/*:XML*/ = objs[ii];
                    var wktStr = xmlObj.hasOwnProperty('WKT') ? xmlObj.WKT : "";
                    var format = new ol.format.WKT();
                    try{
                        var geom = format.readGeometry(wktStr);
                    }catch (e) {
                        format = new map.format.WKT({dimension: 3});
                        geom = format.readGeometry(wktStr);
                    }
                            /*'POLYGON((10.689697265625 -25.0927734375, 34.595947265625 ' +
                            '-20.1708984375, 38.814697265625 -35.6396484375, 13.502197265625 ' +
                            '-39.1552734375, 10.689697265625 -25.0927734375))');*/
                    if(!gpx) gpx = "";
                        /*gpx = '<gpx xmlns="http://www.topografix.com/GPX/1/1" creator="MapSource 6.11.6" version="1.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd">';*/
                    if (geom){
                        var objName = xmlObj.hasOwnProperty('LABEL') ? xmlObj.LABEL : "";
                        var gType = geom.getType();

                        //Пересчитываем общую рамку
                        var curExtent = geom.getExtent(); //[minx, miny, maxx, maxy]
                        if (curExtent && curExtent.length==4) {
                            boundsObj.minX = Math.min(curExtent[0], boundsObj.minX);
                            boundsObj.minY = Math.min(curExtent[1], boundsObj.minY);
                            boundsObj.maxX = Math.max(curExtent[2], boundsObj.maxX);
                            boundsObj.maxY = Math.max(curExtent[3], boundsObj.maxY);
                        }
                        var i,g;
                        switch (gType){
                            // точечный
                            case "Point":
                                gpx += ExportUtil.addPointGPX(geom, objName, time);
                                break;
                            case "MultiPoint":
                                var points = geom.getPoints();
                                for (i = 0; i<points.length; i++) {
                                    g = points[i];
                                    gpx += ExportUtil.addPointGPX(g, objName+"_"+i.toString(), time);
                                }
                                break;
                            // линейный
                            case "LineString":
                                gpx += ExportUtil.addLineGPX(geom, objName, time);
                                break;
                            case "MultiLineString":
                                var lineStrings = geom.getLineStrings();
                                for (i = 0; i<lineStrings.length; i++) {
                                    g = lineStrings[i];
                                    gpx += ExportUtil.addLineGPX(g, objName+"_"+i.toString(), time);
                                }
                                break;
                            case "Polygon":
                            case "MultiPolygon":
                                // площадной
                                var pix = ol.extent.getCenter(geom.getExtent());
                                var pp = new ol.geom.Point(pix);
                                gpx += ExportUtil.addPointGPX(pp, objName, time);
                                break;
                        }
                    }
                    else{
                        App.errorReport(ExportUtil.INCORRECT_GEO, ExportUtil.INCORRECT_GEO, undefined, {filename:gis_filename_594, functionname:'gis_filename_594_1'});
                    }
                }
                var meta = '<metadata><link href="http://www.garmin.com"><text>Garmin International</text></link><time>'+time+'</time>' +
                            '<bounds maxlat="'+boundsObj.maxY+'" maxlon="'+boundsObj.maxX+'" minlat="'+boundsObj.minY+'" minlon="'+boundsObj.minX+'"/></metadata>';
                /*gpx += meta + '</gpx>';
                var finalContext = '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>' + gpx;*/
                finalGpx += meta + gpx + '</gpx>';
                var finalContext = '<?xml version="1.0" encoding="UTF-8" standalone="no" ?>' + finalGpx;
                return finalContext;
            }
            case ExportUtil.KML:
            {
                kml = '<kml xmlns="http://www.opengis.net/kml/2.2" xmlns:gx="http://www.google.com/kml/ext/2.2" xmlns:kml="http://www.opengis.net/kml/2.2" xmlns:atom="http://www.w3.org/2005/Atom">';
                //FF00008B - dark red для kml файла. Почему-то не RGB формат, а BGR
                var document = '<Document><Style id="lineStyle"><LineStyle><color>FF00008B</color><width>4</width></LineStyle></Style>';
                var addKml = "";
                for (ii = 0; ii < objs.length; ii++){
                    var xmlObj/*:XML*/ = objs[ii];
                    var wktStr = xmlObj.hasOwnProperty('WKT') ? xmlObj.WKT : "";
                    var format = new ol.format.WKT();
                    try{
                        var geom = format.readGeometry(wktStr);
                    }catch (e) {
                        format = new map.format.WKT({dimension: 3});
                        geom = format.readGeometry(wktStr);
                    }
                    if (geom){
                        var objName = xmlObj.hasOwnProperty('LABEL') ? xmlObj.LABEL : "";
                        var gType = geom.getType();
                        var i,g;
                        switch (gType) {
                            // точечный
                            case "Point":
                                document += ExportUtil.addPointKML(geom, objName);
                                break;
                            case "MultiPoint":
                                var points = geom.getPoints();
                                for (i = 0; i<points.length; i++) {
                                    g = points[i];
                                    document += ExportUtil.addPointKML(g, objName+"_"+i.toString());
                                }
                                break;
                            // линейный
                            case "LineString":
                                document += ExportUtil.addLineKML(geom, objName);
                                break;
                            case "MultiLineString":
                                var lineStrings = geom.getLineStrings();
                                for (i = 0; i<lineStrings.length; i++) {
                                    g = lineStrings[i];
                                    document += ExportUtil.addLineKML(g, objName+"_"+i.toString());
                                }
                                break;
                            case "Polygon":
                            case "MultiPolygon":
                                // площадной
                                var pix = ol.extent.getCenter(geom.getExtent());
                                var pp = new ol.geom.Point(pix);
                                document += ExportUtil.addPointKML(pp, objName);
                                break;
                        }
                    }
                    else{
                        App.errorReport(ExportUtil.INCORRECT_GEO, ExportUtil.INCORRECT_GEO, undefined, {filename:gis_filename_594, functionname:'gis_filename_594_2'});
                    }
                }
                //Закрываем тег документа
                kml += document + '</Document>';
                //Добавляем остальные элементы, которые идут в самом kml
                kml += addKml + '</kml>';

                var finalContextKml = '<?xml version="1.0" encoding="UTF-8" ?>' + kml;
                return finalContextKml;
            }
            default: break;
        }
    }
    else
    {
        App.errorReport(ExportUtil.NO_GEO, ExportUtil.NO_GEO, undefined, {filename:gis_filename_594, functionname:'gis_filename_594_3'});
    }
    return "";
};

//Получение строки из XML
ExportUtil.xmlToString = function(xmlData) { // this functions waits jQuery XML
    var xmlString = undefined;

    if (window.ActiveXObject){
        xmlString = xmlData[0].xml;
    }

    if (xmlString === undefined)
    {
        var oSerializer = new XMLSerializer();
        xmlString = oSerializer.serializeToString(xmlData[0]);
    }
    if (xmlString === undefined)
    {
        xmlString = xmlData[0].outerHTML;
        /*var oSerializer = new XMLSerializer();
         xmlString = oSerializer.serializeToString(xmlData[0]);*/
    }
    return xmlString;

    var xmlString = undefined;
    if (window && window.ActiveXObject){
        /*xmlString = xmlData[0].xml;*/
        xmlString = xmlData[0].outerHTML;
    }
    if (xmlString === undefined)
    {
        xmlString = xmlData[0].outerHTML;
        /*var oSerializer = new XMLSerializer();
        xmlString = oSerializer.serializeToString(xmlData[0]);*/
    }
    return xmlString;
};

//Добавление очередной точки в xml для GPX
ExportUtil.addPointGPX = function(geoObj/*ol.Geom.Point*/, name/*:String*/, time/*:String*/, res/*:XML*/, boundsObj/*:Object*/) {
    if (geoObj == null) return "";
    var p = {x:geoObj.flatCoordinates[0], y:geoObj.flatCoordinates[1]};
    if(App.projection === GeoUtil.PROJS.Pulkovo42)
        p = GeoUtil.P42WGS(p["y"], p["x"]);
    var res = '<wpt lat="' + p.y + '" lon="' + p.x + '"><time>' + time + '</time><name>' + name + '</name><sym>Flag, Blue</sym></wpt>';
    return res;
};

//Добавление очередной линии в xml для GPX
ExportUtil.addLineGPX = function(geoObj/*ol.geom.LineString*/, name/*:String*/, time/*:String*/, res/*:XML*/, boundsObj/*:Object*/) {
    if (geoObj == null)
        return "";
    var trk = '<trk><name>' + name + '</name>' +
    '<extensions><gpxx:TrackExtension xmlns:gpxx="http://www.garmin.com/xmlschemas/GpxExtensions/v3" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.garmin.com/xmlschemas/GpxExtensions/v3 http://www.garmin.com/xmlschemas/GpxExtensions/v3/GpxExtensionsv3.xsd">' +
    '<gpxx:DisplayColor>DarkRed</gpxx:DisplayColor></gpxx:TrackExtension></extensions>';
    var trkP = '<trkseg>';
    for (var i = 0; i< geoObj.flatCoordinates.length; i+=geoObj.stride)
    {
        var p = {x:geoObj.flatCoordinates[i], y:geoObj.flatCoordinates[i+1]};
        if(App.projection === GeoUtil.PROJS.Pulkovo42)
            p = GeoUtil.P42WGS(p["y"], p["x"]);
        trkP += '<trkpt lat="' + p.y + '" lon="' + p.x + '"><time>' + time + '</time></trkpt>';
    }
    trkP += '</trkseg>';
    trk += trkP + '</trk>';
    return trk;
};

//Добавление очередной точки в xml для KML
ExportUtil.addPointKML = function(geoObj/*ol.Geom.Point*/, name/*:String*/, res/*:XML*/) {
    if (geoObj == null)
        return "";
    //Проекция геоданных из БД
    var dataProjection = App.projection;
    var p = {x:geoObj.flatCoordinates[0], y:geoObj.flatCoordinates[1]};
    if(dataProjection === GeoUtil.PROJS.Pulkovo42){
        p = GeoUtil.P42WGS(p["y"], p["x"]);
    }
    var placemark = '<Placemark><name>' + name + '</name><description>' + name + '</description><Point><coordinates>' + p.x + ',' + p.y + ',0</coordinates></Point></Placemark>';
    return placemark;
};

//Добавление очередной линии в xml для KML
ExportUtil.addLineKML = function(geoObj/*ol.geom.LineString*/, name/*:String*/, res/*:XML*/) {
    if (geoObj == null)
        return "";
    var placemark = '<Placemark><name>' + name + '</name><description>' + name + '</description>';
    var coords = [];
    var lineString = '<LineString><tessellate>1</tessellate>';
    for (var i = 0; i < geoObj.flatCoordinates.length; i+=geoObj.stride)
    {
        var p = {x:geoObj.flatCoordinates[i], y:geoObj.flatCoordinates[i+1]};
        if(App.projection === GeoUtil.PROJS.Pulkovo42)
            p = GeoUtil.P42WGS(p["y"], p["x"]);
        coords.push(p.x);//longitude долгота
        coords.push(p.y);//latitude широта
        coords.push(0);//altitude  высота
    }
    var coordXml = '<coordinates>' + coords.toString() + '</coordinates>';
    lineString += coordXml + '</LineString>';
    var styleXml = '<styleUrl>#lineStyle</styleUrl>';
    placemark += styleXml + lineString + '</Placemark>';
    return placemark;
};

/**
 * Функции для экспорта в Excel
 * */
//Переменная хранит последнее имя генерируемого файла
ExportUtil.exportExcelFileName = "";


/**
 * Экспорт в Excel пикетаза из административной задачи
 * @param dataArray
 * @param fileName
 * @param excelTemplate
 * @param requestSource
 */
ExportUtil.exportAdmPicketingToExcel = function exportFinalXML(dataArray, excelTemplate, requestSource) {
	var alertForm, requestParams;
	if (dataArray !== undefined && dataArray.length>0) {
        /* Групповой экспорт:
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\8135B2A5-1AF8-805E-E727-2D164400319B.xls" template="server_export" data="&lt;root>&#xA;  &lt;data LINE_ID_FILTER=&quot;1300347,1300064,1300066,1300067,1300069,1300348,1300070,1300350,1300071,1300079,1300080,1300029,1300376,1300351,1300032,1300341,1300035,1300081,1300377,1300082,1300084,1300352,1300085,1300086,1300378,1300088,1300089,1300353,1300342,1300092,1300036,1300037,1300094,1300096,1300097,1300098,1300354,1300379,1300099,1300100,1300102,1300104,1300380,1300381,1300382,1300106,1300028,1300107,1300355,1300109,1300111,1300113,1300356,1300115,1300436,1300357,1300117,1300023,1300119,1300384,1300385,1300120,1300386,1300387,1300388,1300063,1300358,1300389,1300359,1300123,1300344,1300360,1300345,1300441,1300125,1300126,1300128,1300439,1300130,1300132,1300134,1300440,1300034,1300031,1300136,1300138,1300390,1300039,1300139,1300361,1300391,1300141,1300033,1300143,1300145,1300392,1300146,1300026,1300393,1300362,1300030,1300147,1300394,1300395,1300363,1300396,1300149,1300397,1300151,1300398,1300153,1300399,1300364,1300365,1300154,1300156,1300400,1300157,1300366,1300402,1300159,1300060,1300061,1300403,1300162,1300404,1300164,1300167,1300169,1300171,1300405,1300172,1300173,1300174,1300175,1300176,1300178,1300406,1300179,1300181,1300183,1300187,1300199,1300221,1300233,1300237,1300059,1300253,1300257,1300261,1300265,1300277,1300279,1300291,1300370,1300293,1300407,1300018,1300019,1300447,1300375,1300408,1300409,1300410,1300411,1300295,1300412,1300413,1300371,1300414,1300297,1300415,1300299,1300416,1300003,1300004,1300005,1300020,1300027,1300300,1300417,1300302,1300303,1300418,1300419,1300420,1300304,1300421,1300422,1300423,1300424,1300425,1300426,1300346,1300305,1300306,1300434,1300435,1300006,1300007,1300427,1300307,1300308,1300309,1300312,1300313,1300314,1300315,1300428,1300316,1300429,1300317,1300318,1300319,1300320,1300321,1300430,1300431,1300322,1300323,1300324,1300373,1300432,1300325,1300000,1300327,1300433,1300329,1300330,1300331,1300332,1300012,1300017,1300013,1300016,1300014,1300015,1300025,1300024,1300334,1300001,1300021,1300002,1300022,1300008,1300011,1300009,1300010,0&quot; ROUTE_TYPE_FILTER=&quot;'ROUTE_TYPE_12','ROUTE_TYPE_10','ROUTE_TYPE_03','ROUTE_TYPE_04','ROUTE_TYPE_11','ROUTE_TYPE_02','ROUTE_TYPE_01','UNKNOWN'&quot; OLD_LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot; FILTER=&quot;8=8 AND ID IN (1301709,1300249)&quot; LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_GRID.XML#PODS_ROUTE"/>
         * */
        /* Экспорт одного объекта
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\B6CC9B4C-A9EF-8378-02B1-2D1A50BB73CF.xls" template="PODS_ROUTE" data="&lt;root>&#xA;  &lt;data LINE_ID=&quot;1300000&quot; OPERATING_STATUS_GCL=&quot;ACTIVE&quot; SRV_DISTRICT_ID=&quot;13006&quot; ID=&quot;1301709&quot; TYPE_LBL=&quot;Магистральный&quot; ROUTE_TYPE_CL=&quot;ROUTE_TYPE_10&quot; mx_internal_uid=&quot;F6052EAE-5832-1190-E3E5-2D159C634C63&quot; SYS_OBJ_ID=&quot;1301709&quot; RWN=&quot;1&quot; DESCRIPTION=&quot;СРТО-Урал&quot; STATION_BEG=&quot;1690&quot; FILTER=&quot;ID=1301709&quot; STATION_END=&quot;1840&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_EXPORT.xml#PODS_ROUTE"/>
         * */
		//генерируем UID для текущей выгрузки
		var currentUID = App.generateUUID();
		var itemXmlEscaped = '&lt;root>';
		for(var i = 0;i < dataArray.length; i++){
			itemXmlEscaped += ExportUtil.Obj2StrXML(dataArray[i], 'data');
		}
		itemXmlEscaped += '&lt;/root>';

		//формируем  шаблон для задачи AA
		var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
		ExportUtil.exportExcelFileName = resFileName;
		//Формируем команду на выполнение сервису
		var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
		if (requestSource=="export") {
			inputData = '<input file_name="'+resFileName+'" template="export" data="'+itemXmlEscaped+'" keep_files="true"/>';
		}
		alertForm = new AlertForm();
		alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
		//Добавляем слушатель закрытия формы
		$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
			$("body").off(CloseEvent.CLOSE);
			if (evt && evt.detail == 1) {
				var processExportForm = new ProcessExportExcelForm();
				processExportForm.inputData = inputData;
				//Собственно создаем форму
				processExportForm.build();
			}
		});
	}
	else{
		App.confirmDialog(ExportUtil.EXPORT_EXCEL_EMPTY_DATA_ERROR);
	}
};

ExportUtil.exportToExcel = function exportFinalXML(dataArray, fileName, excelTemplate, requestSource, topFilter, extendedExport) {
    var alertForm, requestParams;

    if (dataArray && dataArray.length>0) {
        /* Групповой экспорт:
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\8135B2A5-1AF8-805E-E727-2D164400319B.xls" template="server_export" data="&lt;root>&#xA;  &lt;data LINE_ID_FILTER=&quot;1300347,1300064,1300066,1300067,1300069,1300348,1300070,1300350,1300071,1300079,1300080,1300029,1300376,1300351,1300032,1300341,1300035,1300081,1300377,1300082,1300084,1300352,1300085,1300086,1300378,1300088,1300089,1300353,1300342,1300092,1300036,1300037,1300094,1300096,1300097,1300098,1300354,1300379,1300099,1300100,1300102,1300104,1300380,1300381,1300382,1300106,1300028,1300107,1300355,1300109,1300111,1300113,1300356,1300115,1300436,1300357,1300117,1300023,1300119,1300384,1300385,1300120,1300386,1300387,1300388,1300063,1300358,1300389,1300359,1300123,1300344,1300360,1300345,1300441,1300125,1300126,1300128,1300439,1300130,1300132,1300134,1300440,1300034,1300031,1300136,1300138,1300390,1300039,1300139,1300361,1300391,1300141,1300033,1300143,1300145,1300392,1300146,1300026,1300393,1300362,1300030,1300147,1300394,1300395,1300363,1300396,1300149,1300397,1300151,1300398,1300153,1300399,1300364,1300365,1300154,1300156,1300400,1300157,1300366,1300402,1300159,1300060,1300061,1300403,1300162,1300404,1300164,1300167,1300169,1300171,1300405,1300172,1300173,1300174,1300175,1300176,1300178,1300406,1300179,1300181,1300183,1300187,1300199,1300221,1300233,1300237,1300059,1300253,1300257,1300261,1300265,1300277,1300279,1300291,1300370,1300293,1300407,1300018,1300019,1300447,1300375,1300408,1300409,1300410,1300411,1300295,1300412,1300413,1300371,1300414,1300297,1300415,1300299,1300416,1300003,1300004,1300005,1300020,1300027,1300300,1300417,1300302,1300303,1300418,1300419,1300420,1300304,1300421,1300422,1300423,1300424,1300425,1300426,1300346,1300305,1300306,1300434,1300435,1300006,1300007,1300427,1300307,1300308,1300309,1300312,1300313,1300314,1300315,1300428,1300316,1300429,1300317,1300318,1300319,1300320,1300321,1300430,1300431,1300322,1300323,1300324,1300373,1300432,1300325,1300000,1300327,1300433,1300329,1300330,1300331,1300332,1300012,1300017,1300013,1300016,1300014,1300015,1300025,1300024,1300334,1300001,1300021,1300002,1300022,1300008,1300011,1300009,1300010,0&quot; ROUTE_TYPE_FILTER=&quot;'ROUTE_TYPE_12','ROUTE_TYPE_10','ROUTE_TYPE_03','ROUTE_TYPE_04','ROUTE_TYPE_11','ROUTE_TYPE_02','ROUTE_TYPE_01','UNKNOWN'&quot; OLD_LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot; FILTER=&quot;8=8 AND ID IN (1301709,1300249)&quot; LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_GRID.XML#PODS_ROUTE"/>
         * */
        /* Экспорт одного объекта
        * templateName DATA_LAY_Exp.xml
        * input <input template="PODS_ROUTE" ext_data_id="PODS_EXPORT.xml#PODS_ROUTE" data="&lt;root>&#xA;  &lt;data LINE_ID=&quot;1300000&quot; OPERATING_STATUS_GCL=&quot;ACTIVE&quot; SRV_DISTRICT_ID=&quot;13006&quot; ID=&quot;1301709&quot; TYPE_LBL=&quot;Магистральный&quot; ROUTE_TYPE_CL=&quot;ROUTE_TYPE_10&quot; mx_internal_uid=&quot;F6052EAE-5832-1190-E3E5-2D159C634C63&quot; SYS_OBJ_ID=&quot;1301709&quot; RWN=&quot;1&quot; DESCRIPTION=&quot;СРТО-Урал&quot; STATION_BEG=&quot;1690&quot; FILTER=&quot;ID=1301709&quot; STATION_END=&quot;1840&quot;/>&#xA;&lt;/root>" keep_files="true" file_name="Public\Data\TAB\B6CC9B4C-A9EF-8378-02B1-2D1A50BB73CF.xls" />
        * */
        //генерируем UID для текущей выгрузки
        var currentUID = App.generateUUID();
        var itemXmlEscaped = '&lt;root>';
        var filterStr = "ID IN (";
        var propertiesStr = "";
        for (var i = 0; i < dataArray.length; i++) {
            if(!dataArray[i]["ID"] && requestSource !== "export")
                continue;
            filterStr += dataArray[i]["ID"];
            //К последнему ID сзади запятую не добавляем
            if (i < dataArray.length-1) {
                filterStr += ",";
            }
            //Добавляем остальные атрибуты только при экспорте одиночной записи
            if (excelTemplate !== "server_export") {
                if (requestSource === "export") {
                    //Просто выгрузка строки с русским текстом атрибутов
                    $.each(dataArray[i], function (index, value) {
                        var propValEscaped = value.replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/&/g, '&amp;');
                        propertiesStr += index + '=&quot;' + propValEscaped + '&quot; ';
                    });
                } else {
                    $.each(dataArray[i], function (index, value) {
                        var propValEscaped = value.replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/&/g, '&amp;');
                        propertiesStr += index.toUpperCase() + '=&quot;' + propValEscaped + '&quot; ';
                    });
                    //Добавляем особые атрибуты которые хз зачем нужны но без них не работает
                    propertiesStr += 'SYS_OBJ_ID=&quot;' + dataArray[i]["ID"] + '&quot; ';
                    //propertiesStr += 'mx_internal_uid=&quot;4F019BC1-3901-E875-1249-0C5760BB5B9E&quot ';
                }
            }
        }
        filterStr += ")";
        if(filterStr === 'ID IN ()')// если не нашли ни одного ID, то не экспортируем в excel
            return;
        //Если экспортируем один объект - меняем FILTER="ID IN ()" на FILTER="ID=value"
        if (excelTemplate!="server_export" && !extendedExport)
            filterStr = "ID="+dataArray[0]["ID"];
        if (requestSource=="export") {
            itemXmlEscaped += '&lt;data '+propertiesStr+'/>';
        } else {
            if(extendedExport)propertiesStr = '';// если расширенный экспорт, то не передает доп. атрибуты, только выбранные идентификаторы в фильтре
            itemXmlEscaped += '&lt;data FILTER=&quot;'+filterStr+'&quot; '+propertiesStr+'/>'; //атрибут filter обязательно должен быть в верхнем регистре!!!
        }
        itemXmlEscaped += '&lt;/root>';

        //формируем  шаблон для задачи AA
        var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
        ExportUtil.exportExcelFileName = resFileName;
        //Формируем команду на выполнение сервису
        var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
        if (requestSource=="export") {
            inputData = '<input file_name="'+resFileName+'" template="export" data="'+itemXmlEscaped+'" keep_files="true"/>';
        }

        alertForm = new AlertForm();
        alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
        //Добавляем слушатель закрытия формы
        $("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
            $("body").off(CloseEvent.CLOSE);
            if (evt && evt.detail == 1) {
                var processExportForm = new ProcessExportExcelForm();
                processExportForm.inputData = inputData;
                //Собственно создаем форму
                processExportForm.build();
            }
        });


    }
    else{
        if(topFilter !== undefined || extendedExport !== undefined){
            //генерируем UID для текущей выгрузки
            var currentUID = App.generateUUID();
            var item = $('<root></root>');
            var child = ExportUtil.Obj2XML(topFilter, 'data');
            child.appendTo(item);
            var itemStr = ExportUtil.xmlToString(item);
            //переводим атрибуты в верхний регистр, хардкод
            itemStr = itemStr.replace('lpu_access_filter','LPU_ACCESS_FILTER');
            itemStr = itemStr.replace('ili_insp_filter','ILI_INSP_FILTER');
            itemStr = itemStr.replace('route_type_filter','ROUTE_TYPE_FILTER');
            itemStr = itemStr.replace('line_id_filter','LINE_ID_FILTER');

            var itemXmlEscaped = itemStr.xmlEscape();
            //формируем  шаблон для задачи AA
            var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
            ExportUtil.exportExcelFileName = resFileName;
            //Формируем команду на выполнение сервису
            var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
            //Добавляем слушатель закрытия формы
            alertForm = new AlertForm();
            alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
            $("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
                $("body").off(CloseEvent.CLOSE);
                if (evt && evt.detail == 1) {
                    var processExportForm = new ProcessExportExcelForm();
                    processExportForm.inputData = inputData;
                    //Собственно создаем форму
                    processExportForm.build();
                }
            });
        }
    }
};

ExportUtil.exportShurfToExcel = function (dataArray, fileName, excelTemplate, requestSource, topFilter) {
    var alertForm;
    if (dataArray && dataArray.length>0) {
         //генерируем UID для текущей выгрузки
        var currentUID = App.generateUUID();
        var itemXmlEscaped = '&lt;root>';
        var propertiesStr = "";
        var ids = [];
        for (var i = 0; i < dataArray.length; i++) {
            //добавляем только идентификаторы выбранных объектов
            ids.push(dataArray[i]["ID"]);
        }
        propertiesStr += 'SYS_OBJ_ID=&quot;' + ids.join() + '&quot; ';
        itemXmlEscaped += '&lt;data '+propertiesStr+'/>&lt;/root>';

        //формируем  шаблон для задачи AA
        var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
        ExportUtil.exportExcelFileName = resFileName;
        //Формируем команду на выполнение сервису
        var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
        if (requestSource=="export") {
            inputData = '<input file_name="'+resFileName+'" template="export" data="'+itemXmlEscaped+'" keep_files="true"/>';
        }

	    alertForm = new AlertForm();
	    alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
	    //Добавляем слушатель закрытия формы
	    $("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
		    $("body").off(CloseEvent.CLOSE);
		    if (evt && evt.detail == 1) {
			    var processExportForm = new ProcessExportExcelForm();
			    processExportForm.inputData = inputData;
			    //Собственно создаем форму
			    processExportForm.build();
		    }
	    });
    }
};

/**
 * Экспорт в Excel из справочника
 * @param dataArray
 * @param fileName
 * @param excelTemplate
 * @param requestSource
 */
ExportUtil.exportToExcelFromDirectory = function exportFinalXML(dataArray, fileName, excelTemplate, requestSource) {
    var alertForm, requestParams;
    if (dataArray !== undefined && dataArray.length>0) {
        /* Групповой экспорт:
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\8135B2A5-1AF8-805E-E727-2D164400319B.xls" template="server_export" data="&lt;root>&#xA;  &lt;data LINE_ID_FILTER=&quot;1300347,1300064,1300066,1300067,1300069,1300348,1300070,1300350,1300071,1300079,1300080,1300029,1300376,1300351,1300032,1300341,1300035,1300081,1300377,1300082,1300084,1300352,1300085,1300086,1300378,1300088,1300089,1300353,1300342,1300092,1300036,1300037,1300094,1300096,1300097,1300098,1300354,1300379,1300099,1300100,1300102,1300104,1300380,1300381,1300382,1300106,1300028,1300107,1300355,1300109,1300111,1300113,1300356,1300115,1300436,1300357,1300117,1300023,1300119,1300384,1300385,1300120,1300386,1300387,1300388,1300063,1300358,1300389,1300359,1300123,1300344,1300360,1300345,1300441,1300125,1300126,1300128,1300439,1300130,1300132,1300134,1300440,1300034,1300031,1300136,1300138,1300390,1300039,1300139,1300361,1300391,1300141,1300033,1300143,1300145,1300392,1300146,1300026,1300393,1300362,1300030,1300147,1300394,1300395,1300363,1300396,1300149,1300397,1300151,1300398,1300153,1300399,1300364,1300365,1300154,1300156,1300400,1300157,1300366,1300402,1300159,1300060,1300061,1300403,1300162,1300404,1300164,1300167,1300169,1300171,1300405,1300172,1300173,1300174,1300175,1300176,1300178,1300406,1300179,1300181,1300183,1300187,1300199,1300221,1300233,1300237,1300059,1300253,1300257,1300261,1300265,1300277,1300279,1300291,1300370,1300293,1300407,1300018,1300019,1300447,1300375,1300408,1300409,1300410,1300411,1300295,1300412,1300413,1300371,1300414,1300297,1300415,1300299,1300416,1300003,1300004,1300005,1300020,1300027,1300300,1300417,1300302,1300303,1300418,1300419,1300420,1300304,1300421,1300422,1300423,1300424,1300425,1300426,1300346,1300305,1300306,1300434,1300435,1300006,1300007,1300427,1300307,1300308,1300309,1300312,1300313,1300314,1300315,1300428,1300316,1300429,1300317,1300318,1300319,1300320,1300321,1300430,1300431,1300322,1300323,1300324,1300373,1300432,1300325,1300000,1300327,1300433,1300329,1300330,1300331,1300332,1300012,1300017,1300013,1300016,1300014,1300015,1300025,1300024,1300334,1300001,1300021,1300002,1300022,1300008,1300011,1300009,1300010,0&quot; ROUTE_TYPE_FILTER=&quot;'ROUTE_TYPE_12','ROUTE_TYPE_10','ROUTE_TYPE_03','ROUTE_TYPE_04','ROUTE_TYPE_11','ROUTE_TYPE_02','ROUTE_TYPE_01','UNKNOWN'&quot; OLD_LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot; FILTER=&quot;8=8 AND ID IN (1301709,1300249)&quot; LPU_ACCESS_FILTER=&quot;13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_GRID.XML#PODS_ROUTE"/>
         * */
        /* Экспорт одного объекта
         * templateName DATA_LAY_Exp.xml
         * input <input file_name="Public\Data\TAB\B6CC9B4C-A9EF-8378-02B1-2D1A50BB73CF.xls" template="PODS_ROUTE" data="&lt;root>&#xA;  &lt;data LINE_ID=&quot;1300000&quot; OPERATING_STATUS_GCL=&quot;ACTIVE&quot; SRV_DISTRICT_ID=&quot;13006&quot; ID=&quot;1301709&quot; TYPE_LBL=&quot;Магистральный&quot; ROUTE_TYPE_CL=&quot;ROUTE_TYPE_10&quot; mx_internal_uid=&quot;F6052EAE-5832-1190-E3E5-2D159C634C63&quot; SYS_OBJ_ID=&quot;1301709&quot; RWN=&quot;1&quot; DESCRIPTION=&quot;СРТО-Урал&quot; STATION_BEG=&quot;1690&quot; FILTER=&quot;ID=1301709&quot; STATION_END=&quot;1840&quot;/>&#xA;&lt;/root>" keep_files="true" ext_data_id="PODS_EXPORT.xml#PODS_ROUTE"/>
         * */
        //генерируем UID для текущей выгрузки
        var currentUID = App.generateUUID();
        var itemXmlEscaped = '&lt;root>';
        for(var i = 0;i < dataArray.length; i++){
            itemXmlEscaped += ExportUtil.Obj2StrXML(dataArray[i], 'data');
        }
        itemXmlEscaped += '&lt;/root>';

        //формируем  шаблон для задачи AA
        var resFileName = 'Public/Data/TAB/'+currentUID+'.xls';
        ExportUtil.exportExcelFileName = resFileName;
        //Формируем команду на выполнение сервису
        var inputData = '<input file_name="'+resFileName+'" template="'+excelTemplate+'" data="'+itemXmlEscaped+'" keep_files="true" ext_data_id="'+requestSource+'"/>';
        if (requestSource=="export") {
            inputData = '<input file_name="'+resFileName+'" template="export" data="'+itemXmlEscaped+'" keep_files="true"/>';
        }
	    alertForm = new AlertForm();
	    alertForm.build("utilExportExcelAlertForm",gis_exportutil_14,gis_core_1,AlertForm.OK);
	    //Добавляем слушатель закрытия формы
	    $("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
		    $("body").off(CloseEvent.CLOSE);
		    if (evt && evt.detail == 1) {
			    var processExportForm = new ProcessExportExcelForm();
			    processExportForm.inputData = inputData;
			    //Собственно создаем форму
			    processExportForm.build();
		    }
	    });
    }
    else{
        App.confirmDialog(ExportUtil.EXPORT_EXCEL_EMPTY_DATA_ERROR);
    }
};


ExportUtil.exportToExcelFault = function exportToExcelFault(resultXml) {
    //Снимаем курсор ожидания
    BlockingUtil.ready();
    //BlockingUtil.unblockApplication();
    App.errorReport(ExportUtil.EXPORT_EXCEL_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_5'});
    ExportUtil.exportExcelFileName = "";
};

/**
 * Функции для экспорта в WRL
 * */
//Переменная хранит последнее имя генерируемого файла (уже с расширением .wrz)
ExportUtil.exportWRLFileName = "";

ExportUtil.exportToWRL = function exportToWRL(wrlId, wrlFileName) {
    //Запоминаем имя файла (русскоязычное) для последующего вызова
    ExportUtil.exportWRLFileName = wrlId;//wrlFileName;
    var templateName = "TAB_BLOB_Exp.xml";
    //var inputData = '<item folder_name="Public/Data/VRML" file_id="'+wrlId+'" keep_files="false" table_name="WEB50.LIB_DOC_VERSION" blob_field="BODY" file_name_field="FILE_NAME" id_field="DOC_VERSION_ID"/>';
	var inputData = '<item folder_name="Public/Data/VRML" file_id="'+wrlId+'" keep_files="false" table_name="WEB50.LIB_DOC_VERSION" blob_field="BODY" file_name_field="DOC_ID" id_field="DOC_VERSION_ID"/>';
    var requestParams = ExportUtil.makeUTETaskServiceDataReqParams(templateName, inputData);
    App.serverQueryXMLWithTries(Services.RunUTETaskService, requestParams
        ,ExportUtil.exportToWRLResult
        ,ExportUtil.exportToWRLFault
        ,4
    );
};

ExportUtil.exportToWRLResult = function exportToWRLResult(resultXml) {
    if (!resultXml || resultXml==undefined || resultXml!="<result>1</result>") {
        App.errorReport(ExportUtil.EXPORT_WRL_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_6'});
    } else {
        var curUrl = ExportUtil.getCurrentUrl();
        /* будет такой запрос : /web55/Public/Modules/VRML/Wrl.htm?wrl=http://192.168.3.244/Public/Data/VRML/FILE_NAME.wrz */
        var fileUrl = curUrl + 'Public/Modules/VRML/Wrl.htm?wrl=' + curUrl + 'Public/Data/VRML/' + ExportUtil.exportWRLFileName;
        //Предоставляем пользователю ссылку на этот файл
        var win = window.open(fileUrl, '_blank');
        win.focus();
    }
    ExportUtil.exportWRLFileName = "";
};

ExportUtil.exportToWRLFault = function exportToWRLFault(resultXml) {
    App.errorReport(ExportUtil.EXPORT_WRL_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_7'});
    ExportUtil.exportWRLFileName = "";
};

/**
 * Функции для экспорта в IMG
 * */
//Переменная хранит последнее имя генерируемого файла (уже с расширением .img)
ExportUtil.exportIMGFileName = "";

ExportUtil.exportToIMG = function exportToIMG(imgId, imgFileName) {
    //Запоминаем имя файла (русскоязычное) для последующего вызова
    ExportUtil.exportIMGFileName = imgFileName;
    var templateName = "TAB_BLOB_Exp.xml";
    var inputData = '<item folder_name="Public/Data/IMG" file_id="'+imgId+'" keep_files="false" table_name="WEB50.LIB_DOC_VERSION" blob_field="BODY" file_name_field="FILE_NAME" id_field="DOC_VERSION_ID"/>';
    var requestParams = ExportUtil.makeUTETaskServiceDataReqParams(templateName, inputData);
    App.serverQueryXMLWithTries(Services.
            RunUTETaskService, requestParams
        ,ExportUtil.exportToIMGResult
        ,ExportUtil.exportToIMGFault
        ,4
    );
};

ExportUtil.exportToIMGResult = function exportToIMGResult(resultXml) {
    if (!resultXml) {
        App.errorReport(ExportUtil.PACK_IMG_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_10'});
    } else {
        var realtivePath = 'Public/Data/IMG/'+ExportUtil.exportIMGFileName;
        var curUrl = ExportUtil.getCurrentUrl();
        /* будет такой запрос : /Public/Data/Temp/IMG/{file_name}.img  */
        var fileUrl = curUrl + realtivePath;
        //Предоставляем пользователю ссылку на этот файл
        var win = window.open(fileUrl, '_blank');
        win.focus();
    }
    ExportUtil.exportIMGFileName = "";
};

ExportUtil.exportToIMGFault = function exportToIMGFault(resultXml) {
    App.errorReport(ExportUtil.EXPORT_IMG_ERROR, resultXml.toString(), undefined, {filename:gis_filename_594, functionname:'gis_filename_594_9'});
    ExportUtil.exportIMGFileName = "";
};


/* Вспомогательные функции */

ExportUtil.Obj2XML = function(obj, name){
    var item = $('<' + name + '/>');
    for(var prop in obj){
        item.attr(prop.toUpperCase(),obj[prop]);
        //item[0].setAttribute(prop.toUpperCase(),obj[prop]);
    }
    return item;
};

ExportUtil.Obj2StrXML = function(obj, name){
    var item = '&lt;' + name ;
    for(var prop in obj){
        item += ' '+prop+'=&quot;'+obj[prop]+'&quot; ';
    }
    item += ' />';
    return item;
};
//Глобальный объект
GeoUtil = {};
//константы проекций
GeoUtil.PROJS = {
	'EPSG:4284':'EPSG:4284',//Пулково84
	'Pulkovo42':'EPSG:4284',//Пулково84
	'EPSG:4326':'EPSG:4326',//WGS 84
	'WGS84':'EPSG:4326',//WGS 84
	'EPSG:900913':'EPSG:900913',//Google Mercator
	'GoogleMercator':'EPSG:900913',//Google Mercator
	'EPSG:3857':'EPSG:3857',//Google Mercator
	'EPSG:3395':'EPSG:3395',//Проекция Яндекса
	'EPSG:5807':'EPSG:5807'//Проекция тех схемы и пка
};
//Функции
GeoUtil.P42WGS = function(y, x, h1) {
	if (h1===undefined || h1===null) h1 = 0;
	// y - широта
	// x - долгота
	y = y*Math.PI/180;
	x = x*Math.PI/180;

	//Параметры эллипсоида CK-42
	var a1=6378245;
	var e1=0.0066934216;

	//Параметры эллипсоида WGS
	var a2=6378137;
	var e2=0.00669438;
	var N1=a1/Math.sqrt(1-e1*Math.pow(Math.sin(y),2));

	//Геоцентрические прямоугольные координаты в CK-42
	var x1=(N1+h1)*Math.cos(y)*Math.cos(x);
	var y1=(N1+h1)*Math.cos(y)*Math.sin(x);
	var z1=((1-e1)*N1+h1)*Math.sin(y);
	var coeff = 1-0.12E-6;

	//Геоцентрические прямоугольные координаты в WGS
	var x2=coeff*(x1-4.363321062E-6*y1+1.939259378E-6*z1)+26.3;
	var y2=coeff*(4.36332313E-6*x1+y1-1.066581637E-6*z1)-132.6;
	var z2=coeff*(-1.939254724E-6*x1+1.066590098E-6*y1+z1)-76.3;

	var l2=Math.atan(y2/x2);
	if (x2<0)
	{
		if (y2<0)
		{
			l2-=Math.PI;
		}
		else
		{
			l2+= Math.PI;
		}
	}
	var b2=y;

	var N2 = 0;

	for(var i=0; i<3; i++)
	{
		N2=a2/Math.sqrt(1-e2*Math.pow(Math.sin(b2),2));
		b2 = Math.atan((z2+e2*N2*Math.sin(b2))/Math.sqrt(x2*x2+y2*y2));
	}

	var h2=x2/Math.cos(l2)/Math.cos(b2)-N2;
	b2 = b2*180/Math.PI;
	l2 = l2*180/Math.PI;
	//Объект-точка
	return {x:l2, y:b2};
};

GeoUtil.WGSP42 = function(y, x, h1) {
	if (h1===undefined || h1===null) h1 = 0;
	// y - широта
	// x - долгота
	y = y*Math.PI/180;
	x = x*Math.PI/180;

	//Параметры эллипсоида WGS
	var a1=6378137;
	var e1=0.00669438;

	//Параметры эллипсоида CK-42
	var a2=6378245;
	var e2=0.0066934216;
	var N1=a1/Math.sqrt(1-e1*Math.pow(Math.sin(y),2));

	//Геоцентрические прямоугольные координаты в WGS
	var x1=(N1+h1)*Math.cos(y)*Math.cos(x);
	var y1=(N1+h1)*Math.cos(y)*Math.sin(x);
	var z1=((1-e1)*N1+h1)*Math.sin(y);
	var coeff = 1-0.12E-6;

	//Геоцентрические прямоугольные координаты в CK-42
	/*
	 var x2=coeff*(x1+3.849423968E-6*y1-2.3755816253E-6*z1)-26.3;
	 var y2=coeff*(-3.849420628E-6*x1+y1+1.4059688198E-6*z1)+132.6;
	 var z2=coeff*(2.3755870374E-6*x1-1.4059596752E-6*y1+z1)+76.3;
	 */
	var x2=coeff*(x1+4.363321062E-6*y1-1.939259378E-6*z1)-26.3;
	var y2=coeff*(-4.36332313E-6*x1+y1+1.066581637E-6*z1)+132.6;
	var z2=coeff*(1.939254724E-6*x1-1.066590098E-6*y1+z1)+76.3;
	var l2=Math.atan(y2/x2);
	if (x2<0)
	{
		if (y2<0)
		{
			l2-=Math.PI;
		}
		else
		{
			l2+= Math.PI;
		}
	}
	var b2=y;
	var N2 = 0;
	for(var i=0; i<3; i++)
	{
		N2=a2/Math.sqrt(1-e2*Math.pow(Math.sin(b2),2));
		b2 = Math.atan((z2+e2*N2*Math.sin(b2))/Math.sqrt(x2*x2+y2*y2));
	}

	var h2=x2/Math.cos(l2)/Math.cos(b2)-N2;
	b2 = b2*180/Math.PI;
	l2 = l2*180/Math.PI;
	//Объект-точка
	return {x:l2, y:b2};
};

//Прямоугольник из пулково в WGS
GeoUtil.RectP42WGS = function(data) {
	if (data != null)
	{
		var topA = GeoUtil.P42WGS(data.top, data.right);
		var btmA = GeoUtil.P42WGS(data.bottom, data.left);
		var r = {};
		r.top = topA.y;
		r.left = btmA.x;
		r.bottom = btmA.y;
		r.right = topA.x;
		return r;
	}
	return null;
};

//Прямоугольник из WGS в пулково
GeoUtil.RectWGSP42 = function(data) {
	if (data != null)
	{
		var topA = GeoUtil.WGSP42(data.top, data.right);
		var btmA = GeoUtil.WGSP42(data.bottom, data.left);
		var r = {};
		r.top = topA.y;
		r.left = btmA.x;
		r.bottom = btmA.y;
		r.right = topA.x;
		return r;
	}
	return null;
};


/**
 * Конвертация дополнительных слоёв на карте(слой выделения, слой рисования, буферный,..)
 * @param vectorLayers
 * @param source
 * @param dest
 */
GeoUtil.convertAdditionalGeometryFromToDefault = function(vectorLayers,source,dest){
	if(source === GeoUtil.PROJS['EPSG:900913'])
		source = GeoUtil.PROJS['EPSG:3857'];
	if(dest === GeoUtil.PROJS['EPSG:900913'])
		dest = GeoUtil.PROJS['EPSG:3857'];
	if(source === dest)return;
	var i = 0;
	for(;i<vectorLayers.length;i++){
		var layer = vectorLayers[i];
		if(goog.isDef(layer)){
			var layerSource = layer.getSource();
			var features = layerSource.getFeatures();
			var j = 0;
			for(;j<features.length;j++){
				var featureGeometry = features[j].getGeometry();
				GeoUtil.convertGeometry(featureGeometry,source,dest);
			}
			if(features.length>0)
				layer.changed();
		}
	}
};

/**
 * Конвертация проекции при смене режима карты
 * @param source
 * @param dest
 */
GeoUtil.convertGeometryFromToDefault = function(vectorLayers,source,dest){
	if(source === GeoUtil.PROJS['EPSG:900913'])
		source = GeoUtil.PROJS['EPSG:3857'];
	if(dest === GeoUtil.PROJS['EPSG:900913'])
		dest = GeoUtil.PROJS['EPSG:3857'];
	if(source === dest)return;
	if(vectorLayers.length > 0){
		var i = 0;
		for(;i<vectorLayers.length;i++){
			var layer = vectorLayers[i];
			if(goog.isDef(layer.layer) && goog.isDef(layer.layer.featureProjLayer)){
				var layerSource = layer.layer.featureProjLayer.getSource().getSource();
				var features = layerSource.getFeatures();
				var j = 0;
				for(;j<features.length;j++){
					var feature = features[j];
					var labelsObjAll = feature.get('labelsObjAll');
					var k = 0;
					try {
						for (; k < labelsObjAll.length; k++) {
							var geo = labelsObjAll[k].geo;
							GeoUtil.convertGeometry(geo, source, dest);
						}
					}
					catch(ex){
					}
					var featureGeometry = feature.getGeometry();
					GeoUtil.convertGeometry(featureGeometry,source,dest);
				}
				if(features.length>0)
					layer.layer.featureProjLayer.changed();
			}
		}
	}
};

/**
 * Конвертирует массив координат для линии
 * @param coords массив координат  of Array.<ol.Coordinate>
 * @param source По умолчанию pulkovo42
 * @param dest По умолчанию pulkovo42
 * @returns {Array}
 */
GeoUtil.convertCoords1 = function(coords, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	var source_ =  new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
	var dest_= new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
	var pnt;
	var j = 0;
	for (j; j < coords.length; j ++) {
		pnt = new proj4.toPoint(coords[j]);
		if((source === GeoUtil.PROJS.Pulkovo42)){
			var p42WgsPnt = GeoUtil.P42WGS( pnt.y, pnt.x);
			pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
		}
		proj4.transform(source_, dest_, pnt);
		if(isNaN(pnt.x) || isNaN(pnt.y))
			continue;
		if((dest === GeoUtil.PROJS.Pulkovo42)){
			var pWgsP42Pnt = GeoUtil.WGSP42( pnt.y, pnt.x);
			pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
		}
		coords[j] = [pnt.x, pnt.y];
	}
	return coords;
};

/**
 * Конвертирует массив координат для полигона
 * @param coords массив координат  of Array.<ol.Coordinate>
 * @param source По умолчанию pulkovo42
 * @param dest По умолчанию pulkovo42
 * @returns {Array}
 */
GeoUtil.convertCoords2 = function(coords, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	var source_ =  new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
	var dest_= new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
	var pnt;
	var j = 0, i = 0;
	for (i; i < coords.length; i++) {
		for (j; j < coords[i].length; j ++) {
			pnt = new proj4.toPoint(coords[i][j]);
			if((source === GeoUtil.PROJS.Pulkovo42)){
				var p42WgsPnt = GeoUtil.P42WGS( pnt.y, pnt.x);
				pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
			}
			proj4.transform(source_, dest_, pnt);
			if(isNaN(pnt.x) || isNaN(pnt.y))
				continue;
			if((dest === GeoUtil.PROJS.Pulkovo42)){
				var pWgsP42Pnt = GeoUtil.WGSP42( pnt.y, pnt.x);
				pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
			}
			coords[i][j] = [pnt.x, pnt.y];
		}
	}
	return coords;
};
/**
 * Конвертирует массив координат
 * @param coords массив координат  of Array.<ol.Coordinate>
 * @param source По умолчанию pulkovo42
 * @param dest По умолчанию pulkovo42
 * @returns {Array}
 */
GeoUtil.convertCoords = function(coords, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	var newCoords  = [];//of Array.<ol.Coordinate>
	var stride = 2;
	goog.asserts.assert(coords.length % stride === 0);
	var source_ =  new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
	var dest_= new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
	var pnt;
	var j = 0;
	for (j; j < coords.length; j += stride) {
		pnt = new proj4.toPoint([coords[j], coords[j+1]]);
		if((source === GeoUtil.PROJS.Pulkovo42)){
			var p42WgsPnt = GeoUtil.P42WGS( pnt.y, pnt.x);
			pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
		}
		proj4.transform(source_, dest_, pnt);
		if(isNaN(pnt.x) || isNaN(pnt.y))
			continue;
		if((dest === GeoUtil.PROJS.Pulkovo42)){
			var pWgsP42Pnt = GeoUtil.WGSP42( pnt.y, pnt.x);
			pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
		}
		newCoords.push(pnt.x);
		newCoords.push(pnt.y);
	}
	return newCoords;
};

/**
 * Конвертация геометрии
 * @param geometryCollection
 * @param source по умолчанию pulkovo42
 * @param dest по умолчанию google mercator 900913
 */
GeoUtil.convertGeometry = function(geometryCollection, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	if(geometryCollection instanceof ol.geom.GeometryCollection){
		var geoArr = geometryCollection.getGeometriesArray();
		for(var i=0; i<geoArr.length;i++){
			GeoUtil.convertGeometry(geoArr[i], source, dest);
		}
	}
	else{
		var geometry = geometryCollection;
		if(geometry !== undefined){
			var coords = geometry.flatCoordinates;
			var newCoords  = [];//of Array.<ol.Coordinate>
			var stride = geometry.stride;
			var source_ = new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
			var dest_ =  new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
			goog.asserts.assert(coords.length % stride === 0);
			var pnt;
			var j;
			for ( j = 0; j < coords.length; j += stride) {
				//с двойной трансформацей отлет 2 метра пропадает
				pnt= new proj4.toPoint([coords[j], coords[j+1]]);
				if((source === GeoUtil.PROJS.Pulkovo42)){
					var p42WgsPnt = GeoUtil.P42WGS( coords[j+1], coords[j]);
					pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
				}
				proj4.transform(source_, dest_, pnt);
				if((dest === GeoUtil.PROJS.Pulkovo42)){
					var pWgsP42Pnt = GeoUtil.WGSP42( coords[j+1], coords[j]);
					pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
				}
				if(isNaN(pnt.x) || isNaN(pnt.y))
					continue;
				newCoords.push(pnt.x);
				newCoords.push(pnt.y);
				if(stride === 3)
					newCoords.push(coords[j+2]);
			}
			if(geometry.getType() === ol.geom.GeometryType.POLYGON || geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
				geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
			else if(geometry.getType() === ol.geom.GeometryType.MULTI_POLYGON)
				geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
			else
				geometry.setFlatCoordinates(geometry.layout,newCoords);
		}
	}
};

/**
 * Функция перевода спец проекции в базовую.
 * Вынесена отдельно, чтобы наглядно было видно, что спец проекция в месте вызова
 * @param feature
 * @param sourceZone
 * @param destZone
 */
GeoUtil.convertFeature326NN = function (feature, sourceZone, destZone) {
	if (!goog.isDef(sourceZone))sourceZone = 'EPSG:32639';
	if (!goog.isDef(destZone))destZone = 'EPSG:32639';

	GeoUtil.convertFeature(feature, sourceZone, destZone);
};

/**
 * Конвертация фичи
 * TODO, стоит в дальшейшем объекдинить с GeoUtil.convertGeometry
 * @param feature
 * @param source
 * @param dest
 */
GeoUtil.convertFeature = function(feature, source, dest){
	source = (source || GeoUtil.PROJS.Pulkovo42);
	dest = (dest || GeoUtil.PROJS.GoogleMercator);
	var geometry = feature.getGeometry();
	if(geometry !== undefined){
		var coords = geometry.flatCoordinates;
		var newCoords  = [];//of Array.<ol.Coordinate>
		var stride = geometry.stride;
		var source_ = new proj4.Proj((source === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:source);
		var dest_ =  new proj4.Proj((dest === GeoUtil.PROJS.Pulkovo42)?GeoUtil.PROJS.WGS84:dest);
		goog.asserts.assert(coords.length % stride === 0);
		var pnt;
		var j = 0;
		for (j; j < coords.length; j += stride) {
			pnt= new proj4.toPoint([coords[j], coords[j+1]]);
			if((source === GeoUtil.PROJS.Pulkovo42)){
				var p42WgsPnt = GeoUtil.P42WGS( pnt.y, pnt.x);
				pnt= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
			}
			proj4.transform(source_, dest_, pnt);
			if((dest === GeoUtil.PROJS.Pulkovo42)){
				var pWgsP42Pnt = GeoUtil.WGSP42( pnt.y, pnt.x);
				pnt= new proj4.toPoint([pWgsP42Pnt.x, pWgsP42Pnt.y]);
			}
			if(isNaN(pnt.x) || isNaN(pnt.y))
				continue;
			newCoords.push(pnt.x);
			newCoords.push(pnt.y);
			if(stride === 3)
				newCoords.push(coords[j+2]);
		}
		if(feature.getGeometry().getType() === ol.geom.GeometryType.POLYGON || feature.getGeometry().getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
			feature.getGeometry().setFlatCoordinates(geometry.layout,newCoords,feature.getGeometry().getEnds());
		else if(feature.getGeometry().getType() === ol.geom.GeometryType.MULTI_POLYGON)
			feature.getGeometry().setFlatCoordinates(geometry.layout,newCoords,feature.getGeometry().getEndss());
		else
			feature.getGeometry().setFlatCoordinates(geometry.layout,newCoords);
	}
};

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */
GeoUtil.forEach = function(flatCoordinates, offset, end, stride, callback, opt_this) {
	var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
	var point2 = [];
	var ret;
	for (; (offset + stride) < end; offset += stride) {
		point2[0] = flatCoordinates[offset + stride];
		point2[1] = flatCoordinates[offset + stride + 1];
		ret = callback.call(opt_this, point1, point2);
		if (ret) {
			return ret;
		}
		point1[0] = point2[0];
		point1[1] = point2[1];
	}
	return false;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
GeoUtil.lineString = function(flatCoordinates, offset, end, stride, extent, geoExtent) {
	//убрана проверка координат, т.к. extent уже есть в сохраненной геометрии фичи
	var coordinatesExtent = (geoExtent) ? geoExtent : ol.extent.extendFlatCoordinates(
		ol.extent.createEmpty(), flatCoordinates, offset, end, stride);
	if (!ol.extent.intersects(extent, coordinatesExtent)) {
		return false;
	}
	if (ol.extent.containsExtent(extent, coordinatesExtent)) {
		return true;
	}
	if (coordinatesExtent[0] >= extent[0] &&
		coordinatesExtent[2] <= extent[2]) {
		return true;
	}
	if (coordinatesExtent[1] >= extent[1] &&
		coordinatesExtent[3] <= extent[3]) {
		return true;
	}
	return GeoUtil.forEach(flatCoordinates, offset, end, stride,
		/**
		 * @param {ol.Coordinate} point1 Start point.
		 * @param {ol.Coordinate} point2 End point.
		 * @return {boolean} `true` if the segment and the extent intersect,
		 *     `false` otherwise.
		 */
		function(point1, point2) {
			return ol.extent.intersectsSegment(extent, point1, point2);
		});
};

/**
 *
 * @param feature
 * @param extent
 * @returns {[]|*[]}
 */
GeoUtil.getIntersectedGeometry = function(feature, extent, excudeGeoTypes){
	var result = [];
	var geometry = feature.getGeometry();
	goog.asserts.assert(goog.isDefAndNotNull(geometry),
		'feature geometry is defined and not null');
	if(!goog.isDef(feature.get('labelType')))
		return [];
	if(excudeGeoTypes && excudeGeoTypes.length > 0){
		if(excudeGeoTypes.indexOf(geometry.getType()) !== -1)
			return [];
	}
	switch(geometry.getType()){
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			var i, ii;
			var ends = geometry.ends_;
			var offset = 0;
			for (i = 0, ii = ends.length; i < ii; ++i) {
				if (ol.geom.flat.intersectsextent.lineString(
					geometry.flatCoordinates, offset, ends[i], geometry.stride, extent)) {
					if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
						var obj =  jQuery.extend({}, globalLinesLabels_[feature.get('labelType')][i]);
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getLineString(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его

								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
							}
						}

						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0].clone());
						else{
							var gm = new ol.geom.MultiLineString(null);
							gm.setLineStrings(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}

				}
				offset = ends[i];
			}

			break;
		case ol.geom.GeometryType.LINE_STRING:
			ol.geom.flat.intersectsextent.lineString(
				geometry.flatCoordinates, 0, geometry.ends_, geometry.stride, extent);
			if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
				var obj = globalLinesLabels_[feature.get('labelType')][0];
				obj.geo = new ol.Feature(geometry.getLineString(0).clone());
				obj.feature = feature;
				result.push(obj);
			}
			break;
		case ol.geom.GeometryType.MULTI_POINT:
			var i, ii, x, y;
			for (i = 0, ii = geometry.flatCoordinates.length; i < ii; i += geometry.stride) {
				x = geometry.flatCoordinates[i];
				y = geometry.flatCoordinates[i + 1];
				if (ol.extent.containsXY(extent, x, y)) {
					if(goog.isDef(globalPointsLabels_[feature.get('labelType')]) && goog.isDef(feature.get('labelsObj'))){
						//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
						//, выбираем из этого списка
						var obj;
						if(globalPointsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
							obj = feature.get('labelsObj')[i/2];
							if (obj === undefined)
								obj = globalPointsLabels_[feature.get('labelType')][i/2];
						}
						else{
							obj = globalPointsLabels_[feature.get('labelType')][i/2];
						}

						obj.geo = new ol.Feature(geometry.getPoint(i/2).clone());
						obj.feature = feature;
						result.push(obj);
					}
				}
			}
			break;
		case ol.geom.GeometryType.POINT:
			var x, y;
			x = geometry.flatCoordinates[0];
			y = geometry.flatCoordinates[1];
			if (ol.extent.containsXY(extent, x, y)) {
				if(goog.isDef(globalPointsLabels_[feature.get('labelType')])){
					var obj = globalPointsLabels_[feature.get('labelType')][0];
					obj.geo = new ol.Feature(geometry.clone());
					obj.feature = feature;
					result.push(obj);
				}
			}
			break;
		case ol.geom.GeometryType.MULTI_POLYGON:
			var i, ii;
			var offset = 0;
			var or = geometry.getOrientedFlatCoordinates();
			var endss = geometry.endss_;
			for (i = 0, ii = endss.length; i < ii; ++i) {
				var ends = endss[i];
				if (ol.geom.flat.intersectsextent.linearRings(
					or, offset, ends, geometry.stride, extent)) {
					if(goog.isDef(globalPolygonsLabels_[feature.get('labelType')]) && goog.isDef(feature.get('labelsObj'))){
						//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
						//, выбираем из этого списка
						var obj;
						if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
							obj = feature.get('labelsObj')[i];
						}
						else{
							obj = jQuery.extend({}, globalPolygonsLabels_[feature.get('labelType')][i]);
						}
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getPolygon(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его

								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalPolygonsLabels_[feature.get('labelType')][t];
									}

									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getPolygon(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalPolygonsLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj)&& goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getPolygon(t).clone());
									}
								}
							}
						}
						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0]);
						else{
							var gm = new ol.geom.MultiPolygon(null);
							gm.setPolygons(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}
				}
				offset = ends[ends.length - 1];
			}
			break;
		case ol.geom.GeometryType.POLYGON:
			var or = geometry.getOrientedFlatCoordinates();
			var ends = geometry.ends_;
			if (ol.geom.flat.intersectsextent.linearRings(
				or, 0, ends, geometry.stride, extent)) {
				if(goog.isDef(globalPolygonsLabels_[feature.get('labelType')])){
					var obj = globalPolygonsLabels_[feature.get('labelType')][0];
					obj.geo = new ol.Feature(geometry.clone());
					obj.feature = feature;
					result.push(obj);
				}
			}
			offset = ends[ends.length - 1];
			break;
	}
	return result;
};

GeoUtil.getIntersectedGeometry_old = function(feature, extent){
	var result = [];
	var geometry = feature.getGeometry();
	goog.asserts.assert(goog.isDefAndNotNull(geometry),
		'feature geometry is defined and not null');
	if(!goog.isDef(feature.get('labelType')))
		return [];
	switch(geometry.getType()){
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			var i, ii;
			var ends = geometry.ends_;
			var offset = 0;
			if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
				for (i = 0, ii = ends.length; i < ii; ++i) {
					var geo = globalLinesLabels_[feature.get('labelType')][i].geo;
					if(geo === undefined)
						continue;
					var geoExcent = geo.getExtent();
					if(!ol.extent.intersects(geoExcent, extent))
						continue;
					/*if (GeoUtil.lineString(geometry.flatCoordinates, offset, ends[i], geometry.stride, extent, geoExcent)) {*/
					if (ol.geom.flat.intersectsextent.lineString(
						geometry.flatCoordinates, offset, ends[i], geometry.stride, extent)) {
						var obj =  jQuery.extend({}, globalLinesLabels_[feature.get('labelType')][i]);
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getLineString(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его
								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
							}
						}

						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0].clone());
						else{
							var gm = new ol.geom.MultiLineString(null);
							gm.setLineStrings(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}
				}
			}
			offset = ends[i];
			break;
		case ol.geom.GeometryType.LINE_STRING:
			ol.geom.flat.intersectsextent.lineString(
				geometry.flatCoordinates, 0, geometry.ends_, geometry.stride, extent);
			if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
				var obj = globalLinesLabels_[feature.get('labelType')][0];
				obj.geo = new ol.Feature(geometry.getLineString(0).clone());
				obj.feature = feature;
				result.push(obj);
			}
			break;
		case ol.geom.GeometryType.MULTI_POINT:
			var i, ii, x, y;
			for (i = 0, ii = geometry.flatCoordinates.length; i < ii; i += geometry.stride) {
				x = geometry.flatCoordinates[i];
				y = geometry.flatCoordinates[i + 1];
				if (ol.extent.containsXY(extent, x, y)) {
					if(goog.isDef(globalPointsLabels_[feature.get('labelType')]) && goog.isDef(feature.get('labelsObj'))){
						//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
						//, выбираем из этого списка
						var obj;
						if(globalPointsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
							obj = feature.get('labelsObj')[i/2];
						}
						else{
							obj = globalPointsLabels_[feature.get('labelType')][i/2];
						}

						obj.geo = new ol.Feature(geometry.getPoint(i/2).clone());
						obj.feature = feature;
						result.push(obj);
					}
				}
			}
			break;
		case ol.geom.GeometryType.POINT:
			var x, y;
			x = geometry.flatCoordinates[0];
			y = geometry.flatCoordinates[1];
			if (ol.extent.containsXY(extent, x, y)) {
				if(goog.isDef(globalPointsLabels_[feature.get('labelType')])){
					var obj = globalPointsLabels_[feature.get('labelType')][0];
					obj.geo = new ol.Feature(geometry.clone());
					obj.feature = feature;
					result.push(obj);
				}
			}
			break;
		case ol.geom.GeometryType.MULTI_POLYGON:
			var i, ii;
			var offset = 0;
			var or = geometry.getOrientedFlatCoordinates();
			var endss = geometry.endss_;
			for (i = 0, ii = endss.length; i < ii; ++i) {
				var ends = endss[i];
				if (ol.geom.flat.intersectsextent.linearRings(
					or, offset, ends, geometry.stride, extent)) {
					if(goog.isDef(globalPolygonsLabels_[feature.get('labelType')]) && goog.isDef(feature.get('labelsObj'))){
						//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
						//, выбираем из этого списка
						var obj;
						if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
							obj = feature.get('labelsObj')[i];
						}
						else{
							obj = jQuery.extend({}, globalPolygonsLabels_[feature.get('labelType')][i]);
						}
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getPolygon(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его

								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalPolygonsLabels_[feature.get('labelType')][t];
									}

									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getPolygon(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalPolygonsLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalPolygonsLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj)&& goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getPolygon(t).clone());
									}
								}
							}
						}
						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0]);
						else{
							var gm = new ol.geom.MultiPolygon(null);
							gm.setPolygons(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}
				}
				offset = ends[ends.length - 1];
			}
			break;
		case ol.geom.GeometryType.POLYGON:
			var or = geometry.getOrientedFlatCoordinates();
			var ends = geometry.ends_;
			if (ol.geom.flat.intersectsextent.linearRings(
				or, 0, ends, geometry.stride, extent)) {
				if(goog.isDef(globalPolygonsLabels_[feature.get('labelType')])){
					var obj = globalPolygonsLabels_[feature.get('labelType')][0];
					obj.geo = new ol.Feature(geometry.clone());
					obj.feature = feature;
					result.push(obj);
				}
			}
			offset = ends[ends.length - 1];
			break;
	}
	return result;
};

//дистанция между двумя точками. Координаты в pulkovo84
GeoUtil.GetDist = function(b1, l1, z1, b2, l2, z2) {
	var dB = (b2-b1)*3600;
	var dL = (l2-l1)*3600;
	if(dB==0 && dL==0)
		return 0;

	var Bm = (b1+b2)/2;
	var ddB = dB/10000;
	var ddL = dL/10000;
	var ddB2 = ddB*ddB;
	var ddL2 = ddL*ddL;
	var ddB2L = ddB2*ddL;
	var ddBL2 = ddB*ddL2;
	var ddB3 = ddB2*ddB;
	var ddL3 = ddL2*ddL;
	var cosB = Math.cos(Bm*Math.PI/180);
	var cosB2 = cosB*cosB;
	var cosB3 = cosB2*cosB;
	var cosB4 = cosB3*cosB;
	var cosB5 = cosB4*cosB;
	var cosB6 = cosB5*cosB;
	var sinB = Math.sin(Bm*Math.PI/180);
	var a1 = 103422.05*cosB;
	var a2 = 9.5144*cosB+0.5525*cosB3-0.0078*cosB5;
	var a3 = -10.1287*cosB+10.1287*cosB3;
	var a4 = 103422.05-696.9116*cosB2+4.6954*cosB4-0.0310*cosB6;
	var a5 = -30.3860+10.3334*cosB2-0.2061*cosB4+0.0014*cosB6;
	var a6 = -0.2048+0.4192*cosB2-0.0124*cosB4;
	var D = (593.602160+cosB2)/(197.867385+cosB2);
	var E1 = a1*ddL+a2*ddB2L+a3*ddL3;
	var E2 = a4*ddB+a5*ddBL2+a6*ddB3;
	var sinA = Math.sin(Math.atan2(E1,E2));
	var dist;
	if(sinA!=0)
		dist = Math.abs(D*E1/sinA);
	else
		dist = Math.abs(D*E2);
	return Math.sqrt(dist*dist+(z2-z1)*(z2-z1));
};

//получение координаты точки по отрезку и длине, на которой она в нём находится от первой точки
GeoUtil.PointByDistanceAndSegment1 = function(distance, segment){
	var d = GeoUtil.Distance(segment[0],segment[1]); //длина сегмента
	var d1 = distance;//от первой точки до искомой
	var coeff = d1/d;//d1/d2;
	var pX = (1-coeff)*segment[0][0]+coeff*segment[1][0];
	var pY = (1-coeff)*segment[0][1]+coeff*segment[1][1];
	return [pX,pY];// segment[1];//[pX,pY];
};

GeoUtil.PointByDistanceAndSegment = function(lat1, long1, lat2, long2, per) {
	return [lat1 + (lat2 - lat1) * per, long1 + (long2 - long1) * per];
};

//получение координаты точки по отрезку и длине, на которой она в нём находится от первой точки
GeoUtil.PointByDistanceAndSegment12 = function(distance, segment){
	var x,y = 0;
	var d = GeoUtil.Distance(segment[0],segment[1]); //длина сегмента
	var d1 = distance;//от первой точки до искомой
	var d2 = d-distance;// от искомой до 2-й точки
	var coeff = d1/d;//d1/d2;
	var aX,aY,bX,bY,pX,pY = 0;
	aX = segment[0][0];
	aY = segment[0][1];
	bX = segment[1][0];
	bY = segment[1][1];
	pX = aX + coeff*(bX-aX);
	pY = aY + coeff*(bY-aY);
	return [pX,pY];// segment[1];//[pX,pY];
};

//Compute the distance from A to B
GeoUtil.Distance =  function (pointA, pointB){
	var d1 = pointA[0] - pointB[0];
	var d2 = pointA[1] - pointB[1];
	return Math.sqrt(d1 * d1 + d2 * d2);
};

/**
 * Calculating distance between line (or line segment) and point 2D
 */
//Compute the dot product AB . AC
GeoUtil.DotProduct = function(pointA, pointB, pointC){
	var AB = [0,0];
	var BC = [0,0];
	AB[0] = pointB[0] - pointA[0];
	AB[1] = pointB[1] - pointA[1];
	BC[0] = pointC[0] - pointB[0];
	BC[1] = pointC[1] - pointB[1];
	var dot = AB[0] * BC[0] + AB[1] * BC[1];

	return dot;
};

//Compute the cross product AB x AC
GeoUtil.CrossProduct = function(pointA, pointB, pointC){
	var AB = [0,0];
	var AC = [0,0];
	AB[0] = pointB[0] - pointA[0];
	AB[1] = pointB[1] - pointA[1];
	AC[0] = pointC[0] - pointA[0];
	AC[1] = pointC[1] - pointA[1];
	var cross = AB[0] * AC[1] - AB[1] * AC[0];

	return cross;
};

//Compute the distance from AB to C
//if isSegment is true, AB is a segment, not a line.
GeoUtil.LineToPointDistance2D = function(pointA, pointB, pointC, isSegment){
	if (isSegment == true){
		var dot1 = GeoUtil.DotProduct(pointA, pointB, pointC);
		if (dot1 > 0)
			return GeoUtil.Distance(pointB, pointC);

		var dot2 = GeoUtil.DotProduct(pointB, pointA, pointC);
		if (dot2 > 0)
			return GeoUtil.Distance(pointA, pointC);
	}
	var dist = GeoUtil.CrossProduct(pointA, pointB, pointC) / GeoUtil.Distance(pointA, pointB);
	return Math.abs(dist);
};


/**
 * Удаление из геометрии объекта по индексу
 * @param geometry
 * @param index
 */
GeoUtil.removeObjectFromGeometry = function(feature, index){
	if(feature === undefined)
		return false;
	var geometry = feature.getGeometry();
	switch(geometry.getType()){
		case ol.geom.GeometryType.MULTI_POINT:
			var n = !geometry.flatCoordinates ?
				0 : geometry.flatCoordinates.length / geometry.stride;
			if (index < 0 || n <= index) {
				geometry.changed();
				return false;
			}
			var coords = geometry.flatCoordinates;
			coords.splice(index * geometry.stride, geometry.stride);
			geometry.setFlatCoordinates(geometry.layout,coords);
			break;
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			if (index < 0 || geometry.ends_.length <= index) {
				return false;
			}
			var ls = geometry.getLineStrings();
			ls.splice(index,1);
			geometry.setLineStrings(ls);
			// geometry.flatCoordinates.splice(index === 0 ? 0 : geometry.ends_[index - 1], geometry.ends_[index]);
			break;
		case ol.geom.GeometryType.MULTI_POLYGON:
			if (index < 0 || geometry.endss_.length <= index) {
				return false;
			}
			var ls = geometry.getPolygons();
			ls.splice(index,1);
			geometry.setPolygons(ls);
			break;
	}
	return true;
};

GeoUtil.segmentIntersect = function(seg1, seg2){
// Check the validity of the segments
	if ((seg1[1]) < (seg1[0])){
		return false;
	}
	if ((seg2[1]) < (seg2[0])){
		return false;
	}

	// Compute some useful oriented length needed later for computing
	//   the cross product of 2D-vectors centered in (0,0).
	// Compute the X-orientedLength and Y-orientedLength of the edge seg1
	var x12_11 = ((seg1[1]) - (seg1[0]));  // seg1.x2 - seg1.x1
	var y12_11 = ((seg1[1]) - (seg1[0]));  // seg1.y2 - seg1.y1
	// Compute the X-orientedLength and Y-orientedLength of the edge seg2
	var x22_21 = ((seg2[1]) - (seg2[0]));  // seg2.x2 - seg2.x1
	var y22_21 = ((seg2[1]) - (seg2[0]));  // seg2.y2 - seg2.y1
	// Compute the X-orientedLength and Y-orientedLength between the first vertex of each edge, named seg3
	var x11_21 = ((seg1[0]) - (seg2[0]));  // seg1.x1 - seg2.x1
	var y11_21 = ((seg1[0]) - (seg2[0]));  // seg1.y1 - seg2.y1

	// Compute the cross product seg1 x seg2
	var d= (x12_11 * y22_21) - (x22_21 * y12_11);
	// Compute the cross product seg2 x seg3
	var n1 = (x22_21 * y11_21) - (x11_21 * y22_21);
	// Compute the cross product seg1 x seg3
	var n2 = (x12_11 * y11_21) - (x11_21 * y12_11);

	// Why do we use cross products ? Let's explain with d = seg1 x seg2
	// d represents the signed area of the parallelogram defined by the
	//   two segments seg1 and seg2 translated to have the same origin.
	// If d==0, then seg1 and seg2 are colinear (same or opposite sense)
	// If d<0, then seg1 is in the direct sense from seg2
	// If d>0, then seg1 is in the indirect sens from seg2

	// Test if the two segments intersect themselves or not
	var intersection = false;
	if (d == 0) {  // seg1 and seg2 are colinear and could be coincident
		if (n1 == 0 && n2 == 0) {  // coincident
			return true;
		}
		// else there is no intersection but the Boolean to return will
		//   depend on the tolerance management.
	} else {  // seg1 and seg2 are not colinear, an intersection could exist
		var along1 = n1 / d;
		var along2 = n2 / d;
		if ((along1 >= 0) && (along1 <= 1) && (along2 >=0) && (along2 <= 1)) {  // intersect
			return true;
		}
		// else there is no intersection but the Boolean to return will
		//   depend on the tolerance management.
	}

	// The tolerance must be managed to test if an approximated
	//   intersection exists or not.
	return false; // TODO
};

GeoUtil.lineIntersect = function(line,lineRing){
	if(lineRing.getType() === ol.geom.GeometryType.LINEAR_RING){
		if(!ol.extent.intersects(line.getExtent(),lineRing.getExtent()))
			return false;
		var segs1 = line.getCoordinates();
		var segs2 = lineRing.getCoordinates();
		var seg1, seg1y0, seg1y1, seg1yMin, seg1yMax;
		var seg2, seg2y0, seg2y1, seg2yMin, seg2yMax;
		var i=0;
		for(i; i<segs1.length; ++i) {
			seg1 = segs1[i];
			// Loop over each segment of the requested geometry
			for(var j=0; j<segs2.length; ++j) {
				// Before to really test the intersection between the two
				//    segments, we will test the intersection between their
				//    respective bounding boxes in four steps.
				seg2 = segs2[j];
				// If the most left vertex of seg2 is at the right of the
				//   most right vertex of seg1, there is no intersection
				if (seg2[0] > seg1[1]) {
					continue;
				}
				// If the most right vertex of seg2 is at the left of the
				//   most left vertex of seg1, there is no intersection
				if (seg2[1] < seg1[0]) {
					// seg2 still left of seg1
					continue;
				}
				// To perform similar tests along Y-axis, it is necessary to
				//   order the vertices of each segment
				seg1y0 = seg1[0];
				seg1y1 = seg1[1];
				seg2y0 = seg2[0];
				seg2y1 = seg2[1];
				seg1yMin = Math.min(seg1y0, seg1y1);
				seg1yMax = Math.max(seg1y0, seg1y1);
				seg2yMin = Math.min(seg2y0, seg2y1);
				seg2yMax = Math.max(seg2y0, seg2y1);
				// If the most bottom vertex of seg2 is above the most top
				//   vertex of seg1, there is no intersection
				if (seg2yMin > seg1yMax) {
					continue;
				}
				// If the most top vertex of seg2 is below the most bottom
				//   vertex of seg1, there is no intersection
				if (seg2yMax < seg1yMin) {
					continue;
				}
				// Now it sure that the bounding box of the two segments
				//   intersect themselves, so we have to perform the real
				//   intersection test of the two segments
				if (GeoUtil.segmentIntersect(seg1, seg2)) {
					// These two segments intersect, there is no need to
					//   continue the tests for all the other couples of
					//   segments
					return true;
				}
			}
		}
	}
	return false;
};

GeoUtil.polygonIntersect = function(polygon,geom){
	if(geom.getType() === ol.geom.GeometryType.LINE_STRING){

		// LinearRing should be tested before LineString if a different
		//   action should be made for each case..
		// Test for the intersection of each LinearRing of tis Polygon
		//   with the geometry (LineString or LinearRing)
		var linearRings = polygon.getLinearRings();
		var i=0;
		for(i; i<linearRings.length; i++) {
			if (GeoUtil.lineIntersect(geom,linearRings[i]))
				return true;
		}
		// None of the LinearRings of this Polygon intersects with the
		//  input geometry. An intersection exists in two cases:
		//  1) if the input geomety is whole contained in the first
		//    LinearRing but not in one of the holes represented by the
		//    others LinearRings.
		//  2) if the input geometry is a LinearRing (not a LineString)
		//    and this polygon is whole contained in it.
		//  Test only one vertex is sufficient in the two cases since
		//  there is no intersection.
		//      return this.containsPoint((geom as LineString).componentByIndex(0) as Point)
		//  || ((geom is LinearRing) && (geom as LinearRing).containsPoint((this.componentByIndex(0) as LinearRing).componentByIndex(0) as Point));
	}
	return false;
};

/**
 * Преобразование пришедшего массива с объектом WKT строки из пулково42 в wgs
 * @param dataArr
 * @returns {*}
 */
GeoUtil.parseP42WKTStringToWGS = function(dataArr){
	if(dataArr !== undefined){
		var i = 0;
		for(;i<dataArr.length;i++){
			var obj = dataArr[i];
			if(obj.WKT !== undefined){
				var format = new ol.format.WKT();
				var geometry = format.readGeometry(obj.WKT);
				var coords = geometry.flatCoordinates;
				var newCoords  = [];//of Array.<ol.Coordinate>
				var stride = geometry.stride;
				var j;
				for ( j = 0; j < coords.length; j += stride) {
					var p42WgsPnt = GeoUtil.P42WGS( coords[j+1], coords[j]);
					newCoords.push(p42WgsPnt.x);
					newCoords.push(p42WgsPnt.y);
					if(stride === 3)
						newCoords.push(coords[j+2]);
				}
				if(geometry.getType() === ol.geom.GeometryType.POLYGON || geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
					geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
				else if(geometry.getType() === ol.geom.GeometryType.MULTI_POLYGON)
					geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
				else
					geometry.setFlatCoordinates(geometry.layout,newCoords);
				//преобразуем в WGS WKT строку
				obj.WKT = format.writeGeometry(geometry)
			}
		}
	}
	return dataArr;
};


/**
 * Проверка, пересекаются ли геометрии
 * @param cadGeo
 * @param bufferGeo
 * @returns {Array}
 */
GeoUtil.checkCadastreInBuffer = function(cadGeo, bufferGeo){
	var polygon1,polygon2,features;
	var result = {geo:undefined, error:''};
	try{
		if(cadGeo instanceof ol.geom.GeometryCollection)
			polygon1 =  new ol.Feature(cadGeo.getGeometries()[0]);
		else
			polygon1 = new ol.Feature(cadGeo);
		polygon2 = new ol.Feature(bufferGeo);
		var format = new ol.format.GeoJSON();
		var fpolygon1 =  format.writeFeatureObject(polygon1);
		var fpolygon2 =  format.writeFeatureObject(polygon2);
		//fpolygon2.geometry.coordinates[0].splice(fpolygon2.geometry.coordinates[0].length-2);
		//fpolygon2.geometry.coordinates[0].push(fpolygon2.geometry.coordinates[0][0]);
		var intersection = turf.intersect(fpolygon1,fpolygon2);
		if(goog.isDef(intersection)){
			features = format.readFeaturesFromObject(intersection);
		}
		result.geo = features;
		return result;
	}
	catch(ex){
		result.error = ex.message;
	}
	return result;
};

/**
 * Перевод тайла в географические координаты
 * @param x долгота
 * @param z масштаб
 * @returns {number}
 * @constructor
 */
GeoUtil.Tile2Longitude = function(x,z) {
	return (x/Math.pow(2,z)*360-180);
};

/**
 * Перевод тайла в географические координаты
 * @param y широта
 * @param z масштаб
 * @returns {number}
 * @constructor
 */
GeoUtil.Tile2Latitude = function(y,z) {
	var n=Math.PI-2*Math.PI*y/Math.pow(2,z);
	return (180/Math.PI*Math.atan(0.5*(Math.exp(n)-Math.exp(-n))));
};
/**
 * Вычисление ближайшей точки до прямой
 */
GeoUtil.getClosestPointForGeo = function(objForBind, pointCoord) {
	//рассчитываем ближайшее расстояние до каждого из отрезков прямой
	//Координаты сначала переводятся из проекции базового слоя карты в метровую,
	//затем рассчитывается привязка, а потом полученные координаты привязки переводятся в проекцию базового слоя карты
	if(goog.isDef(objForBind.geo) && (objForBind.geo.getGeometry().getType() === ol.geom.GeometryType.LINE_STRING
		|| objForBind.geo.getGeometry().getType() === ol.geom.GeometryType.POLYGON)) {
		var minDist1 = Number.POSITIVE_INFINITY;
		var closestSegment1 = null;
		var srcPntArr1;
		var coeff1 = 0;
		//дополнительные переменные для привязки линейного EVENT_RANGE
		srcPntArr1 = pointCoord;//текущее положение курсора
		//получаем сегменты линии
		var point1;
		var point2;
		var lineCoordinates = objForBind.geo.getGeometry().getCoordinates();
		var numSegs = lineCoordinates.length;
		if(objForBind.geo.getGeometry().getType() === ol.geom.GeometryType.POLYGON && lineCoordinates.length > 0){
			numSegs = lineCoordinates[0].length;
			lineCoordinates = lineCoordinates[0];
		}

		var pos1 = -1;
		var i = 0;
		//var pp = ol.coordinate.closestOnSegment(lineCoordinates,)
		for (; i < numSegs - 1; ++i) {
			point1 = lineCoordinates[i];
			point2 = lineCoordinates[i + 1];
			//Длина текущего отрезка
			var segmentLength = GeoUtil.Distance(point1, point2);
			//рассчитываем ближайшее расстояние от нашей точки до текущего отрезка
			var calcDist1 = GeoUtil.LineToPointDistance2D(point1, point2, srcPntArr1, true);
			if (calcDist1 < minDist1) {
				var srcPoint1ToPoint1Dist = GeoUtil.Distance(point1, srcPntArr1);
				var srcPoint1ToPoint2Dist = GeoUtil.Distance(point2, srcPntArr1);
				//рассчитываем коэффициент отношения длины от начальной точки до точки проекции на отрезок к длине отрезка
				//Если длина от нашей точки до отрезка равна длине от нашей точки до одной из 2-х точек отрезка coeff1 = 0 если точка первая и coeff1 = 1 если точка последняя
				if (calcDist1 === srcPoint1ToPoint1Dist)
					coeff1 = 0;
				else if (calcDist1 === srcPoint1ToPoint2Dist)
					coeff1 = 1;
				else
					coeff1 = Math.sqrt(Math.pow(srcPoint1ToPoint1Dist, 2) - Math.pow(calcDist1, 2)) / segmentLength;
				//Сохраняем текущую дистанцию как минимальную, текущий отрезок как ближайший
				minDist1 = calcDist1;
				closestSegment1 = [point1, point2];
				//тут ещё можно посчитать координаты точки пересечения
				pos1 = i;
			}
		}
		if (!goog.isNull(closestSegment1)) {
			// closestsegment1 - найти проекцию
			var newPointProj = ol.coordinate.closestOnSegment(srcPntArr1, closestSegment1);
			return {segment: closestSegment1, geo: objForBind.geo, position: pos1, point: newPointProj, coeff: coeff1};
		}
	}
	return undefined;
};

GeoUtil.getIntersectedRouteGeometry = function(geometry, extent, routeId, routeLabel){
	var result = [];
	goog.asserts.assert(goog.isDefAndNotNull(geometry),
		'feature geometry is defined and not null');
	switch(geometry.getType()){
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			var i, ii;
			var ends = geometry.ends_;
			var offset = 0;
			if(goog.isDef(globalLinesLabels_[feature.get('labelType')])){
				for (i = 0, ii = ends.length; i < ii; ++i) {
					var geo = globalLinesLabels_[feature.get('labelType')][i].geo;
					if(geo === undefined)
						continue;
					var geoExcent = geo.getExtent();
					if(!ol.extent.intersects(geoExcent, extent))
						continue;
					/*if (GeoUtil.lineString(geometry.flatCoordinates, offset, ends[i], geometry.stride, extent, geoExcent)) {*/
					if (ol.geom.flat.intersectsextent.lineString(
						geometry.flatCoordinates, offset, ends[i], geometry.stride, extent)) {
						var obj =  jQuery.extend({}, globalLinesLabels_[feature.get('labelType')][i]);
						var geosArr = [];
						if(goog.isDef(obj.id)){
							var testId = obj.id;
							if(obj.id.indexOf('@')!=-1)
								testId = obj.id.substring(0, obj.id.indexOf('@'));
							var r=0;
							//проверяем, обрабатывался ли ранее этот id, когда ткнули в объект с @, если да, то пропускаем
							var rFinded = false;
							for(;r<result.length;r++){
								if(goog.isDef(result[r].id) && result[r].id == testId){
									rFinded = true;
									break;
								}
							}
							if(rFinded)
								continue;
							geosArr.push(geometry.getLineString(i).clone());
							if( obj.id.indexOf('@')!=-1){
								//проходимся по добавленным объектам. Если нашли объект, то игнорируем, если не нашли, то
								//ищем основной и добавляем его
								var fullId = obj.id.substring(0, obj.id.indexOf('@'));
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
								obj.id = fullId;
							}
							else{
								//доп. проверка. Если в id есть @, значит работам с мультиобъектом из gdal
								//если нет @ - значит это основной объект и ищем все геометрии связанные с ним
								var fullId = obj.id;
								//проходимся по всем остальным связанным объектам
								var t,tt;
								for (t = 0, tt = ends.length; t < tt; ++t) {
									if(t == i) //пропускаем индекс объекта, найденного выше
										continue;
									//если количество отображаемых объектов в слое меньше, чем количество загруженных(фильтрация - оставить выбранные)
									//, выбираем из этого списка
									var newObj;
									if(globalLinesLabels_[feature.get('labelType')].length>feature.get('labelsObj').length){
										newObj = feature.get('labelsObj')[t];
									}
									else{
										newObj = globalLinesLabels_[feature.get('labelType')][t];
									}
									if(goog.isDef(newObj) && goog.isDef(newObj.id) && (newObj.id.indexOf(fullId+'@')!=-1 || newObj.id == fullId)){//нужный id
										geosArr.push(geometry.getLineString(t).clone());
									}
								}
							}
						}

						if(geosArr.length == 1)
							obj.geo = new ol.Feature(geosArr[0].clone());
						else{
							var gm = new ol.geom.MultiLineString(null);
							gm.setLineStrings(geosArr);
							obj.geo = new ol.Feature(gm);
						}
						obj.feature = feature;
						result.push(obj);
					}
				}
			}
			offset = ends[i];
			break;
		case ol.geom.GeometryType.LINE_STRING:
			ol.geom.flat.intersectsextent.lineString(
				geometry.flatCoordinates, 0, geometry.ends_, geometry.stride, extent);
			var obj = {};
			obj.geo = geometry.clone();
			obj.id = routeId;
			obj.label = routeLabel;
			result.push(obj);
			break;
	}
	return result;
};

/**
 * Вычисление ближайшей точки до прямой
 */
GeoUtil.getClosestRoutePointForGeo = function(objForBind, pointCoord) {
	//рассчитываем ближайшее расстояние до каждого из отрезков прямой
	//Координаты сначала переводятся из проекции базового слоя карты в метровую,
	//затем рассчитывается привязка, а потом полученные координаты привязки переводятся в проекцию базового слоя карты
	if(goog.isDef(objForBind.geo) && objForBind.geo.getType() === ol.geom.GeometryType.LINE_STRING) {
		var minDist1 = Number.POSITIVE_INFINITY;
		var closestSegment1 = null;
		var srcPntArr1;
		var coeff1 = 0;
		//дополнительные переменные для привязки линейного EVENT_RANGE
		srcPntArr1 = pointCoord;//текущее положение курсора
		//получаем сегменты линии
		var point1;
		var point2;
		var lineCoordinates = objForBind.geo.getCoordinates();
		var numSegs = lineCoordinates.length;
		var pos1 = -1;
		var i = 0;
		//var pp = ol.coordinate.closestOnSegment(lineCoordinates,)
		for (; i < numSegs - 1; ++i) {
			point1 = lineCoordinates[i];
			point2 = lineCoordinates[i + 1];
			//Длина текущего отрезка
			var segmentLength = GeoUtil.Distance(point1, point2);
			//рассчитываем ближайшее расстояние от нашей точки до текущего отрезка
			var calcDist1 = GeoUtil.LineToPointDistance2D(point1, point2, srcPntArr1, true);
			if (calcDist1 < minDist1) {
				var srcPoint1ToPoint1Dist = GeoUtil.Distance(point1, srcPntArr1);
				var srcPoint1ToPoint2Dist = GeoUtil.Distance(point2, srcPntArr1);
				//рассчитываем коэффициент отношения длины от начальной точки до точки проекции на отрезок к длине отрезка
				//Если длина от нашей точки до отрезка равна длине от нашей точки до одной из 2-х точек отрезка coeff1 = 0 если точка первая и coeff1 = 1 если точка последняя
				if (calcDist1 === srcPoint1ToPoint1Dist)
					coeff1 = 0;
				else if (calcDist1 === srcPoint1ToPoint2Dist)
					coeff1 = 1;
				else
					coeff1 = Math.sqrt(Math.pow(srcPoint1ToPoint1Dist, 2) - Math.pow(calcDist1, 2)) / segmentLength;
				//Сохраняем текущую дистанцию как минимальную, текущий отрезок как ближайший
				minDist1 = calcDist1;
				closestSegment1 = [point1, point2];
				//тут ещё можно посчитать координаты точки пересечения
				pos1 = i;
			}
		}
		if (!goog.isNull(closestSegment1)) {
			// closestsegment1 - найти проекцию
			var newPointProj = ol.coordinate.closestOnSegment(srcPntArr1, closestSegment1);
			return {segment: closestSegment1, geo: objForBind.geo, position: pos1, point: newPointProj, coeff: coeff1};
		}
	}
	return undefined;
};


/**
 * Перевод десятичные градусы в градусы
 */
GeoUtil.convertDecimalIntoDegree = function (text) {
	//ex. 56.530865
	var n = parseFloat(text);
	if(isNaN(n))
		return '';
	var dd = parseInt(text);//градус
	var mm = parseInt((n - dd) * 60);//минуты
	var ss = ((n - dd) * 60 - mm) * 60;
	//ss = parseInt(ss*100);//Math.round(60*(n - dd)*60 - parseInt(n - parseInt(n))*60) ;//секунды
	ss = ss.toFixed(2);
	if (dd < 10)
		dd = '0' + dd;
	dd = dd + '° ';
	if (mm < 10)
		mm = '0' + mm;
	mm = mm + "' ";
	if (ss < 10)
		ss = '0' + ss;
	ss = ss + "''";
	return dd + mm + ss;

	/*var n = parseFloat(text);
	var dd = parseInt(n);
	var ddS = (dd<10)?'0'+dd:dd;
	var mm = parseInt((n-dd)*60);
	var mmS = (mm<10)?'0'+mm:mm;
	var ss = parseInt((n - dd - mm/60)*3600);
	return ""+ddS+"°"+mmS+"\""+ss+'\'';*/
};


/**
 * Перевод градусы в десятичные градусы
 */
GeoUtil.convertDegreeIntoDecimal = function (text) {
	var dd = text.split('°')[0];
	dd = dd.replace('_', '0').replace('_', '0');
	var mm = text.split('°')[1].split("'")[0];
	mm = mm.replace('_', '0').replace('_', '0');
	var ss = text.split('°')[1].split("'")[1];
	ss = ss.replace('_', '0').replace('_', '0').replace('_', '0').replace('_', '0');

	var ddD = parseFloat(dd);
	var mmD = parseFloat(mm);
	var ssD = parseFloat(ss);
	if(isNaN(ddD) || isNaN(mmD) || isNaN(ssD))
		return -1;
	var resDD = Math.round(100000 * (ddD + mmD / 60 + ssD / 3600)) / 100000;
	return resDD;
};

/**
 * Переводим десятичные градусы в градусы в массиве объектов вида {latitude:22, longitude:22}
 */
GeoUtil.convertArrayDecimalIntoDegree = function (array) {
	for (var i = 0; i <= array.length; i++) {
		array[i].longitude = GeoUtil.convertDecimalIntoDegree(array[i].longitude);
		array[i].longitude = GeoUtil.convertDecimalIntoDegree(array[i].latitude);
	}
	return array;
};

/**
 * Переводим градусы в десятичные градусы в массиве объектов вида {latitude:22, longitude:22}
 */
GeoUtil.convertArrayDegreeIntoDecimal = function (array) {
	for (var i = 0; i <= array.length; i++) {
		array[i].longitude = GeoUtil.convertDegreeIntoDecimal(array[i].longitude);
		array[i].longitude = GeoUtil.convertDegreeIntoDecimal(array[i].latitude);
	}
	return array;
};


GeoUtil.getFontSizeByCharWidth = function(charWidth){
	return parseInt(''+(charWidth*20/11));
	if(charWidth < 10)
		return 12;
	if(charWidth < 12)
		return 20;
	if(charWidth < 14)
		return 24;
	if(charWidth < 14)
		return 24;
	/*if(charWidth < 10)
		return 12;
	if(charWidth < 10)
		return 12;*/
	return 12;
};

/**
 * Функция вырезает точки переданной геометрии, которые попали в полигон
 * @param baseGeometry
 * @param polygon
 * @returns {*}
 */
GeoUtil.truncateGeometry = function(baseGeometry, polygonGeometry) {
	var newGeometry = baseGeometry;
	if(baseGeometry){
		var coords = baseGeometry.getCoordinates();
		var newCoords = [];
		if(baseGeometry.getType() === ol.geom.GeometryType.POINT){
			if(!polygonGeometry.containsCoordinate(coords))
				newCoords.push(coords);
			newGeometry.setFlatCoordinates(newGeometry.layout, newCoords);
		}
		else if(baseGeometry.getType() === ol.geom.GeometryType.LINE_STRING){
			coords.forEach(function (coord) {
				if (!polygonGeometry.containsCoordinate(coord))
					newCoords.push(coord);
			})
			if(newCoords.length < 2){
				//обнуляем геометрию, т.к. 2 координаты в полигоне
				newCoords = [];
			}
			newGeometry.setCoordinates(newCoords, newGeometry.layout);
		}
		else {
			if(coords.length > 0){
				coords.forEach(function (pCoords) {
					pCoords.forEach(function (coord) {
						if (!polygonGeometry.containsCoordinate(coord)){
							newCoords.push(coord[0],coord[1]);
						}

					});
				});
			}
			if(newCoords.length >= 6){  //3*2 координаты
				//проверяем, что 1-я и последняя координаты совпадают. Если нет - дописываем
				if(!(newCoords[0] === newCoords[newCoords.length - 2] && newCoords[1] === newCoords[newCoords.length - 1]))
					newCoords.push(newCoords[0], newCoords[1]);
			}else{
				//обнуляем геометрию, т.к. 2 координаты в полигоне
				newCoords = [];
			}
			//newGeometry.setCoordinates(newCoords, newGeometry.layout);
			newGeometry.setFlatCoordinates(newGeometry.layout, newCoords, [newCoords.length]);
		}
	}
	return newGeometry;
}

/**
 * Функция вырезает точки переданной геометрии, которые extent
 * @param baseGeometry
 * @param extent
 * @returns {*}
 */
GeoUtil.truncateGeometryByExtent = function(baseGeometry, extent) {
	var newGeometry = baseGeometry;
	if(baseGeometry){
		var coords = baseGeometry.getCoordinates();
		var newCoords = [];
		if(baseGeometry.getType() === ol.geom.GeometryType.POINT){
			if(!ol.extent.containsCoordinate(extent,coords))
				newCoords = coords;
			newGeometry.setFlatCoordinates(newGeometry.layout, newCoords);
		}
		else if(baseGeometry.getType() === ol.geom.GeometryType.LINE_STRING){
			coords.forEach(function (coord) {
				if (!ol.extent.containsCoordinate(extent, coord))
					newCoords.push(coord);
			})
			if(newCoords.length < 2){
				//обнуляем геометрию, т.к. 2 координаты в полигоне
				newCoords = [];
			}
			newGeometry.setCoordinates(newCoords, newGeometry.layout);
		}
		else {

			if(coords.length > 0){
				coords.forEach(function (pCoords) {
					var firstCoord = pCoords[0], endCoord = pCoords[pCoords.length - 1]; //первая и последняя координаты, совпадают у полигона
					pCoords.forEach(function (coord, i) {
						if (!ol.extent.containsCoordinate(extent, coord)){
							newCoords.push(coord[0],coord[1]);
						}
					});
				});
			}
			if(newCoords.length >= 6){  //3*2 координаты
				//проверяем, что 1-я и последняя координаты совпадают. Если нет - дописываем
				if(!(newCoords[0] === newCoords[newCoords.length - 2] && newCoords[1] === newCoords[newCoords.length - 1]))
					newCoords.push(newCoords[0], newCoords[1]);
			}else{
				//обнуляем геометрию, т.к. 2 координаты в полигоне
				newCoords = [];
			}
			//newGeometry.setCoordinates(newCoords, newGeometry.layout);
			newGeometry.setFlatCoordinates(newGeometry.layout, newCoords, [newCoords.length]);
		}

	}
	return newGeometry;
}

/**
 * Получение координат по введенной строке.
 * Формат координат допускается либо в десятичном виде(57.8527438000 55.0096917000), либо обычном(55°22'15.94'' 57°50'41.10'')
 *
 * @param str
 */
GeoUtil.getCoordsByString = function(str){
	var maskLat = /^(-?[1-8]?\d(?:\.\d{1,18})?|90(?:\.0{1,18})?)$/;
	var maskLon = /^(-?(?:1[0-7]|[1-9])?\d(?:\.\d{1,18})?|180(?:\.0{1,18})?)$/;
	if(str){
		var lat = '', lon = '';
		var coordsSp = str.trim().split(' ');
		coordsSp.forEach(function(item){
			if(item !== '')
				if(lon === '')
					lon = item;
				else
					lat = item;
		});
		if(lat.match(maskLat) && lon.match(maskLon))
			return {y:lon, x:lat};
	}
}

GeoUtil.getFlatGeometry = function(baseFeature){
	if(!baseFeature)
		return;
	var coords = undefined;
	try{
		if (!baseFeature.getGeometry)// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
			baseFeature = new ol.Feature(baseFeature);
		var geometry = baseFeature.getGeometry();
		if(!geometry)
			return;

		switch(geometry.getType()){
			case ol.geom.GeometryType.LINE_STRING :
				coords = geometry;
				break;
			case ol.geom.GeometryType.POINT :
				coords = geometry.flatCoordinates;
				break;
			case ol.geom.GeometryType.POLYGON :
				var pp = new ol.geom.Polygon(null);
				var linearRing = new ol.geom.LinearRing(null);
				linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, geometry.flatCoordinates);
				pp.appendLinearRing(linearRing);
				coords = pp;
				break;
		}
	}
	catch(ex){ }
	return coords;
}

/**
 *
 * @param feature фича для клонирования
 * @param withGeo флаг, нужно ли копировать геометрию
 * @returns {ol.Feature}
 */
GeoUtil.cloneFeature = function (feature, withGeo, recreateGeo) {
	var clone = new ol.Feature(feature.getProperties());
	clone.setGeometryName(feature.getGeometryName());
	if (withGeo) {
		var geometry = feature.getGeometry();
		if (geometry) {
			//если тип полигов
			if(recreateGeo && geometry.getType() === ol.geom.GeometryType.POLYGON){
				var polygon = new ol.geom.Polygon(null);
				polygon.setFlatCoordinates(geometry.layout, geometry.flatCoordinates,
					[geometry.flatCoordinates.length]);
				clone.setGeometry(polygon);
			}
			else
				clone.setGeometry(geometry.clone());
		}
	}
	var style = feature.getStyle();
	if (style) {
		clone.setStyle(style);
	}
	return clone;
};

/**
 * Функция для переподготовки геометрии полигона, который резался, чтобы не сбивались endss при рисовании на карте
 * @param feature
 * @returns {*}
 */
GeoUtil.recreateFeatureGeometry = function (feature) {
	//если тип полигов
	var newFeature = feature;
	var geometry = feature.getGeometry();
	if(geometry.getType() === ol.geom.GeometryType.POLYGON){
		var polygon = new ol.geom.Polygon(null);
		polygon.setFlatCoordinates(geometry.layout, geometry.flatCoordinates,
			[geometry.flatCoordinates.length]);
		newFeature.setGeometry(polygon);
	}
	else
		newFeature.setGeometry(geometry.clone());
	return newFeature;
};



/**
 * Функция корректирует положение подписи на техсхеме для слоя капитальных ремонтов
 *
 * @param {Object} lay Объект слоя LayerManager.getLayerByName
 * @param {ol.Geometry} geometry геометрия рисуемого объекта(линия, точка)
 * @param {number} x базовая координата подписи в пикселах
 * @param {number} y базовая координата подписи в пикселах
 * @param {Object} shift  объект с положением линии и текстом {position:1, text:''}
 * @param {number} textWidth ширина текста
 * @param {number} mapZoom масштаб карты
 * @returns {{x, y}}
 */
GeoUtil.kapRemAdjustment = function(lay, geometry, x, y, shift, textWidth, mapZoom){
	var labelCollisionPercent = 0.3;// 30%
	if(lay && lay.id === 'KAP_REMONT_PLAN' && geometry && mapZoom > 7){
		var extent = geometry.getExtent();
		// в кпг линия с диагональным перепадом, то рисуем подпись в конце линии(трубы идут справо налево)
		var isDiagLine = (1 - extent[1]/extent[3]) > 0.001;
		if(isDiagLine){
			var lastCoord = WidgetMap.map.getPixelFromCoordinate([geometry.flatCoordinates[geometry.flatCoordinates.length - 2],geometry.flatCoordinates[geometry.flatCoordinates.length - 1]]);
			x = lastCoord[0] + textWidth/2;
			y = lastCoord[1];
		}
		else if(shift && shift.position !== 0 && mapZoom < 10){
			var newX, newY;
			var position = shift.position;
			var firstTextPx = x;
			var lastGeoPx = WidgetMap.map.getPixelFromCoordinate([extent[2],extent[3]])[0];
			var firstGeoPx = WidgetMap.map.getPixelFromCoordinate([extent[0],extent[1]])[0];
			newX = x + textWidth * position;
			//если начало подписи выходит за линию, то двигаем её в обратную сторону влево
			if(newX > lastGeoPx){
				newX = x - textWidth/2;
				if(newX > firstGeoPx){
					x = newX;
				}
				else if(position % 2 !== 0) //если и влево выходит за пределы и position четная, тоне рисуем подпись
					x = NaN;
			}
			else if(newX > firstGeoPx){
				x = x + textWidth * position;
			}
		}
	}

	return {x: x, y:y};
}

//TODO перенести данные функции в файл утилит по canvasreplay

/**
 * Функция формирования линии по видимой рамке карты, чтобы подписывания начинались именно с границ видимой области карты
 * @param lineString
 * @param mapExtent
 * @param isPods //TODO upd. 09.02.22 в рамках работы по задаче "карта водного перехода" принято решение
 * пока хардкодить условие отображение(30px) подписи по названию PODS
 * @returns {*}
 */
GeoUtil.composeLineStringByExtent = function(lineString, mapExtent, isPods){
	isPods = isPods === true;
	if(!lineString)
		return;
	//если линия не пересекает рамку карты, не включаем её в выдачу
	if(!lineString.intersectsExtent(mapExtent))
		return;
	var geometryExtent = lineString.getExtent();
	//Обрезаем линии по рамке
	var coordinates = lineString.getCoordinates();
	var intersects = Intersection.lineclip(coordinates, mapExtent);
	var geometry = undefined;
	var geometries = [];
	var resolution = WidgetMap.map.getView().getResolution();
	if(intersects && intersects.length > 0){
		geometry = new ol.geom.LineString(intersects[0], ol.geom.GeometryLayout.XY);
		geometryExtent = geometry.getExtent();
		//проверяем, что если линия меньше допустимого размера, то не выдаем её
		var lineD = Math.sqrt(ol.extent.getWidth(geometryExtent) * ol.extent.getWidth(geometryExtent) + ol.extent.getHeight(geometryExtent) * ol.extent.getHeight(geometryExtent));
		lineD /= resolution;
		//upd. 02.09.21 если длина линии меньше 30px(размер иконки для визуального сравнения), то подпись не выводим(нет смысла для труб выводить такую подпись)
		if (lineD >= 30 || !isPods)
			geometries.push(geometry);
	}
	if(geometries && geometries.length > 0)
		return geometries;
}


GeoUtil.getLineStringsByStartPoint = function(lineString, startPoint, textWidth, findSector){
	if(!lineString)
		return [];
	if(!findSector)findSector = 'right';
	var offset = 10; //увеличиваем у рамки область захвата
	//рамка вокруг точки
	var leftOffset = (findSector === 'left') ? textWidth + offset : 0;
	var rightOffset = (findSector === 'right') ? textWidth + offset : 0;
	var pointExtent = [startPoint[0] - leftOffset, startPoint[1] - textWidth - offset, startPoint[0] + rightOffset, startPoint[1] + textWidth + offset];
	//Обрезаем линии по рамке
	var coordinates = lineString.getCoordinates();
	var geometries = [];
	var intersects = Intersection.lineclip(coordinates, pointExtent);
	var geometry = undefined;

	if(intersects && intersects.length > 0) {
		geometry = new ol.geom.LineString(intersects[0], ol.geom.GeometryLayout.XY);
		geometries.push(geometry);
	}
	return geometries;
}

/**
 * Получение координаты на прямой по двум точкам и дистанции от 1-й точки
 * @param pnt1
 * @param pnt2
 * @param distance
 * @returns {*[]}
 */
GeoUtil.getCoordsByDistance = function(pnt1, pnt2, distance){
	if(!pnt1 || !pnt2) return;
	var theta = Math.atan2(pnt2[1] - pnt1[1], pnt2[0] - pnt1[0]);
	return [pnt1[0] + distance * Math.cos(theta), pnt1[1] + distance * Math.sin(theta)];
}




GeoUtil.rotateLineTextBy2Points = function (p1, p2) {
	var p1,p2, x, y;
	var tempP = p1;
	if (p1[0] > p2[0]) {
		p1 = p2;
		p2 = tempP;
	}
	var rotation = 0;
	if (p1 !== null && p2 !== null) {
		rotation = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) * 180 / Math.PI;
	}
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return [x, y, rotation];
};


/**
 * Разбиваем линию на отрезки, чтобы производить рисование подписи в рамках каждого отрезка.
 * Во время разбития возвращаем вектор подписи с корректным сдвигом по горизонтали.
 * TODO для вертикальных сдвигов пока принято решение не сдвигать
 * Зависимость от map_label_repeatRatio
 * @param {{startPoint: Array<number>, lineString: ol.geom.LineString}} startPointOptions
 * @param textObject
 * @param isCasUnits
 * @return {Array<map.renderer.vector.TextVector>}
 */
GeoUtil.composeTextVectorFromStartPoint = function(startPointOptions, textObject, isCasUnits, needTransform){
	if(!startPointOptions || startPointOptions.startPoint === undefined)
		return;
	var segmentCoords = [], lineString = startPointOptions.lineString, startPoint = startPointOptions.startPoint;
	var coords = lineString.getCoordinates();
	//переводим координаты линии в пикселы
	for(var i = 0; i < coords.length; i++) {
		var pnt = (needTransform !== false)?WidgetMap.map.getPixelFromCoordinate(coords[i]):coords[i];
		segmentCoords.push([pnt[0], pnt[1]]);
	}
	return GeoUtil.createTextVector(startPoint, segmentCoords, textObject, isCasUnits);
}

GeoUtil.getLength = function(coords){
	var length = -1;
	for(var i = 1; i < coords.length; i++) {
		var pnt1 = WidgetMap.map.getPixelFromCoordinate(coords[i - 1]);
		var pnt2 = WidgetMap.map.getPixelFromCoordinate(coords[i]);
		var distanceP1P2 = Math.sqrt(ol.coordinate.squaredDistance(pnt1, pnt2));
		length += distanceP1P2;
	}
	return length;
}

/**
 * Создание объекта вектора текста
 * @param startPoint начальная точка от которой начинать рисовать
 * @param segmentCoords
 * @param textObject
 * @param isCasUnits
 * @returns {map.renderer.vector.TextVector|undefined}
 */
GeoUtil.createTextVector = function(startPoint, segmentCoords, textObject, isCasUnits){
	if(!textObject)
		return;
	var textStyle = textObject.textStyle;
	var textWidth = textObject.textWidth;
	var textHeight = 12;
	var lineString = new ol.geom.LineString(null);
	lineString.setCoordinates(segmentCoords, ol.geom.GeometryLayout.XY);
	//пункт 5. Вращение. Определение второй точки вектора подписи
	var rotation = GeoUtil.rotateLineText(startPoint, lineString, textWidth);
	if(textObject.isTextObject){//если надпись
		rotation = GeoUtil.rotateLineTextObject(startPoint, lineString, textWidth);
	}
	if(isNaN(rotation))
		return;
	var x = startPoint[0];//координаты без смещения
	var y = startPoint[1];
	var bounds = [];//полигон
	var textProp = {
		rotation: rotation,
		textWidth: textWidth,
		textHeight: textHeight,
		text: textObject.text,
		isTextObject: textObject.isTextObject,
	};
	var text = textObject.text;
	var labelDrawType = LABEL_DRAW_TYPE;
	if (isCasUnits) labelDrawType = 'cas_units';
	if (labelDrawType === 'cut' ){
		var cutObj = GeoUtil.cutText(textProp, segmentCoords, x, y);
		if(!cutObj) return;
		text = cutObj.text;
		bounds = cutObj.bounds;
		var coordEnd = cutObj.coordEnd;
	}

	var textVector = new map.renderer.vector.TextVector({
		text: text, x: x, y: y, coordEnd: coordEnd,
		rotation: rotation,
		lineString: lineString,
		textStyle: textStyle,
		textWidth: textWidth,
		textHeight: textHeight,
		bounds: bounds,
	});

	return textVector;
}

/**
 * Функция выссчитывает начальное положение точки
 * @param lineString
 * @param align
 * @param mapWidth
 * @returns {{startPoint: Array<number>, lineString: ol.geom.LineString}}
 */
GeoUtil.alignText = function(lineString, align, mapWidth, textWidth, text){
	//var textAlign = align || 'center';
	var textAlign = 'center';
	var p1;
	var tries = 1;
	if(textAlign === 'center'){
		p1 = lineString.getFlatMidpoint();//GeoUtil.findCenter(lineString, distance);
		p1 = WidgetMap.map.getPixelFromCoordinate(p1);
		//получение начальной точки, чтобы подпись рисовалась ровно по центру
		var startPointObj = GeoUtil.getRealStartPoint(lineString, p1, textWidth, text);
		if(startPointObj && startPointObj.startPoint){
			p1 = startPointObj.startPoint;
			tries = startPointObj.tries;
		}
	}
	return {startPoint: p1, lineString: lineString, tries:tries};
}

GeoUtil.alignTextObject = function(lineString, align){
	var textAlign = align || 'right';
	var p1, p2;
	if(textAlign === 'left'){
		p1 = WidgetMap.map.getPixelFromCoordinate([lineString.flatCoordinates[0], lineString.flatCoordinates[1]]);
		/*p2 =  lineString.flatCoordinates[lineString.flatCoordinates.length - 1];
		if(p1[0] > p2[0])
			p1 = p2;*/
	}
	/*if(textAlign === 'right'){
		p1 = lineString.flatCoordinates[lineString.flatCoordinates.length - 1];
		p2 = lineString.flatCoordinates[0];
		if(p1[0] > p2[0])
			p1 = p2;
	}*/
	return {startPoint: p1, lineString: lineString, tries:1};
}

/**
 * Функция получения реального центра линии, чтобы подпись рисовалась ровно по центру
 * @param fLineString
 * @param center
 * @param radius
 */
GeoUtil.getRealStartPoint = function(fLineString, center, radius, text){
	var coords = fLineString.getCoordinates();
	//переводим координаты линии в пикселы
	var segmentCoords = [];
	for(var i = 0; i < coords.length; i++) {
		var pnt = WidgetMap.map.getPixelFromCoordinate(coords[i])
		segmentCoords.push([pnt[0], pnt[1]]);
	}
	var lineString = new ol.geom.LineString(null);
	lineString.setCoordinates(segmentCoords, ol.geom.GeometryLayout.XY);
	//проводим поиск точек пересечения сначала в левой части
	var textWidth = radius;
	var startPoint = GeoUtil.getPointOnLineByCenterAndRadius(center, lineString, textWidth/2, 'left');
	var tries = 1; //попытки обрезки
	//доп. проверка. если не нашли точку стартовую, то сокращаем размер подписи и пытаемся найти заново
	if(startPoint === undefined){
		for(var i = 0; i < 3; i++){
			textWidth -= textWidth * LABEL_CUT_RATIO;
			startPoint = GeoUtil.getPointOnLineByCenterAndRadius(center, lineString, textWidth/2, 'left');
			tries++;
			if(startPoint !== undefined)
				break;
		}
	}
	if(startPoint === undefined)
		return undefined;
	return {startPoint: startPoint, tries: tries};
	//если не нашли в левой части - ищем внизу
}


/**
 *
 * @param startPoint
 * @param fLineString
 * @param textWidth
 * @param findSector сектор, в котором ищется точки пересечения  left|right|top|bottom
 * @returns {number[]}
 */
GeoUtil.getPointOnLineByCenterAndRadius = function(startPoint, fLineString, textWidth, findSector){
	if(!findSector) findSector = 'right';
	//формируем рамку у начальной точки, как по ширине подписи * 2( 2 * R )
	var subLineStrings = GeoUtil.getLineStringsByStartPoint(fLineString, startPoint, textWidth, findSector);
	//проходимся по сегментам и ищем точки пересечения с отрезками сегментов
	var intersectPoints = [];
	for(var i = 0; i < subLineStrings.length; i++){
		var subLineString = subLineStrings[i];
		var subLineStringCoords = subLineString.getCoordinates();
		for(var j = 0; j < subLineStringCoords.length - 1; j++){
			//получаем отрезок и ищем точки пересечения
			var segment = [subLineStringCoords[j], subLineStringCoords[j + 1]];
			var segmentIntersects  = GeoUtil.intersectCircleAndSegment(segment, startPoint, textWidth)
			if(!segmentIntersects)
				continue;
			var segmentString = new ol.geom.LineString(null);
			segmentString.setCoordinates(segment, ol.geom.GeometryLayout.XY);
			//получили рамку отрезка, чтобы при выборке на те пересечения, которые попадают в рамку
			var segmentExtent = segmentString.getExtent();
			var intersects = GeoUtil.getIntersectionBetweenCircleAndLine(segmentString, startPoint, textWidth);
			if(intersects)
				intersects.forEach(function(point){
					//пункт 5.2 из массива точек убираем точки левее, т.е. оставляем точки только в правом секторе
					if (findSector === 'right' && point[0] >= startPoint[0]){
						var pointExtent = [point[0],point[1],point[0],point[1]];
						if(ol.extent.intersects(pointExtent, segmentExtent))
							intersectPoints.push(point);
					}
					if (findSector === 'left' && point[0] <= startPoint[0]){
						var pointExtent = [point[0],point[1],point[0],point[1]];
						if(ol.extent.intersects(pointExtent, segmentExtent))
							intersectPoints.push(point);
					}
				});
		}
	}
	//пункт 5.3 сортируем оставшиеся точки и выбираем максимальный Y
	var secondPoint = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
	intersectPoints.forEach(function(point){
		if(point[1] >= secondPoint[1])
			secondPoint = point;
	});

	//если не нашли при повороте точку пересечения с отрезком
	if(secondPoint[0] === Number.NEGATIVE_INFINITY || secondPoint[1] === Number.NEGATIVE_INFINITY)
		return;
	return secondPoint;
}

/**
 * Поворот подписи по начальной точке
 * @param startPoint начальная точка
 * @param fLineString линий, на которой подпись рисуется
 * @param textWidth
 * @returns {number}
 */
GeoUtil.rotateLineText = function (startPoint, fLineString, textWidth) {
	var secondPoint = GeoUtil.getPointOnLineByCenterAndRadius(startPoint, fLineString, textWidth);
	if(secondPoint === undefined){
		for(var i = 0; i < 3; i++){
			textWidth -= textWidth * LABEL_CUT_RATIO;
			secondPoint = GeoUtil.getPointOnLineByCenterAndRadius(startPoint, fLineString, textWidth);
			if(secondPoint !== undefined)
				break;
		}
	}
	if(secondPoint === undefined)
		return NaN;

	var rotation = Math.atan2(secondPoint[1] - startPoint[1], secondPoint[0] - startPoint[0]) * 180 / Math.PI;
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return rotation;
};

/**
 * Поворот подписи по начальной точке
 * @param startPoint начальная точка
 * @param fLineString линий, на которой подпись рисуется
 * @param textWidth
 * @returns {number}
 */
GeoUtil.rotateLineTextObject = function (startPoint, fLineString, textWidth) {
	var lineCoords =  fLineString.getCoordinates();
	var secondPoint = lineCoords[lineCoords.length - 1];
	var rotation = Math.atan2(secondPoint[1] - startPoint[1], secondPoint[0] - startPoint[0]) * 180 / Math.PI;
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return rotation;
};

/**
 * Поворот подписи вдоль линии
 * @param segmentCoords
 * @param width
 * @param height
 * @param vAlign
 * @param hAlign
 * @param distance
 * @returns {[number, number, number]}
 */
GeoUtil.rotateLineText1 = function (segmentCoords, width, height, vAlign, hAlign, distance, offset) {
	hAlign = 'center';
	if(!segmentCoords || segmentCoords.length < 2)
		return;
	//меняем порядок координат, чтобы отсчет был слева направо
	if(segmentCoords[0][0] > segmentCoords[segmentCoords.length - 1][0])
		segmentCoords = segmentCoords.reverse();
	var p1,p2, newSegments = segmentCoords;// новый массив сегментов, чтобы начинать пересчет с середины
	//TODO принято решение пока для подписей линий не двигать по вертикали
	//vAlign = 'middle';
	var fObj //найденный объект
	if(hAlign === 'left')
		fObj = GeoUtil.findLeft(segmentCoords, distance);
	if(hAlign === 'center')
		fObj = GeoUtil.findCenter(segmentCoords, distance);
	if(hAlign === 'right')
		fObj = GeoUtil.findRight(segmentCoords, distance);
	if(fObj[0][0] > fObj[1][0]){
		var temp = fObj[1];
		fObj[1] = fObj[0];
		fObj[0] = temp;
	}
	p1 = fObj[0];
	p2 = fObj[1];
	newSegments = fObj[2];
	var rotation = 0;
	if (p1 !== null && p2 !== null) {
		rotation = Math.atan2(p2[1] - p1[1], p2[0] - p1[0]) * 180 / Math.PI;
		if(Math.abs(rotation) < 1)
			rotation = 0;
	}
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return [p1[0], p1[1], rotation, newSegments];
};
GeoUtil.findCenter = function(lineString, distance){
	var p1 = lineString.getFlatMidpoint();
	return p1;
	var p2 = lineString.getCoordinateAt(0.51);//ищем след точку с небольшим сдвигом, для поиска поворота
	var newSegments = GeoUtil.splitLinestringAtCoordinate(lineString, p1, distance);
	if(distance){
		p1 = newSegments[0];
		p2 = GeoUtil.getCoordsByDistance(newSegments[0], newSegments[1], 30);//10px
	}
	return [p1, p2, newSegments];
}
/*GeoUtil.findCenter = function(coords, distance){
	var lineString = new ol.geom.LineString(coords, ol.geom.GeometryLayout.XY)//линия их координат в пикселях
	var p1 = lineString.getFlatMidpoint();
	var p2 = lineString.getCoordinateAt(0.51);//ищем след точку с небольшим сдвигом, для поиска поворота
	var newSegments = GeoUtil.splitLinestringAtCoordinate(lineString, p1, distance);
	if(distance){
		p1 = newSegments[0];
		p2 = GeoUtil.getCoordsByDistance(newSegments[0], newSegments[1], 30);//10px
	}
	return [p1, p2, newSegments];
}*/
GeoUtil.findLeft = function(coords, distance){
	var lineString = new ol.geom.LineString(coords, ol.geom.GeometryLayout.XY)//линия их координат в пикселях
	var p1 = coords[0];
	var p2 = lineString.getCoordinateAt(0.01);
	var newSegments = GeoUtil.splitLinestringAtCoordinate(lineString, p1, distance);
	if(distance) {
		p1 = newSegments[0];
		p2 = GeoUtil.getCoordsByDistance(newSegments[0], newSegments[1], 30);//10px
	}
	return [p1, p2, newSegments];
}
GeoUtil.findRight = function(coords, distance){
	var lineString = new ol.geom.LineString(coords, ol.geom.GeometryLayout.XY)//линия их координат в пикселях
	var p1 = lineString.getCoordinateAt(0.99);
	var p2 = coords[coords.length - 1]
	var newSegments = GeoUtil.splitLinestringAtCoordinate(lineString, p1, distance);
	if(distance){
		p1 = newSegments[0];
		p2 = GeoUtil.getCoordsByDistance(newSegments[0], newSegments[1], 30);//10px
	}
	return [p1, p2, newSegments];
}

GeoUtil.splitLinestringAtCoordinate = function(lineString, p1, dist){
	var geometry = /** @type {ol.geom.LineString} */lineString;
	var lineLength = lineString.getLength() / 2;
	var coordinates = geometry.getCoordinates();
	var newLineString = [];
	var distance = 0;
	if(dist){
		//если известна дистанция, то ищем точку
		lineLength = dist;
		for (var i = 1; i < coordinates.length; i++) {
			var pnt1 = coordinates[i - 1];
			var pnt2 = coordinates[i];
			distance += Math.sqrt(ol.coordinate.squaredDistance(pnt1, pnt2));
			if (distance >= dist) {
				p1 = GeoUtil.getCoordsByDistance(pnt1, pnt2, dist);
				break;
			}
		}
	}
	//точка старта найдена, теперь режем линию
	newLineString.push(p1);
	distance = 0;
	for (var i = 1; i < coordinates.length; i++) {
		var pnt1 = coordinates[i - 1];
		var pnt2 = coordinates[i];
		distance += Math.sqrt(ol.coordinate.squaredDistance(pnt1, pnt2));
		if (distance >= lineLength) {
			newLineString.push(pnt2);
		}
	}
	if(newLineString.length < 2)
		newLineString.push(coordinates[coordinates.length - 1]);
	return newLineString;
}


/**
 * Функция обрезки текста вдоль линии, если
 * @param textFeature
 * @param lineCoordinates
 * @param x
 * @param y
 * @returns {Object|*}
 */
GeoUtil.cutText = function (textFeature, lineCoordinates, x, y ) {
	var closestSegment1;
	var rotation = textFeature.rotation;
	var textWidth = textFeature.textWidth;
	var textHeight = textFeature.textHeight;
	var text = textFeature.text;
	var isTextObject = textFeature.isTextObject;
	var charWidth = textWidth / text.length;
	var textInp = '';
	var coordsEndPixel = [x + Math.cos(rotation) * textWidth, y + Math.sin(rotation) * textWidth];
	var closestDistance = Number.MAX_VALUE;
	var coordStart = [x, y];
	var coordEnd = coordsEndPixel;
	for (var j = 0; j < 3; j++) {
		if(isTextObject) break;
		coordsEndPixel = [x + Math.cos(rotation) * textWidth, y + Math.sin(rotation) * textWidth];
		closestDistance = Number.MAX_VALUE;
		for (var i = 0; i < lineCoordinates.length - 1; ++i) {
			closestSegment1 = [lineCoordinates[i], lineCoordinates[i + 1]];
			var coordsClosestPixel = ol.coordinate.closestOnSegment(coordsEndPixel, closestSegment1);
			var dist = GeoUtil.Distance(coordsClosestPixel, coordsEndPixel);
			if (dist < closestDistance)
				closestDistance = dist;
		}
		if (closestDistance < LABEL_CUT_TOLERANCE){
			textInp =  (textInp) ? textInp : text;
			coordEnd = coordsEndPixel;
			var bounds = GeoUtil.calcTextBounds(coordStart, coordEnd, rotation, textHeight, textWidth);
			coordEnd = GeoUtil.getCoordEnd([x, y], textWidth, lineCoordinates, coordEnd);
			return {text: textInp, coordStart: coordStart, coordEnd: coordEnd, bounds: bounds};
		}
		if (j === 2)
			return;
		textWidth -= textFeature.textWidth * LABEL_CUT_RATIO;
		var charCount = (textWidth / charWidth).toFixed(0) - 3;// -3 символа для '...'
		if (charCount > 4) //Выводим подпись, только если вмещается 5 символов
			textInp = text.slice(0, charCount) + '...';
	}
	textInp = text;
	var bounds = GeoUtil.calcTextBounds(coordStart, coordEnd, rotation, textHeight, textWidth);
	coordEnd = GeoUtil.getCoordEnd([x, y], textWidth, lineCoordinates, coordEnd);
	return {text: textInp, coordStart: coordStart, coordEnd: coordEnd, bounds: bounds};
};

//ищем начало следующего сдвинутого вектора на расттроянии половины подписи от начала старого вектора
// корректировка алгоритма. при коллизии берем не последнюю координату подписи, а середину
GeoUtil.getCoordEnd = function(startPoint, textWidth, lineCoordinates, baseCoordEnd){
	var lineString = new ol.geom.LineString(null);
	lineString.setCoordinates(lineCoordinates, ol.geom.GeometryLayout.XY);
	var coordEnd = GeoUtil.getPointOnLineByCenterAndRadius(startPoint, lineString, textWidth/2);
	if(coordEnd !== undefined)
		return coordEnd;
	return baseCoordEnd;
}


GeoUtil.calcTextBounds = function(coordStart, coordEnd, rotation, textHeight, textWidth){
	var leftTop, leftBottom, rightTop, rightBottom;
	leftTop = [Math.round(coordStart[0]), Math.round(coordStart[1] - textHeight/2)];
	leftBottom = [Math.round(coordStart[0]), Math.round(coordStart[1] + textHeight/2)];
	rightTop = [Math.round(leftTop[0] + Math.cos(rotation) * textWidth), Math.round(leftTop[1] + Math.sin(rotation) * textWidth)];
	rightBottom = [Math.round(leftBottom[0] + Math.cos(rotation) * textWidth), Math.round(leftBottom[1] + Math.sin(rotation) * textWidth)];

	var polygon = new ol.geom.Polygon(null);
	var linearRing = new ol.geom.LinearRing(null);
	linearRing.setCoordinates([leftTop, leftBottom, rightBottom, rightTop, leftTop ], ol.geom.GeometryLayout.XY);
	polygon.appendLinearRing(linearRing);
	return polygon;
}


/**
 * Функция фильтрации сегментов, что оставляем самый длинный
 * @param lines
 * @param lay
 * @returns {{}}
 */
GeoUtil.filterSegments = function(lines, lay){
	var filteredLines = {};
	for(var t = 0; t < lines.length; t++){
		var lineObj = lines[t];
		var lineId = lineObj.labelObj.id;
		var realId = (lineId.split('|').length > 1) ? lineId.split('|')[1] : lineId;
		var line = lineObj.lineString;
		var text = lineObj.labelObj.label;
		if(!text){
			if(lay && lay.layer && lay.layer.semanticUniqData && lay.layer.semanticUniqData[realId]) {
				text = lay.layer.semanticUniqData[realId].label;
			}
		}
		if(!text)
			continue;
		filteredLines[lineId + App.generateUUID()] = {
			lineString: line,
			lineStringLength: line.getLength(),
			text: text,
		}
	}
	return filteredLines;
}


/**
 * Продвинутая проверка коллизии. Помимо поиска попадания произвольного прямоугольника(с поворотами) возвращаеются свободные и занятые ячейки
 * @param {map.renderer.vector.TextVector} textVector
 * @returns {{result: boolean, collisionCells: *[], freeCells: *[]}}
 */
GeoUtil.hasComplexTextCollision = function(textVector, force){
	var type = 'label';
	var freeCells = [], collisionCells = [];
	var matrix = _visibleTextMatrix[type];
	if(!textVector || !matrix)
		return {hasCollision: true, freeCells: freeCells, collisionCells: collisionCells};
	var bounds = textVector.bounds; //Polygon
	var intersectMatrix = GeoUtil.findMatrixIntersection(bounds, matrix);
	freeCells = intersectMatrix.freeCells;
	collisionCells = intersectMatrix.collisionCells;
	return {hasCollision: collisionCells.length !== 0, freeCells: freeCells, collisionCells: collisionCells};
};

GeoUtil.addComplexText = function(feature, textVector, freeCells){
	//Считаем координату х смещенной на _matrixAddWidth, а координату y смещенной на _matrixAddHeight,
	//поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
	var layerId = feature.get('labelType');
	var type = 'label';
	var matrix = _visibleTextMatrix[type];
	var coord = WidgetMap.map.getCoordinateFromPixel([textVector.x, textVector.y]);
	var unique = layerId+'_'+coord[0]+'_'+coord[1];
	var sav = {
		priority: 0,
		obj: feature,
		unique: unique,
	};
	if(freeCells && freeCells.length > 0 ){
		freeCells.forEach(function(el){
			var i = el[0], j = el[1];
			matrix[i][j] = sav;
		});
	}
	return unique;
}

/**
 * поиск смещения по матрице коллизий
 * @param collisionCells
 * @returns {number}
 */
GeoUtil.findOffsetDistanceByCollision = function(collisionCells){
	//если нашли коллизии, то начинаем считать сдвиг
	var nxGr = [], nyGr = [];
	for(var col in collisionCells){
		if(nxGr.indexOf(collisionCells[col][0]) === -1)
			nxGr.push(collisionCells[col][0]);
		if(nyGr.indexOf(collisionCells[col][1]) === -1)
			nyGr.push(collisionCells[col][1]);
	}
	var dist = Math.sqrt((nxGr.length * _dx) * (nxGr.length * _dx) + (nyGr.length * _dy) * (nyGr.length * _dy));//гипотенуза
	return dist;
}

/**
 * Поиск пересечений и свободных ячеек в матрице текстовых подписей
 * @param bounds
 * @param matrix
 */
GeoUtil.findMatrixIntersection = function(bounds, matrix){
	var i, j,
		freeCells = [], collisionCells = [];
	var extent = bounds.getExtent();
	//высчитываем min/max от extent полигона
	var min_x = Math.floor(extent[0]/_dx);
	var min_y = Math.floor(extent[1]/_dy);
	var max_y = Math.floor((extent[1] + ol.extent.getHeight(extent))/_dy);
	var max_x = Math.floor((extent[0] + ol.extent.getWidth(extent))/_dx);

	if (min_x < 0 || min_y < 0 || max_x >= matrix.length || max_y >= matrix[0].length)
		return {freeCells: freeCells, collisionCells: collisionCells};
	try{
		for (j = min_y; j <= max_y; j++){
			for (i = min_x; i <= max_x; i++){
				var cellExtent = [i * _dx, j * _dy, i * _dx + _dx,  j * _dy + _dy];
				//если подпись пересекает ячейку, то проверяем, есть ли в ней уже подпись
				if (bounds.intersectsExtent(cellExtent)){
					//если в ячейке ничего нет
					if (matrix[i] && !matrix[i][j]){
						freeCells.push([i, j]);
					}
					else{
						collisionCells.push([i, j]);
					}
				}
			}
		}
	}
	catch(ex){ }
	return {freeCells: freeCells, collisionCells: collisionCells};
}

GeoUtil.findNearestPoint = function(lineCoordinates, point){
	var closestPoint = point;
	var closestSegment, closestDistance = Number.MAX_VALUE;
	var index = -1;
	for (var k = 0; k < lineCoordinates.length - 1; ++k) {
		closestSegment = [lineCoordinates[k], lineCoordinates[k + 1]];
		var closestFirstProj = ol.coordinate.closestOnSegment(point, closestSegment);
		if (GeoUtil.Distance(closestFirstProj, point) < closestDistance){
			closestDistance = GeoUtil.Distance(closestFirstProj, point);
			closestPoint = closestFirstProj;
			index = k;
		}
	}
	return [closestPoint, index];
}


/**
 * Получение текста средствами canvas.context либо попытка посчитать примерную ширигу текста по размеру символа
 * @param text текст
 * @param textStyle стиль текстовой подписи
 * @param context контекст карты
 */
GeoUtil.getTextWidth = function(text, textStyle, context){
	var textWidth = 89;
	if(context){
		context.font = textStyle.getFont();
		textWidth = context.measureText(text).width;
	}
	else{
		var charWidth = 6;
		textWidth = text.length * charWidth;
	}
	return textWidth;
}

GeoUtil.getDefaultTextWidth = function(text, context){
	var textWidth = 89;
	if(context){
		context.font = 'normal 13px Times New Roman';
		textWidth = context.measureText(text).width;
	}
	else{
		var charWidth = 6;
		textWidth = text.length * charWidth;
	}
	return textWidth;
}

/**
 * Проверка, пересекает ли отрезок окружность
 * @param segment
 * @param center
 * @param radius
 */
GeoUtil.intersectCircleAndSegment = function(segment, center, radius){
	var x1 = segment[0][0],
		y1 = segment[0][1],
		x2 = segment[1][0],
		y2 = segment[1][1],
		xC = center[0],
		yC = center[1];

	var r1 = Math.sqrt(Math.pow(xC-x1, 2) + Math.pow(yC-y1, 2));
	var r2 = Math.sqrt(Math.pow(xC-x2, 2) + Math.pow(yC-y2, 2));
	if((r1 >= radius && r2 < radius) || (r1 < radius && r2 >= radius))
		return true;
	return false;

	x1 -= xC;
	y1 -= yC;
	x2 -= xC;
	y2 -= yC;

	var dx = x2 - x1;
	var dy = y2 - y1;
	//составляем коэффициенты квадратного уравнения на пересечение прямой и окружности.
	//если на отрезке [0..1] есть отрицательные значения, значит отрезок пересекает окружность
	var a = dx * dx + dy * dy;
	var b = 2 * (x1 * dx + y1 * dy);
	var c = x1 * x1 + y1 * y1 - radius * radius;

	//а теперь проверяем, есть ли на отрезке [0..1] решения
	if (-b < 0)
		return (c < 0);
	if (-b < (2 * a))
		return ((4 * a * c - b * b) < 0);

	return (a + b + c < 0);
	/*var b, c, d, v1, v2;
	v1 = {};
	v2 = {};
	v1.x = segment[1][0] - segment[0][0];
	v1.y = segment[1][1] - segment[0][1];
	v2.x = segment[0][0] - center[0];
	v2.y = segment[0][1] - center[1];
	b = (v1.x * v2.x + v1.y * v2.y);
	c = 2 * (v1.x * v1.x + v1.y * v1.y);
	b *= -2;
	d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - radius * radius));
	if(isNaN(d)){ // no intercept
		return false
	}
	return true;*/
	/*var x = x1 * (1 - t) + x2 * t;
	var y = y1 * (1 - t) + y2 * t
	var s = (x1 * (1 - t) + x2 * t)^2 + (y1 * (1 - t) + y2 * t) ^2 = R^2;*/
}


/**
 * Получение точки пересечения между линией и окружностью
 * @param lineString
 * @param center
 * @param radius
 * @returns {*}
 */
GeoUtil.getIntersectionBetweenCircleAndLine = function(lineString, center, radius){
	var intersect = function(center, k, b, radius){
		//находим дискрименант квадратного уравнения
		var x = center[0], y = center[1];
		var d = (Math.pow((2 * k * b - 2 * x - 2 * y * k), 2) - (4 + 4 * k * k) * (b * b - radius * radius + x * x + y * y - 2 * y * b));
		//если он меньше 0, уравнение не имеет решения
		if(d < 0)
			return;
		//иначе находим корни квадратного уравнения
		var x1 = ((-(2 * k * b - 2 * x - 2 * y * k) - Math.sqrt(d)) / (2 + 2 * k * k));
		var x2 = ((-(2 * k * b - 2 * x - 2 * y * k) + Math.sqrt(d)) / (2 + 2 * k * k));
		var y1 = k * x1 + b;
		var y2 = k * x2 + b;
		//если абсциссы точек совпадают, то пересечение только в одной точке
		if (x1 === x2)
			return [[x1, y1]];
		return [ [x1, y1], [x2, y2]];
	}
	if(lineString){
		var coords = lineString.getCoordinates();
		for(var i = 1; i < coords.length; i++){
			var p1 = coords[i - 1];
			var p2 = coords[i];
			var x1 = p1[0], x2 = p2[0],
				y1 = p1[1], y2 = p2[1],
				k, b;
			(x1 === x2) ? k = (y1 - y2) / (x1) : k = (y1 - y2) / (x1 - x2);
			b = y1 - k * x1;
			var intersection = intersect(center, k, b, radius);
			if(intersection && intersection.length > 0){
				return intersection;
			}
		}
	}
}
var Intersection = {};
//https://github.com/mapbox/lineclip#lineclippolylinepoints-bbox-result
// Cohen-Sutherland line clippign algorithm, adapted to efficiently
// handle polylines rather than just segments
Intersection.lineclip = function(points, bbox, result) {
	var len = points.length,
		codeA = Intersection.bitCode(points[0], bbox),
		part = [],
		i, a, b, codeB, lastCode;

	if (!result) result = [];

	for (i = 1; i < len; i++) {
		a = [points[i - 1][0],points[i - 1][1]];
		b = [points[i][0], points[i][1]];
		codeB = lastCode = Intersection.bitCode(b, bbox);

		while (true) {

			if (!(codeA | codeB)) { // accept
				part.push(a);

				if (codeB !== lastCode) { // segment went outside
					part.push(b);

					if (i < len - 1) { // start a new line
						result.push(part);
						part = [];
					}
				} else if (i === len - 1) {
					part.push(b);
				}
				break;

			} else if (codeA & codeB) { // trivial reject
				break;

			} else if (codeA) { // a outside, intersect with clip edge
				a = Intersection.intersect(a, b, codeA, bbox);
				codeA = Intersection.bitCode(a, bbox);

			} else { // b outside
				b = Intersection.intersect(a, b, codeB, bbox);
				codeB = Intersection.bitCode(b, bbox);
			}
		}

		codeA = lastCode;
	}

	if (part.length) result.push(part);

	return result;
}

// Sutherland-Hodgeman polygon clipping algorithm

/*function polygonclip(points, bbox) {

	var result, edge, prev, prevInside, i, p, inside;

	// clip against each side of the clip rectangle
	for (edge = 1; edge <= 8; edge *= 2) {
		result = [];
		prev = points[points.length - 1];
		prevInside = !(bitCode(prev, bbox) & edge);

		for (i = 0; i < points.length; i++) {
			p = points[i];
			inside = !(bitCode(p, bbox) & edge);

			// if segment goes through the clip window, add an intersection
			if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));

			if (inside) result.push(p); // add a point if it's inside

			prev = p;
			prevInside = inside;
		}

		points = result;

		if (!points.length) break;
	}

	return result;
}*/

// intersect a segment against one of the 4 lines that make up the bbox

Intersection.intersect = function(a, b, edge, bbox) {
	return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
		edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
			edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
				edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : null; // left
}

// bit code reflects the point position relative to the bbox:
//         left  mid  right
//    top  1001  1000  1010
//    mid  0001  0000  0010
// bottom  0101  0100  0110

Intersection.bitCode = function(p, bbox) {
	var code = 0;

	if (p[0] < bbox[0]) code |= 1; // left
	else if (p[0] > bbox[2]) code |= 2; // right

	if (p[1] < bbox[1]) code |= 4; // bottom
	else if (p[1] > bbox[3]) code |= 8; // top

	return code;
}



GeoUtil.getFontSizeByZoom = function(textWidth){
	var zoom = WidgetMap.map.getView().getZoom();
	//var coeff = 13/11;
	//var coeff = 1.75;
	var coeff = 2;

	/*var f = WidgetMap.DEFALT_FONT_SIZE;
	if(zoom > WidgetMap.DEFALT_ZOOM_FOR_FONT){
		f = Math.abs((WidgetMap.DEFALT_ZOOM_FOR_FONT - zoom) * coeff);
	}
	if(zoom < WidgetMap.DEFALT_ZOOM_FOR_FONT){
		f = Math.abs((WidgetMap.DEFALT_ZOOM_FOR_FONT - zoom) / coeff);
	}
	return f;*/
	var fontObj = {
		21: WidgetMap.DEFALT_FONT_SIZE * (Math.pow(coeff, Math.abs(WidgetMap.DEFALT_ZOOM_FOR_FONT - zoom))),//coeff * coeff * coeff,
		20: WidgetMap.DEFALT_FONT_SIZE * coeff * coeff,
		19: WidgetMap.DEFALT_FONT_SIZE * coeff,
		18: WidgetMap.DEFALT_FONT_SIZE,
		17: WidgetMap.DEFALT_FONT_SIZE / coeff,
		16: WidgetMap.DEFALT_FONT_SIZE / coeff / coeff ,
		15: WidgetMap.DEFALT_FONT_SIZE / coeff / coeff / coeff,
	}
	/*var fontObj = {
		21: 28,
		20: 22,
		19: 16.9,
		18: 13,
		17: 10,
		16: 7,
		15: 6,
		14: 4,
		13: 3,
	}*/
	return fontObj[zoom] || 1;
}
GeoUtil.getOffsetByZoom = function(){
	var zoom = WidgetMap.map.getView().getZoom();
	var offset = 10;
	return 0;
	switch (zoom){
		case 18:
			offset = 10;
			break;
		case 17:
			offset = 5;
			break;
		case 16:
			offset = 2;
			break;
		case 15:
			offset = 0;
			break;
		case 13:
			offset = 5;
			break;
		default:
			offset = 5;
			break;
	}
	return offset;
}
/* Глобальный объект с функциями для ожидания и блокировки */
BlockingUtil = {};

//Признак, что часики крутятся
BlockingUtil._isWaiting = false;
BlockingUtil._waitCount = 0;
//Признак, что грузится геометрия
BlockingUtil._isWaitingGeo = false;
BlockingUtil._waitCountGeo = 0;
//Признак, что приложение заблокировано
BlockingUtil._isBlocked = false;
BlockingUtil._blockCount = 0;

//Добавляем часики
BlockingUtil.wait = function() {
    BlockingUtil._isWaiting = true;
    BlockingUtil._waitCount += 1;
    //Устанавливаем курсор ожидания
    $("body").css("cursor", "progress");
};

BlockingUtil.waitGeo = function() {
	BlockingUtil._isWaitingGeo = true;
	BlockingUtil._waitCountGeo += 1;
	//Устанавливаем показываем лоадер
    if(goog.isDef(WidgetMap) && goog.isDef(WidgetMap.geometryLoaderControl))
	    WidgetMap.geometryLoaderControl.setVisible(true);
};
BlockingUtil.readyGeo = function() {
	BlockingUtil._waitCountGeo -= 1;
	if (BlockingUtil._waitCountGeo <= 0) {
		BlockingUtil._waitCountGeo = 0;
		BlockingUtil._isWaitingGeo = false;
		//прячем лоадер
		if(goog.isDef(WidgetMap) && goog.isDef(WidgetMap.geometryLoaderControl))
			WidgetMap.geometryLoaderControl.setVisible(false);
	}
};

//Убираем часики
BlockingUtil.ready = function() {
    BlockingUtil._waitCount -= 1;
    if (BlockingUtil._waitCount <= 0) {
        BlockingUtil._waitCount = 0;
        BlockingUtil._isWaiting = false;
        //Устанавливаем обычный курсор
        $("body").css("cursor", "default");
        /* Для проверки курсора ожидания делаем задержку перед восстановлением */
        /*setTimeout(function (){
         $("body").css("cursor", "default");
         },5000);*/
    }
};

//Ставим блокировку на приложение
BlockingUtil.blockApplication = function() {
    BlockingUtil._isBlocked = true;
    BlockingUtil._blockCount += 1;
    //Добавляем div, который закрывает собой все приложение (сквозь него не проходят никакие события)
    var overlayDiv = '<div class="applicationBlockOverlay"></div>';
    $("body").append(overlayDiv);
};

//Снимаем блокировку с приложения (если не было других блокировок, мы их накапливаем)
BlockingUtil.unblockApplication = function() {
    BlockingUtil._blockCount -= 1;
    if (BlockingUtil._blockCount <= 0) {
        BlockingUtil._blockCount = 0;
        BlockingUtil._isBlocked = false;
        //Убираем div, который закрывает собой все приложение (сквозь него не проходят никакие события)
        $(".applicationBlockOverlay").remove();
        /* Для проверки блокировки приложения делаем задержку перед восстановлением */
        /*setTimeout(function (){
         $(".applicationBlockOverlay").remove();
         },5000);*/
    }
};


/*Глобальный объект с константами всех сервисов (просто адреса к ним)*/
Services = {};
/*Сервис выполняет запросы к БД или XML-файлам на сервере*/
Services.processQueryNew = './DataService.asmx/ProcessQueryNew';
/*Сервис запрашивает картинку карты по введенным координатам рамки (запрос к растеризатору)*/
Services.mapDrawService = './MapService.asmx/DrawTile';
/*Сервис запрашивает информацию об объектах растровой карты в указанной точке (запрос к растеризатору)*/
Services.mapInfoService = './MapService.asmx/GetObjectsInfo';
Services.mapWmsService = './MapService.asmx/DrawImageWMS';
/*Сервис */
Services.RunUTETaskService = './ServerTaskService.asmx/RunUTETask';

Services.ImportCP = './UTEService.asmx/ImportPI_CP';

Services.processQueryNode = './api/process-query';
Services.processQueryNodeGeo = './api/process-geoquery';
Services.processQueryNodeXml = './api/process-xml';

Services.exportExcelNode = './api/run-ute-task';

/*сервисы 2-й очереди фриланса*/
Services.sendMailNode = './api/send-mail';
/*********сервисы, работающие с геометриями***********/
//Сервис получает буферную зону (строка WKT) для переданной геометрии объекта (тоже строка WKT)
Services.bufferZoneNode =  './api/geo/buffer-zone';
/*********** ********************************************/

/*********сервисы, работающие с файловой системой***********/

Services.getFileNamesFromDirNode    = './api/files/names'; //получение списка файлов и папок в текущей директории
Services.uploadNode                 = './api/files/upload'; //загрузка файлов на сервер
Services.createImageNode            = './api/files/create-image'; //создание изображения
Services.deleteFileNode             = './api/files/delete'; //удаление файла
/*********** ********************************************/

/*Сервис для записи в лог на сервере*/
Services.logNode = './api/log';

/*Сервисы предпросмотра документов*/
Services.docPreview             = './api/doc/preview';
Services.pdfPreview             = './api/pdf/preview';
Services.pdfOriginal            = './api/pdf/original';
Services.pdfConvert             = './api/pdf/convert';
Services.pdfFullScreen         = './api/pdf-preview';// TODO Заменить как будет готов сервис
/* --------------- Конец --------------- сервисы 2-й очереди фриланса*/

/*Сервисы экспорта данных из внешних источников*/
Services.exportGdalNode         = './api/gdal/export';
Services.importGdalNode         = './api/gdal/import';
Services.parseGdalNode          = './api/gdal/parse';

/*Сервисы авторизации*/
Services.loginNode              = './api/auth/login';
Services.logoutNode             = './api/auth/logout';
Services.changePassNode         = './api/auth/change-pass';
Services.userTasksNode          = './api/auth/user-tasks';
Services.userTaskNode          = './api/auth/user-task';
Services.hasTaskNode          = './api/auth/has-task';

/* сервис проверки работоспособности nodejs*/
Services.isNodeReady            = './api/status/is-ready';

/*Сервисы ute*/
Services.uteLrsRouteCalc        = './ute/lrs-route-calc';
Services.uteKmRouteCalc         = './ute/km-route-calc';
Services.uteIliInspCalc         = './ute/ili-insp-calc';
Services.uteIliInspLink         = './ute/ili-insp-link';
Services.uteIliImportXml        = './ute/ili-import-xml';
Services.uteIliCluster          = './ute/ili-cluster';
Services.uteStoEhzInspProc      = './ute/sto-ehz-insp-proc';
Services.uteStoIliInspProc      = './ute/sto-ili-insp-proc';
Services.uteIliPressure         = './ute/ili-pressure';
Services.uteGroupRouteIdx       = './ute/group-route-idx';
Services.uteOfflineRouteIdx     = './ute/offline-line-idx';
Services.uteLineRouteIdx        = './ute/line-route-idx';
Services.uteIntervalDivining    = './ute/interval-divining';

/* Сервисы для дашбордов*/
Services.getDashboards          = './api/dashboards/list';
Services.saveDashboard          = './api/dashboards/dashboard';
Services.dashboard              = './api/dashboards/dashboard';

/*Сервисы работы с задачами*/
Services.task              = './api/task';

Services.updateMonoServices = function(){
	if(App && App.config && App.config.APP_60_SERVER){
		Services.processQueryNew = Services.processQueryNew.replace('./', App.config.APP_60_SERVER);
		Services.mapDrawService = Services.mapDrawService.replace('./', App.config.APP_60_SERVER);
		Services.mapInfoService = Services.mapInfoService.replace('./', App.config.APP_60_SERVER);
		Services.mapWmsService = Services.mapWmsService.replace('./', App.config.APP_60_SERVER);
		Services.RunUTETaskService = Services.RunUTETaskService.replace('./', App.config.APP_60_SERVER);
		Services.ImportCP = Services.ImportCP.replace('./', App.config.APP_60_SERVER);
	}
}
//Глобальный объект
HTTPServiceUtil = {};



HTTPServiceUtil.getLoginError = function (error, login) {
    if(error && error.indexOf(gis_httpserviceutil_2) !== -1)
        return gis_httpserviceutil_3+login;
    return error;
}
HTTPServiceUtil.getError = function getError(result/*Object*/) {
    var innXML;
    var errorObjectStr = '[object Object]';
    var resultErrorString = '';
    try {
        if (typeof result === 'string') {
            var resultStr = result.toString();
            if (resultStr.indexOf("<error") >= 0 || resultStr.indexOf("<critic_errors>") >= 0 ) {
                innXML = $(resultStr);//try to make xml from string
                if (innXML && innXML.length>0 && (innXML[0].nodeName.toLowerCase() === "error" || innXML[0].nodeName.toLowerCase() === "critic_errors")) {
                    resultErrorString = resultStr.replace("<error>", '').replace("</error>", '');
                    //Заменяем в результирующей строке xml-escaped последовательности на корректные читаемые символы
                    resultErrorString = resultErrorString.replace(/&apos;/g, "'").replace(/&quot;/g, '"').replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&amp;/g, '&');
                    if(resultErrorString.indexOf(errorObjectStr) !== -1)
                        return resultStr;
                    return resultErrorString;
                }
                //Иначе ищем в дочерних элементах
                var innChildErr = innXML.find("error, critic_errors");
                if (innChildErr && innChildErr.length > 0) {
                    return resultStr;
                }
            }
            if (resultStr.indexOf("error=") >= 0)
            {
                innXML = $(resultStr);//try to make xml from string
                var innAttrErr = innXML.find("[error]");
                if (innAttrErr && innAttrErr.length>0)
                    return resultStr;
            }
            if(resultStr.indexOf("&lt;error&gt;") >= 0 || resultStr.indexOf("&lt;critic_errors&gt;") >= 0)
                return resultStr;
            if(resultStr.indexOf("503 Service Unavailable") >= 0 || resultStr.indexOf("Service Unavailable") >= 0){
                return App.SERVER_ERRORS['Service Unavailable']+' . details=' + resultStr;
            }
            if(resultStr.indexOf("500 Internal Server Error") >= 0 || resultStr.indexOf("Internal Server Error") >= 0) {
                return App.SERVER_ERRORS['Internal Server Error'] + ' . details=' + resultStr;
            }
        }
        if (result instanceof jQuery) {
            var errorsArr = result.find("error, critic_errors, [error]");
            if (errorsArr !== undefined && errorsArr && errorsArr.length > 0){
                resultErrorString = HTTPServiceUtil.xmlToString(result);
                if(resultErrorString.indexOf(errorObjectStr) !== -1)
                    return resultStr;
                return resultErrorString;
            }
        }
    } catch (e) { }

    return resultErrorString;
};

/* Возвращает объект jQuery (XML)*/
HTTPServiceUtil.getXMLData = function getXMLData(result/*XML*/) {
    var res;
    try
    {
        res = $(result);
    }
    catch(e)
    {
        App.errorReport(gis_httpserviceutil_1+e, result.toString(), undefined, {filename:gis_filename_611, functionname:'gis_filename_611_1'});
        return null;
    }
    return res;
};

HTTPServiceUtil.getStringData = function getStringData(result/*XML*/) {
    return result.toString();
};

HTTPServiceUtil.xmlToString = function(xmlData) { // this functions waits jQuery XML
    var xmlString = undefined;

    if (window.ActiveXObject){
        xmlString = xmlData[0].xml;
    }

    if (xmlString === undefined)
    {
        var oSerializer = new XMLSerializer();
        xmlString = oSerializer.serializeToString(xmlData[0]);
    }
    if (xmlString === undefined)
    {
        xmlString = xmlData[0].outerHTML;
        /*var oSerializer = new XMLSerializer();
         xmlString = oSerializer.serializeToString(xmlData[0]);*/
    }
    return xmlString;

    var xmlString = undefined;
    if (window && window.ActiveXObject){
        /*xmlString = xmlData[0].xml;*/
        xmlString = xmlData[0].outerHTML;
    }
    if (xmlString === undefined)
    {
        xmlString = xmlData[0].outerHTML;
        /*var oSerializer = new XMLSerializer();
         xmlString = oSerializer.serializeToString(xmlData[0]);*/
    }
    return xmlString;
};

/* Функция проверки существования файла на сервере */
HTTPServiceUtil.isUrlExists = function isUrlExists(url) {
    var http = new XMLHttpRequest();
    http.open('HEAD', url, false);
    http.send();
    return http.status !== 404 && http.status !== 403; /* можно доработать, включив проверку статусов вроде 200 (успешно скачан) и других */
};

/**
 * Функция открытия файла
 * @param fileName
 * @param options
 */
HTTPServiceUtil.openFile = function (fileName, options) {
    var target = (options && options.target)? options.target : '_blank';
    var parentDir = (options && options.parentDir)? options.parentDir : '';
    var errMessage = (options && options.errMessage)? options.errMessage : gis_core_error_5;
    //если для разных открытий файлов используются разные имена
    var specificPdfFileName = (options && options.specificPdfFileName)? options.specificPdfFileName : fileName;
    //var link = window.location.protocol+'//'+window.location.host+'/'+fileName;
    if(fileName.indexOf('.pdf#') === -1){//если в url не содержится .pdf#, значит нужно выполнить запрос на генерацию картинки
        //для обычных файлов добавляем возможность указывать родительскую директорию. Например, Public/Data/LIB
        fileName = parentDir + fileName;
        if (HTTPServiceUtil.isUrlExists(fileName))
            window.open(fileName, target);
        else
            App.confirmDialog(errMessage, null, {title: gis_core_1});
    }
    else{
        fileName = specificPdfFileName;
        App.getJsonNode(Services.pdfConvert, {file_name: fileName.replace('#','$')},
            function (result) {
                if (result !== undefined && result.status === 200) {
                    if (result.generated_file !== undefined) {
                        HTTPServiceUtil.openFile(result.generated_file, {errMessage: gis_core_error_6});
                    }
                }
            },
            function (resultXML) {
                //Снимаем курсор ожидания
                var er = HTTPServiceUtil.getError(resultXML);
                App.errorReport(errMessage, er, undefined, {filename:gis_filename_611, functionname:'gis_filename_611_3'});
            }, 'GET');
    }
};
/*Глобальный объект с функциями для работы с базой данных (добавление, изменение, удаление и др.)*/
DBUtil = {};

//константы
DBUtil.DELETE_ALL_ERROR = gis_dbutil_1;
DBUtil.DELETE_GEO_ERROR = gis_dbutil_2;
DBUtil.DELETE_SEM_ERROR = gis_dbutil_3;

DBUtil.NO_GEOMETRY_REQUEST_ERROR = gis_dbutil_4;
DBUtil.NO_SEMANTIC_REQUEST_ERROR = gis_dbutil_5;
DBUtil.NO_LAYER_ERROR = gis_dbutil_6;
//Символ разделителя между перечисленными в одной строке идентификаторами запросов
DBUtil.PROVIDERS_DIVIDER = "$";


//Ссылка на последний выполняющийся запрос удаления
DBUtil.CURRENT_DELETING_MESSAGE_ID = null;
//Идентификатор объекта вида "PODS_ROUTE/130006"
DBUtil.savingEntityId = null;
DBUtil.savingLayer = null;
//Последнее сохраненное имя панели свойств для удаления
DBUtil.propertyPanelName = null;
//Привязка
DBUtil.savingBindData = null;
//Переменная хранит набор провайдеров, которые мы должны выполнить последовательно для удаления объекта
//Если переменная ==null, то мы не выполняем удаление с помощью провайдеров
//Если переменная содержит хотя бы один провайдер - нужно продолжать удалять каждый раз с новым провайдером
DBUtil._providersForDelete /*Array*/ = null;

DBUtil.getReqParams = function(requestId, sendingData, descrType) {
    var userId = Auth.getUserId();
    var userLogin = Auth.getUserName();

    return {
        descrId: requestId,
        descrType: descrType,
        data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+sendingData+'</root>'
    };
};

DBUtil.getDeleteReqParams = function(requestId, sendingData) {
    var userId = Auth.getUserId();
    var userLogin = Auth.getUserName();

    return {
        getSchema: false,
        descrId: requestId,
        toElements: false,
        descrType: 'delete',
        data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+sendingData+'</root>'
    };
};

//Функция удаления геометрии (а затем и семантики) из базы данных. Если завершается успешно - удаляем с карты и из грида
//provider: список провайдеров (если он указан, удаление производится по этим провайдерам без обращения к карте или к панели свойств)
//propertyPanelName: имя панели свойств, если нет ни провайдера, ни карты удалять будем по свойству dataProvider из описания панели свойств
DBUtil.deleteGeometryFromDB = function(idStr, dataType, provider, propertyPanelName) {
    var deleteRequestParams = null;
    if (idStr && idStr!="" && dataType && dataType!="") {
        /* формируем xml с данными геометрии
        @WKT не посылаем, он будет = null */
        var sendingData = '<data ID="'+idStr+'"/>';

        var deletingId = dataType+"/"+idStr;
        DBUtil.savingEntityId = deletingId;
        DBUtil.propertyPanelName = propertyPanelName;
        //Обрабатываем наличие provider - если он непустой и в нем значатся валидные идентификаторы запросов, разделенные знаком PROVIDERS_DIVIDER
        //тогда производим удаление ТОЛЬКО с помощью последовательных вызовов этих провайдеров, не используя ни слой ни propertyPanelName
        if ((DBUtil._providersForDelete && DBUtil._providersForDelete.length>0) || (provider && provider!="")) {
            if (provider && provider!="") {
                var splittedProvArr = provider.split(DBUtil.PROVIDERS_DIVIDER);
                if (splittedProvArr.length>0) {
                    //Разворачиваем массив, чтобы последним элементом был первый, т.к мы извлекаем провайдеры с помощью pop()
                    splittedProvArr = splittedProvArr.reverse();
                    if (!DBUtil._providersForDelete || DBUtil._providersForDelete.length==0)
                        DBUtil._providersForDelete = splittedProvArr;

                    var currentProv = DBUtil._providersForDelete.pop();

                    /*Logger.info("Запуск удаления геометрии объекта с помощью цепочки провайдеров: ID="+savingEntityId+"; request="+sendingData+"; provider="+currentProv);*/
                    /*_model.wait();*/
                    deleteRequestParams = DBUtil.getDeleteReqParams(currentProv, sendingData);
                    //Устанавливаем курсор ожидания
                    BlockingUtil.wait();
                    //BlockingUtil.blockApplication();
                    DBUtil.CURRENT_DELETING_MESSAGE_ID = App.serverQueryXMLNodeWithTries(Services.processQueryNode, deleteRequestParams, DBUtil.deleteGeomResult, DBUtil.deleteFault);
                }
            } else {
                // Отправляем событие успешного завершения операции - мы обработали все провайдеры без ошибок
                //По-хорошему сюда алгоритм заходить не должен, так как при обработке последнего provider из _providersForDelete
                //функция deleteGeometryFromDB снова не вызывается, но на всякий случай обработку оставил
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_DELETED_BY_ID, OperationEvent.DATA_PART_ALL, dataType, idStr, "");
            }
        } else {
            var lay = WidgetMap.layerManager.getLayerByName(dataType);
            if (lay) {
                //сохраняем все данные перед отправкой
                DBUtil.savingLayer = lay;

                if (lay.dataProvider && lay.dataProvider.spatial && lay.dataProvider.spatial!="") {
                    /*Logger.info("Запуск удаления геометрии объекта через provider слоя: ID="+savingEntityId+"; request="+sendingData);*/
                    /*_model.wait();*/
                    deleteRequestParams = DBUtil.getDeleteReqParams(lay.dataProvider.spatial, sendingData);
                    //Устанавливаем курсор ожидания
                    BlockingUtil.wait();
                    //BlockingUtil.blockApplication();
                    DBUtil.CURRENT_DELETING_MESSAGE_ID = App.serverQueryXMLNodeWithTries(Services.processQueryNode, deleteRequestParams, DBUtil.deleteGeomResult, DBUtil.deleteFault);
                } else {
                    // если слой найден но у него нет провайдера - пытаемся удалить семантику!
                    DBUtil.deleteSemanticFromDB(idStr, dataType);
                }
            } else if (propertyPanelName!="") {
                // если слой для объекта не найден - пытаемся удалить по имени панели свойств propertyPanelName
                DBUtil.deleteObjectByPropertyPanelName(idStr, dataType, propertyPanelName);
            } else {
                //Если же нет ни провайдеров, ни слоя, ни имени панели свойств для удаления - показываем сообщение об ошибке и отправляем результат с ошибкой
                //sendOperationResultEvent(OperationEvent.OBJECT_DELETED_BY_ID, OperationEvent.DATA_PART_ALL, dataType, idStr, gis_dbutil_7);
                //2013_03_12 - замечание: "Если слоя нет, то ошибок не должно отображаться." - чтобы у нас был результат и не возникло ошибки
                //отправляем сообщение с успешным результатом (то есть с error="") .
                DBUtil.sendOperationResultEvent((propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
                    , OperationEvent.DATA_PART_ALL, dataType, idStr, "");
            }
        }
    }
    else {
        // если нет ID или типа - показываем сообщение об ошибке и отправляем результат с ошибкой
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent((propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
            , OperationEvent.DATA_PART_ALL, dataType, idStr, gis_dbutil_7);
    }
};

//слушатели результата удаления геометрии
DBUtil.deleteGeomResult = function(data) {
    //Снимаем курсор ожидания
    BlockingUtil.ready();
    //BlockingUtil.unblockApplication();
    /*_model.ready();*/
    if (data) {
        /*var resultXML = HTTPServiceUtil.getXMLData(data);
        var er = HTTPServiceUtil.getError(resultXML);*/
        var er = HTTPServiceUtil.getError(data);
        var classId = "";
        var objectId = "";
        if (DBUtil.savingEntityId && DBUtil.savingEntityId!="" && DBUtil.savingEntityId.indexOf("/")>=0) {
            classId = DBUtil.savingEntityId.split("/")[0];
            objectId = DBUtil.savingEntityId.split("/")[1];
        }
        //
        if (er=="") {
            var objFromGrid = OperationEvent.OBJECT_DELETED_BY_ID;
            if(DBUtil.propertyPanelName=="") objFromGrid = OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID;
            if (DBUtil.savingEntityId && DBUtil.savingEntityId!="") {
                if (DBUtil._providersForDelete) {
                    // Если удаляли через цепочку провайдеров, _providersForDelete будет != null
                    if (DBUtil._providersForDelete.length>0)
                        DBUtil.deleteGeometryFromDB(objectId, classId, DBUtil._providersForDelete.join(DBUtil.PROVIDERS_DIVIDER), "");
                    else // Отправляем событие успешного завершения операции - мы обработали все провайдеры без ошибок
                        DBUtil.sendOperationResultEvent(objFromGrid, OperationEvent.DATA_PART_ALL, classId, objectId, er);
                } else if (DBUtil.savingLayer) {
                    //Отправляем событие завершения операции
                    DBUtil.sendOperationResultEvent(objFromGrid, OperationEvent.DATA_PART_GEO, classId, objectId, er);
                    //Запускаем удаление семантической части после успешного удаления геометрии
                    DBUtil.deleteSemanticFromDB(DBUtil.savingEntityId.split("/")[1],DBUtil.savingEntityId.split("/")[0]);
                    /*
                    //TODO - удаление геометрии из слоя на карте должно производиться в самой карте !!!
                    savingLayer.removeObjectById(savingEntityId.split("/")[1]);
                    //Вместо обновления всего слоя из базы просто обновляем его после удаления конкретного объекта
                    savingLayer.redrawLayer();
                    */
                }
            }
        } else {
            //Отправляем событие завершения операции
            DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
                , OperationEvent.DATA_PART_ALL, classId, objectId, er);
            //_model.ready();
            DBUtil.savingEntityId = "";
        }
    }
    //очищаем вспомогательные переменные и слой, на котором рисовали
    DBUtil.savingGeometry = null;
    DBUtil.savingLayer = null;
    /*closeDrawPanel();*/
};

//Функция удаления семантики из базы данных. Вызывается если успешно удалили из базы геометрию
DBUtil.deleteSemanticFromDB = function(idStr, dataType) {
    if (idStr && idStr!="" && dataType && dataType!="") {
        var deletingId = dataType+"/"+idStr;
        DBUtil.savingEntityId = deletingId;
        var lay = WidgetMap.layerManager.getLayerByName(dataType);
        if (lay) {
            //формируем xml с данными
            var sendingData = '<data ID="'+idStr+'"/>';
            if (lay.dataProvider && lay.dataProvider.semantic && lay.dataProvider.semantic!="") {
                /*_model.wait();*/
                /*Logger.info("Запуск удаления семантики объекта: ID="+savingEntityId+"; request="+sendingData);*/
                var deleteRequestParams = DBUtil.getDeleteReqParams(lay.dataProvider.semantic, sendingData);
                //Устанавливаем курсор ожидания
                BlockingUtil.wait();
                //BlockingUtil.blockApplication();
                DBUtil.CURRENT_DELETING_MESSAGE_ID = App.serverQueryXMLNodeWithTries(Services.processQueryNode, deleteRequestParams, DBUtil.deleteSemResult, DBUtil.deleteFault);
            } else {
                // Отправляем событие завершения операции с ошибкой
                DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
                    , OperationEvent.DATA_PART_SEM, dataType, idStr, DBUtil.NO_SEMANTIC_REQUEST_ERROR);
            }
        } else {
            // Отправляем событие завершения операции с ошибкой
            DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
                , OperationEvent.DATA_PART_SEM, dataType, idStr, DBUtil.NO_LAYER_ERROR/*StringUtil.substitute(NO_LAYER_ERROR,dataType)*/);
        }
    } else {
        // Отправляем событие завершения операции с ошибкой
        DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
            , OperationEvent.DATA_PART_SEM, dataType, idStr, DBUtil.NO_LAYER_ERROR/*StringUtil.substitute(NO_LAYER_ERROR,dataType)*/);
    }
};

//слушатели результата удаления семантики
DBUtil.deleteSemResult = function(data) {
    //Снимаем курсор ожидания
    BlockingUtil.ready();
    if (data) {
        var er = HTTPServiceUtil.getError(data);
        var classId = "";
        var objectId = "";
        if (DBUtil.savingEntityId && DBUtil.savingEntityId!="" && DBUtil.savingEntityId.indexOf("/")>=0) {
            classId = DBUtil.savingEntityId.split("/")[0];
            objectId = DBUtil.savingEntityId.split("/")[1];
        }
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent((DBUtil.propertyPanelName=="") ? OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID : OperationEvent.OBJECT_DELETED_BY_ID
            , OperationEvent.DATA_PART_SEM, classId, objectId, er);

        DBUtil.savingEntityId = "";
    }
    //очищаем вспомогательные переменные и слой, на котором рисовали
    DBUtil.savingGeometry = null;
    DBUtil.savingLayer = null;
};

//Обработка fault при удалении геометрии или семантики - посылаем сообщение об ошибке
DBUtil.deleteFault = function(info) {
    //Снимаем курсор ожидания
    BlockingUtil.ready();
    //BlockingUtil.unblockApplication();
    DBUtil.fault(info);
    var classId = "";
    var objectId = "";
    if (DBUtil.savingEntityId && DBUtil.savingEntityId!="" && DBUtil.savingEntityId.indexOf("/")>=0) {
        classId = DBUtil.savingEntityId.split("/")[0];
        objectId = DBUtil.savingEntityId.split("/")[1];
    }
    var er = DBUtil.NO_SEMANTIC_REQUEST_ERROR;
    //Отправляем событие завершения операции с ошибкой
    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_DELETED_BY_ID, OperationEvent.DATA_PART_ALL, classId, objectId, er);
};

//Функция удаления объекта по имени панели свойств
//Получает форму по названию панели свойств, и если форму загрузилась удачно - пытаемся получить ее dataProvider
DBUtil.deleteObjectByPropertyPanelName = function(idStr, dataType, propertyPanelName) {
    if (idStr!="" && dataType!="" && propertyPanelName!="") {
        //Заново загружаем форму (даже если есть - нам из описания нужно получить только dataProvider).
        //TODO - Нужно сделать отдельный скрипт для получения только dataProvider'a формы по dataType, но пока что делаем так
        /*var f:DataForm = new DataForm(propertyPanelName);
        if(!f.isReady)
        {
            f.addEventListener(Event.COMPLETE, formComplete);
            f.addEventListener(Event.CLOSE, formClose);
        }*/
    }
};

//Функция отправки сообщения о результате выполнения операции (insert, update, delete)
DBUtil.sendOperationResultEvent = function(type, dataPart, classId, objectId, error, data) {
    var opCompleteEvt = new OperationEvent(type);
    //Указываем, какая часть была удалена
    opCompleteEvt.dataPart = dataPart;
    opCompleteEvt.rowData = data;
    opCompleteEvt.classId = DBUtil.savingEntityId.split("/")[0];
    opCompleteEvt.objectId = DBUtil.savingEntityId.split("/")[1];
    //Обрабатываем тип строки ошибки (если пустая - операция прошла успешно)
    if (error=="") {
        opCompleteEvt.operationSuccess = true;
    } else {
        opCompleteEvt.operationSuccess = false;
        //Если операция не групповая - нужн
    }
    //Сохраняем текст сообщения об ошибке
    opCompleteEvt.operationData = error;
    opCompleteEvt.dispatch();
};

DBUtil.fault = function(info) {
    //очищаем привязку
    DBUtil.savingBindData = null;
};

/**
 * Сериализует объект в xml строку тега <data>
 * @param data
 * @returns {string}
 */
DBUtil.serializeData = function(data) {
    var result = "<data ";
    for(var item in data){
        if(item !== '') {
            result += ' ' + item + '="' + (''+data[item]).xmlEscape() + '" ';
        }
    }
    result += ' />';
    return result;
};

/**
 * Сериализует объект в xml строку тега <data> с атрибутом фильтр
 * @param data
 * @returns {string}
 */
DBUtil.serializeDataWithFilter = function(data) {
    var result = "<data ";
    for(var item in data){
        if(item === 'ID')
            result+=' FILTER="'+item+'='+data[item]+'" ';
        else
            result+=' '+item+'="'+data[item]+'" ';
    }
    result += ' />';
    return result;
};


DBUtil.insertStoIliDataAdvToDB = function(data, dataAdapter, provider) {
    if (data) {
        DBUtil.savingEntityId =  '/';
        var reqParams = DBUtil.getReqParams(provider, DBUtil.serializeData(data), 'insert');
        App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
            if (resultXML) {
                var er = HTTPServiceUtil.getError(resultXML);
                if (er !== "") {
                    /*App.errorReport(title, er, undefined, {
                        filename: gis_filename_243,
                        functionname: 'gis_filename_243_56'
                    });*/
                    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', er);
                    return;
                }
            }
            DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED
                , OperationEvent.DATA_PART_ALL, '', '', '');
            DBUtil.savingEntityId = "";
        },function (resultXML) {
            var er = HTTPServiceUtil.getError(resultXML);
            if (er !== "") {
                /*App.errorReport(title, er, undefined, {
                    filename: gis_filename_243,
                    functionname: 'gis_filename_243_57'
                });*/
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', er);
            }
            else
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', resultXML);
        });
    }
    else {
        // если нет ID или типа - показываем сообщение об ошибке и отправляем результат с ошибкой
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', '');
    }
};

DBUtil.insertObjectToDB = function(data, dataAdapter, colTypes) {
    if (data) {
        var layerId = dataAdapter.currentGridDescr.layerId;
        var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
        var curLayerObj = layerManagerInst.getLayerByName(layerId);
        if (curLayerObj) {
            var dataRequest = curLayerObj.dataProvider.semantic;
            var descrType = (!data.ID) ? 'insert' : 'update';
            //добавляем атрибут SYS_OBJ_ID, т.к. update в панелях свойств использует его
            if (descrType === 'update')
                data.SYS_OBJ_ID = data.ID;
            DBUtil.savingEntityId = layerId+'/';
            var validate = '';
            for(var d in data){
                if(colTypes){
                    //upd. 28.03.22 инц. 2686, при пасте из экселя,  выполнять замену на NULL для тех колонок, которые есть в буфере вставки и отправлять эти null на update;
                    if(colTypes[d] === 'date' && data[d] === ''){
                        data[d] = '';
                        //delete data[d];
                        continue;
                    }
                    validate += GridUtil.validateCell2(data[d], colTypes[d], d);
                }
            }
            if(validate  !== ''){
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', validate);
                return;
            }
            var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(data), descrType);
            App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
                if (resultXML) {
                    var er = HTTPServiceUtil.getError(resultXML);
                    if (er !== "") {
                        DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', er);
                        return;
                    }
                }
                DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED
                    , OperationEvent.DATA_PART_ALL, '', '', '');
                DBUtil.savingEntityId = "";
            }, function (resultXML) {
                var er = HTTPServiceUtil.getError(resultXML);
                if (er !== "") {
                    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', er);
                } else
                    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', resultXML);
            },4);
        }
    }
    else {
        // если нет ID или типа - показываем сообщение об ошибке и отправляем результат с ошибкой
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_INSERTED, OperationEvent.DATA_PART_ALL, '', '', '');
    }
};


DBUtil.reverseObject = function(data, classId) {
    if (data) {
        var dataRequest = 'GAZPROM_ADM_SEM.xml#VTD_CORR_REVERSE';
        var descrType = 'insert';
        DBUtil.savingEntityId = classId+'/'+data.ID;
        var dto = {
            ILI_INSPECTION_ID: data.ILI_INSPECTION_ID,
        }
        var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(dto), descrType);
        App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
            if (resultXML) {
                var er = HTTPServiceUtil.getError(resultXML);
                if (er !== "") {
                    DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID, OperationEvent.DATA_PART_ALL, '', '', er);
                    return;
                }
            }
            DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_REVERSED_RESULT_BY_ID
                , OperationEvent.DATA_PART_ALL, '', '', '', data);
            DBUtil.savingEntityId = "";
        }, function (resultXML) {
            var er = HTTPServiceUtil.getError(resultXML);
            if (er === "") er = resultXML;
            DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID, OperationEvent.DATA_PART_ALL, '', '', er);
        });
    }
    else {
        //Отправляем событие завершения операции
        DBUtil.sendOperationResultEvent(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID, OperationEvent.DATA_PART_ALL, '', '', '');
    }
};

/* Глобальный объект с функциями логирования */
LogUtil = {};

/* Константы для логирования */
LogUtil.Severity_CRITICAL = 1; // Фатальная ошибка
LogUtil.Severity_ERROR = 2; // Ошибка
LogUtil.Severity_WARNING = 4; // предупреждение
LogUtil.Severity_INFO = 8; // информационное сообщение

LogUtil.Severity_VERBOSE = 16; // отладка

LogUtil.Severity_START = 256; // начало процесса
LogUtil.Severity_STOP = 512; // остановка процесса
LogUtil.Severity_SUSPEND = 1024; // приостановка процесса
LogUtil.Severity_RESUME = 2048; // возобновление процесса
LogUtil.Severity_TRANSFER = 4096; // передача управления другому процессу

//Запись в лог сервера текста
/**
 *
 * @param {String} message
 * @param {AuditEventType} category
 * @param {int} severity
 * @param {String} context
 * @returns {*}
 */
LogUtil.sendLog = function(message , category , severity , context ) {
    /* Закомментировать return; для отладки */
    /*return;*/
    message = (message) || ' ';
    category = (category) || AuditEventType.DEFAULT;
    severity = (severity) || LogUtil.Severity_CRITICAL;
    context = (context) || ' ';
    var req = $.ajax({
        type: "POST",
        url: Services.logNode,
        data: {
            message: message,
            categories: category,
            severity: severity,
            context: context
        },
        timeout: App && App.clientRequestTimeout !== undefined ? App.clientRequestTimeout : 0,
        dataType: 'json'
    });
    //Возвращаем ссылку на запрос (для возможности отмены запроса)
    return req;
};

/* Типы событий аудита */
AuditEventType = {
    USER_LOGIN: 32,
    USER_LOGOUT: 34,
    TASK_START: 256,
    TASK_STOP: 257,
    MODULE_START: 258,
    MODULE_STOP: 259,
    DEFAULT: 260
};
//Запись в журнал аудита события
//upd 20
/**
 *
 * @param {int} userId
 * @param {AuditEventType} auditType
 * @param {String} success 'true' or 'false'
 * @param {String} details
 */
LogUtil.sendAuditEvent = function (userId, auditType , success, details ) {
    LogUtil.sendLog(logutil_1, auditType, LogUtil.Severity_INFO, logutil_2 + userId + ", " + logutil_3 + success);
};

/* Глобальный объект с функциями фильтрации */
FilterUtil = {};
//Создание строки фильтра для отправки в запрос
FilterUtil.getFilterString = function (filters/*Array*/) {
	var _strFilter = "";
	if (filters && filters.length > 0) {
		var res = [];
		var n;
		for (var j = 0; j < filters.length; j++) {
			var f = filters[j];
			if (f.hasOwnProperty("val")) {
				switch (f.op) {
					case 'in': // из списка
						res.push(f.fld + " IN (" + FilterUtil.getArrayDictFilter(f.val) + ")");
						break;
					case '=': // число или строка
						//Даты игнорируем (они добавятся в фильтр верхнего уровня как переменные)
						if (f.hasType == 'date') break;
						if (f.hasType == 'number') {
							if ((f.val.toString()).indexOf(";") > 0) { //тогда имеет место массив чисел и нужен оператор in
								var arr = f.val.toString().split(";");
								res.push(f.fld + " IN (" + FilterUtil.getArrayFilter(arr) + ")");
							} /*else if ((f.val.toString()).indexOf(",") > 0) {
							 res.push(f.fld + " IN (" + f.val.toString() + ")");
							 }*/ else {
								n = FilterUtil.getNumber(f.val.toString().replace(',', '.'));
								if (!isNaN(n))
									res.push(f.fld + " = " + n.toString());
							}
						} else {
							if ((f.val.toString()).indexOf(";") >= 0) { //тогда имеет место массив строк и нужен оператор in
								var arrStr = f.val.toString().split(";");
								//проверяем, все ли элементы в кавычка, если нет, то ставим
								for (var i = 0; i < arrStr.length; i++) {
									//replace (';;',';XZY;') заменяем
									if (arrStr[i].length == 0)
										arrStr[i] = "XZY";
									if (arrStr[i].indexOf("'") == -1) { //т.е. строки данного элемента ещё не обрамлены в кавычки
										if (arrStr[i].length > 0)
											arrStr[i] = "UPPER('" + arrStr[i] + "')";
									}
								}
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY')" + " IN (" + FilterUtil.getArrayFilter(arrStr) + ")");
							} else if ((f.val.toString()).indexOf(",") > 0) {
								var replStr = f.val.toString();
								replStr = replStr.replace(",,", ",XZY,");
								replStr = replStr.toUpperCase();
								// вставляем как есть
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN (" + FilterUtil.validate(f.val) + ")");
							} else {
								if (f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
									res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
								else
									res.push("UPPER(" + f.fld + ") LIKE UPPER('%" + FilterUtil.validate(f.val) + "%')");
							}
						}
						break;
					default: // только числа
						//тут меняем первую запятую и меняем на точку. Если получится число, то отправляем запрос
						n = FilterUtil.getNumber(f.val.toString().replace(',', '.'));
						if (!isNaN(n))
							res.push(f.fld + " " + FilterUtil.validate(f.op) + " " + n.toString());
						break;
				}
			}
		}
		if (res.length > 0)
			_strFilter = res.join(" AND ");
	}
	if (_strFilter == "")
		_strFilter = '8=8';

	return _strFilter.replace('&amp;#60;', '&amp;lt;'); //Фиксим баг #1016 - Если задать условие "<" , то ничего не найдется.
};

FilterUtil.getFilterStringFromObject = function (filter/*Object*/) {
	var filterStr = '';
	if(filter){
		Object.keys(filter).forEach(function (key) {
			var escapeFilterVal = (''+filter[key]).xmlEscape();
			filterStr += ' ' + key + '="' + escapeFilterVal + '" ';
		});
	}
	return filterStr;
}


/**
 * Получение значений с кавычками, если строка и без них, если число. Объединяет значения одного массива в строку через ","
 * @param {Array}dict
 * @returns {string}
 */
FilterUtil.getArrayDictFilter = function (dict) {
	if (dict && (dict.length > 0)) {
		var res = [];
		for (var i = 0; i < dict.length; i++) {
			var d = dict[i];
			if (d.hasOwnProperty('CODE')) {
				var v = d.CODE;
				if (typeof v == 'string'){
                    if(v == 'NULL')
                        res.push("NULL");
					else //экранируем двойные кавычки, чтобы не рушился формат xml
	                    res.push("'" + v.toString().replace(/\"/g,'&quot;') + "'");
                }

				else
					res.push(v.toString());
			}
		}
		return res.join(", ");
	}
	return 'NULL';
};

/**
 * Объединение значений в строку
 * @param {Array}dict
 * @returns {string}
 */
FilterUtil.getArrayFilter = function (dict) {
	if (dict && (dict.length > 0)) {
		var res = [];
		for (var i = 0; i < dict.length; i++) {
			var d = dict[i];
			if (d.length == 0 || d == " ")
				continue;
			res.push(d);
		}
		return res.toString(); //TODO - проверить что объединяет строки !!!
	}
	return 'NULL';
};

/**
 * Получение числа из строки с заменой символа разделителя
 * @param {string}value
 * @returns {Number}
 */
FilterUtil.getNumber = function (value) {
	var n = parseFloat(value);
	if (!isNaN(n))
		return n;
	return parseFloat(value.replace(",", "."));
};

/**
 * Получение числа из строки с заменой символа разделителя
 * @param {string} val
 * @returns {string}
 */
FilterUtil.validate = function (val) {
	val = val.replace(/&/g, '&amp;');
	val = val.replace(/<=/g, '&amp;lt;=');
	val = val.replace(/</g, '&amp;lt;');
	val = val.replace(/>=/g, '&amp;gt;=');
	val = val.replace(/>/g, '&amp;gt;');
	val = val.replace(/"/g, '&amp;quot;'); //" просто чтобы форматирование нормально показывалось
	return val;
};
FilterUtil.showLightWeightFilter = function(opt_options){
	var options = opt_options || {};
	var filterId = options.filterId;
	var requestId = options.requestId;
	if(!FilterSourceDataManager[requestId])
		return;
	var datas = FilterSourceDataManager[requestId].datas;
	var currDialog = $('#lightWeightFilterDialog_' + options.filterId);

	App.destroyDialog(null, currDialog);
	var divv = '<div id="lightWeightFilterDialog_' + options.filterId + '" >' +
		'<div style="color: white;padding: 5px;">' +
		'В связи с тем, что список содержит большое количество записей, просим выбрать интересующие записи по одной в списке, расположенном ниже.' +
		'<br/>' +
		'Для удобства наберите часть имени искомой записи в строке поиска.' +
		'<br/><br/>' +
		'Выбор элемента списка для дальнейшей фильтрации осуществляется кликом. Все выбранные элементы отображаются в списке "Выбранные записи". ' +
		'<br/><br/>' +
		'После нажатия кнопки "Применить" выбранные записи будут приняты к использованию в общем фильтре.' +
		'</div>'+
		'<div style="padding: 5px;">' +
		'<div id="lightWeightFilterCombo_' + options.filterId + '" class="manageLayersDiv" ></div>' +
		'</div>'+
		'<div style="padding: 5px;">' +
		'<div id="lightWeightFilterResultGrid_' + options.filterId + '" class="manageLayersResultDiv" ></div>'+
		'</div>'+
		'<div class="manageLayersButtonsDiv" style="padding: 5px; margin-left: 160px;">' +
		'   <input type="button" name="apply" class="map-dialog-button" id="lightWeightFilterApply_'+ options.filterId+'" value="Применить">' +
		'   <input type="button" name="cancel" class="map-dialog-button" id="lightWeightFilterCancel_'+ options.filterId+'" value="Отменить">' +
		'</div>';

	divv +=	'</div>';
	$('body').append(divv);
	var dlg = $('#lightWeightFilterDialog_' + options.filterId);
	dlg.dialog({
		modal: true,
		title: 'Выбор записей фильтра',
		closeOnEscape: true,
		dialogClass: 'gsi-zindex__dialog',
		width: 500,
		height: 472,
		resizable: true
	});
	//заполняем данными элементы
	var lightWeightFilterSource = { localdata: datas, datatype: "array" };
	var lightWeightFilterDataAdapter = new $.jqx.dataAdapter(lightWeightFilterSource);
	$('#lightWeightFilterCombo_' + options.filterId).jqxComboBox({
		placeHolder:'Выберите запись', selectedIndex: -1, searchMode: 'containsignorecase', source: lightWeightFilterDataAdapter,
		autoComplete: true, displayMember: "DESCR", valueMember: "CODE", itemHeight: 21, height: 21, width: 490});
	$('#lightWeightFilterCombo_' + options.filterId).on('select', function (event) {
		var args = event.args;
		if (args) {
			var item = event.args.item;
			var originalElement = item.originalItem;
			$("#lightWeightFilterResultGrid_" + options.filterId).jqxGrid('addrow', null, originalElement);
		}
	});
	$('#lightWeightFilterApply_' + options.filterId).on('click',function(){
		var selectedRows = $("#lightWeightFilterResultGrid_" + options.filterId).jqxGrid('getrows');
		var divListCheckBoxes = $('#'+filterId+'_listCheckBoxes');
		divListCheckBoxes.jqxListBox({ source: selectedRows, checkboxes: true, itemHeight:21,
			displayMember: "DESCR", valueMember: "CODE",width:'100%',height:'100%',
			theme:'filter',
		}).data('applyfilter',true);
		divListCheckBoxes.jqxListBox('checkAll');
		divListCheckBoxes.data('items', selectedRows);
		divListCheckBoxes.data('checkedItems', divListCheckBoxes.jqxListBox('getCheckedItems'));
		$('#'+filterId+'_checkAll').data('infinite', true);

		App.destroyDialog(null, dlg);
	});
	$('#lightWeightFilterCancel_' + options.filterId).on('click',function(){
		App.destroyDialog(null, dlg);
	});
	var listCheckBoxes = $('#'+filterId+'_listCheckBoxes');
	var selectedItems = listCheckBoxes.jqxListBox('getCheckedItems');
	var selectedFilters = [];
	if(selectedItems && selectedItems.length > 0){
		selectedItems.forEach(function(item){
			selectedFilters.push(item.originalItem);
		});
	}


	var source ={
		localdata: selectedFilters,
		datatype: "array",
		//id: "LayerId",
		datafields:
			[
				{ name: 'CODE', type: 'string' },
				{ name: 'DESCR', type: 'string' },
			]
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#lightWeightFilterResultGrid_" + options.filterId).jqxGrid({
		width: 490,
		height: 207,
		source: dataAdapter,
		pageable: false,
		altRows: false,
		columnsResize: false,
		editable: false,
		theme:'gis-blue-grid',
		localization: getLocalization('ru'),
		columns: [
			{
				text: '', sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				datafield: 'delete', columntype: 'number', width: 25,
				cellsrenderer: function (row, column, value) {
					return "<div type='submit' class='map-img map-delete-img' onclick='FilterUtil.removeLayer_("+row+",\""+options.filterId+"\")'></div>";
				}
			},
			{   text: 'Выбранные записи', datafield: 'DESCR',
				sortable: false, filterable: false, editable: false,
				groupable: false, draggable: false, resizable: false,
				columntype: 'string', width: 445,
			}
		]
	});
}
FilterUtil.removeLayer_ = function(index, filterId){
	var rowId= $("#lightWeightFilterResultGrid_" + filterId).jqxGrid('getrowid', index);
	$("#lightWeightFilterResultGrid_" + filterId).jqxGrid('deleterow', rowId);
};
FilterUtil.generateFilterStub = function(){
	var result = [];
	for(var i = 0; i< 30000; i++){
		result.push({CODE: i, DESCR: 'Описание_'+i})
	}
	return result;
}
//Глобальный объект
GroupOperationsUtil = {};

GroupOperationsUtil.PROCESS_FORM_DIV = "processStatusForm";
GroupOperationsUtil.GROUP_OPERATION_ERROR_TEXT = gis_groupoperationutil_1;

//Создаем форму статуса процесса групповой последовательной обработки
/**
 * titleStr:String - Заголовок формы
 * array:Array=null - массив обрабатываемых объектов
 * thisObject:Object=null - Объект, от которого выполняются функции (модуль или форма, от которой запустили эту форму)
 * processFunction:Function=null - Функция обработки текущего элемента массива и ее аргументы
 * endFunction:Function=null - Функция, выполняемая при завершении обработки и ее аргументы
 * cancelFunction:Function=null - Функция, выполняемая при отмене обработки - обычно в ней будет отменяться текущий выполняемый вызов
 * */
GroupOperationsUtil.createProcessStatusForm = function createProcessStatusForm(titleStr/*String*/, array/*Array*/, thisObject/*Object*/,
    processFunction/*Function*/,endFunction/*Function*/,cancelFunction/*Function*/, modal/*Boolean*/) {
        var processStatusForm = new ProcessStatusForm();
    processStatusForm.title = titleStr;
    if (array) {
        processStatusForm.totalCount = array.length;
    }
    processStatusForm.objectsArray = array;
    processStatusForm.thisObject = thisObject;
    processStatusForm.processFunction = processFunction;
    processStatusForm.endFunction = endFunction;
    processStatusForm.cancelFunction = cancelFunction;
    processStatusForm.build(GroupOperationsUtil.PROCESS_FORM_DIV);//Форма выполнения групповых операций всегда одна!
    return processStatusForm;
};

//Показываем форму работы с групповыми ошибками, если она есть
GroupOperationsUtil.showActionOnErrorForm = function showActionOnErrorForm(actionOnErrorForm/*ActionOnErrorForm*/, listenerFunc/*Function*/, fullStr/*String*/) {
    if (actionOnErrorForm && listenerFunc!=null) {
        /*PopUpManager.addPopUp(actionOnErrorForm, (Application.application as DisplayObject), true);
        PopUpManager.centerPopUp(actionOnErrorForm);*/
        actionOnErrorForm.shortMessage = GroupOperationsUtil.GROUP_OPERATION_ERROR_TEXT;
        actionOnErrorForm.fullMessage = fullStr;
        actionOnErrorForm.addEventListener(CloseEvent.CLOSE,listenerFunc);
    }
};
/**
 * Менеджер фильтров для грида. Хранит также справочники для рендеринга в гриде не кодов справочников, а соответствующего им текста
 * */

 function FilterManager(opt_options) {
	this.options = goog.isDef(opt_options) ? opt_options : {};
    this.buffer = {};
    this.count = 0;
    this.filterType = "JS";//undefined;// если выставлен в "JS", то данные будут приходить в виде <data CODE="123" DESCR="aaa" />, иначе <data><CODE>123</CODE><DESCR>aaa</DESCR></data>
    //Константы
    this.CODE_NAME = "CODE";
    this.DESCR_NAME = "DESCR";
	if(WidgetMap !== undefined && WidgetMap.getShowErrorInGridDictationary() == false)//если выставлен флаг, то не показываем сообщения в гриде и текст будет другой
		this.EMPTY_NAME = gis_filtermanager_5;
	else
	    this.EMPTY_NAME = gis_filtermanager_1;

}

//Получение данных в виде массива
FilterManager.prototype.getArrayData = function getArrayData(filterRequestId/*String*/,callback) {
    var that = this;
    if (filterRequestId == "")
        return null;

    if (!that.buffer.hasOwnProperty(filterRequestId))
        that.addToBuffer(filterRequestId);

    var item/*FilterManagerItem*/ = that.buffer[filterRequestId];

    if (!item.isLoaded && !item.isLoading)
        that.getListData(filterRequestId,callback);
    //если элемент в процессе подгрузки, то возвращаем null
    if(item.isLoading)
        return 'loading';
    return item.data;
};

FilterManager.prototype.reloadDictationary = function reloadDictationary(filterRequestId/*String*/,callback) {
    var that = this;
    if (filterRequestId == "")
        return null;
    that.removeFromBuffer(filterRequestId);
    this.getArrayData(filterRequestId, callback);
};

//Добавление объекта "filterRequestId", чтобы позже через менеджера забирать данные
FilterManager.prototype.addToBuffer = function addToBuffer(filterRequestId) {
    var that = this;
    if(!that.buffer.hasOwnProperty(filterRequestId) || !that.buffer[filterRequestId]) {
        /*FilterManagerItem*/
        that.buffer[filterRequestId] = {
            filterRequestId: filterRequestId,
            dataAdapters: [],
            data: [],
            isLoading: false,
            isLoaded: false,
            messageId: ""
        };
    }
};

FilterManager.prototype.removeFromBuffer = function removeFromBuffer(filterRequestId) {
    var that = this;
    if(that.buffer.hasOwnProperty(filterRequestId) || that.buffer[filterRequestId]) {
        /*FilterManagerItem*/
        delete that.buffer[filterRequestId];
    }
};

//Добавление объекта dataAdapter, чтобы после загрузки обновить его коллекцию
FilterManager.prototype.addDataAdapterToBuffer = function addDataAdapterToBuffer(filterRequestId, dataAdapter) {
    var that = this;
    if(that.buffer.hasOwnProperty(filterRequestId)) {
        that.buffer[filterRequestId].dataAdapters.push(dataAdapter);
    }
};

//Формирование запроса для получения справочника
FilterManager.prototype.makeLoadFilterReqParams = function makeLoadFilterReqParams(dataRequest) {
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    return {
        getSchema: false,
        descrId: dataRequest,
        toElements: false,
        descrType: 'select',
        data:'<root USER_ID="'+userId.xmlEscape()+
        '" USER_LOGIN="'+userLogin.xmlEscape()+
        '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
        '<data/>'+
        '</root>'
    };
};

//Обновление данных во всех dataAdapter'ах после загрузки данных для визуального обновления
FilterManager.prototype.refreshDataAdapters = function refreshDataAdapters(item) {
    if (item) {
        for (var i = 0; i < item.dataAdapters.length; i++) {
            /*item.dataAdapters[i]._source.localdata = item.data;*/
            item.dataAdapters[i]._source.localdata = item.data;
            item.dataAdapters[i].dataBind();
        }
    }
};

//Менеджер, раздаёт и формирует данные справочника по id запроса
FilterManager.prototype.getListData = function (filterRequestId/*String*/,callback) {
    try {
        var that = this;
        var item/*FilterManagerItem*/ = that.buffer[filterRequestId];
        if (item.isLoaded) {
            //Обновление для визуального отображения
            that.refreshDataAdapters(item);
        } else {
            if (!item.isLoading) {
                /*SpinnerUtils.showDictSpinner();*/
                that.count++;
                //запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
                var filterRequest = FilterManager.prototype.makeLoadFilterReqParams(filterRequestId);
                //Делаем запрос на получение описания грида, сохраняя id для отмены

                var filterResult = function (xmlData) {
                    var er = HTTPServiceUtil.getError(xmlData);
                    if (er !== ''){
                        that.count--;
                        if (item) {
                            item.messageId = "";
                            item.isLoading = false;
                            item.isLoaded = false;
                        }
                        App.errorReport(gis_gridwidget_1, gis_filtermanager_2 + filterRequestId + gis_filtermanager_3 + xmlData, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_5'});
                        return;
                    }
                    //В замыкание должен попасть элемент item (чтобы знать какой filterRequestId запрашивался)
                    var fr = that.formatResponse(xmlData);
                    that.count--;
                    /*if(count==0)SpinnerUtils.hideDictSpinner();*/
                    if(item && item.data.length == 0) {
                        item.messageId = "";
                        if(fr.length > 0) {
                            /*item.data.push.apply(item.data, fr);*/
                            item.data = fr;
                            item.isLoading = false;
                            item.isLoaded = true;
                            //Это непосредственно установка запрошенных значений в источники, для которых был сделан запрос
                            that.refreshDataAdapters(item);
                            if(callback!=undefined){
                                callback({fr:fr});
                            }
                        }
                        else{
                            if(callback!=undefined)
                                callback({fr:fr});
                        }
                    }
                }
                var filterFault = function (xmlData) {
                    that.count--;
                    /*if(count==0)SpinnerUtils.hideDictSpinner();*/
                    if (item) {
                        item.messageId = "";
                        item.isLoading = false;
                        item.isLoaded = false;
                    }
                    App.errorReport(gis_gridwidget_1, gis_filtermanager_2 + filterRequestId + gis_filtermanager_3 + xmlData, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_1'});
                }

                var messageId = undefined;
                if(filterRequestId.indexOf('IUST_SEM_DICT.xml') !== -1 )
                    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, filterRequest, filterResult, filterFault );
                else
                    App.serverQueryXMLNodeWithTries(Services.processQueryNode, filterRequest, filterResult, filterFault,4);
                item.isLoading = true;
                item.messageId = messageId;
            } else {
                //Ничего не делаем - источник в процессе загрузки
            }
        }
    } catch(err) {
        App.errorReport(gis_gridwidget_1, gis_filtermanager_2 + filterRequestId + gis_filtermanager_3+ err, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_2'});
    }
};

//Преобразовывание полученных данных из делегата в массив объектов
FilterManager.prototype.formatResponse =  function formatResponse(xmlData) {
    var that = this;
    if(xmlData == "") {
        App.errorReport(gis_gridwidget_1, gis_filtermanager_4, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_3'});
        return [];
    }

    var str = HTTPServiceUtil.getError(xmlData);
    if(str!="") {
        App.errorReport(gis_gridwidget_1, str, undefined, {filename:gis_filename_607, functionname:'gis_filename_607_4'});
        return [];
    }

    var resXmlData = HTTPServiceUtil.getXMLData(xmlData);
    var formattedObjects = that.formatObject(resXmlData);


    return formattedObjects;
};

/**
 * Форматируем свойство CODE в Number если в схеме оно xs:decimal
 * @param res
 * @return
 *
 */
FilterManager.prototype.formatObject = function formatObject(res) {
    var that = this;
    if(that.filterType == "JS"){
	    var objects = [];
	    //Для удобства получения значения объекта по его коду создаем свойство массива codehash - это объект вида {CODE:DESCR}
	    var codeHash = {};
	    var fObj /*FilterDictObject*/;
	    var resData = res.find("data");
	    for (i = 0; i < resData.length; i++) {
            var it = $(resData[i]);
            var itCode = it.attr("CODE");
            if (!(itCode && itCode.length>0))
                itCode = that.EMPTY_NAME;
            var itDescr = it.attr("DESCR");
            if (!(itDescr && itDescr.length>0))
	            itDescr = that.EMPTY_NAME;
            fObj = {DESCR: itDescr, CODE: itCode};
		    objects.push(fObj);
            //Для удобства получения значения объекта по его коду добавляем хеш кода в объект codeHash
            codeHash[fObj.CODE] = fObj.DESCR;
	    }
	    //Для удобства получения значения объекта по его коду создаем свойство массива codehash - это объект вида {CODE:DESCR}
	    objects.codehash = codeHash;
	    return objects;
    }
    var schema;
    try {
        schema = res.find("xs\\:schema>xs\\:element>xs\\:complexType>xs\\:choice>xs\\:element>xs\\:complexType>xs\\:attribute:empty");
        if (schema && schema.length==0)
            schema = res.find("xs\\:complextype>xs\\:sequence>xs\\:element:empty");
        //schema = res.schema.element.complexType.choice.element.complexType.attribute;
    } catch(e) {
        schema = res.find("xs\\:complextype>xs\\:sequence>xs\\:element:empty");
        //schema = res.schema.element.complexType.choice.element.complexType.sequence.element;
    }
    var codeType;
    var i;
    for (i = 0; i < schema.length; i++) {
        var item = schema[i].attributes;
        if(item.name.value.toLowerCase() == that.CODE_NAME.toLowerCase()) {
            if(item.hasOwnProperty("type"))
                codeType = item.type.value;
            if(item.hasOwnProperty("simpleType") && item.simpleType.hasOwnProperty("restriction"))
                codeType = item.simpleType.restriction.base;
        }
    }


    var objects = [];
    //Для удобства получения значения объекта по его коду создаем свойство массива codehash - это объект вида {CODE:DESCR}
    var codeHash = {};
    var fObj /*FilterDictObject*/;
    var resData = res.find("data");
    for (i = 0; i < resData.length; i++) {
        try {
            var it = $(resData[i]);
            var itCode = it.find("CODE");
            if (itCode && itCode.length>0) {
                itCode = itCode[0].hasOwnProperty('innerText') ? itCode[0].innerText : itCode[0].innerHTML;
            } else {
                itCode = undefined;
            }
            var itDescr = it.find("DESCR");
            if (itDescr && itDescr.length>0) {
                itDescr = itDescr[0].hasOwnProperty('innerText') ? itDescr[0].innerText : itDescr[0].innerHTML;
            } else {
                itDescr = that.EMPTY_NAME;
            }
            fObj = {DESCR: itDescr, CODE: itCode};
            switch(codeType) {
                case "xs:decimal":
                case "xs:double":
                case "xs:long":
                    fObj.CODE = parseFloat(fObj.CODE);
                    objects.push(fObj);
                    break;
                case "xs:string":
                    objects.push(fObj);
                    break;
                default:
                    objects.push(fObj);
                    break;
            }
            //Для удобства получения значения объекта по его коду добавляем хеш кода в объект codeHash
            codeHash[fObj.CODE] = fObj.DESCR;
        } catch (e) {}
    }
    //Для удобства получения значения объекта по его коду создаем свойство массива codehash - это объект вида {CODE:DESCR}
    objects.codehash = codeHash;
    return objects;
};

/**
 * Получение объекта по коду и запросу
 * @param filterRequestId
 * @param code
 * @returns {string}
 */
FilterManager.prototype.getDataByDataField = function (filterRequestId, code) {
    if(filterRequestId && code){
        var item = this.buffer[filterRequestId];
        if(item && item.data && item.data.length > 0) {
            for (var i = 0; i < item.data.length; i++) {
                var it = item.data[i];
                if(it.CODE === code){
                    return it;
                }
            }
        }
    }
    return undefined;
}


//тут складируются результаты загруженных фильтров
FilterSourceDataManager = {};
//проверка, если открыт виджет w=1, и выбран сразу рубрикатор ВТД, то 1-е открытие игнорируем
//предполагается, что извне придет id обследования
//далее работа будет происходить по старой схеме с открытием окна выбора обследования при выборе вкладки
ExternalInteraction.firstCheckHead = true;

/**
 * Функция загрузки описания всех фильтров
 * @param filters
 * @param callback
 */
ExternalInteraction.loadFiltersDescr = function (filters, loadedFilters, callback) {
	var filters = [{title: gis_treeutils_11}, {title: gis_treeutils_10}]
	if (callback) callback(filters);
}

/**
 * Показать перед фильтром форму с выбором, какой из фильтров использовать
 * @param filterType
 * @param topFilterSource
 * @param middleFilterSource
 * @param showLayers
 * @param applyHandler
 */
ExternalInteraction.showSelectableFilter = function (filterType, topFilterSource, middleFilterSource, showLayers, applyHandler) {
	//сначала грузим все
	ExternalInteraction.loadFiltersDescr(middleFilterSource, [], function (filters) {
		$('#selectableFilterFormDialog').remove();
		var divv = '<div id="selectableFilterFormDialog">' +
			'<div class="filter-form-div">';
		divv += '<div>' + gis_treeutils_12 + '</div><br/>';
		var checked = '';
		var height = 160;
		for (var i = 0; i < filters.length; i++) {
			checked = (i === 0) ? 'checked' : '';
			divv += '<div class="filter-form-radio">';
			divv += '   <input name="filterRadio" id="filterRadio_' + i + '" type="radio" ' + checked + ' value="' + i + '"/>';
			divv += '   <label for="filterRadio_' + i + '" style="margin-left: 5px;">' + filters[i].title + '</label>';
			divv += '</div>';
			height += 30;
		}
		divv += '<br/><div>' + gis_treeutils_13 + '</div>';
		divv += '</div></div>';
		$('body').append(divv);
		var dlg = $('#selectableFilterFormDialog');
		var buttons = [{
			text: gis_core_16,
			click: function () {
				var selectedFilterIndex = Number($("input[name='filterRadio']:checked", dlg).val());
				if (applyHandler)
					applyHandler(selectedFilterIndex);
				$('#selectableFilterFormDialog').remove();
			}
		},
			{
				text: gis_treeutils_9,
				click: function () {
					if (applyHandler)
						applyHandler(-1);
					$('#selectableFilterFormDialog').remove();
				}
			}];
		dlg.dialog({
			modal: true,
			title: gis_treeutils_8,
			dialogClass: 'noCloseButton gsi-zindex__dialog',
			closeOnEscape: true,
			width: 470,
			height: height,
			resizable: false,
			buttons: buttons,
		});
	})
};

ExternalInteraction.showFilter = function (filterType, topFilterSource, middleFilterSource, showLayers, applyHandler) {
	var isMiddleFilter = topFilterSource === undefined || topFilterSource === '';
	//если уже был открыт средний фильтр, то игнорируем. Обход ситуации, когда от каждого фильтра рубрикатора вызывается checkHeadRadioHandler
	if ($('#middleFilterDialog').length > 0)
		return;
	$('body').append('<div id="middleFilterDialog"></div>');
	var dlg = $('#middleFilterDialog');
	dlg.append('<div id="middleFilterDiv"></div>');
	var middleFilterDiv = $('#middleFilterDiv');
	middleFilterDiv.myFilters({
		dataSource: middleFilterSource,
		handlers: {
			applyHandler: function (params) {
				//устанавливаем верхний фильтр
				var resFilterValues = middleFilterDiv.myFilters('getFilterValuesArray');
				var dotSplitArr = resFilterValues[0].values;
				//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
				var roughArr = [];
				for (var j = 0; j < dotSplitArr.length; j++) {
					roughArr.push(dotSplitArr[j].code);
				}
				if (dotSplitArr.length == 0) {
					roughArr.push('NULL');
				}
				var showInfo = false;
				$('#middleFilterDialog').remove();
				var idFilter = resFilterValues[0].idFilter;
				if (isMiddleFilter) {
					var rr = [];
					WidgetMap.currentRoughFilter = [];
					for (var k = 0; k < showLayers.length; k++) {
						//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
						var smallLayerId = showLayers[k];
						rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
						WidgetMap.currentFilter[smallLayerId] = [];
						WidgetMap.currentFilter[smallLayerId].push({
							layerName: smallLayerId,
							filter: idFilter,
							value: roughArr.join(",")
						});
						WidgetMap.currentRoughFilter.push({name: idFilter, value: roughArr.join(","), layerName:smallLayerId});
					}

					//WidgetMap.currentRoughFilter = [{name:idFilter, value:}];
					if (applyHandler !== undefined)
						applyHandler();
				}
				//если был объявлен верхний фильтр, то при работе со средним выбранные значения будут заноситься в верхний
				else {
					//если открывался ещё средний фильтр, то выставляем currentRoughFilter для корректного нанесения геометрии на карту
					if (middleFilterSource !== undefined && middleFilterSource !== '' && filterType.indexOf('middle') !== -1) {
						var rr = [];
						WidgetMap.currentRoughFilter = [];
						for (var t = 0; t < showLayers.length; t++) {
							//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
							var smallLayerId = showLayers[t];
							rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
							WidgetMap.currentRoughFilter.push({name: idFilter, value: roughArr.join(","), layerName: smallLayerId});
						}
					}
					var newData = '<data OBJ_IDS="' + roughArr.join(',') + '" TOP_FILTER="' + idFilter + '" ></data>';
					var treeDiv = $('#treeDiv');
					if(treeDiv.length > 0)
						treeDiv.myCategories('updateTopFilter', {params: newData});

					function checkFilter(filter) {
						WidgetMap.updateTopFilter(filter.params);
						var splittedFilter = filter.params[0].value.split('|');
						for (var i = 0; i < splittedFilter.length; i++) {
							if (splittedFilter[i].indexOf(filterName) != -1) {
								var filterValue = splittedFilter[i].split(':')[1];
								for (var k = 0; k < showLayers.length; k++) {
									//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
									var smallLayerId = showLayers[k];
									WidgetMap.currentFilter[smallLayerId] = [];
									WidgetMap.currentFilter[smallLayerId].push({
										layerName: smallLayerId,
										filter: filterName,
										value: filterValue
									});
								}
								if (filterValue == '' || filterValue == 'VOID') {
									showInfo = true;
								}
								if (filterValue !== roughArr.join(',')) {
									return false;
								}
								break;
							}
						}
						return true;
					}

					var filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: {}}) : undefined;
					if (filter && filter.params && filter.params.length > 0) {
						//добавляем проверку на выбранное кол-во записей перед открытием грида
						if (goog.isDef(idFilter)) {
							var filterName = idFilter;
							var start = Date.now();
							var timeout = 0;
							while (!checkFilter(filter) && timeout < 1000) {
								filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: {}}) : undefined;
								timeout = Date.now() - start;
							}
						}
					}
					if (showInfo) {
						var text = gis_treeutils_3;
						var title = gis_treeutils_4;
						var buttons = [
							{text: gis_core_4, click: showGridDialog},
							{text: gis_core_5, click: closeDialog}
						];
						var dlg = App.confirmDialog(text, buttons, {title: title, width: 400});

						function closeDialog() {
							dlg.dialog('destroy');
							dlg.remove();
						}

						function showGridDialog() {
							if (applyHandler !== undefined)
								applyHandler();
							closeDialog();
						}
					} else if (applyHandler !== undefined)
						applyHandler(roughArr);
				}
			},
			cancelHandler: function (params) {
				$('#middleFilterDialog').remove();
			}
		}
	});

	var closeDiv = '<div id="middleFilterCloseDiv" class="middleFilterCloseDiv"></div>';
	middleFilterDiv.append(closeDiv);
	$('#middleFilterCloseDiv').on('click', function (event) {
		$('#middleFilterDialog').remove();
	});
	dlg.dialog({
		resizable: false,
		modal: true,
		dialogClass: 'noCloseButton noTitleBar gsi-zindex__dialog',
		width: 605,
		height: 440,
		title: ''
	});

};


ExternalInteraction.showLayers = function (showLayers, clearFilter) {
	if (showLayers.length > 0) {
		if (WidgetMap.layerManager !== undefined) {
			for (var index = 0; index < showLayers.length; index++) {
				var smallLayerId = showLayers[index];
				var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
				if (goog.isDef(layer)) {

					if (layer.filter !== undefined && layer.filter !== '' && WidgetMap.isModelsVector == true) {
						//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
						WidgetMap.layerManager.clearLayer(smallLayerId, true);
					}
					if(clearFilter === true){
						layer.filter = undefined;
						layer.filters = undefined;
						if(layer.layer){
							layer.layer.filter = undefined;
							layer.layer.filters = undefined;
						}
					}
					if (layer.visible != true)
						WidgetMap.layerManager.updateLayer(smallLayerId);
					WidgetMap.layerManager.enableLayer(smallLayerId);
				}
			}
		}
	}
}

ExternalInteraction.openTables = function (scenarioParams) {
	var timeout = 3000;
	if (scenarioParams !== undefined) {
		if (scenarioParams.openTableInterval !== undefined)
			timeout = scenarioParams.openTableInterval;
		//сначала подгружаем часть стиля для получения title грида
		var openTableTitle = scenarioParams.openTableTitle;
		var openTableGridId = scenarioParams.openTableGridId;
		var openTableLevelParams = scenarioParams.openTableLevelParams;
		var openTableShowDashboard = scenarioParams.openTableShowDashboard;
		var querySource = scenarioParams.querySource;
		var queryLayerId = scenarioParams.queryLayerId;
		var queryFileName = scenarioParams.queryFileName;
		//если есть данные для открытия гридов
		if (openTableTitle !== undefined && openTableGridId !== undefined && openTableLevelParams !== undefined
			&& querySource !== undefined && queryLayerId !== undefined && queryFileName !== undefined) {
			var openTableTitleArr = openTableTitle.replace('undefined|', '').split('|');
			var openTableGridIdArr = openTableGridId.replace('undefined|', '').split('|');
			var openTableLevelParamsArr = openTableLevelParams.replace('undefined|', '').split('|');
			var openTableShowDashboardArr = openTableShowDashboard?openTableShowDashboard.replace('undefined|', '').split('|'): undefined;
			var querySourceArr = querySource.replace('undefined|', '').split('|');
			var queryLayerIdArr = queryLayerId.replace('undefined|', '').split('|');
			var queryFileNameArr = queryFileName.replace('undefined|', '').split('|');
			var gridArr = [];

			function loadStyle() {
				if (gridArr.length > 0) {
					var gridItem = gridArr.pop();
					if (gridItem.title.indexOf('{') == -1) {
						ExternalInteraction.openTable(gridItem.gridId, gridItem.title, gridItem.levelParams, gridItem.showDashboard, scenarioParams.openTableMinimize);
						setTimeout(function () {
							loadStyle();
						}, timeout)
					} else
						App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
							{
								descrId: gridItem.source,
								descrType: 'select',
								getSchema: false,
								toElements: false,
								data: '<root><data LAYER_ID="' + gridItem.layerId + '" FILE_NAME="' + gridItem.fileName + '"/></root>'
							},
							function (xmlElement) {
								var xmlData = ($.parseXML(xmlElement)).firstChild;
								var styles = xmlData.getElementsByTagName("Style");
								var i = 0;
								if (styles.length > 0) {
									var curStyle = styles[0];
									var descr = curStyle.getAttribute('descr');
									//открываем грид
									if (descr !== undefined && descr !== '') {
										ExternalInteraction.openTable(gridItem.gridId, descr, gridItem.levelParams, false, scenarioParams.openTableMinimize);
										setTimeout(function () {
											loadStyle();
										}, timeout)
									}
								}
							},
							function (xmlElement) {
							});
				}
			}

			//если количество данных для открытия гридов совпадает
			if (openTableTitleArr.length == openTableGridIdArr.length && openTableTitleArr.length == openTableLevelParamsArr.length &&
				openTableTitleArr.length == querySourceArr.length && openTableTitleArr.length == queryLayerIdArr.length &&
				openTableTitleArr.length == queryFileNameArr.length) {
				for (var i = 0; i < querySourceArr.length; i++) {
					if(queryLayerIdArr[i])
						gridArr.push({
							title: openTableTitleArr[i],
							source: querySourceArr[i],
							layerId: queryLayerIdArr[i],
							fileName: queryFileNameArr[i],
							gridId: openTableGridIdArr[i],
							levelParams: openTableLevelParamsArr[i],
							showDashboard: (openTableShowDashboardArr)?openTableShowDashboardArr[i]:undefined,
						});
				}
				loadStyle();
			}
		}
	}
}

//открытие грида
ExternalInteraction.openTable = function (gridId, descr, levelParams, showDashboard, minimize) {
	var prms = {
		event_name: 'FULL_GRID_EVENT_ID_MODULE',
		levelParams: levelParams, //"layerId=PODS_INSP_Layers.xml#"PODS_ILI_DATA_FEATURE;",
		vars: {
			functionName: '',
			gridId: gridId,
			layerId: '',
			mdl: 'Public/SWF/Grid_55.swf',
			needTopFilter: 'true',
			task: 'GRID',
			title: descr,
			useSynchCommands: 'false',
			windowTemplateId: 'gridWindow',
			onlyGrid: true,//новое, чтобы дальше не подгружались данные на карте для слоя,
			showDashboard: showDashboard,
			minimize: minimize,//нужно ли минимизировать размер грида, как при клике центровки
		}
	};
	ExternalInteraction.treeCallFunction(prms, 'clickButton');
};

/**
 * Реакция на кнопки в рубрикаторе
 * @param params
 */
ExternalInteraction.treeCallFunction = function (params, funcName) {
	var vars = params.vars;
	//флаг открытия грида в одной вкладке или каждый раз в новой
	//по умолчанию все гриды открываются в одной и той же вкладке, соответствующей данному id грида
	var useExistList = true;
	var useSynchCommands = false;//(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true);
	if (goog.isDefAndNotNull(vars)) {
		if (funcName === 'loadScenario') {
			//забираем флаг открытия среднегно фильтрна, список на открытие гридов и список на включение слоёв
			var middleFilterSource = '';//'MIDDLE_ILI_FILTER';
			var topFilterSource = '';//'ILI_INSP_FILTER;
			var filterType = '';
			if (vars.filterType !== undefined && vars.filterType !== '')
				filterType = vars.filterType;
			if (vars.middleFilterSource !== undefined && vars.middleFilterSource !== '')
				middleFilterSource = vars.middleFilterSource;
			if (vars.topFilterSource !== undefined && vars.topFilterSource !== '')
				topFilterSource = vars.topFilterSource;
			var showLayers = [];//['PODS_ILI_DATA','PODS_ILI_DATA_FEATURE'];
			if (vars.openLayers !== undefined && vars.openLayers !== '')
				showLayers = vars.openLayers;
			if (middleFilterSource !== '') {
				if (Array.isArray(middleFilterSource)) {
					ExternalInteraction.showSelectableFilter(filterType, topFilterSource, middleFilterSource, showLayers, function (selectedFilterIndex) {
						//выбираем тот средний фильтр за основу, который пришел из формы выбора
						vars.middleFilterSource = middleFilterSource[0];
						if (selectedFilterIndex < middleFilterSource.length)
							vars.middleFilterSource = middleFilterSource[selectedFilterIndex];
						if (selectedFilterIndex !== -1) {
							ExternalInteraction.showFilter(filterType, topFilterSource, vars.middleFilterSource, showLayers, function () {
								ExternalInteraction.showLayers(showLayers);
								ExternalInteraction.openTables(vars);
							})
						} else {
							//если selectedFilterIndex = -1 , значит выбрать всё
							ExternalInteraction.showLayers(showLayers, true);//флаг, чтобы удалить фильтр. нужно переработать
							ExternalInteraction.openTables(vars);
						}
					})
				} else {
					ExternalInteraction.showFilter(filterType, topFilterSource, middleFilterSource, showLayers, function () {
						//TODO рефакторинг
						if (WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.fullLayerId){
							var pArr = [],
								fullLayerId = WidgetMap.config.grid.fullLayerId.replace('#', '*');
							for (var key in WidgetMap.config.grid)
								pArr.push({name: key, value: WidgetMap.config.grid[key]});
							ExternalInteraction.openGrid({
									pArr: pArr,
									reload: useExistList,
									fullLayerId: fullLayerId,
									forceTopFilter: true,
								});
							return;
						}
						ExternalInteraction.showLayers(showLayers);
						ExternalInteraction.openTables(vars);
					})
				}
			} else {
				ExternalInteraction.showLayers(showLayers);
				ExternalInteraction.openTables(vars);
			}
		}
		if (funcName === 'clickButton') {
			if (params.event_name === 'FULL_GRID_EVENT_ID_MODULE') {
				var levelParams = params.levelParams;
				var fullLayerId = '';
				var smallLayerId = '';
				if (levelParams != '') {
					fullLayerId = levelParams.split('=')[1].split(';')[0];
					smallLayerId = fullLayerId.split('#')[1];
				}
				//1. Устанавливаем текущий фильтр
				var showInfo = false;
				//получили фильтры
				var treeDiv = $('#treeDiv');
				var filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: params}) : undefined;
				WidgetMap.updateTopFilter(filter.params);
				var mapParams = [];
//                mapParams.push({name:'filter',value: filter.params});
				if (filter && filter.params && filter.params.length > 0) {
					mapParams.push(filter.params[0]);
					//добавляем проверку на выбранное кол-во записей перед открытием грида
					if (goog.isDef(vars.filter)) {
						var filterName = vars.filter;
						var splittedFilter = filter.params[0].value.split('|');
						for (var i = 0; i < splittedFilter.length; i++) {
							if (splittedFilter[i].indexOf(filterName) != -1) {
								var filterValue = splittedFilter[i].split(':')[1];
								WidgetMap.currentFilter[smallLayerId] = [];
								WidgetMap.currentFilter[smallLayerId].push({
									layerName: smallLayerId,
									filter: filterName,
									value: filterValue
								});
								if (filterValue == '' || filterValue == 'VOID') {
									showInfo = true;
								}
								break;
							}
						}
					}
				}

				//2.открываем грид
				var winTemplateId = 'default';
				var task = 'GRID';
				var needTopFilter = false;

				//upd 21.11.19 доавляем параметр, чтобы открывался только грид
				var onlyGrid = false;
				var pArr = [];
				var minimize = false;

				for (var item in vars) {
					switch (item) {
						//общие параметры
						case "gridId":
						case "template": {
							pArr.push({name: "template", value: vars[item]});
							break;
						}
						case "use_exist_list": {
							useExistList = vars[item];
							break;
						}
						case "task": {
							task = vars[item];
							break;
						}
						case "windowTemplateId": {
							winTemplateId = vars[item];
							break;
						}
						case "needTopFilter": {
							needTopFilter = (vars[item] == "true") ? true : false;
							break;
						}
						case "useSynchCommands": {
							useSynchCommands = (vars[item] == "true") ? true : false;
							break;
						}
						case "title": {
							pArr.push({name: item, value: "'" + vars[item] + "'"});
							break;
						}
						case "filter": {
							break;
						}
						case "layerId": {
							//забираем полный идентификатор из уровня дерева
							if (levelParams !== undefined) {
								fullLayerId = fullLayerId.replace("#", "*");
								pArr.push({name: "fullLayerId", value: fullLayerId});
							}
							break;
						}
						case "onlyGrid": {
							onlyGrid = vars[item];
							break;
						}
						case "minimize": {
							minimize = vars[item];
							break;
						}
						default: {/*остальные параметры*/
							pArr.push({name: item, value: vars[item]});
							break;
						}
					}
				}
				if (!onlyGrid)
					WidgetMap.currentRoughFilter = [];
				if (showInfo) {
					var text = gis_treeutils_3;
					var title = gis_treeutils_4;
					var buttons = [
						{text: gis_core_4, click: showGridDialog},
						{text: gis_core_5, click: closeDialog}
					];
					var dlg = App.confirmDialog(text, buttons, {title: title, width: 400});

					function closeDialog() {
						dlg.dialog('destroy');
						dlg.remove();
					}

					function showGridDialog() {
						//временное условие, если типа filteredWkbLayer, у которого есть filter
						var layer = (WidgetMap.layerManager) ? WidgetMap.layerManager.getLayerByName(smallLayerId) : undefined;
						//layer.layer.dataReady_ = false;
						if (goog.isDef(layer) && goog.isDef(layer.filter) && layer.filter != '' && !onlyGrid) {
							mapParams.push({name: 'layerId', value: smallLayerId});
							if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
								if (WidgetMap.isModelsVector == true) {
									//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
									WidgetMap.layerManager.clearLayer(smallLayerId, true);

								}
								if (layer.visible == true)
									WidgetMap.layerManager.enableLayer(smallLayerId);
								else
									WidgetMap.layerManager.updateLayer(smallLayerId);
							}
							if (WidgetMap.isModelsVector == false)
								ExternalInteraction.callFunction('', 'updateCacheLayer', mapParams, true);
						}
						closeDialog();
						if (useExistList) {
							//открываем новое окно
							ExternalInteraction.openGrid({
								pArr: pArr,
								reload: useExistList,
								fullLayerId: fullLayerId,
								forceTopFilter: true,
								minimize: minimize,
								ignoreLabelColumn: true,
							});

						} else {
							//выбираем нулевое окно
							var funcResult = ExternalInteraction.callFunction('', funcName, params);
							//если не предусмотрены сообщения об ошибках на функциях синхронизации
						}
					}
				} else {
					if (useExistList) {
						if (WidgetMap.layerManager != undefined && !onlyGrid) {
							var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
							//if(goog.isDef(layer))
							//  layer.layer.dataReady_ = false;
							if (goog.isDef(layer) && goog.isDef(layer.filter) && layer.filter != '') {
								mapParams.push({name: 'layerId', value: smallLayerId});
								if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
									if (WidgetMap.isModelsVector == true) {
										//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
										WidgetMap.layerManager.clearLayer(smallLayerId, true);
									}
									if (layer.visible == true)
										WidgetMap.layerManager.enableLayer(smallLayerId);
									else
										WidgetMap.layerManager.updateLayer(smallLayerId);
								}
								if (WidgetMap.isModelsVector == false)
									ExternalInteraction.callFunction('', 'updateCacheLayer', mapParams, true);
							}
						}
						ExternalInteraction.openGrid({
							pArr: pArr,
							reload: useExistList,
							fullLayerId: fullLayerId,
							forceTopFilter: true,
							minimize: minimize,
							ignoreLabelColumn: true,
						});
					} else {
						//выбираем нулевое окно
						var funcResult = ExternalInteraction.callFunction('', funcName, params);
						//если не предусмотрены сообщения об ошибках на функциях синхронизации
					}
				}
			}
			//открываем окошко среднего фильтра в попапе
			if (params.event_name === 'FULL_GRID_ROUGH_FILTER_MODULE') {
				WidgetMap.currentRoughFilter = [];
				var levelParams = params.levelParams;
				var fullLayerId = levelParams.split('=')[1].split(';')[0];
				var smallLayerId = fullLayerId.split('#')[1];
				//1. Устанавливаем текущий фильтр
				//получили фильтры
				var treeDiv = $('#treeDiv');
				var filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: params}) : undefined;
				WidgetMap.updateTopFilter(filter.params);
				var mapParams = [];
//                mapParams.push({name:'filter',value: filter.params});
				if (filter && filter.params && filter.params.length > 0)
					mapParams.push(filter.params[0]);
				mapParams.push({name: 'layerId', value: smallLayerId});
				//2.открываем грид
				var winTemplateId = 'default',
					task = 'GRID',
					functionName = 'filterData',
					needTopFilter = false,
					popupTitle = '',
					requestId = '',
					variableName = '',
					addParams = undefined;

				var maxCnt = 1;

				var pArr = [];


				for (var item in vars) {
					switch (item) {
						//общие параметры
						case "gridId":
						case "template": {
							pArr.push({name: "template", value: vars[item]});
							break;
						}
						case "task": {
							task = vars[item];
							break;
						}
						case "windowTemplateId": {
							winTemplateId = vars[item];
							break;
						}
						case "use_exist_list": {
							useExistList = vars[item];
							break;
						}
						case "needTopFilter": {
							needTopFilter = (vars[item] == "true") ? true : false;
							break;
						}
						case "useSynchCommands": {
							useSynchCommands = (vars[item] == "true") ? true : false;
							break;
						}
						case "title": {
							pArr.push({name: item, value: "'" + vars[item] + "'"});
							popupTitle = vars[item];
							break;
						}
						case "winTitle": {
							popupTitle = vars[item];
							break;
						}
						case "maxRecords": {
							maxCnt = vars[item];
							break;
						}
						case "filter": {
							break;
						}
						case "requestId": {
							requestId = vars[item];
							break;
						}
						case "variableName": {
							variableName = vars[item];
							break;
						}
						case "layerId": {
							//забираем полный идентификатор из уровня дерева
							if (levelParams !== undefined) {
								fullLayerId = fullLayerId.replace("#", "*");
								pArr.push({name: "fullLayerId", value: fullLayerId});
							}
							break;
						}
						default: {/*остальные параметры*/
							pArr.push({name: item, value: vars[item]});
							break;
						}
					}
				}

				if (needTopFilter)
					addParams = '<data ' + LayerManager.getTopFiltersString(WidgetMap.currentTopFilter) + ' />';
				$('#roughFilterDialog').remove();

				$('body').append('<div id="roughFilterDialog"></div>');
				var dlg = $('#roughFilterDialog');
				var filterControl = "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'><components:FilterPopUpButton width='100%' isDropDown='false' minPopupWidth='610' height='22' title='" + popupTitle + "' selectAllElements='false' minCnt='0' maxCnt='" + maxCnt + "' id='" + variableName + "' dataProvider='" + requestId + "' /> </mx:VBox>";
				dlg.append('<div id="roughFilterDiv"></div>');
				//upd. 08.08.19 только для ЭХЗ среднего фильтра добавляем курсор ожидания
				var showLoader = false;
				showLoader = variableName == 'PI_CP_EVENT_ID';
				var roughFilterDiv = $('#roughFilterDiv');
				roughFilterDiv.myFilters({
					showLoader: showLoader,
					addParams: addParams,
					dataXML: filterControl, handlers: {
						applyHandler: function (params) {
							var rr = [];
							pArr.push({name: 'roughRequestId', value: requestId});
							var resFilterValues = roughFilterDiv.myFilters('getFilterValuesArray');
							var dotSplitArr = resFilterValues[0].values;
							//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
							var roughArr = [];
							for (var j = 0; j < dotSplitArr.length; j++) {
								roughArr.push(dotSplitArr[j].code);
							}
							//fix для postgres, т.к. пустые кавычки вызывают ошибку синтаксиса
							if (dotSplitArr.length == 0) {
								roughArr.push('NULL');
							}
							$('#roughFilterDialog').remove();
							rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
							pArr.push({
								name: "roughFilter",
								value: variableName + ":" + roughArr.join(","),
								layerName: smallLayerId
							});
							WidgetMap.currentFilter[smallLayerId] = [];
							WidgetMap.currentFilter[smallLayerId].push({
								layerName: smallLayerId,
								filter: variableName,
								value: roughArr.join(",")
							});
							WidgetMap.currentRoughFilter = rr;//{layerId:smallLayerId,roughFilter:rr};
							if (WidgetMap.layerManager != undefined) {
								var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
								if (goog.isDef(layer) && layer.filter != '') {
									pArr.push({name: 'layerId', value: smallLayerId});
									if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
										if (WidgetMap.isModelsVector == true) {
											//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
											WidgetMap.layerManager.clearLayer(smallLayerId, true);

										}
										WidgetMap.layerManager.enableLayer(smallLayerId);
									}
									ExternalInteraction.callFunction('', 'updateCacheLayer', pArr, true);
								}
							}

							ExternalInteraction.openGrid({
								pArr: pArr,
								reload: useExistList,
								fullLayerId: fullLayerId,
								forceTopFilter: true,
							});
						},
						cancelHandler: function (params) {
							$('#roughFilterDialog').remove();
						}
					}
				});
				var closeDiv = '<div id="middleFilterCloseDiv" class="middleFilterCloseDiv"></div>';
				roughFilterDiv.append(closeDiv);
				$('#middleFilterCloseDiv').on('click', function (event) {
					$('#roughFilterDialog').remove();
				});
				dlg.dialog({
					resizable: false,
					modal: true,
					dialogClass: 'noCloseButton noTitleBar gsi-zindex__dialog',
					width: 605,
					height: 440,
					title: ''
				});
			}
			if (params.event_name === 'exportToExcelFromTree') {
				//получили фильтры
				var filter = $('#treeDiv').myCategories('callbackFilter', {params: params});

				var filtersObj = ExternalInteraction.topFilterStrToObject(filter.params);


				ExportUtil.exportToExcel([], 'file', 'server_export', vars['dataRequestId'], filtersObj);
			}

			if (params.event_name === 'importPointGPS') {
				ImportUtil.importPOIPointTrack('point');
			}
			if (params.event_name === 'importTrackGPS') {
				ImportUtil.importPOIPointTrack('track');
			}
			//заглушки для кнопок экспорта
			if (params.event_name === 'exportImgFromTree') {
				App.confirmDialog(gis_treeutils_2, null, {width: 482});
			}
			if (params.event_name === 'exportWrmlFromTree') {
				App.confirmDialog(gis_treeutils_1, null, {width: 467});
			}
			if (params.event_name === 'checkBufferFromTree') {
				if (goog.isDef(vars) && goog.isDef(vars.classId) && vars.classId != '')
					if (goog.isDef(WidgetMap))
						WidgetMap.checkCadastreMDR(vars.classId);
			}
			//заглушка для создания объекта
			if (params.event_name === 'createObjectFromTree') {
				if (goog.isDef(vars) && goog.isDef(vars.classId) && vars.classId != '') {
					if (goog.isDef(WidgetMap) && goog.isDef(WidgetMap.addObjectControl)) {
						widgetMoveWindowToPosition('grid');
						WidgetMap.addObjectControl.handleAddObjectClick_({addFromTree: true, layerName: vars.classId});
					}
				}
			}
		}
		if (funcName === 'enableLayer') {
			var p = vars.layerParams.split('=');
			var obj = [{name: p[0], value: p[1].split(';')[0]}];
			var lName = p[1].split(';')[0];
			var layer = WidgetMap.layerManager.getVectorLayerByName(lName);
			if (goog.isDef(layer)) {
				layer.visible = true;
			} else {
				return;
			}

			if (WidgetMap.isModelsVector == true) {//если слой векторный, то данные подгружаем на карту.
				if (layer.filter === undefined)
					layer.layer.setVisible(layer.visible);
				else {
					layer.layer.setVisible(layer.visible);
					//проверка, есть ли флаг, то эмулируем открытие среднего фильтра
					/*if (goog.isDef(vars.needPreOpenRoughFilter) && vars.needPreOpenRoughFilter == 'true' && layer.layer.needPreOpenRoughFilter == false) {
						layer.layer.needPreOpenRoughFilter = true;
						var p = {};
						if (goog.isDef(params.tree) && goog.isDef(params.tree.invokes) && goog.isDef(vars.invokeName) && vars.invokeName != '') {
							p.event_name = params.tree.invokes[vars.invokeName].event_name;

							var gridVars = params.tree.invokes[vars.invokeName].vars;
							p.vars = gridVars;
							for (var vv in gridVars) {
								if (goog.isDef(vars[vv]))
									p.vars[vv] = vars[vv];
							}
							p.levelParams = vars.levelParams;
							ExternalInteraction.treeCallFunction(p, 'clickButton');
						}
					}*/
				}
			}
		}

		if (funcName === 'disableLayer') {
			var p = vars.layerParams.split('=');
			var obj = [{name: p[0], value: p[1].split(';')[0]}];
			var lName = p[1].split(';')[0];
			var layer = WidgetMap.layerManager.getLayerByName(lName);
			if (goog.isDef(layer)) {
				layer.visible = false;
			} else {
				return;
			}
			if (WidgetMap.isModelsVector == true) {//если слой векторный, то данные подгружаем на карту.
				var params = {windowId: ''};
				/*var filter = $('#treeDiv').myCategories('callbackFilter', {params: params});
				WidgetMap.updateTopFilter(filter.params);*/
				layer.layer.setVisible(layer.visible);
			}
		}

		if (funcName === 'checkHead') {
			//проверка на виджет
			var isWidget = Auth.getParameterByName("w") == '1' && Auth.getParameterByName("task") == 'ILI_WIDGET';
			if (isWidget && ExternalInteraction.firstCheckHead == true) {
				ExternalInteraction.firstCheckHead = false;
				return;
			}
			var maxCnt = vars.maxCnt;
			var popupTitle = vars.title;
			var variableName = vars.variableName;
			var requestId = vars.dataProvider;
			//проверяем , установлено ли что-то в фильтре верхнего уровня. Если да, то добавляем id в фильтра
			var selectedItems = undefined;
			var lastSelected = [];
			if (goog.isDef(variableName) && variableName != '') {
				var filter = $('#treeDiv').myCategories('callbackFilter', {params: params});
				if (filter.params.length > 0) {
					//добавляем проверку на выбранное кол-во записей перед открытием грида
					var filterName = variableName;
					var splittedFilter = filter.params[0].value.split('|');
					for (var ii = 0; ii < splittedFilter.length; ii++) {
						if (splittedFilter[ii].indexOf(filterName) != -1) {
							var filterValue = splittedFilter[ii].split(':')[1];
							var splittedValues = filterValue.split(',');
							for (var sv in splittedValues)
								lastSelected.push({CODE: splittedValues[sv]});
							break;
						}
					}
				}
				if (lastSelected.length > 0) {
					selectedItems = {};
					selectedItems[variableName] = {lastSelected: lastSelected}
				}

			}

			$('#topFilterDialog').remove();
			$('body').append('<div id="topFilterDialog"></div>');
			var dlg = $('#topFilterDialog');
			var filterControl = "<mx:VBox xmlns:mx='http://www.adobe.com/2006/mxml' xmlns:components='ru.corelight.view.components.*'><components:FilterPopUpButton width='100%' isDropDown='false' minPopupWidth='610' height='22' title='" + popupTitle + "' selectAllElements='false' minCnt='0' maxCnt='" + maxCnt + "' id='" + variableName + "' dataProvider='" + requestId + "' /> </mx:VBox>";
			dlg.append('<div id="topFilterDiv"></div>');
			var topFilterDiv = $('#topFilterDiv');
			topFilterDiv.myFilters({
				selectedItems: selectedItems,
				dataXML: filterControl, handlers: {
					applyHandler: function (params) {
						//устанавливаем верхний фильтр
						var resFilterValues = topFilterDiv.myFilters('getFilterValuesArray');
						var dotSplitArr = resFilterValues[0].values;
						//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
						var roughArr = [];
						for (var j = 0; j < dotSplitArr.length; j++) {
							roughArr.push(dotSplitArr[j].code);
						}
						if (dotSplitArr.length == 0) {
							roughArr.push('NULL');
						}
						$('#topFilterDialog').remove();
						var newData = '<data OBJ_IDS="' + roughArr.join(',') + '" TOP_FILTER="' + resFilterValues[0].idFilter + '" ></data>';
						$('#treeDiv').myCategories('updateTopFilter', {params: newData});
						//эмуляция клика по кнопке "показать список" слоя PODS_ILI_DATA "Данные ВТД. Дефекты"

						var prms = {
							event_name: 'FULL_GRID_EVENT_ID_MODULE',
							levelParams: "layerId=PODS_INSP_Layers.xml#PODS_ILI_DATA;",
							vars: {
								filter: 'ILI_INSP_FILTER',
								functionName: '',
								gridId: 'PODS_ILI_DATA_LIST',
								layerId: '',
								mdl: 'Public/SWF/Grid_55.swf',
								needTopFilter: 'true',
								task: 'GRID',
								title: gis_treeutils_7,
								useSynchCommands: 'false',
								useExistList: 'true',
								windowTemplateId: 'gridWindow'
							}
						};

						var smallLayerId = "PODS_ILI_DATA";
						var filter = $('#treeDiv').myCategories('callbackFilter', {params: {}});

						function checkFilter(filter) {
							WidgetMap.updateTopFilter(filter.params);
							var splittedFilter = filter.params[0].value.split('|');
							for (var i = 0; i < splittedFilter.length; i++) {
								if (splittedFilter[i].indexOf(filterName) != -1) {
									var filterValue = splittedFilter[i].split(':')[1];
									WidgetMap.currentFilter[smallLayerId] = [];
									WidgetMap.currentFilter[smallLayerId].push({
										layerName: smallLayerId,
										filter: filterName,
										value: filterValue
									});
									if (filterValue == '' || filterValue == 'VOID') {
										showInfo = true;
									}
									if (filterValue !== roughArr.join(',')) {
										return false;
									}
									break;
								}
							}
							return true;
						}

						if (filter.params.length > 0) {
							//добавляем проверку на выбранное кол-во записей перед открытием грида
							if (goog.isDef(prms.vars.filter)) {
								var filterName = prms.vars.filter;
								var start = Date.now();
								var timeout = 0;
								while (!checkFilter(filter) && timeout < 1000) {
									filter = $('#treeDiv').myCategories('callbackFilter', {params: {}});
									timeout = Date.now() - start;
								}
							}
						}

						if (WidgetMap.layerManager != undefined) {
							var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
							if (goog.isDef(layer) && goog.isDef(layer.filter) && layer.filter != '') {
								if (WidgetMap.isModelsVector == true) {
									//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
									WidgetMap.layerManager.clearLayer(smallLayerId, true);
								}
								if (layer.visible == true)
									WidgetMap.layerManager.enableLayer(smallLayerId);
								else
									WidgetMap.layerManager.updateLayer(smallLayerId);
							}
						}

					},
					cancelHandler: function (params) {
						$('#topFilterDialog').remove();
					}
				}
			});

			var closeDiv = '<div id="middleFilterCloseDiv" class="middleFilterCloseDiv"></div>';
			topFilterDiv.append(closeDiv);
			$('#middleFilterCloseDiv').on('click', function (event) {
				$('#topFilterDialog').remove();
			});
			dlg.dialog({
				resizable: false,
				modal: true,
				dialogClass: 'noCloseButton noTitleBar gsi-zindex__dialog',
				width: 605,
				height: 440,
				title: ''
			});
		}
	}
};

ExternalInteraction.topFilterStrToObject = function (params) {
	for (var j = 0; j < params.length; j++) {
		var curParam = params[j];
		if (!curParam.hasOwnProperty('name')) continue;

		var newFilters = [];
		var curFilters;
		var newFilterObj = {};
		switch (curParam['name']) {
			case 'filter':
			case 'roughFilter':
				curFilters = curParam['value'].split('|');
				for (var i = 0; i < curFilters.length; i++) {
					var nameValArr = curFilters[i].split(':');
					if (nameValArr && nameValArr.length == 2) {
						//var newFilterObj = { name: nameValArr[0], value: nameValArr[1] };

						var splittedIds = nameValArr[1].split(',');

						for (var t = 0; t < splittedIds.length; t++) {
							var pp = parseInt(splittedIds[t]);
							if (isNaN(pp))
								splittedIds[t] = "'" + splittedIds[t] + "'";
						}
						newFilterObj[nameValArr[0]] = splittedIds.toString();//nameValArr[1] ;
//                        newFilters.push(newFilterObj);
					}
				}

				break;
			case 'layerId':
				break;
		}
		return newFilterObj;
	}
	return null;
};

ExternalInteraction.getLayersVisibility = function (params) {
	if (!goog.isDef(WidgetMap.layerManager)) {
		var res = [];
		for (var i in params) res.push({layerName: params[i].layer, visible: false});
		return res;
	}
	for (var i in params) {
		var isVisible = WidgetMap.layerManager.getLayerVisibility(params[i].layer);
		params[i].visible = isVisible;
		params[i].layerName = params[i].layer;
	}
	return params;
};

//открытие грида
ExternalInteraction.openGrid = function (opt_options, callback) {
	var options = opt_options !== undefined ? opt_options : {};
	var pArr = [];
	var url = options.url || location.href;
	var reload = options.reload !== undefined && options.reload === true;
	//использовать ли в Tab только один грид
	var singleTab = options.singleTab !== undefined && options.singleTab === true;
	var fullLayerId = options.fullLayerId;
	var parentRoughFilter = options.parentRoughFilter;
	var staticParentRoughFilter = options.staticParentRoughFilter;
	var parentRoughParams = options.parentRoughParams;
	var parentGridFilter = options.parentGridFilter;
	var	parentGridRowId = options.parentGridRowId;
	var minimize = options.minimize;
	var ignoreLabelColumn = options.ignoreLabelColumn || false;

	var filterMap = options.filterMap;
	var ignoreLabelColumn = options.ignoreLabelColumn === true;
	try {
		if (options.pArr) {
			pArr = options.pArr;
		} else {
			if (!options.gridId)
				return;
			var gridId = options.gridId;
			var parentGrid = options.parentGrid;
			var childGrid = options.childGrid;
			var position = (options.position !== undefined) ? options.position : -1;
			var showDashboard = options.showDashboard || false;
			if (options.pArr === undefined) {
				pArr.push({name: "fullLayerId", value: fullLayerId.replace("#", "*")});
				pArr.push({name: "template", value: gridId});
				pArr.push({name: "title", value: "'" + options.label + "'"});
				pArr.push({name: "filter", value: options.data});
				pArr.push({name: "parentRoughFilter", value: options.parentRoughFilter});
				pArr.push({name: "parentRoughParams", value: options.parentRoughParams});
				pArr.push({name: "staticParentRoughFilter", value: options.staticParentRoughFilter});
				pArr.push({name: "filterMap", value: options.filterMap});
				pArr.push({name: "parentGrid", value: parentGrid});
				pArr.push({name: "childGrid", value: childGrid});
				pArr.push({name: "position", value: position});
				pArr.push({name: "showDashboard", value: '' + showDashboard});// из-за того, что далее сравнение строковое
				pArr.push({name: "ignoreLabelColumn", value: '' + ignoreLabelColumn});// из-за того, что далее сравнение строковое
				pArr.push({name: "parentGridFilter", value: options.parentGridFilter});
				pArr.push({name: "parentGridRowId", value: options.parentGridRowId});
			}
		}
		if (reload && !singleTab) {
			var gridWidget = GridUtil.findTabByLayerName(fullLayerId.replace("#", "*"));
			if (gridWidget) {
				gridWidget.ignoreLabelColumn = ignoreLabelColumn;
				if(ignoreLabelColumn){
					GridUtil.emulateShowAllClick(gridWidget.id, true, true);
				}
				gridWidget.updateGridContent(options.data, options.forceTopFilter, reload, parentRoughFilter, filterMap, parentRoughParams, staticParentRoughFilter);
				return;
			}
		}
		if(singleTab){
			var tabNav = $('#gridTabNavigator');
			if(tabNav.length){
				var tabCount =  tabNav.jqxTabs('length');
				for(var t = 0; t < tabCount; t++){
					tabNav.jqxTabs('removeAt', t);
				}
			}
		}
		//открываем новое окно
		openNewWindow(url, "gridWindow", "GRID", pArr, callback, minimize);
	} catch (ex) {

	}
};




/**
 * Выполнение сценария для поискового движка
 * @param currentObject  "PODS_ILI_INSPECTION:1302016"
 * @param categoryId "ILI_INSP"
 */
ExternalInteraction.processScenario = function (currentObject, categoryId) {
	if (WidgetMap.config.search_engine && WidgetMap.config.search_engine.templates && WidgetMap.config.search_engine.templates[categoryId]) {
		var scenario = WidgetMap.config.search_engine.templates[categoryId].scenario;
		if (scenario) {
			var showLayers = (scenario.openLayers) ? scenario.openLayers : [];//['PODS_ILI_DATA','PODS_ILI_DATA_FEATURE'];
			//забираем флаг открытия среднегно фильтрна, список на открытие гридов и список на включение слоёв
			var middleFilterSource = '';//'MIDDLE_ILI_FILTER';
			var topFilterSource = '';//'ILI_INSP_FILTER;
			var filterType = '';
			var openTableInterval = (scenario.openTableInterval) ? scenario.openTableInterval : 3000;
			//установить верхний фильтр
			var filterParams = [{name: 'filter', value: 'ILI_INSP_FILTER:' + currentObject.split(':')[1]}]
			WidgetMap.updateTopFilter(filterParams);
			var filterName = 'ILI_INSP_FILTER';
			var splittedFilter = filterParams[0].value.split('|');
			for (var i = 0; i < splittedFilter.length; i++) {
				if (splittedFilter[i].indexOf(filterName) !== -1) {
					var filterValue = splittedFilter[i].split(':')[1];
					for (var k = 0; k < showLayers.length; k++) {
						//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
						var smallLayerId = showLayers[k];
						WidgetMap.currentFilter[smallLayerId] = [];
						WidgetMap.currentFilter[smallLayerId].push({
							layerName: smallLayerId,
							filter: filterName,
							value: filterValue
						});
					}
					break;
				}
			}
			var filter = scenario.filter;
			if (filter) {
				if (filter.type)
					filterType = filter.type;
				if (filter.middleFilterSource)
					middleFilterSource = filter.middleFilterSource;
				if (filter.topFilterSource)
					topFilterSource = filter.topFilterSource;
			}

			if (middleFilterSource !== '') {
				ExternalInteraction.showFilter(filterType, topFilterSource, middleFilterSource, showLayers, function () {
					ExternalInteraction.showLayers(showLayers);
					ExternalInteraction.showTables(scenario.openTables);
				})
			} else {
				ExternalInteraction.showLayers(showLayers);
				ExternalInteraction.showTables(scenario.openTables);
			}
		}
	}
}

ExternalInteraction.showTables = function (tables) {
	if (tables && tables.length === 0)
		return;
	var table = tables.pop();
	ExternalInteraction.openTable(table.gridId, table.title, table.levelParams);
	setTimeout(function () {
		ExternalInteraction.showTables(tables);
	}, 3000);
};

/**
 * Возвращает распарсенные параметры задачи
 * @param {*} taskName
 */
ExternalInteraction.parseTask = function (taskName){
	App.serverQueryJSON('./Core/UITasks/'+taskName.toLowerCase()+'.json', result, fault);
	function fault(res) {
		App.errorReport(gis_main55_2, res, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_12'});
	}
	function result(res) {
		try {
			if (res !== undefined && res.code === 200) {
				var scenario;
				if (res.tree && res.tree.trees && res.tree.trees.length > 0)
					scenario = res.tree.trees[0].startupScenario;
				if (WidgetMap) WidgetMap.config = res;
				if (scenario) {
					//забираем флаг открытия среднегно фильтрна, список на открытие гридов и список на включение слоёв
					var filter = scenario.filter;
					var middleFilterSource = '';//'MIDDLE_ILI_FILTER';
					var topFilterSource = '';//'ILI_INSP_FILTER;
					var filterType = '';
					if (filter.type !== undefined && filter.type !== '')
						filterType = filter.type;
					if (filter.middleDataSource !== undefined && filter.middleDataSource !== '')
						middleFilterSource = filter.middleDataSource;
					if (filter.topDataSource !== undefined && filter.topDataSource !== '')
						topFilterSource = filter.topDataSource;
					var showLayers = [];
					if (middleFilterSource !== '') {
						ExternalInteraction.showFilter(filterType, topFilterSource, middleFilterSource, showLayers, function (ids) {
							var objectFullId = 'PODS_ROUTE:' + ids.join(':');
							App.loadDocuments('#postswrapper', objectFullId, 'objId', true);
						});
					}
				}
			}
		}
		catch(ex) {
			App.errorReport(gis_main55_2, ex, undefined, {filename:gis_filename_110, functionname:'gis_filename_483_6'});
		}
	}
}
/*
 * Date Format 1.2.3
 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
 * MIT license
 *
 * Includes enhancements by Scott Trenda <scott.trenda.net>
 * and Kris Kowal <cixar.com/~kris.kowal/>
 *
 * Accepts a date, a mask, or a date and a mask.
 * Returns a formatted version of the given date.
 * The date defaults to the current date/time.
 * The mask defaults to dateFormat.masks.default.
 */

var dateFormat = function () {
    var	token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function (val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) val = "0" + val;
            return val;
        };

    // Regexes and supporting functions are cached through closure
    return function (date, mask, utc) {
        var dF = dateFormat;

        // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
        if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
            mask = date;
            date = undefined;
        }

        // Passing date through Date applies Date.parse, if necessary
        date = date ? new Date(date) : new Date;
        if (isNaN(date)) throw SyntaxError("invalid date");

        mask = String(dF.masks[mask] || mask || dF.masks["default"]);

        // Allow setting the utc argument via the mask
        if (mask.slice(0, 4) == "UTC:") {
            mask = mask.slice(4);
            utc = true;
        }

        var	_ = utc ? "getUTC" : "get",
            d = date[_ + "Date"](),
            D = date[_ + "Day"](),
            m = date[_ + "Month"](),
            y = date[_ + "FullYear"](),
            H = date[_ + "Hours"](),
            M = date[_ + "Minutes"](),
            s = date[_ + "Seconds"](),
            L = date[_ + "Milliseconds"](),
            o = utc ? 0 : date.getTimezoneOffset(),
            flags = {
                d:    d,
                dd:   pad(d),
                ddd:  dF.i18n.dayNames[D],
                dddd: dF.i18n.dayNames[D + 7],
                m:    m + 1,
                mm:   pad(m + 1),
                mmm:  dF.i18n.monthNames[m],
                mmmm: dF.i18n.monthNames[m + 12],
                yy:   String(y).slice(2),
                yyyy: y,
                h:    H % 12 || 12,
                hh:   pad(H % 12 || 12),
                H:    H,
                HH:   pad(H),
                M:    M,
                MM:   pad(M),
                s:    s,
                ss:   pad(s),
                l:    pad(L, 3),
                L:    pad(L > 99 ? Math.round(L / 10) : L),
                t:    H < 12 ? "a"  : "p",
                tt:   H < 12 ? "am" : "pm",
                T:    H < 12 ? "A"  : "P",
                TT:   H < 12 ? "AM" : "PM",
                Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
            };

        return mask.replace(token, function ($0) {
            return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
        });
    };
}();

// Some common format strings
dateFormat.masks = {
    "default":      "ddd mmm dd yyyy HH:MM:ss",
    shortDate:      "m/d/yy",
    mediumDate:     "mmm d, yyyy",
    longDate:       "mmmm d, yyyy",
    fullDate:       "dddd, mmmm d, yyyy",
    shortTime:      "h:MM TT",
    mediumTime:     "h:MM:ss TT",
    longTime:       "h:MM:ss TT Z",
    isoDate:        "yyyy-mm-dd",
    isoTime:        "HH:MM:ss",
    isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};

// Internationalization strings
dateFormat.i18n = {
    dayNames: [
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
    ],
    monthNames: [
        "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
        "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
    ]
};

// For convenience...
Date.prototype.format = function (mask, utc) {
    return dateFormat(this, mask, utc);
};
//Глобальный объект
MapUtil = {};

/**
 * Установка дефолных разрешений карты
 * @returns {number}
 * @constructor
 */
MapUtil.setDefaultResolutions = function() {
	var resolutions=[];
	var DEFAULT_MAX_RESOLUTION = 156543.0339;
	var minZoom = 4;
	var maxZoom = 22;
	var zoom = maxZoom + 1;
	resolutions.push(DEFAULT_MAX_RESOLUTION);
	var i = 1;
	for (; i < zoom; i++) {
		resolutions.push(resolutions[i - 1] / 2);
	}
	resolutions = resolutions.slice(minZoom);
	return resolutions;
};

/**
 * Установка дефолных разрешений карты тех. схемы
 * @returns {number}
 * @constructor
 */
MapUtil.setDefaultTechSchemaResolutions = function(maxZoom) {
	var nominalResolution = 1.40625;
	var resolutions = [];
	var minZoom = 3;
	var maxZoom = (maxZoom) ? maxZoom  : 20;
	resolutions.push(nominalResolution * 20);
	var i = 1;
	for(i; i < maxZoom; i++){
		resolutions.push(resolutions[i - 1] / 2);
	}
	resolutions = resolutions.slice(minZoom);
	return resolutions;
};

/**
 * После открытия формы настроек пользователя устанавливаем параметры
 * @param params
 * @param force - форсирование переустановки в системе
 */
MapUtil.applyThemeParams = function(params, force) {
	//TODO upd. 21.01.20 хардкод. Если виджеты, то всё сворачиваем и растровый режим
	if(getParameterByName('w') === '1'){
		WidgetMap.sendCadastreEmail = false;
		WidgetMap.CURRENT_MODE = WidgetMap.MODES.RASTER;
		WidgetMap.showCenterMap = false;
		WidgetMap.showOverviewMap = false;
		WidgetMap.coordMode = WidgetMap.COORD_MODES.DECIMAL;
		return;
	}
	if(WidgetMap !== undefined){
		if (params.showOverviewMap !== undefined) WidgetMap.showOverviewMap = params.showOverviewMap;
		if (params.showTree !== undefined) WidgetMap.showTree = params.showTree;
		if (params.sendCadastreEmail !== undefined) WidgetMap.sendCadastreEmail = params.sendCadastreEmail;
		if (params.showCenterMap !== undefined) WidgetMap.showCenterMap = params.showCenterMap;
		var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
		if (WidgetMap.MODES !== undefined) {
			if (params.mapMode === WidgetMap.MODES.RASTER)
				WidgetMap.CURRENT_MODE = (mapConfig.block_raster_pipe_mode !== true)?params.mapMode:WidgetMap.MODES.VECTOR;
			else
				WidgetMap.CURRENT_MODE = WidgetMap.MODES.VECTOR;
		}
		if (WidgetMap.COORD_MODES !== undefined) {
			if (params.coordMode === 'decimal')
				WidgetMap.coordMode = WidgetMap.COORD_MODES.DECIMAL;
			else
				WidgetMap.coordMode = WidgetMap.COORD_MODES.GRAD;
		}
		if (params.useSynchronization !== undefined) App.syncEnabled = params.useSynchronization;

		//если сохраняем форму личных настроек, то применяем только нужные,например, режим карты
		if(force === true){
			//changeMode(WidgetMap.CURRENT_MODE)
			//sendCadastreEmail(WidgetMap.sendCadastreEmail)
			//hideTree(WidgetMap.showTree)
		}
		else{
			//changeMode(WidgetMap.CURRENT_MODE)
			//sendCadastreEmail(WidgetMap.sendCadastreEmail)
		}
	}
};

MapUtil.calculateObjectSize = function(object){
	//пробуем забрать текущий выделенный объект и посчитать его длину или площадь
	if(WidgetMap.mapSelectionLayer){
		var features = WidgetMap.mapSelectionLayer.getSource().getFeatures();
		if(features.length > 0 ){
			var feature = features[0];
			var geometry = feature.getGeometry();
			if(geometry){
				switch(geometry.getType()){
					case 'LineString':
						return '(' + map.controls.MeasureControl.prototype.calculateDistance_(feature) + ')';
					case 'Polygon':
						return '(' + map.controls.MeasureControl.prototype.calculateArea_(feature).replace('<br/>',';') + ')';
				}
			}
		}
	}
	return '';
};


/**
 *
 * @param that - локальная переменная that извне
 * @param layerObj
 * @param thatt контекст this извне
 */
MapUtil.showObjectError = function(that, layerObj, thatt){
	if(!layerObj || !that)
		return;
	if(that.ignoreErrors)
		return;
	if (goog.isDef(that.showObjectsErrorHandler)) {
		that.showObjectsErrorHandler.apply(thatt, [layerObj.layer.useServerCache ? gis_bindtolineform_4 : gis_widgetmap_3, that.showObjectError]);
	} else {
		App.confirmDialog(layerObj.layer.useServerCache ? gis_bindtolineform_4 : gis_widgetmap_3, null, {title: gis_core_1});
	}
}

MapUtil.getTopFilterByName = function(name){
	var filter = undefined;
	if(WidgetMap && WidgetMap.currentTopFilter){
		WidgetMap.currentTopFilter.forEach(function(item){
			if(item.name === name)
				filter = item;
		});
	}
	return filter;
}


MapUtil.updateLayerData = function(layerName, ids, needLoadData){
	if(checkMapExisting()){
		var layer = WidgetMap.layerManager.getLayerByName(layerName);
		if(layer && layer.layer){
			if(ids && ids.length === 0){
				layer.layer.refreshLayerData();
				return;
			}
			//сначала удаляем с карты объекты
			layer.layer.deleteObjectsByIds(ids);
			//перезапрашиваем из базы геометрии
			if(needLoadData){
				layer.layer.refreshData(ids);
				//layer.layer.refreshObjectGeometryByIds(ids);
			}

		}
	}
}


/**  Вынесено из WidgetMap */

/**
 * Чистка слоя с выделенными объектами
 */
MapUtil.clearSelectionLayer = function(){
	if(WidgetMap && WidgetMap.mapSelectionLayer)
		WidgetMap.mapSelectionLayer.getSource().clear();
	WidgetMap.mapSelectedObject = undefined;
};

/**
 * Смена сортировки векторных слоёв на основе order и mapOrder
 */
MapUtil.reorderVectorLayers = function(){
	if(WidgetMap && WidgetMap.currentVectorGroupLayer){
		var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
		var layers = tLayers.getArray();
		// generic comparison function
		var cmp = function(x, y){
			return x > y ? 1 : x < y ? -1 : 0;
		};

		//sort name ascending then id descending
		layers.sort(function(a, b){
			//note the minus before -cmp, for descending order
			return cmp(
				[cmp(a.values_.mapOrder, b.values_.mapOrder), -cmp(a.values_.order, b.values_.order)],
				[cmp(b.values_.mapOrder, a.values_.mapOrder), -cmp(b.values_.order, a.values_.order)]
			);
		});

		WidgetMap.currentVectorGroupLayer.setLayers(new ol.Collection(layers));
	}
};

/**
 * Закрыть выпадающий список кнопок на карте
 */
MapUtil.closeButtons = function (sender) {
	if(!WidgetMap) return;
	switch(sender){
		case 'mapView':
			if(WidgetMap.share)WidgetMap.share.setVisible_(false);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(!WidgetMap.viewMap.isVisible);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(false);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(false);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(false);
			break;
		case 'share':
			if(WidgetMap.share)WidgetMap.share.setVisible_(!WidgetMap.share.isVisible);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(false);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(false);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(false);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(false);
			break;
		case 'searchOnMap':
			if(WidgetMap.share)WidgetMap.share.setVisible_(false);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(false);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(false);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(false);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(!WidgetMap.searchOnMap.isVisible);
			break;
		case 'export':
			if(WidgetMap.share)WidgetMap.share.setVisible_(false);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(false);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(false);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(!WidgetMap.exportImageControl.isVisible);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(false);
			break;
		case 'measure':
			if(WidgetMap.share)WidgetMap.share.setVisible_(false);
			if(WidgetMap.viewMap)WidgetMap.viewMap.setVisible_(false);
			if(WidgetMap.measureControl)WidgetMap.measureControl.setVisible_(!WidgetMap.measureControl.isVisible);
			if(WidgetMap.exportImageControl)WidgetMap.exportImageControl.setVisible_(false);
			if(WidgetMap.searchOnMap)WidgetMap.searchOnMap.setVisible_(false);
			break;
		default:
			if(WidgetMap.share !== undefined){
				WidgetMap.share.setVisible_(false);
				WidgetMap.share.isVisible = false;
			}
			if(WidgetMap.searchOnMap !== undefined){
				WidgetMap.searchOnMap.setVisible_(false);
				WidgetMap.searchOnMap.isVisible = false;
			}
			if(WidgetMap.viewMap !== undefined){
				WidgetMap.viewMap.setVisible_(false);
				WidgetMap.viewMap.isVisible = false;
			}

			if(WidgetMap.measureControl !== undefined){
				WidgetMap.measureControl.setVisible_(false);
				WidgetMap.measureControl.isVisible = false;
			}

			if(WidgetMap.exportImageControl !== undefined){
				WidgetMap.exportImageControl.setVisible_(false);
				WidgetMap.exportImageControl.isVisible = false;
			}
			break;
	}
	if(WidgetMap.baseLayersControl !== undefined && sender !== undefined && sender !== '')
		WidgetMap.baseLayersControl.close();

};

MapUtil.getAvailableMapMode = function(mode){
	var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
	if (mapConfig.block_raster_pipe_mode === true)
		return WidgetMap.MODES.VECTOR;
	return mode;
}

/**
 * Получение координат и масштаба для объекта
 * @param layerName
 * @param id
 */
MapUtil.getWaterwayGeoById = function(layerName, id, callback){
	function reqParams() {
		var layer = WidgetMap.layerManager.getLayerByName(layerName);
		var request = (layer && layer.dataProvider && layer.dataProvider.spatial) ? layer.dataProvider.spatial: 'WATERWAY_GEO.xml#WATERWAY_CROSS';
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var filterStr = 'ID=' + id;
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" ' + topFiltersStr + '>' +
				'<data FILTER="' + filterStr + '" />' +
				'</root>'
		};
	}
	function result(resultXml) {
		try {
			var coords = null;
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') {
				App.errorReport(gis_core_error_2, er, undefined, {
					filename: gis_filename_626,
					functionname: 'gis_filename_626_68'
				});
				return;
			}
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			var stride = 2;
			if (datas.length > 0) {
				//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
				var format = new ol.format.WKT({dimension: stride});
				var wktStr = datas[0].getAttribute("WKT");//;"POINT(-1 -1)";
				var fGeometry = undefined;
				try {
					fGeometry = format.readGeometry(wktStr);
				} catch (ex) {
					//для случая с видеозаписями, приходит 3 координаты
					stride = 3;
					format = new map.format.WKT({dimension: stride});
					fGeometry = format.readGeometry(wktStr);
				}
				if (fGeometry) {
					var coords = fGeometry.flatCoordinates;
					coords.length = 2;
				}
			}
			if (callback) callback(coords);
		}
		catch(ex){
			App.errorReport(gis_core_error_2, ex.message, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_69'});
		}
	}

	function fault(resultXml) {
		BlockingUtil.ready();
		var dataString = $(resultXml).children('string').text();
		var er = HTTPServiceUtil.getError(dataString);
		if (er === '')
			er = dataString;
		App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_626, functionname:'gis_filename_626_70'});
	}
	BlockingUtil.wait();
	App.serverQueryXML2Node(Services.processQueryNodeGeo, reqParams(), result, fault);
}

goog.require('ol');
goog.require('ol.Map');
goog.require('ol.View');


goog.require('ol.interaction');
goog.require('ol.interaction.Interaction');
goog.require('ol.interaction.Draw');
goog.require('ol.interaction.DragPan');
goog.require('ol.interaction.MouseWheelZoom');
goog.require('ol.interaction.DragZoom');
goog.require('ol.interaction.Modify');
goog.require('ol.interaction.Translate');

goog.require('ol.control');
goog.require('ol.control.Control');
goog.require('ol.control.ZoomSlider');
goog.require('ol.control.MousePosition');
goog.require('ol.control.ScaleLine');

goog.require('ol.layer.Tile');
goog.require('ol.layer.Vector');
goog.require('ol.source.OSM');
goog.require('ol.source.TileWMS');
goog.require('ol.source.ImageWMS');
goog.require('ol.source.Vector');
goog.require('ol.source.Cluster');
//goog.require('ol.source.GPX');
goog.require('ol.style.Circle');
goog.require('ol.style.RegularShape');
goog.require('ol.style.Fill');
goog.require('ol.style.Stroke');
goog.require('ol.style.Style');

goog.require('ol.layer.Group');
goog.require('ol.Collection');

goog.require('ol.Kinetic');
goog.require('ol.Overlay');

goog.require('ol.Feature');
goog.require('ol.format.WKT');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('ol.css');
goog.provide('map.style.Rectangle');

goog.require('goog.dom');
goog.require('ol.color');
goog.require('ol.render.canvas');
goog.require('ol.style.Fill');
goog.require('ol.style.Image');
goog.require('ol.style.ImageState');
goog.require('ol.style.Stroke');



/**
 * @classdesc
 * Set circle style for vector features.
 *
 * @constructor
 * @extends {ol.style.Image}
 * @api
 */
map.style.Rectangle = function(opt_options) {

    var options = goog.isDef(opt_options) ? opt_options : {};

    /**
    * @private
    * @type {HTMLCanvasElement}
    */
    this.canvas_ = /** @type {HTMLCanvasElement} */
     (goog.dom.createElement('CANVAS'));

     /**
      * @private
      * @type {HTMLCanvasElement}
      */
     this.hitDetectionCanvas_ = null;

     /**
      * @private
      * @type {ol.style.Fill}
      */
     this.fill_ = goog.isDef(options.fill) ? options.fill : null;

     /**
      * @private
      * @type {Array.<number>}
      */
     this.origin_ = [0, 0];

     /**
      * @private
      * @type {number}
      */
     this.radius_ = options.radius;

     /**
      * @private
      * @type {ol.style.Stroke}
      */
     this.stroke_ = goog.isDef(options.stroke) ? options.stroke : null;

     var size = this.render_();

     /**
      * @private
      * @type {Array.<number>}
      */
     this.anchor_ = [size / 2, size / 2];

     /**
      * @private
      * @type {ol.Size}
      */
     this.size_ = [size, size];

     /**
      * @type {boolean}
      */
     var snapToPixel = goog.isDef(options.snapToPixel) ?
         options.snapToPixel : true;

     goog.base(this, {
          opacity: 1,
          rotateWithView: false,
          rotation: 0,
          scale: 1,
          snapToPixel: snapToPixel
     });

};
goog.inherits(map.style.Rectangle, ol.style.Image);


/**
 * @inheritDoc
 * @api
 */
map.style.Rectangle.prototype.getAnchor = function() {
    return this.anchor_;
};


/**
 * @return {ol.style.Fill} Fill style.
 * @api
 */
map.style.Rectangle.prototype.getFill = function() {
    return this.fill_;
};


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.getHitDetectionImage = function(pixelRatio) {
    return this.hitDetectionCanvas_;
};


/**
 * @inheritDoc
 * @api
 */
map.style.Rectangle.prototype.getImage = function(pixelRatio) {
    return this.canvas_;
};


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.getImageState = function() {
    return ol.style.ImageState.LOADED;
};


/**
 * @inheritDoc
 * @api
 */
map.style.Rectangle.prototype.getOrigin = function() {
    return this.origin_;
};


/**
 * @return {number} Radius.
 * @api
 */
map.style.Rectangle.prototype.getRadius = function() {
    return this.radius_;
};


/**
 * @inheritDoc
 * @api
 */
map.style.Rectangle.prototype.getSize = function() {
    return this.size_;
};


/**
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
map.style.Rectangle.prototype.getStroke = function() {
    return this.stroke_;
};


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.listenImageChange = goog.nullFunction;


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.load = goog.nullFunction;


/**
 * @inheritDoc
 */
map.style.Rectangle.prototype.unlistenImageChange = goog.nullFunction;


/**
 * @private
 * @return {number} Size.
 */
map.style.Rectangle.prototype.render_ = function() {
    var canvas = this.canvas_;
    var strokeStyle, strokeWidth;

    if (goog.isNull(this.stroke_)) {
        strokeWidth = 0;
    } else {
        strokeStyle = ol.color.asString(this.stroke_.getColor());
        strokeWidth = this.stroke_.getWidth();
        if (!goog.isDef(strokeWidth)) {
            strokeWidth = ol.render.canvas.defaultLineWidth;
        }
    }

    var size = 2 * (this.radius_ + strokeWidth) + 1;
    // draw the circle on the canvas

    canvas.height = size;
    canvas.width = size;

    // canvas.width and height are rounded to the closest integer
    size = canvas.width;

    var context = /** @type {CanvasRenderingContext2D} */
        (canvas.getContext('2d'));
    //context.rect(size / 2 - strokeWidth -1, size / 2 - strokeWidth-2, this.radius_, this.radius_);
    context.rect(this.radius_ / 2, this.radius_ / 2, this.radius_, this.radius_);

    if (!goog.isNull(this.fill_)) {
        context.fillStyle = ol.color.asString(this.fill_.getColor());
        context.fill();
    }
    if (!goog.isNull(this.stroke_)) {
        context.strokeStyle = strokeStyle;
        context.lineWidth = strokeWidth;
        context.stroke();
    }

    // deal with the hit detection canvas

    if (!goog.isNull(this.fill_)) {
        this.hitDetectionCanvas_ = canvas;
    } else {
        this.hitDetectionCanvas_ = /** @type {HTMLCanvasElement} */
            (goog.dom.createElement('CANVAS'));
        canvas = this.hitDetectionCanvas_;

        canvas.height = size;
        canvas.width = size;

        context = /** @type {CanvasRenderingContext2D} */
            (canvas.getContext('2d'));
        context.arc(size / 2, size / 2, this.radius_, 0, 2 * Math.PI, true);

        context.fillStyle = ol.render.canvas.defaultFillStyle;
        context.fill();
        if (!goog.isNull(this.stroke_)) {
            context.strokeStyle = strokeStyle;
            context.lineWidth = strokeWidth;
            context.stroke();
        }
    }

    return size;
};

goog.provide('map.layer.ExtImageVector');

goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('goog.vec.Mat4');
goog.require('ol.dom');
goog.require('ol.extent');
goog.require('ol.render.canvas.ReplayGroup');
goog.require('ol.renderer.vector');
goog.require('ol.source.ImageCanvas');
goog.require('ol.source.Vector');
goog.require('ol.style.Style');
goog.require('ol.vec.Mat4');



/**
 * @classdesc
 * An image source whose images are canvas elements into which vector features
 * read from a vector source (`ol.source.Vector`) are drawn. An
 * `ol.source.ImageVector` object is to be used as the `source` of an image
 * layer (`ol.layer.Image`). Image layers are rotated, scaled, and translated,
 * as opposed to being re-rendered, during animations and interactions. So, like
 * any other image layer, an image layer configured with an
 * `ol.source.ImageVector` will exhibit this behaviour. This is in contrast to a
 * vector layer, where vector features are re-drawn during animations and
 * interactions.
 *
 * @constructor
 * @extends {ol.source.ImageCanvas}
 * @param {olx.source.ImageVectorOptions} options Options.
 * @api
 */
map.layer.ExtImageVector = function(options) {
  this.id_ = options.id;
  this.hasGeometryInExtent = false;
  goog.base(this, options);

};
goog.inherits(map.layer.ExtImageVector, ol.source.ImageVector);


/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Size} size Size.
 * @param {ol.proj.Projection} projection Projection;
 * @return {HTMLCanvasElement} Canvas element.
 * @private
 */
map.layer.ExtImageVector.prototype.canvasFunctionInternal_ =
    function(extent, resolution, pixelRatio, size, projection) {


  var replayGroup = new ol.render.canvas.ReplayGroup(
      ol.renderer.vector.getTolerance(resolution, pixelRatio), extent,
      resolution);

  //this.source_.loadFeatures(extent, resolution, projection);
  var loading = false;
  if(this.id_!==undefined){
      WidgetMap.regenerateMatrix(this.id_);
      this.hasGeometryInExtent = false;
  }
  _GEO_EXTENTS = {};
  _TEXT_EXTENTS = {};
  this.source_.forEachFeatureInExtent(extent,
      /**
       * @param {ol.Feature} feature Feature.
       */
      function(feature) {

        loading = loading ||
            this.renderFeature_(feature, resolution, pixelRatio, replayGroup);
      }, this);

  replayGroup.finish();

  if (loading) {
    return null;
  }
        //size[0] = 1017;
        //size[1] = 706;
  size[0] = parseInt(size[0]);
  size[1] = parseInt(size[1]);
  //console.log(this.id_+' width='+this.canvasSize_[0]+' height='+this.canvasSize_[1]);
  if (Math.abs(this.canvasSize_[0] - size[0])>=5 || Math.abs(this.canvasSize_[1] - size[1])>=5) {
    this.canvasContext_.canvas.width = size[0];
    this.canvasContext_.canvas.height = size[1];
    this.canvasSize_[0] = size[0];
    this.canvasSize_[1] = size[1];
  } else {
    //если this.hasGeometryInExtent == false - не отрисовало объекты
    this.canvasContext_.clearRect(0, 0, size[0], size[1]);
  }
  //this.canvasContext_.clearRect(0, 0, size[0], size[1]);
  //console.log(this.id_+'width='+size[0]+' height='+size[1]);
  var transform = this.getTransform_(ol.extent.getCenter(extent),
      resolution, pixelRatio, size);
  replayGroup.replay(this.canvasContext_, pixelRatio, transform, 0, {});
  this.replayGroup_ = replayGroup;

  if(!this.hasGeometryInExtent)
    return null;
  return this.canvasContext_.canvas;
};



/**
 * @inheritDoc
 */
map.layer.ExtImageVector.prototype.getImage =
    function(extent, resolution, pixelRatio, projection) {
        resolution = this.findNearestResolution(resolution);

        var canvas = this.canvas_;
        if (canvas &&
            this.renderedRevision_ == this.getRevision() &&
            canvas.getResolution() == resolution &&
            canvas.getPixelRatio() == pixelRatio &&
            ol.extent.containsExtent(canvas.getExtent(), extent) && this.hasGeometryInExtent == true) {
            return canvas;
        }

        extent = extent.slice();
        ol.extent.scaleFromCenter(extent, this.ratio_);
        //!!!! тут считается размер канваса
        var width = ol.extent.getWidth(extent) / resolution;
        var height = ol.extent.getHeight(extent) / resolution;
        var size = [width * pixelRatio, height * pixelRatio];
        //console.time('##'+random);
        //console.log('##'+imageLayer.get('id'));
        var canvasElement = this.canvasFunction_(
            extent, resolution, pixelRatio, size, projection);
        //может возникнуть ситуация, когда в новом экстенте не нашлось фич с объектами видимыми
        //и возвращается null, то в канвасе ничего нет и условие ol.extent.containsExtent(canvas.getExtent(), extent) выполняется -> этот слой отрисовывается, как пустой
        if (canvasElement) {
            canvas = new ol.ImageCanvas(extent, resolution, pixelRatio,
                this.getAttributions(), canvasElement);
        }
        this.canvas_ = canvas;
        this.renderedRevision_ = this.getRevision();

        return canvas;
    };
goog.provide('map.layer.VectorLayer');

var globalPointsLabels_ = {};
var globalPolygonsLabels_ = {};
var globalLinesLabels_ = {};
var globalLinesGEOs_ = {};
var globalPointsGEOs_ = {};
var globalPolygonsGEOs_ = {};
/**
 * @classdesc
 * Векторный слой слой
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @param  opt_options Options.
 * @api
 */
map.layer.VectorLayer = function (opt_options) {
	var options = goog.isDef(opt_options) ? opt_options : {};
	//уникальное имя слоя, чтобы корректно работало клонирование
	this.uniqueLayerName = goog.isDef(options.uniqueLayerName) ?
		options.uniqueLayerName : '';
	this.layerLoadCallback = undefined;
	this.xmlGeoArr = ['PODS_ANODE', 'PODS_CLOSURE', 'PODS_COMPRESSOR_STATION', 'PODS_CP_FOREIGN_LINE_CROSSING',
		'PODS_DISTRIBUTION_PLANT', 'PODS_JUNCTION_BOX', 'PODS_LAUNCHER_RECEIVER',
		'PODS_METER_STATION', 'PODS_RECTIFIER', 'PODS_ROUTE', 'PODS_TEST_LEAD', 'PODS_VALVE', 'PODS_VENT_PIPE', 'PODS_WATERWAY',
		'PODS_RAILROAD', 'PODS_ROAD', 'PODS_STRUCTURE_CP_BLOCK', 'PODS_STRUCTURE_CP_TRANS', 'PODS_SHEET_NOTE_LINK', 'PODS_FOREIGN_LINE_CROSSING_LINK',
		'PODS_SHEET_NOTE_FUND', 'PODS_MARKER', 'PODS_MARKER_POINT',
		'PODS_MARKER_KM', 'PODS_STRUCTURE', 'PODS_FOREIGN_LINE_CROSSING', 'PODS_METER', 'PODS_ROAD_ENTITY', 'PODS_WATERWAY_ENTITY'];

	//массив синонимов слоя. Используется в синхронизации между окнами
	this.layerNameSynonym =  goog.isDef(options.layerNameSynonym) ?
		options.layerNameSynonym : [];

	this.layerQueryId = goog.isDef(options.layerQueryId) ?
		options.layerQueryId : '';

	//флаг указывает, можно ли центроваться по объекту при первичной загрузке
	this.canFirstTimeCentering = goog.isDef(options.canFirstTimeCentering) ?
		options.canFirstTimeCentering : true;

	this.layerSchema = goog.isDef(options.layerSchema) ?
		options.layerSchema : '';

	//произошло ли отписывание от события. По какой-то причине не происходит отписывание через
	//goog.events.unliste - не находится событие в 
	//  var index = goog.events.ListenerMap.findListenerIndex_(
	//       listenerArray, listener, opt_useCapture, opt_listenerScope);
	//хотя оно там есть. Принято решение использовать доп. флаг
	this.isUnlistenedMoveEnd = false;

	this.layerTable = goog.isDef(options.layerTable) ?
		options.layerTable : '';

	//размерность геометрии.  ol.geom.GeometryLayout.XY или ol.geom.GeometryLayout.XYZ. По умолчанию не определена.
	//используется для функционала копирования вставки геометрии
	this.layout = undefined;

	this.emptyDataExtent = [Infinity, Infinity, -Infinity, -Infinity];

	//будут использоваться для ограничения видимости в текущем масштабе. Из файлов слоёв
	this.maxResolution = goog.isDef(options.maxResolution) ?
		options.maxResolution : Infinity;
	this.minResolution = goog.isDef(options.minResolution) ?
		options.minResolution : 0;

	this.maxLayerZoom = goog.isDef(options.maxLayerZoom) ?
		options.maxLayerZoom : Infinity;
	this.minLayerZoom = goog.isDef(options.minLayerZoom) ?
		options.minLayerZoom : 0;

	this.useServerCache = goog.isDef(options.useServerCache) ?
		options.useServerCache : false;
	this.sourceName = goog.isDef(options.sourceName) ?
		options.sourceName : '';

	this.sourceDescr = goog.isDef(options.sourceDescr) ?
		options.sourceDescr : '';

	this.name = goog.isDef(options.name) ?
		options.name : '';

	this.mapName = goog.isDef(options.mapName) ?
		options.mapName : '';

	this.spacing = goog.isDef(options.spacing) ?
		options.spacing : '';

	this.cover = goog.isDef(options.cover) ?
		options.cover : 'false';

	this.type = goog.isDef(options.type) ?
		options.type : 'common';

	this.showInfo = goog.isDef(options.showInfo) ?
		options.showInfo : 'true';

	this.order = goog.isDef(options.order) ?
		options.order : NaN;

	this.mapOrder = goog.isDef(options.mapOrder) ?
		options.mapOrder : NaN;

	this.zIndex = goog.isDef(options.zIndex) ?
		options.zIndex : 0;

	this.filter = goog.isDef(options.filter) ?
		options.filter : undefined;
	/**
	 * Вариант, когда в layers файле описаны несколько фильтров
	 * @type {*|undefined}
	 */
	this.filters = goog.isDef(options.filters) ?
		options.filters : undefined;

	this.filterExpression = goog.isDef(options.filterExpression) ?
		options.filterExpression : '';

	this.dataType = goog.isDef(options.dataType) ?
		options.dataType : map.layer.DATA_TYPE.VECTOR;

	this.fieldId = goog.isDef(options.fieldId) ?
		options.fieldId : 'GID';

	//уникальная часть идентификатора. Если она есть, то используем её в качестве идентификатора при получении информации
	this.semanticField = 'SEMANTIC_ID';
	this.hasSemanticField = false;

	//массив уникальных значений геометрии, подписей и прочего для составных объктов техсхемы, чтобы корректтирование данные на карте
	//например, чтобы подписи были только для одного сегмента
	this.semanticUniqData = {};
	this.semanticShiftData = {};//position:0 и счетчик по экстенту

	this.labelField = goog.isDef(options.labelField) ?
		options.labelField : '';

	this.classField = goog.isDef(options.classField) ?
		options.classField : '';

	this.projection = goog.isDef(options.projection) ?
		options.projection : GeoUtil.PROJS.WGS84;//по умолчанию проекция WGS84

	//по умолчанию - "GEOLOC". Альтернатива - "WKB_GEOMETRY";
	this.fieldGeodata = goog.isDef(options.fieldGeodata) ?
		options.fieldGeodata : 'WKB_GEOMETRY';
	this.fitMap = goog.isDef(options.fitMap) ?
		options.fitMap : false;

	//upd 12.02.21 из-за того, что пытались грузить замкнутые линии из gpx в слой треков, который
	this.drawTypes = goog.isDef(options.drawTypes) ?
		options.drawTypes : [];

	this.dataReady_ = false;

	this.iustMemoryCorruptCounter = 5;
	//Linux. Счетчик попыток перезапроса данных, если выдается ошибка proxy badgateway в nodejs
	this.nodeErrorCounter = 30;
	//Linux. Счетчик попыток перезапроса данных, если выдается ошибка apache2
	this.internalServerErrorCounter = 5;
	//перезапрос данных в случае ошибки geoloc в техсхеме
	this.geolocErrorCounter = 5;

	//флаг запрещает загрузку данных, например, в случае со сменой режима на растровый
	this.canLoadData = true;

	//локальный кеш, если убираем видимость
	this.cache_ = undefined;

	this.isDataLoading_ = false;

	this.dataProvider = goog.isDef(options.dataProvider) ?
		options.dataProvider : {};

	this.featureProjLayer = undefined;

	this.points_ = {};

	this.lines_ = {};
	this.polygons_ = {};
	this.pointsData_ = {};
	this.linesData_ = {};
	this.polygonsData_ = {};

	this.hasData = false;//есть ли геометрия в слое

	this.showText = true;

	//нужно ли открывать средний фильтр при старте задачи
	this.needPreOpenRoughFilter = false;
	this.hasSplittedData = false;
	this.allSplittedStubDataLoaded = false;
	this.currentXmlLoadIndex = 0;
};
//Чистка глобального массива _LABELS. Для случая, если при отрисовке фичи, она не попала в отрисовки по масштабу и т.д
map.layer.VectorLayer.prototype.clearLabelsOnMap = function(type, topology){
	if(_LABELS && _LABELS.length){
		topology = topology.toLowerCase();
		var i = _LABELS.length - 1;
		for (i; i >= 0; i--) {
			var labelTopoType  = (''+_LABELS[i].type).toLowerCase();
			if (_LABELS[i].unique.indexOf(type + '_') === 0 && topology === labelTopoType)
				_LABELS.splice(i, 1);
		}
	}
}

map.layer.VectorLayer.prototype.bindDataRequest = function (evt) {
	if (goog.isDef(WidgetMap.map)) {
		goog.events.listen(WidgetMap.map,
			'moveend',
			map.layer.VectorLayer.prototype.onMoveEnd, false, this);
	}
};

map.layer.VectorLayer.prototype.onMoveEnd = function (evt) {
	var that = this;
	if(that.isUnlistenedMoveEnd)
		return;
	if (this.dataReady_ == true) {
		goog.events.unlisten(WidgetMap.map,
			'moveend',
			map.layer.VectorLayer.prototype.onMoveEnd, false, this);
		that.isUnlistenedMoveEnd = true;
		return false;
	}
	if (this.isDataLoading_ == true)
		return;
	if (!goog.isDef(this.filter)) {
		var layerObj = WidgetMap.layerManager.getLayerByName(this.name);
		if (goog.isDef(layerObj)) {
			if (layerObj.visible === 'true' || layerObj.visible == true) {
				WidgetMap.layerManager.enableLayer(layerObj.id);
			}
			else {
				WidgetMap.layerManager.disableLayer(layerObj.id);
			}
		}
	}
	else {
		goog.events.unlisten(WidgetMap.map,
			'moveend',
			map.layer.VectorLayer.prototype.onMoveEnd, false, this);
		that.isUnlistenedMoveEnd = true;
	}

};

map.layer.VectorLayer.prototype.toXML = function () {
	this.setFieldGeodataFromTask_();
	var textStyle = WidgetMap.layerManager.getTextStyle(this.name);
	var requestXML;
	var layerType = (this.dataType == map.layer.DATA_TYPE.VECTOR) ? '1' : '2';
	if (false && goog.isDefAndNotNull(textStyle)) {
		if (this.filterExpression !== '') {
			requestXML = '<LAYER ID="' + this.name + '" NAME="' + this.sourceName + '" TABLE_OWNER="' + this.layerSchema +
				'" TABLE_NAME="' + this.layerTable + '" FILTER_EXPRESSION="' + this.filterExpression +
				'" LAYER_TYPE_ID="' + layerType + '" FIELD_ID="' + this.fieldId + '" FIELD_DESCR="' + this.labelField +
				'" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"' +
				' LABEL_AUTO="' + textStyle.auto + '" LABEL_COLUMN="' + this.labelField +
				//'" LABEL_FONT="'+textStyle.MIStyle+'" LABEL_PARALLEL="'+textStyle.parallel+
				'" LABEL_OVERLAP="' + textStyle.overlap + '" LABEL_DUPLICATE="' + textStyle.duplicate + '" />';
		}
		else {
			requestXML = '<LAYER ID="' + this.name + '" NAME="' + this.sourceName + '" TABLE_OWNER="' + this.layerSchema + '" TABLE_NAME="' + this.layerTable +
				'" LAYER_TYPE_ID="' + layerType + '" FIELD_ID="' + this.fieldId + '" FIELD_DESCR="' + this.labelField +
				'" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"' +
				' LABEL_AUTO="' + textStyle.auto + '" LABEL_COLUMN="' + this.labelField +
				//'" LABEL_FONT="'+textStyle.MIStyle+'" LABEL_PARALLEL="'+textStyle.parallel+
				'" LABEL_OVERLAP="' + textStyle.overlap + '" LABEL_DUPLICATE="' + textStyle.duplicate + '" />';
		}
	}
	else {
		if (this.filterExpression !== '') {
			requestXML = '<LAYER ID="' + this.name + '" NAME="' + this.sourceName + '" TABLE_OWNER="' + this.layerSchema +
				'" TABLE_NAME="' + this.layerTable + '" FILTER_EXPRESSION="' + this.filterExpression +
				'" LAYER_TYPE_ID="' + layerType + '" FIELD_ID="' + this.fieldId + '" FIELD_DESCR="' + this.labelField +
				'" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"' +
				' LABEL_AUTO="0" LABEL_COLUMN="' + this.labelField + '" />';
		}
		else {
			requestXML = '<LAYER ID="' + this.name + '" NAME="' + this.sourceName + '" TABLE_OWNER="' + this.layerSchema +
				'" TABLE_NAME="' + this.layerTable +
				'" LAYER_TYPE_ID="' + layerType + '" FIELD_ID="' + this.fieldId + '" FIELD_DESCR="' + this.labelField +
				'" FIELD_STYLE="STYLE" FIELD_MI_STYLE="MI_STYLE" FIELD_TEXT_CLAUSE="TEXT_CLAUSE"' +
				' LABEL_AUTO="0" LABEL_COLUMN="' + this.labelField + '" />';
		}
	}
	return requestXML;
};


map.layer.VectorLayer.prototype.setFieldGeodataFromTask_ = function () {
	this.fieldGeodata = 'GEOLOC';
	this.fieldId = "GID";
	if (true || this.fieldGeodata === "GEOLOC") {
		this.fieldId = "MI_PRINX";
	}
	else {
		if (this.fieldGeodata !== "WKB_GEOMETRY")
			this.fieldGeodata = "WKB_GEOMETRY";
	}
};
map.layer.VectorLayer.prototype.setVisibleText = function (value) {
	this.showText = value;
};

map.layer.VectorLayer.prototype.setVisible = function (value) {
	//выставляем чекбокс в контроле управления слоями
	if(WidgetMap !== undefined && WidgetMap.baseLayersControl !== undefined){
		WidgetMap.baseLayersControl.updateVisibility(this.name, value);
	}

	if (this.dataReady_ == true) {
		if (this.featureProjLayer.getVisible() == value)
			return;
		this.featureProjLayer.setVisible(value);
		if (!value) {//
			//если скрываем слой, то из массива подписей убираем во временный массив для этого слоя
			_IS_CHANGE_LAYER_VISIBILITY[this.name] = {};
			if (_LABELS.length > 0) {
				var i = _LABELS.length - 1;
				for (; i >= 0; i--) {
					if (_LABELS[i].unique.indexOf(this.name) != -1) {
						if (!goog.isDef(_TEMP_LAYERS_LABELS[this.name])) {
							_TEMP_LAYERS_LABELS[this.name] = [];
						}
						_TEMP_LAYERS_LABELS[this.name].push(_LABELS[i]);
						_LABELS.splice(i, 1);
					}
				}
			}
		}
		else {
			//заносим в массив назад подписи, если просто видимость меняем
			if (_IS_FULL_REDRAW == false) {
				if (goog.isDef(_TEMP_LAYERS_LABELS[this.name])) {
					var arr = _TEMP_LAYERS_LABELS[this.name];
					var i = arr.length - 1;
					for (; i >= 0; i--) {
						if (arr[i].unique.indexOf(this.name) != -1) {
							_pointLabels.push(arr[i]);
						}
					}
				}
			}
		}
	}
	else {//подгрузить если слои изначально не подгрузились
		//чистим сначала слой
		this.clear();
		if (value == true) { //подгрузить только, если слой установили видимым
			if (this.checkStyleZoom() == true) {
				if (!goog.isDef(this.filter)) {
					this.loadData();
				}
				else {
					if (goog.isDef(WidgetMap.currentFilter[this.name]) && WidgetMap.currentFilter[this.name].length > 0) {
						var i = 0;
						for (; i < WidgetMap.currentFilter[this.name].length; i++) {
							var curF = WidgetMap.currentFilter[this.name][i];
							if (curF.value != '')
								this.loadData();
						}
					}
				}
			}
		}
	}
};

/**
 * Проверяем стили на попадание в зум карты
 */
map.layer.VectorLayer.prototype.checkStyleZoom = function () {
	var currZoom = WidgetMap.map.getView().getZoom();
	if (currZoom >= this.minLayerZoom && currZoom <= this.maxLayerZoom)
		return true;
	return false;
};

//Полное обновление данных в слоях карты (получаем заново из базы)
map.layer.VectorLayer.prototype.refreshLayerData = function (ignoreCache) {
	if (this.dataReady_) {
		this.dataReady_ = false;
		this.clear();
		this.loadData(true, ignoreCache);
	}
};

/**
 * Подгружаем данные
 */
map.layer.VectorLayer.prototype.loadData = function (force, ignoreCache) {
	if (this.dataReady_ == false) {
		if (this.isDataLoading_ == true) return;
		this.clear();

		//заполняем переменную с дефолтным экстеном без данныхх
		/*try{
			this.emptyDataExtent = this.featureProjLayer.getSource().getSource().getExtent();
		}
		catch (e) {}*/

		//this.requestJsonStubData_();
		//Временная проверка , если не нашли в массиве, то грузим из сервиса, иначе из файла
		//используем запрос для получения флага USE_SERVER_CACHE. Если true, то используем постраничность, иначе геометрия загружается из бд
		if(this.checkStyleZoom() == true || force == true){
			if(ignoreCache){
				this.requestData_();
				return;
			}
			(this.useServerCache)?this.splitData_():this.requestData_();
		}
	}
};

/**
 * Подгружаем данные
 *
 * @param ids
 * @param centeting флаг, нужна ли перецентровка после загрузки данных
 */
map.layer.VectorLayer.prototype.loadDataByIds = function (ids, centeting) {
	if(!this.useServerCache && (this.checkStyleZoom() === true || this.dataReady_)){
		this.requestData_(ids, centeting);
	}
};


/**
 *
 * @private
 */
map.layer.VectorLayer.prototype.splitData_ = function () {
	var that = this;
	if (!that.canLoadData) return;
	if (that.isDataLoading_ == true) return;
	that.isDataLoading_ = true;
	that.currentXmlLoadIndex = 0;
	var dataActualDate = '';
	if (goog.isDef(App.config) && goog.isDef(App.config.DATA_ACTUAL_DATE))// передаем параметр, который будет указывать, нужно ли перенерерирывать данные
		dataActualDate = App.config.DATA_ACTUAL_DATE;
	function getReqParams(request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var roughFiltersStr = LayerManager.getRoughFiltersString(WidgetMap.currentRoughFilter);
		var filter = '';
		if (goog.isDef(that.name) && goog.isDef(that.filter)) {
			if (roughFiltersStr != '') {
				var ff = that.filter.replace('{FILTER}', roughFiltersStr);
				ff = ff.replace('{FILTER}', roughFiltersStr);
				filter = ' AND ' + ff;
			}
		}
		else{
			topFiltersStr = LayerManager.getTopFiltersStringWithBaseLPU(WidgetMap.currentTopFilter);
		}
		var filterStr = '8=8';
		return {
			descrId: request,
			descrType: 'select',
			topology: that.drawTypes.join(),
			data: '<root USER_ID="' + userId.xmlEscape() +
			'" USER_LOGIN="' + userLogin.xmlEscape() +
			'" PODS_USER="' + userLogin.xmlEscape() +
			'" ' + topFiltersStr + '' +
			'>' +
			'<data USE_SERVER_CACHE="'+that.useServerCache+'" FILE_NAME="' + that.name + '"  DATA_ACTUAL_DATE="' + dataActualDate + '" FILTER="' + filterStr + filter + '" />' +
			'</root>'
		};
	}

	function getLayerGeoResult(resultXml) {
		BlockingUtil.readyGeo();
		that.isDataLoading_ = false;
		try {
			var dataArray = [];
			// Иногда ответ в формате XML, а иногда в виде просто строки
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '')
				that.requestData_();
			else
				that.requestSplittedStubData_();
		}
		catch (ex) {
			that.requestData_();
		}
	}

	//ошибка
	function getLayerGeoFault(resultXml) {
		BlockingUtil.readyGeo();
		that.isDataLoading_ = false;
		that.requestData_();
	}
	BlockingUtil.waitGeo();
	App.serverQueryXML2Node(Services.processQueryNodeGeo, getReqParams(that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault, false);
};


map.layer.VectorLayer.prototype.requestSplittedStubData_ = function () {
	var that = this;
	var dataActualDate = '';
	if (goog.isDef(App.config) && goog.isDef(App.config.DATA_ACTUAL_DATE))// передаем параметр, который будет указывать, нужно ли перенерерирывать данные
		dataActualDate = App.config.DATA_ACTUAL_DATE;
	if (!that.canLoadData || that.isDataLoading_ == true)
		return;
	this.hasSplittedData = true;
	if(this.currentXmlLoadIndex == 0) {//если первый запрос, то считаем данных нет. Следующие части файла не должны этот флаг редактировать, т.к. идет сбой на последнем пустом
		this.hasData = false;
		this.dataReady_ = false;
	}
	if (goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.spatial) && that.dataProvider.spatial != '') {
		this.isDataLoading_ = true;
		BlockingUtil.waitGeo();
		function getLayerGeoReqParams(xmlIndex, request) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			return {
				descrId: request,
				xmlIndex: xmlIndex,
				descrType: 'select',
				data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'><data /></root>'
			};
		}

		function getLayerGeoResult(resultXml) {
			if (!that.canLoadData)//если в момент получения данных уже растровый режим, то не обрабатываем
				return;
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.readyGeo();
					if (er.indexOf('Отсутствует корневой элемент.' != -1) || er.indexOf('Root element is missing')!=-1) {//если файла не существует
						that.isDataLoading_ = false;
						that.allSplittedStubDataLoaded = true;
						that.fitMap_();
						return;
					}
					App.errorReport(gis_vectorlayer_1, er, undefined, {
						filename: gis_filename_1,
						functionname: 'requestStubData__getLayerGeoResult'
					});
					return;
				}

				that.nodeErrorCounter = 30;
				that.points_ = {};
				that.pointsLabels_ = {};
				that.lines_ = {};
				that.polygons_ = {};
				that.pointsData_ = {};
				that.linesData_ = {};
				that.polygonData_ = {};
				var i = 0;
				var result = $.parseXML(resultXml);
				var layerGeoXml;
				var datas = [];
				if(result){
					layerGeoXml = result.firstChild;
					datas = layerGeoXml.getElementsByTagName("data");
				}
				var stride = 2;
				for (i; i < datas.length; i++) {
					//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
					var format = new ol.format.WKT({dimension: stride});
					var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
					var type = datas[i].getAttribute("TYPE");
					var label = datas[i].getAttribute("LABEL");
					var idStr = datas[i].getAttribute("ID");
					if (idStr == '' || idStr === null) {
						idStr = datas[i].getAttribute("id");
					}
					var semanticId = undefined;
					var semanticField = datas[i].getAttribute(that.semanticField);
					if(semanticField){
						that.hasSemanticField = true;
						idStr += '|' + semanticField; //делаем комбинированный id, вариант тех схемы, где ID должно совпадать
					}
					if (!goog.isNull(label)) {
						label = label.replace(/""/gm, '"');
						label = label.replace(/Ж(\d)/gm, 'Ø$1');
					}
					var fGeometry = undefined;
					if (goog.isNull(wktStr))
						continue;
					try {
						fGeometry = format.readGeometry(wktStr);
					}
					catch (ex) {
						//для случая с видеозаписями, приходит 3 координаты
						stride = 3;
						format = new map.format.WKT({dimension: stride});
						fGeometry = format.readGeometry(wktStr);
					}
					if (fGeometry.getType() == 'Point' && that.drawTypes.indexOf('point') != -1) {
						if ((fGeometry.flatCoordinates[0] < 0 || fGeometry.flatCoordinates[1] < 0) && that.projection !== 'EPSG:3395' && that.projection !== 'EPSG:5807')
							continue;
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.points_[that.name + ttype]))
							that.points_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsLabels_[that.name + ttype]))
							globalPointsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsGEOs_[that.name + ttype]))
							globalPointsGEOs_[that.name + ttype] = {};
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
								GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						that.points_[that.name + ttype].push(fGeometry.getFlatCoordinates());
						globalPointsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalPointsGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() == 'LineString' && that.drawTypes.indexOf('line') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.lines_[that.name + ttype]))
							that.lines_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesLabels_[that.name + ttype]))
							globalLinesLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesGEOs_[that.name + ttype]))
							globalLinesGEOs_[that.name + ttype] = {};
						that.lines_[that.name + ttype].push(fGeometry);
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						//считаем extent для геометрии
						//fGeometry.getExtent();
						globalLinesLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalLinesGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() == 'Polygon' && that.drawTypes.indexOf('polygon') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.polygons_[that.name + ttype]))
							that.polygons_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsLabels_[that.name + ttype]))
							globalPolygonsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsGEOs_[that.name + ttype]))
							globalPolygonsGEOs_[that.name + ttype] = {};
						that.polygons_[that.name + ttype].push(fGeometry);
						globalPolygonsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalPolygonsGEOs_[that.name + ttype][idStr] = fGeometry;
					}

				}
				var pArr = [];
				var stName;
				var findedFeature = false;
				for (stName in that.polygons_) {
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newPolygonFeature;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newPolygonFeature = sourceFeatures[fea];
							var polygons = newPolygonFeature.getGeometry().getPolygons();
							polygons = polygons.concat(that.polygons_[stName]);
							var geometry1 = new ol.geom.MultiPolygon(null);
							geometry1.setPolygons(polygons);
							newPolygonFeature.setGeometry(geometry1);
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					//если загрузили первый файл, то создаем фичу или если не нашли фичу с типом
					if (that.currentXmlLoadIndex == 1 || findedFeature != true) {
						var geometry = new ol.geom.MultiPolygon(null);
						geometry.setPolygons(that.polygons_[stName]);
						newPolygonFeature = new ol.Feature(geometry);
						newPolygonFeature.set('layerId', that.name);
						newPolygonFeature.set('spacing', that.spacing);
						newPolygonFeature.set('labelType', stName);
						newPolygonFeature.set('zIndex', that.zIndex);
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('labelsObjAll', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);//текущие, которые обрабатываются
						newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);//все объекты
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.POLYGON;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('type'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							styleName = this.get('layerId');
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(styleName);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							styleName = 'DEFAULT';
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newPolygonFeature);
					}
					delete that.polygons_[stName];
					delete that.polygonData_[stName];
				}
				for (stName in that.lines_) {
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newLineFeature;
					findedFeature = false;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newLineFeature = sourceFeatures[fea];
							var lineStrings = newLineFeature.getGeometry().getLineStrings();
							lineStrings = lineStrings.concat(that.lines_[stName]);
							var geometry1 = new ol.geom.MultiLineString(null);
							geometry1.setLineStrings(lineStrings);
							newLineFeature.setGeometry(geometry1);
							//that.featureProjLayer.changed();
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					//если загрузили первый файл, то создаем фичу или если не нашли фичу с типом
					if (that.currentXmlLoadIndex == 1 || findedFeature != true) {
						var geometry = new ol.geom.MultiLineString(null);
						geometry.setLineStrings(that.lines_[stName]);
						newLineFeature = new ol.Feature(geometry);
						newLineFeature.set('layerId', that.name);
						newLineFeature.set('spacing', that.spacing);
						newLineFeature.set('zIndex', that.zIndex);
						newLineFeature.set('labelType', stName);
						newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
						newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);//все объекты
						newLineFeature.set('type', stName.replace('/', '_'));
						newLineFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.LINE_STRING;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							styleName = this.get('layerId');
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							styleName = 'DEFAULT';
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s && !goog.isNull(s.style))) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newLineFeature);
					}
					delete that.lines_[stName];
					delete that.linesData_[stName];
				}
				for (stName in that.points_) {
					that.hasData = true;
					findedFeature = false;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newPointFeature;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newPointFeature = sourceFeatures[fea];
							var points = newPointFeature.getGeometry().getCoordinates();
							points = points.concat(that.points_[stName]);
							var geometry1 = new ol.geom.MultiPoint(null);
							geometry1.setCoordinates(points, ol.geom.GeometryLayout.XY);
							newPointFeature.setGeometry(geometry1);
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					//если загрузили первый файл, то создаем фичу или если не нашли фичу с типом
					if (that.currentXmlLoadIndex == 1 || findedFeature != true) {
						var geometry = new ol.geom.MultiPoint(null);
						geometry.setCoordinates(that.points_[stName], ol.geom.GeometryLayout.XY);
						newPointFeature = new ol.Feature(geometry);
						newPointFeature.set('layerId', that.name);
						newPointFeature.set('spacing', that.spacing);
						newPointFeature.set('zIndex', that.zIndex);
						newPointFeature.set('labelType', stName);
						newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
						newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
						newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);//все объекты
						newPointFeature.set('labelsObjAll', globalPointsLabels_[stName]);
						newPointFeature.set('type', stName.replace('/', '_'));
						newPointFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.POINT;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);

								}
								return [s.style];
							}
							styleName = this.get('layerId');
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							styleName = 'DEFAULT';
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(styleName, topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newPointFeature);
					}
					delete that.pointsLabels_[stName];
					delete that.points_[stName];
					delete that.pointsData_[stName];
				}
				if (pArr.length > 0)
					that.featureProjLayer.getSource().getSource().addFeatures(pArr);
				delete pArr;
				//если удачно добавили часть данных, то запрашиваем новую порцию из другого файла
				that.isDataLoading_ = false;
				BlockingUtil.readyGeo();
				//выставляем флаг, что данные есть
				that.dataReady_ = true;
				if(datas.length == 0){
					that.isDataLoading_ = false;
					that.allSplittedStubDataLoaded = true;
					that.fitMap_();
					return;
				}
				that.requestSplittedStubData_();
			}
			catch (ex) {
				if (goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(false);
				that.isDataLoading_ = false;
				BlockingUtil.readyGeo();
				App.errorReport(gis_vectorlayer_1, ex.message+gis_vectorlayer_6+resultXml, undefined, {
					filename: gis_filename_1,
					functionname: 'requestStubData__getLayerGeoResult_1',
					datatext: gis_vectorlayer_5 + that.name + gis_vectorlayer_6 + resultXml
				});
				goog.events.unlisten(WidgetMap.map,
					'moveend',
					map.layer.VectorLayer.prototype.onMoveEnd, false, this);
				that.isUnlistenedMoveEnd = true;
				that.allSplittedStubDataLoaded = true;
				that.fitMap_();
			}
		}

		function getLayerGeoFault(resultXml) {
			BlockingUtil.readyGeo();
			if (that.nodeErrorCounter > 1)
				if (resultXml.indexOf('Bad Gateway') !== -1 || resultXml.indexOf('(Node.js)') !== -1|| resultXml.indexOf('Proxy Error') !== -1) {
					--that.nodeErrorCounter;
					--that.currentXmlLoadIndex;
					that.dataReady_ = false;
					that.isDataLoading_ = false;
					that.allSplittedStubDataLoaded = false;
					that.requestSplittedStubData_();
					return;
				}
			that.internalServerErrorCounter = 0;
			that.dataReady_ = true;
			if (goog.isDef(that.layerLoadCallback))
				that.layerLoadCallback(false);
			that.isDataLoading_ = false;
			App.errorReport(gis_vectorlayer_1, resultXml, undefined, {
				filename: gis_filename_1,
				functionname: 'getLayerGeoFault'
			});
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;

			that.allSplittedStubDataLoaded = true;
			that.fitMap_();
		}
	}

	App.serverQueryXMLSplit1(Services.processQueryNodeXml, getLayerGeoReqParams(that.currentXmlLoadIndex, that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
	++that.currentXmlLoadIndex;
};

/**
 *
 * @param fitTries  попытки перецентровки, если не перецентровалось
 * @private
 */
map.layer.VectorLayer.prototype.fitMap_ = function (fitTries) {
	var that = this;
	if (that.fitMap == true && that.featureProjLayer.getSource().getSource().getFeatures().length > 0) {
		if (that.canFirstTimeCentering == true || (goog.isDef(that.filter) && that.filter != '')/* || fitTries !== undefined*/) {
			var extent = that.featureProjLayer.getSource().getSource().getExtent();
			/*if(ol.extent.equals(extent, that.emptyDataExtent)){
				if(fitTries === undefined) fitTries = 5;
				if(fitTries > 0){
					that.fitMap_(fitTries - 1);
					return;
				}
			}*/
			WidgetMap.centerOnMap(extent);
			that.featureProjLayer.setVisible(true);
		}
		that.canFirstTimeCentering = true;
	}
	if (goog.isDef(that.layerLoadCallback))
		that.layerLoadCallback(true);
};

/**
 * запрос к данным
 * @params ids массив идентификаторов для тонкой загрузки геометрий только по этим объектам
 */
map.layer.VectorLayer.prototype.requestData_ = function (ids, centering) {
	if (!this.canLoadData)
		return;
	var that = this;
	if (that.isDataLoading_ == true)
		return;
	this.hasData = false;
	if (goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.spatial) && that.dataProvider.spatial != '') {
		this.isDataLoading_ = true;
		BlockingUtil.waitGeo();
		function getLayerGeoReqParams(filter, request) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
			var roughFiltersStr = LayerManager.getRoughFiltersString(WidgetMap.currentRoughFilter);
			var roughFilterObj = convertArrayFilterToObject(WidgetMap.currentRoughFilter);

			var filter = '';
			if (goog.isDef(that.name) && goog.isDef(that.filter)) {
				if (roughFiltersStr !== '') {
					if(that.filters){
						for(var f in that.filters){
							var fi = that.filters[f]; //тут хранится pattern. ключ - название переменной
							if(roughFilterObj && roughFilterObj[f]){
								var ff = fi.replace('{FILTER}', roughFiltersStr);
								ff = ff.replace('{FILTER}', roughFiltersStr);
								filter = ' AND ' + ff;
								break;
							}
						}
					}
					else{
						var ff = that.filter.replace('{FILTER}', roughFiltersStr);
						ff = ff.replace('{FILTER}', roughFiltersStr);
						filter = ' AND ' + ff;
					}

				}
			}
			else{
				topFiltersStr = LayerManager.getTopFiltersStringWithBaseLPU(WidgetMap.currentTopFilter);
			}
			var filterIds = '';
			if(ids && ids.length > 0){
				filterIds = ' and ID in ('+ids.join()+') ';
			}
			var zoneId = getParameterByName('ZONE_ID');
			if(zoneId){
				filterIds += ' and zone_id=' + zoneId;
			}
			var filterStr = '8=8';
			return {
				descrId: request,
				topology: that.drawTypes.join(),
				descrType: 'select',
				data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" ' + topFiltersStr + '' +
				'>' +
				'<data FILTER="' + filterStr + filter + filterIds + '" />' +
				'</root>'
			};
		}

		function getLayerGeoResult(resultXml) {
			if (!that.canLoadData)//если в момент получения данных уже растровый режим, то не обрабатываем
				return;
			that.dataReady_ = true;
			that.isDataLoading_ = false;
			//Пытаемся сохранить данные в кеш
			that.saveResultToCache(resultXml);
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.readyGeo();
					if (that.iustMemoryCorruptCounter > 1)
						if (er.indexOf('memory is corrupt.') != -1 || er.indexOf('память повреждена.') != -1/* || er.indexOf('выгруженному объекту AppDomain.') !=-1*/) {
							--that.iustMemoryCorruptCounter;
							that.dataReady_ = false;
							that.isDataLoading_ = false;
							that.requestData_();
							return;
						}
					if (that.geolocErrorCounter > 1)
						if (er.indexOf('Не найдено поле геоданных GEOLOC') != -1) {
							--that.geolocErrorCounter;
							that.dataReady_ = false;
							that.isDataLoading_ = false;
							that.requestData_();
							return;
						}
					App.errorReport(gis_vectorlayer_1, er, undefined, {
						filename: gis_filename_1,
						functionname: 'requestData__getLayerGeoResult'
					});
					return;
				}
				that.iustMemoryCorruptCounter = 0;
				that.internalServerErrorCounter = 0;
				that.geolocErrorCounter = 0;
				var layerGeoXml = ($.parseXML(resultXml)).firstChild;
				var datas = layerGeoXml.getElementsByTagName("data");
				var stride = 2;

				that.points_ = {};
				that.pointsLabels_ = {};
				that.lines_ = {};
				that.polygons_ = {};
				that.pointsData_ = {};
				that.linesData_ = {};
				that.polygonData_ = {};
				var i = 0;
				for (i; i < datas.length; i++) {
					//for (i; i < 1; i++) {
					//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
					var format = new ol.format.WKT({dimension: stride});
					var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
					//wktStr = "POLYGON(( 48.945863 55.994377,48.946621 55.994351,48.946796 55.994342,48.947085 55.99432,48.947175 55.994313,48.947553 55.994488,48.948151 55.994715,48.948434 55.994761,48.949163 55.99505,48.949182 55.995066,48.949572 55.995193,48.950274 55.995425,48.950969 55.995654,48.951667 55.995881,48.951743 55.995906,48.951575 55.995717,48.951684 55.995519,48.951502 55.995321,48.951008 55.995254,48.949904 55.994526,48.949647 55.994255,48.949657 55.994099,48.949347 55.993966,48.948875 55.993888,48.948103 55.993611,48.948275 55.993389,48.948146 55.993341,48.947653 55.993575,48.947126 55.993738,48.94688 55.993672,48.947127 55.993239,48.946967 55.993136,48.947074 55.993022,48.947429 55.992992,48.947397 55.992721,48.947268 55.992691,48.946914 55.992913,48.946431 55.992938,48.946055 55.993107,48.946676 55.993395,48.946677 55.993624,48.946484 55.993672,48.945508 55.993028,48.945132 55.993071,48.945016 55.99316,48.9445 55.992914,48.944265 55.992992,48.944104 55.992667,48.944329 55.992565,48.944137 55.992348,48.945509 55.992071,48.945585 55.991933,48.945746 55.991873,48.945613 55.991723,48.945265 55.991331,48.944458 55.991728,48.944276 55.991939,48.943633 55.992427,48.94356049 55.9925513640001,48.943289 55.993017,48.943023646 55.993200782,48.943019 55.993204,48.9430356410001 55.9932057390001,48.943114822 55.9932140110001,48.94322 55.993225,48.945736432 55.9943218330001,48.945823481 55.9943597750001,48.945845933 55.994369561,48.9458551770001 55.9943735900001,48.945858711 55.99437513,48.945863 55.994377),(48.946783 55.993919,48.946912 55.99384,48.947009 55.993829,48.947308 55.993991,48.947341 55.994045,48.947255 55.9941,48.947169 55.994136,48.947105 55.994141,48.947019 55.994099,48.946847 55.993985,48.946794 55.993955,48.946783 55.993919))";
					//wktStr = "POLYGON(( 48.945863 55.994377,48.946621 55.994351,48.946796 55.994342,48.947085 55.99432,48.947175 55.994313,48.947553 55.994488,48.948151 55.994715,48.948434 55.994761,48.949163 55.99505,48.949182 55.995066,48.949572 55.995193,48.950274 55.995425,48.950969 55.995654,48.951667 55.995881,48.951743 55.995906,48.951575 55.995717,48.951684 55.995519,48.951502 55.995321,48.951008 55.995254,48.949904 55.994526,48.949647 55.994255,48.949657 55.994099,48.949347 55.993966,48.948875 55.993888,48.948103 55.993611,48.948275 55.993389,48.948146 55.993341,48.947653 55.993575,48.947126 55.993738,48.94688 55.993672,48.947127 55.993239,48.946967 55.993136,48.947074 55.993022,48.947429 55.992992,48.947397 55.992721,48.947268 55.992691,48.946914 55.992913,48.946431 55.992938,48.946055 55.993107,48.946676 55.993395,48.946677 55.993624,48.946484 55.993672,48.945508 55.993028,48.945132 55.993071,48.945016 55.99316,48.9445 55.992914,48.944265 55.992992,48.944104 55.992667,48.944329 55.992565,48.944137 55.992348,48.945509 55.992071,48.945585 55.991933,48.945746 55.991873,48.945613 55.991723,48.945265 55.991331,48.944458 55.991728,48.944276 55.991939,48.943633 55.992427,48.94356049 55.9925513640001,48.943289 55.993017,48.943023646 55.993200782,48.943019 55.993204,48.9430356410001 55.9932057390001,48.943114822 55.9932140110001,48.94322 55.993225,48.945736432 55.9943218330001,48.945823481 55.9943597750001,48.945845933 55.994369561,48.9458551770001 55.9943735900001,48.945858711 55.99437513,48.945863 55.994377),(48.946783 55.993919,48.946912 55.99384,48.947009 55.993829,48.947308 55.993991,48.947341 55.994045,48.947255 55.9941,48.947169 55.994136,48.947105 55.994141,48.947019 55.994099,48.946847 55.993985,48.946794 55.993955,48.946783 55.993919)" +
					//	",(48.9483543108 55.9939982769,48.9482041050 55.9943282981,48.9490624104 55.9944543074,48.9483543108 55.9939982769))";
					var type = datas[i].getAttribute("TYPE");
					var label = datas[i].getAttribute("LABEL");
					var idStr = datas[i].getAttribute("ID");
					if (idStr == '' || idStr === null) {
						idStr = datas[i].getAttribute("id");
					}
					var semanticId = undefined;
					var semanticField = datas[i].getAttribute(that.semanticField);
					if(semanticField){
						that.hasSemanticField = true;
						var complexRes = that.updateComplexSemantic(semanticField, label, wktStr);
						if(complexRes && complexRes.ignoreWkt)
							continue;
						if(complexRes && complexRes.ignoreLabel)
							label = null;
						idStr += '|' + semanticField; //делаем комбинированный id, вариант тех схемы, где ID должно совпадать
					}

					if (!goog.isNull(label)) {
						label = label.replace(/""/gm, '"');
						label = label.replace(/Ж(\d)/gm, 'Ø$1');
					}
					var fGeometry = undefined;
					if (goog.isNull(wktStr))
						continue;
					try {
						fGeometry = format.readGeometry(wktStr);
					}
					catch (ex) {
						//для случая с видеозаписями, приходит 3 координаты
						stride = 3;
						format = new map.format.WKT({dimension: stride});
						fGeometry = format.readGeometry(wktStr);
					}

					if(semanticField){
						var geoExtentStr = fGeometry.getExtent().toString();
						if(!that.semanticShiftData[geoExtentStr])
							that.semanticShiftData[geoExtentStr] = {tempPosition: 0, text: label, position: 0 };
						else{
							//если уже есть(по новой схеме двигаем координаты)
							//TODO если экстент одинаковый, то в общий массив заносим position, чтобы
							// на отрисовке текста от position сдвигать вправо и сбрасывать каждые 3 подписи, чтобы подписи рисовалсь лесенкой
							var position = that.semanticShiftData[geoExtentStr].tempPosition + 1;
							that.semanticShiftData[geoExtentStr].tempPosition++;
							if(fGeometry.getType() === ol.geom.GeometryType.POINT)
								fGeometry.translate(0, -position * 3);
							else
								fGeometry.translate(0, -position * 0.5);
							geoExtentStr = fGeometry.getExtent().toString();
							that.semanticShiftData[geoExtentStr] = {tempPosition: 0, position: position, text: label };
						}
						that.semanticUniqData[semanticField].flatCoordinates = that.semanticUniqData[semanticField].flatCoordinates.concat(fGeometry.flatCoordinates);
					}
					if (fGeometry.getType() === ol.geom.GeometryType.POINT && that.drawTypes.indexOf('point') != -1) {
						if ((fGeometry.flatCoordinates[0] < 0 || fGeometry.flatCoordinates[1] < 0) && that.projection !== 'EPSG:3395' && that.projection !== 'EPSG:5807')
							continue;
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.points_[that.name + ttype]))
							that.points_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsLabels_[that.name + ttype]))
							globalPointsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsGEOs_[that.name + ttype]))
							globalPointsGEOs_[that.name + ttype] = {};
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						that.points_[that.name + ttype].push(fGeometry.getFlatCoordinates());
						globalPointsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalPointsGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() === ol.geom.GeometryType.LINE_STRING && that.drawTypes.indexOf('line') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.lines_[that.name + ttype]))
							that.lines_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesLabels_[that.name + ttype]))
							globalLinesLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesGEOs_[that.name + ttype]))
							globalLinesGEOs_[that.name + ttype] = {};
						that.lines_[that.name + ttype].push(fGeometry);
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalLinesLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalLinesGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() === ol.geom.GeometryType.POLYGON && that.drawTypes.indexOf('polygon') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.polygons_[that.name + ttype]))
							that.polygons_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsLabels_[that.name + ttype]))
							globalPolygonsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsGEOs_[that.name + ttype]))
							globalPolygonsGEOs_[that.name + ttype] = {};
						that.polygons_[that.name + ttype].push(fGeometry);
						globalPolygonsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalPolygonsGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					// if(fGeometry.getType() == 'MultiPolygon' && that.drawTypes.indexOf('polygon') != -1){
					// 	var ttype = (goog.isNull(type))?'':'/'+type;
					// 	if(!goog.isDef(that.polygons_[that.name+ttype]))
					// 		that.polygons_[that.name+ttype] = [];
					// 	if(!goog.isDef(globalPolygonsLabels_[that.name+ttype]))
					// 		globalPolygonsLabels_[that.name+ttype] = [];
					// 	if(!goog.isDef(globalPolygonsGEOs_[that.name+ttype]))
					// 		globalPolygonsGEOs_[that.name+ttype] = {};
					// 	that.polygons_[that.name+ttype].push(fGeometry);
					// 	globalPolygonsLabels_[that.name+ttype].push({label:label,id:idStr,geo:fGeometry});
					// 	if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
					//      GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
					// 	globalPolygonsGEOs_[that.name+ttype][idStr] = fGeometry;
					// }

				}
				//console.log('!! '+ that.name+'   length='+datas.length +' time='+new Date().getTime());
				var pArr = [];
				var stName;
				var findedFeature = false;
				for (stName in that.polygons_) {
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newPolygonFeature;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newPolygonFeature = sourceFeatures[fea];
							var polygons = newPolygonFeature.getGeometry().getPolygons();
							polygons = polygons.concat(that.polygons_[stName]);
							var geometry1 = new ol.geom.MultiPolygon(null);
							geometry1.setPolygons(polygons);
							newPolygonFeature.setGeometry(geometry1);
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					if(!findedFeature){
						var geometry = new ol.geom.MultiPolygon(null);
						geometry.setPolygons(that.polygons_[stName]);
						newPolygonFeature = new ol.Feature(geometry);
						newPolygonFeature.set('layerId', that.name);
						newPolygonFeature.set('spacing', that.spacing);
						newPolygonFeature.set('labelType', stName);
						newPolygonFeature.set('zIndex', that.zIndex);
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('labelsObjAll', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);//текущие, которые обрабатываются
						newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);//все объекты
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.POLYGON;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)) {
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('type'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							styleName = this.get('layerId');
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							styleName = 'DEFAULT';
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(styleName, topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)) {
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newPolygonFeature);
					}
					delete that.polygons_[stName];
					delete that.polygonData_[stName];
				}

				for (stName in that.lines_) {
					findedFeature = false;
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newLineFeature;
					findedFeature = false;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newLineFeature = sourceFeatures[fea];
							var lineStrings = newLineFeature.getGeometry().getLineStrings();
							lineStrings = lineStrings.concat(that.lines_[stName]);
							var geometry1 = new ol.geom.MultiLineString(null);
							geometry1.setLineStrings(lineStrings);
							newLineFeature.setGeometry(geometry1);
							//that.featureProjLayer.changed();
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					if(!findedFeature){
						var geometry = new ol.geom.MultiLineString(null);
						geometry.setLineStrings(that.lines_[stName]);
						newLineFeature = new ol.Feature(geometry);
						newLineFeature.set('layerId', that.name);
						newLineFeature.set('spacing', that.spacing);
						newLineFeature.set('zIndex', that.zIndex);
						newLineFeature.set('labelType', stName);
						newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
						newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);//все объекты
						newLineFeature.set('type', stName.replace('/', '_'));
						newLineFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.LINE_STRING;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', topology);
							if (!goog.isNull(s && !goog.isNull(s.style))) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newLineFeature);
					}

					delete that.lines_[stName];
					delete that.linesData_[stName];
				}
				for (stName in that.points_) {
					findedFeature = false;
					that.hasData = true;
					var sourceFeatures = that.featureProjLayer.getSource().getSource().getFeatures();
					var newPointFeature;
					for (var fea in sourceFeatures)
					{
						if (sourceFeatures[fea].get('labelType') == stName) {
							newPointFeature = sourceFeatures[fea];
							var points = newPointFeature.getGeometry().getCoordinates();
							points = points.concat(that.points_[stName]);
							var geometry1 = new ol.geom.MultiPoint(null);
							geometry1.setCoordinates(points, ol.geom.GeometryLayout.XY);
							newPointFeature.setGeometry(geometry1);
							findedFeature = true;
							break;
						}
						findedFeature = false;
					}
					if(!findedFeature){
						var geometry = new ol.geom.MultiPoint(null);
						geometry.setCoordinates(that.points_[stName], ol.geom.GeometryLayout.XY);
						newPointFeature = new ol.Feature(geometry);
						newPointFeature.set('layerId', that.name);
						newPointFeature.set('spacing', that.spacing);
						newPointFeature.set('zIndex', that.zIndex);
						newPointFeature.set('labelType', stName);
						newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
						newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
						newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);//все объекты
						newPointFeature.set('labelsObjAll', globalPointsLabels_[stName]);
						newPointFeature.set('type', stName.replace('/', '_'));
						newPointFeature.setStyle(function (resolution) {
							var styleName = this.get('type');
							var labelStyleName = this.get('labelType');
							var topology = ol.geom.GeometryType.POINT;
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), topology);
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);

								}
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', topology);
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax)){
									that.clearLabelsOnMap(labelStyleName, topology);
									return null;
								}
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', topology);
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							that.clearLabelsOnMap(labelStyleName, topology);
							return null;
						});
						pArr.push(newPointFeature);
					}


					delete that.pointsLabels_[stName];
					delete that.points_[stName];
					delete that.pointsData_[stName];
				}
				if (pArr.length > 0)
					that.featureProjLayer.getSource().getSource().addFeatures(pArr);
				delete pArr;
				//that.points_ = null;
				//that.lines_ = null;
				//that.polygons_ = null;
				BlockingUtil.readyGeo();
				//при подгрузке отдельных данных, даем возможность не центроваться по всему слою
				if(centering !== false)
					that.fitMap_();
			}
			catch (ex) {
				if (goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(false);
				BlockingUtil.readyGeo();
				that.dataReady_ = true;
				that.isDataLoading_ = false;
				App.errorReport(gis_vectorlayer_1, ex, undefined, {
					filename: gis_filename_1,
					functionname: 'requestData__getLayerGeoResult_1',
					datatext: gis_vectorlayer_5 + that.name + gis_vectorlayer_6 + resultXml
				});
				goog.events.unlisten(WidgetMap.map,
					'moveend',
					map.layer.VectorLayer.prototype.onMoveEnd, false, this);
				that.isUnlistenedMoveEnd = true;
			}
		}

		function getLayerGeoFault(resultXml) {
			if (that.internalServerErrorCounter > 1)
				if (resultXml.indexOf('Internal Server Error') != -1 || resultXml.indexOf('. error. ') != -1 || resultXml.indexOf('. Error. ') != -1 || resultXml.indexOf('. Error ') != -1) {
					--that.internalServerErrorCounter;
					that.dataReady_ = false;
					that.isDataLoading_ = false;
					that.requestData_();
					return;
				}
			that.internalServerErrorCounter = 0;
			that.dataReady_ = true;
			if (goog.isDef(that.layerLoadCallback))
				that.layerLoadCallback(false);
			BlockingUtil.readyGeo();
			that.isDataLoading_ = false;
			App.errorReport(gis_vectorlayer_1, resultXml, undefined, {
				filename: gis_filename_1,
				functionname: 'requestData__getLayerGeoFault'
			});
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;
		}


		//Получаем данные из кеша
		var layerDataCache = this.getDataFromCache();
		if (goog.isDefAndNotNull(layerDataCache)) {
			getLayerGeoResult(layerDataCache.result);
		}
		else
			App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams('', that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
	}
};

map.layer.VectorLayer.prototype.processObject_ = function (feature, dProp) {
	if (!goog.isDef(feature))
		return;
	var geo = feature.getGeometry();
	var geoType = feature.getGeometry().getType();
	var coords = feature.getGeometry().flatCoordinates;
	if (!goog.isDef(dProp.geo))
		dProp.geo = geo;
	var style = undefined;
	switch (geoType) {
		case 'Point': {
			var lName = this.name + '_' + dProp.TYPE;
			var id = dProp.ID;
			style = WidgetMap.layerManager.getPointStyle(lName);
			this.getArrayProperty(this.points_, lName).push(coords);
			this.addObjectPropertyToData_(this.pointsData_, lName, dProp);

			break;
		}
		case 'LineString': {
			break;
		}
		case 'Polygon': {
			break;
		}
		default: {
			style = WidgetMap.layerManager.getStyleByName(this.name + '_' + dProp.TYPE);
		}
	}
};

/**
 * Установка стиля текстовой подписи для стиля фичи
 * @param style
 * @param textstyle
 */
map.layer.VectorLayer.prototype.setTextStyle = function (style, textstyle) {
	if (!goog.isNull(textstyle)) {
		var textAlign = ['left', 'middle'];
		if (goog.isDef(textstyle.align)) {
			if ((textstyle.align.indexOf('|') != -1))
				textAlign = textstyle.align.split('|');
			else {
				if (textstyle.align === 'bottom' || textstyle.align === 'top' || textstyle.align === 'middle')
					textAlign = ['right', textstyle.align];
				else if (textstyle.align === 'left' || textstyle.align === 'right' || textstyle.align === 'left')
					textAlign = [textstyle.align,'top'];
			}
		}
		var align = textAlign[0];

		var baseline = textAlign[1];
		var size = goog.isDef(textstyle.fontSize) ? textstyle.fontSize + 'px' : '';
		var offsetX = 0;//-10;
		var offsetY = 0;
		//если стиль точечный и размеры иконок есть, то учитываем при сдвигах
		var iconOffsetX = 0;
		var iconOffsetY = 0;
		if (!goog.isArray(style) && !goog.isNull(style.image_)) {
			var imageSize = style.getImage().getSize();
			iconOffsetX = imageSize[0] / 2;
			iconOffsetY = imageSize[1] - 3;
		}
		if (align == 'left') {
			align = 'right';
			offsetX = -iconOffsetX;//-10;
		} else if (align == 'right') {

			align = 'left';
			offsetX = iconOffsetX;//3;
		}
		if (baseline == 'top') {
			baseline = 'bottom';
			offsetY = -iconOffsetY;//-7;
		} else if (baseline == 'bottom') {

			baseline = 'top';
			offsetY = iconOffsetY;//10;
		}
		var weight = (textstyle.bold == '1') ? 'bold ' : 'normal ';//убрал в 8.1 версии библиотеки 'normal', т.к. с ним перестал применяться italic
		var italic = (textstyle.italic == '1') ? 'italic ' : '';
		var fontName = goog.isDef(textstyle.fontFamily) ? textstyle.fontFamily : 'Arial';
		var font = italic + '' + weight + '' + size + ' ' + fontName;//font: 'normal 16px Helvetica',
		var fillColor = '#' + textstyle.color.substr(2, 6);
		//прозрачность
		var alpha = parseInt((parseInt('0x0000' + textstyle.color.substr(0, 2), 16) / 255) * 100) / 100;
		//col = '#'+c.substr(2,6); //parseFloat('0x'+c.substr(2,6));
		var col = 'rgba(' + parseInt(textstyle.color.substr(2, 2), 16) + ', ' + parseInt(textstyle.color.substr(4, 2), 16) + ', ' + parseInt(textstyle.color.substr(6, 2), 16) + ', ' + alpha + ')';
		fillColor = col;

		var texttt = undefined;
		if (textstyle.type == 'polygon')
			texttt = '';//'q2';//features[i].get('label');
		if (goog.isDef(style)) {
			if (goog.isArray(style)) {
				var i = 0;
				for (i; i < style.length; i++) {
					style[i].text_ = new ol.style.Text({
						textAlign: align,
						textBaseline: baseline,
						font: font,
						stroke: new ol.style.Stroke({color: '#fff', width: 2}),
						text: texttt,
						offsetX: offsetX,
						offsetY: offsetY,
						fill: new ol.style.Fill({color: fillColor})
					});
				}
			}
			else {
				style.text_ = new ol.style.Text({
					textAlign: align,
					textBaseline: baseline,
					font: font,
					stroke: new ol.style.Stroke({color: '#fff', width: 2}),
					text: texttt,
					offsetX: offsetX,
					offsetY: offsetY,
					fill: new ol.style.Fill({color: fillColor})
				});
			}
		}
	}
	else {
		style.text_ = null;
	}
};


/* проверяет, есть ли такое свойство у объекта и возвращает его, если нет, то создает свойство типа Array */
map.layer.VectorLayer.prototype.getArrayProperty = function (obj, prop) {
	if (!goog.isDef(obj[prop])) {
		obj[prop] = [];
	}
	return obj[prop];
};

map.layer.VectorLayer.prototype.getObjectProperty = function (obj, prop) {
	if (!goog.isDef(obj[prop])) {
		obj[prop] = {};
	}
	return obj[prop];
};

/* Добавляет геометрию в соответствующий объект по ключу ID, учитывая что может быть несколько объектов с одинаковым ключем */
map.layer.VectorLayer.prototype.addObjectPropertyToData_ = function (topologyData, styleName, dProp) {
	if (!goog.isDef(dProp) || !goog.isDef(dProp.ID) || !goog.isDef(dProp.geo))
		return;
	//Проверяем, есть ли уже сохраненный объект с таким id, и если есть - добавляем геометрию к нему, не меняя остальных свойств (это мультиконтур)
	var existProp = this.getObjectProperty(topologyData, styleName);
	if (!goog.isDef(existProp))
		return;

	if (goog.isDef(existProp[dProp.ID]) && goog.isDef(existProp[dProp.ID].geo)) {
		//Если свойство existProp[dProp.ID].geo еще массив, делаем массивом, добавляя в него старую геометрию
		/*if (!(existProp[dProp.ID].geo is Array))
		 existProp[dProp.ID].geo = [existProp[dProp.ID].geo];
		 //Добавляем текущую геометрию уже в массив
		 (existProp[dProp.ID].geo as Array).push(dProp.geo);*/
	}
	else {
		existProp[dProp.ID] = dProp;
	}
};

map.layer.VectorLayer.prototype.getStyle_ = function (styleName, type) {
	//1. если есть атрибут type, то ищем стиль
	//2. если не нашли стиль, то ищем с пустым type
	//3. если не нашли, то устанавливаем дефолтный
	var that = this;
	var s = function (resolution) {
		/*if(this.getId().indexOf('WEB50_POI_POINT')!=-1)
		 console.log('fd');*/
		//TODO добавить условие, чтобы постоянное не получать из менеджера стили, а хранить их
		//сплитим сначала id
		//примененный уже стиль
		var appliedStyle = this.get('appliedStyle');
		if (false && goog.isDef(appliedStyle)) {
			var z = WidgetMap.map.getView().getZoom();
			if (z >= appliedStyle.zoom.zoomMin && z <= appliedStyle.zoom.zoomMax)
				return appliedStyle;
			return null;
		}
		//var idType = this.getId().split(':');//this.get('type');//
		//var idArr =  idType[0].split('/');
		//var styles = WidgetMap.layerManager.getStyleByName(this.getId());
		//return styles;
		var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByName(this.get('layerId') + "_" + this.get('type')/*this.get('layerId')+"_"+this.get('objectId')*/);
		if (!goog.isNull(s))
			return [s];
		s = WidgetMap.layerManager.getStyleByName(this.get('layerId'));
		if (!goog.isNull(s))
			return [s];
		return null;
	};
	return s;
	//TODO добавить получение дефолтного по типу геометрии
};


/**
 * Функция обновления геометрии объекта из базы по его Id
 */
map.layer.VectorLayer.prototype.refreshObjectGeometryById = function (id) {
	var that = this;

	function getLayerGeoReqParams(id, request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var filter = "ID='" + id + "'";
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
			'" USER_LOGIN="' + userLogin.xmlEscape() +
			'" PODS_USER="' + userLogin.xmlEscape() +
			'" ' + topFiltersStr + '' +
			'>' +
			'<data FILTER=" ' + filter + '" />' +
			'</root>'
		};
	}

	function getLayerGeoResult(resultXml) {
		try {
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			for (var i = 0; i < datas.length; i++) {
				var format = new ol.format.WKT({dimension: 2});
				var wktStr = datas[i].getAttribute("WKT");
				var idStr = datas[i].getAttribute("ID");
				if (idStr == '' || idStr === null) {
					idStr = datas[i].getAttribute("id");
				}
				if (wktStr == '' && idStr == '') {
					BlockingUtil.readyGeo();
					return;
				}
				var stride = 2;
				var fGeometry;
				try {
					fGeometry = format.readGeometry(wktStr);
				}
				catch (ex) {
					//для случая с видеозаписями, приходит 3 координаты
					stride = 3;
					format = new map.format.WKT({dimension: stride});
					fGeometry = format.readGeometry(wktStr);
				}
				if (fGeometry.getType() === 'Point' || fGeometry.getType() === 'LineString' || fGeometry.getType() === 'Polygon')
					GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
			}
			var featureProjLayer = that.featureProjLayer;
			//выбираем все features, в которых возможно хранить наш тип геометрии
			var features = featureProjLayer.getSource().getSource().getFeatures();
			var j;
			for (j in features) {
				var index = -1;
				var labels = features[j].get('labelsObj');
				var aa = 0;
				for (; aa < labels.length; aa++) {
					if (labels[aa].id == id) {
						index = aa;
						break;
					}
				}
				if (fGeometry.getType() == ol.geom.GeometryType.LINE_STRING) {
					//заменяем строку на нужную
					if (index != -1) {
						var lineStrings = features[j].getGeometry().getLineStrings();
						lineStrings[index] = fGeometry;
						features[j].get('pointsObj')[id] = fGeometry;
						features[j].get('pointsObjAll')[id] = fGeometry;
						features[j].getGeometry().setLineStrings(lineStrings);
						break;
					}
				}
			}
			BlockingUtil.readyGeo();
		}
		catch (ex) {
			BlockingUtil.readyGeo();
			App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
				filename: gis_filename_1,
				functionname: 'gis_filename_1_1'
			});
		}
	}

	function getLayerGeoFault(resultXml) {
		BlockingUtil.readyGeo();
		App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
			filename: gis_filename_1,
			functionname: 'gis_filename_1_2'
		});
	}

	App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams(id, that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
};


/**
 * Функция обновления геометрии объекта из базы по идентификаторам
 */
map.layer.VectorLayer.prototype.refreshObjectGeometryByIds = function (ids) {
	var that = this;

	function getLayerGeoReqParams(id, request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var filter = "ID in (" + id + ")";
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" ' + topFiltersStr + '' +
				'>' +
				'<data FILTER=" ' + filter + '" />' +
				'</root>'
		};
	}

	function getLayerGeoResult(resultXml) {
		try {
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			for (var i = 0; i < datas.length; i++) {
				var format = new ol.format.WKT({dimension: 2});
				var wktStr = datas[i].getAttribute("WKT");
				var idStr = datas[i].getAttribute("ID");
				if (idStr == '' || idStr === null) {
					idStr = datas[i].getAttribute("id");
				}
				if (wktStr == '' && idStr == '') {
					BlockingUtil.readyGeo();
					return;
				}
				var stride = 2;
				var fGeometry;
				try {
					fGeometry = format.readGeometry(wktStr);
				}
				catch (ex) {
					//для случая с видеозаписями, приходит 3 координаты
					stride = 3;
					format = new map.format.WKT({dimension: stride});
					fGeometry = format.readGeometry(wktStr);
				}
				if (fGeometry.getType() === 'Point' || fGeometry.getType() === 'LineString' || fGeometry.getType() === 'Polygon')
					GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
			}
			var featureProjLayer = that.featureProjLayer;
			//выбираем все features, в которых возможно хранить наш тип геометрии
			var features = featureProjLayer.getSource().getSource().getFeatures();
			var j;
			for (j in features) {
				var index = -1;
				var labels = features[j].get('labelsObj');
				var aa = 0;
				for (; aa < labels.length; aa++) {
					if (labels[aa].id == id) {
						index = aa;
						break;
					}
				}
				if (fGeometry.getType() == ol.geom.GeometryType.LINE_STRING) {
					//заменяем строку на нужную
					if (index != -1) {
						var lineStrings = features[j].getGeometry().getLineStrings();
						lineStrings[index] = fGeometry;
						features[j].get('pointsObj')[id] = fGeometry;
						features[j].get('pointsObjAll')[id] = fGeometry;
						features[j].getGeometry().setLineStrings(lineStrings);
						break;
					}
				}
			}
			BlockingUtil.readyGeo();
		}
		catch (ex) {
			BlockingUtil.readyGeo();
			App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
				filename: gis_filename_1,
				functionname: 'gis_filename_1_1'
			});
		}
	}

	function getLayerGeoFault(resultXml) {
		BlockingUtil.readyGeo();
		App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
			filename: gis_filename_1,
			functionname: 'gis_filename_1_2'
		});
	}

	App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams(id, that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
};





/**
 * Чистим на карте подписи у фичи
 * @param feature
 */
map.layer.VectorLayer.prototype.clearFeatureLabels_ = function (feature) {
	var labelType = feature.get('labelType');
	//перед обработкой чистим массив с подписями и временный массив
	_TEMP_LAYERS_LABELS[labelType] = [];
	if (_LABELS.length > 0) {
		var i = _LABELS.length - 1;
		for (i; i >= 0; i--) {
			if (_LABELS[i].unique.indexOf(labelType + '_') != -1)
				_LABELS.splice(i, 1);
		}
	}
	if (_pointLabels.length > 0) {
		var i = _pointLabels.length - 1;
		for (i; i >= 0; i--) {
			if (_pointLabels[i].unique.indexOf(labelType + '_') != -1)
				_pointLabels.splice(i, 1);
		}
	}
	GLOBAL_REDRAW[labelType] = true;
	GLOBAL_REDRAW_COUNTER[labelType] = 0;
};

/**
 * Функция удаления геометрии объекта из карты по его Id
 */
map.layer.VectorLayer.prototype.deleteObjectById = function (id) {
	if (!goog.isDef(id) || id == '')
		return false;
	//выбираем все features, в которых возможно хранить наш тип геометрии
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	var index = -1;
	var aa = 0;
	for (j; j < features.length; j++) {
		index = -1;
		var labels = features[j].get('labelsObj');
		var labelsAll = features[j].get('labelsObjAll');
		var pointsAll = features[j].get('pointsObjAll');
		var points = features[j].get('pointsObj');
		aa = 0;
		for (aa; aa < labels.length; aa++) {
			if (labels[aa].id == id) {
				try {
					index = aa;
					labels.splice(index, 1);
					if(labelsAll)
						labelsAll.splice(index, 1);
					if(pointsAll)
						delete pointsAll[id];
					if(points)
						delete points[id];
					GeoUtil.removeObjectFromGeometry(features[j], index);
					//если удалили последний объект в фиче, кто он ребудет рендериться, соответственно, не будет чистится _LABELS
					// поэтому чистим _LABELS
					if (labels.length == 0) {
						this.clearFeatureLabels_(features[j]);
					}
				}
				catch (e) {
					
				}
				return true;
			}
		}
	}
	return false;
};

/**
 * Функция удаления геометрии объекта из карты по массиву идентификаторов
 */
map.layer.VectorLayer.prototype.deleteObjectsByIds = function (ids) {
	var that = this;
	if (!goog.isDef(ids))
		return false;
	if(ids.length === 0){// чистим весь слой
		that.refreshLayerData();
		return true;
	}
	ids.forEach(function(id){
		that.deleteObjectById(id)
	});
	WidgetMap.map.renderSync();
	return true;
};




/**
 * Получить рамку для текущего слоя и переместить карту
 */
map.layer.VectorLayer.prototype.getQueryGeoMBR = function (resultHandler) {
	var that = this;
	function getReqLPUParams(request, lpuIds) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		return {
			descrId: request,
			descrType: 'select',
			data:'<root USER_ID="'+userId.xmlEscape()+
				'" USER_LOGIN="'+userLogin.xmlEscape()+
				'" PODS_USER="'+userLogin.xmlEscape()+
				'" '+ topFiltersStr+''+
				'>'+
				'<data LPU_IDS="'+lpuIds+'"/></root>'
		};
	}
	function faultLPU(resultXml) {
		if (goog.isDef(resultHandler))
			resultHandler.apply(this);
	}
	function resultLPU(resultXml) {
		try { // Иногда ответ в формате XML, а иногда в виде просто строки
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') {
				if (goog.isDef(resultHandler))
					resultHandler.apply(this);
				return;
			}
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			var dd = 0;
			for (dd; dd < datas.length; dd++) {
				var maxLat = parseFloat(datas[dd].getAttribute('YMAX'));
				var minLat = parseFloat(datas[dd].getAttribute('YMIN'));
				var minLon = parseFloat(datas[dd].getAttribute('XMIN'));
				var maxLon = parseFloat(datas[dd].getAttribute('XMAX'));
				var pnt1 = new proj4.toPoint([minLon, minLat]);
				var pnt2 = new proj4.toPoint([maxLon, maxLat]);
				var source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
				var dest_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
				if (App.projection === GeoUtil.PROJS.Pulkovo42) {//преобразуем в wgs84
					var p42WgsPnt = GeoUtil.P42WGS(minLat, minLon);
					pnt1 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
					p42WgsPnt = GeoUtil.P42WGS(maxLat, maxLon);
					pnt2 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
				}
				proj4.transform(source_, dest_, pnt1);
				proj4.transform(source_, dest_, pnt2);
				if(isNaN(pnt1.x) || isNaN(pnt1.y) || isNaN(pnt2.x) || isNaN(pnt2.y))
					continue;
				var extent = [pnt1.x, pnt1.y, pnt2.x, pnt2.y]; // of ol.Extent `[minx, miny, maxx, maxy]`.
				if(extent.length == 0)
					extent= [pnt1.x, pnt1.y, pnt2.x, pnt2.y];
				else
					extent = ol.extent.extend(extent,[pnt1.x, pnt1.y, pnt2.x, pnt2.y]);
			}
			if(WidgetMap.canFirstTimeCentering)
				WidgetMap.centerOnMap(extent);
			if (goog.isDef(resultHandler))
				resultHandler.apply(this);
		} catch (ex) {
			if (goog.isDef(resultHandler))
				resultHandler.apply(this);
		}
	}


	if(goog.isDef(WidgetMap.currentTopFilter) &&  WidgetMap.currentTopFilter.length > 0){
		var k=0;
		for(;k<WidgetMap.currentTopFilter.length;k++){
			if(goog.isDef(WidgetMap.currentTopFilter[k].name) && WidgetMap.currentTopFilter[k].name == 'LPU_ACCESS_FILTER'){
				var lpus = WidgetMap.currentTopFilter[k].value;
				App.serverQueryXMLNodeWithTries(Services.processQueryNode, getReqLPUParams('GAZPROM_ADM_SEM.xml#GET_LPU_BOUNDS', lpus), resultLPU, faultLPU,4);
				return;
			}
		}
	}
};

map.layer.VectorLayer.prototype.clear = function () {
	if (goog.isDefAndNotNull(this.featureProjLayer.getSource)) {
		this.featureProjLayer.getSource().getSource().clear();
		//и удаляем из всех мест сохраненные данные об этом слое
		this.semanticUniqData = {};
		this.semanticShiftData = {};
		//var globalPointsLabels_ = {};
		//var globalPolygonsLabels_ = {};
		//var globalLinesLabels_ = {};
		//var globalLinesGEOs_ = {};
		//var globalPointsGEOs_ = {};
		//var globalPolygonsGEOs_ = {};
		var obj;
		for (obj in globalPointsLabels_) {
			if (obj.indexOf(this.name + '/') != -1) {
				delete globalPointsLabels_[obj];
				delete globalPointsGEOs_[obj];
			}
			else if (obj == this.name) {
				delete globalPointsLabels_[obj];
				delete globalPointsGEOs_[obj];
			}
		}
		for (obj in globalLinesLabels_) {
			if (obj.indexOf(this.name + '/') != -1) {
				delete globalLinesLabels_[obj];
				delete globalLinesGEOs_[obj];
			}
			else if (obj == this.name) {
				delete globalLinesLabels_[obj];
				delete globalLinesGEOs_[obj];
			}
		}
		for (obj in globalPolygonsLabels_) {
			if (obj.indexOf(this.name + '/') != -1) {
				delete globalPolygonsLabels_[obj];
				delete globalPolygonsGEOs_[obj];
			}
			else if (obj == this.name) {
				delete globalPolygonsLabels_[obj];
				delete globalPolygonsGEOs_[obj];
			}
		}
	}
};

/**
 * Обновление подписи в слое
 * @param semId
 * @param dataObject
 */
map.layer.VectorLayer.prototype.updateLabel = function (semId, label) {
	var found = false;//если объект не найден в этом слое
	if (goog.isDef(this.featureProjLayer)) {
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		var i = 0, j = 0;
		for (j; j < features.length; j++) {
			if(found) break;
			var labelsObj = features[j].get('labelsObj');
			for (i = 0; i < labelsObj.length; i++) {
				if (labelsObj[i].id == semId) {
					var geoType = features[j].get('pointsObjAll')[semId].getType();
					var labelType = features[j].get('labelType');
					switch (geoType) {
						case 'Point':
							globalPointsLabels_[labelType][i].label = label;
							break;
						case 'LineString':
							globalLinesLabels_[labelType][i].label = label;
							break;
						case 'Polygon':
							globalPolygonsLabels_[labelType][i].label = label;
							break;
					}
					found = true;
					labelsObj[i].label = label;
					this.featureProjLayer.getSource().changed();
					break;
				}
			}
		}
	}
	return found;
};

map.layer.VectorLayer.prototype.getLayerGeoFields = function(callback){
	var that = this;
	that.layout = ol.geom.GeometryLayout.XY;
	function getLayerGeoReqParams(source) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		return {
			descrId: 'SYS_SEM.xml#GET_DATA_XML',
			descrType: 'select',
			data:  '<root USER_ID="'+userId.xmlEscape()+
				'" USER_LOGIN="'+userLogin.xmlEscape()+
				'" PODS_USER="'+userLogin.xmlEscape()+
				'" >'+
				'<data file="'+source.split("#")[0]+'" dataId="'+source.split("#")[1]+'" />'+
				'</root>'
		};
	}
	function onProvDataResult(resultXml) {
		try {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er === '') {
				var select = resultXml.find("select");
				if(select.length>0 && select[0].getElementsByTagName("geoQuery").length>0){
					var geoField = select[0].getElementsByTagName("geoQuery")[0].getAttribute("geoField");
					if(geoField && geoField.split(',').length > 2)
						that.layout = ol.geom.GeometryLayout.XYZ;
				}
			}
		}
		catch(e){
		}
		if(callback) callback();
	}
	function onProvDataFault() {
		if(callback) callback();
	}
	App.serverQueryNodeWithTries(Services.processQueryNodeXml, getLayerGeoReqParams(this.dataProvider.spatial ), onProvDataResult, onProvDataFault,4);
}

/**
 * Добавление геометрии в слой
 * @param baseFeature фича с геометрией
 * @param semId id объекта
 * @param dataObject
 */
map.layer.VectorLayer.prototype.addGeometry = function (baseFeature, semId, dataObject, callback) {
	var that  = this;
	//проверка на размерность слоя XY или XYZ
	if(this.layout === undefined){
		//запрашиваем из select соответствующего гео файла атрибут geoField, после этого вызываем опять addGeometry с уже установленной геометрией
		this.getLayerGeoFields(function(){
			that.addGeometry(baseFeature, semId, dataObject);
			if(callback) callback();
		})
		return false;
	}

	if (goog.isDef(this.featureProjLayer)) {
		//парсим data, забираем из него label и type_cl из атрибутов
		//сохранить координаты и подпись в фичу для этого слоя
		//Обрабатываем classField слоя, если в объекте есть такое свойство, сохраняем его в тип
		var typeStr = '';
		var label = null;
		if (goog.isDef(dataObject) && goog.isDef(dataObject.savingData)) {
			var tableName = this.name.substring(this.name.indexOf("_") + 1);
			var xmlData = $.parseXML(dataObject.savingData);
			var data = xmlData.getElementsByTagName("data");
			if (data.length >= 0) {
				if (!goog.isNull(data[0].getAttribute(tableName + '_' + this.classField)) && data[0].getAttribute(tableName + '_' + this.classField) != 'NULL')
					typeStr = '/' + data[0].getAttribute(tableName + '_' + this.classField);
				if (!goog.isNull(data[0].getAttribute(this.classField)) && data[0].getAttribute(this.classField) != 'NULL')
					typeStr = '/' + data[0].getAttribute(this.classField);
				if (!goog.isNull(data[0].getAttribute(tableName + '_' + this.labelField)) && data[0].getAttribute(tableName + '_' + this.labelField) != 'NULL')
					label = data[0].getAttribute(tableName + '_' + this.labelField);
				if (!goog.isNull(data[0].getAttribute(this.labelField)) && data[0].getAttribute(this.labelField) != 'NULL')
					label = data[0].getAttribute(this.labelField); //TODO  посмотреть откуда во флеше для линий электропередач берется подпись
				if (!goog.isNull(data[0].getAttribute('LABEL')))
					label = data[0].getAttribute('LABEL');
				if (!goog.isNull(data[0].getAttribute('TYPE')))
					typeStr = data[0].getAttribute('TYPE');
			}
		}
		//если косметический слой, то у него нет типа, поэтому выставляем ему фейковый, чтобы при отрисовке не затирались тексты у линий.
		//сначала рисуются линии, потом точки и затирается _LABELS по типу(тип пустой)
		if(that.uniqueLayerName === 'COSMETIC_OBJECT' && typeStr === ''){
			typeStr = '/'+baseFeature.getGeometry().getType();
		}
		if(dataObject && dataObject.label && !label)//случай отката косметики
			label = dataObject.label;
		var found = false;
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		var fGeometry = baseFeature.getGeometry();


		//проводим конвертацию layout геометрии к layout слоя
		if(fGeometry && fGeometry.layout !== this.layout){
			fGeometry = this.transformGeometryLayout(fGeometry);
		}

		if(this.name === "PODS_ROUTE" && fGeometry.stride === 2){
			var lineString = new ol.geom.LineString(null);
			var flatRouteCoords = [];
			var routeCoords = fGeometry.getCoordinates();
			for(var rk = 0; rk < routeCoords.length; rk ++){
				flatRouteCoords = flatRouteCoords.concat([routeCoords[rk][0], routeCoords[rk][1], 0]);
			}
			lineString.setFlatCoordinates( ol.geom.GeometryLayout.XYZ, flatRouteCoords);
			fGeometry = lineString;
		}
		//если слой косметики, то все размерности приводим к двумерным XY
		if(this.name === 'COSMETIC_OBJECT' && fGeometry.stride === 3){
			//TODO пока делаем для линий
			if(fGeometry.getType() === ol.geom.GeometryType.LINE_STRING){
				var lineString = new ol.geom.LineString(null);
				var flatRouteCoords = [];
				var routeCoords = fGeometry.getCoordinates();
				for(var rk = 0; rk < routeCoords.length; rk ++){
					flatRouteCoords = flatRouteCoords.concat([routeCoords[rk][0], routeCoords[rk][1]]);
				}
				lineString.setFlatCoordinates( ol.geom.GeometryLayout.XY, flatRouteCoords);
				fGeometry = lineString;
			}
		}

		var j = 0, feature;
		for (j; j < features.length; j++) {
			feature = features[j];
			if (feature.get('labelType') === this.name + typeStr) {
				if (feature.getGeometry().getType().indexOf(fGeometry.getType()) != -1) {
					/*var stride = feature.getGeometry().stride;
					var baseFeatureStride = fGeometry.stride;
					if(stride !== baseFeatureStride) {//случай, когда ранее вставляли в косметику трубу XYZ, а после этого рисовали линию XY
						typeStr += '_' + fGeometry.layout;// фиктивно подправляем тип отрисовки для случая косметики, иначе общая ссылка на labelsObj у каждой фичи слоя
						break;
					}*/
					switch (fGeometry.getType()) {
						case ol.geom.GeometryType.LINE_STRING:
							globalLinesLabels_[this.name + typeStr].push({
								label: label,
								id: semId,
								geo: fGeometry
							});
							if (!goog.isDef(feature.get('pointsObj')))
								feature.set('pointsObj', {});
							if (!goog.isDef(feature.get('pointsObjAll')))
								feature.set('pointsObjAll', {});
							feature.get('pointsObj')[semId] = fGeometry;
							feature.get('pointsObjAll')[semId] = fGeometry;
							feature.getGeometry().appendLineString(fGeometry);
							found = true;
							break;
						case ol.geom.GeometryType.POINT:
							globalPointsLabels_[this.name + typeStr].push({
								label: label,
								id: semId,
								geo: fGeometry
							});
							feature.getGeometry().appendPoint(fGeometry);
							if (!goog.isDef(feature.get('pointsObj')))
								feature.set('pointsObj', {});
							if (!goog.isDef(feature.get('pointsObjAll')))
								feature.set('pointsObjAll', {});
							feature.get('pointsObj')[semId] = fGeometry;
							feature.get('pointsObjAll')[semId] = fGeometry;
							found = true;
							break;
						case ol.geom.GeometryType.POLYGON:
							globalPolygonsLabels_[this.name + typeStr].push({
								label: label,
								id: semId,
								geo: fGeometry
							});
							feature.getGeometry().appendPolygon(fGeometry);
							if (!goog.isDef(feature.get('pointsObj')))
								feature.set('pointsObj', {});
							if (!goog.isDef(feature.get('pointsObjAll')))
								feature.set('pointsObjAll', {});
							feature.get('pointsObj')[semId] = fGeometry;
							feature.get('pointsObjAll')[semId] = fGeometry;
							found = true;
							break;
					}
				}
				if (found == true)
					break;
			}
		}
		//если не нашли по layerName+typeStr - ищем по layerName
		if (!found) {
			j = 0;
			for (j; j < features.length; j++) {
				feature = features[j];
				//если не нашли по labelType, то ищем по обычному названию слоя и потом заносим объекты в массивы с labelType у выбранной фичи
				if (feature.get('labelType') == this.name) {
					if (feature.getGeometry().getType().indexOf(fGeometry.getType()) != -1) {
						/*var stride = feature.getGeometry().stride;
						var baseFeatureStride = fGeometry.stride;
						if(stride !== baseFeatureStride) {//случай, когда ранее вставляли в косметику трубу XYZ, а после этого рисовали линию XY
							typeStr += '_' + fGeometry.layout;// фиктивно подправляем тип отрисовки для случая косметики, иначе общая ссылка на labelsObj у каждой фичи слоя
							break;
						}*/
						switch (fGeometry.getType()) {
							case ol.geom.GeometryType.LINE_STRING:
								globalLinesLabels_[feature.get('labelType')].push({label: label, id: semId});
								feature.getGeometry().appendLineString(fGeometry);
								if (!goog.isDef(feature.get('pointsObj')))
									feature.set('pointsObj', {});
								if (!goog.isDef(feature.get('pointsObjAll')))
									feature.set('pointsObjAll', {});
								feature.get('pointsObj')[semId] = fGeometry;
								feature.get('pointsObjAll')[semId] = fGeometry;
								found = true;
								break;
							case ol.geom.GeometryType.POINT:
								globalPointsLabels_[feature.get('labelType')].push({label: label, id: semId});
								feature.getGeometry().appendPoint(fGeometry);
								if (!goog.isDef(feature.get('pointsObj')))
									feature.set('pointsObj', {});
								if (!goog.isDef(feature.get('pointsObjAll')))
									feature.set('pointsObjAll', {});
								feature.get('pointsObj')[semId] = fGeometry;
								feature.get('pointsObjAll')[semId] = fGeometry;
								found = true;
								break;
							case ol.geom.GeometryType.POLYGON:
								globalPolygonsLabels_[feature.get('labelType')].push({label: label, id: semId});
								feature.getGeometry().appendPolygon(fGeometry);
								if (!goog.isDef(feature.get('pointsObj')))
									feature.set('pointsObj', {});
								if (!goog.isDef(feature.get('pointsObjAll')))
									feature.set('pointsObjAll', {});
								feature.get('pointsObj')[semId] = fGeometry;
								feature.get('pointsObjAll')[semId] = fGeometry;
								found = true;
								break;
						}
					}
				}
				if (found) break;
			}
		}
		//
		if (!found) {
			//если не добавили(нет объектов или тип не подошел по найденному, например, для блок-боксов была точечная и тип полигона совпадает)
			//значит создаем новую фичу, то создаем мультифичу и туда добавляем
			if (true || features.length == 0) {
				var finalFeature = undefined;
				var stName = this.name + typeStr;
				if (fGeometry.getType() === 'Point' && this.drawTypes.indexOf('point') !== -1) {
					if (!goog.isDef(globalPointsLabels_[stName]))
						globalPointsLabels_[stName] = [];
					globalPointsLabels_[stName].push({label: label, id: semId, geo: fGeometry});
					if (!goog.isDef(globalPointsGEOs_[stName]))
						globalPointsGEOs_[stName] = {};
					globalPointsGEOs_[stName][semId] = fGeometry;
					this.hasData = true;
					var geometry = new ol.geom.MultiPoint(null);
					geometry.appendPoint(fGeometry);
					var newPointFeature = new ol.Feature(geometry);
					newPointFeature.set('layerId', that.name);
					newPointFeature.set('spacing', that.spacing);
					newPointFeature.set('zIndex', that.zIndex);
					newPointFeature.set('labelType', stName);
					newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
					newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
					newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);
					newPointFeature.set('type', stName.replace('/', '_'));
					newPointFeature.setId('DEFAULT_SELECTED_' + map.controls.DrawGeometryControl.generateGeoGUID());
					newPointFeature.setStyle(function (resolution) {
						var mapZoom = WidgetMap.map.getView().getZoom();
						var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'Point');
						var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), 'Point');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
									that.setTextStyle(s.style, textstyle);
								}
								else
									that.setTextStyle(s.style, null);

							}
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'Point');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), 'Point');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
									that.setTextStyle(s.style, textstyle);
								}
								else
									that.setTextStyle(s.style, null);
							}
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'Point');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', 'Point');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax) {
									that.setTextStyle(s.style, textstyle);
								}
								else
									that.setTextStyle(s.style, null);
							}
							return [s.style];
						}
						return null;
					});
					finalFeature = newPointFeature;
				}
				if (fGeometry.getType() === 'LineString' && that.drawTypes.indexOf('line') !== -1) {
					if (!goog.isDef(globalLinesLabels_[stName]))
						globalLinesLabels_[stName] = [];
					if (!goog.isDef(globalLinesGEOs_[stName]))
						globalLinesGEOs_[stName] = {};
					globalLinesLabels_[stName].push({label: label, id: semId, geo: fGeometry});
					globalLinesGEOs_[stName][semId] = fGeometry;
					that.hasData = true;
					var geometry = new ol.geom.MultiLineString(null);
					geometry.setLineStrings([fGeometry]);
					var newLineFeature = new ol.Feature(geometry);
					newLineFeature.set('layerId', that.name);
					newLineFeature.set('spacing', that.spacing);
					newLineFeature.set('labelType', stName);
					newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
					newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
					newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);
					newLineFeature.set('type', stName.replace('/', '_'));
					newLineFeature.setId('DEFAULT_SELECTED_' + map.controls.DrawGeometryControl.generateGeoGUID());
					newLineFeature.setStyle(function (resolution) {
						var mapZoom = WidgetMap.map.getView().getZoom();
						var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'LineString');
						var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), 'LineString');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							if (goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'LineString');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), 'LineString');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							if (goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'LineString');
						if (!goog.isNull(s && !goog.isNull(s.style))) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', 'LineString');
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);

							}
							if (goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						return null;
					});
					finalFeature = newLineFeature;
				}
				if (fGeometry.getType() === 'Polygon' && that.drawTypes.indexOf('polygon') !== -1) {
					if (!goog.isDef(globalPolygonsLabels_[stName]))
						globalPolygonsLabels_[stName] = [];
					if (!goog.isDef(globalPolygonsGEOs_[stName]))
						globalPolygonsGEOs_[stName] = {};
					globalPolygonsLabels_[stName].push({label: label, id: semId, geo: fGeometry});
					globalPolygonsGEOs_[stName][semId] = fGeometry;
					that.hasData = true;
					var geometry = new ol.geom.MultiPolygon(null);
					geometry.appendPolygon(fGeometry);
					var newPolygonFeature = new ol.Feature(geometry);
					newPolygonFeature.set('layerId', that.name);
					newPolygonFeature.set('spacing', that.spacing);
					newPolygonFeature.set('labelType', stName);
					newPolygonFeature.set('type', stName.replace('/', '_'));
					newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
					newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);
					newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);
					newPolygonFeature.set('type', stName.replace('/', '_'));
					newPolygonFeature.setId('DEFAULT_SELECTED_' + map.controls.DrawGeometryControl.generateGeoGUID());
					newPolygonFeature.setStyle(function (resolution) {
						var mapZoom = WidgetMap.map.getView().getZoom();
						var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'Polygon');
						var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyle(this.get('type'));
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if (goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'Polygon');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if (goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'Polygon');
						if (!goog.isNull(s) && !goog.isNull(s.style)) {
							if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
								return null;
							if (allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
								if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if (goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						return null;
					});
					finalFeature = newPolygonFeature;
				}
				if (finalFeature) {
					that.dataReady_ = true;
					that.featureProjLayer.getSource().getSource().addFeature(finalFeature);
				}
			}
		}
		else {
			//если нашли, то центрируемся к нему
			/*if(goog.isDef(baseFeature) && goog.isDef(baseFeature.getGeometry)){
			 var extent = baseFeature.getGeometry().getExtent();
			 WidgetMap.centerOnMap(extent);
			 }*/
		}
	}
	return true;
};


/**
 * Обновление геометрии в слое
 * @param baseFeature фича с геометрией
 * @param semId id объекта
 */
map.layer.VectorLayer.prototype.updateGeometry = function (baseFeature, semId, force) {
	if (goog.isDef(this.featureProjLayer)) {
		var newExtent = undefined;
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		var j;
		for (j in features) {
			if (goog.isDef(newExtent))
				break;
			if (features[j].getGeometry().getType().indexOf(baseFeature.getGeometry().getType()) != -1) {
				var index = -1;
				var labels = features[j].get('labelsObj');
				var aa = 0;
				for (aa; aa < labels.length; aa++) {
					if (labels[aa].id == semId) {
						index = aa;
						break;
					}
				}
				switch (baseFeature.getGeometry().getType()) {
					case ol.geom.GeometryType.LINE_STRING:
						//заменяем строку на нужную
						if (index != -1) {
							if (this.name != 'PODS_ROUTE' || force === true) {
								var lineStrings = features[j].getGeometry().getLineStrings();
								if(baseFeature.getGeometry().flatCoordinates.length === 0) {
									this.deleteObjectById(semId);
									return;
									/*lineStrings.splice(index, 1);
									delete features[j].get('pointsObj')[semId];
									delete features[j].get('pointsObjAll')[semId];*/
								}
								else {
									lineStrings[index] = baseFeature.getGeometry();
									newExtent = baseFeature.getGeometry().getExtent();
									features[j].get('pointsObj')[semId] = baseFeature.getGeometry();
									features[j].get('pointsObjAll')[semId] = baseFeature.getGeometry();
								}
								features[j].getGeometry().setLineStrings(lineStrings);

							}
						}
						break;
					case ol.geom.GeometryType.POINT:
						//заменяем точку на нужную
						if (index !== -1) {
							var points = features[j].getGeometry().getCoordinates();
							if(baseFeature.getGeometry().flatCoordinates.length === 0) {
								this.deleteObjectById(semId);
								return;
								/*points.splice(index, 1);
								delete features[j].get('pointsObj')[semId];
								delete features[j].get('pointsObjAll')[semId];*/
							}
							else {
								points[index] = baseFeature.getGeometry().getCoordinates();
								newExtent = baseFeature.getGeometry().getExtent();
								features[j].get('pointsObj')[semId] = baseFeature.getGeometry();
								features[j].get('pointsObjAll')[semId] = baseFeature.getGeometry();
							}
							features[j].getGeometry().setCoordinates(points, ol.geom.GeometryLayout.XY);
						}
						break;
					case ol.geom.GeometryType.POLYGON:
						//заменяем полигон
						if (index != -1) {
							var polygons = features[j].getGeometry().getPolygons();
							if(baseFeature.getGeometry().flatCoordinates.length === 0) {
								this.deleteObjectById(semId);
								return;
								/*polygons.splice(index, 1);
								delete features[j].get('pointsObj')[semId];
								delete features[j].get('pointsObjAll')[semId];*/
							}
							else {
								polygons[index] = baseFeature.getGeometry();
								newExtent = baseFeature.getGeometry().getExtent();
								features[j].get('pointsObj')[semId] = baseFeature.getGeometry();
								features[j].get('pointsObjAll')[semId] = baseFeature.getGeometry();
							}
							features[j].getGeometry().setPolygons(polygons);
						}
						break;
				}
			}
		}
	}
};

/**
 * Показываем все объекты. Перед каждой фильтрацией
 */
map.layer.VectorLayer.prototype.showAllObjects_old = function () {
	//return;
	if(!this.featureProjLayer)
		return;
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var i = 0, j = 0;
	var findedPointFeatures = {};//найденные фичи
	var findedLineFeatures = {};//найденные фичи
	var findedPolygonFeatures = {};//найденные фичи
	var features4Deletion = [];//фичи на удаление
	try{
		for (i; i < features.length; i++) {
			//ищем только в multiPoint
			var oId;
			var feature = features[i];
			var featureLabelType = feature.get('labelType');
			var labelsObjAll = feature.get('labelsObjAll');
			var pointsObjAll = feature.get('pointsObjAll');
			if(feature.get('labelsObjAllBackup')){
				labelsObjAll = feature.get('labelsObjAllBackup');
				pointsObjAll = feature.get('pointsObjAllBackup');
			}
			if (goog.isDef(labelsObjAll)){
				for(j = 0; j< labelsObjAll.length; j++){
					oId = labelsObjAll[j].id;
					if (goog.isDef(pointsObjAll[oId])) {
						//добавляем фичу найденную
						var type = pointsObjAll[oId].getType();
						if (type == ol.geom.GeometryType.POINT) {
							if (!goog.isDef(findedPointFeatures[featureLabelType])) {
								findedPointFeatures[featureLabelType] = this.cloneFeature(feature, false);
								findedPointFeatures[featureLabelType].set('pointsObj', {});
								findedPointFeatures[featureLabelType].set('labelsObj', []);
								findedPointFeatures[featureLabelType].setId(App.generateUUID());
								features4Deletion.push(feature);
							}
							//установил новый объект с геометрией
							findedPointFeatures[featureLabelType].get('pointsObj')[oId] = pointsObjAll[oId];
							findedPointFeatures[featureLabelType].get('labelsObj').push(labelsObjAll[j])
						}
						else if (type == ol.geom.GeometryType.LINE_STRING) {
							if (!goog.isDef(findedLineFeatures[featureLabelType])) {
								findedLineFeatures[featureLabelType] = this.cloneFeature(feature, false);
								findedLineFeatures[featureLabelType].set('pointsObj', {});
								findedLineFeatures[featureLabelType].set('labelsObj', []);
								findedLineFeatures[featureLabelType].setId(App.generateUUID());
								features4Deletion.push(feature);
							}
							//установил новый объект с геометрией
							findedLineFeatures[featureLabelType].get('pointsObj')[oId] = pointsObjAll[oId];
							findedLineFeatures[featureLabelType].get('labelsObj').push(labelsObjAll[j]);
						}
						else if (type == ol.geom.GeometryType.POLYGON) {
							if (!goog.isDef(findedPolygonFeatures[featureLabelType])) {
								findedPolygonFeatures[featureLabelType] = this.cloneFeature(feature, false);
								findedPolygonFeatures[featureLabelType].set('pointsObj', {});
								findedPolygonFeatures[featureLabelType].set('labelsObj', []);
								findedPolygonFeatures[featureLabelType].setId(App.generateUUID());
								features4Deletion.push(feature);
							}
							//установил новый объект с геометрией
							findedPolygonFeatures[featureLabelType].get('pointsObj')[oId] = pointsObjAll[oId];
							findedPolygonFeatures[featureLabelType].get('labelsObj').push(labelsObjAll[j]);
						}
						this.clearFeatureLabels_(features[i]);
					}
					//если не нашли, то делаем фичу без объектов
					else {
						var lbObj = feature.get('labelsObjAll');
						if (goog.isDef(lbObj) && lbObj.length > 0 && goog.isDef(lbObj[0].geo)) {
							var type = (lbObj[0].geo.getType)?lbObj[0].geo.getType():lbObj[0].geo.getGeometry().getType();
							if (type == ol.geom.GeometryType.POINT) {
								if (!goog.isDef(findedPointFeatures[featureLabelType])) {
									findedPointFeatures[featureLabelType] = this.cloneFeature(feature, false);
									findedPointFeatures[featureLabelType].set('pointsObj', {});
									findedPointFeatures[featureLabelType].set('labelsObj', []);
									features4Deletion.push(features[i]);
								}
							}
							else if (type == ol.geom.GeometryType.LINE_STRING) {
								if (!goog.isDef(findedLineFeatures[featureLabelType])) {
									findedLineFeatures[featureLabelType] = this.cloneFeature(feature, false);
									findedLineFeatures[featureLabelType].set('pointsObj', {});
									findedLineFeatures[featureLabelType].set('labelsObj', []);
									features4Deletion.push(feature);
								}
							}
							else if (type == ol.geom.GeometryType.POLYGON) {
								if (!goog.isDef(findedPolygonFeatures[featureLabelType])) {
									findedPolygonFeatures[featureLabelType] = this.cloneFeature(feature, false);
									findedPolygonFeatures[featureLabelType].set('pointsObj', {});
									findedPolygonFeatures[featureLabelType].set('labelsObj', []);
									features4Deletion.push(feature);
								}
							}
							this.clearFeatureLabels_(feature);
						}
					}
				}
			}
		}
	}
	catch(ex){
		//console.log('1')
	}


	//нашли и сделали все фичи для объектов, добавляем новую копию
	var obj;
	var centeringExtent = ol.extent.createEmpty();
	//проходимся по точечным фичам
	try{
		for (obj in findedPointFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedPointFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				geos.push(lObj[k].geo.flatCoordinates);
			}

			var geometry = new ol.geom.MultiPoint(null);
			geometry.setCoordinates(geos, ol.geom.GeometryLayout.XY);
			findedPointFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedPointFeatures[obj]);
		}

		for (obj in findedLineFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedLineFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				geos.push(lObj[k].geo);
			}
			var geometry = new ol.geom.MultiLineString(null);
			geometry.setLineStrings(geos);
			findedLineFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedLineFeatures[obj]);
		}

		for (obj in findedPolygonFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedPolygonFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				var pp = new ol.geom.Polygon(null);
				var linearRing = new ol.geom.LinearRing(null);
				linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, lObj[k].geo.flatCoordinates);
				pp.appendLinearRing(linearRing);
				geos.push(pp);
			}
			var geometry = new ol.geom.MultiPolygon(null);
			geometry.setPolygons(geos);
			findedPolygonFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedPolygonFeatures[obj]);
		}

		var i = 0;
		for (i; i < features4Deletion.length; i++)
			this.featureProjLayer.getSource().getSource().removeFeature(features4Deletion[i]);
		this.featureProjLayer.changed();
	}
	catch(ex){}

}

/**
 * Показываем все объекты. Перед каждой фильтрацией
 */
map.layer.VectorLayer.prototype.showAllObjects = function () {
	if(!this.featureProjLayer)
		return;
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var i = 0, j = 0, findedFeature;
	var findedPointFeatures = {};//найденные фичи
	var findedLineFeatures = {};//найденные фичи
	var findedPolygonFeatures = {};//найденные фичи
	var features4Deletion = features;//фичи на удаление
	try{
		//первый проход чистка фич
		for (i; i < features.length; i++) {
			var feature = features[i];
			this.clearFeatureLabels_(feature);
			var featureLabelType = feature.get('labelType');
			var lbObj = feature.get('labelsObjAll');
			var labelsObjAll = feature.get('labelsObjAll');
			var pointsObjAll = feature.get('pointsObjAll');
			if(feature.get('labelsObjAllBackup')){
				labelsObjAll = feature.get('labelsObjAllBackup');
				pointsObjAll = feature.get('pointsObjAllBackup');
				lbObj = labelsObjAll;
			}
			if (lbObj && lbObj.length > 0 && lbObj[0].geo) {
				var type = (lbObj[0].geo.getType) ? lbObj[0].geo.getType() : lbObj[0].geo.getGeometry().getType();
				if (type === ol.geom.GeometryType.POINT) {
					findedPointFeatures[featureLabelType] = this.cloneFeature(feature, false);
					globalPointsLabels_[featureLabelType] = labelsObjAll;
					findedFeature = findedPointFeatures[featureLabelType];
					findedFeature.set('labelsObj', goog.array.clone(globalPointsLabels_[featureLabelType]));
					findedFeature.set('labelsObjAll', globalPointsLabels_[featureLabelType]);
					findedFeature.set('pointsObj',  pointsObjAll);// goog.object.clone(feature.get('labelsObjAll'))
					findedFeature.set('pointsObjAll', pointsObjAll);
				}
				else if (type === ol.geom.GeometryType.LINE_STRING) {
					findedLineFeatures[featureLabelType] = this.cloneFeature(feature, false);
					globalLinesLabels_[featureLabelType] = labelsObjAll;
					findedFeature = findedLineFeatures[featureLabelType];
					findedFeature.set('labelsObj', goog.array.clone(globalLinesLabels_[featureLabelType]));
					findedFeature.set('labelsObjAll', globalLinesLabels_[featureLabelType]);
					findedFeature.set('pointsObj',  pointsObjAll);// goog.object.clone(feature.get('labelsObjAll'))
					findedFeature.set('pointsObjAll', pointsObjAll);
				}
				else if (type === ol.geom.GeometryType.POLYGON) {
					findedPolygonFeatures[featureLabelType] = this.cloneFeature(feature, false);
					globalPolygonsLabels_[featureLabelType] = labelsObjAll;
					findedFeature = findedPolygonFeatures[featureLabelType];
					findedFeature.set('labelsObj', goog.array.clone(globalPolygonsLabels_[featureLabelType]));
					findedFeature.set('labelsObjAll', globalPolygonsLabels_[featureLabelType]);
					findedFeature.set('pointsObj',  pointsObjAll);// goog.object.clone(feature.get('labelsObjAll'))
					findedFeature.set('pointsObjAll', pointsObjAll);

				}
				if(findedFeature){
					findedFeature.set('pointsObjAllBackup', undefined);
					findedFeature.set('labelsObjAllBackup', undefined);
					findedFeature.setId(App.generateUUID());
					findedFeature = undefined;
				}
			}
		}
	}
	catch(ex){
		//console.log('1')
	}

	for (i = 0; i < features4Deletion.length; i++)
		this.featureProjLayer.getSource().getSource().removeFeature(features4Deletion[i]);
	//нашли и сделали все фичи для объектов, добавляем новую копию
	var obj;
	var centeringExtent = ol.extent.createEmpty();
	//проходимся по точечным фичам
	try{
		for (obj in findedPointFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedPointFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				var fl = GeoUtil.getFlatGeometry(lObj[k].geo);
				if(fl) geos.push(fl);
			}
			var geometry = new ol.geom.MultiPoint(null);
			geometry.setCoordinates(geos, ol.geom.GeometryLayout.XY);
			findedPointFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedPointFeatures[obj]);
		}

		for (obj in findedLineFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedLineFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				var fl = GeoUtil.getFlatGeometry(lObj[k].geo);
				if(fl) geos.push(fl);
			}
			var geometry = new ol.geom.MultiLineString(null);
			geometry.setLineStrings(geos);
			findedLineFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedLineFeatures[obj]);
		}

		for (obj in findedPolygonFeatures) {
			//устанавливаю геометрию по содержимому фичи
			var geos = [];
			var lObj = findedPolygonFeatures[obj].get('labelsObj');
			var k;
			for(k = 0; k<lObj.length; k++){
				var fl = GeoUtil.getFlatGeometry(lObj[k].geo);
				if(fl) geos.push(fl);
			}
			var geometry = new ol.geom.MultiPolygon(null);
			geometry.setPolygons(geos);
			findedPolygonFeatures[obj].setGeometry(geometry);
			this.featureProjLayer.getSource().getSource().addFeature(findedPolygonFeatures[obj]);
		}
	}
	catch(ex){ }
}


/**
 * Оставляет на карте только выбранные объекты
 * @param objects
 * @param centering - флаг масштабирования
 */
map.layer.VectorLayer.prototype.showObjectById = function (objects, centering) {
	//удаляем фичу и создаём новую с выбранными геометриями
	//проходим по всем фичам и забираем по id Объекта геометрию из _globalPointLabels,
	//TODO добавить обработку @ для гдала
	var findedPointFeatures = {};//найденные фичи
	var findedLineFeatures = {};//найденные фичи
	var findedPolygonFeatures = {};//найденные фичи
	var features4Deletion = [];//фичи на удаление
	try{
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		var i = 0, j = 0;
		for (j; j < objects.length; j++) {
			i = 0;
			for (i; i < features.length; i++) {
				//ищем только в multiPoint
				var oId = objects[j];
				if (goog.isDef(features[i].get('pointsObjAll')) && goog.isDef(features[i].get('pointsObjAll')[oId])) {
					//newPointsObj[oId] = features[i].get('pointsObj')[oId];
					//добавляем фичу найденную
					var type = features[i].get('pointsObjAll')[oId].getType();
					if (type == ol.geom.GeometryType.POINT) {
						if (!goog.isDef(findedPointFeatures[features[i].get('labelType')])) {
							findedPointFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
							findedPointFeatures[features[i].get('labelType')].set('pointsObj', {});
							findedPointFeatures[features[i].get('labelType')].set('labelsObj', []);
							//findedPointFeatures[features[i].get('labelType')].setId(App.generateUUID());
							features4Deletion.push(features[i]);
						}
						//установил новый объект с геометрией
						findedPointFeatures[features[i].get('labelType')].get('pointsObj')[oId] = features[i].get('pointsObjAll')[oId];
					}
					else if (type == ol.geom.GeometryType.LINE_STRING) {
						if (!goog.isDef(findedLineFeatures[features[i].get('labelType')])) {
							findedLineFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
							findedLineFeatures[features[i].get('labelType')].set('pointsObj', {});
							findedLineFeatures[features[i].get('labelType')].set('labelsObj', []);
							//findedLineFeatures[features[i].get('labelType')].setId(App.generateUUID());
							features4Deletion.push(features[i]);
						}
						//установил новый объект с геометрией
						findedLineFeatures[features[i].get('labelType')].get('pointsObj')[oId] = features[i].get('pointsObjAll')[oId];
					}
					else if (type == ol.geom.GeometryType.POLYGON) {
						if (!goog.isDef(findedPolygonFeatures[features[i].get('labelType')])) {
							findedPolygonFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
							findedPolygonFeatures[features[i].get('labelType')].set('pointsObj', {});
							findedPolygonFeatures[features[i].get('labelType')].set('labelsObj', []);
							findedPolygonFeatures[features[i].get('labelType')].setId(App.generateUUID());
							features4Deletion.push(features[i]);
						}
						//установил новый объект с геометрией
						findedPolygonFeatures[features[i].get('labelType')].get('pointsObj')[oId] = features[i].get('pointsObjAll')[oId];
					}
					this.clearFeatureLabels_(features[i]);
				}
				//если не нашли, то делаем фичу без объектов
				else {
					var lbObj = features[i].get('labelsObjAll');
					if (goog.isDef(lbObj) && lbObj.length > 0 && goog.isDef(lbObj[0].geo)) {
						var type = (lbObj[0].geo.getType)?lbObj[0].geo.getType():lbObj[0].geo.getGeometry().getType();
						if (type == ol.geom.GeometryType.POINT) {
							if (!goog.isDef(findedPointFeatures[features[i].get('labelType')])) {
								findedPointFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
								findedPointFeatures[features[i].get('labelType')].set('pointsObj', {});
								findedPointFeatures[features[i].get('labelType')].set('labelsObj', []);
								findedPointFeatures[features[i].get('labelType')].setId(App.generateUUID());
								features4Deletion.push(features[i]);
							}
						}
						else if (type == ol.geom.GeometryType.LINE_STRING) {
							if (!goog.isDef(findedLineFeatures[features[i].get('labelType')])) {
								findedLineFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
								findedLineFeatures[features[i].get('labelType')].set('pointsObj', {});
								findedLineFeatures[features[i].get('labelType')].set('labelsObj', []);
								findedLineFeatures[features[i].get('labelType')].setId(App.generateUUID());
								features4Deletion.push(features[i]);
							}
						}
						else if (type == ol.geom.GeometryType.POLYGON) {
							if (!goog.isDef(findedPolygonFeatures[features[i].get('labelType')])) {
								findedPolygonFeatures[features[i].get('labelType')] = this.cloneFeature(features[i], false);
								findedPolygonFeatures[features[i].get('labelType')].set('pointsObj', {});
								findedPolygonFeatures[features[i].get('labelType')].set('labelsObj', []);
								findedPolygonFeatures[features[i].get('labelType')].setId(App.generateUUID());
								features4Deletion.push(features[i]);
							}
						}
						this.clearFeatureLabels_(features[i]);
					}
				}
			}
		}
	}
	catch(ex){
		//console.log('2')
	}


	//нашли и сделали все фичи для объектов, добавляем новую копию
	var obj;
	//если флаг масштабирования  = true, то его по всем фичам считаем
	var centeringExtent = ol.extent.createEmpty();
	var i = 0;
	for (i; i < features4Deletion.length; i++)
		this.featureProjLayer.getSource().getSource().removeFeature(features4Deletion[i]);

	var featuresToAppend = [];
	var geometry;
	//проходимся по точечным фичам
	for (obj in findedPointFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedPointFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedPointFeatures[obj].get('labelsObjAll');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedPointFeatures[obj].get('labelsObj').push(labels[t]);
					break;
				}
			}
			geos.push(pObj[geo].flatCoordinates);//собираем геометрии
		}
		geometry = new ol.geom.MultiPoint(null);
		geometry.setCoordinates(geos, ol.geom.GeometryLayout.XY);
		findedPointFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedPointFeatures[obj]);
		if(geos.length > 0){
			if (centering == true)
				ol.extent.extend(centeringExtent, findedPointFeatures[obj].getGeometry().getExtent());
		}
	}


	for (obj in findedLineFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedLineFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedLineFeatures[obj].get('labelsObjAll');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedLineFeatures[obj].get('labelsObj').push(labels[t]);
					break;
				}
			}
			geos.push(pObj[geo]);//собираем геометрии
		}
		geometry = new ol.geom.MultiLineString(null);
		geometry.setLineStrings(geos);
		findedLineFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedLineFeatures[obj]);
		if(geos.length > 0){
			if (centering == true)
				ol.extent.extend(centeringExtent, findedLineFeatures[obj].getGeometry().getExtent());
		}
	}

	for (obj in findedPolygonFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedPolygonFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedPolygonFeatures[obj].get('labelsObjAll');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedPolygonFeatures[obj].get('labelsObj').push(labels[t]);
					break;
				}
			}
			var pp = new ol.geom.Polygon(null);
			var linearRing = new ol.geom.LinearRing(null);
			linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, pObj[geo].flatCoordinates);
			pp.appendLinearRing(linearRing);
			geos.push(pp);
		}//собираем геометрии
		geometry = new ol.geom.MultiPolygon(null);
		geometry.setPolygons(geos);
		findedPolygonFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedPolygonFeatures[obj]);
		if(geos.length > 0){
			if (centering == true)
				ol.extent.extend(centeringExtent, findedPolygonFeatures[obj].getGeometry().getExtent());
		}
	}
	if(featuresToAppend.length > 0)
		this.featureProjLayer.getSource().getSource().addFeatures(featuresToAppend);
	this.featureProjLayer.changed();
	if (centering == true) {
		WidgetMap.centerOnMap(centeringExtent);
	}
};

map.layer.VectorLayer.prototype.showObjectsByIds = function (objects, centering) {
	var that = this;
	//удаляем фичу и создаём новую с выбранными геометриями
	//проходим по всем фичам и забираем по id Объекта геометрию из _globalPointLabels,
	var findedPointFeatures = {};//найденные фичи
	var findedLineFeatures = {};//найденные фичи
	var findedPolygonFeatures = {};//найденные фичи
	var features4Deletion = [];//фичи на удаление
	try{
		var features = this.featureProjLayer.getSource().getSource().getFeatures();
		features4Deletion = features;
		var i = 0, j = 0, findedFeature;
		//первый проход чистка фич
		for (i; i < features.length; i++) {
			this.clearFeatureLabels_(features[i]);
			var featureLabelType = features[i].get('labelType');
			var lbObj = features[i].get('labelsObjAll');
			if (lbObj && lbObj.length > 0 && lbObj[0].geo) {
				var type = (lbObj[0].geo.getType) ? lbObj[0].geo.getType() : lbObj[0].geo.getGeometry().getType();
				if (type === ol.geom.GeometryType.POINT) {
					findedPointFeatures[featureLabelType] = this.cloneFeature(features[i], false);
					globalPointsLabels_[featureLabelType] = [];
					findedFeature = findedPointFeatures[featureLabelType];
				}
				else if (type === ol.geom.GeometryType.LINE_STRING) {
					findedLineFeatures[featureLabelType] = this.cloneFeature(features[i], false);
					globalLinesLabels_[featureLabelType] = [];
					findedFeature = findedLineFeatures[featureLabelType];
				}
				else if (type === ol.geom.GeometryType.POLYGON) {
					findedPolygonFeatures[featureLabelType] = this.cloneFeature(features[i], false);
					globalPolygonsLabels_[featureLabelType] = [];
					findedFeature = findedPolygonFeatures[featureLabelType];
				}
				if(findedFeature){
					findedFeature.set('pointsObj', {});
					findedFeature.set('pointsObjAll', {});
					findedFeature.set('pointsObjAllBackup', goog.object.clone(features[i].get('pointsObjAll')));
					findedFeature.set('labelsObj', []);
					findedFeature.set('labelsObjAll', []);
					findedFeature.set('labelsObjAllBackup', goog.array.clone(features[i].get('labelsObjAll')));
					findedFeature.setId(App.generateUUID());
					findedFeature = undefined;
				}
			}
		}
		//второй проход установка найденных объектов
		for (i = 0; i < features.length; i++) {
			var featureLabelType = features[i].get('labelType');
			var featurePointsAll = features[i].get('pointsObjAll');
			for (j = 0; j < objects.length; j++) {
				var oId = objects[j];
				if(that.hasSemanticField){
					for(var fp in featurePointsAll){
						if(fp.indexOf('|') !== -1 && fp.split('|')[1] === oId){
							//добавляем фичу найденную
							var type = featurePointsAll[fp].getType();
							if (type === ol.geom.GeometryType.POINT) {
								findedPointFeatures[featureLabelType].get('pointsObj')[fp] = featurePointsAll[fp];
								findedPointFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
							}
							else if (type === ol.geom.GeometryType.LINE_STRING) {
								findedLineFeatures[featureLabelType].get('pointsObj')[fp] = featurePointsAll[fp];
								findedLineFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
							}
							else if (type === ol.geom.GeometryType.POLYGON) {
								findedPolygonFeatures[featureLabelType].get('pointsObj')[fp] = featurePointsAll[fp];
								findedPolygonFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
							}
						}
					}
				}
				else{
					if (featurePointsAll && featurePointsAll[oId]) {
						//добавляем фичу найденную
						var type = featurePointsAll[oId].getType();
						if (type === ol.geom.GeometryType.POINT) {
							findedPointFeatures[featureLabelType].get('pointsObj')[oId] = featurePointsAll[oId];
							findedPointFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
						}
						else if (type === ol.geom.GeometryType.LINE_STRING) {
							findedLineFeatures[featureLabelType].get('pointsObj')[oId] = featurePointsAll[oId];
							findedLineFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
						}
						else if (type === ol.geom.GeometryType.POLYGON) {
							findedPolygonFeatures[featureLabelType].get('pointsObj')[oId] = featurePointsAll[oId];
							findedPolygonFeatures[featureLabelType].set('pointsObjAll', featurePointsAll);
						}
					}
				}
			}
		}
	}
	catch(ex){
	}

	//нашли и сделали все фичи для объектов, добавляем новую копию
	var obj;
	//если флаг масштабирования  = true, то его по всем фичам считаем
	var centeringExtent = ol.extent.createEmpty();
	var i = 0;
	for (i; i < features4Deletion.length; i++)
		this.featureProjLayer.getSource().getSource().removeFeature(features4Deletion[i]);

	var featuresToAppend = [];
	var geometry;
	//проходимся по точечным фичам
	for (obj in findedPointFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedPointFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedPointFeatures[obj].get('labelsObjAllBackup');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedPointFeatures[obj].get('labelsObj').push(labels[t]);
					globalPointsLabels_[obj].push(labels[t]);
					break;
				}
			}
			geos.push(pObj[geo].flatCoordinates);//собираем геометрии
		}
		geometry = new ol.geom.MultiPoint(null);
		geometry.setCoordinates(geos, ol.geom.GeometryLayout.XY);
		findedPointFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedPointFeatures[obj]);
		if(geos.length > 0 && centering == true){
			ol.extent.extend(centeringExtent, findedPointFeatures[obj].getGeometry().getExtent());
		}
	}


	for (obj in findedLineFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedLineFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedLineFeatures[obj].get('labelsObjAllBackup');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedLineFeatures[obj].get('labelsObj').push(labels[t]);
					globalLinesLabels_[obj].push(labels[t]);
					break;
				}
			}
			geos.push(pObj[geo]);//собираем геометрии
		}
		geometry = new ol.geom.MultiLineString(null);
		geometry.setLineStrings(geos);
		findedLineFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedLineFeatures[obj]);
		if(geos.length > 0 && centering == true){
			ol.extent.extend(centeringExtent, findedLineFeatures[obj].getGeometry().getExtent());
		}
	}

	for (obj in findedPolygonFeatures) {
		//устанавливаю геометрию по содержимому фичи
		var geo;
		var geos = [];
		var pObj = findedPolygonFeatures[obj].get('pointsObj');
		for (geo in pObj) {
			var t = 0;
			var labels = findedPolygonFeatures[obj].get('labelsObjAllBackup');
			for (t; t < labels.length; t++) {
				if (labels[t].id == geo) {
					findedPolygonFeatures[obj].get('labelsObj').push(labels[t]);
					globalPolygonsLabels_[obj].push(labels[t]);
					break;
				}
			}
			var pp = new ol.geom.Polygon(null);
			var linearRing = new ol.geom.LinearRing(null);
			linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, pObj[geo].flatCoordinates);
			pp.appendLinearRing(linearRing);
			geos.push(pp);
		}//собираем геометрии
		geometry = new ol.geom.MultiPolygon(null);
		geometry.setPolygons(geos);
		findedPolygonFeatures[obj].setGeometry(geometry);
		featuresToAppend.push(findedPolygonFeatures[obj]);
		if(geos.length > 0 && centering == true){
			ol.extent.extend(centeringExtent, findedPolygonFeatures[obj].getGeometry().getExtent());
		}
	}
	if(featuresToAppend.length > 0)
		this.featureProjLayer.getSource().getSource().addFeatures(featuresToAppend);
	this.featureProjLayer.changed();
	if (centering == true) {
		WidgetMap.centerOnMap(centeringExtent);
	}
};

/**
 * Получение геометрии по id
 * @param id
 */
map.layer.VectorLayer.prototype.getGeometryById = function (id) {
	if (!goog.isDef(id) || id == '')
		return undefined;
	//выбираем все features, в которых возможно хранить наш тип геометрии
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	for (j; j < features.length; j++) {
		var points = features[j].get('pointsObjAll');
		var aa;
		for (aa in points) {
			if (aa == id) {
				return points[aa];
			}
		}
	}
	return undefined;
};


/**
 * Получение массива геометрий
 */
map.layer.VectorLayer.prototype.getAllGeometries = function () {
	var result = [];
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	for (j; j < features.length; j++) {
		var points = features[j].get('pointsObjAll');
		for (var aa in points) {
			result.push(points[aa])
		}
	}
	return result;
};


/**
 *
 * @param feature фича для клонирования
 * @param withGeo флаг, нужно ли копировать геометрию
 * @returns {ol.Feature}
 */
map.layer.VectorLayer.prototype.cloneFeature = function (feature, withGeo) {
	var clone = new ol.Feature(feature.getProperties());
	clone.setGeometryName(feature.getGeometryName());
	if (withGeo == true) {
		var geometry = feature.getGeometry();
		if (geometry) {
			clone.setGeometry(geometry.clone());
		}
	}
	var style = feature.getStyle();
	if (style) {
		clone.setStyle(style);
	}
	return clone;
};

/**
 * Функция получения данных из кеша (если они там есть и актуальны)
 */
map.layer.VectorLayer.prototype.getDataFromCache = function () {
	if (supports_html5_storage()) {
		var retrievedObject = sessionStorage.getItem(this.name);
		return JSON.parse(retrievedObject);
	}

};

/**
 * Функция принудительной очистки кеша
 * (применяется при добавлении, изменении или удалении объектов слоя)
 */
map.layer.VectorLayer.prototype.clearDataCache = function () {
	if (supports_html5_storage()) {

	}

};

/**
 * Функция сохранения результата геозапроса в кеш
 * @param resultData - данные для кеширования
 */
map.layer.VectorLayer.prototype.saveResultToCache = function (resultData) {
	if (supports_html5_storage()) {
		//Пытаемся получить локальный кеш и сохранить пришедшие данные в него
		if (sessionStorage[this.name] == undefined && this.name != 'PODS_ROUTE') {
			var curDate = new Date();
			var testObject = {CACHE_ACTUAL_DATE: curDate, result: resultData};
			var strItem = JSON.stringify(testObject);
			try {
				sessionStorage.setItem(this.name, strItem);
			}
			catch (ex) {
				//App.errorReport('Ошибка при сохранении данных слоя "'+this.sourceDescr+'" в кеш браузера', ex);
			}
			//Проверяем результат сохранения
		}
	}
};
/**
 * Получение геометрии по id
 * @param id
 */
map.layer.VectorLayer.prototype.updateGeometryById = function (id, geometry) {
	if (!id || !geometry)
		return;
	//выбираем все features, в которых возможно хранить наш тип геометрии
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	for (j; j < features.length; j++) {
		var index = -1;
		var labels = features[j].get('labelsObj');
		var aa = 0;
		for (aa; aa < labels.length; aa++) {
			if (labels[aa].id === id) {
				try {
					index = aa;
					//делаем копию объекта
					var baseFeature = labels[aa].geo;
					if (!baseFeature.getGeometry)// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
						baseFeature = new ol.Feature(baseFeature);
					baseFeature.setGeometry(geometry);
					//обновляем геометрию в слое
					this.updateGeometry(baseFeature, id, true);
					this.featureProjLayer.getSource().changed();
					//this.featureProjLayer.changed();
					return baseFeature;
				}
				catch (e) {
				}
				break;
			}
		}
	}
};

/**
 * Обновление типа отрисовки на карте
 * если у объекта поменялся стиль отрисовки при сохранении семантики TYPE_CL,
 * то перерисовываем его новым стилем и переносим в другую фичу с его типом
 * @param semId идентификатор объекта
 * @param data данные, которые передавались на сохранение, которые содержат тип отрисовки из TYPE_CL
 */
map.layer.VectorLayer.prototype.updateObjectGeoStyle = function (semId, data, dataObject) {
	if (goog.isDef(data)) {
		var that = this;
		var classField = data[0].getAttribute(this.classField);
		if (goog.isDefAndNotNull(classField) && goog.isDef(this.featureProjLayer)) {
			var features = this.featureProjLayer.getSource().getSource().getFeatures();
			var i = 0, j = 0;
			for (j; j < features.length; j++) {
				var labelsObj = features[j].get('labelsObj');
				for (i = 0; i < labelsObj.length; i++) {
					if (labelsObj[i].id == semId) {
						//ищем объект и проверяем менялся ли у него classField. Если да - обновляем геометрию
						//TODO убедиться, что всегда 2 элемента при split у  labelType
						var featureClass = features[j].get('labelType').split('/')[1];
						if (classField == featureClass)
							break;
						var geoType = features[j].get('pointsObjAll')[semId].getType();
						//переносим объект
						this.moveObjectGeoToAnotherFeature(semId, classField, dataObject);
						this.featureProjLayer.getSource().changed();
						break;
					}
				}
			}
		}

	}
};

/**
 * Функция переносит объект в другую фичу
 * Сначала удаляет из старой и потом добавляет в новую
 */
map.layer.VectorLayer.prototype.moveObjectGeoToAnotherFeature = function (id, classField, dataObject) {
	if (!goog.isDef(id) || id == '')
		return;
	//выбираем все features, в которых возможно хранить наш тип геометрии
	var features = this.featureProjLayer.getSource().getSource().getFeatures();
	var j = 0;
	for (j; j < features.length; j++) {
		var index = -1;
		var labels = features[j].get('labelsObj');
		var pointsAll = features[j].get('pointsObjAll');
		var points = features[j].get('pointsObj');
		var aa = 0;
		for (aa; aa < labels.length; aa++) {
			if (labels[aa].id == id) {
				try {
					index = aa;
					//делаем копию объекта
					var currObj = labels[aa];
					var baseFeature = labels[aa].geo;
					if (!goog.isDef(baseFeature.getGeometry))// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
						baseFeature = new ol.Feature(baseFeature);
					labels.splice(index, 1);
					delete pointsAll[id];
					delete points[id];
					//удаляем
					GeoUtil.removeObjectFromGeometry(features[j], index);
					//если удалили последний объект в фиче, кто он ребудет рендериться, соответственно, не будет чистится _LABELS
					// поэтому чистим _LABELS
					if (labels.length == 0) {
						this.clearFeatureLabels_(features[j]);
					}
					//добавляем объект в другую фичу
					this.addGeometry(baseFeature, id, dataObject);

				}
				catch (e) {
				}
				//features[j].changed();
				break;
			}
		}
	}
};

/**
 * Получение иконки для слоя
 */
map.layer.VectorLayer.prototype.getIcon = function () {
	var topology = this.drawTypes[0];
	var styleArr = WidgetMap.layerManager.getStyleObjByNameAndType(this.name,topology);
	if(styleArr !== undefined && styleArr.length != 0){
		var style = styleArr[0];
		if(style !== undefined){
			if(style.pointObj !== undefined){
				if(style.pointObj.form === 'bitmap')
					return style.pointObj.href;
				else{

				}
			}
			else if(style.polyObj !== undefined){

			}
			else if(style.lineObj !== undefined){
				//color, size
			}
		}
	}
};


/**
 * Трансвормация типа геометрии к текущему слою
 * @param fGeometry
 * @returns {*}
 */
map.layer.VectorLayer.prototype.transformGeometryLayout = function(fGeometry){
	try{
		if(fGeometry){
			var newFGeometry = undefined;
			//производим трансформаци из XY в XYZ и наоборот
			if(fGeometry.layout === ol.geom.GeometryLayout.XY){
				//newFGeometry
			}
			else{//ol.geom.GeometryLayout.XYZ

			}
		}
	}
	catch(ex){

	}
	return fGeometry;
};



/**
 * откат геометрии
 */
map.layer.VectorLayer.prototype.revertGeometry = function (data) {
	try{
		if(data && data.labelsObj){
			//выбираем все features, в которых возможно хранить наш тип геометрии
			var features = this.featureProjLayer.getSource().getSource().getFeatures();
			for (var j = 0; j < features.length; j++) {
				var labels = features[j].get('labelsObj');
				var pointsAll = features[j].get('pointsObjAll');
				var points = features[j].get('pointsObj');
				var aa = 0;
				var finded = false;
				for (aa; aa < labels.length; aa++) {
					if (labels[aa].id === data.labelsObj.id) {
						try {
							finded = true;
							//забираем гео сохраненного объекта
							var baseFeature = data.labelsObj.geo;
							if (!baseFeature.getGeometry)// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
								baseFeature = new ol.Feature(baseFeature);
							//обновляем геометрию в слое
							this.updateGeometry(baseFeature, data.labelsObj.id, true);
							this.featureProjLayer.getSource().changed();
							return ;
						}
						catch (e) {
						}
						break;
					}
				}
			}
			//если не нашли, то добавляем геометрию
			if(!finded){
				try {
					finded = true;
					//забираем гео сохраненного объекта
					var baseFeature = data.labelsObj.geo;
					if (!baseFeature.getGeometry)// если .geo это фича(выбранный обхъект), то ничего не делаемб иначе создаем новую фичу с геометрией
						baseFeature = new ol.Feature(baseFeature);
					//обновляем геометрию в слое
					//var savingData = '<root><data LABEL="' + data.labelsObj.label + '"></root>'
					this.addGeometry(baseFeature, data.labelsObj.id, {label:data.labelsObj.label});
					this.featureProjLayer.getSource().changed();
					return ;
				}
				catch (e) {
				}
			}
		}
	}
	catch(ex){

	}
};

/**
 * Функция обновления геометрий объектов из базы по их идентификаторам
 */
map.layer.VectorLayer.prototype.loadObjectsByIds = function (ids) {
	var that = this;

	function getLayerGeoReqParams(request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		var filter = 'ID in ('+ids.join()+')';
		return {
			descrId: request,
			descrType: 'select',
			topology: that.drawTypes.join(),
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'" ' + topFiltersStr + '' +
				'>' +
				'<data FILTER=" ' + filter + '" />' +
				'</root>'
		};
	}

	function getLayerGeoResult(resultXml) {
		try {
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			for (var i = 0; i < datas.length; i++) {
				var format = new ol.format.WKT({dimension: 2});
				var wktStr = datas[i].getAttribute("WKT");
				var idStr = datas[i].getAttribute("ID");
				if (idStr == '' || idStr === null) {
					idStr = datas[i].getAttribute("id");
				}
				if (wktStr == '' && idStr == '') {
					BlockingUtil.readyGeo();
					return;
				}
				var stride = 2;
				var fGeometry;
				try {
					fGeometry = format.readGeometry(wktStr);
				}
				catch (ex) {
					//для случая с видеозаписями, приходит 3 координаты
					stride = 3;
					format = new map.format.WKT({dimension: stride});
					fGeometry = format.readGeometry(wktStr);
				}
				if (fGeometry.getType() === 'Point' || fGeometry.getType() === 'LineString' || fGeometry.getType() === 'Polygon')
					GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
			}
			var featureProjLayer = that.featureProjLayer;
			//выбираем все features, в которых возможно хранить наш тип геометрии
			var features = featureProjLayer.getSource().getSource().getFeatures();
			var j;
			for (j in features) {
				var index = -1;
				var labels = features[j].get('labelsObj');
				var aa = 0;
				for (; aa < labels.length; aa++) {
					if (labels[aa].id == idStr) {
						index = aa;
						break;
					}
				}
				if (fGeometry.getType() == ol.geom.GeometryType.LINE_STRING) {
					//заменяем строку на нужную
					if (index != -1) {
						var lineStrings = features[j].getGeometry().getLineStrings();
						lineStrings[index] = fGeometry;
						features[j].get('pointsObj')[idStr] = fGeometry;
						features[j].get('pointsObjAll')[idStr] = fGeometry;
						features[j].getGeometry().setLineStrings(lineStrings);
						break;
					}
				}
			}
			BlockingUtil.readyGeo();
		}
		catch (ex) {
			BlockingUtil.readyGeo();
			App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
				filename: gis_filename_1,
				functionname: 'gis_filename_1_1'
			});
		}
	}

	function getLayerGeoFault(resultXml) {
		BlockingUtil.readyGeo();
		App.errorReport(gis_vectorlayer_2 + that.name, gis_vectorlayer_3 + that.sourceDescr + "(" + that.name + gis_vectorlayer_4 + resultXml + "\n", undefined, {
			filename: gis_filename_1,
			functionname: 'gis_filename_1_2'
		});
	}

	App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams(that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
};



/**
 * запрос к данным
 * @params ids массив идентификаторов для тонкой загрузки геометрий только по этим объектам
 */
map.layer.VectorLayer.prototype.refreshData = function (ids) {
	var that = this;
	if (goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.spatial) && that.dataProvider.spatial != '') {
		this.isDataLoading_ = true;
		BlockingUtil.waitGeo();
		function getLayerGeoReqParams(filter, request) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
			var roughFiltersStr = LayerManager.getRoughFiltersString(WidgetMap.currentRoughFilter);
			var filterIds = '';
			if(ids && ids.length > 0){
				filterIds = ' and ID in ('+ids.join()+') ';
			}

			var filterStr = '8=8';
			return {
				descrId: request,
				descrType: 'select',
				topology: that.drawTypes.join(),
				data: '<root USER_ID="' + userId.xmlEscape() +
					'" USER_LOGIN="' + userLogin.xmlEscape() +
					'" PODS_USER="' + userLogin.xmlEscape() +
					'" ' + topFiltersStr + '' +
					'>' +
					'<data FILTER="' + filterStr + filterIds + '" />' +
					'</root>'
			};
		}

		function getLayerGeoResult(resultXml) {
			that.dataReady_ = true;
			that.isDataLoading_ = false;
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.readyGeo();
					if (that.iustMemoryCorruptCounter > 1)
						if (er.indexOf('memory is corrupt.') != -1 || er.indexOf('память повреждена.') != -1/* || er.indexOf('выгруженному объекту AppDomain.') !=-1*/) {
							--that.iustMemoryCorruptCounter;
							that.dataReady_ = false;
							that.isDataLoading_ = false;
							that.refreshData(ids);
							return;
						}
					if (that.geolocErrorCounter > 1)
						if (er.indexOf('Не найдено поле геоданных GEOLOC') != -1) {
							--that.geolocErrorCounter;
							that.dataReady_ = false;
							that.isDataLoading_ = false;
							that.refreshData(ids);
							return;
						}
					App.errorReport(gis_vectorlayer_1, er, undefined, {
						filename: gis_filename_1,
						functionname: 'refreshData__getLayerGeoResult'
					});
					return;
				}
				that.iustMemoryCorruptCounter = 0;
				that.internalServerErrorCounter = 0;
				that.geolocErrorCounter = 0;
				var layerGeoXml = ($.parseXML(resultXml)).firstChild;
				var datas = layerGeoXml.getElementsByTagName("data");
				var stride = 2;

				that.points_ = {};
				that.pointsLabels_ = {};
				that.lines_ = {};
				that.polygons_ = {};
				that.pointsData_ = {};
				that.linesData_ = {};
				that.polygonData_ = {};
				var i = 0;
				for (i; i < datas.length; i++) {
					//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
					var format = new ol.format.WKT({dimension: stride});
					var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
					var type = datas[i].getAttribute("TYPE");
					var label = datas[i].getAttribute("LABEL");
					var idStr = datas[i].getAttribute("ID");
					if (idStr == '' || idStr === null) {
						idStr = datas[i].getAttribute("id");
					}
					if (!goog.isNull(label)) {
						label = label.replace(/""/gm, '"');
						label = label.replace(/Ж(\d)/gm, 'Ø$1');
					}
					var fGeometry = undefined;
					if (goog.isNull(wktStr))
						continue;
					try {
						fGeometry = format.readGeometry(wktStr);
					}
					catch (ex) {
						//для случая с видеозаписями, приходит 3 координаты
						stride = 3;
						format = new map.format.WKT({dimension: stride});
						fGeometry = format.readGeometry(wktStr);
					}
					if (fGeometry.getType() == 'Point' && that.drawTypes.indexOf('point') != -1) {
						if ((fGeometry.flatCoordinates[0] < 0 || fGeometry.flatCoordinates[1] < 0) && that.projection !== 'EPSG:3395' && that.projection !== 'EPSG:5807')
							continue;
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.points_[that.name + ttype]))
							that.points_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsLabels_[that.name + ttype]))
							globalPointsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPointsGEOs_[that.name + ttype]))
							globalPointsGEOs_[that.name + ttype] = {};
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						that.points_[that.name + ttype].push(fGeometry.getFlatCoordinates());
						globalPointsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalPointsGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() == 'LineString' && that.drawTypes.indexOf('line') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.lines_[that.name + ttype]))
							that.lines_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesLabels_[that.name + ttype]))
							globalLinesLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalLinesGEOs_[that.name + ttype]))
							globalLinesGEOs_[that.name + ttype] = {};
						that.lines_[that.name + ttype].push(fGeometry);
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalLinesLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						globalLinesGEOs_[that.name + ttype][idStr] = fGeometry;
					}
					if (fGeometry.getType() == 'Polygon' && that.drawTypes.indexOf('polygon') != -1) {
						var ttype = (goog.isNull(type)) ? '' : '/' + type;
						if (!goog.isDef(that.polygons_[that.name + ttype]))
							that.polygons_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsLabels_[that.name + ttype]))
							globalPolygonsLabels_[that.name + ttype] = [];
						if (!goog.isDef(globalPolygonsGEOs_[that.name + ttype]))
							globalPolygonsGEOs_[that.name + ttype] = {};
						that.polygons_[that.name + ttype].push(fGeometry);
						globalPolygonsLabels_[that.name + ttype].push({label: label, id: idStr, geo: fGeometry});
						if (WidgetMap.DEFAULT_PROJECTION == GeoUtil.PROJS.GoogleMercator || WidgetMap.DEFAULT_PROJECTION == 'EPSG:3395')
							GeoUtil.convertGeometry(fGeometry, that.projection, WidgetMap.DEFAULT_PROJECTION);
						globalPolygonsGEOs_[that.name + ttype][idStr] = fGeometry;
					}

				}
				var pArr = [];
				var stName;
				var findedFeature = undefined; // если нашли фичу с таким типом
				var features = that.featureProjLayer.getSource().getSource().getFeatures();
				var geometry = undefined;
				for (stName in that.polygons_) {
					that.hasData = true;
					for (var ff in features) {
						var f = features[ff];
						var fG = f.getGeometry();
						if(f.get('labelType') === stName && fG.getType() === ol.geom.GeometryType.MULTI_LINE_STRING){
							findedFeature = f;
						}
					}
					findedFeature = undefined;
					if(findedFeature){
						geometry = findedFeature.getGeometry();
						if(geometry){
							var ls = geometry.getLineStrings();
							ls = ls.concat(that.lines_[stName]);
							geometry.setLineStrings(ls);
						}
					}
					else{
						geometry = new ol.geom.MultiPolygon(null);
						geometry.setPolygons(that.polygons_[stName]);
						var newPolygonFeature = new ol.Feature(geometry);
						newPolygonFeature.set('layerId', that.name);
						newPolygonFeature.set('spacing', that.spacing);
						newPolygonFeature.set('labelType', stName);
						newPolygonFeature.set('zIndex', that.zIndex);
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('labelsObjAll', globalPolygonsLabels_[stName]);
						newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);//текущие, которые обрабатываются
						newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);//все объекты
						newPolygonFeature.set('type', stName.replace('/', '_'));
						newPolygonFeature.setStyle(function (resolution) {
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'Polygon');
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('type'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'Polygon');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'Polygon');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyle(this.get('layerId'));
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								else
									that.setTextStyle(s.style, null);
								if (goog.isArray(s.style))
									return s.style;
								return [s.style];
							}
							return null;
						});
						pArr.push(newPolygonFeature);
					}

					delete that.polygons_[stName];
					delete that.polygonData_[stName];
				}
				findedFeature = undefined;
				geometry = undefined;
				for (stName in that.lines_) {
					that.hasData = true;
					for (var ff in features) {
						var f = features[ff];
						var fG = f.getGeometry();
						if(f.get('labelType') === stName && fG.getType() === ol.geom.GeometryType.MULTI_LINE_STRING){
							findedFeature = f;
						}
					}
					if(findedFeature){
						geometry = findedFeature.getGeometry();
						if(geometry){
							var ls = geometry.getLineStrings();
							ls = ls.concat(that.lines_[stName] );
							geometry.setLineStrings(ls);
						}
					}
					else{
						var geometry = new ol.geom.MultiLineString(null);
						geometry.setLineStrings(that.lines_[stName]);

						var newLineFeature = new ol.Feature(geometry);
						newLineFeature.set('layerId', that.name);
						newLineFeature.set('spacing', that.spacing);
						newLineFeature.set('zIndex', that.zIndex);
						newLineFeature.set('labelType', stName);
						newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
						newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
						newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);//все объекты
						newLineFeature.set('type', stName.replace('/', '_'));
						newLineFeature.setStyle(function (resolution) {
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'LineString');
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), 'LineString');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'LineString');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), 'LineString');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'LineString');
							if (!goog.isNull(s && !goog.isNull(s.style))) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', 'LineString');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2')
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								if (goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
							return null;
						});
						pArr.push(newLineFeature);
					}
					delete that.lines_[stName];
					delete that.linesData_[stName];
				}
				findedFeature = undefined;
				geometry = undefined;
				for (stName in that.points_) {
					that.hasData = true;
					for (var ff in features) {
						var f = features[ff];
						var fG = f.getGeometry();
						if(f.get('labelType') === stName && fG.getType() === ol.geom.GeometryType.MULTI_POINT){
							findedFeature = f;
						}
					}
					if(findedFeature){
						geometry = findedFeature.getGeometry();
						if(geometry){
							var coords = geometry.getCoordinates();
							coords = coords.concat(that.points_[stName])
							geometry.setCoordinates(coords, ol.geom.GeometryLayout.XY);
						}
					}
					else{
						var geometry = new ol.geom.MultiPoint(null);
						geometry.setCoordinates(that.points_[stName], ol.geom.GeometryLayout.XY);
						var newPointFeature = new ol.Feature(geometry);
						newPointFeature.set('layerId', that.name);
						newPointFeature.set('spacing', that.spacing);
						newPointFeature.set('zIndex', that.zIndex);
						newPointFeature.set('labelType', stName);
						newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
						newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
						newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);//все объекты
						newPointFeature.set('labelsObjAll', globalPointsLabels_[stName]);
						newPointFeature.set('type', stName.replace('/', '_'));
						newPointFeature.setStyle(function (resolution) {
							var mapZoom = WidgetMap.map.getView().getZoom();
							var s = (goog.isNull(this.get('layerId'))) ? null : WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('type'), 'Point');
							var allowText = WidgetMap.layerManager.isTextAllowedByLayerName(this.get('layerId'));
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('type'), 'Point');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);

								}
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(this.get('layerId'), 'Point');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(this.get('layerId'), 'Point');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT', 'Point');
							if (!goog.isNull(s) && !goog.isNull(s.style)) {
								if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
									return null;
								if (goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT', 'Point');
									if (!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax && textstyle.fontSize != '-2') {
										//this.set('textOverlap',textstyle.overlap);
										that.setTextStyle(s.style, textstyle);
									}
									else
										that.setTextStyle(s.style, null);
								}
								return [s.style];
							}
							return null;
						});
						pArr.push(newPointFeature);
					}
					delete that.pointsLabels_[stName];
					delete that.points_[stName];
					delete that.pointsData_[stName];
				}
				if (pArr.length > 0)
					that.featureProjLayer.getSource().getSource().addFeatures(pArr);
				delete pArr;
				BlockingUtil.readyGeo();
				that.fitMap_();
			}
			catch (ex) {
				if (goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(false);
				BlockingUtil.readyGeo();
				that.dataReady_ = true;
				that.isDataLoading_ = false;
				App.errorReport(gis_vectorlayer_1, ex, undefined, {
					filename: gis_filename_1,
					functionname: 'refreshData__getLayerGeoResult_1',
					datatext: gis_vectorlayer_5 + that.name + gis_vectorlayer_6 + resultXml
				});
			}
		}

		function getLayerGeoFault(resultXml) {
			if (that.internalServerErrorCounter > 1)
				if (resultXml.indexOf('Internal Server Error') != -1 || resultXml.indexOf('. error. ') != -1 || resultXml.indexOf('. Error. ') != -1 || resultXml.indexOf('. Error ') != -1) {
					--that.internalServerErrorCounter;
					that.dataReady_ = false;
					that.isDataLoading_ = false;
					that.requestData_();
					return;
				}
			that.internalServerErrorCounter = 0;
			that.dataReady_ = true;
			if (goog.isDef(that.layerLoadCallback))
				that.layerLoadCallback(false);
			BlockingUtil.readyGeo();
			that.isDataLoading_ = false;
			App.errorReport(gis_vectorlayer_1, resultXml, undefined, {
				filename: gis_filename_1,
				functionname: 'requestData__getLayerGeoFault'
			});
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			that.isUnlistenedMoveEnd = true;
		}
		
		//Получаем данные из кеша
		var layerDataCache = this.getDataFromCache();
		if (goog.isDefAndNotNull(layerDataCache)) {
			getLayerGeoResult(layerDataCache.result);
		}
		else
			App.serverQueryXML3Node(Services.processQueryNodeGeo, getLayerGeoReqParams('', that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
	}
};

/**
 *
 * Процесс обновление данных по составному объекту для тех схемы
 * @param id
 * @param label
 */
map.layer.VectorLayer.prototype.updateComplexSemantic = function (id, label, wkt) {
	var ignoreWkt = false;
	var ignoreLabel = false;
	if(!this.semanticUniqData)this.semanticUniqData = {};
	//если данных нет, до вписываем сюда подпись линии, массив wkt-строк
	if(!this.semanticUniqData[id]){
		this.semanticUniqData[id] = {
			wkts: [wkt],
			label: label,
			flatCoordinates:[],
		}
	}
	else{
		var wkts = this.semanticUniqData[id].wkts;
		//если такая wkt уже есть - игнорируем
		if(wkts.indexOf(wkt) !== -1)
			ignoreWkt = true;
		else
			this.semanticUniqData[id].wkts.push(wkt);
	}
	return {ignoreWkt: ignoreWkt, ignoreLabel: ignoreLabel}
};
goog.provide('map.layer.CASLayer');


map.layer.CASLayer.ILLEGAL_TO_FILTER_LAYER = gis_caslayer_1;
/**
 * @classdesc
 * Векторный слой
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @param  opt_options Options.
 * @api
 */
map.layer.CASLayer = function(opt_options) {
	var options = goog.isDef(opt_options) ? opt_options : {};
	this.loadSpatialCallback = undefined;
	this.spatialVariables = undefined;
	//Переменная обозначает, что слой находится в состоянии загрузки переменных
	this.inSpatialRequest = false;
	//оригинальные значение, первоначальные
	this.originalMinValue_ = NaN;
	this.originalMaxValue_ = NaN;

	this.group = options.group;// объект группы со ссылкой на его детей
	this.groupIndex = options.groupIndex;
	this.groupId = options.groupId;
	this.groupMaxGeoBounds = NaN;
	this.groupMinGeoBounds = NaN;

	//если был выставлен флаг config.cas.scale.cut_y, то при пересчете сюда установить минимальное значение
	this.cutYMin = 0;

	//массив синонимов слоя. Используется в синхронизации между окнами
	this.layerNameSynonym =  goog.isDef(options.layerNameSynonym) ?
		options.layerNameSynonym : [];

	this.filtersXml = goog.isDef(options.filtersXml) ?
		options.filtersXml : undefined;

	//название слоя на легенде(нужно для последующего редактирования)
	this.legendDescr =  goog.isDef(options.legendDescr) ?
		options.legendDescr : '';
	//имя слоя, которое сейчас отображается в легене
	this.legendDescrOriginal =  goog.isDef(options.legendDescrOriginal) ?
		options.legendDescrOriginal : '';

	//все данные для слоя с фильтром
	this.allXMLData = undefined;

	//флаг, показывать шкалу с километрами под графиком или нет
	this.needScale = true;

	//Linux. Счетчик попыток перезапроса данных, если выдается ошибка apache2
	this.internalServerErrorCounter = 5;

	//текущий фильтр, если есть
	this.filter = undefined;
	
	//если при выборе фильтра параметры необходимо передавать не в FILTER, а как отдельные переменные. Пример в задаче профиля водного перехода
	this.filterAsParam = options.filterAsParam;

	//параметры выбранного линейного объекта по которому будет происходить построение новых графиков
	this.selectedLineObj = options.selectedLineObj;

	//форма фильтра, чтобы несколько раз не подгружать данные
	this.casFilterForm = undefined;

	//Минимально возможное значение данных по оси Y
	this.dataYMin_ = NaN;
	//Максимально возможное значение данных по оси Y
	this.dataYMax_ = NaN;

	//массив косметических элементов на графике(линии,..) принимают топологию, координаты, и стиль
	this.cosmeticElements = [];

	//Число делений на вертикальной шкале для данного графика
	this.ySteps_=4;

	this.minMeasure = 0;

	/** Переменные слоя, отвечающие за смещение и растяжение по Y */
	//Текущая позиция слоя
	this.layPosition_;
	//Текущая высота слоя
	this.layHeight_;
	//Тип диаграммы (может быть 1D и 2D или interval)  interval является 2D графиком, необходим при экспорте в эксель, при работе с анализами
	this.layDiagType_ = '1D';
	//Число делений на вертикальной шкале для данного графика
	this.ySteps_ = 4;
	//Текущий коэффициент растяжения реальных данных 2D графика по оси Y
	this.scaleYCoeff_ = 1;

	//коэффициент растяжения графика по y
	this.expandValue = NaN;
	//реальный текущий коэффициент
	this.newScaleXCoeff = 1;
	//Переменная коэффициента растяжения данных слоя по X
	this.scaleXCoeff_ = 1;

	//Запрос для получения параметров из файлов *_GEO.xml
	this.requestProviderData = 'SYS_SEM.xml#GET_DATA_XML';

	//Список выбранных объектов в слое (объекты должны быть из feature.data, чтобы была геометрия и ID)
	this.selectedObjects = [];

	//Запрос для получения идентификаторов в фильтруемых слоях
	//например, PODS_GRID.XML#PODS_ILI_INSPECTION_RANGE
	this.requestFilterData = goog.isDef(options.requestFilterData) ?
		options.requestFilterData : '';
	goog.base(this, options);
};
goog.inherits(map.layer.CASLayer, map.layer.VectorLayer);

//Сеттер и геттер для сохранения коэффициента растяжения по X
map.layer.CASLayer.prototype.setScaleXCoeff = function(coeff){
	if (this.scaleXCoeff_ != coeff){
		this.scaleXCoeff_ = coeff;
		//При любом изменении коэффициента изменяем данные слоя
		this.multLayerData(this.scaleXCoeff_);
	}
};

//Сеттер и геттер для сохранения коэффициента растяжения по X
map.layer.CASLayer.prototype.getScaleXCoeff = function(){
	return this.scaleXCoeff_;
};

/**
 * @param weak флаг слабой ссылки. доступ к слоями из widgetmap.baselayes
 */
map.layer.CASLayer.prototype.loadSpatial = function(weak){
	if(goog.isDef(this.dataProvider) && goog.isDef(this.dataProvider.spatial) && this.dataProvider.spatial != '') {
		if(!goog.isDef(this.spatialVariables))
			this.getProvDataXML(this.dataProvider.spatial);
		else {
			//если переменные уже подгружены, то грузим данные для слоя
			var layerObj = WidgetMap.layerManager.getLayerByName(this.name);
			if(!layerObj)
				layerObj = WidgetMap.layerManager.getLayerByName1(this.name, WidgetMap.baseLayers);
			if(layerObj.visible === 'true' || layerObj.visible == true){
				if(goog.isDef(this.filter))
					this.requestFilterData_();
				else
					this.requestData_();
			}
		}
	}
	else if(goog.isDef(this.loadSpatialCallback))
		this.loadSpatialCallback(this);
};

/**
 * Подгрузка переменных слоя
 * @param source
 */
map.layer.CASLayer.prototype.getProvDataXML = function(source){
	var that = this;
	//Подгружаем все параметры запроса выбранного источника
	if (!this.inSpatialRequest && goog.isDef(source) && source.indexOf("#")>0){
		//Устанавливаем признак процесса загрузки переменных (чтобы не отправлять 2 запроса)
		this.inSpatialRequest = true;
		BlockingUtil.blockApplication();
		BlockingUtil.wait();
		function getLayerGeoReqParams(source,request) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			return {
				getSchema: false,
				descrId: request,
				toElements: false,
				descrType: 'select',
				data:  '<root USER_ID="'+userId.xmlEscape()+
				'" USER_LOGIN="'+userLogin.xmlEscape()+
				'" PODS_USER="'+userLogin.xmlEscape()+
				'" >'+
				'<data file="'+source.split("#")[0]+'" dataId="'+source.split("#")[1]+'" />'+
				'</root>'
			};
		}
		function onProvDataResult(resultXml) {
			that.inSpatialRequest = false;
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					BlockingUtil.ready();
					BlockingUtil.unblockApplication();
					App.errorReport(gis_caslayer_3+source, gis_caslayer_2 + that.sourceDescr + "("+ that.name+gis_caslayer_4 +resultXml, undefined, {filename:gis_filename_2, functionname:'gis_filename_2_1'});
					return;
				}
				//Перед обработкой переменных инициализируем _spatialVariables
				that.spatialVariables = {};
				//var layerGeoXml = ($.parseXML(resultXml)).firstChild;
				var select = resultXml.find("select");
				if(select.length>0 && select[0].getElementsByTagName("geoQuery").length>0){
					var vars = select[0].getElementsByTagName("geoQuery")[0].getElementsByTagName("var");
					var i=0;
					for(; i<vars.length;i++){
						//Получаем переменные запроса select
						var attrName = vars[i].getAttribute('name');
						that.spatialVariables[attrName] = vars[i].getAttribute('default');

					}
				}
				if(goog.isDef(that.spatialVariables.LABEL))
					that.spatialVariables.LABEL = that.spatialVariables.LABEL.replace('\\n','');
				//После получения переменных устанавливаем внутренние переменные в нужные значения
				//Переменные обозначают границы данных по Y, полученные из переменных слоя "Y_MIN" и "Y_MAX" (если таковые имеются)
				that.dataYMin_ = goog.isDef(that.spatialVariables.Y_MIN) ? parseFloat(that.spatialVariables.Y_MIN) : NaN;
				that.dataYMax_ = goog.isDef(that.spatialVariables.Y_MAX) ? parseFloat(that.spatialVariables.Y_MAX) : NaN;
				var cosmeticElementCounter = 0;
				try{
					while(true){

						if(that.spatialVariables["COSMETIC_ELEMENT_"+cosmeticElementCounter] !== undefined){
							var cosmeticElement = that.spatialVariables["COSMETIC_ELEMENT_"+cosmeticElementCounter];
							var spCE = cosmeticElement.split(';');
							var item = {};
							for(var spIndex = 0; spIndex < spCE.length;spIndex++){
								if(spCE[spIndex].indexOf('topology') == 0){
									var spTopo = spCE[spIndex].replace('topology=','');
									item.topology = 'LineString';//по умолчанию линия
									if(spTopo === 'point') item.topology = 'Point';
									if(spTopo === 'polygon') item.topology = 'Polygon';

								}
								if(spCE[spIndex].indexOf('coord') == 0){
									var count_array = spCE[spIndex].replace('coord=','').split(',');
									for(var kk=0; kk<count_array.length;kk++) count_array[kk] = parseFloat(count_array[kk]);
									item.coords = count_array;
								}
								if(spCE[spIndex].indexOf('style') == 0){
									item.style = spCE[spIndex].replace('style=','');
								}
							}
							if(that.checkYCosmetic(item.coords,that.dataYMin_,that.dataYMax_))
								that.cosmeticElements.push(item);
							//that.cosmeticElements.push({id:"COSMETIC_ELEMENT_1",topology:'LineString',coords:[0,0.2,100000000,0.2],style:'COSMETIC_ELEMENT_GREEN'});
						}
						else
							break;
						cosmeticElementCounter++;
					}
				}
				catch(ex){}

				//если определен loadSpatialCallback, то не грузим пока данные
				if(goog.isDef(that.loadSpatialCallback)){
					that.loadSpatialCallback(that);
					that.loadSpatialCallback = undefined;
				}
				else{
					//Успешно получили все переменные - запрашиваем данные
					var layerObj = WidgetMap.layerManager.getLayerByName(that.uniqueLayerName);
					if(layerObj.visible === 'true' || layerObj.visible == true){
						if(goog.isDef(that.filter))
							that.requestFilterData_();
						else
							that.requestData_();
					}
				}
			}
			catch(e){
			}
			finally{
				BlockingUtil.ready();
				BlockingUtil.unblockApplication();
			}
		}
		function onProvDataFault(resultXml) {
			//Снимаем признак процесса загрузки переменных
			BlockingUtil.unblockApplication();
			that.inSpatialRequest = false;
			BlockingUtil.ready();
			App.errorReport(gis_caslayer_7+source, gis_caslayer_2 + that.sourceDescr + "("+ that.name+gis_caslayer_4 +resultXml, undefined, {filename:gis_filename_2, functionname:'gis_filename_2_2'});
		}
		App.serverQueryNodeWithTries(Services.processQueryNodeXml, getLayerGeoReqParams(source,this.requestProviderData), onProvDataResult, onProvDataFault,4);
	}

};


/**
 * Проверка, что косметические линии попадают в границы графика, если они(границы) есть
 * @param coords
 * @param yMin
 * @param yMax
 */
map.layer.CASLayer.prototype.checkYCosmetic = function(coords, yMin, yMax) {
	if(coords.length == 0)
		return false;
	try{
		var maxYCoord = coords[1];
		var minYCoord = coords[1];
		if(isNaN(yMin))
			yMin = minYCoord;
		if(isNaN(yMax))
			yMax = maxYCoord;
		for(var i = 2; i < coords.length; i += 2){
			if(maxYCoord < coords[i+1])
				maxYCoord = coords[i+1];
			if(minYCoord > coords[i+1])
				minYCoord = coords[i+1];
		}
		if(minYCoord < yMin || maxYCoord > yMax)
			return false;
	}
	catch(ex){}

	return true;
};



/**
 * Запрос к данным фильтров, и после этого запрос геометрии по необходимости(если пришли какие-нибудь id)
 * @private
 */
map.layer.CASLayer.prototype.requestFilterData_ = function(){
	var that = this;
	//если слой типа основного оборудования без стартового фильтра, то не запрашиваем id из грида
	//upd. 11.04.22 убираем этот блок, чтобы использовался фильтр FILTER только в geo запросе
	if(true || (that.filter.length == 0 && goog.isDef(that.spatialVariables) && !goog.isDef(that.spatialVariables.START_FILTER))){
		that.requestData_();
		return;
	}
	function getLayerGeoReqParams(filter,request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		var inspectionFilter = '';
		if(WidgetMap.INSPECTION_ID !== undefined)
			inspectionFilter = 'ID="' + WidgetMap.INSPECTION_ID + '"';
		return {
			getSchema: false,
			descrId: request,
			toElements: false,
			descrType: 'select',
			data:  '<root USER_ID="'+userId.xmlEscape()+
			'" USER_LOGIN="'+userLogin.xmlEscape()+
			'" PODS_USER="'+userLogin.xmlEscape()+
			'" >'+
			'<data COLUMNS_FILTER="ID" ' + inspectionFilter + ' FILTER="' + filter + '" LINE_ID="'+WidgetMap.LINE_ID+'" START_KM="'+WidgetMap.BEGIN_KM+'" FINISH_KM="'+WidgetMap.END_KM+'" />'+
			'</root>'
		};
	}
	function onProvDataResult(resultXml) {
		try {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') {
				WidgetMap.totalLayersCount--;
				if(goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(that);
				BlockingUtil.ready();
				return;
			}
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			var filterArr = [];
			for (var i = 0; i < datas.length; i++) {
				//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
				filterArr.push(datas[i].getAttribute("ID"));
			}
			if(filterArr.length > 0){
				that.requestData_(filterArr);
			}
			else{
				WidgetMap.totalLayersCount--;
				if(goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(that);
			}
		}
		catch(e){
		}
		finally{
			BlockingUtil.ready();
		}
	}
	function onProvDataFault(resultXml) {
		WidgetMap.totalLayersCount--;
		//Снимаем признак процесса загрузки переменных
		if(goog.isDef(that.layerLoadCallback))
			that.layerLoadCallback(that);
		BlockingUtil.ready();
	}
	var filterStr = this.parseFilter(this.filter);
	BlockingUtil.wait();
	App.serverQueryXML2Node(Services.processQueryNode, getLayerGeoReqParams(filterStr,this.requestFilterData), onProvDataResult, onProvDataFault);
};


/**
 * Запрос к данным
 * При попытке получения данных сперва получаем переменные из запроса геометрии.
 * Если не смогли получить - считаем что данные мы не запрашивали
 */
map.layer.CASLayer.prototype.requestData_ = function(filterIds) {
	if (!goog.isDef(this.spatialVariables) && goog.isDef(this.dataProvider) && goog.isDef(this.dataProvider.spatial) && this.dataProvider.spatial!=""){
		this.getProvDataXML(this.dataProvider.spatial);
		return;
	}

	var lineId = WidgetMap.LINE_ID, beginKm = WidgetMap.BEGIN_KM, endKm = WidgetMap.END_KM;
	if(this.selectedLineObj){
		lineId = this.selectedLineObj.lineId;
		beginKm = this.selectedLineObj.lineStartKm;
		endKm = this.selectedLineObj.lineEndKm;
	}
	var maxMeasure = WidgetMap.max_km;
	var that = this;
	if(that.isDataLoading_ == true)
		return;
	this.hasData = false;
	if(goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.spatial) && that.dataProvider.spatial != ''){
		this.isDataLoading_ = true;
		BlockingUtil.wait();
		function getLayerGeoReqParams(request) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			var filter = that.parseFilter(that.filter);
			var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
			var filterAsParams = FilterUtil.getFilterStringFromObject(that.filterAsParam);
			var inspectionFilter = '';
			if(WidgetMap.INSPECTION_ID !== undefined)
				inspectionFilter = 'ID="' + WidgetMap.INSPECTION_ID + '"';
			return {
				getSchema: false,
				descrId: request,
				toElements: false,
				descrType: 'select',
				data:  '<root USER_ID="'+userId.xmlEscape()+
				'" USER_LOGIN="'+userLogin.xmlEscape()+
				'" PODS_USER="'+userLogin.xmlEscape()+
				'" ' + topFiltersStr + '' +
				' >'+
				'<data FILTER="' + filter + '" ' + inspectionFilter + ' LINE_ID="'+lineId+'" START_KM="'+beginKm+'" FINISH_KM="'+endKm+'"  ' + filterAsParams + ' />'+
				'</root>'
			};
		}
		function getLayerGeoResult(resultXml) {
			if(!that.canLoadData)//если в момент получения данных уже растровый режим, то не обрабатываем
				return;
			that.dataReady_ = true;
			that.isDataLoading_ = false;
			//Пытаемся сохранить данные в кеш
			that.saveResultToCache(resultXml);
			goog.events.unlisten(WidgetMap.map,
				'moveend',
				map.layer.VectorLayer.prototype.onMoveEnd, false, this);
			try {

				var er = HTTPServiceUtil.getError(resultXml);
				if(er !== ''){
					WidgetMap.totalLayersCount--;
					BlockingUtil.ready();
					App.errorReport(gis_caslayer_8, er, undefined, {filename:gis_filename_2, functionname:'requestData___getLayerGeoResult'});
					return;
				}
				that.internalServerErrorCounter = 0;
				var layerGeoXml = ($.parseXML(resultXml)).firstChild;
				var datas = layerGeoXml.getElementsByTagName("data");
				var stride = 2;

				that.points_ = {};
				that.pointsLabels_ = {};
				that.lines_ = {};
				that.polygons_ = {};
				that.pointsData_ = {};
				that.linesData_ = {};
				that.polygonData_ = {};
				var i = 0;
				for (i; i < datas.length; i++) {
					var idStr = datas[i].getAttribute("ID");
					// Случай нового графика CAS_PODS_CAS_CP_GEO.xml#PI_PS_ON_TO_CURRENT_READING
					// идентификаторы приходят в формате  data ID="161913433|2119"
					var checkId = idStr.split('|')[0];
					//если id не нашли, дальше не обрабатываем геометрию
					if(goog.isDef(filterIds) && filterIds.indexOf(checkId)==-1)
						continue;
					//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
					var format = new ol.format.WKT({dimension: stride});
					var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
					var type = datas[i].getAttribute("TYPE");
					var label = datas[i].getAttribute("LABEL");

					if(!goog.isNull(label)){
						label = label.replace(/""/gm, '"');
						label = label.replace(/Ж(\d)/gm, 'Ø$1');
					}
					var fGeometry = undefined;
					if(goog.isNull(wktStr))
						continue;
					try {
						fGeometry = format.readGeometry(wktStr);
					}
					catch (ex) {
						//для случая с видеозаписями, приходит 3 координаты
						stride = 3;
						format = new map.format.WKT({dimension: stride});
						fGeometry = format.readGeometry(wktStr);
					}
					if(fGeometry.getType() == 'Point' && that.drawTypes.indexOf('point') != -1){
						if(fGeometry.flatCoordinates[0] == -1 && fGeometry.flatCoordinates[1]  == -1)
							continue;
						var ttype = (goog.isNull(type))?'':'/'+type;
						if(!goog.isDef(that.points_[that.uniqueLayerName+ttype]))
							that.points_[that.uniqueLayerName+ttype] = [];
						if(!goog.isDef(globalPointsLabels_[that.uniqueLayerName+ttype]))
							globalPointsLabels_[that.uniqueLayerName+ttype] = [];
						if(!goog.isDef(globalPointsGEOs_[that.uniqueLayerName+ttype]))
							globalPointsGEOs_[that.uniqueLayerName+ttype] = {};
						//не конвертируем данные. т.к. проекци 5807
						that.points_[that.uniqueLayerName+ttype].push(fGeometry.getFlatCoordinates());
						globalPointsLabels_[that.uniqueLayerName+ttype].push({label:label,id:idStr,geo:fGeometry});
						globalPointsGEOs_[that.uniqueLayerName+ttype][idStr] = fGeometry;
					}
					if(fGeometry.getType() == 'LineString' && that.drawTypes.indexOf('line') != -1){
						var ttype = (goog.isNull(type))?'':'/'+type;
						if(!goog.isDef(that.lines_[that.uniqueLayerName+ttype]))
							that.lines_[that.uniqueLayerName+ttype] = [];
						if(!goog.isDef(globalLinesLabels_[that.uniqueLayerName+ttype]))
							globalLinesLabels_[that.uniqueLayerName+ttype] = [];
						if(!goog.isDef(globalLinesGEOs_[that.uniqueLayerName+ttype]))
							globalLinesGEOs_[that.uniqueLayerName+ttype] = {};
						that.lines_[that.uniqueLayerName+ttype].push(fGeometry);
						//не конвертируем данные. т.к. проекци 5807
						globalLinesLabels_[that.uniqueLayerName+ttype].push({label:label,id:idStr,geo:fGeometry});
						globalLinesGEOs_[that.uniqueLayerName+ttype][idStr] = fGeometry;
					}
					if(fGeometry.getType() == 'Polygon' && that.drawTypes.indexOf('polygon') != -1){
						if(that.name && (that.name.indexOf('CAS_PROFILE') !== -1 || that.name.indexOf('CAS_MAIN') !== -1))
							fGeometry = that.scaleBaseGeometry(fGeometry);
						var ttype = (goog.isNull(type))?'':'/'+type;
						if(!goog.isDef(that.polygons_[that.uniqueLayerName+ttype]))
							that.polygons_[that.uniqueLayerName+ttype] = [];
						if(!goog.isDef(globalPolygonsLabels_[that.uniqueLayerName+ttype]))
							globalPolygonsLabels_[that.uniqueLayerName+ttype] = [];
						if(!goog.isDef(globalPolygonsGEOs_[that.uniqueLayerName+ttype]))
							globalPolygonsGEOs_[that.uniqueLayerName+ttype] = {};
						that.polygons_[that.uniqueLayerName+ttype].push(fGeometry);
						globalPolygonsLabels_[that.uniqueLayerName+ttype].push({label:label,id:idStr,geo:fGeometry});
						//не конвертируем данные. т.к. проекци 5807
						globalPolygonsGEOs_[that.uniqueLayerName+ttype][idStr] = fGeometry;
					}
				}
				var pArr = [];
				var stName;
				for (stName in that.polygons_){
					that.hasData = true;
					var geometry = new ol.geom.MultiPolygon(null);
					geometry.setPolygons(that.polygons_[stName]);
					var newPolygonFeature = new ol.Feature(geometry);
					newPolygonFeature.set('layerId',that.uniqueLayerName);
					newPolygonFeature.set('spacing',that.spacing);
					newPolygonFeature.set('labelType', stName);
					newPolygonFeature.set('dataProviderStyle', that.dataProvider.style);
					newPolygonFeature.set('zIndex',that.zIndex);
					newPolygonFeature.set('type',stName.replace('/','_'));
					newPolygonFeature.set('labelsObj', globalPolygonsLabels_[stName]);
					newPolygonFeature.set('labelsObjAll', globalPolygonsLabels_[stName]);
					newPolygonFeature.set('pointsObj', globalPolygonsGEOs_[stName]);//текущие, которые обрабатываются
					newPolygonFeature.set('pointsObjAll', globalPolygonsGEOs_[stName]);//все объекты
					newPolygonFeature.set('type',stName.replace('/','_'));
					newPolygonFeature.setStyle(function(resolution){
						var lId = this.get('layerId').split('#')[0];
						var splitted = this.get('type').split('#');
						var lType = splitted[0];//из типа надо вычленить уникальный id: от # до первого _
						var typeStr = '';
						if(splitted.length>1){
							var sp = splitted[1].split('_');
							if(sp.length>1){
								//удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
								sp.splice(0,1);
								typeStr ='_'+sp.join('_');
								lType += typeStr;
							}
						}
						var s;
						if(that.groupIndex !== undefined){
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('GROUP_POSITION_HORIZONTAL_' + that.groupIndex,'Polygon');
							if(!goog.isNull(s) && !goog.isNull(s.style)){
								return [s.style];
							}
						}

						//если определен стиль, описанный в dataProvider для слоя в *_layers.xml
						var allowText = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
						//если определен стиль, описанный в dataProvider для слоя в *_layers.xml
						//с типом
						if(goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.style)){
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(that.dataProvider.style+typeStr,'Polygon');
							allowText  = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
							if(!goog.isNull(s) && !goog.isNull(s.style)){
								if(allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(that.dataProvider.style+typeStr,'Polygon');
									if(!goog.isNull(textstyle))
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								return [s.style];
							}
						}
						//если определен стиль, описанный в dataProvider для слоя в *_layers.xml
						//без типа
						if(goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.style)){
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(that.dataProvider.style,'Polygon');
							allowText  = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
							if(!goog.isNull(s) && !goog.isNull(s.style)){
								if(allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(that.dataProvider.style,'Polygon');
									if(!goog.isNull(textstyle))
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								return [s.style];
							}
						}
						s = (goog.isNull(lId))?null:WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lType,'Polygon');
						allowText = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
						if(!goog.isNull(s) && !goog.isNull(s.style)){
							if(allowText){
								var textstyle = WidgetMap.layerManager.getTextStyle(lType);
								if(!goog.isNull(textstyle))
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if(goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lId,'Polygon');
						if(!goog.isNull(s) && !goog.isNull(s.style)){
							if(allowText){
								var textstyle = WidgetMap.layerManager.getTextStyle(lId);
								if(!goog.isNull(textstyle))
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if(goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT','Polygon');
						if(!goog.isNull(s) && !goog.isNull(s.style)){
							if(allowText){
								var textstyle = WidgetMap.layerManager.getTextStyle(lId);
								if(!goog.isNull(textstyle) && mapZoom >= textstyle.zoomMin && mapZoom <= textstyle.zoomMax)
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							else
								that.setTextStyle(s.style, null);
							if(goog.isArray(s.style))
								return s.style;
							return [s.style];
						}
						return null;
					});
					pArr.push(newPolygonFeature);
					delete that.polygons_[stName];
					delete that.polygonData_[stName];
				}

				for (stName in that.lines_){
					that.hasData = true;
					var geometry = new ol.geom.MultiLineString(null);
					geometry.setLineStrings(that.lines_[stName]);
					var newLineFeature = new ol.Feature(geometry);
					newLineFeature.set('layerId',that.uniqueLayerName);
					newLineFeature.set('spacing',that.spacing);
					newLineFeature.set('zIndex',that.zIndex);
					newLineFeature.set('labelType', stName);
					newLineFeature.set('dataProviderStyle', that.dataProvider.style);
					newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
					newLineFeature.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
					newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
					newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);//все объекты
					newLineFeature.set('type',stName.replace('/','_'));
					newLineFeature.setStyle(function(resolution){
						var lId = this.get('layerId').split('#')[0];
						var splitted = this.get('type').split('#');
						var lType = splitted[0];//из типа надо вычленить уникальный id: от # до первого _
						var typeStr = '';
						if(splitted.length>1){
							var sp = splitted[1].split('_');
							if(sp.length>1){
								//удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
								sp.splice(0,1);
								typeStr ='_'+sp.join('_');
								lType += typeStr;
							}
						}
						var s;
						if(that.groupIndex !== undefined){
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('GROUP_POSITION_HORIZONTAL_' + that.groupIndex,'LineString');
							if(!goog.isNull(s) && !goog.isNull(s.style)){
								return [s.style];
							}
						}

						var allowText  = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
						//если определен стиль, описанный в dataProvider для слоя в *_layers.xml
						//с типом
						if(goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.style)){
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(that.dataProvider.style+typeStr,'LineString');
							allowText  = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
							if(!goog.isNull(s) && !goog.isNull(s.style)){
								if(goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(that.dataProvider.style+typeStr,'LineString');
									if(!goog.isNull(textstyle))
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);
								}
								if(goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
						}
						//если определен стиль, описанный в dataProvider для слоя в *_layers.xml
						//без типа
						if(goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.style)){
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(that.dataProvider.style,'LineString');
							allowText  = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
							if(!goog.isNull(s) && !goog.isNull(s.style)){
								if(goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(that.dataProvider.style,'LineString');
									if(!goog.isNull(textstyle))
										that.setTextStyle(s.style, textstyle);
									else
										that.setTextStyle(s.style, null);

								}
								if(goog.isArray(s.style))
									return [s.style[0]];
								return [s.style];
							}
						}
						s = (goog.isNull(this.get('layerId')))?null:WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lType,'LineString');
						if(!goog.isNull(s) && !goog.isNull(s.style)){
							if(goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(lType,'LineString');
								if(!goog.isNull(textstyle))
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							if(goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lId,'LineString');
						if(!goog.isNull(s) && !goog.isNull(s.style)){
							if(goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(lId,'LineString');
								if(!goog.isNull(textstyle))
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);
							}
							if(goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT','LineString');
						if(!goog.isNull(s && !goog.isNull(s.style))){
							if(goog.isDef(globalLinesLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT','LineString');
								if(!goog.isNull(textstyle))
									that.setTextStyle(s.style, textstyle);
								else
									that.setTextStyle(s.style, null);

							}
							if(goog.isArray(s.style))
								return [s.style[0]];
							return [s.style];
						}
						return null;
					});
					pArr.push(newLineFeature);
					delete that.lines_[stName];
					delete that.linesData_[stName];
				}
				for (stName in that.points_){
					that.hasData = true;
					var geometry = new ol.geom.MultiPoint(null);
					geometry.setCoordinates(that.points_[stName],ol.geom.GeometryLayout.XY);

					var newPointFeature = new ol.Feature(geometry);
					newPointFeature.set('layerId',that.uniqueLayerName);
					newPointFeature.set('spacing',that.spacing);
					newPointFeature.set('zIndex',that.zIndex);
					newPointFeature.set('dataProviderStyle', that.dataProvider.style);
					newPointFeature.set('labelType', stName);
					newPointFeature.set('labelsObj', globalPointsLabels_[stName]);
					newPointFeature.set('pointsObj', globalPointsGEOs_[stName]);
					newPointFeature.set('pointsObjAll', globalPointsGEOs_[stName]);//все объекты
					newPointFeature.set('labelsObjAll', globalPointsLabels_[stName]);
					newPointFeature.set('type',stName.replace('/','_'));
					newPointFeature.set('mapName',that.layerQueryId);
					newPointFeature.setStyle(function(resolution){
						var lId = this.get('layerId').split('#')[0];
						var splitted = this.get('type').split('#');
						var lType = splitted[0];//из типа надо вычленить уникальный id: от # до первого _
						var typeStr = '';
						if(splitted.length>1){
							var sp = splitted[1].split('_');
							if(sp.length>1){
								//удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
								sp.splice(0,1);
								typeStr ='_'+sp.join('_');
								lType += typeStr;
							}
						}
						var s;
						if(that.groupIndex !== undefined){
							var horizontalStyle = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('GROUP_POSITION_HORIZONTAL_' + that.groupIndex,'Point');
							var origPointStyle = WidgetMap.layerManager.getOrigPointStyleByNameAndType([that.dataProvider.style + typeStr, lType, lId] ,'Point');
							if(origPointStyle && origPointStyle.pointObj && origPointStyle.pointObj.form === 'bitmap'){
								horizontalStyle = origPointStyle;
							}
							if(!goog.isNull(horizontalStyle) && !goog.isNull(horizontalStyle.style)){
								return [horizontalStyle.style];
							}
						}

						var allowText  = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
						//если определен стиль, описанный в dataProvider для слоя в *_layers.xml
						//с типом
						if(goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.style)){
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(that.dataProvider.style+typeStr,'Point');
							allowText  = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
							if(!goog.isNull(s) && !goog.isNull(s.style)){
								if(goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(that.dataProvider.style+typeStr,'Point');
									if(!goog.isNull(textstyle))
										that.setTextStyle(s.style, textstyle, true);
									else
										that.setTextStyle(s.style, null, true);

								}
								//устанавливаем типа иконки, чтобы при отрисовки не учитывали на hasCollision max_x = Math.floor((x + obj.width)/_dx);
								if(s.style.getImage() instanceof ol.style.Icon)
									this.set('styleType','icon');
								else
									this.set('styleType','mark');
								return [s.style];
							}
						}
						//если определен стиль, описанный в dataProvider для слоя в *_layers.xml
						//без типа
						if(goog.isDef(that.dataProvider) && goog.isDef(that.dataProvider.style)){
							s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(that.dataProvider.style,'Point');
							allowText  = WidgetMap.layerManager.isTextAllowedByCASLayerName(this.get('layerId'));
							if(!goog.isNull(s) && !goog.isNull(s.style)){
								if(goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
									var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(that.dataProvider.style,'Point');
									if(!goog.isNull(textstyle))
										that.setTextStyle(s.style, textstyle, true);
									else
										that.setTextStyle(s.style, null, true);

								}
								//устанавливаем типа иконки, чтобы при отрисовки не учитывали на hasCollision max_x = Math.floor((x + obj.width)/_dx);
								if(s.style.getImage() instanceof ol.style.Icon)
									this.set('styleType','icon');
								else
									this.set('styleType','mark');
								return [s.style];
							}
						}
						s = (goog.isNull(this.get('layerId')))?null:WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lType,'Point');
						if(!goog.isNull(s) && !goog.isNull(s.style)){
							if(goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(lType,'Point');
								if(!goog.isNull(textstyle))
									that.setTextStyle(s.style, textstyle, true);
								else
									that.setTextStyle(s.style, null, true);
							}
							//устанавливаем типа иконки, чтобы при отрисовки не учитывали на hasCollision max_x = Math.floor((x + obj.width)/_dx);
							if(s.style.getImage() instanceof ol.style.Icon)
								this.set('styleType','icon');
							else
								this.set('styleType','mark');
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lId,'Point');
						if(!goog.isNull(s) && !goog.isNull(s.style)){
							if(goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(lId,'Point');
								if(!goog.isNull(textstyle) )
									that.setTextStyle(s.style, textstyle, true);
								else
									that.setTextStyle(s.style, null, true);
							}
							//устанавливаем типа иконки, чтобы при отрисовки не учитывали на hasCollision max_x = Math.floor((x + obj.width)/_dx);
							if(s.style.getImage() instanceof ol.style.Icon)
								this.set('styleType','icon');
							else
								this.set('styleType','mark');
							return [s.style];
						}
						s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT','Point');
						if(!goog.isNull(s) && !goog.isNull(s.style)){
							if(goog.isDef(globalPointsLabels_[this.get('labelType')]) && allowText) {
								var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType('DEFAULT','Point');
								if(!goog.isNull(textstyle))
									that.setTextStyle(s.style, textstyle, true);
								else
									that.setTextStyle(s.style, null, true);
							}
							//устанавливаем типа иконки, чтобы при отрисовки не учитывали на hasCollision max_x = Math.floor((x + obj.width)/_dx);
							if(s.style.getImage() instanceof ol.style.Icon)
								this.set('styleType','icon');
							else
								this.set('styleType','mark');
							return [s.style];
						}
						return null;
					});
					pArr.push(newPointFeature);

					delete that.pointsLabels_[stName];
					delete that.points_[stName];
					delete that.pointsData_[stName];
				}
				if(pArr.length>0)
					that.featureProjLayer.getSource().getSource().addFeatures(pArr);
				delete pArr;
				that.fillCosmetic_();
				that.multLayerData(that.scaleXCoeff_);
				if((that.fitMap == true && that.featureProjLayer.getSource().getSource().getFeatures().length > 0 )){
					if(that.canFirstTimeCentering == true){
						var extent = that.featureProjLayer.getSource().getSource().getExtent();
						WidgetMap.centerOnMap(extent);
						that.featureProjLayer.setVisible(true);						
					}
					that.canFirstTimeCentering = true;
				}

			}
			catch (ex) {
				that.dataReady_ = true;
				that.isDataLoading_ = false;
				App.errorReport(gis_caslayer_8, ex, undefined, {filename:gis_filename_2, functionname:'requestData__getLayerGeoResult_1', datatext:gis_caslayer_5+that.name+gis_caslayer_6+resultXml});
			}
			finally{
				BlockingUtil.ready();
				WidgetMap.totalLayersCount--;
				if(goog.isDef(that.layerLoadCallback))
					that.layerLoadCallback(that, maxMeasure);
				//WidgetMap.moveAllLayersToPosition();
			}
		}

		function getLayerGeoFault(resultXml) {
			if(that.internalServerErrorCounter > 1)
				if(resultXml.indexOf('Internal Server Error') != -1 || resultXml.indexOf('. error. ') != -1 || resultXml.indexOf('. Error. ') != -1 || resultXml.indexOf('. Error ') != -1) {
					--that.internalServerErrorCounter;
					that.dataReady_ = false;
					that.isDataLoading_ = false;
					BlockingUtil.ready();
					that.requestData_();
					return;
				}
			that.internalServerErrorCounter = 0;
			WidgetMap.totalLayersCount--;
			//WidgetMap.moveAllLayersToPosition();
			that.dataReady_ = true;
			if(goog.isDef(that.layerLoadCallback))
				that.layerLoadCallback(that);
			BlockingUtil.ready();
			that.isDataLoading_ = false;
			App.errorReport(gis_caslayer_8, resultXml, undefined, {filename:gis_filename_2, functionname:'requestData__getLayerGeoFault'});
		}

		//Получаем данные из кеша
		var layerDataCache = this.getDataFromCache();
		if(goog.isDefAndNotNull(layerDataCache)){
			getLayerGeoResult(layerDataCache.result);
		}
		else
			App.serverQueryXML2Node(Services.processQueryNodeGeo, getLayerGeoReqParams(that.dataProvider.spatial), getLayerGeoResult, getLayerGeoFault);
	}
};

map.layer.CASLayer.prototype.fillCosmetic_ = function() {
	var that = this;
	if(this.cosmeticElements.length == 0)
		return;
	that.lines_ = {};
	that.linesData_ = {};
	var i = 0;
	for (i; i < this.cosmeticElements.length; i++) {
		var elem = this.cosmeticElements[i];
		var idStr = elem.id;
		//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
		var type = elem.style;
		var linePntArr = [];
		var stride = 2;
		for (var kk=0; kk < elem.coords.length; kk += stride){
			linePntArr.push([elem.coords[kk],elem.coords[kk+1]]);
		}
		if(linePntArr.length == 0 ) break;
		//Добавляем косметику
		var fGeometry = new ol.geom.LineString(linePntArr,ol.geom.GeometryLayout.XY);
		if(fGeometry.getType() == 'LineString'){
			var ttype = (goog.isNull(type))?'':'/'+type;
			if(!goog.isDef(that.lines_[that.uniqueLayerName+ttype]))
				that.lines_[that.uniqueLayerName+ttype] = [];
			if(!goog.isDef(globalLinesLabels_[that.uniqueLayerName+ttype]))
				globalLinesLabels_[that.uniqueLayerName+ttype] = [];
			if(!goog.isDef(globalLinesGEOs_[that.uniqueLayerName+ttype]))
				globalLinesGEOs_[that.uniqueLayerName+ttype] = {};
			that.lines_[that.uniqueLayerName+ttype].push(fGeometry);
			//не конвертируем данные. т.к. проекци 5807
			globalLinesLabels_[that.uniqueLayerName+ttype].push({label:'',id:idStr,geo:fGeometry});
			globalLinesGEOs_[that.uniqueLayerName+ttype][idStr] = fGeometry;
		}

	}
	var pArr = [];
	var stName;
	for (stName in that.lines_){
		var geometry = new ol.geom.MultiLineString(null);
		geometry.setLineStrings(that.lines_[stName]);
		var newLineFeature = new ol.Feature(geometry);
		newLineFeature.set('layerId',that.uniqueLayerName);
		newLineFeature.set('spacing',that.spacing);
		newLineFeature.set('zIndex',that.zIndex);
		newLineFeature.set('featureType','cosmetic');
		newLineFeature.set('labelType', stName);
		newLineFeature.set('dataProviderStyle', that.dataProvider.style);
		newLineFeature.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
		newLineFeature.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
		newLineFeature.set('pointsObj', globalLinesGEOs_[stName]);
		newLineFeature.set('pointsObjAll', globalLinesGEOs_[stName]);//все объекты
		newLineFeature.set('type',stName.replace('/','_'));
		newLineFeature.setStyle(function(resolution){
			var lType = this.get('labelType').split('/')[1];
			var s;
			s = (goog.isNull(this.get('layerId')))?null:WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lType,'LineString');
			if(!goog.isNull(s) && !goog.isNull(s.style)){
				if(goog.isArray(s.style))
					return [s.style[0]];
				return [s.style];
			}
			s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT','LineString');
			if(!goog.isNull(s && !goog.isNull(s.style))){
				if(goog.isArray(s.style))
					return [s.style[0]];
				return [s.style];
			}
			return null;
		});
		pArr.push(newLineFeature);
		delete that.lines_[stName];
		delete that.linesData_[stName];
	}
	if(pArr.length>0)
		that.featureProjLayer.getSource().getSource().addFeatures(pArr);
	delete pArr;
	//that.multLayerData(that.scaleXCoeff_);
};



//Умножение всех данных слоя на коэффициент масштабирования по оси X
//Функция для умножения на коэффициент геометрии слоя (без перерисовки)
map.layer.CASLayer.prototype.multLayerData = function(scaleX){
	//Оптимизация - если коэффициент растяжения = 1, ничего не делаем (данные останутся как есть)
	if (scaleX==1)
		return;
	var mapFtrLayer = this.featureProjLayer;
	var fs = mapFtrLayer.getSource().getSource().getFeatures();
	//Далее растягиваем данные слоя по X на коэффициент растяжения scaleXCoeff
	var i = 0;
	for(;i<fs.length;i++){
		var geometry = fs[i].getGeometry();
		if(goog.isDefAndNotNull(geometry)){
			var coords = geometry.flatCoordinates;
			var newCoords  = [];//of Array.<ol.Coordinate>
			var stride = geometry.stride;
			goog.asserts.assert(coords.length % stride === 0);
			var j;
			for ( j = 0; j < coords.length; j += stride) {
				newCoords.push(coords[j]*scaleX);
				newCoords.push(coords[j+1]);
			}
			if(geometry.getType() === ol.geom.GeometryType.POLYGON || geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
				geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
			else if(geometry.getType() === ol.geom.GeometryType.MULTI_POLYGON)
				geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
			else
				geometry.setFlatCoordinates(geometry.layout,newCoords);
		}
	}
};

/**
 * Функция смещения геометрии слоя по заданным параметрам позиции, высоты, типа диаграммы в заданную позицию по оси Y
 * @param {Number} layPosition
 * @param {Number} layHeight
 * @param {String} layDiagType
 * @param {Boolean} rollback
 * @param {Number} ySteps
 * @param {Number} globalMinY
 * @param {Number} globalMaxY
 */
map.layer.CASLayer.prototype.moveLayerToPosition = function(layPosition, layHeight, layDiagType, rollback, ySteps, globalMinY, globalMaxY){
	//Сохраняем переменные, необходимые для определения позиции и растяжения слоя по Y
	this.layPosition_ = layPosition;
	this.layHeight_ = layHeight;
	this.layDiagType_ = layDiagType;
	this.ySteps_ = ySteps;
	//Смещаем и растягиваем данные по оси Y
	if(goog.isDef(this.featureProjLayer)){
		//Сохраняем минимальное и максимальное значения до трансформации
		//нужно для нанесения на карту легенды вертикальной шкалы по реальным значениям
		var maxGeoBounds = Number.NEGATIVE_INFINITY;
		var minGeoBounds = Number.POSITIVE_INFINITY;
		//Обрабатываем все геометрии
		var fs = this.featureProjLayer.getSource().getSource().getFeatures();
		//Заранее определяем максимальную и минимальную границу данных по Y.
		//Если слой 2D и для него установлены переменные dataYMin и dataYMax - устанавливаем их как границы
		if ((layDiagType=='2D' || layDiagType == 'interval')
			&& !isNaN(this.dataYMin_) && !isNaN(this.dataYMax_)){
			minGeoBounds = this.dataYMin_;
			maxGeoBounds = this.dataYMax_;
		}
		else{ //иначе берем границы по данным
			var i = 0;
			for (; i < fs.length; i++){
				var curFtr = fs[i];
				var ext = curFtr.getGeometry().getExtent();
				if (maxGeoBounds<ol.extent.getTopLeft(ext)[1]) maxGeoBounds = ol.extent.getTopLeft(ext)[1];
				if (minGeoBounds>ol.extent.getBottomLeft(ext)[1]) minGeoBounds = ol.extent.getBottomLeft(ext)[1];
			}
		}

		/*if(this.groupId){
			var casBounds = WidgetMap.layerManager.getCasGeoBoundsByName(this.groupId);
			maxGeoBounds = casBounds.max;
			minGeoBounds = casBounds.min;
		}*/

		//устанавливаем 1 раз оригинальные значения;
		if(isNaN(this.originalMaxValue_))
			this.originalMaxValue_ = maxGeoBounds;
		if(isNaN(this.originalMinValue_))
			this.originalMinValue_ = minGeoBounds;


		if(!isNaN(globalMinY))
			minGeoBounds = globalMinY;
		if(!isNaN(globalMaxY))
			maxGeoBounds = globalMaxY;


		var geomPosition = layPosition;
		//Коэффициент растяжения по Y - применяется если диаграмма 2D
		var yCoeff = 1;
		//изменяем позицию если 2D - диаграмма начинается c низа
		if (layDiagType === '2D' || layDiagType === 'interval'){
			//Для двухмерных диаграмм ВСЕГДА нужно растягиваться в высоту по общим границам!
			//Особо нужно обработать случай, когда maxGeoBounds==minGeoBounds - в этом случае yCoeff должен быть равен 1
			if (maxGeoBounds!=minGeoBounds)
				yCoeff = layHeight / Math.abs(maxGeoBounds - minGeoBounds);
		}
		else{
			geomPosition = layPosition + layHeight/2;
		}
		//Если rollback==true, откатываемся!
		if (rollback){
			//Смещение обратно в начальное состояние: мы должны поменять местами geomPosition и minGeoBounds,
			//поскольку смещение с растяжением рассчитывается по формуле newY = (oldY + startYOffset) * yCoeff + yOffset
			//значит для отката мы должны применить формулу oldY = (newY - yOffset) * 1/yCoeff - startYOffset
			yCoeff = 1/this.scaleYCoeff_;
			minGeoBounds = geomPosition;
			if(!isNaN(globalMinY))
				geomPosition = globalMinY;
			else
				geomPosition = this.originalMinValue_;
			if(yCoeff == 1){
				minGeoBounds = 0;
				geomPosition = 0;
			}
		}
		for(var f in fs){
			//Смещаем конкретную feature в свою позицию по полученным параметрам
			this.moveFeatureToPosition(fs[f], geomPosition, yCoeff, -minGeoBounds);
		}

		//После смещения всех feature в свои позиции перезатираем текущий коэффициент растяжения 2D графика по оси Y
		this.scaleYCoeff_ = yCoeff;
	}
};

/**
 * Функция смещения геометрии одной feature по заданным параметрам позиции, высоты, типа диаграммы в заданную позицию по оси Y
 * feature необязательно должна принадлежать этому слою!
 * @param {ol.Feature} f
 * @param {Number} geomPosition
 * @param {Number} yCoeff
 * @param {Number} minGeoBounds
 */
map.layer.CASLayer.prototype.moveFeatureToPosition = function(f, yOffset, yCoeff, startYOffset){
	var geometry = f.getGeometry();
	if(goog.isDefAndNotNull(geometry)){
		var coords = geometry.flatCoordinates;
		var newCoords  = [];//of Array.<ol.Coordinate>
		var stride = geometry.stride;
		goog.asserts.assert(coords.length % stride === 0);
		var j;
		for ( j = 0; j < coords.length; j += stride) {
			newCoords.push(coords[j]);
			newCoords.push((coords[j+1] + startYOffset) * yCoeff + yOffset);
		}
		if(geometry.getType() === ol.geom.GeometryType.POLYGON || geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
			geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
		else if(geometry.getType() === ol.geom.GeometryType.MULTI_POLYGON)
			geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
		else
			geometry.setFlatCoordinates(geometry.layout,newCoords);
	}
};


/**
 * Функция загрузки файла фильтра, указанного в переменной слоя "FILTERED_CLASS"
 */
map.layer.CASLayer.prototype.loadFilterFile = function(closeCallback,addParams){
	if(goog.isDef(this.spatialVariables) && goog.isDef(this.spatialVariables.FILTERED_CLASS)){
		var that = this;
		//Устанавливаем признак процесса загрузки переменных (чтобы не отправлять 2 запроса)
		BlockingUtil.blockApplication();
		BlockingUtil.wait();
		function getFilterParams(requestGetXMLFile) {
			var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
			var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
			return {
				getSchema: false,
				descrId: requestGetXMLFile,
				toElements: false,
				descrType: 'select',
				data:  '<root USER_ID="'+userId.xmlEscape()+
				'" USER_LOGIN="'+userLogin.xmlEscape()+
				'" PODS_USER="'+userLogin.xmlEscape()+
				'" >'+
				'<data data_id="'+that.name+'" file="cas_pods_filters.xml" />'+
				//'<data data_id="'+that.spatialVariables.FILTERED_CLASS.replace('_LIST','')+'" file="cas_pods_filters.xml" />'+
				'</root>'
			};
		}
		function onFilterResult(resultXml) {
			BlockingUtil.ready();
			BlockingUtil.unblockApplication();
			try {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== '') {
					App.errorReport(gis_caslayer_9, resultXml, undefined, {filename:gis_filename_2, functionname:'gis_filename_2_5'});
				}
				else{
					//Перед обработкой переменных инициализируем _spatialVariables
					var layerGeoXml = $($.parseXML(resultXml)).find('filters');
					//фильтры со спискомаи
					var dp = $(layerGeoXml).attr('dataProvider');
					that.requestFilterData = dp;
					var links = $(layerGeoXml).children('link');
					//скалярные фильтры
					var scalars = $(layerGeoXml).children('property');
					var i = 0;
					var linksArr = [];
					for (i; i < links.length; i++) {
						//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
						var lName = $(links[i]).attr("name");
						var lDataProvider = $(links[i]).attr("dataProvider");
						var lDataField = $(links[i]).attr("dataField");
						var lLimit = $(links[i]).attr("limit");
						var obj = {name:lName,dataProvider:lDataProvider,type:'array',dataField:lDataField,limit:lLimit};
						linksArr.push(obj);

						//добавляем в общие фильтры, если какого-то нет
						if(!goog.isDef(WidgetMap.commonFilters[lDataField]))
							WidgetMap.commonFilters[lDataField] = obj;
					}
					var scalarsArr = [];
					for (i=0; i < scalars.length; i++) {
						var lName = $(scalars[i]).attr("name");
						var lType = $(scalars[i]).attr("type");
						var lDataField = $(scalars[i]).attr("dataField");
						scalarsArr.push({name:lName,type:lType,dataField:lDataField});
					}
					var casFilterForm = new CASFilterForm({
						addParams:addParams,
						commonFilters:WidgetMap.commonFilters,
						datas:linksArr.concat(scalarsArr),layer:that,
						closeCallback:function(layer, filter){
							if(goog.isDef(filter))
								layer.filter = filter;
								if(goog.isDef(closeCallback))
									closeCallback(that);
							}
					});
					casFilterForm.build();
				}
			}
			catch(e){
			}
		}
		function onFilterFault(resultXml) {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '') 
				App.errorReport(gis_caslayer_9, er, undefined, {filename:gis_filename_2, functionname:'gis_filename_2_7'});
			//Снимаем признак процесса загрузки переменных
			BlockingUtil.unblockApplication();
			BlockingUtil.ready();
		}
		var requestGetXMLFile = 'GAZPROM_SYS_SEM.xml#GET_CAS_FILTER';
		//this.loadFiltersFromLayers(closeCallback, addParams);
		App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getFilterParams(requestGetXMLFile), onFilterResult, onFilterFault);
	}
	else{
		App.errorReport(map.layer.CASLayer.ILLEGAL_TO_FILTER_LAYER,map.layer.CASLayer.ILLEGAL_TO_FILTER_LAYER, undefined, {filename:gis_filename_2, functionname:'gis_filename_2_6'});
	}
};

/**
 * Загрузка фильтра из файлов слоёв, чтобы избавиться от использования запроса SYS_SEM.xml#GET_FILTER и парсинга файлов гридов
 */
map.layer.CASLayer.prototype.loadFiltersFromLayers = function(closeCallback, addParams){
	var that = this;
	try {
		//Перед обработкой переменных инициализируем _spatialVariables
		//<filters dataProvider="PODS_GRID.xml#PODS_VENT_PIPE">
		//  <link name="Тип труб-да" dataProvider="PODS_POLICY.xml#PODS_ROUTE_TYPE_GRID" dataField="ROUTE_TYPE_CL" />
		//  <property name="Км. устан." dataField="STATION" type="number" />
		// </filters>
		var layerGeoXml = this.filtersXml;
		if(layerGeoXml){
			//фильтры со спискомаи
			var dp = $(layerGeoXml).attr('dataProvider');
			that.requestFilterData = dp;
			var links = $(layerGeoXml).children('link');
			//скалярные фильтры
			var scalars = $(layerGeoXml).children('property');
		}

		var i = 0;
		var linksArr = [];
		var scalarsArr = [];
		for (i; i < links.length; i++) {
			//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
			var lName = $(links[i]).attr("name");
			var lDataProvider = $(links[i]).attr("dataProvider");
			var lDataField = $(links[i]).attr("dataField");
			var lLimit = $(links[i]).attr("limit");
			var obj = {name:lName,dataProvider:lDataProvider,type:'array',dataField:lDataField,limit:lLimit};
			linksArr.push(obj);

			//добавляем в общие фильтры, если какого-то нет
			if(!goog.isDef(WidgetMap.commonFilters[lDataField]))
				WidgetMap.commonFilters[lDataField] = obj;
		}

		for (i=0; i < scalars.length; i++) {
			var lName = $(scalars[i]).attr("name");
			var lType = $(scalars[i]).attr("type");
			var lDataField = $(scalars[i]).attr("dataField");
			scalarsArr.push({name:lName,type:lType,dataField:lDataField});
		}
		var casFilterForm = new CASFilterForm({
			addParams:addParams,
			commonFilters:WidgetMap.commonFilters,
			datas:linksArr.concat(scalarsArr),layer:that,
			closeCallback:function(layer, filter){
				if(goog.isDef(filter))
					layer.filter = filter;
				if(goog.isDef(closeCallback))
					closeCallback(that);
			}
		});
		casFilterForm.build();
	}
	catch(e){
		App.errorReport(gis_caslayer_9, e.message, undefined, {filename:gis_filename_2, functionname:'gis_filename_2_5'});
	}
	finally{
		BlockingUtil.unblockApplication();
		BlockingUtil.ready();
	}
};

/**
 * Преобразование фильтра в строку для передачи в запрос
 * @param {Array.<Object>} filter
 * @returns {string}
 */
map.layer.CASLayer.prototype.parseFilter = function(filter){
	if(goog.isDef(filter))
		return FilterUtil.getFilterString(filter);
	return '8=8';
};


/**
 * Установка стиля текстовой подписи для стиля фичи
 * @param style
 * @param textStyle
 */
map.layer.CASLayer.prototype.setTextStyle = function(style, textstyle, isPoint){
	if(!goog.isNull(textstyle)){
		var textAlign = ['left','middle'];
		if(goog.isDef(textstyle.align)){
			if((textstyle.align.indexOf('|') != -1))
				textAlign = textstyle.align.split('|');
			else{
				if(textstyle.align.indexOf('bottom')!=-1 || textstyle.align.indexOf('top')!=-1 || textstyle.align.indexOf('middle')!=-1)
					textAlign = ['right','top'];
				else
					textAlign = [textstyle.align,'middle'];
			}
		}
		var align = textAlign[0];

		var baseline = textAlign[1];
		if(isPoint == true){
			align = 'center';
			baseline = 'bottom';
		}

		var size = goog.isDef(textstyle.fontSize)?textstyle.fontSize+'px':'';
		var offsetX = 0;//-10;
		var offsetY = 0;
		//если стиль точечный и размеры иконок есть, то учитываем при сдвигах
		var iconOffsetX = 0;
		var iconOffsetY = 0;
		if(!goog.isArray(style) && !goog.isNull(style.image_)){
			var imageSize = style.getImage().getSize();
			iconOffsetX = imageSize[0]/2;
			iconOffsetY = imageSize[1]-3;
		}
		if(align == 'left'){
			align = 'right';
			offsetX = -iconOffsetX;//-10;
		}
		else if(align == 'right'){
			align = 'left';
			offsetX = iconOffsetX;//3;
		}
		if(baseline == 'top'){
			baseline = 'bottom';
			offsetY = -iconOffsetY;//-7;
		}
		else if(baseline == 'bottom'){
			baseline = 'top';
			offsetY = iconOffsetY;//10;
		}
		//align = 'center';
		baseline = 'middle';
		var weight = (textstyle.bold == '1')?'bold ':'normal ';//убрал в 8.1 версии библиотеки 'normal', т.к. с ним перестал применяться italic
		var italic = (textstyle.italic == '1')?'italic ':'';
		var fontName = goog.isDef(textstyle.fontFamily)?textstyle.fontFamily:'Arial';
		var font = italic + '' + weight  + '' + size + ' ' + fontName;//font: 'normal 16px Helvetica',
		//прозрачность
		var textStyleAplha = (textstyle)? textstyle.color.substr(0,2): 'ff';
		var alpha = parseInt((parseInt('0x0000' +textStyleAplha,16)/255)*100)/100;
		var col = 'rgba('+parseInt(textstyle.color.substr(2,2),16)+', '+parseInt(textstyle.color.substr(4,2),16)+', '+parseInt(textstyle.color.substr(6,2),16)+', '+alpha+')';
		var fillColor = col;
		if(isPoint == true){
			font = '10px Arial';
			fillColor = 'rgba(0,0,0,1)';
		}
		var texttt = undefined;
		if(textstyle.type == 'polygon')
			texttt = '';
		if(goog.isDef(style)){
			if(goog.isArray(style)){
				var i = 0;
				for(i ;i<style.length;i++){
					style[i].text_ = new ol.style.Text({
						textAlign: align,
						textBaseline: baseline,
						font: font,
						stroke: new ol.style.Stroke({color: '#fff', width: 2}),
						text: texttt,
						offsetX: offsetX,
						offsetY: offsetY,
						fill: new ol.style.Fill({color: fillColor})
					});
				}
			}
			else{
				style.text_ = new ol.style.Text({
					textAlign: align,
					textBaseline: baseline,
					font: font,
					stroke: new ol.style.Stroke({color: '#fff', width: 2}),
					text: texttt,
					offsetX: offsetX,
					offsetY: offsetY,
					fill: new ol.style.Fill({color: fillColor})
				});
			}
		}
	}
	else{
		style.text_ = null;
	}
};

//Вытягиваем по вертикали по средствам отсечения нижней границы полигона по минимальной Y
//Если в описании задачи ПКА присутсвует параметр bound_requrest, то:
//  - в результатах запросов на геометрию делить X на 2.5;
//  - по полученнии массива даднных геометрии по одному слою, выбирать в нем минимальный Y>0 и отнимать его из всех Y прибавлять 2;
map.layer.CASLayer.prototype.scaleBaseGeometry = function(geometry){
	var scale = WidgetMap.getScale();
	/*var measureOffset = 0;
	///смещение координат относительно титульного газопровода. В задаче водных переходов
	if(this.selectedLineObj && this.selectedLineObj.lineMeasureOffset){
		measureOffset = this.selectedLineObj.lineMeasureOffset;
	}*/
	var coords = geometry.flatCoordinates;
	var newCoords  = [];//of Array.<ol.Coordinate>
	var stride = geometry.stride;
	goog.asserts.assert(coords.length % stride === 0);
	var j;
	var minY = 0;
	if(scale.cutY){
		minY = Number.MAX_VALUE;
		for ( j = 0; j < coords.length; j += stride) {
			if(j === 0 || j >= coords.length - 4)//отсекаем первый и предпоследний
				continue;
			var y = coords[j + 1];
			if (y < minY) minY = y;
		}

	}
	this.cutYMin = minY - 2;
	for ( j = 0; j < coords.length; j += stride) {
		if(j === 0 || j >= coords.length - 4)// первый и предпоследний выравниваем с минимальным
			coords[j + 1] = 0;
		else
			coords[j + 1] = coords[j + 1] - this.cutYMin;
		//coords[j] = coords[j] / scale.x;

		newCoords.push(coords[j]);
		newCoords.push(coords[j + 1]);
		if (stride === 3)
			newCoords.push(coords[j + 2]);
	}
	switch (geometry.getType()) {
		case ol.geom.GeometryType.POLYGON:
		case ol.geom.GeometryType.MULTI_LINE_STRING:
			geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
			break;
		case ol.geom.GeometryType.MULTI_POLYGON:
			geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
			break;
		default:
			geometry.setFlatCoordinates(geometry.layout,newCoords);
	}
	return geometry;
};

map.layer.CASLayer.prototype.clone = function() {

}
goog.require('ol.style.Text');
goog.require('ol.style.Stroke');

DEFAULT_STYLE_NAME = 'Default_STYLE.xml';

function LayerManager(opt_options) {
    var options = goog.isDef(opt_options) ? opt_options : {};
    //колбек на результат обработки файлов слоёв, стилей
    this.layersReadyCallback = goog.isDef(options.layersReadyCallback) ?
        options.layersReadyCallback : undefined;
    this._layers = [];//new ol.Collection(); of WKBLayer
    this._multiLayers = [];
    //очередь векторных слоёв
    this._layersQuery = 0;

    this._needCenteringLayers = [];//new ol.Collection(); of WKBLayer

    this._events = {};

    this._rasterLayersNames = [];//называния моделей, чтобы при загрузке xml не дублировались
    this._rasterLayers = [];//new ol.Collection(); of RasterLayerp

    //очередь растровых слоёв
    this._rasterLayersQuery = 0;
    //очередь стилей
    this._styleQuery = 0;
    //массив с уникальными именами, чтобы потом удобно было чистить общие стили и оставить векторные/быстрого кеша
    this._rasterUniqueStyleNames = [];

    this._pointStyles = {};
    this._lineStyles = {};
    this._textStyles = {};
    this._zoomStyles = {};// объект с массивом зумов для одинаковых стилей, но разных масштабов
    this._polygonStyles = {};
    this._unknownTopologyStyles = {};
    this._styles = {};  /* of String  */
    //TODO место для массива с order слоев
    //Специально введен объект, в который попадают все стили, у которых не удается определить топологию.
    this._orders = [];
    this._numOrders = [];
    //объект для хранения mapOrder растровых слоев
    this._rasterMapOrders = {};

    //Количество моделей слоев, которые парсились
    this._parsedModelsCount = 0;
    this._modelsLayers = {};
    //объект для хранения mapOrder векторных слоев
    this._vectorMapOrders = {};
    //Соответствия _source.name и lay.name (для получения MapLayer по FeatureLayer.name)
    this._sourceToLayNames = {};

    //очередь на подгрузку стилей после парсинга слоёв
    this.stylesQueue = [];

    this._descrs = {};
}

/**
 *
 * Установка описаний
 *
 * @param name
 */
LayerManager.prototype.setDescr = function(name,descr){
    if(goog.isDef(this._descrs[name]))
        return;
    this._descrs[name] = descr;
};

/**
 * Чистим все данные по растровым слоя,
 */
LayerManager.prototype.clearRasterDatas = function(){
    delete this._rasterMapOrders;
    this._rasterMapOrders = [];
    delete this._rasterLayers;
    this._rasterLayers = [];
    delete this._rasterLayersNames;
    this._rasterLayersNames = [];
};

LayerManager.prototype.clearLayer = function(layerName,isVector){
    if(isVector == true){
        var layObj = this.getLayerByName(layerName);
        if(goog.isDef(layObj) && goog.isDef(layObj.layer) && goog.isDef(layObj.layer.featureProjLayer)){
            layObj.layer.featureProjLayer.getSource().getSource().clear();
            layObj.layer.dataReady_ = false;
        }
    }
};

LayerManager.prototype.isTextAllowedByLayerName = function(layerName) {
    var that = this;
    var curLayer = undefined;
    var i;
    for ( i = 0; i < that._layers.length; i++) {
        curLayer = that._layers[i];
        if (curLayer.id == layerName)
            return curLayer.isTextAllow;
    }
    for (i = 0; i < that._rasterLayers.length; i++) {
        curLayer = that._rasterLayers[i];
        if (curLayer.id == layerName)
            return curLayer.isTextAllow;
    }
    return false;
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllLayers = function() {
    var arr = this.getVectorLayersByMode();
    return arr;
    return  this._layers;
};

LayerManager.prototype.getAllLayersWeak = function() {
    var arr = this.getVectorLayersByModeWeak();
    return arr;
    return  this._layers;
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };


    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });


    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    //return this._rasterLayers.concat(this._layers);
    var vectorArr = this.getVectorLayersByMode();
    var rasterArr =  this.getRasterLayersByMode();
    return rasterArr.concat(vectorArr);
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedRasterLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };
    //sort name ascending then id descending
    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    //return this._rasterLayers.concat(this._layers);
    var rasterArr =  this.getRasterLayersByMode();
    return rasterArr;
};
/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedByNameLayers1 = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapName, b.layer.mapName), cmp(a.layer.sourceDescr, b.layer.sourceDescr)],
            [cmp(b.layer.mapName, a.layer.mapName), cmp(b.layer.sourceDescr, a.layer.sourceDescr)]
        );
    });
    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapName, b.layer.mapName), cmp(a.layer.sourceDescr, b.layer.sourceDescr)],
            [cmp(b.layer.mapName, a.layer.mapName), cmp(b.layer.sourceDescr, a.layer.sourceDescr)]
        );
    });
    return  this._rasterLayers.concat(this._layers);
};
/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedByNameLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(a.layer.mapName+a.layer.sourceDescr, b.layer.mapName+b.layer.sourceDescr);
    });
    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(a.layer.mapName+a.layer.sourceDescr, b.layer.mapName+b.layer.sourceDescr);
    });
    //return  this._rasterLayers.concat(this._layers);

    var vectorArr = this.getVectorLayersByMode();
    var rasterArr = this.getRasterLayersByMode();
    return rasterArr.concat(vectorArr);
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedByNameLayers2 = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(a.layer.mapName+a.layer.sourceDescr, b.layer.mapName+b.layer.sourceDescr);
    });
    this._rasterLayers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(a.layer.mapName+a.layer.sourceDescr, b.layer.mapName+b.layer.sourceDescr);
    });
    //return  this._rasterLayers.concat(this._layers);

    var vectorArr = this.getVectorLayersByMode();
    var rasterArr = this.getRasterLayersByMode1();
    return rasterArr.concat(vectorArr);
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedVectorLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    //return this._layers;
    var arr = this.getVectorLayersByMode();
    return arr;
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedVectorLayersWOMode = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    return this._layers;
};

/**
 * Получаем все слои
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllSortedByNameVectorLayers = function() {
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    this._layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapName, b.layer.mapName), cmp(a.layer.sourceDescr, b.layer.sourceDescr)],
            [cmp(b.layer.mapName, a.layer.mapName), cmp(b.layer.sourceDescr, a.layer.sourceDescr)]
        );
    });
    var arr = this.getVectorLayersByMode();
    return arr;
    //return this._layers;
};


/**
 * Получаем все слои, видимые в текущем масштабе
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllVisibleInScaleRasterLayers = function() {
    var layers = [];
    var currLayer;
    var zoom;
    var currZoom = WidgetMap.map.getView().getZoom();
    for(var i in this._rasterLayers){
        currLayer = this._rasterLayers[i].layer;
        zoom = this.getZoomForLayer(currLayer.name);
        if(this._rasterLayers[i].visible){
            if(currZoom  >= zoom.zoomMin && currZoom <= zoom.zoomMax ){
                layers.push(this._rasterLayers[i]);
            }
        }
    }

    //return layers;
    var arr = this.getRasterLayersByMode(layers);
    return arr;
};

/**
 * Получаем все слои, видимые в текущем масштабе отсортированные по mapOrder и order
 * getter для возвращения списка векторных слоев
 */
LayerManager.prototype.getAllVisibleInScaleSortedRasterLayers = function(isAscending) {
    var layers = [];
    var currLayer;
    var zoom;
    var currZoom = WidgetMap.map.getView().getZoom();
    for(var i in this._rasterLayers){
        currLayer = this._rasterLayers[i].layer;
        /*if(currLayer.name === 'PODS_COMPRESSOR_STATION')
            console.log('s');*/
        zoom = this.getZoomForLayer(currLayer.name);
        if(this._rasterLayers[i].visible){
            if(currZoom  >= zoom.zoomMin && currZoom <= zoom.zoomMax ){
                layers.push(this._rasterLayers[i]);
            }
        }
    }
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    if(isAscending == false){
        //sort name ascending then id descending
        layers.sort(function(a, b){
            //note the minus before -cmp, for descending order
            return cmp(
                [cmp(a.layer.mapOrder, b.layer.mapOrder), -cmp(a.layer.order, b.layer.order)],
                [cmp(b.layer.mapOrder, a.layer.mapOrder), -cmp(b.layer.order, a.layer.order)]
            );
        });
    }
    else{
        //sort name ascending then id descending
        layers.sort(function(a, b){
            //note the minus before -cmp, for descending order
            return cmp(
                [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
                [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
            );
        });
    }
    //проверяем тип и cover у слоя, чтобы отбросиль лишние
    /*var newLayers = [];
    for(var j in layers){
        if(layers[j].layer.type != 'system' && layers[j].layer.showInfo != 'false'){
            newLayers.push(layers[j]);
        }
        if(layers[j].layer.cover == 'true'){
            return newLayers;
        }
    }*/
    //var arr = this.getRasterLayersByMode(layers);
    //return arr;
    return layers;
};

/**
 * Получаем все слои, которые рисуются кешем и сортируем
 */
LayerManager.prototype.getAllVisibleInScaleSortedVectorLayers = function() {
    var layers = [];
    var currLayer;
    var zoom;
    var vectorArr = this.getVectorLayersByMode();
    for(var i in vectorArr){
        currLayer = vectorArr[i].layer;
        zoom = this.getZoomForLayer(currLayer.name);
        if(vectorArr[i].visible && WidgetMap.map.getView().getZoom() >= zoom.zoomMin && WidgetMap.map.getView().getZoom() <= zoom.zoomMax )
            layers.push(vectorArr[i]);
    }
    //сортируем
    // generic comparison function
    var cmp = function(x, y){
        return x > y ? 1 : x < y ? -1 : 0;
    };

    //sort name ascending then id descending
    layers.sort(function(a, b){
        //note the minus before -cmp, for descending order
        return cmp(
            [cmp(a.layer.mapOrder, b.layer.mapOrder), cmp(a.layer.order, b.layer.order)],
            [cmp(b.layer.mapOrder, a.layer.mapOrder), cmp(b.layer.order, a.layer.order)]
        );
    });
    //проверяем тип и cover у слоя, чтобы отбросиль лишние
    var newLayers = [];
    for(var j in layers){
        if(layers[j].layer.type != 'system' && layers[j].layer.showInfo != 'false'){
            newLayers.push(layers[j]);
        }
        if(layers[j].layer.cover == 'true'){
            return newLayers;
        }
    }

    /*var layers1 = this.getRasterLayersByMode(layers);
    //проверяем тип и cover у слоя, чтобы отбросиль лишние
    var newLayers = [];
    for(var j in layers1){
        if(layers1[j].layer.type != 'system' && layers1[j].layer.showInfo != 'false'){
            newLayers.push(layers1[j]);
        }
        if(layers1[j].layer.cover == 'true'){
            return newLayers;
        }
    }*/

    return newLayers;
};


/**
 * Получаем список слоёв, которые используются для перецентровки
 * @returns {*}
 */
LayerManager.prototype.getNeedCenteringLayers = function() {
    return this._needCenteringLayers;
};

/**
 * Получаем растровые слои
 */
LayerManager.prototype.getRasterLayers = function() {
    //return this.getRasterLayersByMode();
    this._rasterLayers;
};

LayerManager.prototype.getRasterLayersByMode = function(layers) {
    var i = 0;
    return this._rasterLayers;
    if(goog.isDef(layers)){
        var arr = [];
        //если режим векторный, то удаляем из масси
        if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER){
            i = 0;
            for(;i<layers.length;i++){
                if(WidgetMap.MULTI_MODE_LAYERS.indexOf(layers[i].layerQueryId)==-1)
                    arr.push(layers[i]);
            }
            return arr;
        }
        return layers;
    }
    var arr = [];
    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER){
        i = 0;
        for(;i<this._rasterLayers.length;i++){
            if(WidgetMap.MULTI_MODE_LAYERS.indexOf(this._rasterLayers[i].layerQueryId)==-1)
                arr.push(this._rasterLayers[i]);
        }
        return arr;
    }
    return this._rasterLayers;

};

LayerManager.prototype.getRasterLayersByMode1 = function(layers) {
    var i = 0;
    if(goog.isDef(layers)){
        var arr = [];
        //если режим векторный, то удаляем из масси
        if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR){
            i = 0;
            for(;i<layers.length;i++){
                if(WidgetMap.MULTI_MODE_LAYERS.indexOf(layers[i].layerQueryId)==-1)
                    arr.push(layers[i]);
            }
            return arr;
        }
        return layers;
    }
    var arr = [];
    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR){
        i = 0;
        for(;i<this._rasterLayers.length;i++){
            if(WidgetMap.MULTI_MODE_LAYERS.indexOf(this._rasterLayers[i].layerQueryId)==-1)
                arr.push(this._rasterLayers[i]);
        }
        return arr;
    }
    return this._rasterLayers;

};

LayerManager.prototype.getVectorLayersByMode = function() {
    var arr = [];
    //если режим растровый, то из  _layers удаляем растровые слои типа pods_route
    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER){
        var i = 0;
        for(;i<this._layers.length;i++){
            if(WidgetMap.MULTI_MODE_LAYERS.indexOf(this._layers[i].layerQueryId)==-1)
                arr.push(this._layers[i]);
        }
        return arr;
    }
    return this._layers;
};

LayerManager.prototype.getVectorLayersByModeWeak = function() {
    var arr = [];
    var i = 0;
    //если режим растровый, то из  _layers удаляем растровые слои типа pods_route
    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER){
        for(;i<this._layers.length;i++){
            if(WidgetMap.MULTI_MODE_LAYERS.indexOf(this._layers[i].layerQueryId)==-1)
                arr.push(this._layers[i]);
        }
        return arr;
    }
    else{
        for(;i<this._layers.length;i++){
                arr.push(this._layers[i]);
        }
        return arr;
    }

    return this._layers;
};


LayerManager.prototype.getLayersByModel = function(modelName) {
    if (goog.isDef(this._modelsLayers[modelName]))
        return this._modelsLayers[modelName];
    return [];
};

/**
 * Полечение общего слоя по имени(в панели свойств для забора dataProvider при поиске информации)
 * @param layerName
 * @returns {undefined}
 */
LayerManager.prototype.getLayerObjByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var rasterArr = this.getRasterLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    for (i = 0; i < rasterArr.length; i++) {
        curLayer = rasterArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    return undefined;
};

LayerManager.prototype.getLayerByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var rasterArr = this.getRasterLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer;
    }
    for (i = 0; i < rasterArr.length; i++) {
        curLayer = rasterArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    return undefined;
};


LayerManager.prototype.getCasLayerStyleColorByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var vectorArr = this.getVectorLayersByMode();
    var resLayers = [];
    var color = '#000000'
    vectorArr.forEach(function(layer){
        if(layer.layer.uniqueLayerName == layerName){
            try{
                var style = layer.layer.featureProjLayer.getSource().getSource().getFeatures()[0].getStyle();
            }
            catch (e) {  }
        }
    });
};
LayerManager.prototype.getCasLayerByGroupId = function(groupId) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var resLayers = [];
    if(groupId){
        vectorArr.forEach(function(layer){
            if(layer.layer.groupId === groupId)
                resLayers.push(layer);
        });
    }
   return resLayers;
};

LayerManager.prototype.getCasLayerByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.id === layerName)
            return curLayer;
    }
    return undefined;
};

LayerManager.prototype.getCasGeoBoundsByName = function(groupId) {
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var min = Number.MAX_VALUE, max = Number.MIN_VALUE;
    if(groupId){
        vectorArr.forEach(function(layer){
            if(layer.layer.groupId === groupId){
                if(!isNaN(layer.layer.groupMaxGeoBounds) || !isNaN(layer.layer.groupMinGeoBounds)){
                    min = layer.layer.groupMinGeoBounds;
                    max = layer.layer.groupMaxGeoBounds;
                    return;
                }
                var fs = layer.layer.featureProjLayer.getSource().getSource().getFeatures();
                var minGeoBounds = Number.MAX_VALUE, maxGeoBounds = Number.MIN_VALUE;
                if ((layer.layer.layDiagType=='2D' || layer.layer.layDiagType == 'interval')
                    && !isNaN(layer.layer.dataYMin_) && !isNaN(layer.layer.dataYMax_)){
                    minGeoBounds = layer.layer.dataYMin_;
                    maxGeoBounds = layer.layer.dataYMax_;
                }
                else{ //иначе берем границы по данным
                    var i = 0;
                    for (; i < fs.length; i++){
                        var curFtr = fs[i];
                        var ext = curFtr.getGeometry().getExtent();
                        if (maxGeoBounds<ol.extent.getTopLeft(ext)[1]) maxGeoBounds = ol.extent.getTopLeft(ext)[1];
                        if (minGeoBounds>ol.extent.getBottomLeft(ext)[1]) minGeoBounds = ol.extent.getBottomLeft(ext)[1];
                    }
                }
                if(minGeoBounds < min) min = minGeoBounds;
                if(maxGeoBounds > max) max = maxGeoBounds;
            }
        });

        vectorArr.forEach(function(layer) {
            if (layer.layer.groupId === groupId) {
                layer.layer.groupMinGeoBounds = min;
                layer.layer.groupMaxGeoBounds = max;
            }
        });
    }

    return {min: min, max: max};
};

LayerManager.prototype.getLayerByName1 = function(layerName, baseLayers) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var vectorArr = [], rasterArr = [];
    var curLayer = undefined;
    if(baseLayers && baseLayers.length){
        vectorArr = baseLayers;
    }
    else{
        vectorArr = this.getVectorLayersByMode();
        rasterArr = this.getRasterLayersByMode();
    }
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer;
    }
    for (i = 0; i < rasterArr.length; i++) {
        curLayer = rasterArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    return undefined;
};

/**
 * Возвращает список косметических слоёв
 */
LayerManager.prototype.getCosmeticIds = function() {
    var ids = [];
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var vectorArr = this.getVectorLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        if (vectorArr[i].layerQueryId === 'COSMETIC_Layers.xml')
            ids.push(vectorArr[i].id);
    }
    return ids;
};

/**
 * Получение векторного/быстрого кеша слоя
 * @param layerName
 * @returns {undefined}
 */
LayerManager.prototype.getRasterLayerByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var rasterArr = this.getRasterLayersByMode();
    var i;
    for ( i = 0; i < rasterArr.length; i++) {
        curLayer = rasterArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    return undefined;
};

/**
 * Получение векторного/быстрого кеша слоя
 * @param layerName
 * @returns {undefined}
 */
LayerManager.prototype.getVectorLayerByName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this.getVectorLayersByMode();
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.id == layerName)
            return curLayer;
    }
    if(WidgetMap && WidgetMap.baseLayers && WidgetMap.baseLayers.length){
        vectorArr = WidgetMap.baseLayers;
        for ( i = 0; i < vectorArr.length; i++) {
            curLayer = vectorArr[i];
            if (curLayer.id == layerName)
                return curLayer;
        }
    }
    return undefined;
};


LayerManager.prototype.getLayer = function(name) {
    if (name && name != ""){
        var vectorArr = this.getVectorLayersByMode();
        if (goog.isDef(vectorArr[name]))
            return vectorArr[name];
    }
    return null;
};

var LayerManagerRegisterCount = 0;
LayerManager.prototype.registerLayer = function(wkbLayer) {
    LayerManagerRegisterCount++;
    // получаем групповой слой ииз карты и добавляем туда новый
    if(goog.isDefAndNotNull(WidgetMap.currentVectorGroupLayer)){
        var source = new ol.source.Vector({
        });
        var imageVectorSource = new map.layer.ExtImageVector({
            source:source,
            id: wkbLayer.uniqueLayerName,
            ratio:1
        });
        var clusters = new ol.layer.Image({
            mapOrder: wkbLayer.mapOrder,
            order: wkbLayer.order,
            id: wkbLayer.uniqueLayerName,
            source: imageVectorSource,
            minResolution: wkbLayer.minResolution,
            maxResolution: wkbLayer.maxResolution
        });

        var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
        tLayers.push(clusters);
        WidgetMap.currentVectorGroupLayer.setLayers(tLayers);
        wkbLayer.featureProjLayer = clusters;
    }
};

LayerManager.prototype.getGeometryByLayerNameAndObjId = function(layer,layersIds){
    var newFeature = [];
    //добавляем мультифичи, чтобы туда заносить
    var multiPointGeometry = [];
    var multiLineGeometry = [];
    var multiPolygonGeometry = [];
    var hasSemanticField = layer.hasSemanticField;
    //проходимся по layersIds и добавляем геометрию
    var t;
    for(t in layersIds){
        var semId = layersIds[t];
        var features = layer.featureProjLayer.getSource().getSource().getFeatures();
        var found = false;
        var j;
        for (j in features) {
            var geo = -1;
            var points = features[j].get('pointsObjAll');
            if(!goog.isDef(points))
                break;
            if(hasSemanticField){//проверка, что идентификатор с semantic_id(ремонты кпг)
                for(var so in points){
                    if(so.indexOf('|') !== -1 && so.split('|')[1] === semId){  //1231|333
                        found = true;
                        var siblingGeo = points[so];
                        if(goog.isDef(siblingGeo)) {
                            switch (siblingGeo.getType()) {
                                case ol.geom.GeometryType.LINE_STRING:
                                    multiLineGeometry.push(siblingGeo);
                                    break;
                                case ol.geom.GeometryType.POLYGON:
                                    multiPolygonGeometry.push(siblingGeo);
                                    break;
                                case ol.geom.GeometryType.POINT:
                                    multiPointGeometry.push(siblingGeo.getCoordinates());
                                    break;
                            }
                        }
                    }
                }
            }
            else{
                geo = points[semId];
                if(goog.isDef(geo)){
                    found = true;
                    switch (geo.getType()) {
                        case ol.geom.GeometryType.LINE_STRING:
                            multiLineGeometry.push(geo);
                            break;
                        case ol.geom.GeometryType.POLYGON:
                            multiPolygonGeometry.push(geo);
                            break;
                        case ol.geom.GeometryType.POINT:
                            multiPointGeometry.push(geo.getCoordinates());
                            break;
                    }
                    //проверка на @ из gdal
                    for(var oo in points){
                        if (oo.indexOf(semId + "@") !== -1 && oo.indexOf(semId) === 0) {//проверяем, что нужный id, случай 5@1, 165@1
                            var siblingGeo = points[oo];
                            if(goog.isDef(siblingGeo)) {
                                switch (siblingGeo.getType()) {
                                    case ol.geom.GeometryType.LINE_STRING:
                                        multiLineGeometry.push(siblingGeo);
                                        break;
                                    case ol.geom.GeometryType.POLYGON:
                                        multiPolygonGeometry.push(siblingGeo);
                                        break;
                                    case ol.geom.GeometryType.POINT:
                                        multiPointGeometry.push(siblingGeo.getCoordinates());
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            if(found)
                break;
        }
    }
    var mpg;
    if(multiPointGeometry.length > 0){
        if(multiPointGeometry.length == 1)
            mpg = new ol.geom.Point(multiPointGeometry[0]);
        else
            mpg = new ol.geom.MultiPoint(multiPointGeometry);
        var ff = new ol.Feature(mpg);
        ff.setId('DEFAULT_SELECTED_'+App.generateUUID());
        WidgetMap.layerManager.defaultSelectionStyle(ff);
        newFeature.push(ff);
    }
    if(multiLineGeometry.length > 0){
        if(multiLineGeometry.length == 1)
            mpg = multiLineGeometry[0];
        else{
            mpg = new ol.geom.MultiLineString(null);
            mpg.setLineStrings(multiLineGeometry);
        }
        var ff = new ol.Feature(mpg);
        ff.setId('DEFAULT_SELECTED_'+App.generateUUID());
        WidgetMap.layerManager.defaultSelectionStyle(ff);
        newFeature.push(ff);
    }
    if(multiPolygonGeometry.length > 0){
        if(multiPolygonGeometry.length == 1) {
            //mpg = multiPolygonGeometry[0];
            // убрал такую установку,т.к. если выделить из грида объект,
            // то при нажатии кнопки редактирования возникает ошибка на clone с атрибутом ends(берется из всего мультиполигона)
            var geometry = new ol.geom.Polygon(null);
            var linearRing = new ol.geom.LinearRing(null);
            linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY, multiPolygonGeometry[0].flatCoordinates);
            geometry.appendLinearRing(linearRing);
            mpg = geometry;
        }
        else{
            mpg = new ol.geom.MultiPolygon(null);
            for(var k in multiPolygonGeometry){
                var geometry = new ol.geom.Polygon(null);
                var linearRing = new ol.geom.LinearRing(null);
                linearRing.setFlatCoordinates(ol.geom.GeometryLayout.XY,multiPolygonGeometry[k].flatCoordinates);
                geometry.appendLinearRing(linearRing);
                mpg.appendPolygon(geometry);
            }
        }

        var ff = new ol.Feature(mpg);
        ff.setId('DEFAULT_SELECTED_'+App.generateUUID());
        WidgetMap.layerManager.defaultSelectionStyle(ff);
        newFeature.push(ff);
    }
    return newFeature;
};



LayerManager.prototype.setGeometryByLayerNameAndObjId = function(layer, semId, geometry){
    try{
        var features = layer.featureProjLayer.getSource().getSource().getFeatures();
        var j;
        for (j in features) {
            var geo = -1;
            var points = features[j].get('pointsObjAll');
            if(points === undefined)
                break;
            geo = points[semId];
            if(geo){
                geo.setCoordinates(geometry.getCoordinates());
                layer.featureProjLayer.changed();
                break;
            }
        }
    }
    catch(ex){

    }
};

LayerManager.prototype.multSelectedData = function(fs, scaleX, startYOffset, yCoeff, yOffset){
    var i = 0;
    var firstCoord = undefined;
    if(yCoeff === 1){
        yOffset = 0;
    }

    for(;i<fs.length;i++){
        var geometry = fs[i].getGeometry();
        if(goog.isDefAndNotNull(geometry)){
            var coords = geometry.flatCoordinates;
            var newCoords  = [];//of Array.<ol.Coordinate>
            var stride = geometry.stride;
            goog.asserts.assert(coords.length % stride === 0);
            var j;
            for ( j = 0; j < coords.length; j += stride) {
                newCoords.push(coords[j]*scaleX);
                //newCoords.push(coords[j+1]);
                newCoords.push((coords[j+1] + startYOffset) * yCoeff + yOffset);
                if(!firstCoord)
                    firstCoord = [newCoords[newCoords.length-2], newCoords[newCoords.length -1]];
            }
            if(geometry.getType() === ol.geom.GeometryType.POLYGON || geometry.getType() === ol.geom.GeometryType.MULTI_LINE_STRING)
                geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEnds());
            else if(geometry.getType() === ol.geom.GeometryType.MULTI_POLYGON)
                geometry.setFlatCoordinates(geometry.layout,newCoords,geometry.getEndss());
            else
                geometry.setFlatCoordinates(geometry.layout,newCoords);
        }
    }
    return firstCoord;//возвращаем 1-ю координату геометрии, чтобы по ней центроваться

};


LayerManager.prototype.parseRasterLayersDescr = function(layerName, mapOrder) {
    if(layerName === 'PODS_EQUIP_Layers.xml')//TODO помещаем слой труб в начало массива
        mapOrder = 0;
    var that = this;
    function getLayersReqParams(layerName) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: 'SYS_SEM.xml#GET_XML_FILE',
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data FILE="'+layerName+'"/>'+
            '</root>'
        };
    }


    function parseLayersDescrRequest(layerName){
        if(layerName.indexOf('_Layers')>0){
            that._rasterLayersQuery++;
        }
        if(layerName.indexOf("_STYLE") > 0){
            var layerDataCache = that.getDataFromCache(layerName);
            if (goog.isDefAndNotNull(layerDataCache))
                getLayersResult(layerDataCache.result, layerName);
            else
                App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);
        }
        else{
            if(that._rasterLayersNames.indexOf(layerName)==-1)
                that._rasterLayersNames.push(layerName);
            else
                return;
            App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);
        }


        function getLayersResult(resultXml) {
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                var er = HTTPServiceUtil.getError(resultXml);
                if(er !== ''){
                    App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_1'});
                    if(layerName.indexOf('_Layers')>0){
                        that._rasterLayersQuery--;
                    }
                    return;
                }
                var layersDescriptionXml = $.parseXML(resultXml);
                if (layerName.indexOf("_STYLE") > 0) {
                    layersDescriptionXml = layersDescriptionXml.firstChild;
                    that.saveResultToCache(layerName, resultXml);
                    that.parseStyle(layersDescriptionXml, layerName);
                }
                else{
                    layersDescriptionXml = $(layersDescriptionXml).find('root');
                    if(layersDescriptionXml.length > 0)
                        that.parseRasterLayers(layersDescriptionXml[0],layerName);
                    //that.parseRasterLayers(layersDescriptionXml,layerName);
                    var styleName = layerName.replace('_Layers','_STYLE');
                    //that.parseRasterLayersDescr(styleName);
                    if(layerName.indexOf('CADASTRE') == -1)
                        that.parseDefaultStyleDescr(styleName,undefined,true);
                }

            }
            catch(ex) {
                App.errorReport(gis_layermanager_2, ex, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_15'});// Распарсить XML не удалось, видимо это просто строка
            }
            if(layerName.indexOf('_Layers')>0){
                that._rasterLayersQuery--;
                if(that._rasterLayersQuery == 0){
                    if(goog.isDef(that.layersReadyCallback))
                        that.layersReadyCallback();
                }
            }
        }

        function getLayersFault(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== '')
                App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_2'});
            if(layerName.indexOf('_Layers')>0)
                that._rasterLayersQuery--;
        }
    }
    var isFileParsed = false;
    if(!isNaN(mapOrder) && goog.isDef(mapOrder)){
        var name = layerName.replace("_Layers.xml","");
        if(goog.isDef(this._rasterMapOrders[name])){
            isFileParsed = true;
        }
        this._rasterMapOrders[name] = mapOrder;
    }
    if(layerName != '' && !isFileParsed){
        parseLayersDescrRequest(layerName);
    }

};
/**
 * Парсим только дефолтные стили
 * @param layerName
 * @param mapOrder
 */
LayerManager.prototype.parseDefaultStyleDescr = function(layerName, mapOrder, isRasterStyle) {
    var that = this;
    that.isRasterStyle = isRasterStyle;
    function getLayersReqParams(layerName) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: "SYS_SEM.xml#GET_DEFAULT_STYLES_XML",
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
                '<data FILE="'+layerName+'"/>'+
                '</root>'
        };
    }


    function parseLayersDescrRequest(layerName){
        if(layerName.indexOf('_STYLE')>0){
            that._styleQuery++;
        }
        App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);
        var rasterStyle = that.isRasterStyle;
        function getLayersResult(resultXml) {
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                var er = HTTPServiceUtil.getError(resultXml);
                if(er !== ''){
                    App.errorReport(gis_layermanager_2, er);
                    if(layerName.indexOf('_STYLE')>0){
                        that._styleQuery--;
                    }
                    return;
                }
                var layersDescriptionXml = ($.parseXML(resultXml)).firstChild;
                that.parseStyle(layersDescriptionXml,layerName,rasterStyle);
            }
            catch(ex) {
                App.errorReport(gis_layermanager_2, ex);// Распарсить XML не удалось, видимо это просто строка
            }
            if(layerName.indexOf('_STYLE')>0){
                that._styleQuery--;
                if(that._styleQuery == 0){
                    if(goog.isDef(that.layersReadyCallback))
                        that.layersReadyCallback();
                }
            }
        }

        function getLayersFault(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== '')
                App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_9'});
            if(layerName.indexOf('_STYLE')>0){
                that._styleQuery--;
            }
            return;
        }
    }
    if(layerName !== ''){
        parseLayersDescrRequest(layerName);
    }
};


LayerManager.prototype.parseLayersDescr = function(layerName) {
    var that = this;
    if(!goog.isDef(layerName) || layerName == '')
        return;
    function getLayersReqParams(layerName) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: 'SYS_SEM.xml#GET_XML_FILE',
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
                '<data FILE="'+layerName+'"/>'+
                '</root>'
        };
    }


    function parseLayersDescrRequest(layerName){
        if(layerName.indexOf('_Layers')>0){
            that._layersQuery++;
        }
        if(layerName.indexOf("_STYLE") > 0){
            var layerDataCache = that.getDataFromCache(layerName);
            if (goog.isDefAndNotNull(layerDataCache))
                getLayersResult(layerDataCache.result, layerName);
            else
               App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);
        }
        else
            App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams(layerName), getLayersResult,getLayersFault);



        function getLayersResult(resultXml) {
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                var er = HTTPServiceUtil.getError(resultXml);
                if (er !== '') {
                    App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_3'});
                    if (layerName.indexOf('_Layers') > 0) {
                        that._layersQuery--;
                    }
                    return;
                }
                //var layersDescriptionXml = ($.parseXML(resultXml)).firstChild;
                var layersDescriptionXml = $.parseXML(resultXml);

                if (layerName.indexOf("_STYLE") > 0) {
                    layersDescriptionXml = layersDescriptionXml.firstChild;
                    that.saveResultToCache(layerName, resultXml);
                    that.parseStyle(layersDescriptionXml, layerName);
                }
                else{
                    layersDescriptionXml = $(layersDescriptionXml).find('root');
                    if(layersDescriptionXml.length > 0)
                        that.parseLayers(layersDescriptionXml[0],layerName);
                    var styleName = layerName.replace('_Layers','_STYLE');
                    //если модель не ПКА, то грузим напрямую стили, иначе забираем их из файла *_layers
                    if(styleName.indexOf('CAS_')!=0)
                        that.parseLayersDescr(styleName);
                }

            }
            catch(ex) {
                App.errorReport(gis_layermanager_2, ex, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_4'});// Распарсить XML не удалось, видимо это просто строка
            }
            if(layerName.indexOf('_Layers')>0){
                that._layersQuery--;
                if(that._layersQuery == 0){
                    if(goog.isDef(that.layersReadyCallback))
                        that.layersReadyCallback();
                }
            }
        }

        function getLayersFault(resultXml) {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') 
                App.errorReport(gis_layermanager_2, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_7'});
            if (layerName.indexOf('_Layers') > 0) {
                that._layersQuery--;
            }
        }
    }
    parseLayersDescrRequest(layerName);
};

LayerManager.prototype.parseRasterLayers = function(value, layerName) {/** of XML */
    var that = this;
    var layers = value.getElementsByTagName("layer");
    for (var i = 0; i < layers.length; i++) {
        var curLayer = layers[i];
        var lId = curLayer.getAttribute('id');
        //если слой такой уже ранее парсился, то заново его не регистрируем
        if(goog.isDef(this.getRasterLayerByName(lId)))
            continue;
        var layerObj = {};
        layerObj.id = lId;
        var dataProviders = curLayer.getElementsByTagName("dataProvider");
        layerObj.dataProvider = {};
        layerObj.layerQueryId = layerName;
        layerObj.visible = ('true' == curLayer.getAttribute('visible'));
        //ФЛАГ ПОКАЗА ТЕКСТА
        layerObj.isTextAllow = true;
	    var modelName = layerName.replace('_Layers.xml','');
	    layerObj.modelName = modelName;

        for (var j = 0; j < dataProviders.length; j++) {
            var curDataProvider = dataProviders[j];
            var type = curDataProvider.hasAttribute('type') ? curDataProvider.getAttribute('type') : '';
            if(type == 'semantic')
                layerObj.dataProvider.semantic = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
            if(type == 'spatial')
                layerObj.dataProvider.spatial = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
        }
        var descr = layerName.replace("_Layers.xml","");
        var wkbLayer  = new map.layer.RasterLayer({
            name: curLayer.getAttribute('id'),
	        mapName: value.getAttribute('descr') !== null?value.getAttribute('descr'):layerName,
            layerSchema: curLayer.getAttribute('schema'),
            layerTable: curLayer.getAttribute('table'),
            sourceName: curLayer.getAttribute('id'),//value.getAttribute('name')
            sourceDescr: curLayer.getAttribute('descr'),
            layerNameSynonym: curLayer.getAttribute('synonym')?curLayer.getAttribute('synonym').split(','): [],
            dataType: curLayer.getAttribute('dataType'),
            labelField: curLayer.getAttribute('labelField'),
            classField: curLayer.getAttribute('classField'),
            cover: curLayer.getAttribute('cover'),
            type: curLayer.getAttribute('type'),
            canFirstTimeCentering:WidgetMap.canFirstTimeCentering,
            drawTypes:  (!goog.isNull(curLayer.getAttribute('topology')))?curLayer.getAttribute('topology').toLowerCase().split(','):['point'],
            showInfo: curLayer.getAttribute('showInfo'),
            order: parseFloat(curLayer.getAttribute('order')),
            mapOrder: that._rasterMapOrders[descr],
            fitMap: curLayer.getAttribute('fitMap') === 'true'
        });
        //данные по фильтру
        layerObj.filter = undefined;
        var filter = curLayer.getElementsByTagName("filter");
        if(goog.isDef(filter) && filter.length>0){
            if(filter[0].getElementsByTagName("pattern").length>0 && filter[0].getElementsByTagName("pattern")[0].textContent != ''){
                layerObj.filter = filter[0].getElementsByTagName("pattern")[0].textContent;
            }
        }
        else{
            if(layerObj.visible && wkbLayer.fitMap)
                this._needCenteringLayers.push(wkbLayer)
        }

        layerObj.layer = wkbLayer;
        //if(layerName === 'PODS_EQUIP_Layers.xml')
            that._rasterLayers.push(layerObj);

        //если выставлен флаг, то запрашиваем рамку
        if(wkbLayer.fitMap && wkbLayer.canFirstTimeCentering && !goog.isDef(layerObj.filter)){
            wkbLayer.canFirstTimeCentering = true;
            WidgetMap.canFirstTimeCentering = false;
            //если был выбран растровый режим, то не центрируемся, т.к. уже была центровка по вектору
            //кроме случая, если режим растровый пришел из настроек или из урл
            that.getQueryGeoMBR(layerObj);
        }
    }
};

LayerManager.prototype.parseLayers = function(value, layerName) {/** of XML */
    var that = this;
    var styleDataProviders = $(value).children('dataProvider');
    for (var k = 0; k < styleDataProviders.length; k++) {
        //проходимся по всем и выбираем только файлы стилей, а не запросы
        var curDataProvider = styleDataProviders[k];
        var type = $(curDataProvider).attr('type');
        var source = $(curDataProvider).attr('source');
        if(type == 'style' && goog.isDef(source) && source.indexOf('#') == -1 && this.stylesQueue.indexOf(source)==-1){
            this.stylesQueue.push(source);
        }
    }

    var layers = value.getElementsByTagName("layer");
    var i = 0;
    for (; i < layers.length; i++) {
        var curLayer = layers[i];
        var lId = curLayer.getAttribute('id');
        //если слой такой уже ранее парсился, то заново его не регистрируем
        if(goog.isDef(this.getVectorLayerByName(lId)))
            continue;
        var layerObj = {};
        layerObj.id = lId;
        var dataProviders = curLayer.getElementsByTagName("dataProvider");
        layerObj.dataProvider = {};
        layerObj.layerQueryId = layerName;
        //ФЛАГ ПОКАЗА ТЕКСТА
        layerObj.isTextAllow = true;
        layerObj.visible = ('true' == curLayer.getAttribute('visible'));
        //var filters = curLayer.getElementsByTagName("filters");

        for (var j = 0; j < dataProviders.length; j++) {
            var curDataProvider = dataProviders[j];
            var type = curDataProvider.hasAttribute('type') ? curDataProvider.getAttribute('type') : '';
            if(type == 'semantic')
                layerObj.dataProvider.semantic = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
            if(type == 'spatial')
                layerObj.dataProvider.spatial = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
            if(type == 'style')
                layerObj.dataProvider.style = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
            if(type == 'propertiesPanel')
                layerObj.dataProvider.propertiesPanel = curDataProvider.hasAttribute('source') ? curDataProvider.getAttribute('source') : '';
        }


        var modelName = layerName.replace('_Layers.xml','');
	    layerObj.modelName = modelName;
        if (!goog.isDef(this._modelsLayers[modelName]))
            that._modelsLayers[modelName] = [];
        that._modelsLayers[modelName].push(layerObj);
        var zMax = parseFloat(curLayer.getAttribute('zoomMin'));
        zMax = that.getZoom(zMax);
        if(isNaN(zMax))zMax = Infinity;
        var zMin =  parseFloat(curLayer.getAttribute('zoomMax'));
        zMin = that.getZoom(zMin);
        if(isNaN(zMin))zMin = 0;

        var spacing =  curLayer.getAttribute('spacing');
        var ress = LayerManager.getResolutionForZoomMinMax(WidgetMap.map,zMin,zMax);
        //console.log(curLayer.getAttribute('id')+' zMin='+zMin+' zMax='+zMax+' ress='+ress[0]+'  '+ress[1]);
        var tempOrder = (!goog.isNull(curLayer.getAttribute('order')))?parseFloat(curLayer.getAttribute('order')):100;
        var wkbLayer;
        if(layerName.indexOf('CAS_')==0){
            wkbLayer = new map.layer.CASLayer({//временно продублировал атрибуты
                name: curLayer.getAttribute('id'),
                uniqueLayerName: curLayer.getAttribute('id'),
                mapName: value.getAttribute('descr') !== null?value.getAttribute('descr'):layerName,
                layerSchema: curLayer.getAttribute('schema'),
                layerTable: curLayer.getAttribute('table'),
                sourceName: curLayer.getAttribute('id'),
                sourceDescr: curLayer.getAttribute('descr'),
                layerNameSynonym: curLayer.getAttribute('synonym')?curLayer.getAttribute('synonym').split(','): [],
                dataType: curLayer.getAttribute('dataType'),
                labelField: curLayer.getAttribute('labelField'),
                classField: curLayer.getAttribute('classField'),
                cover: curLayer.getAttribute('cover'),
                type: curLayer.getAttribute('type'),
                showInfo: curLayer.getAttribute('showInfo'),
                canFirstTimeCentering:WidgetMap.canFirstTimeCentering,
                fitMap: curLayer.getAttribute('fitMap') == 'true',
                drawTypes: (!goog.isNull(curLayer.getAttribute('topology')))?curLayer.getAttribute('topology').toLowerCase().split(','):'point',
                minResolution:ress[1],
                maxResolution:ress[0],
                order: tempOrder,
                mapOrder: that._vectorMapOrders[modelName],
                zIndex: (that._vectorMapOrders[modelName]+1)*10000+parseFloat(tempOrder),
                maxLayerZoom:zMax,
                minLayerZoom:zMin,
                spacing: spacing,
                layerQueryId: layerName,
                dataProvider:layerObj.dataProvider,
                groupIndex: i,
                //filtersXml: filters//upd.02.09.20  новое, сюда перенесены справочники из гридов
            });
        }
        else
            wkbLayer = new map.layer.VectorLayer({
            name: curLayer.getAttribute('id'),
            uniqueLayerName: curLayer.getAttribute('id'),
	        mapName: value.getAttribute('descr') !== null?value.getAttribute('descr'):layerName,
            layerSchema: curLayer.getAttribute('schema'),
            layerTable: curLayer.getAttribute('table'),
            useServerCache: curLayer.getAttribute('useServerCache') == 'true',
            sourceName: curLayer.getAttribute('id'),
            sourceDescr: curLayer.getAttribute('descr'),
            layerNameSynonym: curLayer.getAttribute('synonym')?curLayer.getAttribute('synonym').split(','): [],
            dataType: curLayer.getAttribute('dataType'),
            labelField: curLayer.getAttribute('labelField'),
            classField: curLayer.getAttribute('classField'),
            projection: curLayer.getAttribute('projection'),
            cover: curLayer.getAttribute('cover'),
            type: curLayer.getAttribute('type'),
            showInfo: curLayer.getAttribute('showInfo'),
            canFirstTimeCentering:WidgetMap.canFirstTimeCentering,
            fitMap: curLayer.getAttribute('fitMap') == 'true',
            drawTypes: (!goog.isNull(curLayer.getAttribute('topology')))?curLayer.getAttribute('topology').split(','):['point'],
            minResolution:ress[1],
            maxResolution:ress[0],
            order: tempOrder,
            mapOrder: that._vectorMapOrders[modelName],
            zIndex: (that._vectorMapOrders[modelName]+1)*10000+parseFloat(tempOrder),
            maxLayerZoom:zMax,
            minLayerZoom:zMin,
            spacing: spacing,
            layerQueryId: layerName,
            dataProvider:layerObj.dataProvider
        });


        //данные по фильтру
        layerObj.filter = undefined;
        var filters = $(curLayer).find('filter');

        if(goog.isDef(filters) && filters.length>0){
            filters.each(function(){
                var pattern = $(this).find('pattern').text();
                if(pattern !== ''){
                    layerObj.filter = pattern;
                }
                if(filters.length > 1){
                    var field = $(this).find('field').text();
                    if(!layerObj.filters) layerObj.filters = {};
                    layerObj.filters[field] = pattern;
                }
            })
        }
        else{
            if(layerObj.visible && wkbLayer.fitMap)
                this._needCenteringLayers.push(wkbLayer);
        }
        //дублируем в слой фильтр, используется при биндинге в подгрузке данных при зуме
        wkbLayer.filter = layerObj.filter;
        wkbLayer.filters = layerObj.filters;
        layerObj.layer = wkbLayer;
        //регистрируем слой
        that.registerLayer(wkbLayer);
        that._layers.push(layerObj);
    }
};

LayerManager.prototype.parseStyle = function(valueRes, urlStr, isRasterStyle){/** of XML */
    var that = this;
    if(goog.isDefAndNotNull(valueRes)){
        var styles = valueRes.getElementsByTagName("Style");
        var i = 0;
        for (; i < styles.length; i++) {
            var curStyle = styles[i];
            if(!goog.isDef(that._styles[urlStr]))
                that._styles[urlStr] = urlStr;
            var sId = curStyle.getAttribute('id');
            if (sId == "")
                sId = curStyle.getAttribute('schema') + "_" + curStyle.getAttribute('table');
            if (sId == "_")
                sId = "DEFAULT";
            var value = curStyle.getElementsByTagName("value");//[0].textContent
            if (goog.isDefAndNotNull(value) && value.length>0 && value[0].textContent !== ""){
                sId += "_" + value[0].textContent;
            }

            var descr = curStyle.getAttribute('descr');
            var style = new ol.style.Style();
            //массив стилей, если линии с каймой или т.п.
            var styleArr = [];
            var textStyle = undefined;
            var currZoom = {};
            var styleObj = {};
            styleObj.name = sId;
            styleObj.layerId = curStyle.getAttribute('id');
            styleObj.descr= descr;
            styleObj.style = style;

            var stObj = {"point":null, "line":[], "poly": null, "polyOutline":'1', "label": undefined/*new ol.style.Text()*/,"zoom":{}};
            //Выбираем объект, который определяет тип текущего стиля. По-умолчанию не устанавливаем никакой.
            //Поскольку наличие дочернего IconStyle или PolyStyle однозначно определяет что стиль точечный или полигональный, то:
            //если мы один раз установили stType=_pointStyles, это значит что стиль считаем точечным и сохраняем в точечных (_pointStyles)
            //если мы один раз установили stType=_polygonStyles, это значит что стиль считаем площадным и сохраняем в площадных (_polygonStyles)
            //если ни первое ни второе условия не соблюдены и есть линейный стиль - сохраняем в линейных (_lineStyles)
            var stType = null;/* of Object */
//                var styleElements = curStyle.children;
            var styleElements = curStyle.childNodes;
            var curElement = undefined;
            var j = 0;
            for (; j < styleElements.length; j++) {
                if(styleElements[j].nodeName == '#text')
                    continue;
                curElement = styleElements[j];
                var name = curElement.nodeName;
                var str; /* of ol.style.Stroke */
                var alpha = 1;
                var col;// = 0x000000;
                var c;
                switch (name){
                    case "LineStyle":
                        var lineCap = "round";
                        var lineJoin = "round";
                        var lineDash = null;
                        var width = 0;
                        var colorEl = curElement.getElementsByTagName("color");
                        if(goog.isDefAndNotNull(colorEl) && colorEl.length>0)
                            c = colorEl[0].textContent;
                        var widthEl = curElement.getElementsByTagName("width");
                        if(goog.isDefAndNotNull(widthEl) && widthEl.length>0){
                            width = parseFloat(widthEl[0].textContent);
                            if(!goog.isNumber(width))
                                width = 0;
                        }

                        if(goog.isDefAndNotNull(curElement.getElementsByTagName("caps")) && curElement.getElementsByTagName("caps").length>0)
                            lineCap = curElement.getElementsByTagName("caps")[0].textContent;

                        if(goog.isDefAndNotNull(curElement.getElementsByTagName("join")) && curElement.getElementsByTagName("join").length>0)
                            lineJoin = curElement.getElementsByTagName("join")[0].textContent;

                        if(goog.isDefAndNotNull(curElement.getElementsByTagName("dasharray")) && curElement.getElementsByTagName("dasharray").length>0)
                            lineDash = curElement.getElementsByTagName("dasharray")[0].textContent.split(' ');

                        if (c && c != ""){
                            //прозрачность неправильно обрабатывается
                            //alpha = parseFloat('0x0000' + c.substr(0,2))/255;
                            alpha = parseInt((parseInt('0x0000' + c.substr(0,2),16)/255)*100)/100;
                            //col = '#'+c.substr(2,6); //parseFloat('0x'+c.substr(2,6));
                            col = 'rgba('+parseInt(c.substr(2,2),16)+', '+parseInt(c.substr(4,2),16)+', '+parseInt(c.substr(6,2),16)+', '+alpha+')';
                            var str = new ol.style.Stroke({color: col,
                                    lineCap: lineCap,
                                    lineJoin: lineJoin,
                                    lineDash: lineDash,
                                    width: width});
                            stObj.line.push(str);
                            if(stObj.line.length>1)
                                stObj.lineObjBorder = {color:c,size:width};
                            else
                                stObj.lineObj = {color:c,size:width};
                            //Сохранять стиль будем в _lineStyles только если нет ни PolyStyle, ни IconStyle
                            if (!stType)
                                stType = that._lineStyles;
                        }
                        break;
                    case "LabelStyle":
                        var text = {};//пока использую не ol.style.Text, т.к нигде текстовые подписи не использую
                        //stType = that._textStyles;
                        /* <LabelStyle>
                         <zoomMin>0</zoomMin>
                         <zoomMax>1500</zoomMax>
                         <color>FFFF0000</color>
                         <fontFamily>Arial Cyr</fontFamily>
                         <fontSize>12</fontSize>
                         <duplicate>1</duplicate>
                         <overlap>0</overlap>
                         <bold>0</bold>
                         <italic>0</italic>
                         <underline>0</underline>
                         <auto>0</auto>
                         <scale>1</scale>
                         </LabelStyle> */
                        var overlapEl = curElement.getElementsByTagName("overlap");
                        if(goog.isDefAndNotNull(overlapEl) && overlapEl.length>0)
                            text.overlap = overlapEl[0].textContent;
                        var autoEl = curElement.getElementsByTagName("auto");
                        if(goog.isDefAndNotNull(autoEl) && autoEl.length>0)
                            text.auto = autoEl[0].textContent;
                        var duplicateEl = curElement.getElementsByTagName("duplicate");
                        if(goog.isDefAndNotNull(duplicateEl) && duplicateEl.length>0)
                            text.duplicate = duplicateEl[0].textContent;
                        var colorElement = curElement.getElementsByTagName("color");
                        if(goog.isDefAndNotNull(colorElement) && colorElement.length>0)
                            text.color =  colorElement[0].textContent;
	                    var alignElement = curElement.getElementsByTagName("align");
                        if(goog.isDefAndNotNull(alignElement) && alignElement.length>0)
                            text.align = alignElement[0].textContent;
	                    else
	                        text.align = 'right|top';
                        var fontFamilyEl = curElement.getElementsByTagName("fontFamily");
                        if(goog.isDefAndNotNull(fontFamilyEl) && fontFamilyEl.length>0)
                            text.fontFamily = fontFamilyEl[0].textContent;
                        var fontSizeEl = curElement.getElementsByTagName("fontSize");
                        if(goog.isDefAndNotNull(fontSizeEl) && fontSizeEl.length>0)
                            text.fontSize = fontSizeEl[0].textContent;
                        var scaleEl = curElement.getElementsByTagName("scale");
                        if(goog.isDefAndNotNull(scaleEl) && scaleEl.length>0){
                            var scale = scaleEl[0].textContent;
                            if(scale === '1')
                                text.fontSize = '-3';//флаг, для тех схемы - схемы ВТД, чтобы подписи масштабировались по длине подписи
                        }
                        var boldEl = curElement.getElementsByTagName("bold");
                        if(goog.isDefAndNotNull(boldEl) && boldEl.length>0)
                            text.bold = boldEl[0].textContent;
                        var italicEl = curElement.getElementsByTagName("italic");
                        if(goog.isDefAndNotNull(italicEl) && italicEl.length>0)
                            text.italic = italicEl[0].textContent;
                        var underlineEl = curElement.getElementsByTagName("underline");
                        if(goog.isDefAndNotNull(underlineEl) && underlineEl.length>0)
                            text.underline = underlineEl[0].textContent;
                        var textZoomMax = NaN;
                        var zoomMaxEl = curElement.getElementsByTagName("zoomMin");
                        var zoomMinEl = curElement.getElementsByTagName("zoomMax");
                        if(goog.isDefAndNotNull(zoomMaxEl) && zoomMaxEl.length>0)
                            textZoomMax = parseFloat(zoomMaxEl[0].textContent);
                        textZoomMax = that.getZoom(textZoomMax);
                        if(!isNaN(textZoomMax))
                            text.zoomMax = textZoomMax;
                        else
                            text.zoomMax = Number.POSITIVE_INFINITY;
                        var textZoomMin = NaN;
                        if(goog.isDefAndNotNull(zoomMinEl) && zoomMinEl.length>0)
                            textZoomMin = parseFloat(zoomMinEl[0].textContent);
                        textZoomMin = that.getZoom(textZoomMin);
                        if(!isNaN(textZoomMin))
                            text.zoomMin = that.getZoom(textZoomMin);
                        else
                            text.zoomMin = 0;
                        text.isTextObject = false;
                        var isTextObjectEl = curElement.getElementsByTagName("italic");
                        if(goog.isDefAndNotNull(isTextObjectEl) && isTextObjectEl.length>0)
                            text.isTextObject = isTextObjectEl[0].textContent === '1';
                        stObj.label = text;
                        if(goog.isDef(text.auto) && (text.auto == '0') || text.auto == 0)
	                        stObj.label = 'none';

                        break;
                    case "PolyStyle":
                        //Сохраняем стиль в _polygonStyles, т.к. PolyStyle встречается только на площадных стилях (даже если уже установлен в _lineStyles)
                        stType = that._polygonStyles;
                        var colorEl = curElement.getElementsByTagName("color");
                        if(goog.isDefAndNotNull(colorEl) && colorEl.length>0)
                            c = colorEl[0].textContent;
                        var fill = curElement.getElementsByTagName("fill");
                        if(goog.isDefAndNotNull(fill) && fill.length>0)
                            fill = fill[0].textContent;
                        var outline = curElement.getElementsByTagName("outline");
                        if(goog.isDefAndNotNull(outline) && outline.length>0)
                            outline = outline[0].textContent;
                        stObj.polyOutline = outline;
                        stObj.polyObj = {};
                        //флаг заливки контура
                        if(fill == '1'){
                            alpha = parseInt((parseInt('0x0000' + c.substr(0,2),16)/255)*100)/100;
                            if(c.length == 8){
                                col = 'rgba('+parseInt(c.substr(2,2),16)+', '+parseInt(c.substr(4,2),16)+', '+parseInt(c.substr(6,2),16)+', '+alpha+')';
                                stObj.poly = new ol.style.Fill({
                                    color: col//'rgba( 255,255,255,0.12)' //col
                                });
                            }
                            stObj.polyObj.color = c;
                        }
                        stObj.polyObj.fill = fill == '1';
                        stObj.polyObj.outline = outline == '1';//отрисовка каймы
                        break;
                    case "IconStyle":
                        var iconEl = curElement.getElementsByTagName("Icon");
                        if(!goog.isDefAndNotNull(iconEl[0])
                            || !goog.isDefAndNotNull(iconEl[0].getElementsByTagName("form"))
                            || !goog.isDef(iconEl[0].getElementsByTagName("form")[0]))
                            break;
                        var outline = curElement.getElementsByTagName("outline");
                        if(goog.isDefAndNotNull(outline) && outline.length>0)
                            outline = outline[0].textContent;

                        var form = iconEl[0].getElementsByTagName("form")[0].textContent;

                        //Сохраняем стиль в _pointStyles, т.к. IconStyle встречается только на точечных стилях (даже если уже установлен в _lineStyles)
                        stType = that._pointStyles;
                        var mark; /* of ol.style.Circle */
                        //var rotation = parseDecimalDegrees(Number(t.rotation));
                        var size = parseFloat(iconEl[0].getElementsByTagName("size")[0].textContent);
                        stObj.pointObj = {form:form,size:size};
                        switch (form){
                            case "bitmap":
                                mark = new ol.style.Icon({
                                    src: iconEl[0].getElementsByTagName("href")[0].textContent,
                                    size: [size,size]
                                });
                                stObj.pointObj.href = iconEl[0].getElementsByTagName("href")[0].textContent;
                                break;
                            default :
                                if(goog.isDefAndNotNull(curElement.getElementsByTagName("color")[0])){
                                    c = curElement.getElementsByTagName("color")[0].textContent;
                                    //col = '#'+c.substr(2,6);
                                    col = 'rgba('+parseInt(c.substr(2,2),16)+', '+parseInt(c.substr(4,2),16)+', '+parseInt(c.substr(6,2),16)+', '+alpha+')';
                                }
                                if(form == 'square'){
                                    mark = {form:form,radius: size/2+2,
                                        fill:  new ol.style.Fill({
                                            color: col
                                        }),stroke: new ol.style.Stroke({
                                            color: '#ffffff',
                                            width: 1
                                        })
                                    };
                                }else{
                                    mark = {form:form,radius: size+1,
                                        fill:  new ol.style.Fill({
                                        color: col
                                        }),
                                        stroke: new ol.style.Stroke({
                                            color: '#ffffff',
                                            width: 1
                                        })
                                    };
                                }
                                break;

                        }
                        stObj.point = mark;
                        stObj.pointObj.color = c;
                        stObj.pointObj.outline = outline == '1';//отрисовка каймы
                        break;
                    case "zoomMin":
                        var zoomMax = NaN;
                        if(goog.isDefAndNotNull(curElement.textContent) && curElement.textContent.length>0)
                            zoomMax = parseFloat(curElement.textContent);
                        zoomMax = that.getZoom(zoomMax);
                        if(!isNaN(zoomMax))
                            stObj.zoom.zoomMax = zoomMax;
                        else
                            stObj.zoom.zoomMax = Number.POSITIVE_INFINITY;
                        break;
                    case "zoomMax":
                        var zoomMin = NaN;
                        if(goog.isDefAndNotNull(curElement.textContent) && curElement.textContent.length>0)
                            zoomMin = parseFloat(curElement.textContent);
                        zoomMin = that.getZoom(zoomMin);
                        if(!isNaN(zoomMin))
                            stObj.zoom.zoomMin = that.getZoom(zoomMin);
                        else
                            stObj.zoom.zoomMin = 0;
                        break;
                    default: break;
                }
            }
            var currType = 'point';
            if (stType == that._lineStyles) {
                if (stObj.line.length > 1) {
                    // делаем остальные стили
                    var l = stObj.line.length;

                    for (var tt = l - 1; tt > 0; tt--) {
                        styleArr.push(new ol.style.Style({
                            stroke: stObj.line[tt]
                        }));
                    }
                }
                if(styleArr.length > 0){
                    styleArr.push(new ol.style.Style({
                        stroke:stObj.line[0]
                    }))
                }
                else
                    style = new ol.style.Style({
                        stroke:stObj.line[0]
                    });
	            currType = 'line';
            }
            else if (stType == that._polygonStyles){
	            //TODO 21.01.18 при обсуждении принято решение оставить для полигонов окантовку из одной линии, т.к.
	            // в полигоны с дырками в этом случае не заливались
	            if (stObj.line.length > 1) {
                    // делаем остальные стили
                    var l = stObj.line.length;
                    for (var tt = l - 1; tt > 0; tt--) {
                        styleArr.push(new ol.style.Style({
                            stroke: stObj.line[tt],
                            fill: stObj.poly
                        }));
                    }
                }
                else{
                    style = new ol.style.Style({
                        stroke: stObj.line[0],
                        fill: stObj.poly
                    });
                }
                if(styleArr.length > 0){
                    styleArr.push(new ol.style.Style({
                        stroke:stObj.line[0],
                        fill: stObj.poly
                    }))
                }
	            currType = 'polygon';
            }
            else {//если stType == _pointStyles или не был указан, считаем точечным
                var strk  = new ol.style.Stroke({
                    color: '#ffffff',
                    width: 1
                });
                if (stObj.line.length > 0){
                    if (stObj.point){
                        strk = stObj.line[0];//stObj.point.stroke_ = stObj.line[0];
                    }
                }
                var imgg = null;
                try{
                    if(stObj.point.form === undefined){
                        imgg = stObj.point;
                    }
                    else{
                        if(stObj.point.form == 'square'){
                            imgg = new ol.style.RegularShape({
                                angle: Math.PI / 4,
                                points: 4,
                                radius: stObj.point.radius,
                                fill:  stObj.point.fill,
                                stroke: strk
                            });
                        }
                        else{
                            imgg = new ol.style.Circle({
                                radius: stObj.point.radius,
                                fill: stObj.point.fill,
                                stroke: strk
                            });
                        }
                    }

                    style = new ol.style.Style({
                        stroke: null,
                        image: imgg
                    });
                }
                catch(e){
                }
            }

            if (stObj.label !== 'none'){
                if(goog.isDef(stObj.label)){
                    if(currType == 'polygon'){
                        textStyle = stObj.label;
                        stObj.labelObj = textStyle;
                    }
                    else{
                        textStyle = stObj.label;
                        stObj.labelObj = textStyle;
                    }

                }
                else{//дефолтный для точечного Arial,10px
                    /*if(styleObj.name.indexOf('POI_TRACK') !== -1 )
                        console.log('d')*/
                    /*var style = that.getTextStyle('DEFAULT');
                    if(style){
                        textStyle = {
                            color: style.color,
                            fontSize: style.fontSize,
                            bold: style.bold,
                            align: style.align,
                            overlap: style.overlap,
                            fontFamily: 'Arial',
                            zoomMax: style.zoomMax,
                            zoomMin: style.zoomMin
                        };
                    }
                    else
                        textStyle = {};*/
                    var colorText = 'ff000000';
                    if(currType == 'polygon'){
                        colorText = 'ff000000';
                    }
                    textStyle = {color:colorText,fontSize:'10',bold:'0',align:'right|top',overlap:'0',fontFamily:'Arial',zoomMax:Number.POSITIVE_INFINITY, zoomMin:0, isTextObject: false};
                    stObj.labelObj = textStyle;
                }
	            textStyle.type = currType;
            }
            else{
                //размер -2, т.к. -1 это размер шрифта для тех.схемы, который должен отрисовываться
                textStyle = {};
	            stObj.labelObj = textStyle;
            }
            //в рамках #2503 Стиль подписи по умолчанию необходимо вынести в default_style. Если стиль по умолчанию не задан - подпись не выводить.


            if (goog.isDef(stObj.zoom.zoomMin) && goog.isDef(stObj.zoom.zoomMax)){
                currZoom = stObj.zoom;
            }
            else{//если зумы не определены, то ставим их в мин/макс
                stObj.zoom.zoomMin = 0;
                stObj.zoom.zoomMax = Number.POSITIVE_INFINITY;
                currZoom = stObj.zoom;
            }

            if(goog.isDefAndNotNull(stType)) {
                if(!goog.isDef(stType[urlStr + "#" + styleObj.name])){
                    stType[urlStr + "#" + styleObj.name] = [];
                    if(isRasterStyle == true)
                        this._rasterUniqueStyleNames.push(urlStr + "#" + styleObj.name);
                }
                stType[urlStr + "#" + styleObj.name] = [];
                if(styleArr.length > 0){
                    stType[urlStr + "#" + styleObj.name].push({
                        layerId: styleObj.layerId,
                        sId: styleObj.name,
                        descr: (styleObj.descr)?styleObj.descr:gis_layermanager_6,
                        style: styleArr,
                        zoom: currZoom,
                        text: textStyle,
                        textOverlap: textStyle.overlap,
                        pointObj: stObj.pointObj,
                        lineObj: stObj.lineObj,
                        lineBorderObj: stObj.lineBorderObj,
                        polyObj: stObj.polyObj,
                        labelObj: stObj.labelObj
                    });
                }
                else{
                    stType[urlStr + "#" + styleObj.name].push({
                        layerId: styleObj.layerId,
                        sId: styleObj.name,
                        descr: (styleObj.descr)?styleObj.descr:gis_layermanager_6,
                        style: style,
                        zoom: currZoom,
                        text: textStyle,
                        textOverlap: textStyle.overlap,
                        pointObj: stObj.pointObj,
                        lineObj: stObj.lineObj,
                        lineBorderObj: stObj.lineBorderObj,
                        polyObj: stObj.polyObj,
                        labelObj: stObj.labelObj
                    });
                }
            }
            if(goog.isDef(textStyle))
                that._textStyles[urlStr+"#"+styleObj.name] = textStyle;
            if(goog.isDef(currZoom)){
                that._zoomStyles[urlStr+"#"+styleObj.name] = currZoom;
            }
            //обновляем стили в слое, если данные к нему уже подгружены
            var lay = this.getLayerByName(styleObj.name);
            if(goog.isDef(lay) && goog.isDef(lay.layer) && lay.layer.dataReady_ == true)
                lay.layer.featureProjLayer.getSource().changed();
        }
    }
    //пробуем обновить иконки для контрола с векторными слоями
    try{
        WidgetMap.baseLayersControl.updateVectorIcons(urlStr);
    }
    catch(e){}
};

/**
 * Получение соответствующего зума для карты
 * @param dist в метрах или номерах масштабов
 */
LayerManager.prototype.getZoom = function(dist) {
    try {
        if (goog.isNumber(dist) &&  !isNaN(dist)){
            if (dist <= 0)
                return NaN;
            if (dist <= 50)//передан номер масштаба, а не метры
                return dist;
            var extent = [0, 1, dist, 0]; // 1 для примера, равняемся по ширине
            return WidgetMap.getZoomForExtent(extent);
        }
    }
    catch(ex){
    }
    return NaN;
};


//устанавливаем слою дефолтный стиль
LayerManager.prototype.defaultSelectionStyle = function(feature, featureStyleName) {
    var that = this;
    var styleName = (goog.isDef(featureStyleName))?featureStyleName:"DEFAULT_SELECTED";
    var style;
    //устанавливаем id, чтобы нормально потом искать стиль. Возможно, потом придется по-другому сделать
    if(!goog.isDef(feature.getId()))
        feature.setId(styleName);
    if(goog.isDefAndNotNull(feature.getGeometry())){
        var type = feature.getGeometry().getType();
        switch(type){
            case ol.geom.GeometryType.POINT:
            case ol.geom.GeometryType.MULTI_POINT:
                style = this.getPointStyle(styleName);
                if(!goog.isNull(style))
                    feature.setStyle(style);
                else
                    feature.setStyle(this.getDefaultPointStyle());
                break;
            case ol.geom.GeometryType.LINE_STRING:
            case ol.geom.GeometryType.MULTI_LINE_STRING:
                style = this.getLineStyle(styleName);
                /*feature.setStyle(this.getDefaultLineStyle());
                break;*/
                if(!goog.isNull(style)){
                    var st = function(resolution) {
                        var styles = null;
                        var idd = this.getId();
                        if(goog.isDef(idd)){
                            var lName = idd.split(':')[0];
                            if(lName.indexOf('DEFAULT_SELECTED')!=-1)
                                lName = 'DEFAULT_SELECTED';
                            styles = that.getLineStyle(lName.replace('/','_'));/*this = ol.Feature*/
                        }
                        return styles;
                    };
                    feature.setStyle(st);
                    //feature.setStyle(style);
                }

                else
                    feature.setStyle(this.getDefaultLineStyle());
                break;
            case ol.geom.GeometryType.POLYGON:
            case ol.geom.GeometryType.MULTI_POLYGON:
                style = this.getPolygonStyle(styleName);
                if(!goog.isNull(style))
                    feature.setStyle(style);
                else
                    feature.setStyle(this.getDefaultPolygonStyle());
                break;
            default: break;
        }
    }
};

//устанавливаем слою дефолтный стиль
LayerManager.prototype.setDefaultSelectionStyle = function(feature, featureStyleName) {
    var that = this;
    var styleName = (goog.isDef(featureStyleName))?featureStyleName:"DEFAULT_SELECTED";
    var style;
    //устанавливаем id, чтобы нормально потом искать стиль. Возможно, потом придется по-другому сделать
    if(goog.isDefAndNotNull(feature.getGeometry())){
        var type = feature.getGeometry().getType();
        switch(type){
            case ol.geom.GeometryType.POINT:
            case ol.geom.GeometryType.MULTI_POINT:
                style = this.getPointStyle(styleName);
                if(!goog.isNull(style))
                    feature.setStyle(style);
                else
                    feature.setStyle(this.getDefaultPointStyle());
                break;
            case ol.geom.GeometryType.LINE_STRING:
            case ol.geom.GeometryType.MULTI_LINE_STRING:
                style = this.getLineStyle(styleName);
                if(!goog.isNull(style)){
                    feature.setStyle(style);
                }
                else
                    feature.setStyle(this.getDefaultLineStyle());
                break;
            case ol.geom.GeometryType.POLYGON:
            case ol.geom.GeometryType.MULTI_POLYGON:
                style = this.getPolygonStyle(styleName);
                if(!goog.isNull(style))
                    feature.setStyle(style);
                else
                    feature.setStyle(this.getDefaultPolygonStyle());
                break;
            default: break;
        }
    }
};


//получить текстовый стиль у слоя
LayerManager.prototype.getTextStyle = function(name) {
    for(var sty in this._styles){
        if (goog.isDef(this._textStyles[sty+"#"+name])){
            return this._textStyles[sty+"#"+name];
        }
    }
    if (goog.isDef(this._textStyles[name])){
        return this._textStyles[name];
    }

    return null;
};

//получить текстовый стиль у слоя
LayerManager.prototype.getTextStyleWithLabel = function(name,text) {
    if(!goog.isDefAndNotNull(text))
        return null;
    for(var sty in this._styles){
        if (goog.isDef(this._textStyles[sty+"#"+name])){
            return this._textStyles[sty+"#"+name];
        }
    }
    if (goog.isDef(this._textStyles[name])){
        return this._textStyles[name];
    }

    return null;
};

//получить текстовый стиль у слоя
LayerManager.prototype.getZoomForLayer = function(name) {
    for(var sty in this._styles){
        if (goog.isDef(this._zoomStyles[sty+"#"+name])){
            return this._zoomStyles[sty+"#"+name];
        }
    }
    if (goog.isDef(this._zoomStyles[name])){
        return this._zoomStyles[name];
    }

    return {zoomMin:0, zoomMax:Number.POSITIVE_INFINITY};
};

/**
 * Получение стиля по типу геометрии, который попадает в зум карты
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getStyleByNameAndType = function(name,type) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
        if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
        if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (type == 'Point' && goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};

/**
 * Получение стиля по типу геометрии без учитывания зума карты
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getStyleByNameAndTypeWOZoom = function(name,type) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    for(var sty in this._styles){
        if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
        if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
        if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
    }
    if (type == 'Point' && goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            return currStyles[i];
        }
    }
    if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            return currStyles[i];
        }
    }
    if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            return currStyles[i];
        }
    }
    return null;
}

/**
 * Получение оригинального стиля точки для использования на ПКА при совмещении графиков
 * @param names массив названий стилей
 * @param type
 * @returns {null|*}
 */
LayerManager.prototype.getOrigPointStyleByNameAndType = function(names) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map) || !names)
        return null;
    for(var n = 0; n < names.length; n++){
        var name = names[n];
        for(var sty in this._styles){
            if (goog.isDef(this._pointStyles[sty+"#"+name])){
                //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
                currStyles = this._pointStyles[sty+"#"+name];
                for(var i in currStyles){
                    return currStyles[i];
                }
            }
        }
        if (goog.isDef(this._pointStyles[name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
    }
    return null;
};

LayerManager.prototype.getOrigStyleByNameAndType = function(names, type ) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map) || !names)
        return null;
    for(var n = 0; n < names.length; n++){
        var name = names[n];
        for(var sty in this._styles){
            if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
                //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
                currStyles = this._pointStyles[sty+"#"+name];
                for(var i in currStyles){
                    return currStyles[i];
                }
            }
            if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
                //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
                currStyles = this._lineStyles[sty+"#"+name];
                for(var i in currStyles){
                    return currStyles[i];
                }
            }
            if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
                //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
                currStyles = this._polygonStyles[sty+"#"+name];
                for(var i in currStyles){
                    return currStyles[i];
                }
            }
        }
        if (type == 'Point' && goog.isDef(this._pointStyles[name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
        if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
        if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[name];
            for(var i in currStyles){
                return currStyles[i];
            }
        }
    }
    return null;
};

/**
 * Получение стиля по типу фичи ex. ROUTE_TYPE_02
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getStyleByNameWOZoomAndType = function(name,type) {
    var currStyles;
    for(var sty in this._styles){
        if (type === 'point'&& goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].style;
            }
        }
        if (type === 'line'&& goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].style;
            }
        }
        if (type === 'polygon'&& goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].style;
            }
        }
    }
    if (type === 'point'&& goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            return currStyles[i].style;
        }
    }
    if (type === 'line'&& goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            return currStyles[i].style;
        }
    }
    if (type === 'polygon'&& goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            return currStyles[i].style;
        }
    }
};

/**
 * Получение полного объекта со стилем по названию слоя и типу топологии
 * @param name
 * @param topology
 * @returns {*}
 */
LayerManager.prototype.getStyleObjByNameAndType = function(name,topology) {
    for(var sty in this._styles){
        if (topology === 'point'&& goog.isDef(this._pointStyles[sty+"#"+name]))
            return this._pointStyles[sty+"#"+name];
        if (topology === 'line'&& goog.isDef(this._lineStyles[sty+"#"+name]))
            return this._lineStyles[sty+"#"+name];
        if (topology === 'polygon'&& goog.isDef(this._polygonStyles[sty+"#"+name]))
            return this._polygonStyles[sty+"#"+name];
    }
    if (topology === 'point'&& goog.isDef(this._pointStyles[name]))
        return this._pointStyles[name];
    if (topology === 'line'&& goog.isDef(this._lineStyles[name]))
        return this._lineStyles[name];
    if (topology === 'polygon'&& goog.isDef(this._polygonStyles[name]))
        return this._polygonStyles[name];
};


LayerManager.prototype.getStyleByName = function(name) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
        if (goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
        if (goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    if (goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    if (goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};


LayerManager.prototype.getTextOverlapByNameAndType = function(name,type) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return '0';
    for(var sty in this._styles){
        if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].textOverlap;
            }
        }
        if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].textOverlap;
            }
        }
        if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                return currStyles[i].textOverlap;
            }
        }
    }
    if (type == 'Point' && goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        for(var i in currStyles){
            return currStyles[i].textOverlap;
        }
    }
    if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            return currStyles[i].textOverlap;
        }
    }
    if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            return currStyles[i].textOverlap;
        }
    }
    return '0';
};



LayerManager.prototype.getTextStyleByNameAndType = function(name,type) {
	var currStyles;
	if(!goog.isDefAndNotNull(WidgetMap.map))
		return null;
	for(var sty in this._styles){
		if (type == 'Point' && goog.isDef(this._pointStyles[sty+"#"+name])){
			//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
			currStyles = this._pointStyles[sty+"#"+name];
			for(var i in currStyles){
					return currStyles[i].text;
			}
		}
		if (type == 'LineString' && goog.isDef(this._lineStyles[sty+"#"+name])){
			//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
			currStyles = this._lineStyles[sty+"#"+name];
			for(var i in currStyles){
					return currStyles[i].text;
			}
		}
		if (type == 'Polygon' && goog.isDef(this._polygonStyles[sty+"#"+name])){
			//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
			currStyles = this._polygonStyles[sty+"#"+name];
			for(var i in currStyles){
					return currStyles[i].text;
			}
		}
	}
	if (type == 'Point' && goog.isDef(this._pointStyles[name])){
		//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
		currStyles = this._pointStyles[name];
		for(var i in currStyles){
				return currStyles[i].text;
		}
	}
	if (type == 'LineString' && goog.isDef(this._lineStyles[name])){
		//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
		currStyles = this._lineStyles[name];
		for(var i in currStyles){
				return currStyles[i].text;
		}
	}
	if (type == 'Polygon' && goog.isDef(this._polygonStyles[name])){
		//собираем стиль, чтобы на разных масштабах мог показываться свой стиль
		currStyles = this._polygonStyles[name];
		for(var i in currStyles){
				return currStyles[i].text;
		}
	}
	return null;
};




LayerManager.prototype.getPointStyle = function(name) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (goog.isDef(this._pointStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._pointStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (goog.isDef(this._pointStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._pointStyles[name];
        var z = WidgetMap.map.getView().getZoom();
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};
LayerManager.prototype.getLineStyle = function(name) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (goog.isDef(this._lineStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._lineStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (goog.isDef(this._lineStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._lineStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};

LayerManager.prototype.getPolygonStyle = function(name) {
    var currStyles;
    if(!goog.isDefAndNotNull(WidgetMap.map))
        return null;
    var z = WidgetMap.map.getView().getZoom();
    for(var sty in this._styles){
        if (goog.isDef(this._polygonStyles[sty+"#"+name])){
            //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
            currStyles = this._polygonStyles[sty+"#"+name];
            for(var i in currStyles){
                if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                    return currStyles[i].style;
            }
        }
    }
    if (goog.isDef(this._polygonStyles[name])){
        //собираем стиль, чтобы на разных масштабах мог показываться свой стиль
        currStyles = this._polygonStyles[name];
        for(var i in currStyles){
            if(z >= currStyles[i].zoom.zoomMin  && z <= currStyles[i].zoom.zoomMax)
                return currStyles[i].style;
        }
    }
    return null;
};

/**
 * Дефолтные стили для примитивов
 * @returns {ol.style.Style}
 */
LayerManager.prototype.getDefaultPointStyle = function(){
    return new ol.style.Style({
          image: new map.style.Rectangle({
              radius: 7,
              fill: new ol.style.Fill({
                  color: 'rgba(242, 98, 15, 0.7)'
              }),
              stroke: new ol.style.Stroke({
                  color: '#A6430A',
                  width: 1
              })
          })
  })
};

/**
 * Цвет иконок для легенды пка из карусели
 * @param index
 * @returns {ol.style.Style}
 */
LayerManager.prototype.getDefaultCASCarouselStyle = function(index){
    return new ol.style.Style({
        image: new map.style.Rectangle({
            radius: 200,
            fill: new ol.style.Fill({
                color: CHART_COLORS[index]
            }),
            stroke: new ol.style.Stroke({
                color: CHART_COLORS[index],
                width: 2
            })
        })
    })
};

/**
 * Дефолтные стили для точечного объекта ПКА
 * @returns {ol.style.Style}
 */
LayerManager.prototype.getDefaultCASPointStyle = function(){
    return new ol.style.Style({
        image: new map.style.Rectangle({
            radius: 1,
            fill: new ol.style.Fill({
                color: 'rgba(242, 98, 15, 0.7)'
            }),
            stroke: new ol.style.Stroke({
                color: '#A6430A',
                width: 0
            })
        })
    })
};

LayerManager.prototype.getDefaultCircleStyle = function(){
    return new ol.style.Style({
        image: new ol.style.Circle({
            radius: 7,
            fill: new ol.style.Fill({
                color: 'rgba(242, 98, 15, 0.7)'
            }),
            stroke: new ol.style.Stroke({
                color: '#A6430A',
                width: 1
            })
        })
    })
};

LayerManager.prototype.getDefaultLineStyle = function(){
    return new ol.style.Style({
        stroke: new ol.style.Stroke({
            color: '#000000',//'#ffcc33',
            width: 3
        })
    })
};
LayerManager.prototype.getDefaultPolygonStyle = function(){
    return new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0.2)'
        }),
        stroke: new ol.style.Stroke({
            color: '#ffcc33',
            width: 2
        })
    })
};


LayerManager.prototype.getDrawSurfaceStyle = function(){
    return new ol.style.Style({
        fill: new ol.style.Fill({
            color: 'rgba(228, 237, 242, 0.4)'
        }),
        stroke: new ol.style.Stroke({
            color: '#E7FF33',
            width: 3
        })
    })
};



//об6новляем только фильтры у слоя, если он выключен
LayerManager.prototype.updateLayer = function(layerId){
    var layerObj = this.getVectorLayerByName(layerId);
    if(goog.isDefAndNotNull(layerObj))
        layerObj.visible = true;
    var filter = $('#treeDiv').myCategories('callbackFilter',{params:{}});
    WidgetMap.updateTopFilter(filter.params);
};

//включаем видимость слоя
LayerManager.prototype.enableLayer = function(layerId){
    var layerObj = this.getVectorLayerByName(layerId);
    if(goog.isDefAndNotNull(layerObj))
        layerObj.visible = true;
    var obj = {"params":[{
        name:"layerId",
        value:layerId
    }]};

    //если вернулось false, то не нашло в рубрикаторе(возможно, не открыт был ешё)
    var finded = $('#treeDiv').myCategories('enableLayer', obj);
    if(finded === false && layerId !== 'COSMETIC_OBJECT' && layerId !== 'FIND_PATH_OBJECT'
        && layerId !== 'LIB_DOC_GEO_VIDEO_OBJECT' && layerId !=='BUFFER_OBJECT'){
        var vars = {layerParams:'layerId='+layerId+';'};
        var params = {vars:vars};
        ExternalInteraction.treeCallFunction(params,'enableLayer');
    }
};

//включаем видимость слоя
LayerManager.prototype.disableLayer = function(layerId){
    var layerObj = this.getLayerByName(layerId);
    if(goog.isDefAndNotNull(layerObj))
        layerObj.visible = false;
    $('#treeDiv').myCategories('disableLayer',{"params":[{"name":"layerId","value":layerId}]});
};

//Получение видимости для слоя
LayerManager.prototype.getLayerVisibility = function(layerId){
    var layerObj = this.getLayerByName(layerId);
    if(goog.isDefAndNotNull(layerObj))
        return layerObj.visible;
    return false;
};



/**
 * Получить рамку для текущего слоя и переместить карту
 * @param layerObj
 *  * @param layerObj
 */
LayerManager.prototype.getQueryGeoMBR = function(layerObj, resultHandler){
    var that = this;
    function getReqLPUParams(request, lpuIds) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:'<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+
                '" '+ topFiltersStr+''+
                '>'+
                '<data LPU_IDS="'+lpuIds+'"/></root>'
        };
    }

    function resultLPU(resultXml) {
        try { // Иногда ответ в формате XML, а иногда в виде просто строки
            BlockingUtil.ready();
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') {
                if (goog.isDef(resultHandler))
                    resultHandler.apply(this);
                return;
            }
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var datas = layerGeoXml.getElementsByTagName("data");
            var dd = 0;
            for (dd; dd < datas.length; dd++) {
                var maxLat = parseFloat(datas[dd].getAttribute('YMAX'));
                var minLat = parseFloat(datas[dd].getAttribute('YMIN'));
                var minLon = parseFloat(datas[dd].getAttribute('XMIN'));
                var maxLon = parseFloat(datas[dd].getAttribute('XMAX'));
                var pnt1 = new proj4.toPoint([minLon, minLat]);
                var pnt2 = new proj4.toPoint([maxLon, maxLat]);
                var source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
                var dest_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
                if (App.projection === GeoUtil.PROJS.Pulkovo42) {//преобразуем в wgs84
                    var p42WgsPnt = GeoUtil.P42WGS(minLat, minLon);
                    pnt1 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
                    p42WgsPnt = GeoUtil.P42WGS(maxLat, maxLon);
                    pnt2 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
                }
                proj4.transform(source_, dest_, pnt1);
                proj4.transform(source_, dest_, pnt2);
                if(isNaN(pnt1.x) || isNaN(pnt1.y) || isNaN(pnt2.x) || isNaN(pnt2.y))
                    continue;
                var extent = [pnt1.x, pnt1.y, pnt2.x, pnt2.y]; // of ol.Extent `[minx, miny, maxx, maxy]`.
                if(extent.length == 0)
                    extent= [pnt1.x, pnt1.y, pnt2.x, pnt2.y];
                else
                    extent = ol.extent.extend(extent,[pnt1.x, pnt1.y, pnt2.x, pnt2.y]);
            }
            if(WidgetMap.canFirstTimeCentering || layerObj.layer.canFirstTimeCentering)
                WidgetMap.centerOnMap(extent);
            WidgetMap.canFirstTimeCentering = true;
            if (goog.isDef(resultHandler))
                resultHandler.apply(this);
        }
        catch(ex) {
            if(goog.isDef(resultHandler))
                resultHandler.apply(this);
        }
        finally {
            // WidgetMap.baseLayersControl.changeListByMode();
        }
    }
    function faultLPU(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== '') 
            App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_14'})
        if (goog.isDef(resultHandler))
            resultHandler.apply(this);
    }

    if(goog.isDef(WidgetMap.currentTopFilter) &&  WidgetMap.currentTopFilter.length > 0){
        var k=0;
        for(;k<WidgetMap.currentTopFilter.length;k++){
            if(goog.isDef(WidgetMap.currentTopFilter[k].name) && WidgetMap.currentTopFilter[k].name == 'LPU_ACCESS_FILTER'){
                var lpus = WidgetMap.currentTopFilter[k].value;
                App.serverQueryXMLNodeWithTries(Services.processQueryNode, getReqLPUParams('GAZPROM_ADM_SEM.xml#GET_LPU_BOUNDS', lpus), resultLPU, faultLPU,4);
                WidgetMap.canFirstTimeCentering = true;
                return;
            }
        }
    }
    WidgetMap.canFirstTimeCentering = true;
};




//Получение из массива фильтров строки со всеми фильтрами верхнего уровня (передаются в тег root, разделяются пробелами)
LayerManager.getTopFiltersString = function(filtersArr) {
    /******* FILTER ******/
        //Получение по значению данных его обертки для отправки в запрос (для строк добавляет кавычки)
    function getStrOrNumVal(val) {
        var valueStr = '';
        if($.isNumeric(val))
            valueStr += val;
        else if(val === "NULL")
            valueStr += val;
        else if(val === "")
            valueStr += 'NULL';
        else
            valueStr += "'"+val+"'";
        valueStr = valueStr.replace(/''/g, "'");//случай, если пришел уже в одинарных кавычках
        return valueStr;
    }
    var resultStr = '';
    if (filtersArr) {
        for (var i = 0; i < filtersArr.length; i++) {
            var curObj = filtersArr[i];
            var curObjName = curObj['name'];
            var curObjValue = curObj['value'];
            var curObjValArr = curObjValue.split(',');
            var valuesStr = '';
            for (var j=0; j < curObjValArr.length; j++) {
                valuesStr += getStrOrNumVal(curObjValArr[j]) + ",";
            }
            //убираем последнюю ","
            valuesStr = valuesStr.substr(0, valuesStr.length-1);
            //Формируем общую строку со всеми фильтрами
            resultStr = resultStr + curObjName + '="' + valuesStr + '" '; //Сзади добавляем пробел для разделения с последующими значениями
        }
    }

    return resultStr;
};
LayerManager.getTopFiltersStringWithBaseLPU = function(filtersArr) {
    /******* FILTER ******/
    //Получение по значению данных его обертки для отправки в запрос (для строк добавляет кавычки)
    function getStrOrNumVal(val) {
        var valueStr = '';
        if($.isNumeric(val))
            valueStr += val;
        else if(val === "NULL")
            valueStr += val;
        else if(val === "")
            valueStr += 'NULL';
        else
            valueStr += "'"+val+"'";
        valueStr = valueStr.replace(/''/g, "'");//случай, если пришел уже в одинарных кавычках
        return valueStr;
    }
    function getPreloadLpuValues(){
        var resArr = [];
        if(WidgetMap.preloadLpuValues && WidgetMap.preloadLpuValues.length > 0){
            WidgetMap.preloadLpuValues.forEach(function(lpu){
                if(lpu)resArr.push(lpu.CODE);
            });
        }
        return resArr;
    }
    var resultStr = '';
    if (filtersArr) {
        for (var i = 0; i < filtersArr.length; i++) {
            var curObj = filtersArr[i];
            var curObjName = curObj['name'];
            var curObjValue = curObj['value'];
            var curObjValArr = curObjValue.split(',');
            var valuesStr = '';
            if(curObjName === 'LPU_ACCESS_FILTER'){
                curObjValArr = getPreloadLpuValues();
            }
            for (var j=0; j < curObjValArr.length; j++) {
                valuesStr += getStrOrNumVal(curObjValArr[j]) + ",";
            }
            //убираем последнюю ","
            valuesStr = valuesStr.substr(0, valuesStr.length-1);
            //Формируем общую строку со всеми фильтрами
            resultStr = resultStr + curObjName + '="' + valuesStr + '" '; //Сзади добавляем пробел для разделения с последующими значениями
        }
    }

    return resultStr;
};
//Получение из массива фильтров строки со всеми фильтрами среднего уровня (передаются в тег data в атрибут FILTER, разделяются словом ' AND ')
LayerManager.getRoughFiltersString = function(filtersArr) {
    /******* FILTER ******/
        //Получение по значению данных его обертки для отправки в запрос (для строк добавляет кавычки)
    function getStrOrNumVal(val) {
        var valueStr = '';
        if($.isNumeric(val))
            valueStr += val;
        else if(val === "NULL")
            valueStr += val;
        else if(val === "")
            valueStr += 'NULL';
        else
            valueStr += "'"+val+"'";
	    valueStr = valueStr.replace(/''/g, "'");//случай, если пришел уже в одинарных кавычках
        return valueStr;
    }

    var resultStr = '';
    if (filtersArr && filtersArr.length > 0) {
        var curObj = filtersArr[0];
        var curObjValue = curObj['value'];
        var curObjValArr = curObjValue.split(',');
        var valuesStr = '';
        for (var j=0; j < curObjValArr.length; j++) {
            valuesStr += getStrOrNumVal(curObjValArr[j]) + ",";
        }
        //убираем последнюю ","
        valuesStr = valuesStr.substr(0, valuesStr.length-1);
        //Формируем общую строку со всеми фильтрами
        resultStr = valuesStr;
    }

    return resultStr;
};



/**
 *
 * @returns {number}
 */
LayerManager.getResolutionForZoomMinMax = function(map, zoomMin, zoomMax){
    var resolutions = [0, Infinity];
    if(goog.isDefAndNotNull(map) && goog.isDefAndNotNull(map.getView())){
        var view = map.getView();
        var res, z = 0;
        //опускаем zoomMin до 0, если zoomMin<=4, т.к. у нас начинаются масштабы с 4, а maxResolution_ для z=0 соответствует масштабу 4
        if(zoomMin <= view.minZoom_)
            zoomMin = view.minZoom_;
        resolutions = [view.maxResolution_ ,view.minResolution_];
        var mapResolutions = [];
        do {
            res = view.constrainResolution(view.maxResolution_, z);
            mapResolutions[view.minZoom_+z] = res;
            ++z;
        } while (res > view.minResolution_);

        resolutions[0] = mapResolutions[zoomMin]*2;
        if(zoomMax>=mapResolutions.length)
            resolutions[1] = mapResolutions[mapResolutions.length-1];
        else
            resolutions[1] = mapResolutions[zoomMax];
        return resolutions;//view.maxResolution_ соответствует minZoom, поэтому добавляем. И отнимаем 1, как во флеш
    }
    return resolutions;
};

LayerManager.styleCache = {};

LayerManager.prototype.createCustomClusterStyle = function(feature){
    return this.getStyleByName(feature.id_);
};


/**
 * Получения массива всех стилей для слоя
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getAllStylesForLayer = function(styleFileName,layerId) {
    var styles = [];
    var styleName = styleFileName+'#'+layerId;
    var i;
    for(i in this._pointStyles){
        if(i.indexOf(styleName) !=-1 && this._pointStyles[i][0].layerId == layerId )
            styles.push(this._pointStyles[i][0]);
    }
    for(i in this._lineStyles){
        if(i.indexOf(styleName) !=-1 && this._lineStyles[i][0].layerId == layerId )
            styles.push(this._lineStyles[i][0]);
    }
    for(i in this._polygonStyles) {
        if (i.indexOf(styleName) != -1 && this._polygonStyles[i][0].layerId == layerId)
            styles.push(this._polygonStyles[i][0]);
    }
    return styles;
};

/**
 * Получения всех стилей для слоя в виде объекта
 * @param name
 * @param type
 * @returns {*}
 */
LayerManager.prototype.getAllStylesForLayerObj = function(styleFileName,layerId) {
    var styles = {};
    var styleName = styleFileName+'#'+layerId;
    var i;
    styles['point'] = {};
    styles['line'] = {};
    styles['polygon'] = {};
    for(i in this._pointStyles){
        if(i.indexOf(styleName) !=-1 && this._pointStyles[i][0].layerId == layerId )
            styles['point'][this._pointStyles[i][0].sId] = this._pointStyles[i][0];
    }
    for(i in this._lineStyles){
        if(i.indexOf(styleName) !=-1 && this._lineStyles[i][0].layerId == layerId )
            styles['line'][this._lineStyles[i][0].sId] = this._lineStyles[i][0];
    }
    for(i in this._polygonStyles) {
        if (i.indexOf(styleName) != -1 && this._polygonStyles[i][0].layerId == layerId)
            styles['polygon'][this._polygonStyles[i][0].sId] = this._polygonStyles[i][0];
    }
    return styles;
};

/**
 * Получения стилей для косметического слоя в виде объекта
 * @param styleFileName
 * @param layerId
 * @returns {*}
 */
LayerManager.prototype.getAllCosmeticStylesForLayerObj = function(styleFileName, layerId) {
    var styles = {};
    var styleName = styleFileName+'#'+layerId;
    var i;
    styles['point'] = undefined;
    styles['line'] = undefined;
    styles['polygon'] = undefined;
    for(i in this._pointStyles){
        if(i.indexOf(styleName) !== -1 && this._pointStyles[i][0].layerId === layerId ){
            if(!styles['point'])
                styles['point'] = {};
            styles['point'][this._pointStyles[i][0].sId] = this._pointStyles[i][0];
            styles['point'][this._pointStyles[i][0].sId].layerId = layerId;
        }

    }
    for(i in this._lineStyles){
        if(i.indexOf(styleName) !== -1 && this._lineStyles[i][0].layerId === layerId ){
            if(!styles['line'])
                styles['line'] = {};
            styles['line'][this._lineStyles[i][0].sId] = this._lineStyles[i][0];
            styles['line'][this._lineStyles[i][0].sId].layerId = layerId;
        }
    }
    for(i in this._polygonStyles) {
        if (i.indexOf(styleName) !== -1 && this._polygonStyles[i][0].layerId === layerId){
            if(!styles['polygon'])
                styles['polygon'] = {};
            styles['polygon'][this._polygonStyles[i][0].sId] = this._polygonStyles[i][0];
            styles['polygon'][this._polygonStyles[i][0].sId].layerId = layerId;
        }
    }
    //если какого-то стиля не нашли, берем из дефолтного

    if(!styles['point']){
        styles['point'] = {};
        styles['point'][this._pointStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId] = this._pointStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0];
        styles['point'][this._pointStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId].layerId = layerId;
    }
    if(!styles['line']){
        styles['line'] = {};
        styles['line'][this._lineStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId] = this._lineStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0];
        styles['line'][this._lineStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId].layerId = layerId;
    }
    if(!styles['polygon']){
        styles['polygon'] = {};
        styles['polygon'][this._polygonStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId] = this._polygonStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0];
        styles['polygon'][this._polygonStyles[DEFAULT_STYLE_NAME+'#DEFAULT'][0].sId].layerId = layerId;
    }
    return styles;
};


/**
 * Функция получения данных из кеша (если они там есть и актуальны)
 */
LayerManager.prototype.getDataFromCache = function(requestId) {
    if(supports_html5_storage()){
        var retrievedObject = localStorage.getItem(requestId);
        return JSON.parse(retrievedObject);
    }

};

/**
 * Функция принудительной очистки кеша
 * (применяется при добавлении, изменении или удалении объектов слоя)
 */
LayerManager.prototype.clearDataCache = function(requestId) {
    if(supports_html5_storage()){
        localStorage.removeItem(requestId)
    }

};

/**
 * Функция сохранения результата геозапроса в кеш
 * @param resultData - данные для кеширования
 */
LayerManager.prototype.saveResultToCache = function(requestId, resultData) {
    if(supports_html5_storage()){
        //Пытаемся получить локальный кеш и сохранить пришедшие данные в него
        if(localStorage[requestId] == undefined){
            var curDate  = new Date();
            var testObject = { CACHE_ACTUAL_DATE: curDate, result: resultData };
            var strItem = JSON.stringify(testObject);
            try{
                localStorage.setItem(requestId, strItem );
            }
            catch(ex){
                App.errorReport(gis_layermanager_4+requestId+gis_layermanager_5, ex);
            }
        }
    }
};


/**
 * Прячем выбранные векторные слои
 * @param models - массив моделей
 */
LayerManager.prototype.hideVectorLayers = function(models){
    var i = 0;
    for(; i < models.length; i++){
        var m = models[i];
        var layers = this.getLayersByModel(m.replace('_Layers.xml',''));
        var j = 0;
        for(; j < layers.length; j++){
            var layer = layers[j];
            if(goog.isDef(layer) && goog.isDef(layer.layer)){
                layer.layer.clear();
	            layer.layer.isDataLoading_ = false;
                layer.layer.canLoadData = false;
                layer.layer.dataReady_ = false;
            }
        }
    }
};

/**
 * Показываем выбранные векторные слои
 * @param models - массив моделей
 */
LayerManager.prototype.showVectorLayers = function(models){
    var i = 0;
    for(; i < models.length; i++){
        var m = models[i];
        var layers = this.getLayersByModel(m.replace('_Layers.xml',''));
        var j = 0;
        for(; j < layers.length; j++){
            var layer = layers[j];
            if(goog.isDef(layer) && goog.isDef(layer.layer)){
                layer.layer.canLoadData = true;
	            layer.layer.isDataLoading_ = false;
	            layer.layer.dataReady_ = false;
                layer.layer.canFirstTimeCentering = false;
                layer.layer.loadData();
            }
        }
    }
};


/****************  ПКА  ***************/


/**
 * Удаление неиспользуемых слоёв с карты
 * @param [array.<Object>] layers слои, которые должны остаться
 */
LayerManager.prototype.removeUnusedCASLayers = function(layers){
    var newCASLayers = [];
    var mapLayers = new ol.Collection();
    var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
    for(var i in layers){
        for(var k in this._layers){
            if(this._layers[k].layer.uniqueLayerName==layers[i]){
                newCASLayers.push(this._layers[k]);
                break;
            }
        }
        for(var j=0;j<tLayers.getLength();j++){
            if(tLayers.item(j).get('id') == layers[i]){
                mapLayers.push(tLayers.item(j));
                break;
            }
        }
    }
    this._layers = newCASLayers;
    WidgetMap.currentVectorGroupLayer.setLayers(mapLayers);
};

/**
 * Удаление неиспользуемых слоёв с карты
 */
LayerManager.prototype.removeAllCASLayers = function(){
    WidgetMap.prevScaleXCoeff = 1;
    WidgetMap.mapScaleXCoeff = 1;
    WidgetMap.casScaleCoeff = 1;
    WidgetMap.curStartX = 0;
    WidgetMap.curEndX = 0;
    WidgetMap.positionsArr = [];
    WidgetMap.yScaleData = {};
    cashelper.clearAllCosmeticElements();
    WidgetMap.map.removeLayer(WidgetMap.currentVectorLayer);
    WidgetMap.currentVectorLayer = undefined;
    this._layers = [];
    WidgetMap.currentVectorGroupLayer.setLayers(new ol.Collection());
};

/**
 * Копирование casLayer, featuresProjLayer и добавление их в карту
 * @param [array.<Object>]layers
 * @param groupId идентификатор группы слоёв
 */
LayerManager.prototype.copyCASLayers = function(layers, groupId, group){
    //var tLayers = WidgetMap.currentVectorGroupLayer.getLayers();
    for(var i in layers){
        //если слой клонированный
        if(layers[i].LayerId.indexOf('#')!=-1){
            var layer = this.getVectorLayerByName(layers[i].layer);
            var copy = this.copyCASLayer(layer, layers[i].LayerId, layers[i].filter, layers[i].LayerDescr || layers[i].LayerName, layers[i].filterAsParam, layers[i].groupId, group, layers[i].selectedLineObj);
            this._layers.push(copy);
            this.registerLayer(copy.layer);
        }
    }
};

/**
 * Копирование слоя
 * @param layer
 */
LayerManager.prototype.copyCASLayer = function (layer, uniqueLayerName, filter, descr, filterAsParam, groupId, group, selectedLineObj) {
    var layerObj = {};
    layerObj.id = layer.id;
    layerObj.dataProvider = layer.dataProvider;
    layerObj.layerQueryId = layer.layerQueryId;
    layerObj.isTextAllow = layer.isTextAllow;
    layerObj.visible = layer.visible;
    layerObj.groupId = groupId; // идентификатор группы
    layerObj.group = group; // группы
    var wkbLayer = new map.layer.CASLayer({//временно продублировал атрибуты
        name: layer.layer.name,
        uniqueLayerName: uniqueLayerName,
        mapName: layer.layer.mapName,
        layerSchema: layer.layer.layerSchema,
        layerTable: layer.layer.layerTable,
        sourceName: layer.layer.sourceName,
        filter: filter,
        filterAsParam: filterAsParam,
        selectedLineObj: selectedLineObj,
        legendDescr: descr,
        layerNameSynonym: layer.layer.layerNameSynonym,
        sourceDescr: layer.layer.sourceDescr,
        dataType: layer.layer.dataType,
        labelField: layer.layer.labelField,
        requestFilterData: layer.layer.requestFilterData,
        classField: layer.layer.classField,
        cover: layer.layer.cover,
        type: layer.layer.type,
        showInfo: layer.layer.showInfo,
        canFirstTimeCentering:layer.layer.canFirstTimeCentering,
        fitMap: layer.layer.fitMap,
        drawTypes: layer.layer.drawTypes,
        minResolution:layer.layer.minResolution,
        maxResolution:layer.layer.maxResolution,
        order: layer.layer.order,
        mapOrder: layer.layer.mapOrder,
        zIndex: layer.layer.zIndex,
        maxLayerZoom:layer.layer.maxLayerZoom,
        minLayerZoom:layer.layer.minLayerZoom,
        spacing: layer.layer.spacing,
        layerQueryId: layer.layer.layerQueryId,
        dataProvider:layer.layer.dataProvider,
        groupId: groupId, // идентификатор группы
        group: group, //объект группы со ссылками на дочерние диаграммы
    });
    layerObj.filter = layer.filter;
    layerObj.layer = wkbLayer;
    return layerObj;
};


/**
 * Получение векторного слоя
 * @param layerName
 * @returns {undefined}
 */
LayerManager.prototype.getVectorLayerByUniqueName = function(layerName) {
    //перенести в коллекцию ol.Collection и разобраться с forEach
    var curLayer = undefined;
    var vectorArr = this._layers;
    var i;
    for ( i = 0; i < vectorArr.length; i++) {
        curLayer = vectorArr[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer;
    }
    return undefined;
};



LayerManager.prototype.isTextAllowedByCASLayerName = function(layerName) {
    var that = this;
    var curLayer = undefined;
    var i;
    for ( i = 0; i < that._layers.length; i++) {
        curLayer = that._layers[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer.isTextAllow;
    }
    for (i = 0; i < that._rasterLayers.length; i++) {
        curLayer = that._rasterLayers[i];
        if (curLayer.layer.uniqueLayerName == layerName)
            return curLayer.isTextAllow;
    }
    return false;
};

/**
 * Функция возвращает перечень слоёв, у которых есть синоним layerName
 * @param layerName
 * @returns {[]}
 */
LayerManager.prototype.getLayersBySynonym = function(layerName){
	var layers = [layerName];
	var curLayer = undefined;
	var vectorArr = this.getVectorLayersByMode();
	var rasterArr = this.getRasterLayersByMode();
	var i;
	for ( i = 0; i < vectorArr.length; i++) {
		curLayer = vectorArr[i];
		//не добавляем слой дубль слоя базового
		if (curLayer.layer.layerNameSynonym.indexOf(layerName) !== -1 && layerName !== curLayer.layer.uniqueLayerName)
            layers.push(curLayer.layer.uniqueLayerName);
	}
	for (i = 0; i < rasterArr.length; i++) {
		curLayer = rasterArr[i];
        if (curLayer.layer.layerNameSynonym.indexOf(layerName) !== -1 && layerName !== curLayer.layer.uniqueLayerName)
            layers.push(curLayer.layer.uniqueLayerName);
	}
	/*if(layers.length === 0)
        layers.push(layerName);*/
	return layers;
}


LayerManager.getFileRequestParams = function(fileName){
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

    return {
        getSchema: false,
        descrId: 'SYS_SEM.xml#GET_XML_FILE',
        toElements: false,
        descrType: 'select',
        data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '">' +
            '<data FILE="' + fileName + '"/>' +
            '</root>'
    };
}

/**
 * Функция загрузки файлов стилей
 * @param baseStyleName самые базовые стили (Default_STYLE.xml)
 * @param [customStyleName]  доп стили, уникальные для типа карты(карта, пка, техсхема)
 */
LayerManager.prototype.loadDefaultStyles = function(baseStyleName, customStyleName) {
    var that = this;
    baseStyleName = baseStyleName || customStyleName;
    if(!baseStyleName) return;
    function getLayersResult(resultXml) {
        try {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') {
                App.errorReport(gis_layermanager_7, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_5'});
                return;
            }
            var layersDescriptionXml = $.parseXML(resultXml);
            layersDescriptionXml = layersDescriptionXml.firstChild;
            that.parseStyle(layersDescriptionXml, baseStyleName);
            if(customStyleName){
                App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, LayerManager.getFileRequestParams(customStyleName), getLayersResult, getLayersFault);
                customStyleName = undefined;
            }
        }
        catch(ex) {
            App.errorReport(gis_layermanager_7, ex.message, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_6'});// Распарсить XML не удалось, видимо это просто строка
        }
    }
    function getLayersFault(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== '') 
            App.errorReport(gis_layermanager_7, er, undefined, {filename:gis_filename_497, functionname:'gis_filename_497_8'});
    }
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, LayerManager.getFileRequestParams(baseStyleName), getLayersResult, getLayersFault);
};

LayerManager.prototype.setExpandValueToGroupLayers = function(expandValue, groupId){
    if(expandValue && groupId){
        this._layers.forEach(function(layer){
            if(layer && layer.layer && layer.layer.groupId === groupId){
                layer.layer.expandValue = expandValue;
            }
        })
    }
}
// FIXME add option to apply snapToPixel to all coordinates?
// FIXME can eliminate empty set styles and strokes (when all geoms skipped)
goog.provide('map.render.canvas.Replay');

/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.Replay = function (tolerance, maxExtent, resolution) {
	goog.base(this);

	/**
	 * @protected
	 * @type {number}
	 */
	this.tolerance = tolerance;

	/**
	 * @protected
	 * @const
	 * @type {ol.Extent}
	 */
	this.maxExtent = maxExtent;

	/**
	 * @private
	 * @type {ol.Extent}
	 */
	this.bufferedMaxExtent_ = null;

	/**
	 * @protected
	 * @type {number}
	 */
	this.maxLineWidth = 0;

	/**
	 * @protected
	 * @const
	 * @type {number}
	 */
	this.resolution = resolution;

	/**
	 * @private
	 * @type {Array.<*>}
	 */
	this.beginGeometryInstruction1_ = null;

	/**
	 * @private
	 * @type {Array.<*>}
	 */
	this.beginGeometryInstruction2_ = null;

	/**
	 * @protected
	 * @type {Array.<*>}
	 */
	this.instructions = [];

	/**
	 * @protected
	 * @type {Array.<number>}
	 */
	this.coordinates = [];

	/**
	 * @protected
	 * @type {Array.<number>}
	 */
	this.labels = [];

	/**
	 * @private
	 * @type {goog.vec.Mat4.Number}
	 */
	this.renderedTransform_ = goog.vec.Mat4.createNumber();

	/**
	 * @protected
	 * @type {Array.<*>}
	 */
	this.hitDetectionInstructions = [];

	/**
	 * @private
	 * @type {Array.<number>}
	 */
	this.pixelCoordinates_ = [];

	/**
	 * @private
	 * @type {!goog.vec.Mat4.Number}
	 */
	this.tmpLocalTransform_ = goog.vec.Mat4.createNumber();

	/**
	 * @private
	 * @type {ol.Transform}
	 */
	this.tmpLocalTransformInv_ = goog.vec.Mat4.createNumber();
};
goog.inherits(map.render.canvas.Replay, ol.render.VectorContext);


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} close Close.
 * @protected
 * @return {number} My end.
 */
map.render.canvas.Replay.prototype.appendFlatCoordinates =
	function (flatCoordinates, offset, end, stride, close) {

		var myEnd = this.coordinates.length;
		//var extent = this.getBufferedMaxExtent();
		var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
		var nextCoord = [NaN, NaN];
		var skipped = true;

		var i, lastRel, nextRel;
		for (i = offset + stride; i < end; i += stride) {
			nextCoord[0] = flatCoordinates[i];
			nextCoord[1] = flatCoordinates[i + 1];
			nextRel = ol.extent.Relationship.INTERSECTING;//ol.extent.coordinateRelationship(extent, nextCoord);
			if (nextRel !== lastRel) {
				if (skipped) {
					this.coordinates[myEnd++] = lastCoord[0];
					this.coordinates[myEnd++] = lastCoord[1];
				}
				this.coordinates[myEnd++] = nextCoord[0];
				this.coordinates[myEnd++] = nextCoord[1];
				skipped = false;
			} else if (nextRel === ol.extent.Relationship.INTERSECTING) {
				this.coordinates[myEnd++] = nextCoord[0];
				this.coordinates[myEnd++] = nextCoord[1];
				skipped = false;
			} else {
				skipped = true;
			}
			lastCoord[0] = nextCoord[0];
			lastCoord[1] = nextCoord[1];
			lastRel = nextRel;
		}

		// handle case where there is only one point to append
		if (i === offset + stride) {
			this.coordinates[myEnd++] = lastCoord[0];
			this.coordinates[myEnd++] = lastCoord[1];
		}

		if (close) {
			this.coordinates[myEnd++] = flatCoordinates[offset];
			this.coordinates[myEnd++] = flatCoordinates[offset + 1];
		}
		return myEnd;
	};

map.render.canvas.Replay.prototype.appendNewFlatCoordinates =
	function (flatCoordinates, offset, end, stride, close, labelType) {

		/*this.coordinates = flatCoordinates;
		 var myEnd = this.coordinates.length;
		 return myEnd;*/
		var myEnd = this.coordinates.length;
		//var extent = this.getBufferedMaxExtent();
		var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
		var nextCoord = [NaN, NaN];
		var skipped = true;

		var i, lastRel, nextRel;
		for (i = offset + stride; i < end; i += stride) {
			nextCoord[0] = flatCoordinates[i];
			nextCoord[1] = flatCoordinates[i + 1];
			nextRel = ol.extent.Relationship.INTERSECTING;//ol.extent.coordinateRelationship(extent, nextCoord);//ol.extent.Relationship.INTERSECTING
			if (nextRel !== lastRel) {
				if (skipped) {
					this.coordinates[myEnd++] = lastCoord[0];
					this.coordinates[myEnd++] = lastCoord[1];
				}
				this.coordinates[myEnd++] = nextCoord[0];
				this.coordinates[myEnd++] = nextCoord[1];
				//_labels[labelType].push(globalPointsLabels_[labelType][i/2]);
				skipped = false;
			} else if (nextRel === ol.extent.Relationship.INTERSECTING) {
				this.coordinates[myEnd++] = nextCoord[0];
				this.coordinates[myEnd++] = nextCoord[1];
				//_labels[labelType].push(globalPointsLabels_[labelType][i/2]);
				skipped = false;
			} else {
				skipped = true;
			}
			lastCoord[0] = nextCoord[0];
			lastCoord[1] = nextCoord[1];
			lastRel = nextRel;
		}
		// handle case where there is only one point to append
		if (i === offset + stride) {
			this.coordinates[myEnd++] = lastCoord[0];
			this.coordinates[myEnd++] = lastCoord[1];
		}

		if (close) {
			this.coordinates[myEnd++] = flatCoordinates[offset];
			this.coordinates[myEnd++] = flatCoordinates[offset + 1];
		}
		return myEnd;
	};

// чем меньше приоритет, тем лучше
map.render.canvas.Replay.prototype.hasCollision_ = function (feature, width, height, x, y, priority, type) {
	//поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
	var layerId = feature.get('layerId');//feature.get('labelType');
	if (layerId === undefined) {
		return true;
	}
	if (type === undefined)
		type = 'label';
	x += _dx;
	y += _dy;
	var min_x = Math.floor(x / _dx);
	var min_y = Math.floor(y / _dy);
	var max_y = min_y;
	var max_x = min_x;
	if (feature && feature.get('styleType') != 'mark' && feature.get('styleType') != 'icon') {
		max_x = Math.floor((x + width) / _dx);
		max_y = Math.floor((y + height) / _dy);
	}
	var i, j;

	if (min_x < 0 || min_y < 0)
		return true;
	if (_visibleMatrix[layerId] === undefined)
		return true;
	if (max_x >= _visibleMatrix[layerId].length)
		return true;
	if (max_y >= _visibleMatrix[layerId][0].length)
		return true;

	try {
		for (i = min_x; i <= max_x; i++) {
			for (j = min_y; j <= max_y; j++) {
				if (_visibleMatrix[layerId] !== undefined && _visibleMatrix[layerId][i][j][type] !== undefined) {
					// кто-то уже есть
					var t = _visibleMatrix[layerId][i][j][type];
					if ((priority > t.priority)) {
						// тут должен быть новый объект
						//deleteBlockObject(t.obj, i*_dx, j*_dy, type);
					} else
						return true;
				}
			}
		}
	} catch (ex) {
	}

	return false;
};

map.render.canvas.Replay.prototype.hasTextPointCollision_ = function (feature, width, height, x, y, priority, type) {
	//поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
	var layerId = feature.get('layerId');
	if (layerId === undefined)
		return false;
	if (type === undefined)
		type = 'label';
	if (layerId == 'labelLegend' || layerId == 'labelLegendIcon')
		return false;
	x += _dx;
	y += _dy;
	//feature = null;
	var min_x = Math.floor(x / _dx);
	var min_y = Math.floor(y / _dy);
	var max_y = min_y;
	var max_x = min_x;
	if (feature) {
		max_x = Math.floor((x + width) / _dx);
		max_y = Math.floor((y + height) / _dy);
	}
	var i, j;
	if (min_x < 0 || min_y < 0)
		return true;

	if (max_x >= _visibleTextMatrix[type].length)
		return true;
	if (max_y >= _visibleTextMatrix[type][0].length)
		return true;

	try {
		for (i = min_x; i <= max_x; i++) {
			for (j = min_y; j <= max_y; j++) {
				if (_visibleTextMatrix[type] !== undefined && _visibleTextMatrix[type][i] !== undefined && _visibleTextMatrix[type][i][j] !== undefined) {
					// кто-то уже есть
					var t = _visibleTextMatrix[type][i][j];
					if ((priority < t.priority)) {
						//удаляем с матрице всё, связанное с этим объектом и даем разрешение на добавление нового элемента в матрицу
						this.deleteTextPointObject_(t);
						return false;
					} else
						return true;
				}
			}
		}
	} catch (ex) {
		//console.log('sd');
	}
	return false;
};

map.render.canvas.Replay.prototype.findTextPointObject_ = function (unique) {
	if(unique && _visibleTextMatrix && _visibleTextMatrix['label'] && _visibleTextMatrix['label'].length > 0){
		var vtm = _visibleTextMatrix['label'];
		var i = 0, j = 0;
		for (; i < vtm.length; i++) {
			if(vtm[i].length > 0){
				for (j = 0; j < vtm[i].length; j++) {
					if(vtm[i][j] && vtm[i][j].unique === unique)
						return vtm[i][j];
				}
			}
		}
	}
}

map.render.canvas.Replay.prototype.deleteTextPointObject_ = function (t) {
	if (t === undefined) return;
	var min_x = t.minX;
	var min_y = t.minY;
	var max_x = t.maxX;
	var max_y = t.maxY;

	if (min_x < 0 || min_y < 0)
		return;
	if (max_x >= _visibleTextMatrix['label'].length)
		return;
	if (max_y >= _visibleTextMatrix['label'][0].length)
		return true;
	var i, j;
	//удаляем из матрицы
	for (i = min_x; i <= max_x; i++) {
		for (j = min_y; j <= max_y; j++) {
			if (_visibleTextMatrix['label'][i] && _visibleTextMatrix['label'][i][j] !== undefined)
				_visibleTextMatrix['label'][i][j] = undefined;
		}
	}
	//удаляем из объектов
	var k;
	for (k = _LABELS.length - 1; k >= 0; k--) {
		if (_LABELS[k].unique == t.unique) {
			_LABELS.splice(k, 1);
			break;
		}
	}
};

map.render.canvas.Replay.prototype.addTextPointObject_ = function (feature, width, height, coordX, coordY, x, y, priority, type, lock, label) {
	//поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
	if (!goog.isDef(coordX) || !goog.isDef(coordY))
		return '';
	var layerId = feature.get('labelType');
	if (!goog.isDef(lock))
		lock = true;
	if (!goog.isDef(type))
		type = 'label';
	x += _dx;
	y += _dy;
	var min_x = Math.floor(x / _dx);
	var max_x = min_x;
	var min_y = Math.floor(y / _dy);
	var max_y = min_y;
	if (goog.isDef(feature)) {
		max_x = Math.floor((x + width) / _dx);
		max_y = Math.floor((y + height) / _dy);
	}
	var i, j;
	var unique = layerId + '_' + coordX + '_' + coordY;
	if (min_x < 0 || min_y < 0)
		return unique;
	if (max_x >= _visibleTextMatrix[type].length)
		return unique;
	if (lock == true) {
		for (i = min_x; i <= max_x; i++) {
			for (j = min_y; j <= max_y; j++) {
				var sav;
				if (!goog.isDef(_visibleTextMatrix[type][i][j])) {
					_visibleTextMatrix[type][i][j] = {};
					if (!goog.isDef(_visibleTextMatrix[type][i][j]))
						_visibleTextMatrix[type][i][j] = {};
					sav = _visibleTextMatrix[type][i][j];
					sav.priority = priority;
					sav.obj = feature;
					sav.minX = min_x;
					sav.maxX = max_x;
					sav.minY = min_y;
					sav.maxY = max_y;
					sav.label = label;
					sav.unique = layerId + '_' + coordX + '_' + coordY;
					unique = sav.unique;
					_visibleTextMatrix[type][i][j] = sav;
				} else if (!goog.isDef(_visibleTextMatrix[type][i][j])) {
					if (!goog.isDef(_visibleTextMatrix[type][i][j]))
						_visibleTextMatrix[type][i][j] = {};
					if (!goog.isDef(_visibleMatrix[layerId][i][j][type]))
						_visibleMatrix[layerId][i][j][type] = {};
					sav = _visibleTextMatrix[type][i][j];
					sav.priority = priority;
					sav.obj = feature;
					sav.minX = min_x;
					sav.maxX = max_x;
					sav.minY = min_y;
					sav.maxY = max_y;
					sav.label = label;
					sav.unique = layerId + '_' + coordX + '_' + coordY;
					unique = sav.unique;
					_visibleTextMatrix[type][i][j] = sav;
				}
			}
		}
	} else {
		unique = layerId + '_' + coordX + '_' + coordY;
	}
	return unique;
};

//Добавляем точки в мультиполигоне
map.render.canvas.Replay.prototype.addObject_ = function (feature, width, height, x, y, add, priority, type, lock) {
	//поскольку массив всегда начинается с 0, а объекты должны сохраняться со смещением
	var layerId = feature.get('layerId');
	if (lock === undefined)
		lock = true;
	x += _dx;
	y += _dy;

	var min_x = Math.floor(x / _dx);
	var max_x = min_x;
	var min_y = Math.floor(y / _dy);
	var max_y = min_y;
	if (feature !== undefined && feature.get('styleType') != 'mark' && feature.get('mapName') != 'CAS_PODS_EQUIP_Layers.xml') {//если слой ПКА не из основного оборудования, то не учитываем размеры иконки
		max_x = Math.floor((x + width) / _dx);
		max_y = Math.floor((y + height) / _dy);
	}
	var i;
	var j;
	if (min_x < 0 || min_y < 0)
		return;
	if (max_x >= _visibleMatrix[layerId].length)
		return;
	if (max_y >= _visibleMatrix[layerId][0].length)
		return;
	if (lock == true) {
		for (i = min_x; i <= max_x; i++) {
			for (j = min_y; j <= max_y; j++) {
				var sav;
				if (_visibleMatrix[layerId][i][j] === undefined) {
					_visibleMatrix[layerId][i][j] = {};
					if (_visibleMatrix[layerId][i][j][type] === undefined)
						_visibleMatrix[layerId][i][j][type] = {};
					sav = _visibleMatrix[layerId][i][j][type];
					sav.priority = priority;
					sav.obj = feature;
					_visibleMatrix[layerId][i][j][type] = sav;
				} else if (_visibleMatrix[layerId][i][j][type] === undefined) {
					if (_visibleMatrix[layerId][i][j] === undefined)
						_visibleMatrix[layerId][i][j] = {};
					if (_visibleMatrix[layerId][i][j][type] === undefined)
						_visibleMatrix[layerId][i][j][type] = {};
					sav = _visibleMatrix[layerId][i][j][type];
					sav.priority = priority;
					sav.obj = feature;
					_visibleMatrix[layerId][i][j][type] = sav;
				}
			}
		}
	}
};


map.render.canvas.Replay.prototype.rotateText_ = function (p1, p2, width, height, vAlign, hAlign, mode, dX, dY, resolution, x, y) {
	//меняем vAlign,hAlign,mode
	vAlign = 'middle';
	hAlign = 'right';
	var rotation = 0;
	var tempRotation = rotation;//используем её, чтобы не запортить, которая в return пойдет

	if (p1 != null && p2 != null) {
		rotation = -Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
	}
	var w = width;
	var h = height;
	var kh = 1;
	var kx = 0;
	var ky = 0;
	//2 новых режима - расположение подписи над центром объекта и под центром объекта
	if (vAlign == "middleTop")
		kh = 1;
	if (vAlign == "middleBottom")
		kh = 0;
	if (vAlign == "middle")
		kh = 0.5;
	if (vAlign == "bottom") {
		kh = 0;
		ky = -1;
	}
	if (vAlign == "top")
		ky = 1;

	var kw = 0;
	if (hAlign == "left") {
		kw = 1;
		if (vAlign == "middle") {
			kx = 1;
		}
	}
	if (hAlign == "right")
		if (vAlign == "middle")
			kx = -1;
	if (hAlign == 'center')
		kw = 0.5;

	if (false && mode != "normal" && (!goog.isNull(p1) && !goog.isNull(p2))) {
		var l = Math.sqrt(Math.pow(p2.y - p1.y, 2) + Math.pow(p2.x - p1.x, 2));
		x = dX + p1.x / resolution - 2;
		y = dY - (p1.y + l) / resolution;
	} else {
		if ((rotation > 90) || (rotation < -90)) {
			// добавляем смещение
			rotation = rotation + 180;
			tempRotation = rotation;
			if (rotation > 180)
				tempRotation = rotation - 360;
			x -= w * Math.cos(tempRotation * Math.PI / 180); //- h*kh*Math.sin(lbl.rotation*Math.PI/180);
			y -= w * Math.sin(tempRotation * Math.PI / 180);//+ h*kh*Math.cos(lbl.rotation*Math.PI/180);
			if (tempRotation < 0)
				y -= 5;
			else
				y += 5;
		}

		x += (ky * dY + h * kh) * Math.sin(tempRotation * Math.PI / 180);
		y -= (ky * dY + h * kh) * Math.cos(tempRotation * Math.PI / 180);
		x -= (kx * dX + w * kw) * Math.cos(tempRotation * Math.PI / 180);
		y += (kx * dX + w * kw) * Math.sin(tempRotation * Math.PI / 180);
	}
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return [x - 2, y, rotation];
};
map.render.canvas.Replay.prototype.rotateLineText_ = function (p1, p2, width, height, vAlign, hAlign, mode, dX, dY, resolution, x, y) {
	dY = height * LABEL_FONT_RATIO;
	var tempP = p1;
	var xf, yf, xm, ym;
	if (p1.x > p2.x) {
		p1 = p2;
		p2 = tempP;
	}
	var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p1.x, p1.y]);
	x = pixelCoord[0];
	y = pixelCoord[1];
	var pixelCoordf = WidgetMap.map.getPixelFromCoordinate([p2.x, p2.y]);
	xf = pixelCoordf[0];
	yf = pixelCoordf[1];
	xm = (xf + x) / 2;
	ym = (y + yf) / 2;
	var rotation = 0;
	if (p1 !== null && p2 !== null) {
		rotation = -Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
	}
	var tempRotation = -rotation;
	var offsetRotation = tempRotation;
	if (tempRotation < 0) {
		tempRotation += 180;
	}
	if (tempRotation == 0) {
		tempRotation = 90;
	}
	if (tempRotation == 90) {
		tempRotation = 0;
	}
	//top/bottom меняются месятами в textStyle.baseline, textStyle.align
	width /= 1.1;
	if (vAlign === "top") {
		x = xm - width * Math.cos(offsetRotation * Math.PI / 180) + dY * Math.cos((90 - offsetRotation) * Math.PI / 180);
		y = ym + width * Math.sin(offsetRotation * Math.PI / 180) + dY * Math.sin((90 - offsetRotation) * Math.PI / 180);
	}
	if (vAlign === "middle") {
		x = xm;
		y = ym;
	}
	if (vAlign === "bottom") {
		x = xm - width * Math.cos(offsetRotation * Math.PI / 180) - dY * Math.sin((90 - tempRotation) * Math.PI / 180);
		y = ym + width * Math.sin(offsetRotation * Math.PI / 180) - dY * Math.cos((90 - tempRotation) * Math.PI / 180);
	}
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return [x, y, rotation];
};

map.render.canvas.Replay.prototype.rotateLineText1_ = function (p1, p2, width, height, vAlign, hAlign, mode, dX, dY, resolution, x, y) {
	dX = width;
	dY = height;
	var tempP = p1;
	if (p1.x > p2.x) {
		var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p2.x, p2.y]);
		x = pixelCoord[0];
		y = pixelCoord[1];
		p1 = p2;
		p2 = tempP;
	}
	var kx = 0, ky = 0;
	if (vAlign === "top") ky = 1;
	if (vAlign === "middle") ky = 0;
	if (vAlign === "bottom") ky = -1;
	/*if (hAlign === "left")   {kx = -1;dX = width/2}
	if (hAlign === "right")  {kx = 1;dX = width*2}
	if (hAlign === 'center') {kx = 0;dX = width}*/

	var rotation = 0;
	if (p1 != null && p2 != null) {
		rotation = -Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
	}
	if ((rotation > 90) || (rotation < -90)) {
		rotation = rotation + 180;
	}
	x = x + ky * dY * Math.sin((90 - rotation) * Math.PI / 180);
	//+ kx * Math.cos(rotation*Math.PI/180);
	y = y + ky * dY * Math.cos((rotation + 90) * Math.PI / 180);
	//+ kx * dX * Math.sin(rotation*Math.PI/180);
	//переводим в радианы
	rotation = rotation * Math.PI / 180;
	return [x, y, rotation];
};

map.render.canvas.Replay.prototype.isPlaceFree = function (feature, width, height, x, y) {
	var lSpacing = feature.get('spacing');
	if (lSpacing == '')
		lSpacing = 'point';
	//если шаг матрицы мал, то считаем, что не разрядки
	/*if(_dx<=1 && _dy<=1)
	 return true;*/
	if (feature.get('labelType') == 'labelLegend' || feature.get('labelType') == 'labelLegendIcon'/* && feature.get('styleType') == 'mark'*/)
		return true;
	if (!this.hasCollision_(feature, width, height, x, y, feature.get('zIndex'), lSpacing))
		return true;
	return false;
};

map.render.canvas.Replay.prototype.takePlace = function (feature, width, height, x, y) {
	var lSpacing = feature.get('spacing');
	if (lSpacing == '')
		lSpacing = 'point';
	try {
		this.addObject_(feature, width, height, x, y, false, feature.get('zIndex'), lSpacing);
	} catch (err) {
		//console.log(err);
	}

};


/**
 * @protected
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.Feature} feature Feature.
 */
map.render.canvas.Replay.prototype.beginGeometry = function (geometry, feature) {
	this.beginGeometryInstruction1_ =
		[ol.render.canvas.Instruction.BEGIN_GEOMETRY, feature, 0];
	this.instructions.push(this.beginGeometryInstruction1_);
	this.beginGeometryInstruction2_ =
		[ol.render.canvas.Instruction.BEGIN_GEOMETRY, feature, 0];
	this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
};


/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {goog.vec.Mat4.Number} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 * @param {Array.<*>} instructions Instructions array.
 * @param {function(ol.Feature): T|undefined} featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
map.render.canvas.Replay.prototype.replay_ = function (
	context, pixelRatio, transform, viewRotation, skippedFeaturesHash,
	instructions, featureCallback, opt_hitExtent) {
	/** @type {Array.<number>} */
	var pixelCoordinates;
	if (ol.vec.Mat4.equals2D(transform, this.renderedTransform_)) {
		pixelCoordinates = this.pixelCoordinates_;
	} else {
		pixelCoordinates = ol.geom.flat.transform.transform2D(
			this.coordinates, 0, this.coordinates.length, 2,
			transform, this.pixelCoordinates_);
		goog.vec.Mat4.setFromArray(this.renderedTransform_, transform);
		goog.asserts.assert(pixelCoordinates === this.pixelCoordinates_,
			'pixelCoordinates should be the same as this.pixelCoordinates_');
	}
	var property;
	for (property in skippedFeaturesHash) {
		property = false;
		break;
	}
	var isEmpty = !property;
	var skipFeatures = !isEmpty;
	var i = 0; // instruction index
	var ii = instructions.length; // end of instructions
	var d = 0; // data index
	var dd; // end of per-instruction data
	var styleArr = [];
	var localTransform = this.tmpLocalTransform_;
	var localTransformInv = this.tmpLocalTransformInv_;
	var prevX, prevY, roundX, roundY;
	var pendingFill = 0;
	var pendingStroke = 0;

	_TRANSFORM = localTransform;
	// When the batch size gets too big, performance decreases. 200 is a good
	// balance between batch size and number of fill/stroke instructions.
	var batchSize =
		this.instructions != instructions || this.overlaps ? 0 : 200;


	while (i < ii) {
		var instruction = instructions[i];
		var type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);
		var feature, fill, stroke, text, x, y, geometry, lineStringId, textStyle;
		switch (type) {
			case ol.render.canvas.Instruction.BEGIN_GEOMETRY:
				//console.time('!!'+random);
				feature = /** @type {ol.Feature} */ (instruction[1]);
				if (_CURRENT_RENDERED_LAYERS.indexOf(feature.get('layerId')) == -1)
					_CURRENT_RENDERED_LAYERS.push(feature.get('layerId'));//закидываем в массив текущие отрендеренные слои
				var featureUid = goog.getUid(feature).toString();
				if (goog.isDef(skippedFeaturesHash[featureUid])) {
					i = /** @type {number} */ (instruction[2]);
				} else if (goog.isDef(opt_hitExtent) && !ol.extent.intersects(
					opt_hitExtent, feature.getGeometry().getExtent())) {
					i = /** @type {number} */ (instruction[2]);
				} else {
					++i;
				}
				break;
			case ol.render.canvas.Instruction.BEGIN_PATH:
				context.beginPath();
				++i;
				break;
			case ol.render.canvas.Instruction.CIRCLE:
				goog.asserts.assert(goog.isNumber(instruction[1]),
					'second instruction should be a number');
				d = /** @type {number} */ (instruction[1]);
				var x1 = pixelCoordinates[d];
				var y1 = pixelCoordinates[d + 1];
				var x2 = pixelCoordinates[d + 2];
				var y2 = pixelCoordinates[d + 3];
				var dx = x2 - x1;
				var dy = y2 - y1;
				var r = Math.sqrt(dx * dx + dy * dy);
				context.moveTo(x1 + r, y1);
				context.arc(x1, y1, r, 0, 2 * Math.PI, true);
				++i;
				break;
			case ol.render.canvas.Instruction.CLOSE_PATH:
				context.closePath();
				++i;
				break;
			case ol.render.canvas.Instruction.DRAW_IMAGE:
				goog.asserts.assert(goog.isNumber(instruction[1]),
					'second instruction should be a number');
				d = /** @type {number} */ (instruction[1]);
				goog.asserts.assert(goog.isNumber(instruction[2]),
					'third instruction should be a number');
				dd = /** @type {number} */ (instruction[2]);
				var image =  /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */
					(instruction[3]);
				// Remaining arguments in DRAW_IMAGE are in alphabetical order
				var anchorX = /** @type {number} */ (instruction[4]) * pixelRatio;
				var anchorY = /** @type {number} */ (instruction[5]) * pixelRatio;
				var height = /** @type {number} */ (instruction[6]);
				var opacity = /** @type {number} */ (instruction[7]);
				var originX = /** @type {number} */ (instruction[8]);
				var originY = /** @type {number} */ (instruction[9]);
				var rotateWithView = /** @type {boolean} */ (instruction[10]);
				var rotation = /** @type {number} */ (instruction[11]);
				var scale = /** @type {number} */ (instruction[12]);
				var snapToPixel = /** @type {boolean} */ (instruction[13]);
				var width = /** @type {number} */ (instruction[14]);
				if (rotateWithView) {
					rotation += viewRotation;
				}
				var lId = feature.get('layerId');
				var lay = WidgetMap.layerManager.getLayerByName(lId);
				var layerId = feature.get('labelType');
				var g = 0;

				if (GLOBAL_REDRAW[layerId] == false && goog.isDef(layerId)) {
					for (g; g < GLOBAL_REDRAW_ARR[layerId].length; g++) {
						x = pixelCoordinates[GLOBAL_REDRAW_ARR[layerId][g]] - anchorX;
						y = pixelCoordinates[GLOBAL_REDRAW_ARR[layerId][g] + 1] - anchorY;
						if (snapToPixel) {
							x = (x + 0.5) | 0;
							y = (y + 0.5) | 0;
						}
						if (scale != 1 || rotation !== 0) {
							var centerX = x + anchorX;
							var centerY = y + anchorY;
							ol.vec.Mat4.makeTransform2D(
								localTransform, centerX, centerY, scale, scale,
								rotation, -centerX, -centerY);
							context.setTransform(
								goog.vec.Mat4.getElement(localTransform, 0, 0),
								goog.vec.Mat4.getElement(localTransform, 1, 0),
								goog.vec.Mat4.getElement(localTransform, 0, 1),
								goog.vec.Mat4.getElement(localTransform, 1, 1),
								goog.vec.Mat4.getElement(localTransform, 0, 3),
								goog.vec.Mat4.getElement(localTransform, 1, 3));
						}
						var alpha = context.globalAlpha;
						if (opacity != 1) {
							context.globalAlpha = alpha * opacity;
						}
						context.drawImage(image, x, y, width, height);

						if (opacity != 1) {
							context.globalAlpha = alpha;
						}
						if (scale != 1 || rotation !== 0) {
							context.setTransform(1, 0, 0, 1, 0, 0);
						}
					}
				} else {
					for (; d < dd; d += 2) {
						x = pixelCoordinates[d] - anchorX;
						y = pixelCoordinates[d + 1] - anchorY;
						if (snapToPixel) {
							x = (x + 0.5) | 0;
							y = (y + 0.5) | 0;
						}
						if (goog.isDef(layerId) && GLOBAL_REDRAW[layerId] == true) {
							if (!this.isPlaceFree(feature, width, height, x, y)) {
								continue;
							}
							if (scale != 1 || rotation !== 0) {
								var centerX = x + anchorX;
								var centerY = y + anchorY;
								ol.vec.Mat4.makeTransform2D(
									localTransform, centerX, centerY, scale, scale,
									rotation, -centerX, -centerY);
								context.setTransform(
									goog.vec.Mat4.getElement(localTransform, 0, 0),
									goog.vec.Mat4.getElement(localTransform, 1, 0),
									goog.vec.Mat4.getElement(localTransform, 0, 1),
									goog.vec.Mat4.getElement(localTransform, 1, 1),
									goog.vec.Mat4.getElement(localTransform, 0, 3),
									goog.vec.Mat4.getElement(localTransform, 1, 3));
							}
							var alpha = context.globalAlpha;
							if (opacity != 1) {
								context.globalAlpha = alpha * opacity;
							}
							this.takePlace(feature, width, height, x, y);
							if (goog.isDef(layerId)) {
								//GLOBAL_REDRAW_ARR[layerId].push({x:this.coordinates[d],y:this.coordinates[d+1]});
								GLOBAL_REDRAW_ARR[layerId].push(d);
							}

							if (goog.isDef(lay))
								lay.layer.featureProjLayer.getSource().hasGeometryInExtent = true;
							context.drawImage(image, x, y, width, height);
							if (opacity != 1) {
								context.globalAlpha = alpha;
							}
							if (scale != 1 || rotation !== 0) {
								context.setTransform(1, 0, 0, 1, 0, 0);
							}
						} else {
							if (scale != 1 || rotation !== 0) {
								var centerX = x + anchorX;
								var centerY = y + anchorY;
								ol.vec.Mat4.makeTransform2D(
									localTransform, centerX, centerY, scale, scale,
									rotation, -centerX, -centerY);
								context.setTransform(
									goog.vec.Mat4.getElement(localTransform, 0, 0),
									goog.vec.Mat4.getElement(localTransform, 1, 0),
									goog.vec.Mat4.getElement(localTransform, 0, 1),
									goog.vec.Mat4.getElement(localTransform, 1, 1),
									goog.vec.Mat4.getElement(localTransform, 0, 3),
									goog.vec.Mat4.getElement(localTransform, 1, 3));
							}
							var alpha = context.globalAlpha;
							if (opacity != 1) {
								context.globalAlpha = alpha * opacity;
							}
							//console.log('#lId='+ lId+' width='+width+' height='+height);
							context.drawImage(image, x, y, width, height);
							if (opacity != 1) {
								context.globalAlpha = alpha;
							}
							if (scale != 1 || rotation !== 0) {
								context.setTransform(1, 0, 0, 1, 0, 0);
							}
						}
					}
				}
				GLOBAL_REDRAW[feature.get('labelType')] = false;
				++i;
				break;
			case ol.render.canvas.Instruction.DRAW_TEXT:
				//console.time('$$'+random);
				goog.asserts.assert(goog.isNumber(instruction[1]),
					'2nd instruction should be a number');
				d = /** @type {number} */ (instruction[1]);
				goog.asserts.assert(goog.isNumber(instruction[2]),
					'3rd instruction should be a number');
				dd = /** @type {number} */ (instruction[2]);
				goog.asserts.assert(goog.isString(instruction[3]),
					'4th instruction should be a number');
				text = /** @type {string} */ (instruction[3]);
				goog.asserts.assert(goog.isNumber(instruction[4]),
					'5th instruction should be a number');
				var offsetX = /** @type {number} */ (instruction[4]) * pixelRatio;
				goog.asserts.assert(goog.isNumber(instruction[5]),
					'6th instruction should be a number');
				var offsetY = /** @type {number} */ (instruction[5]) * pixelRatio;
				goog.asserts.assert(goog.isNumber(instruction[6]),
					'7th instruction should be a number');
				rotation = /** @type {number} */ (instruction[6]);
				goog.asserts.assert(goog.isNumber(instruction[7]),
					'8th instruction should be a number');
				scale = /** @type {number} */ (instruction[7]) * pixelRatio;
				goog.asserts.assert(goog.isBoolean(instruction[8]),
					'9th instruction should be a boolean');
				fill = /** @type {boolean} */ (instruction[8]);
				goog.asserts.assert(goog.isBoolean(instruction[9]),
					'10th instruction should be a boolean');
				stroke = /** @type {boolean} */ (instruction[9]);

				geometry = /** @type {MultiLineString|LineString} */ (instruction[10]);
				lineStringId = /** @type {MultiLineString|LineString} */ (instruction[11]);
				textStyle = /** @type {MultiLineString|LineString} */ (instruction[12]);
				var layerId = feature.get('labelType');
				var overlap = '0';
				var layerGeoType = geometry.getType();
				if (layerGeoType == 'MultiPolygon') {
					for (; d < dd; d += 2) {
						x = pixelCoordinates[d] + offsetX;
						y = pixelCoordinates[d + 1] + offsetY;
						if (scale != 1 || rotation !== 0) {
							ol.vec.Mat4.makeTransform2D(
								localTransform, x, y, scale, scale, rotation, -x, -y);
							context.setTransform(
								goog.vec.Mat4.getElement(localTransform, 0, 0),
								goog.vec.Mat4.getElement(localTransform, 1, 0),
								goog.vec.Mat4.getElement(localTransform, 0, 1),
								goog.vec.Mat4.getElement(localTransform, 1, 1),
								goog.vec.Mat4.getElement(localTransform, 0, 3),
								goog.vec.Mat4.getElement(localTransform, 1, 3));
						}
						if (stroke) {
							context.strokeText(text, x, y);
						}
						if (fill) {
							context.fillText(text, x, y);
						}
						if (scale != 1 || rotation !== 0) {
							context.setTransform(1, 0, 0, 1, 0, 0);
						}
					}
				} else if (layerGeoType == 'LineString') {
				}//если подпись для точечного объекта
				else {
					var lay = WidgetMap.layerManager.getLayerByName(feature.get('layerId'));
					if (goog.isDef(lay) && lay.isTextAllow == false) {
						++i;
						break;
					}
					overlap = WidgetMap.layerManager.getTextOverlapByNameAndType(feature.get('type'), 'Point');
					var g = 0;
					//необходимо из общего массива zindex слоёв забирать те, которые выше, без оверлапа. Остальные подписи у слоёв игнорируем
					//сначала пройтис по матрице и выставить всё в корректном порядке
					if (GLOBAL_REDRAW[layerId] == false && goog.isDef(layerId)) {
						//иначе забираем из матрицы подпись
						for (g; g < GLOBAL_REDRAW_ARR[layerId].length; g++) {
							//делаем поправку на d и dd, т.е. в мультифиче все геометрии в одном массиве со смещением для каждой фиче
							var position = (GLOBAL_REDRAW_ARR[layerId][g]) / 2;
							//поправил, т.к. некоторые слои типа водных переходов имеют фичи и точки и полигоны и не находит корректно позицию
							var newpos = (position - d / 2) < 0 ? position : (position - d / 2);
							text = feature.get('labelsObj')[newpos];

							if (!goog.isDefAndNotNull(text))
								continue;
							if (goog.isNull(text.label))
								continue;
							text = text.label;

							/*if (text === '1474.1')
								console.log('ddd')*/
							var offs = (position - d / 2) < 0 ? d : 0;
							x = pixelCoordinates[GLOBAL_REDRAW_ARR[layerId][g] + offs] + offsetX;
							y = pixelCoordinates[GLOBAL_REDRAW_ARR[layerId][g] + offs + 1] + offsetY;
							//получаем обновленную координату
							//если только начали двигать, то закидываем в матрицу и рисуем
							if (GLOBAL_LABEL_REDRAW[feature.get('labelType')] == true) {
								//если overlap=true, то подпись рисуется без разрядки всегда
								var canAdd = false;
								var addedObj = undefined;//объект с добавленными данными
								if (overlap == '1') {
									addedObj = this.addTextPointObject_(feature, context.measureText(text).width, 13, this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]], this.coordinates[GLOBAL_REDRAW_ARR[layerId][g] + 1], x, y, feature.get('zIndex'), 'label', false, text);
									canAdd = true;
								} else {
									//заносим в матрицу
									//предварительно корректируем x,y в зависимости от align и baseline
									var textWidth = context.measureText(text).width * 0.925;//-10;коэффициент, чтобы привести длину к флешевой
									var collX = x;
									var collY = y;
									if (!this.hasTextPointCollision_(feature, textWidth, 18, collX, collY, feature.get('zIndex'))) {
										addedObj = this.addTextPointObject_(feature, textWidth, 18,
											this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]], this.coordinates[GLOBAL_REDRAW_ARR[layerId][g] + 1],
											x, y, feature.get('zIndex'), 'label', undefined, text);
										canAdd = true;
									}
								}
								if (canAdd == true) {
									//сохраняем в _LABELS
									_LABELS.push({ type: 'point', unique: addedObj, text: text,
										textStyle: textStyle,
										coordX: this.coordinates[GLOBAL_REDRAW_ARR[layerId][g]],
										coordY: this.coordinates[GLOBAL_REDRAW_ARR[layerId][g] + 1],
										x: x, y: y,
										scale: scale, rotation: 0, context: context, localTransform: localTransform,
										fill: fill, stroke: stroke
									});
								}
								else{
									this.deleteTextPointObject_(this.findTextPointObject_(addedObj));
								}
							}
						}
						GLOBAL_LABEL_REDRAW[feature.get('labelType')] = false;
					} else {
						for (; d < dd; d += 2) {
							x = pixelCoordinates[d] + offsetX;
							y = pixelCoordinates[d + 1] + offsetY;
							if (scale != 1 || rotation !== 0) {
								ol.vec.Mat4.makeTransform2D(
									localTransform, x, y, scale, scale, rotation, -x, -y);
								context.setTransform(
									goog.vec.Mat4.getElement(localTransform, 0, 0),
									goog.vec.Mat4.getElement(localTransform, 1, 0),
									goog.vec.Mat4.getElement(localTransform, 0, 1),
									goog.vec.Mat4.getElement(localTransform, 1, 1),
									goog.vec.Mat4.getElement(localTransform, 0, 3),
									goog.vec.Mat4.getElement(localTransform, 1, 3));
							}

							if (stroke) {
								context.strokeText(text, x, y);
							}
							if (fill) {
								context.fillText(text, x, y);
							}
							if (scale != 1 || rotation !== 0) {
								context.setTransform(1, 0, 0, 1, 0, 0);
							}
						}
					}
				}
				++i;
				break;
			case ol.render.canvas.Instruction.END_GEOMETRY:
				if (featureCallback !== undefined) {
					feature =
						/** @type {ol.Feature|ol.render.Feature} */ (instruction[1]);
					var result = featureCallback(feature);
					if (result) {
						return result;
					}
				}
				++i;
				break;
			case ol.render.canvas.Instruction.FILL:
				context.fill();
				++i;
				break;
			case ol.render.canvas.Instruction.MOVE_TO_LINE_TO:
				goog.asserts.assert(goog.isNumber(instruction[1]),
					'2nd instruction should be a number');
				d = /** @type {number} */ (instruction[1]);
				goog.asserts.assert(goog.isNumber(instruction[2]),
					'3rd instruction should be a number');
				dd = /** @type {number} */ (instruction[2]);
				styleArr = (instruction[3]);
				if (goog.isDef(styleArr) && styleArr.length > 1) {
					var td = d;
					//context.closePath();
					context.beginPath();
					//забираем стиль у первого элемента массива,
					if (goog.isDef(styleArr) && styleArr.length > 1) {
						context.strokeStyle = styleArr[0].getStroke().getColor();
						context.lineWidth = styleArr[0].getStroke().getWidth();
					}
					//context.strokeStyle = strokeStyle;
					//context.lineWidth = lineWidth;
					context.moveTo(pixelCoordinates[d], pixelCoordinates[d + 1]);
					for (d += 2; d < dd; d += 2) {
						context.lineTo(pixelCoordinates[d], pixelCoordinates[d + 1]);
					}
					context.stroke();

					if (goog.isDef(styleArr) && styleArr.length > 1) {
						var sa = 1;
						for (sa; sa < styleArr.length; sa++) {
							//stub
							context.beginPath();
							var ted = td;
							context.strokeStyle = styleArr[sa].getStroke().getColor();
							context.lineWidth = styleArr[sa].getStroke().getWidth();
							context.moveTo(pixelCoordinates[ted], pixelCoordinates[ted + 1]);
							for (ted += 2; ted < dd; ted += 2) {
								context.lineTo(pixelCoordinates[ted], pixelCoordinates[ted + 1]);
							}
							context.stroke();
							//end stub
						}
					}
				} else {
					x = pixelCoordinates[d];
					y = pixelCoordinates[d + 1];
					roundX = (x + 0.5) | 0;
					roundY = (y + 0.5) | 0;
					if (roundX !== prevX || roundY !== prevY) {
						context.moveTo(x, y);
						prevX = roundX;
						prevY = roundY;
					}
					for (d += 2; d < dd; d += 2) {
						x = pixelCoordinates[d];
						y = pixelCoordinates[d + 1];
						roundX = (x + 0.5) | 0;
						roundY = (y + 0.5) | 0;
						if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
							context.lineTo(x, y);
							prevX = roundX;
							prevY = roundY;
						}
					}

				}
				++i;
				break;
			case ol.render.canvas.Instruction.SET_FILL_STYLE:
				goog.asserts.assert(goog.isString(instruction[1]),
					'2nd instruction should be a string');

				context.fillStyle = /** @type {ol.ColorLike} */ (instruction[1]);
				++i;
				break;
			case ol.render.canvas.Instruction.SET_STROKE_STYLE:
				goog.asserts.assert(goog.isString(instruction[1]),
					'2nd instruction should be a string');
				goog.asserts.assert(goog.isNumber(instruction[2]),
					'3rd instruction should be a number');
				goog.asserts.assert(goog.isString(instruction[3]),
					'4rd instruction should be a string');
				goog.asserts.assert(goog.isString(instruction[4]),
					'5th instruction should be a string');
				goog.asserts.assert(goog.isNumber(instruction[5]),
					'6th instruction should be a number');
				goog.asserts.assert(!goog.isNull(instruction[6]),
					'7th instruction should not be null');
				var usePixelRatio = goog.isDef(instruction[7]) ? instruction[7] : true;
				var lineWidth = /** @type {number} */ (instruction[2]);

				context.strokeStyle = /** @type {string} */ (instruction[1]);
				context.lineWidth = usePixelRatio ? lineWidth * pixelRatio : lineWidth;
				context.lineCap = /** @type {string} */ (instruction[3]);
				context.lineJoin = /** @type {string} */ (instruction[4]);
				context.miterLimit = /** @type {number} */ (instruction[5]);
				if (ol.has.CANVAS_LINE_DASH) {
					context.setLineDash(/** @type {Array.<number>} */ (instruction[6]));
				}
				++i;
				break;
			case ol.render.canvas.Instruction.SET_TEXT_STYLE:
				goog.asserts.assert(goog.isString(instruction[1]),
					'2nd instruction should be a string');
				goog.asserts.assert(goog.isString(instruction[2]),
					'3rd instruction should be a string');
				goog.asserts.assert(goog.isString(instruction[3]),
					'4th instruction should be a string');
				context.font = /** @type {string} */ (instruction[1]);
				//context.textAlign = /** @type {string} */ (instruction[2]);
				context.textBaseline = /** @type {string} */ (instruction[3]);
				++i;
				break;
			case ol.render.canvas.Instruction.STROKE:
				context.stroke();
				++i;
				break;
			default:
				goog.asserts.fail('Unknown canvas render instruction');
				++i; // consume the instruction anyway, to avoid an infinite loop
				break;
		}
	}
	// assert that all instructions were consumed
	goog.asserts.assert(i == instructions.length,
		'all instructions should be consumed');
	return undefined;
};


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {goog.vec.Mat4.Number} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object} skippedFeaturesHash Ids of features to skip
 */
map.render.canvas.Replay.prototype.replay = function (
	context, pixelRatio, transform, viewRotation, skippedFeaturesHash) {
	var instructions = this.instructions;
	this.replay_(context, pixelRatio, transform, viewRotation,
		skippedFeaturesHash, instructions, undefined);
};


/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {goog.vec.Mat4.Number} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object} skippedFeaturesHash Ids of features to skip
 * @param {function(ol.Feature): T=} opt_featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
map.render.canvas.Replay.prototype.replayHitDetection = function (
	context, transform, viewRotation, skippedFeaturesHash,
	opt_featureCallback, opt_hitExtent) {
	var instructions = this.hitDetectionInstructions;
	return this.replay_(context, 1, transform, viewRotation,
		skippedFeaturesHash, instructions, opt_featureCallback, opt_hitExtent);
};


/**
 * @private
 */
map.render.canvas.Replay.prototype.reverseHitDetectionInstructions_ =
	function () {
		var hitDetectionInstructions = this.hitDetectionInstructions;
		// step 1 - reverse array
		hitDetectionInstructions.reverse();
		// step 2 - reverse instructions within geometry blocks
		var i;
		var n = hitDetectionInstructions.length;
		var instruction;
		var type;
		var begin = -1;
		for (i = 0; i < n; ++i) {
			instruction = hitDetectionInstructions[i];
			type = /** @type {ol.render.canvas.Instruction} */ (instruction[0]);
			if (type == ol.render.canvas.Instruction.END_GEOMETRY) {
				goog.asserts.assert(begin == -1, 'begin should be -1');
				begin = i;
			} else if (type == ol.render.canvas.Instruction.BEGIN_GEOMETRY) {
				instruction[2] = i;
				goog.asserts.assert(begin >= 0,
					'begin should be larger than or equal to 0');
				ol.array.reverseSubArray(this.hitDetectionInstructions, begin, i);
				begin = -1;
			}
		}
	};


/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.Feature} feature Feature.
 */
map.render.canvas.Replay.prototype.endGeometry = function (geometry, feature) {
	goog.asserts.assert(!goog.isNull(this.beginGeometryInstruction1_),
		'this.beginGeometryInstruction1_ should not be null');
	this.beginGeometryInstruction1_[2] = this.instructions.length;
	this.beginGeometryInstruction1_ = null;
	goog.asserts.assert(!goog.isNull(this.beginGeometryInstruction2_),
		'this.beginGeometryInstruction2_ should not be null');
	this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
	this.beginGeometryInstruction2_ = null;
	var endGeometryInstruction =
		[ol.render.canvas.Instruction.END_GEOMETRY, feature];
	this.instructions.push(endGeometryInstruction);
	this.hitDetectionInstructions.push(endGeometryInstruction);
};


/**
 * FIXME empty description for jsdoc
 */
map.render.canvas.Replay.prototype.finish = goog.nullFunction;


/**
 * Get the buffered rendering extent.  Rendering will be clipped to the extent
 * provided to the constructor.  To account for symbolizers that may intersect
 * this extent, we calculate a buffered extent (e.g. based on stroke width).
 * @return {ol.Extent} The buffered rendering extent.
 * @protected
 */
map.render.canvas.Replay.prototype.getBufferedMaxExtent = function () {
	return this.maxExtent;
};


/**
 * @constructor
 * @extends {map.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.ImageReplay = function (tolerance, maxExtent, resolution) {
	goog.base(this, tolerance, maxExtent, resolution);

	/**
	 * @private
	 * @type {HTMLCanvasElement|HTMLVideoElement|Image}
	 */
	this.hitDetectionImage_ = null;

	/**
	 * @private
	 * @type {HTMLCanvasElement|HTMLVideoElement|Image}
	 */
	this.image_ = null;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.anchorX_ = undefined;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.anchorY_ = undefined;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.height_ = undefined;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.opacity_ = undefined;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.originX_ = undefined;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.originY_ = undefined;

	/**
	 * @private
	 * @type {boolean|undefined}
	 */
	this.rotateWithView_ = undefined;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.rotation_ = undefined;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.scale_ = undefined;

	/**
	 * @private
	 * @type {boolean|undefined}
	 */
	this.snapToPixel_ = undefined;

	/**
	 * @private
	 * @type {number|undefined}
	 */
	this.width_ = undefined;

};
goog.inherits(map.render.canvas.ImageReplay, map.render.canvas.Replay);


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} My end.
 */
map.render.canvas.ImageReplay.prototype.drawCoordinates_ =
	function (flatCoordinates, offset, end, stride) {
		return this.appendFlatCoordinates(
			flatCoordinates, offset, end, stride, false);
	};
map.render.canvas.ImageReplay.prototype.drawCoordinates1_ =
	function (flatCoordinates, offset, end, stride, labelType) {
		return this.appendNewFlatCoordinates(
			flatCoordinates, offset, end, stride, false);
	};


/**
 * @inheritDoc
 */
map.render.canvas.ImageReplay.prototype.drawPointGeometry =
	function (pointGeometry, feature) {
		if (goog.isNull(this.image_)) {
			return;
		}
		goog.asserts.assert(goog.isDef(this.anchorX_),
			'this.anchorX_ should be defined');
		goog.asserts.assert(goog.isDef(this.anchorY_),
			'this.anchorY_ should be defined');
		goog.asserts.assert(goog.isDef(this.height_),
			'this.height_ should be defined');
		goog.asserts.assert(goog.isDef(this.opacity_),
			'this.opacity_ should be defined');
		goog.asserts.assert(goog.isDef(this.originX_),
			'this.originX_ should be defined');
		goog.asserts.assert(goog.isDef(this.originY_),
			'this.originY_ should be defined');
		goog.asserts.assert(goog.isDef(this.rotateWithView_),
			'this.rotateWithView_ should be defined');
		goog.asserts.assert(goog.isDef(this.rotation_),
			'this.rotation_ should be defined');
		goog.asserts.assert(goog.isDef(this.scale_),
			'this.scale_ should be defined');
		goog.asserts.assert(goog.isDef(this.width_),
			'this.width_ should be defined');
		this.beginGeometry(pointGeometry, feature);
		var flatCoordinates = pointGeometry.getFlatCoordinates();
		var stride = pointGeometry.getStride();
		var myBegin = this.coordinates.length;
		var myEnd = this.drawCoordinates_(
			flatCoordinates, 0, flatCoordinates.length, stride);
		this.instructions.push([
			ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,
			// Remaining arguments to DRAW_IMAGE are in alphabetical order
			this.anchorX_, this.anchorY_, this.height_, this.opacity_,
			this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
			this.scale_, this.snapToPixel_, this.width_
		]);
		this.hitDetectionInstructions.push([
			ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd,
			this.hitDetectionImage_,
			// Remaining arguments to DRAW_IMAGE are in alphabetical order
			this.anchorX_, this.anchorY_, this.height_, this.opacity_,
			this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
			this.scale_, this.snapToPixel_, this.width_
		]);
		this.endGeometry(pointGeometry, feature);
	};


/**
 * @inheritDoc
 */
map.render.canvas.ImageReplay.prototype.drawMultiPointGeometry =
	function (multiPointGeometry, feature, labelType) {
		if (goog.isNull(this.image_)) {
			return;
		}
		goog.asserts.assert(goog.isDef(this.anchorX_),
			'this.anchorX_ should be defined');
		goog.asserts.assert(goog.isDef(this.anchorY_),
			'this.anchorY_ should be defined');
		goog.asserts.assert(goog.isDef(this.height_),
			'this.height_ should be defined');
		goog.asserts.assert(goog.isDef(this.opacity_),
			'this.opacity_ should be defined');
		goog.asserts.assert(goog.isDef(this.originX_),
			'this.originX_ should be defined');
		goog.asserts.assert(goog.isDef(this.originY_),
			'this.originY_ should be defined');
		goog.asserts.assert(goog.isDef(this.rotateWithView_),
			'this.rotateWithView_ should be defined');
		goog.asserts.assert(goog.isDef(this.rotation_),
			'this.rotation_ should be defined');
		goog.asserts.assert(goog.isDef(this.scale_),
			'this.scale_ should be defined');
		goog.asserts.assert(goog.isDef(this.width_),
			'this.width_ should be defined');

		multiPointGeometry = feature.getGeometry();
		this.beginGeometry(multiPointGeometry, feature);

		var flatCoordinates = multiPointGeometry.getFlatCoordinates();
		//console.log('coords='+flatCoordinates.length);
		var stride = multiPointGeometry.getStride();
		var myBegin = this.coordinates.length;
		var myEnd = this.drawCoordinates1_(
			flatCoordinates, 0, flatCoordinates.length, stride, labelType);
		/*if(feature.get('layerId') == 'PODS_SHEET_NOTE_FUND'){
		 console.log('ss1 myEnd='+myEnd+' flatCoord='+flatCoordinates.length);
		 }*/
		//console.log('layerId='+feature.get('layerId')+'  myBegin='+myBegin+' myEnd='+myEnd+' flatCoord='+flatCoordinates.length);
		//console.log(feature.get('layerId')+'  myEnd='+myEnd);
		this.instructions.push([
			ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,
			// Remaining arguments to DRAW_IMAGE are in alphabetical order
			this.anchorX_, this.anchorY_, this.height_, this.opacity_,
			this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
			this.scale_, this.snapToPixel_, this.width_
		]);
		this.hitDetectionInstructions.push([
			ol.render.canvas.Instruction.DRAW_IMAGE, myBegin, myEnd,
			this.hitDetectionImage_,
			// Remaining arguments to DRAW_IMAGE are in alphabetical order
			this.anchorX_, this.anchorY_, this.height_, this.opacity_,
			this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
			this.scale_, this.snapToPixel_, this.width_
		]);
		this.endGeometry(multiPointGeometry, feature);
	};


/**
 * @inheritDoc
 */
map.render.canvas.ImageReplay.prototype.finish = function () {
	this.reverseHitDetectionInstructions_();
	// FIXME this doesn't really protect us against further calls to draw*Geometry
	this.anchorX_ = undefined;
	this.anchorY_ = undefined;
	this.hitDetectionImage_ = null;
	this.image_ = null;
	this.height_ = undefined;
	this.scale_ = undefined;
	this.opacity_ = undefined;
	this.originX_ = undefined;
	this.originY_ = undefined;
	this.rotateWithView_ = undefined;
	this.rotation_ = undefined;
	this.snapToPixel_ = undefined;
	this.width_ = undefined;
};


/**
 * @inheritDoc
 */
map.render.canvas.ImageReplay.prototype.setImageStyle = function (imageStyle) {
	goog.asserts.assert(!goog.isNull(imageStyle),
		'imageStyle should not be null');
	var anchor = imageStyle.getAnchor();
	goog.asserts.assert(!goog.isNull(anchor), 'anchor should not be null');
	var size = imageStyle.getSize();
	goog.asserts.assert(!goog.isNull(size), 'size should not be null');
	var hitDetectionImage = imageStyle.getHitDetectionImage(1);
	goog.asserts.assert(!goog.isNull(hitDetectionImage),
		'hitDetectionImage should not be null');
	var image = imageStyle.getImage(1);
	goog.asserts.assert(!goog.isNull(image), 'image should not be null');
	var origin = imageStyle.getOrigin();
	goog.asserts.assert(!goog.isNull(origin), 'origin should not be null');
	this.anchorX_ = anchor[0];
	this.anchorY_ = anchor[1];
	this.hitDetectionImage_ = hitDetectionImage;
	this.image_ = image;
	this.height_ = size[1];
	this.opacity_ = imageStyle.getOpacity();
	this.originX_ = origin[0];
	this.originY_ = origin[1];
	this.rotateWithView_ = imageStyle.getRotateWithView();
	this.rotation_ = imageStyle.getRotation();
	this.scale_ = imageStyle.getScale();
	this.snapToPixel_ = imageStyle.getSnapToPixel();
	this.width_ = size[0];
};


/**
 * @constructor
 * @extends {map.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.LineStringReplay = function (tolerance, maxExtent, resolution) {

	goog.base(this, tolerance, maxExtent, resolution);

	/**
	 * @private
	 * @type {{currentStrokeStyle: (string|undefined),
	 *         currentLineCap: (string|undefined),
	 *         currentLineDash: Array.<number>,
	 *         currentLineJoin: (string|undefined),
	 *         currentLineWidth: (number|undefined),
	 *         currentMiterLimit: (number|undefined),
	 *         lastStroke: number,
	 *         strokeStyle: (string|undefined),
	 *         lineCap: (string|undefined),
	 *         lineDash: Array.<number>,
	 *         lineJoin: (string|undefined),
	 *         lineWidth: (number|undefined),
	 *         miterLimit: (number|undefined)}|null}
	 */
	this.state_ = {
		currentStrokeStyle: undefined,
		currentLineCap: undefined,
		currentLineDash: null,
		currentLineJoin: undefined,
		currentLineWidth: undefined,
		currentMiterLimit: undefined,
		lastStroke: 0,
		strokeStyle: undefined,
		lineCap: undefined,
		lineDash: null,
		lineJoin: undefined,
		lineWidth: undefined,
		miterLimit: undefined
	};

};
goog.inherits(map.render.canvas.LineStringReplay, map.render.canvas.Replay);


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} end.
 */
map.render.canvas.LineStringReplay.prototype.drawFlatCoordinates_ =
	function (flatCoordinates, offset, end, stride) {
		var myBegin = this.coordinates.length;
		var myEnd = this.appendFlatCoordinates(
			flatCoordinates, offset, end, stride, false);
		var moveToLineToInstruction =
			[ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
		this.instructions.push(moveToLineToInstruction);
		this.hitDetectionInstructions.push(moveToLineToInstruction);
		return end;
	};


map.render.canvas.LineStringReplay.prototype.drawLineFlatCoordinates_ =
	function (flatCoordinates, offset, end, stride, styleArr) {
		var myBegin = this.coordinates.length;
		var myEnd = this.appendFlatCoordinates(
			flatCoordinates, offset, end, stride, false);
		var moveToLineToInstruction =
			[ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd, styleArr];
		this.instructions.push(moveToLineToInstruction);
		this.hitDetectionInstructions.push(moveToLineToInstruction);
		return end;
	};


/**
 * @inheritDoc
 */
map.render.canvas.LineStringReplay.prototype.getBufferedMaxExtent = function () {
	if (goog.isNull(this.bufferedMaxExtent_)) {
		this.bufferedMaxExtent_ = ol.extent.clone(this.maxExtent);
		if (this.maxLineWidth > 0) {
			var width = this.resolution * (this.maxLineWidth + 1) / 2;
			ol.extent.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
		}
	}
	return this.bufferedMaxExtent_;
};


/**
 * @private
 */
map.render.canvas.LineStringReplay.prototype.setStrokeStyle_ = function () {
	var state = this.state_;
	var strokeStyle = state.strokeStyle;
	var lineCap = state.lineCap;
	var lineDash = state.lineDash;
	var lineJoin = state.lineJoin;
	var lineWidth = state.lineWidth;
	var miterLimit = state.miterLimit;
	goog.asserts.assert(goog.isDef(strokeStyle),
		'strokeStyle should be defined');
	goog.asserts.assert(goog.isDef(lineCap), 'lineCap should be defined');
	goog.asserts.assert(!goog.isNull(lineDash), 'lineDash should not be null');
	goog.asserts.assert(goog.isDef(lineJoin), 'lineJoin should be defined');
	goog.asserts.assert(goog.isDef(lineWidth), 'lineWidth should be defined');
	goog.asserts.assert(goog.isDef(miterLimit), 'miterLimit should be defined');
	if (state.currentStrokeStyle != strokeStyle ||
		state.currentLineCap != lineCap ||
		!goog.array.equals(state.currentLineDash, lineDash) ||
		state.currentLineJoin != lineJoin ||
		state.currentLineWidth != lineWidth ||
		state.currentMiterLimit != miterLimit) {
		if (state.lastStroke != this.coordinates.length) {
			this.instructions.push(
				[ol.render.canvas.Instruction.STROKE]);
			state.lastStroke = this.coordinates.length;
		}
		this.instructions.push(
			[ol.render.canvas.Instruction.SET_STROKE_STYLE,
				strokeStyle, lineWidth, lineCap, lineJoin, miterLimit, lineDash],
			[ol.render.canvas.Instruction.BEGIN_PATH]);
		state.currentStrokeStyle = strokeStyle;
		state.currentLineCap = lineCap;
		state.currentLineDash = lineDash;
		state.currentLineJoin = lineJoin;
		state.currentLineWidth = lineWidth;
		state.currentMiterLimit = miterLimit;
	}
};


/**
 * @inheritDoc
 */
map.render.canvas.LineStringReplay.prototype.drawLineStringGeometry = function (lineStringGeometry, feature) {
	var state = this.state_;
	goog.asserts.assert(state, 'state should not be null');
	var strokeStyle = state.strokeStyle;
	var lineWidth = state.lineWidth;
	if (strokeStyle === undefined || lineWidth === undefined) {
		return;
	}
	this.setStrokeStyle_();
	this.beginGeometry(lineStringGeometry, feature);
	this.hitDetectionInstructions.push(
		[ol.render.canvas.Instruction.SET_STROKE_STYLE,
			state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
			state.miterLimit, state.lineDash],
		[ol.render.canvas.Instruction.BEGIN_PATH]);
	var flatCoordinates = lineStringGeometry.getFlatCoordinates();
	var stride = lineStringGeometry.getStride();
	this.drawFlatCoordinates_(
		flatCoordinates, 0, flatCoordinates.length, stride);
	this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);
	this.endGeometry(lineStringGeometry, feature);
};

//`[minx, miny, maxx, maxy]`.
//bottom - 1, top -3, left - 0, rigth -2
//left:Number = NaN, bottom:Number = NaN, right:Number = NaN, top:Number = NaN
map.render.canvas.LineStringReplay.prototype.hasCommonPart = function (mapExtent, extent) {
	//добавил умножение по правой части, чтобю линии раньше границ карты не обрезались
	if ((extent[0] <= mapExtent[2]) && (extent[2] >= mapExtent[0])) {
		if ((extent[3] >= mapExtent[1]) && (extent[1] <= mapExtent[3]))
			return true;
	}
	return false;
};

/**
 *
 * @param multiLineStringGeometry
 * @param feature
 * @param style
 * @param replayGroup
 * @param textStyle
 * @param styleArr массив стилей, чтобы потом корректно отрисовать канву
 */
map.render.canvas.LineStringReplay.prototype.drawMultiLineStringGeometry =
	function (multiLineStringGeometry, feature, style, replayGroup, textStyle, styleArr) {
		var state = this.state_;
		goog.asserts.assert(state, 'state should not be null');
		var strokeStyle = state.strokeStyle;
		var lineWidth = state.lineWidth;
		if (strokeStyle === undefined || lineWidth === undefined) {
			return;
		}

		multiLineStringGeometry = feature.getGeometry();
		this.setStrokeStyle_();
		this.beginGeometry(multiLineStringGeometry, feature);
		this.hitDetectionInstructions.push(
			[ol.render.canvas.Instruction.SET_STROKE_STYLE,
				state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
				state.miterLimit, state.lineDash],
			[ol.render.canvas.Instruction.BEGIN_PATH]);
		var ends = multiLineStringGeometry.getEnds();
		var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
		var stride = multiLineStringGeometry.getStride();
		var offset = 0;
		var i, ii;
		var fGeo = feature.getGeometry();
		var lay = WidgetMap.layerManager.getVectorLayerByUniqueName(feature.get('layerId'));
		var isPods = (lay && lay.modelName === 'PODS');
		var isTextAllow = true;
		var linesForTextDrawing = []; //массив порезанных линий
		if (goog.isDef(lay) && lay.isTextAllow == false)
			isTextAllow = false;
		for (i = 0, ii = ends.length; i < ii; ++i) {
			var fLineString = fGeo.getLineString(i);
			var geoExtent = fLineString.getExtent();//ol.extent.boundingExtent(fLineString.getCoordinates());
			var mapp = undefined;
			if (feature.getId() == 'axesLegend' || feature.getId() == 'axesLegendY')
				mapp = WidgetMap.lmap;
			else
				mapp = WidgetMap.map;
			var mapExtent = mapp.getView().calculateExtent(mapp.getSize());
			var extWidth = ol.extent.getWidth(geoExtent);
			var extHeight = ol.extent.getHeight(geoExtent);
			var lineD = Math.sqrt(extWidth * extWidth + extHeight * extHeight);
			if (lineD < ol.extent.getWidth(mapExtent) * MIN_VISIBLE_RATIO) {
				offset += fLineString.flatCoordinates.length;
				//Линия меньше минимального размера
				continue;
			}
			if (!(this.hasCommonPart(mapExtent, geoExtent))) {
				offset += fLineString.flatCoordinates.length;
				//Линия не попадает в отрисовку
				continue;
			}
			//Установка флага, что геометрия наносится в данном экстенте
			if (goog.isDef(lay))
				lay.layer.featureProjLayer.getSource().hasGeometryInExtent = true;
			offset = this.drawLineFlatCoordinates_(
				flatCoordinates, offset, ends[i], stride, styleArr);

			if (isTextAllow && goog.isDef(feature.get('labelType'))) {
				textStyle = styleArr[0].getText();
				if (!goog.isNull(textStyle)) {
					var labelObj = globalLinesLabels_[feature.get('labelType')][i];
					if(labelObj) {
						//режем линии по рамке
						var newLineStrings = GeoUtil.composeLineStringByExtent(fLineString, mapExtent, isPods);
						if (newLineStrings && newLineStrings.length > 0){
							newLineStrings.forEach(function(newLineString){
								linesForTextDrawing.push({
									lineString: newLineString,
									labelObj: labelObj,
									isTextObject: textStyle.getFont().indexOf(' -1px ') !== -1,// текстовая надпись
								});
							})
						}
					}
					if(CURRENT_MAP_TYPE === MAP_TYPE.CAS){//случай пка
						if (!(goog.isNull(labelObj.label) || labelObj.label == '')) {
							//рисуем текстовую подпись
							this.drawText(textStyle, labelObj, feature, fLineString);
						}
					}
				}
			}
		}

		if(linesForTextDrawing && linesForTextDrawing.length > 0 && isTextAllow && CURRENT_MAP_TYPE !== MAP_TYPE.CAS){
			if(WidgetMap.stubTextLayer)
				WidgetMap.stubTextLayer.getSource().clear();
			var that = this;
			var resolution = WidgetMap.map.getView().getResolution();
			LABEL_REPEAT_RATIO = 1;
			var mapWidth = WidgetMap.map.getSize()[0] * LABEL_REPEAT_RATIO;
			var textReplay = replayGroup.getReplay(
				style.getZIndex(), ol.render.ReplayType.TEXT);
			textStyle.setTextAlign('start');
			var isCasUnits = (feature.get('layerId') !== undefined && feature.get('layerId').indexOf('labelScale') !== -1);
			linesForTextDrawing.forEach(function(obj){
				var text = obj.labelObj.label;
				if(!text) return;
				var geometryExtent = obj.lineString.getExtent();
				//высчитываем длину линии, как диагональ экстента линии
				var lineD = Math.sqrt(ol.extent.getWidth(geometryExtent) * ol.extent.getWidth(geometryExtent) + ol.extent.getHeight(geometryExtent) * ol.extent.getHeight(geometryExtent));
				lineD /= resolution;
				var textWidth = GeoUtil.getTextWidth(text, textStyle, _CONTEXT);
				//upd. 26.10.21 меняем устаревшее условие на модифицированное, чтобы включить в него условия обрезки подписей за 3 попытки
				//if (textWidth > lineD * MAX_LABEL_RATIO )
				if (textWidth > lineD * MAX_LABEL_RATIO * (1 + LABEL_CUT_RATIO * 3 + 0.01) && !obj.isTextObject)//игнорируем условие, если надпись
					return;
				// получаем все начальные точки(на 04.10.21 используем только align=center)
				var lineStartPoint = GeoUtil.alignText(obj.lineString, textStyle.getTextAlign(), mapWidth, textWidth, text);
				if(obj.isTextObject){
					lineStartPoint = GeoUtil.alignTextObject(obj.lineString, 'left');
				}
				//формируем из всех начальных точек векторы
				var textVector = GeoUtil.composeTextVectorFromStartPoint(lineStartPoint, {text: text, textStyle:textStyle, textWidth:textWidth, isTextObject: obj.isTextObject }, isCasUnits);
				if(textVector)
					that.drawTextVector(textReplay, textStyle, textVector, feature, isCasUnits, obj.isTextObject);
			});
		}

		this.hitDetectionInstructions.push([ol.render.canvas.Instruction.STROKE]);
		this.endGeometry(multiLineStringGeometry, feature);
	};


/**
 *
 * @param textReplay
 * @param textStyle
 * @param textVector
 * @param feature
 */
map.render.canvas.LineStringReplay.prototype.drawTextVector = function (textReplay, textStyle, textVector, feature, isCasUnits, isTextObject) {
	if (!textVector)
		return;
	//upd. 23.09.21 Принято решение для линейных объектов вообще игнорировать параметр overlap, чтобы они всегда разряжались
	//пункт 6. Проверка по матрице.
	var collision = GeoUtil.hasComplexTextCollision(textVector);
	var freeCells = collision.freeCells;
	if (!collision.hasCollision || isTextObject) {
		addTextExtent(textVector.bounds);
		var addedObj = GeoUtil.addComplexText(feature, textVector, freeCells);
		var text = textVector.text;
		var lineString = textVector.lineString;
		var lLen = lineString.getLength();
		var rotation = textVector.rotation;
		var x = textVector.x;
		var y = textVector.y;
		var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
		if(isTextObject){
			var defaultZoom = 18;
			if(WidgetMap.DEFALT_ZOOM_FOR_FONT !== undefined)
				defaultZoom = WidgetMap.DEFALT_ZOOM_FOR_FONT;
			var textFont = textStyle.getFont();
			textFont = 'normal -1px Arial';
			if(textFont.indexOf(' -1px ') !== -1){
				var MIN_FONT_SIZE = 1;
				//рассчитать длину основания написи исходя из количества символов в строке ЛЕЙБЛ и размера шрифта принятого ранее и для текущего масштаба и некоего коэффициента. Длина в единицах - как для технологичесмкой схемы.
				var textWidth = GeoUtil.getDefaultTextWidth(text, _CONTEXT);
				var fontSize = GeoUtil.getFontSizeByZoom(textWidth);
				fontSize = fontSize.toFixed(1);
				var font = textFont.replace(' -1px ', ' ' + fontSize + 'px ');
				textStyle.setFont(font);
				//делаем это для всех техсхем
				var fs = textVector.textWidth * LABEL_FONT_RATIO;
				/*if (fontSize < MIN_FONT_SIZE){
					return;
					text = '';
					fs = MIN_FONT_SIZE;
				}*/
				fs = parseInt(fs);
				//var tHeight = fs*13/11;
			}
		}

		_LABELS.push({
			type: 'LineString',
			unique: addedObj, text: text, textStyle: textStyle,
			coordX: coordsXY[0], coordY: coordsXY[1], x: x, y: y, scale: 1, rotation: rotation,
			localTransform: undefined, fill: textStyle.getFill(), stroke: textStyle.getStroke(), lLen: lLen
		});
	}
	else {//пункт 6. Сдвиг
		var startPoint = {startPoint: textVector.coordEnd, lineString:textVector.lineString };
		textVector = GeoUtil.composeTextVectorFromStartPoint(startPoint, {text: textVector.baseText, textStyle:textStyle, textWidth:textVector.textWidth}, isCasUnits, false);
		if(textVector)
			this.drawTextVector(textReplay, textStyle, textVector, feature);
	}
};

var addTextExtent = function(bounds){
	if(!WidgetMap.stubTextLayer)
		return;
	var textExtent = bounds.getExtent();
	var min = WidgetMap.map.getCoordinateFromPixel([textExtent[0],textExtent[1]]);
	var max = WidgetMap.map.getCoordinateFromPixel([textExtent[2],textExtent[3]]);
	var newExtent = [min[0], min[1], max[0], max[1]];
	var polygon = new ol.geom.Polygon.fromExtent(newExtent);
	var lineMatrixGeo = new ol.geom.MultiLineString(null);
	var lineAddGeo = new ol.geom.LineString(polygon.getCoordinates()[0],ol.geom.GeometryLayout.XY);
	lineMatrixGeo.appendLineString(lineAddGeo)

	var lineMatrixGeoFtr = new ol.Feature(lineMatrixGeo);
	lineMatrixGeoFtr.setStyle(function(){ //стили ПКА берем за основу полувидимых линий
			var s = WidgetMap.layerManager.getStyleByNameAndType('CAS_LIGHT_AXES_1', 'LineString');
			if(!goog.isNull(s)) {
				if (goog.isArray(s))
					return [s];
				return [s];
			}
		}
	);
	WidgetMap.stubTextLayer.getSource().addFeature(lineMatrixGeoFtr);
}



map.render.canvas.LineStringReplay.prototype.getCutText = function (textFeature, lineCoordinates, x, y) { //txtFeature:rotation, width, text
	var closestSegment1;
	var rotation = textFeature.rotation;
	var textWidth = textFeature.width;
	var text = textFeature.text;
	//return text;
	var charWidth = (textFeature.width) / textFeature.text.length;
	var textInp = '';
	//корректируем x,y, т.к. приходит средняя точка
	x = x - Math.cos(rotation) * (textWidth / 2);
	y = y - Math.sin(rotation) * (textWidth / 2);
	var coordsStartPixel = [x, y];
	var coordsStart = WidgetMap.map.getCoordinateFromPixel(coordsStartPixel);
	var coordsEndPixel = [x + Math.cos(rotation) * (textWidth), y + Math.sin(rotation) * (textWidth)];
	var coordsEnd = WidgetMap.map.getCoordinateFromPixel(coordsEndPixel);
	var coordMiddlePixel = [(coordsStartPixel[0] + coordsEndPixel[0]) / 2, (coordsStartPixel[1] + coordsEndPixel[1]) / 2];
	var coordMiddle = WidgetMap.map.getCoordinateFromPixel(coordMiddlePixel);
	var closestDistance = Number.MAX_VALUE;
	//первый прогон массива, если дистанция от начала подписи больше лимита, подпись не рисуем
	for (var k = 0; k < lineCoordinates.length - 1; ++k) {
		closestSegment1 = [lineCoordinates[k], lineCoordinates[k + 1]];
		var closestFirstProj = ol.coordinate.closestOnSegment(coordMiddle, closestSegment1);
		var coordsFirstClosestPixel = WidgetMap.map.getPixelFromCoordinate(closestFirstProj);
		if (GeoUtil.Distance(coordsFirstClosestPixel, coordMiddlePixel) < closestDistance)
			closestDistance = GeoUtil.Distance(coordsFirstClosestPixel, coordMiddlePixel);
	}
	if (closestDistance > LABEL_CUT_TOLERANCE)
		return;
	for (var j = 0; j < 3; j++) {
		coordsEndPixel = [x + Math.cos(rotation) * (textWidth), y + Math.sin(rotation) * (textWidth)];
		coordsEnd = WidgetMap.map.getCoordinateFromPixel(coordsEndPixel);
		closestDistance = Number.MAX_VALUE;
		for (var i = 0; i < lineCoordinates.length - 1; ++i) {
			closestSegment1 = [lineCoordinates[i], lineCoordinates[i + 1]];
			var newPointProj = ol.coordinate.closestOnSegment(coordsEnd, closestSegment1);
			var coordsClosestPixel = WidgetMap.map.getPixelFromCoordinate(newPointProj);
			if (GeoUtil.Distance(coordsClosestPixel, coordsEndPixel) < closestDistance)
				closestDistance = GeoUtil.Distance(coordsClosestPixel, coordsEndPixel);
		}
		if (closestDistance < LABEL_CUT_TOLERANCE)
			return (textInp) ? textInp : text;
		if (j == 2)
			return;
		textWidth -= textFeature.width * LABEL_CUT_RATIO;

		var charCount = ((textWidth - 10) / charWidth).toFixed(0) - 3;// Из длины линии -10 т.к. текст начинается с отступом в 10 пикселей от начала, -3 символа для '...'
		if (charCount > 4) //Выводим подпись, только если вмещается 5 символов
			textInp = text.slice(0, charCount) + '...';
	}
	return textInp;
};

map.render.canvas.LineStringReplay.prototype.drawText = function (textStyle, labelObj, feature, lineString) {
	var isCasUnits = (feature.get('layerId') !== undefined && feature.get('layerId').indexOf('labelScale') !== -1);
	var textOffset = LABEL_OFFSET;
	var labelDrawType = LABEL_DRAW_TYPE;
	if (isCasUnits)
		labelDrawType = 'cas_units';
	var geometry = lineString;
	var text = labelObj.label;
	if (!goog.isDef(text))
		return;
	var overlap = '0';
	overlap = WidgetMap.layerManager.getTextOverlapByNameAndType(feature.get('type'), 'LineString');
	//console.log('dd='+dd+"  lineStringId="+lineStringId +'  labelType='+feature.get('labelType'));
	var p = {};
	var p2 = {};
	var mapWidth = 0;
	var textWidth = goog.isDef(_CONTEXT) ? _CONTEXT.measureText(text).width * LABEL_FONT_RATIO : 89;//  goog.isDef(_CONTEXT)?_CONTEXT.measureText(text).width*0.925:89;//goog.isDef(_CONTEXT)?_CONTEXT.measureText(text).width-5:89;//context.measureText(text).width+5;
	var duplicate = true;
	var resolution = WidgetMap.map.getView().getResolution();
	//if(text == 'КС-18 Ординская')
	//console.log('d');
	var j = 0;
	var mapExtent = WidgetMap.map.getView().calculateExtent(WidgetMap.map.getSize());
	mapWidth = ol.extent.getWidth(mapExtent) * LABEL_REPEAT_RATIO;
	var lineLen = lineString.getLength();
	var lineD = Math.sqrt(ol.extent.getWidth(geometry.getExtent()) * ol.extent.getWidth(geometry.getExtent()) + ol.extent.getHeight(geometry.getExtent()) * ol.extent.getHeight(geometry.getExtent()));
	if (lineD < ol.extent.getWidth(mapExtent) * MIN_VISIBLE_RATIO) {
		//Logger.info("Линия меньше минимального размера " + this.layer.name + " " + lineD.toString() + " < " + (this.layer.map.extent.width*LineStringFeature.MIN_VISIBLE_RATIO).toString());
		return;
	}
	var di = 1;
	var n = 0;
	var x, y, origX, origY;
	/*if(text == 'Уренгой-Новопсков')
		console.log('dd');*/

	lineString = this.sliceLineStringByExtent(lineString, mapExtent);
	geometry = lineString;
	try{
		lineLen = lineString.getLength();
	}
	catch(ex){
		//console.log('d')
	}

	var fCoords = lineString.flatCoordinates;
	var coords = lineString.getCoordinates();
	if (lineString.intersectsExtent(mapExtent)) {
		if (coords.length > 3)
			n = 2;
		p = {x: coords[n][0], y: coords[n][1]};
		var pixelCoord = WidgetMap.map.getPixelFromCoordinate([p.x, p.y]);
		x = pixelCoord[0] + textOffset;
		y = pixelCoord[1] + textOffset;
		//получаем индекс добавленного текста
		var addedObj = '';
		if (overlap == '1') {
			addedObj = this.addTextPointObject_(feature, textWidth, 18, coords[n][0], coords[n][1], x, y, feature.get('zIndex'), 'label', false, text);
		} else {
			//заносим в матрицу
			if (!this.hasTextPointCollision_(feature, textWidth, 18, x, y, feature.get('zIndex'))) {
				addedObj = this.addTextPointObject_(feature, textWidth, 18, coords[n][0], coords[n][1], x, y, feature.get('zIndex'), 'label', true, text);
			}
		}
		//наклон
		var rotation = 0;
		var rotateResult = [];
		if (addedObj != '' && coords.length > 1) {
			if (coords.length > 5)
				di = 2;
			p2 = {x: fCoords[(n + di) * 2], y: fCoords[(n + di) * 2 + 1]};//lineString.componentByIndex(n+di) as org.openscales.core.geometry.Point;
			rotateResult = this.rotateLineText_(p, p2, textWidth, 11, textStyle.getTextBaseline(), textStyle.getTextAlign(), 'normal', _dx, _dy, resolution, x, y);
			rotation = rotateResult[2];
			x = rotateResult[0];
			y = rotateResult[1];
		}
		var fill = goog.isDef(textStyle.getFill());
		var stroke = goog.isDef(textStyle.getStroke());
		if (addedObj != '') {
			var lLen = lineLen / resolution;
			var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
			if (lLen < (textWidth / LABEL_FONT_RATIO)) {
				if (text.length < 5) {
					if (lLen * 1.5 < textWidth){
						this.deleteTextPointObject_(this.findTextPointObject_(addedObj));
						return;
					}
				} else {
					var charWidth = (textWidth / LABEL_FONT_RATIO) / text.length;
					var charCount = (lLen / charWidth).toFixed(0) - 3;// Из длины линии -10 т.к. текст начинается с отступом в 10 пикселей от начала, -3 символа для '...'

					if (charCount > 4) //Выводим подпись, только если вмещается 5 символов
						var inpText = text.slice(0, charCount) + '...';
					else{
						this.deleteTextPointObject_(this.findTextPointObject_(addedObj));
						return;
					}
				}
			} else {
				var textProp = {
					rotation: rotation,
					width: textWidth / LABEL_FONT_RATIO,
					text: text
				};
				if (labelDrawType === 'cut')
					var inpText = this.getCutText(textProp, coords, x, y);//this.getCutText(textProp, coords, x, y);

			}

			if (isCasUnits || coords.length == 2)//случай секций труб, где линии небольшие и из 2-х точек
				_LABELS.push({
					type: 'LineString',
					unique: addedObj, text: text, textStyle: textStyle,
					coordX: coordsXY[0], coordY: coordsXY[1], x: x, y: y, scale: 1, rotation: rotation,
					localTransform: undefined, fill: fill, stroke: stroke, lLen: lLen
				});
			else if (inpText) {
				_LABELS.push({
					type: 'LineString',
					unique: addedObj, text: inpText, textStyle: textStyle,
					coordX: coordsXY[0], coordY: coordsXY[1], x: x, y: y, scale: 1, rotation: rotation,
					localTransform: undefined, fill: fill, stroke: stroke, lLen: lLen
				});
			}
			else {
				this.deleteTextPointObject_(this.findTextPointObject_(addedObj));
			}
		}
		n++;
		var limit = mapWidth;
		var bM;
		var intersectLineString;
		var intersectMapBounds = mapExtent;
		var lengthP1P2 = 0;
		var lengthLast = 0;
		addedObj = '';
		if ((lineLen > mapWidth) && (fCoords.length > 6)) {
			bM = 0;
			p2 = {x: coords[n][0], y: coords[n][1]};//lineString.componentByIndex(n) as org.openscales.core.geometry.Point;
			for (j = n + 1; j < coords.length; j++) {
				p = {x: coords[j][0], y: coords[j][1]}; //lineString.componentByIndex(j) as org.openscales.core.geometry.Point;
				lengthP1P2 = Math.sqrt((p2.x - p.x) * (p2.x - p.x) + (p2.y - p.y) * (p2.y - p.y));
				bM += lengthP1P2;
				var ppp;
				intersectLineString = new ol.geom.LineString(null);
				intersectLineString.setFlatCoordinates(ol.geom.GeometryLayout.XY, [p2.x, p2.y, p.x, p.y]);
				if (bM > limit - 20 && intersectLineString.intersectsExtent(intersectMapBounds) && ppp == undefined) {
					ppp = {
						x: coords[j][0],
						y: coords[j][1]
					};
					continue;
				}

				if (bM > limit && intersectLineString.intersectsExtent(intersectMapBounds)) {
					//Лимит увеличиваем до тех пор, пока он не станет больше текущей длины
					limit += mapWidth * Math.ceil((bM - limit) / mapWidth);
					pixelCoord = WidgetMap.map.getPixelFromCoordinate([p.x, p.y]);
					x = pixelCoord[0] + textOffset;
					y = pixelCoord[1] + textOffset;
					origX = x;
					origY = y;
					addedObj = '';
					if (overlap == '1') {
						addedObj = this.addTextPointObject_(feature, textWidth, 18, coords[j][0], coords[j][1], x, y, feature.get('zIndex'), 'label', false, text);
					} else {
						//заносим в матрицу
						if (!this.hasTextPointCollision_(feature, textWidth, 18, x, y, feature.get('zIndex'))) {
							addedObj = this.addTextPointObject_(feature, textWidth, 18, coords[j][0], coords[j][1], x, y, feature.get('zIndex'), 'label', true, text);
						}
					}
					if (addedObj != '') {
						var pp;
						var rotateResult = [];
						pp = ppp;
						rotateResult = this.rotateLineText_(pp, p, textWidth, 11, 'middle', 'right', 'normal', 0, 0, resolution, x, y);//rotateLabel(lbl, p, lineString.componentByIndex(j+di) as org.openscales.core.geometry.Point, symbolizer.labelSymbolyzer ? symbolizer.labelSymbolyzer.vAlign : "top");
						rotation = rotateResult[2];
						x = rotateResult[0];
						y = rotateResult[1];
						var coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
						var textProp = {
							rotation: rotation,
							width: textWidth / LABEL_FONT_RATIO,
							text: text
						};
						if (labelDrawType === 'cut')
							var inpText = this.getCutText(textProp, coords, x, y);//this.getCutText(textProp, coords, coordsXY, x, y);

						if (inpText) {
							coordsXY = WidgetMap.map.getCoordinateFromPixel([x, y]);
							_LABELS.push({
								type: 'LineString',
								unique: addedObj, text: inpText, textStyle: textStyle,
								coordX: coordsXY[0], coordY: coordsXY[1], x: x, y: y, scale: 1, rotation: rotation,
								localTransform: undefined, fill: fill, stroke: stroke
							});
						}
						else{
							this.deleteTextPointObject_(this.findTextPointObject_(addedObj));
						}

					}
					if (lineLen < limit)
						j = coords.length;
					if (duplicate == false)
						j = coords.length;
				}
				ppp = undefined;
				p2 = p;
			}
		}
	}
};

/**
 * @inheritDoc
 */
map.render.canvas.LineStringReplay.prototype.finish = function () {
	var state = this.state_;
	goog.asserts.assert(!goog.isNull(state), 'state should not be null');
	if (state.lastStroke != this.coordinates.length) {
		this.instructions.push([ol.render.canvas.Instruction.STROKE]);
	}
	this.reverseHitDetectionInstructions_();
	this.state_ = null;
};


/**
 * @inheritDoc
 */
map.render.canvas.LineStringReplay.prototype.setFillStrokeStyle =
	function (fillStyle, strokeStyle) {
		goog.asserts.assert(!goog.isNull(this.state_),
			'this.state_ should not be null');
		goog.asserts.assert(goog.isNull(fillStyle), 'fillStyle should be null');
		goog.asserts.assert(!goog.isNull(strokeStyle),
			'strokeStyle should not be null');
		var strokeStyleColor = strokeStyle.getColor();
		this.state_.strokeStyle = ol.color.asString(!goog.isNull(strokeStyleColor) ?
			strokeStyleColor : ol.render.canvas.defaultStrokeStyle);
		var strokeStyleLineCap = strokeStyle.getLineCap();
		this.state_.lineCap = goog.isDef(strokeStyleLineCap) ?
			strokeStyleLineCap : ol.render.canvas.defaultLineCap;
		var strokeStyleLineDash = strokeStyle.getLineDash();
		this.state_.lineDash = !goog.isNull(strokeStyleLineDash) ?
			strokeStyleLineDash : ol.render.canvas.defaultLineDash;
		var strokeStyleLineJoin = strokeStyle.getLineJoin();
		this.state_.lineJoin = goog.isDef(strokeStyleLineJoin) ?
			strokeStyleLineJoin : ol.render.canvas.defaultLineJoin;
		var strokeStyleWidth = strokeStyle.getWidth();
		this.state_.lineWidth = goog.isDef(strokeStyleWidth) ?
			strokeStyleWidth : ol.render.canvas.defaultLineWidth;
		var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
		this.state_.miterLimit = goog.isDef(strokeStyleMiterLimit) ?
			strokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit;

		if (this.state_.lineWidth > this.maxLineWidth) {
			this.maxLineWidth = this.state_.lineWidth;
			// invalidate the buffered max extent cache
			this.bufferedMaxExtent_ = null;
		}
	};


/**
 * @constructor
 * @extends {map.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.PolygonReplay = function (tolerance, maxExtent, resolution) {

	goog.base(this, tolerance, maxExtent, resolution);

	/**
	 * @private
	 * @type {{currentFillStyle: (string|undefined),
	 *         currentStrokeStyle: (string|undefined),
	 *         currentLineCap: (string|undefined),
	 *         currentLineDash: Array.<number>,
	 *         currentLineJoin: (string|undefined),
	 *         currentLineWidth: (number|undefined),
	 *         currentMiterLimit: (number|undefined),
	 *         fillStyle: (string|undefined),
	 *         strokeStyle: (string|undefined),
	 *         lineCap: (string|undefined),
	 *         lineDash: Array.<number>,
	 *         lineJoin: (string|undefined),
	 *         lineWidth: (number|undefined),
	 *         miterLimit: (number|undefined)}|null}
	 */
	this.state_ = {
		currentFillStyle: undefined,
		currentStrokeStyle: undefined,
		currentLineCap: undefined,
		currentLineDash: null,
		currentLineJoin: undefined,
		currentLineWidth: undefined,
		currentMiterLimit: undefined,
		fillStyle: undefined,
		strokeStyle: undefined,
		lineCap: undefined,
		lineDash: null,
		lineJoin: undefined,
		lineWidth: undefined,
		miterLimit: undefined
	};

};
goog.inherits(map.render.canvas.PolygonReplay, map.render.canvas.Replay);


/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */
map.render.canvas.PolygonReplay.prototype.drawFlatCoordinatess_ =
	function (flatCoordinates, offset, ends, stride) {
		var state = this.state_;
		var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];
		this.instructions.push(beginPathInstruction);
		this.hitDetectionInstructions.push(beginPathInstruction);
		var i, ii;
		for (i = 0, ii = ends.length; i < ii; ++i) {
			var end = ends[i];
			var myBegin = this.coordinates.length;
			var myEnd = this.appendFlatCoordinates(
				flatCoordinates, offset, end, stride, true);
			var moveToLineToInstruction =
				[ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
			var closePathInstruction = [ol.render.canvas.Instruction.CLOSE_PATH];
			this.instructions.push(moveToLineToInstruction, closePathInstruction);
			this.hitDetectionInstructions.push(moveToLineToInstruction,
				closePathInstruction);
			offset = end;
		}
		// FIXME is it quicker to fill and stroke each polygon individually,
		// FIXME or all polygons together?
		var fillInstruction = [ol.render.canvas.Instruction.FILL];
		this.hitDetectionInstructions.push(fillInstruction);
		if (goog.isDef(state.fillStyle)) {
			this.instructions.push(fillInstruction);
		}
		if (goog.isDef(state.strokeStyle)) {
			goog.asserts.assert(goog.isDef(state.lineWidth),
				'state.lineWidth should be defined');
			var strokeInstruction = [ol.render.canvas.Instruction.STROKE];
			this.instructions.push(strokeInstruction);
			this.hitDetectionInstructions.push(strokeInstruction);
		}
		return offset;
	};

map.render.canvas.PolygonReplay.prototype.drawPolygonFlatCoordinatess_ =
	function (flatCoordinates, offset, ends, stride, styleArr) {


		var state = this.state_;
		var fill = state.fillStyle !== undefined;
		var stroke = state.strokeStyle != undefined;
		var numEnds = ends.length;
		if (!fill && !stroke) {
			return ends[numEnds - 1];
		}
		var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];
		this.instructions.push(beginPathInstruction);
		this.hitDetectionInstructions.push(beginPathInstruction);
		for (var i = 0; i < numEnds; ++i) {
			var end = ends[i];
			var myBegin = this.coordinates.length;
			var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride,
				// Performance optimization: only close the ring when we do not have a
				// stroke. Otherwise closePath() will take care of that.
				!stroke);
			var moveToLineToInstruction =
				[ol.render.canvas.Instruction.MOVE_TO_LINE_TO, myBegin, myEnd, styleArr];
			this.instructions.push(moveToLineToInstruction);
			this.hitDetectionInstructions.push(moveToLineToInstruction);
			if (stroke) {
				// Performance optimization: only call closePath() when we have a stroke.
				// Otherwise the ring is closed already (see appendFlatCoordinates above).
				var closePathInstruction = [ol.render.canvas.Instruction.CLOSE_PATH];
				this.instructions.push(closePathInstruction);
				this.hitDetectionInstructions.push(closePathInstruction);
			}
			offset = end;
		}
		var fillInstruction = [ol.render.canvas.Instruction.FILL];
		this.hitDetectionInstructions.push(fillInstruction);
		if (fill) {
			this.instructions.push(fillInstruction);
		}
		if (stroke) {
			var strokeInstruction = [ol.render.canvas.Instruction.STROKE];
			this.instructions.push(strokeInstruction);
			this.hitDetectionInstructions.push(strokeInstruction);
		}
		return offset;
	};


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.drawCircleGeometry =
	function (circleGeometry, feature) {
		var state = this.state_;
		goog.asserts.assert(!goog.isNull(state), 'state should not be null');
		var fillStyle = state.fillStyle;
		var strokeStyle = state.strokeStyle;
		if (!goog.isDef(fillStyle) && !goog.isDef(strokeStyle)) {
			return;
		}
		if (goog.isDef(strokeStyle)) {
			goog.asserts.assert(goog.isDef(state.lineWidth),
				'state.lineWidth should be defined');
		}
		this.setFillStrokeStyles_();
		this.beginGeometry(circleGeometry, feature);
		// always fill the circle for hit detection
		this.hitDetectionInstructions.push(
			[ol.render.canvas.Instruction.SET_FILL_STYLE,
				ol.color.asString(ol.render.canvas.defaultFillStyle)]);
		if (goog.isDef(state.strokeStyle)) {
			this.hitDetectionInstructions.push(
				[ol.render.canvas.Instruction.SET_STROKE_STYLE,
					state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
					state.miterLimit, state.lineDash]);
		}
		var flatCoordinates = circleGeometry.getFlatCoordinates();
		var stride = circleGeometry.getStride();
		var myBegin = this.coordinates.length;
		this.appendFlatCoordinates(
			flatCoordinates, 0, flatCoordinates.length, stride, false);
		var beginPathInstruction = [ol.render.canvas.Instruction.BEGIN_PATH];
		var circleInstruction = [ol.render.canvas.Instruction.CIRCLE, myBegin];
		this.instructions.push(beginPathInstruction, circleInstruction);
		this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
		var fillInstruction = [ol.render.canvas.Instruction.FILL];
		this.hitDetectionInstructions.push(fillInstruction);
		if (goog.isDef(state.fillStyle)) {
			this.instructions.push(fillInstruction);
		}
		if (goog.isDef(state.strokeStyle)) {
			goog.asserts.assert(goog.isDef(state.lineWidth),
				'state.lineWidth should be defined');
			var strokeInstruction = [ol.render.canvas.Instruction.STROKE];
			this.instructions.push(strokeInstruction);
			this.hitDetectionInstructions.push(strokeInstruction);
		}
		this.endGeometry(circleGeometry, feature);
	};


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.drawPolygonGeometry =
	function (polygonGeometry, feature) {
		var state = this.state_;
		goog.asserts.assert(!goog.isNull(state), 'state should not be null');
		var fillStyle = state.fillStyle;
		var strokeStyle = state.strokeStyle;
		if (fillStyle === undefined && strokeStyle === undefined) {
			return;
		}
		if (goog.isDef(strokeStyle)) {
			goog.asserts.assert(goog.isDef(state.lineWidth),
				'state.lineWidth should be defined');
		}
		this.setFillStrokeStyles_();
		this.beginGeometry(polygonGeometry, feature);
		// always fill the polygon for hit detection
		this.hitDetectionInstructions.push(
			[ol.render.canvas.Instruction.SET_FILL_STYLE,
				ol.color.asString(ol.render.canvas.defaultFillStyle)]);
		if (state.strokeStyle !== undefined) {
			this.hitDetectionInstructions.push(
				[ol.render.canvas.Instruction.SET_STROKE_STYLE,
					state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
					state.miterLimit, state.lineDash]);
		}
		var ends = polygonGeometry.getEnds();
		var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
		var stride = polygonGeometry.getStride();
		this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
		this.endGeometry(polygonGeometry, feature);
	};


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.drawMultiPolygonGeometry =
	function (multiPolygonGeometry, feature, style, replayGroup, textStyle, styleArr) {
		var state = this.state_;
		goog.asserts.assert(!goog.isNull(state), 'state should not be null');
		var fillStyle = state.fillStyle;
		var strokeStyle = state.strokeStyle;
		if (fillStyle === undefined && strokeStyle === undefined) {
			return;
		}
		if (goog.isDef(strokeStyle)) {
			goog.asserts.assert(goog.isDef(state.lineWidth),
				'state.lineWidth should be defined');
		}
		this.setFillStrokeStyles_();
		this.beginGeometry(multiPolygonGeometry, feature);
		// always fill the multi-polygon for hit detection
		this.hitDetectionInstructions.push(
			[ol.render.canvas.Instruction.SET_FILL_STYLE,
				ol.color.asString(ol.render.canvas.defaultFillStyle)]);
		if (state.strokeStyle !== undefined) {
			this.hitDetectionInstructions.push(
				[ol.render.canvas.Instruction.SET_STROKE_STYLE,
					state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
					state.miterLimit, state.lineDash]);
		}
		var endss = multiPolygonGeometry.getEndss();
		var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
		var stride = multiPolygonGeometry.getStride();
		var offset = 0;
		var i, ii;
		var lay = WidgetMap.layerManager.getVectorLayerByUniqueName(feature.get('layerId'));
		var isTextAllow = true;
		var fGeo = feature.getGeometry();
		if (goog.isDef(lay) && lay.isTextAllow == false)
			isTextAllow = false;
		for (i = 0, ii = endss.length; i < ii; ++i) {
			var fPolygon = fGeo.getPolygon(i);
			if (goog.isDef(lay))
				lay.layer.featureProjLayer.getSource().hasGeometryInExtent = true;
			offset = this.drawPolygonFlatCoordinatess_(
				flatCoordinates, offset, endss[i], stride, styleArr);
			if (isTextAllow && goog.isDef(feature.get('labelType'))) {
				textStyle = styleArr[0].getText();
				if (!goog.isNull(textStyle)) {
					var labelObj = globalPolygonsLabels_[feature.get('labelType')][i];
					if ( labelObj && labelObj.label) {
						//рисуем текстовую подпись
						this.drawPolygonText(textStyle, labelObj, feature, fPolygon);
					}
				}
			}
		}
		this.endGeometry(multiPolygonGeometry, feature);

	};

map.render.canvas.PolygonReplay.prototype.drawPolygonText = function (textStyle, labelObj, feature, fPolygon) {
	var geometry = fPolygon;
	var text = labelObj.label;
	if (!goog.isDef(text))
		return;
	var bounds = geometry.getExtent();
	var resolution = WidgetMap.map.getView().getResolution();
	var MIN_BOUNDS = 6 * resolution;
	var fill = goog.isDef(textStyle.getFill());
	var stroke = goog.isDef(textStyle.getStroke());
	var pCenter = ol.extent.getCenter(bounds);
	var textWidth = goog.isDef(_CONTEXT) ? _CONTEXT.measureText(text).width * LABEL_FONT_RATIO : 89;
	var pixelCoord = WidgetMap.map.getPixelFromCoordinate(pCenter);
	if (ol.extent.getWidth(bounds) > 1000 || ol.extent.getHeight(bounds) > MIN_BOUNDS) {
		if (!this.hasTextPointCollision_(feature, textWidth, 18, pixelCoord[0], pixelCoord[1], feature.get('zIndex'))) {
			var addedObj = this.addTextPointObject_(feature, textWidth, 18, pCenter[0], pCenter[1], pixelCoord[0], pixelCoord[1], feature.get('zIndex'), 'label', true, text);
			_LABELS.push({
				type: 'Polygon',
				unique: addedObj, text: text, textStyle: textStyle,
				coordX: pCenter[0], coordY: pCenter[1], x: pixelCoord[0], y: pixelCoord[1], scale: 1, rotation: 0,
				localTransform: undefined, fill: fill, stroke: stroke
			});
		}
	}
};

/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.finish = function () {
	goog.asserts.assert(!goog.isNull(this.state_),
		'this.state_ should not be null');
	this.reverseHitDetectionInstructions_();
	this.state_ = null;
	// We want to preserve topology when drawing polygons.  Polygons are
	// simplified using quantization and point elimination. However, we might
	// have received a mix of quantized and non-quantized geometries, so ensure
	// that all are quantized by quantizing all coordinates in the batch.
	var tolerance = this.tolerance;
	if (tolerance !== 0) {
		var coordinates = this.coordinates;
		var i, ii;
		for (i = 0, ii = coordinates.length; i < ii; ++i) {
			coordinates[i] = ol.geom.flat.simplify.snap(coordinates[i], tolerance);
		}
	}
};


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.getBufferedMaxExtent = function () {
	if (goog.isNull(this.bufferedMaxExtent_)) {
		this.bufferedMaxExtent_ = ol.extent.clone(this.maxExtent);
		if (this.maxLineWidth > 0) {
			var width = this.resolution * (this.maxLineWidth + 1) / 2;
			ol.extent.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
		}
	}
	return this.bufferedMaxExtent_;
};


/**
 * @inheritDoc
 */
map.render.canvas.PolygonReplay.prototype.setFillStrokeStyle =
	function (fillStyle, strokeStyle) {
		goog.asserts.assert(!goog.isNull(this.state_),
			'this.state_ should not be null');
		goog.asserts.assert(!goog.isNull(fillStyle) || !goog.isNull(strokeStyle),
			'fillStyle or strokeStyle should not be null');
		var state = this.state_;
		if (!goog.isNull(fillStyle)) {
			var fillStyleColor = fillStyle.getColor();
			state.fillStyle = ol.color.asString(!goog.isNull(fillStyleColor) ?
				fillStyleColor : ol.render.canvas.defaultFillStyle);
		} else {
			state.fillStyle = undefined;
		}
		if (!goog.isNull(strokeStyle)) {
			var strokeStyleColor = strokeStyle.getColor();
			state.strokeStyle = ol.color.asString(!goog.isNull(strokeStyleColor) ?
				strokeStyleColor : ol.render.canvas.defaultStrokeStyle);
			var strokeStyleLineCap = strokeStyle.getLineCap();
			state.lineCap = goog.isDef(strokeStyleLineCap) ?
				strokeStyleLineCap : ol.render.canvas.defaultLineCap;
			var strokeStyleLineDash = strokeStyle.getLineDash();
			state.lineDash = !goog.isNull(strokeStyleLineDash) ?
				strokeStyleLineDash.slice() : ol.render.canvas.defaultLineDash;
			var strokeStyleLineJoin = strokeStyle.getLineJoin();
			state.lineJoin = goog.isDef(strokeStyleLineJoin) ?
				strokeStyleLineJoin : ol.render.canvas.defaultLineJoin;
			var strokeStyleWidth = strokeStyle.getWidth();
			state.lineWidth = goog.isDef(strokeStyleWidth) ?
				strokeStyleWidth : ol.render.canvas.defaultLineWidth;
			var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
			state.miterLimit = goog.isDef(strokeStyleMiterLimit) ?
				strokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit;

			if (state.lineWidth > this.maxLineWidth) {
				this.maxLineWidth = state.lineWidth;
				// invalidate the buffered max extent cache
				this.bufferedMaxExtent_ = null;
			}
		} else {
			state.strokeStyle = undefined;
			state.lineCap = undefined;
			state.lineDash = null;
			state.lineJoin = undefined;
			state.lineWidth = undefined;
			state.miterLimit = undefined;
		}
	};


/**
 * @private
 */
map.render.canvas.PolygonReplay.prototype.setFillStrokeStyles_ = function () {
	var state = this.state_;
	var fillStyle = state.fillStyle;
	var strokeStyle = state.strokeStyle;
	var lineCap = state.lineCap;
	var lineDash = state.lineDash;
	var lineJoin = state.lineJoin;
	var lineWidth = state.lineWidth;
	var miterLimit = state.miterLimit;
	if (goog.isDef(fillStyle) && state.currentFillStyle != fillStyle) {
		this.instructions.push(
			[ol.render.canvas.Instruction.SET_FILL_STYLE, fillStyle]);
		state.currentFillStyle = state.fillStyle;
	}
	if (goog.isDef(strokeStyle)) {
		goog.asserts.assert(goog.isDef(lineCap), 'lineCap should be defined');
		goog.asserts.assert(!goog.isNull(lineDash), 'lineDash should not be null');
		goog.asserts.assert(goog.isDef(lineJoin), 'lineJoin should be defined');
		goog.asserts.assert(goog.isDef(lineWidth), 'lineWidth should be defined');
		goog.asserts.assert(goog.isDef(miterLimit), 'miterLimit should be defined');
		if (state.currentStrokeStyle != strokeStyle ||
			state.currentLineCap != lineCap ||
			state.currentLineDash != lineDash ||
			state.currentLineJoin != lineJoin ||
			state.currentLineWidth != lineWidth ||
			state.currentMiterLimit != miterLimit) {
			this.instructions.push(
				[ol.render.canvas.Instruction.SET_STROKE_STYLE,
					strokeStyle, lineWidth, lineCap, lineJoin, miterLimit, lineDash]);
			state.currentStrokeStyle = strokeStyle;
			state.currentLineCap = lineCap;
			state.currentLineDash = lineDash;
			state.currentLineJoin = lineJoin;
			state.currentLineWidth = lineWidth;
			state.currentMiterLimit = miterLimit;
		}
	}
};


/**
 * @constructor
 * @extends {map.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @protected
 * @struct
 */
map.render.canvas.TextReplay = function (tolerance, maxExtent, resolution) {

	goog.base(this, tolerance, maxExtent, resolution);

	/**
	 * @private
	 * @type {?ol.render.canvas.FillState}
	 */
	this.replayFillState_ = null;

	/**
	 * @private
	 * @type {?ol.render.canvas.StrokeState}
	 */
	this.replayStrokeState_ = null;

	/**
	 * @private
	 * @type {?ol.render.canvas.TextState}
	 */
	this.replayTextState_ = null;

	/**
	 * @private
	 * @type {string}
	 */
	this.text_ = '';

	/**
	 * @private
	 * @type {number}
	 */
	this.textOffsetX_ = 0;

	/**
	 * @private
	 * @type {number}
	 */
	this.textOffsetY_ = 0;

	/**
	 * @private
	 * @type {number}
	 */
	this.textRotation_ = 0;

	/**
	 * @private
	 * @type {number}
	 */
	this.textScale_ = 0;

	/**
	 * @private
	 * @type {?ol.render.canvas.FillState}
	 */
	this.textFillState_ = null;

	/**
	 * @private
	 * @type {?ol.render.canvas.StrokeState}
	 */
	this.textStrokeState_ = null;

	/**
	 * @private
	 * @type {?ol.render.canvas.TextState}
	 */
	this.textState_ = null;

};
goog.inherits(map.render.canvas.TextReplay, map.render.canvas.Replay);


/**
 * @inheritDoc
 */
map.render.canvas.TextReplay.prototype.drawText =
	function (flatCoordinates, offset, end, stride, geometry, feature, objId, textStyle) {
		if (this.text_ === '' ||
			goog.isNull(this.textState_) ||
			(goog.isNull(this.textFillState_) &&
				goog.isNull(this.textStrokeState_))) {
			return;
		}
		if (!goog.isNull(this.textFillState_)) {
			this.setReplayFillState_(this.textFillState_);
		}
		if (!goog.isNull(this.textStrokeState_)) {
			this.setReplayStrokeState_(this.textStrokeState_);
		}

		this.setReplayTextState_(this.textState_);
		this.beginGeometry(geometry, feature);
		var myBegin = this.coordinates.length;
		var layerGeoType = geometry.getType();//feature.getGeometry().getType();
		if (layerGeoType == 'MultiLineString') {
			var myEnd = this.appendFlatCoordinates(
				flatCoordinates, 0, flatCoordinates.length, stride, false) / 2;
		} else if (layerGeoType == 'LineString') {
			myBegin = this.coordinates.length;
			var myEnd = /*flatCoordinates.length;*/this.appendNewFlatCoordinates(
				flatCoordinates, 0, flatCoordinates.length, stride, false);
		} else {
			var myEnd =
				this.appendNewFlatCoordinates(flatCoordinates, offset, end, stride, false);
		}


		//console.log(feature.get('layerId')+'  myEnd='+myEnd+'  myEnd1='+myEnd1);
		var fill = !goog.isNull(this.textFillState_);
		var stroke = !goog.isNull(this.textStrokeState_);
		var drawTextInstruction = [
			ol.render.canvas.Instruction.DRAW_TEXT, myBegin, myEnd, this.text_,
			this.textOffsetX_, this.textOffsetY_, this.textRotation_, this.textScale_,
			fill, stroke, geometry, objId, textStyle];
		this.instructions.push(drawTextInstruction);
		this.hitDetectionInstructions.push(drawTextInstruction);
		this.endGeometry(geometry, feature);
	};


/**
 * @param {ol.render.canvas.FillState} fillState Fill state.
 * @private
 */
map.render.canvas.TextReplay.prototype.setReplayFillState_ =
	function (fillState) {
		var replayFillState = this.replayFillState_;
		if (!goog.isNull(replayFillState) &&
			replayFillState.fillStyle == fillState.fillStyle) {
			return;
		}
		var setFillStyleInstruction =
			[ol.render.canvas.Instruction.SET_FILL_STYLE, fillState.fillStyle];
		this.instructions.push(setFillStyleInstruction);
		this.hitDetectionInstructions.push(setFillStyleInstruction);
		if (goog.isNull(replayFillState)) {
			this.replayFillState_ = {
				fillStyle: fillState.fillStyle
			};
		} else {
			replayFillState.fillStyle = fillState.fillStyle;
		}
	};


/**
 * @param {ol.render.canvas.StrokeState} strokeState Stroke state.
 * @private
 */
map.render.canvas.TextReplay.prototype.setReplayStrokeState_ =
	function (strokeState) {
		var replayStrokeState = this.replayStrokeState_;
		if (!goog.isNull(replayStrokeState) &&
			replayStrokeState.lineCap == strokeState.lineCap &&
			replayStrokeState.lineDash == strokeState.lineDash &&
			replayStrokeState.lineJoin == strokeState.lineJoin &&
			replayStrokeState.lineWidth == strokeState.lineWidth &&
			replayStrokeState.miterLimit == strokeState.miterLimit &&
			replayStrokeState.strokeStyle == strokeState.strokeStyle) {
			return;
		}
		var setStrokeStyleInstruction = [
			ol.render.canvas.Instruction.SET_STROKE_STYLE, strokeState.strokeStyle,
			strokeState.lineWidth, strokeState.lineCap, strokeState.lineJoin,
			strokeState.miterLimit, strokeState.lineDash, false
		];
		this.instructions.push(setStrokeStyleInstruction);
		this.hitDetectionInstructions.push(setStrokeStyleInstruction);
		if (goog.isNull(replayStrokeState)) {
			this.replayStrokeState_ = {
				lineCap: strokeState.lineCap,
				lineDash: strokeState.lineDash,
				lineJoin: strokeState.lineJoin,
				lineWidth: strokeState.lineWidth,
				miterLimit: strokeState.miterLimit,
				strokeStyle: strokeState.strokeStyle
			};
		} else {
			replayStrokeState.lineCap = strokeState.lineCap;
			replayStrokeState.lineDash = strokeState.lineDash;
			replayStrokeState.lineJoin = strokeState.lineJoin;
			replayStrokeState.lineWidth = strokeState.lineWidth;
			replayStrokeState.miterLimit = strokeState.miterLimit;
			replayStrokeState.strokeStyle = strokeState.strokeStyle;
		}
	};


/**
 * @param {ol.render.canvas.TextState} textState Text state.
 * @private
 */
map.render.canvas.TextReplay.prototype.setReplayTextState_ =
	function (textState) {
		var replayTextState = this.replayTextState_;
		if (!goog.isNull(replayTextState) &&
			replayTextState.font == textState.font &&
			replayTextState.textAlign == textState.textAlign &&
			replayTextState.textBaseline == textState.textBaseline) {
			return;
		}
		var setTextStyleInstruction = [ol.render.canvas.Instruction.SET_TEXT_STYLE,
			textState.font, textState.textAlign, textState.textBaseline];
		this.instructions.push(setTextStyleInstruction);
		this.hitDetectionInstructions.push(setTextStyleInstruction);
		if (goog.isNull(replayTextState)) {
			this.replayTextState_ = {
				font: textState.font,
				textAlign: textState.textAlign,
				textBaseline: textState.textBaseline
			};
		} else {
			replayTextState.font = textState.font;
			replayTextState.textAlign = textState.textAlign;
			replayTextState.textBaseline = textState.textBaseline;
		}
	};


/**
 * @inheritDoc
 */
map.render.canvas.TextReplay.prototype.setTextStyle = function (textStyle) {
	if (goog.isNull(textStyle)) {
		this.text_ = '';
	} else {
		var textFillStyle = textStyle.getFill();
		if (goog.isNull(textFillStyle)) {
			this.textFillState_ = null;
		} else {
			var textFillStyleColor = textFillStyle.getColor();
			var fillStyle = ol.color.asString(!goog.isNull(textFillStyleColor) ?
				textFillStyleColor : ol.render.canvas.defaultFillStyle);
			if (goog.isNull(this.textFillState_)) {
				this.textFillState_ = {
					fillStyle: fillStyle
				};
			} else {
				var textFillState = this.textFillState_;
				textFillState.fillStyle = fillStyle;
			}
		}
		var textStrokeStyle = textStyle.getStroke();
		if (goog.isNull(textStrokeStyle)) {
			this.textStrokeState_ = null;
		} else {
			var textStrokeStyleColor = textStrokeStyle.getColor();
			var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
			var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
			var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
			var textStrokeStyleWidth = textStrokeStyle.getWidth();
			var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
			var lineCap = goog.isDef(textStrokeStyleLineCap) ?
				textStrokeStyleLineCap : ol.render.canvas.defaultLineCap;
			var lineDash = goog.isDefAndNotNull(textStrokeStyleLineDash) ?
				textStrokeStyleLineDash.slice() : ol.render.canvas.defaultLineDash;
			var lineJoin = goog.isDef(textStrokeStyleLineJoin) ?
				textStrokeStyleLineJoin : ol.render.canvas.defaultLineJoin;
			var lineWidth = goog.isDef(textStrokeStyleWidth) ?
				textStrokeStyleWidth : ol.render.canvas.defaultLineWidth;
			var miterLimit = goog.isDef(textStrokeStyleMiterLimit) ?
				textStrokeStyleMiterLimit : ol.render.canvas.defaultMiterLimit;
			var strokeStyle = ol.color.asString(!goog.isNull(textStrokeStyleColor) ?
				textStrokeStyleColor : ol.render.canvas.defaultStrokeStyle);
			if (goog.isNull(this.textStrokeState_)) {
				this.textStrokeState_ = {
					lineCap: lineCap,
					lineDash: lineDash,
					lineJoin: lineJoin,
					lineWidth: lineWidth,
					miterLimit: miterLimit,
					strokeStyle: strokeStyle
				};
			} else {
				var textStrokeState = this.textStrokeState_;
				textStrokeState.lineCap = lineCap;
				textStrokeState.lineDash = lineDash;
				textStrokeState.lineJoin = lineJoin;
				textStrokeState.lineWidth = lineWidth;
				textStrokeState.miterLimit = miterLimit;
				textStrokeState.strokeStyle = strokeStyle;
			}
		}
		var textFont = textStyle.getFont();
		var textOffsetX = textStyle.getOffsetX();
		var textOffsetY = textStyle.getOffsetY();
		var textRotation = textStyle.getRotation();
		var textScale = textStyle.getScale();
		var textText = textStyle.getText();
		var textTextAlign = textStyle.getTextAlign();
		var textTextBaseline = textStyle.getTextBaseline();
		var font = goog.isDef(textFont) ?
			textFont : ol.render.canvas.defaultFont;
		var textAlign = goog.isDef(textTextAlign) ?
			textTextAlign : ol.render.canvas.defaultTextAlign;
		var textBaseline = goog.isDef(textTextBaseline) ?
			textTextBaseline : ol.render.canvas.defaultTextBaseline;
		if (goog.isNull(this.textState_)) {
			this.textState_ = {
				font: font,
				textAlign: textAlign,
				textBaseline: textBaseline
			};
		} else {
			var textState = this.textState_;
			textState.font = font;
			textState.textAlign = textAlign;
			textState.textBaseline = textBaseline;
		}
		this.text_ = goog.isDef(textText) ? textText : '';
		this.textOffsetX_ = goog.isDef(textOffsetX) ? textOffsetX : 0;
		this.textOffsetY_ = goog.isDef(textOffsetY) ? textOffsetY : 0;
		this.textRotation_ = goog.isDef(textRotation) ? textRotation : 0;
		this.textScale_ = goog.isDef(textScale) ? textScale : 1;
	}
};


// LIBRARY from:
// https://github.com/simonsarris/Canvas-tutorials/blob/master/transform.js
// code below

function Transform() {
	this.reset();
}

Transform.prototype.reset = function () {
	this.m = [1, 0, 0, 1, 0, 0];
};

Transform.prototype.multiply = function (matrix) {
	var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
	var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

	var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
	var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

	var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
	var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

	this.m[0] = m11;
	this.m[1] = m12;
	this.m[2] = m21;
	this.m[3] = m22;
	this.m[4] = dx;
	this.m[5] = dy;
};

Transform.prototype.invert = function () {
	var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
	var m0 = this.m[3] * d;
	var m1 = -this.m[1] * d;
	var m2 = -this.m[2] * d;
	var m3 = this.m[0] * d;
	var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
	var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
	this.m[0] = m0;
	this.m[1] = m1;
	this.m[2] = m2;
	this.m[3] = m3;
	this.m[4] = m4;
	this.m[5] = m5;
};

Transform.prototype.rotate = function (rad) {
	var c = Math.cos(rad);
	var s = Math.sin(rad);
	var m11 = this.m[0] * c + this.m[2] * s;
	var m12 = this.m[1] * c + this.m[3] * s;
	var m21 = this.m[0] * -s + this.m[2] * c;
	var m22 = this.m[1] * -s + this.m[3] * c;
	this.m[0] = m11;
	this.m[1] = m12;
	this.m[2] = m21;
	this.m[3] = m22;
};

Transform.prototype.translate = function (x, y) {
	this.m[4] += this.m[0] * x + this.m[2] * y;
	this.m[5] += this.m[1] * x + this.m[3] * y;
};

Transform.prototype.scale = function (sx, sy) {
	this.m[0] *= sx;
	this.m[1] *= sx;
	this.m[2] *= sy;
	this.m[3] *= sy;
};

Transform.prototype.transformPoint = function (px, py) {
	var x = px;
	var y = py;
	px = x * this.m[0] + y * this.m[2] + this.m[4];
	py = x * this.m[1] + y * this.m[3] + this.m[5];
	return [px, py];
};

map.render.canvas.LineStringReplay.prototype.sliceLineStringByExtent = function(lineString, extent){
	var line = new ol.Feature(new ol.geom.LineString(lineString.getCoordinates()));
	var polygon = new ol.Feature(new ol.geom.Polygon.fromExtent(extent));
	var format = new ol.format.GeoJSON();
	var intersects = turf.intersect(
		format.writeFeatureObject(line),
		format.writeFeatureObject(polygon))
	if(intersects){
		var intersection = format.readFeature(intersects);
		if(intersection.getGeometry().getType() === 'MultiLineString'){
			return intersection.getGeometry().getLineStrings()[0];
		}
		return intersection.getGeometry();
	}
	/*
	var intersection = format.readFeature(
	turf.intersect(
		format.writeFeatureObject(polygon1),
		format.writeFeatureObject(polygon2)));
	 */

	return lineString;
}
goog.provide('map.renderer.vector');

goog.require('goog.asserts');
goog.require('ol.geom.Circle');
goog.require('ol.geom.GeometryCollection');
goog.require('ol.geom.LineString');
goog.require('ol.geom.MultiLineString');
goog.require('ol.geom.MultiPoint');
goog.require('ol.geom.MultiPolygon');
goog.require('ol.geom.Point');
goog.require('ol.geom.Polygon');
goog.require('ol.render.IReplayGroup');
goog.require('ol.style.ImageState');
goog.require('ol.style.Style');



/**
 * @param {ol.render.IReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
map.renderer.vector.renderPointGeometry_ =
    function(replayGroup, geometry, style, feature) {
  goog.asserts.assertInstanceof(geometry, ol.geom.Point,
      'geometry should be an ol.geom.Point');
  var imageStyle = style.getImage();
  if (!goog.isNull(imageStyle)) {
    if (imageStyle.getImageState() != ol.style.ImageState.LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(
        style.getZIndex(), ol.render.ReplayType.IMAGE);
    imageReplay.setImageStyle(imageStyle);
    imageReplay.drawPointGeometry(geometry, feature);
  }
  var textStyle = style.getText();
  if (!goog.isNull(textStyle)) {
    var textReplay = replayGroup.getReplay(
        style.getZIndex(), ol.render.ReplayType.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry.getCoordinates(), 0, 2, 2, geometry, feature);
  }
};

var GLOBAL_REDRAW = {};
var GLOBAL_REDRAW_COUNTER = {};
var GLOBAL_LABEL_REDRAW = {};
var GLOBAL_REDRAW_ARR = {};
var GLOBAL_REDRAW_LABEL_ARR = {};
var _labels = {};//все подписи, актуальные для данного масштаба
var _pointLabels = [];//подписи, которые попали в матрицу
var _lineLabels = [];

/**
 * @param {ol.render.IReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
map.renderer.vector.renderMultiPointGeometry_ =
    function(replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != ol.style.ImageState.LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(
        style.getZIndex(), ol.render.ReplayType.IMAGE);
    imageReplay.setImageStyle(imageStyle);
      //if(feature.get('layerId')=="PODS_SHEET_NOTE_FUND")
      //console.log("WW point+"+feature.get('layerId')+'  '+feature.get('labelType'));
      var labelType = feature.get('labelType');
      //console.time(labelType);
      var layerId = feature.get('layerId');
      GLOBAL_REDRAW[labelType] = true;
      GLOBAL_LABEL_REDRAW[labelType] = true;// успловие, что лейблы можно заносить в матрицу, а потом их использовать
      GLOBAL_REDRAW_ARR[labelType] = [];
      GLOBAL_REDRAW_LABEL_ARR[labelType] = [];
      //общая разрядка подписей, если у них не установлен overlap
      if(!goog.isDef(GLOBAL_REDRAW_LABEL_ARR['common']))
        GLOBAL_REDRAW_LABEL_ARR['common'] = {};
      _labels[labelType] = [];
      //_pointLabels[feature.get('labelType')] = {};
      //WidgetMap.regenerateMatrix(_dx,_dy,10,10,feature.get('labelType'));
      if(goog.isDef(_IS_CHANGE_LAYER_VISIBILITY[layerId])){
        _IS_CHANGE_LAYER_VISIBILITY[layerId] = {};
      }
    //перед обработкой чистим массив с подписями и временный массив
    _TEMP_LAYERS_LABELS[labelType] = [];
    if(_LABELS.length>0){
      var i=_LABELS.length-1;
      for(i; i >= 0;i--){
        if(_LABELS[i].unique.indexOf(labelType+'_') != -1)
          _LABELS.splice(i,1);
      }
    }
    //console.log('renderMultiLineStringGeometry_   '+_LABELS.length+'  name='+name);
    if(_pointLabels.length>0){
      var i=_pointLabels.length-1;
      for(i; i >= 0;i--){
        if(_pointLabels[i].unique.indexOf(labelType+'_') != -1)
          _pointLabels.splice(i,1);
      }
    }
    imageReplay.drawMultiPointGeometry(geometry, feature,labelType);
    //GLOBAL_REDRAW[feature.get('layerId')] = false;
    //GLOBAL_REDRAW_ARR[feature.get('layerId')] = {};
  }
  //console.log('Point  '+feature.get('labelType'));
  var textStyle = style.getText();
      //textStyle = null;
  if (!goog.isNull(textStyle)) {
    var flatCoordinates = geometry.getFlatCoordinates();
    var textReplay;
    //var labels = geometry.get('labels');
    //var labels = globalPointsLabels_[feature.get('labelType')];
    //for(var f=0;f < flatCoordinates.length; f++) {
      textReplay = replayGroup.getReplay(
          style.getZIndex(), ol.render.ReplayType.TEXT);
      //textStyle.setText(labels[f/2]);
      textStyle.setText('ff');
    //console.log('coords='+flatCoordinates.length);
      textReplay.setTextStyle(textStyle);
      //textReplay.drawText([flatCoordinates[f],flatCoordinates[f+1]], 0, 2,
      //    geometry.getStride(), geometry, feature);
    //  f++;
    //}

    textReplay.drawText(flatCoordinates, 0, flatCoordinates.length,
        geometry.getStride(), geometry, feature,'', textStyle);
  }
  //console.timeEnd(labelType);
};


/**
 * @param {ol.render.IReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
map.renderer.vector.renderMultiLineStringGeometry_ =
    function(replayGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
        var lineStringReplay = replayGroup.getReplay(
            style.getZIndex(), ol.render.ReplayType.LINE_STRING);
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        var layerId = feature.get('layerId');
        var labelType = feature.get('labelType');
        if(goog.isDef(_IS_CHANGE_LAYER_VISIBILITY[layerId])){
          _IS_CHANGE_LAYER_VISIBILITY[layerId] = {};
        }
        //перед обработкой чистим массив с подписями и временный массив
        _TEMP_LAYERS_LABELS[labelType] = [];
        if(_LABELS.length>0){
          var i=_LABELS.length-1;
          for(i; i >= 0;i--){
            if(_LABELS[i].unique.indexOf(labelType+'_') != -1)
              _LABELS.splice(i,1);
           }
        }
        if(_pointLabels.length>0){
          var i=_pointLabels.length-1;
          for(i; i >= 0;i--){
            if(_pointLabels[i].unique.indexOf(labelType+'_') != -1)
              _pointLabels.splice(i,1);
          }
        }
        GLOBAL_REDRAW[labelType] = true;
        GLOBAL_REDRAW_COUNTER[labelType] = 0;
        var styleArr = map.renderer.vector.getStyleMultiTypeFeature_(feature,'LineString');
        lineStringReplay.drawMultiLineStringGeometry(geometry, feature, style, replayGroup, style.getText(), styleArr);
      }
};

/**
 * Получение массива стилей для фичи
 * @param feature
 * @param type - Тип геометрии
 * @returns {*}
 * @private
 */
map.renderer.vector.getStyleMultiTypeFeature_ = function(feature,type){
  var mapZoom = WidgetMap.map.getView().getZoom();
  //если в id слоя есть "#", то это пка и клонированный слой
  //из типа надо вычленить уникальный id: от # до первого _
  var lType = undefined;
  if(goog.isDef(feature.get('type'))){
    var splitted = feature.get('type').split('#');
    lType = splitted[0];
    var typeStr = '';
    if(splitted.length>1){
      var sp = splitted[1].split('_');
      if(sp.length>1){
        //удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
        sp.splice(0,1);
        typeStr ='_'+sp.join('_');
        lType += typeStr;
      }
    }
  }
  var s;
  //отдельно обрабатываем тип фичи косметики с горизонтальными линиями
  var featureType = feature.get('featureType');
  if(featureType !== undefined && featureType === 'cosmetic'){
    try{

      lType = feature.get('labelType').split('/')[1];
      s = (goog.isNull(feature.get('layerId')))?null:WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lType,'LineString');
      if(!goog.isNull(s) && !goog.isNull(s.style)){
        if(goog.isArray(s.style))
          return [s.style[0]];
        return [s.style];
      }
    }
    catch(e){}
  }


  //если установлен стиль в _layers в <dataProvider>
  var dps = feature.get('dataProviderStyle');
  if(goog.isDef(dps)){
    s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(dps+typeStr,type);
    if(!goog.isNull(s) && !goog.isNull(s.style)){
      if(!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
        return [];
      if(goog.isArray(s.style))
        return s.style;
      return [s.style];
    }
    else{
      s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(dps,type);
      if(!goog.isNull(s) && !goog.isNull(s.style)){
        if(!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
          return [];
        if(goog.isArray(s.style))
          return s.style;
        return [s.style];
      }
    }

  }


  var lId = undefined;
  if(goog.isDef(feature.get('layerId')))
    lId = feature.get('layerId').split('#')[0];
  s = (goog.isNull(lId))?null:WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lType,type);
  if(!goog.isNull(s) && !goog.isNull(s.style)){
    if(!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
      return [];
    if(goog.isArray(s.style))
      return s.style;
    return [s.style];
  }

  s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(lId,type);
  if(!goog.isNull(s) && !goog.isNull(s.style)){
    if(!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
      return [];
    if(goog.isArray(s.style))
      return s.style;
    return [s.style];
  }
  s = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom('DEFAULT',type);
  if(!goog.isNull(s && !goog.isNull(s.style))) {
    if (!(mapZoom >= s.zoom.zoomMin && mapZoom <= s.zoom.zoomMax))
      return [];
    if(goog.isArray(s.style))
      return s.style;
    return [s.style];
  }
};


/**
 * @param {ol.render.IReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
map.renderer.vector.renderMultiPolygonGeometry_ =
    function(replayGroup, geometry, style, feature) {
      goog.asserts.assertInstanceof(geometry, ol.geom.MultiPolygon,
          'geometry should be an ol.geom.MultiPolygon');
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      //strokeStyle = new ol.style.Stroke({color: '#ff0000',width: 3});
      if (strokeStyle || fillStyle) {
        var polygonReplay = replayGroup.getReplay(
            style.getZIndex(), ol.render.ReplayType.POLYGON);
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);


        var layerId = feature.get('layerId');
        var labelType = feature.get('labelType');
        if(goog.isDef(_IS_CHANGE_LAYER_VISIBILITY[layerId])){
          _IS_CHANGE_LAYER_VISIBILITY[layerId] = {};
        }
        //перед обработкой чистим массив с подписями и временный массив
        _TEMP_LAYERS_LABELS[labelType] = [];
        if(_LABELS.length>0){
          var i=_LABELS.length-1;
          for(i; i >= 0;i--){
            if(_LABELS[i].unique.indexOf(labelType+'_') != -1)
              _LABELS.splice(i,1);
          }
        }
        if(_pointLabels.length>0){
          var i=_pointLabels.length-1;
          for(i; i >= 0;i--){
            if(_pointLabels[i].unique.indexOf(labelType+'_') != -1)
              _pointLabels.splice(i,1);
          }
        }
        GLOBAL_REDRAW[labelType] = true;
        GLOBAL_REDRAW_COUNTER[labelType] = 0;
        var styleArr = map.renderer.vector.getStyleMultiTypeFeature_(feature,'Polygon');

        polygonReplay.drawMultiPolygonGeometry(geometry, feature, style, replayGroup, style.getText(), styleArr);
      }
    };
/**
 * Класс, который содержит данные по вектору подписи
 * @param opt_option
 * @constructor
 */
map.renderer.vector.TextVector = function(opt_option){
  var options = opt_option || {};
  this.text = options.text;
  this.baseText = options.text;
  this.x = options.x;
  this.y = options.y;
  this.coordEnd = options.coordEnd;
  this.rotation = options.rotation;
  this.lineString = options.lineString;
  this.textStyle = options.textStyle;
  this.textWidth = options.textWidth;
  this.textHeight = options.textHeight;
  this.bounds = options.bounds;
}
goog.provide('map.format.WKT');
goog.provide('map.format.WKT.Parser');




/**
 * @constructor
 * @extends {map.format.TextFeature}
 * @param {olx.format.WKTOptions=} opt_options Options.
 * @api stable
 */
map.format.WKT = function(opt_options) {

 var options = goog.isDef(opt_options) ? opt_options : {};

 this.dimension_ = goog.isDef(options.dimension) ?
     options.dimension : 2;

 goog.base(this);

};
goog.inherits(map.format.WKT, ol.format.WKT);


/**
 * Parse a WKT string.
 * @param {string} wkt WKT string.
 * @return {ol.geom.Geometry|ol.geom.GeometryCollection|undefined}
 *     The geometry created.
 * @private
 */
map.format.WKT.prototype.parse_ = function(wkt) {
 var lexer = new ol.format.WKT.Lexer(wkt);
 var parser = new map.format.WKT.Parser(lexer,this.dimension_);
 return parser.parse();
};


/**
 * Class to parse the tokens from the WKT string.
 * @param {map.format.WKT.Lexer} lexer
 * @constructor
 * @protected
 */
map.format.WKT.Parser = function(lexer, dimension) {

 /**
  * @type {map.format.WKT.Lexer}
  * @private
  */
 this.lexer_ = lexer;

 /**
  * @type {map.format.WKT.Token}
  * @private
  */
 this.token_;

 /**
  * @type {number}
  * @private
  */
 this.dimension_ = goog.isDef(dimension)?dimension:2;
};
goog.inherits(map.format.WKT.Parser, ol.format.WKT.Parser);


goog.provide('map.interaction.DragZoomInOut');

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * @constructor
 * @extends {ol.interaction.DragBox}
 * @param {olx.interaction.DragZoomOptions=} opt_options Options.
 * @api stable
 */
map.interaction.DragZoomInOut = function(opt_options) {
    var options = goog.isDef(opt_options) ? opt_options : {};
    ol.DRAG_BOX_HYSTERESIS_PIXELS_SQUARED = 0;
    var condition = goog.isDef(options.condition) ?
        options.condition : ol.events.condition.mouseOnly;

    this.endHandler = goog.isDef(options.endHandler) ?
        options.endHandler : undefined;
    this.isZoomIn_ = goog.isDef(options.isZoomIn) ?
        options.isZoomIn : true;
    goog.base(this, {
        condition: condition
    });

};
goog.inherits(map.interaction.DragZoomInOut, ol.interaction.DragZoom);


/**
 * @inheritDoc
 */
map.interaction.DragZoomInOut.prototype.onBoxEnd = function(event) {
    var map = this.getMap();
    var view = map.getView();
    goog.asserts.assert(goog.isDef(view));
    var extent = this.getGeometry().getExtent();
    if(this.endHandler) {
        this.endHandler(extent, event);
        return;
    }
    var extentSize = ol.extent.getSize(extent);
    var center = ol.extent.getCenter(extent);
    //если просто кликнули, то зуммируемся на уровень вверх/низ в зависимости от выбранного режима
    if(extentSize[0] == 0 && extentSize[1] == 0){
        var currentZoom = view.getZoom();
        view.setCenter(center);
        if(this.isZoomIn_) {
            view.setZoom(currentZoom + 1);
        }
        else {
            view.setZoom(currentZoom - 1);
        }
        return;
    }
    var size = map.getSize();
    goog.asserts.assert(goog.isDef(size));
    if(this.isZoomIn_){
        view.fit(extent, size);
    } else {
        var mapLeftTop = map.getCoordinateFromPixel([0,0]);
        var mapRightBottom = map.getCoordinateFromPixel(size);
        var cntr = [extent[0] + extentSize[0]/2, extent[3] + extentSize[1]/2];
        var zoom = Math.max(extentSize[0]/Math.abs(mapRightBottom[0]-mapLeftTop[0]), extentSize[1]/Math.abs(mapLeftTop[0]-mapRightBottom[0]));
        var bnd = [cntr[0] + (mapLeftTop[0] - cntr[0])/zoom,
                cntr[1] + (mapRightBottom[1] - cntr[1])/zoom,
                cntr[0] + (mapLeftTop[0] - cntr[0])/zoom + (mapRightBottom[0] - mapLeftTop[0])/zoom,
                cntr[1] + (mapRightBottom[1] - cntr[1])/zoom + (mapLeftTop[1] - mapRightBottom[1])/zoom];
        view.fit(bnd, size);
    }

};
goog.provide('map.interaction.CASDragZoomInOut');

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * @constructor
 * @extends {ol.interaction.DragBox}
 * @param {olx.interaction.DragZoomOptions=} opt_options Options.
 * @api stable
 */
map.interaction.CASDragZoomInOut = function(opt_options) {
    var options = goog.isDef(opt_options) ? opt_options : {};
    goog.base(this, options);
    this.callbackFunc_ = options.callbackFunc;
    this.handleUpEvent_ = map.interaction.CASDragZoomInOut.handleUpEvent_;
    this.handleDragEvent_ = map.interaction.CASDragZoomInOut.handleDragEvent_;
};
goog.inherits(map.interaction.CASDragZoomInOut, map.interaction.DragZoomInOut );


/**
 * @inheritDoc
 */
map.interaction.CASDragZoomInOut.prototype.onBoxEnd = function(event) {
    var map = this.getMap();
    var view = map.getView();
    goog.asserts.assert(goog.isDef(view));
    var size = map.getSize();
    var endCoordinates = event.coordinate;
    var startCoordinates = map.getCoordinateFromPixel(this.startPixel_);
    var boundsRect = [Math.min(startCoordinates[0],endCoordinates[0]),
        Math.min(endCoordinates[1],startCoordinates[1]),
        Math.max(startCoordinates[0],endCoordinates[0]),
        Math.max(endCoordinates[1],startCoordinates[1])];
    goog.asserts.assert(goog.isDef(size));
    if(this.isZoomIn_){
        if(goog.isDef(this.callbackFunc_))
            this.callbackFunc_(boundsRect, this.isZoomIn_);
    } else {
        var mapLeftTop = map.getCoordinateFromPixel([0,0]);
        var mapRightBottom = map.getCoordinateFromPixel(size);
        var cntr = [boundsRect[0] + ol.extent.getWidth(boundsRect)/2, boundsRect[3] + ol.extent.getHeight(boundsRect)/2];
        var zoom = Math.max(ol.extent.getWidth(boundsRect)/Math.abs(mapRightBottom[0]-mapLeftTop[0]), ol.extent.getHeight(boundsRect)/Math.abs(mapLeftTop[1]-mapRightBottom[1]));
        var bnd = [cntr[0] + (mapLeftTop[0] - cntr[0])/zoom,
                cntr[1] + (mapRightBottom[1] - cntr[1])/zoom,
                cntr[0] + (mapLeftTop[0] - cntr[0])/zoom + (mapRightBottom[0] - mapLeftTop[0])/zoom,
                cntr[1] + (mapRightBottom[1] - cntr[1])/zoom + (mapLeftTop[1] - mapRightBottom[1])/zoom];
        if(goog.isDef(this.callbackFunc_))
            this.callbackFunc_(bnd, this.isZoomIn_);

    }
};


/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */
map.interaction.CASDragZoomInOut.handleUpEvent_ = function(mapBrowserEvent) {
    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
        return true;
    }
    this.box_.setMap(null);
    var deltaX = mapBrowserEvent.pixel[0] - this.startPixel_[0];
    var deltaY = mapBrowserEvent.pixel[1] - this.startPixel_[1];
    if (deltaX * deltaX + deltaY * deltaY >
        ol.DRAG_BOX_HYSTERESIS_PIXELS_SQUARED) {
        this.onBoxEnd(mapBrowserEvent);
        this.dispatchEvent(new ol.DragBoxEvent(ol.DragBoxEventType.BOXEND,
            mapBrowserEvent.coordinate));
    }
    return false;
};
/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragBox}
 * @private
 */
map.interaction.CASDragZoomInOut.handleDragEvent_ = function(mapBrowserEvent) {
    if (!ol.events.condition.mouseOnly(mapBrowserEvent)) {
        return;
    }
    var map = this.getMap();
    var start = [this.startPixel_[0],0];
    var end = [mapBrowserEvent.pixel[0],map.getSize()[1]];
    this.box_.setPixels(start, end);
};
goog.provide('map.interaction.DrawMeasure');

map.interaction.DrawMeasure = function(options) {
    goog.base(this,options);
};

goog.inherits(map.interaction.DrawMeasure, ol.interaction.Draw);

/**
 * Handle move events.
 * @param {ol.MapBrowserEvent} event A move event.
 * @return {boolean} Pass the event to other interactions.
 * @private
 */
map.interaction.DrawMeasure.prototype.handlePointerMove_ = function(event) {
    if (this.mode_ === ol.interaction.DrawMode.POINT &&
        goog.isNull(this.finishCoordinate_)) {
        this.startDrawing_(event);
    }
    else if (this.finishCoordinate_) {
        this.modifyDrawing_(event);
    } else {
        this.createOrUpdateSketchPoint_(event);
    }
    this.dispatchEvent(new ol.interaction.DrawEvent('calculatedistance',
        this.sketchFeature_, event));
    return true;
};

/**
 * Redraw the skecth features.
 * @private
 */
map.interaction.DrawMeasure.prototype.updateSketchFeatures_ = function() {
    var sketchFeatures = [];
    if (this.sketchFeature_) {
        sketchFeatures.push(this.sketchFeature_);
    }
    if (this.sketchLine_) {
        sketchFeatures.push(this.sketchLine_);// рисуются линии для полигона
    }
    //без отображения стартовой точки
    if (this.sketchPoint_) {
        //sketchFeatures.push(this.sketchPoint_);
    }
    var overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);

};


/**

 /**
 * Add a new coordinate to the drawing.
 * @param {ol.MapBrowserEvent} event Event.
 * @private
 */
map.interaction.DrawMeasure.prototype.addToDrawing_ = function(event) {
    var coordinate = event.coordinate;
    var geometry = this.sketchFeature_.getGeometry();
    goog.asserts.assertInstanceof(geometry, ol.geom.SimpleGeometry,
        'geometry must be an ol.geom.SimpleGeometry');
    var done;
    var coordinates;
    if (this.mode_ === ol.interaction.DrawMode.LINE_STRING) {
        this.finishCoordinate_ = coordinate.slice();
        coordinates = this.sketchCoords_;
        coordinates.push(coordinate.slice());
        done = coordinates.length > this.maxPoints_;
        this.geometryFunction_(coordinates, geometry);
    } else if (this.mode_ === ol.interaction.DrawMode.POLYGON) {
        coordinates = this.sketchCoords_[0];
        coordinates.push(coordinate.slice());
        done = coordinates.length > this.maxPoints_;
        if (done) {
            this.finishCoordinate_ = coordinates[0];
        }
        this.geometryFunction_(this.sketchCoords_, geometry);
    }
    this.updateSketchFeatures_();
    //вызываем событие для пересчета длин
    this.dispatchEvent(new ol.interaction.DrawEvent('calculatedistance',
        this.sketchFeature_, event));
    if (done) {
        this.finishDrawing();
    }

};
goog.provide('map.interaction.DrawGeometry');



/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @fires map.interaction.DrawGeometryEvent
 * @param {olx.interaction.DrawOptions} options Options.
 * @api stable
 */
map.interaction.DrawGeometry = function(options) {
	goog.base(this,options);
};
goog.inherits(map.interaction.DrawGeometry, ol.interaction.Draw);

/**
 * Add a new coordinate to the drawing.
 * @param {ol.MapBrowserEvent} event Event.
 * @private
 */
map.interaction.DrawGeometry.prototype.addToDrawing_ = function(event) {
	var coordinate = event.coordinate;
	var geometry = this.sketchFeature_.getGeometry();
	goog.asserts.assertInstanceof(geometry, ol.geom.SimpleGeometry,
		'geometry must be an ol.geom.SimpleGeometry');
	var done;
	var coordinates;
	if (this.mode_ === ol.interaction.DrawMode.LINE_STRING) {
		this.finishCoordinate_ = coordinate.slice();
		coordinates = this.sketchCoords_;
		coordinates.push(coordinate.slice());
		done = coordinates.length > this.maxPoints_;
		this.geometryFunction_(coordinates, geometry);
	} else if (this.mode_ === ol.interaction.DrawMode.POLYGON) {
		coordinates = this.sketchCoords_[0];
		coordinates.push(coordinate.slice());
		done = coordinates.length > this.maxPoints_;
		if (done) {
			this.finishCoordinate_ = coordinates[0];
		}
		this.geometryFunction_(this.sketchCoords_, geometry);
	}
	this.updateSketchFeatures_();

	if (done) {
		this.finishDrawing();
	}
	//вызываем событие для пересчета длин
	this.dispatchEvent(new ol.interaction.DrawEvent('calculatedistance',
		this.sketchFeature_));
};
goog.provide('map.controls.BaseLayerMenuControl');
/**
 * @constructor
 * @extends {ol.control.Control}
 * @param {Object=} opt_options Control options.
 */
map.controls.BaseLayerMenuControl = function(opt_options){
    var options = opt_options || {};
    //var comboBox = document.createElement('select');
    var className = goog.isDef(options.className) ?
        options.className : 'map-baselayers';
    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;


    var radioVector = goog.dom.createDom(goog.dom.TagName.DIV);//,null,'Векторный режим');
    var radioRaster = goog.dom.createDom(goog.dom.TagName.DIV);
    var radioVectorLabel = goog.dom.createDom(goog.dom.TagName.LABEL, {
        className : 'map-baselayer-label',
        title:gis_baselayermenucontrol_1

    }, null,gis_baselayermenucontrol_2);
    var radioRasterLabel = goog.dom.createDom(goog.dom.TagName.LABEL, {
        className : 'map-baselayer-modeslabel',
        title:gis_baselayermenucontrol_3
    }, null,gis_baselayermenucontrol_4);
    $(radioVector).jqxRadioButton({ width: 20, groupName:'radioMode', checked:WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR, theme:'gis-radio'}).css('display','inline-block')
        .bind('change', function (event) {
        var checked = event.args.checked;
        WidgetMap.changeMode(checked);
    });
    $(radioRaster).jqxRadioButton({ width: 20, groupName:'radioMode', checked:WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER, theme:'gis-radio' }).css('display','inline-block')
        .css('margin-left','20px');

    //var radioVectorDiv = goog.dom.createDom(goog.dom.TagName.DIV,'', radioVector,radioVectorLabel);
    //var radioRasterDiv = goog.dom.createDom(goog.dom.TagName.DIV,'', radioRaster,radioRasterLabel);

    var modesDiv = goog.dom.createDom(goog.dom.TagName.DIV,'', radioVector,radioVectorLabel, radioRaster,radioRasterLabel);
    $(modesDiv).addClass('map-baselayer-modesdiv');
    var source = {
        localdata: [],
        datatype: "array"
    };
    var dataAdapter = new $.jqx.dataAdapter(source);
    this.combobox = goog.dom.createDom(goog.dom.TagName.DIV);
    $(this.combobox).jqxBaseLayersList({ source: dataAdapter, selectedIndex: 0,
        placeHolder:gis_baselayermenucontrol_5,
        theme:'gis-blue',
        displayMember: "label",
        valueMember: "id",
        width: 200, height: 20,
        dropDownWidth: 380,
        autoDropDownHeight: true
    });
    $(this.combobox).addClass('map-baselayers-inner');
    this.isFirstLoad = false;
    var that = this;
    $(this.combobox).on('select', function (event) {
        if(that.isFirstLoad == true){
            that.isFirstLoad = false;
            return false;
        }
        var args = event.args;
        if (goog.isDef(args)) {
            var item = event.args.item;
            WidgetMap.baseLayer = item;
	        WidgetMap.currentMapId = item.value;
            //если выставлен флаг для дизейблинга кнопок и выбран режим интернет подложки, то дизейблим кнопки
	        if(goog.isDef(WidgetMap) && WidgetMap.isPrintDisabled_()){
		        WidgetMap.exportImageChooserControl.disableButtons();
	        }
            WidgetMap.layerManager.clearRasterDatas();
            var baseLayerGroup = WidgetMap.BaseLayersParser.getLayer(item.value);

            if(goog.isDef(WidgetMap.map)){
                var coll = new ol.Collection(baseLayerGroup);
                WidgetMap.BaseLayersParser.currentBaseLayers.setLayers(coll);
                WidgetMap.changeMapView(WidgetMap.BaseLayersParser.getMaxZoom(),item.value,item.originalItem.projection);
            }
        }
        return false;
    });

    if(goog.isDefAndNotNull(WidgetMap.BaseLayersParser.dataProvider) && goog.isArray(WidgetMap.BaseLayersParser.dataProvider)) {
	    this.changeListByMode();
    }

    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, modesDiv, this.combobox );
    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.BaseLayerMenuControl, ol.control.Control);


//фильтруем данные в списке, чтобы там были только для текущего режима
map.controls.BaseLayerMenuControl.prototype.getListByMode = function(){
    var newArr = [];
    var i = 0;
    for(;i<WidgetMap.BaseLayersParser.dataProvider.length;i++){
        var el = WidgetMap.BaseLayersParser.dataProvider[i];
        if(el.isRaster == true && WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER ){
            newArr.push(el);
        }
        if(el.isRaster != true && WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR){
            newArr.push(el);
        }
    }
    return newArr;
};

//устанавливаем в комбобокс новые данные
map.controls.BaseLayerMenuControl.prototype.changeListByMode = function(){
    this.isFirstLoad = true;
    var arr = this.getListByMode();
    var source = {
        localdata: [],
        datatype: "array"
    };
    source.localdata = arr;
    var dataAdapter = new $.jqx.dataAdapter(source);
    var selectedIndex = 0;
	var i=0;
    if(goog.isDef(WidgetMap) && goog.isDef(WidgetMap.currentMapId)){
	    var mapIdWithMode = WidgetMap.currentMapId;
	    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.RASTER) {
            if(mapIdWithMode.indexOf('_RASTERMODE') == -1)
                mapIdWithMode +='_RASTERMODE';
        }
	    if(WidgetMap.CURRENT_MODE == WidgetMap.MODES.VECTOR) mapIdWithMode = mapIdWithMode.replace('_RASTERMODE','');
        for(; i<arr.length;i++){
            if(arr[i].id == mapIdWithMode){
	            selectedIndex = i;
                break;
            }
        }
    }
    $(this.combobox).jqxBaseLayersList({source: dataAdapter,selectedIndex:selectedIndex});
};

goog.provide('map.controls.ClearCosmeticControl');
goog.provide('map.controls.PanControl');
goog.provide('map.controls.ZoomBoxControl');
goog.provide('map.controls.ZoomSliderControl');


goog.provide('map.controls.FullMapControl');

goog.provide('map.controls.ExportImageChooserControl');
goog.provide('map.controls.ExportImageControl');
goog.provide('map.controls.CASExportImageControl');

goog.require('map.interaction.DragZoomInOut');



map.controls.CLASS_CONTROL = 'map-control';

map.controls.PRINT_TYPE = {
    PRINT: 'print',
    EXPORT: 'export'
};

/**
 * Контрол для перемещения руков на карте
 * @constructor
 */
map.controls.PanControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-pan';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_basecontrols_1;

    this.panElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-button  selectedMapButton',
        'type' : 'button',
        'title' : tooltipLabel
    });
    //устанавливаем дефолтную выбранную кнопку
    WidgetMap.selectedMapButton = this.panElement;


    goog.events.listen(this.panElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.PanControl.prototype.handlePanClick_), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.panElement);

    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.PanControl, ol.control.Control);

/**
 * Реация на нажатие кнопки перемещения по карте
 * @private
 */
map.controls.PanControl.prototype.handlePanClick_ = function() {
    if(goog.isDef(WidgetMap.panControl))
        WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.PAN,WidgetMap.panControl.panElement);
    else if(goog.isDef(this.panElement)){
        WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.PAN,this.panElement);
    }
    //удаляем сначала перемещение мышью
    WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
    WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);

    WidgetMap.baseInteraction = new ol.interaction.DragPan({
        kinetic: (goog.isDef(WidgetMap.kinetic))?WidgetMap.kinetic:null
    });
    WidgetMap.map.addInteraction(WidgetMap.baseInteraction);
};

map.controls.PanControl.handleEvent = function(mapBrowserEvent) {
    var stopEvent = false;
    var browserEvent = mapBrowserEvent.browserEvent;
    if (mapBrowserEvent.type == ol.MapBrowserEvent.EventType.DBLCLICK) {
        var map = mapBrowserEvent.map;
        mapBrowserEvent.preventDefault();
        stopEvent = true;
    }
    return !stopEvent;
};

map.controls.PanControl.reset = function(){
};

/**
 * Контрол для кнопок увеличения/уменьшения в виде лупы
 * @constructor
 */
map.controls.ZoomBoxControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-zoombox';

    var tooltipLabelIn = goog.isDef(options.tooltipLabelZoomIn) ?
        options.tooltipLabelZoomIn : gis_basecontrols_2;
    this.inElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-in',
        'type' : 'button',
        'title' : tooltipLabelIn
    });


    this.inElement.style.display = 'inline';

    goog.events.listen(this.inElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ZoomBoxControl.prototype.handleZoomBoxClick_,'zoomIn'), false, this);

    var tooltipLabelOut = goog.isDef(options.tooltipLabelZoomOut) ?
        options.tooltipLabelZoomOut : gis_basecontrols_3;
    this.outElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-out',
        'type' : 'button',
        'title' : tooltipLabelOut
    });
    this.outElement.style.display = 'inline';

    goog.events.listen(this.outElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ZoomBoxControl.prototype.handleZoomBoxClick_,'zoomOut'), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.inElement,
        this.outElement);

    goog.base(this, {
        element: element,
        target: options.target
    });

};
goog.inherits(map.controls.ZoomBoxControl, ol.control.Control);


/**
 * Реация на нажатие кнопок зуммирования
 * @param type тип нажатой кнопки(zoomIn или zoomOut)
 * @private
 */
map.controls.ZoomBoxControl.prototype.handleZoomBoxClick_ = function(type) {
    var currB = (type === "zoomIn")?this.inElement:this.outElement;
    WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.ZOOM, currB);
    //удаляем сначала перемещение мышью
    WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
    WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);
    // вкл/выкл режим дополнительно, если нажали 2-й раз ту же кнопку
    if(WidgetMap.baseInteraction && WidgetMap.baseInteraction.isZoomIn_  !== undefined){
        if((type === "zoomIn" && WidgetMap.baseInteraction.isZoomIn_ === true) || (type === "zoomOut" && WidgetMap.baseInteraction.isZoomIn_ === false)){
                this.reset();
                return;
            }
    }

    var isZoomIn = type === "zoomIn";
    WidgetMap.baseInteraction =
        new map.interaction.DragZoomInOut({
            isZoomIn: isZoomIn,
            //endHandler: map.controls.ZoomBoxControl.endHandler
        });
    WidgetMap.map.addInteraction(WidgetMap.baseInteraction);
};

map.controls.ZoomBoxControl.prototype.reset = function(){
    WidgetMap.handleEscClick_();
};

map.controls.ZoomBoxControl.endHandler = function(){
    //WidgetMap.handleEscClick_();
};

map.controls.ZoomBoxControl.reset = function(){
    //WidgetMap.handleEscClick_();
};



/**
 * Контрол "показать всю карту"
 * @constructor
 */
map.controls.FullMapControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-fullmap';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_basecontrols_4;
    var panElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });


    goog.events.listen(panElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.FullMapControl.prototype.handleFullMapClick_), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, panElement);
    }
    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.FullMapControl, ol.control.Control);


/**
 * Реация на нажатие кнопки перемещения по карте
 * @private
 */
map.controls.FullMapControl.prototype.handleFullMapClick_ = function() {
    //забираем координаты и зум из конфига
    var zoom = WidgetMap.START_ZOOM;
    var centerX = WidgetMap.START_X;
    var centerY = WidgetMap.START_Y;
   
    if(WidgetMap.DEFAULT_PROJECTION == 'EPSG:5807'){
        this.centerOn_([centerX,centerY], zoom);
    }
    else{
         //переводим координаты в проекцию базового слоя
        var coords = GeoUtil.convertCoords([centerX, centerY],GeoUtil.PROJS.WGS84, WidgetMap.DEFAULT_PROJECTION);
        this.centerOn_(coords, zoom);
    }
};

/**
 * Центрирование карты по координатам и зуму
 *
 * @param center - массив [centerX, centerY]
 * @param zoom
 * @private
 */
map.controls.FullMapControl.prototype.centerOn_ = function(center, zoom) {
    var map = WidgetMap.map;
    if(!goog.isDefAndNotNull(map))
        return;
    var view = map.getView();
    var currentResolution = view.getResolution();
    if (goog.isDef(currentResolution)) {
        if (this.duration_ > 0) {
            map.beforeRender(ol.animation.zoom({
                resolution: currentResolution,
                duration: 250,
                easing: ol.easing.easeOut
            }));
        }

        var resolution = view.constrainResolution(
            view.maxResolution_, zoom - view.minZoom_, 0);

        view.setResolution(resolution);
        view.setCenter([center[0], center[1]]);
    }
};

/**
 * Контрол для выбора вариантов экспорта/печати карты
 * @param opt_options
 * @constructor
 */
map.controls.ExportImageChooserControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-choose-image';

    this.currentExportImage = map.controls.PRINT_TYPE.PRINT;
	this.isVisible = false;

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_basecontrols_5;
    this.innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-current map-image-print',
        'type' : 'button',
        'title' : tooltipLabel
    });
    this.innerElement.style.display = 'inline';

    this.arrowElement = goog.dom.createDom(goog.dom.TagName.DIV, {
        'class': className + '-arrow',
        'type' : 'button',
        'title' : tooltipLabel
    });
	this.arrowElement.style.display = 'inline';
    goog.events.listen( this.innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageClick_), false, this);

    goog.events.listen( this.innerElement,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseover'), false, this);
    goog.events.listen( this.innerElement,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen( this.innerElement,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseenter'), false, this);
    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.arrowElement, this.innerElement);

    /*$('.map-image').mouseup(function (e) {
        e.stopPropagation();
    });
    $('.map-choose-image').mouseup(function (e) {
        e.stopPropagation();
    });*/
    goog.base(this, {
        element: element,
        target: options.target
    });

};
goog.inherits(map.controls.ExportImageChooserControl, ol.control.Control);

/**
 * Реакция на нажатия стрелки выбора кнопки. Старая версия. Используется в ПКА
 * @private
 */
map.controls.ExportImageChooserControl.prototype.handleExportImageChooseClick_ = function(type) {
    if(WidgetMap.exportImageControl !== undefined)
        WidgetMap.exportImageControl.setVisible_(!WidgetMap.exportImageControl.isVisible);
};
/**
 * Реация на нажатие кнопки поиска
 * @private
 */
map.controls.ExportImageChooserControl.prototype.handleExportImageClick_ = function() {
    MapUtil.closeButtons('export');
	return;
    if(goog.isDef(WidgetMap.exportImageControl) && WidgetMap.exportImageControl.innerElementPrint.className.indexOf('map-image-print-disable')!=-1)
        return;
    WidgetMap.exportImageControl.handleExportImageClick_(this.currentExportImage);
};

/**
 * Дизейблим кнопки при смене режима карты на интернет режим, чтобы при экс
 * @private
 */
map.controls.ExportImageChooserControl.prototype.disableButtons = function() {
    if(goog.isDef(WidgetMap.exportImageControl)){//дизеблим кнопки
	    $(WidgetMap.exportImageControl.innerElementExport).removeClass('map-image-export');
	    $(WidgetMap.exportImageControl.innerElementExport).addClass('map-image-export-disable');
	    $(WidgetMap.exportImageControl.innerElementPrint).removeClass('map-image-print');
	    $(WidgetMap.exportImageControl.innerElementPrint).addClass('map-image-print-disable');
    }
    if(this.innerElement.className.indexOf('map-image-export')!=-1){
	    $(this.innerElement).removeClass('map-image-export');
	    $(this.innerElement).addClass('map-image-export-disable');
    }
    else{
	    $(this.innerElement).removeClass('map-image-print');
	    $(this.innerElement).addClass('map-image-print-disable');
    }
};
/**
 * Реация на нажатие кнопки выбора режима поиска
 * @private
 */
map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_ = function(eventType) {
	return;
    if(eventType === 'mouseover') {
        WidgetMap.exportImageControl.setVisible_(true);
        if(WidgetMap.baseLayersControl !== undefined)
            WidgetMap.baseLayersControl.close();
    }
    if(eventType === 'mouseleave'){
        setTimeout(function(){
            WidgetMap.exportImageControl.setVisible_(false);
        },2000);
    }
};


/**
 * Смена типа экспорта/печати по клику на кнопки из map.controls.ExportImageControl
 * @private
 */
map.controls.ExportImageChooserControl.prototype.changeExportImageType = function(type) {
    this.currentExportImage = type;
    if(type == map.controls.PRINT_TYPE.PRINT){
        $(this.innerElement).addClass('map-image-print');
        $(this.innerElement).removeClass('map-image-export');
    }
    if(type == map.controls.PRINT_TYPE.EXPORT){
        $(this.innerElement).removeClass('map-image-print');
        $(this.innerElement).addClass('map-image-export');
    }
};

/**
 * Контрол "Экспорт в png"
 * @constructor
 */
map.controls.ExportImageControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-image';

    var needExport = goog.isDef(options.needExport) ?
        options.needExport : true;
    var needPrint = goog.isDef(options.needPrint) ?
        options.needPrint : true;

    this.isVisible = false;

    var tooltipLabelPrint = goog.isDef(options.tooltipLabelPrint) ?
        options.tooltipLabelPrint : gis_basecontrols_6;
    this.innerElementPrint = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-print',
        'type' : 'button',
        'title' : tooltipLabelPrint
    });
    //innerElementPrint.style.display = 'inline';

    goog.events.listen(this.innerElementPrint,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ExportImageControl.prototype.handleExportImageClick_,map.controls.PRINT_TYPE.PRINT), false, this);


    var tooltipLabelExport = goog.isDef(options.tooltipLabelExport) ?
        options.tooltipLabelExport : gis_basecontrols_7;
    this.innerElementExport = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-export',
        'type' : 'button',
        'title' : tooltipLabelExport
    });
    //innerElementExport.style.display = 'inline';

    goog.events.listen(this.innerElementExport,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ExportImageControl.prototype.handleExportImageClick_,map.controls.PRINT_TYPE.EXPORT), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element;
    if(!needExport) this.innerElementExport = undefined;
    if(!needPrint) this.innerElementPrint = undefined;
    if(!needExport && !needPrint) options.noElement = true;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.innerElementPrint, this.innerElementExport);
    goog.events.listen(element,
        goog.events.EventType.MOUSEOVER, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseover'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSELEAVE, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseleave'), false, this);
    goog.events.listen(element,
        goog.events.EventType.MOUSEENTER, goog.partial(
            map.controls.ExportImageChooserControl.prototype.handleExportImageChooseEvents_, 'mouseenter'), false, this);
    goog.base(this, {
        element: element,
        target: options.target
    });
};
goog.inherits(map.controls.ExportImageControl, ol.control.Control);

/**
 * Скрыть/показать список кнопок
 * @param visible
 * @private
 */
map.controls.ExportImageControl.prototype.setVisible_ = function(visible) {
    if(visible)
        $('.map-image').css('visibility','visible');
    else
        $('.map-image').css('visibility','hidden');
    this.isVisible = visible;
};

/**
 * Реакция на нажатие кнопки экспорта изображения
 * @private
 */
map.controls.ExportImageControl.prototype.handleExportImageClick_ = function(type) {
    if(goog.isDef(WidgetMap.exportImageControl) && WidgetMap.exportImageControl.innerElementPrint.className.indexOf('map-image-print-disable')!=-1)
        return;
    var that = this;
    if(goog.isDef(WidgetMap.exportImageChooserControl)){
		this.setVisible_(false);
		WidgetMap.exportImageChooserControl.changeExportImageType(type);
    }
    if(goog.isDefAndNotNull(WidgetMap.map)){
        WidgetMap.map.once('postcompose', function(event) {
            var canvas = event.context.canvas;
            switch(type){
                case map.controls.PRINT_TYPE.EXPORT:{
                    try{
                        that.exportImage(canvas);
                    }
                    catch(ex){
                        BlockingUtil.ready();
                        App.errorReport(gis_basecontrols_8, ex, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_1'});
                    }

                    break;
                }
                case map.controls.PRINT_TYPE.PRINT:{
                    try{
	                    var img = canvas.toDataURL("image/png");
	                    //получаем элемент с линейкой масштаба
	                    var scaleLine = $('.ol-scale-line');
	                    var outerScaleHtml = '';
	                    if(scaleLine.length > 0)
		                    outerScaleHtml = scaleLine[0].outerHTML;
	                    var dsp = $('.map-dsp-label');
	                    var dspHtml = '';
	                    if(dsp.length > 0)
		                    dspHtml = dsp[0].outerHTML;
	                    //ie9 кидает ошибку,
	                    var ww = window.open('','','toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes');
	                    var resultHTML = '<head><meta http-equiv="X-UA-Compatible" content="IE=9" />' +
		                    '<link href="./css/print.css" rel="stylesheet"></head>' +
		                    '<body><input type="Button" onclick="window.print()" value="Печать"><br/>' +
		                    '<div style="position: relative;height:'+canvas.height+'px; width:'+canvas.width+'px;">'+
		                    outerScaleHtml+
		                    dspHtml+
		                    '<img style="height:'+canvas.height+'px; width:'+canvas.width+'px;" src="'+ img +'"/>'+
		                    '</div><br/>' +
		                    '<input type="Button" onclick="window.print()" value="Печать"></body>';
	                    ww.document.write(resultHTML);
	                    ww.document.close();//добавляем эту строку, чтобы в ie9 окошко для печати появлялось
	                    ww.focus();
                    }
                    catch(ex){
	                    BlockingUtil.ready();
	                    App.errorReport(gis_basecontrols_8, ex, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_2'});
                    }

                    break;
                }
            }

//            document.location.href = strData;//.replace("image/png", strDownloadMime);
        });
        WidgetMap.map.renderSync();
    }
};


map.controls.ExportImageControl.prototype.exportImage = function(canvas){
    var that = this;
    var currDialog = $('#exportImageDialog');
    if(currDialog.length >0){
        $('#exportImageDialog').dialog('open');
        return;
    }
    $('body').append('<div id="exportImageDialog" style="overflow: hidden"></div>');
    currDialog = $('#exportImageDialog');
    var dlg = currDialog;
    dlg.load('ui/html/map/ExportImageWithRotate.html', build);
    function build() {
        dlg.dialog({
            modal: false,
            title: gis_basecontrols_9,
            dialogClass: 'noCloseButton gsi-zindex__dialog',
            closeOnEscape: false,
            width: 325,
            height: 105,
            resizable: false
        });
        $('#exportImageRotateAngle').jqxNumberInput({ promptChar: "0", textAlign: "left",inputMode: 'simple',
            decimalDigits: 0, groupSeparator: "", disabled:false,spinButtons: false, min:0, max:360,spinButtonsStep:1,height: 22, width: 60});
        //кнопки "Сохранить", "Отмена"
        $('#exportImageSave').on('click',function(){
            try{
                var myImage = document.createElement("img");
                var elem = that.cloneContext_(canvas);
                myImage.onload = function () {
                    that.rotateImage_(elem,canvas,parseInt($('#exportImageRotateAngle').jqxNumberInput('val')));
                    myImage = null;
                    var strData =  elem.toDataURL('image/png');
                    strData = strData.replace("data:image/png;base64,",'');
                    var fileName = App.generateUUID() + ".png";
                    BlockingUtil.wait();
                    var requestCreateFileParams = map.controls.ExportImageControl.prototype.makeCreateImageReqParams(fileName, strData);
                    App.getJsonNode(Services.createImageNode, requestCreateFileParams
                        , function reqCreateFileResult(createResultXML) {
                            BlockingUtil.ready();
                            var er = HTTPServiceUtil.getError(createResultXML);
                            if(er !== ''){
                                App.errorReport(gis_basecontrols_8, er, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_3'});
                                return;
                            }
                            //открываем урл с изображением
                            //location.href = App.config.UPLOAD_PATH+that.screenUid_+".png";
                            BlockingUtil.ready();
                            var win = window.open(App.config.UPLOAD_PATH + fileName ,'_blank');
                            win.focus();
                        }
                        , function reqCreateFileFault(createFaultXML) {
                            BlockingUtil.ready();
                            var er = HTTPServiceUtil.getError(createFaultXML);
                            if(er !== ''){
                                App.errorReport(gis_basecontrols_8, er, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_4'});
                            }
                        });
                    $('#exportImageDialog').dialog('close');
                };
                myImage.src = canvas.toDataURL();
            }
            catch (ex){
                App.errorReport(gis_basecontrols_8, ex, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_7'});
            }

        });
        $('#exportImageCancel').on('click',function(){
            $('#exportImageDialog').dialog('close');
        });
    }

};

// Запрос создания на сервере файла GPX в указанной директории (экспорт из грида)
map.controls.ExportImageControl.prototype.makeCreateImageReqParams = function(fileName, content) {
    return {
        path: fileName,
        data: content
    };
};

// поворот на угол
map.controls.ExportImageControl.prototype.rotateImage_ = function(newCanvas, oldCanvas, degrees) {
    var context = newCanvas.getContext('2d');
    var radian = degrees*Math.PI/180;
    var newWidth= Math.sin(radian) * newCanvas.height + Math.cos(radian) * newCanvas.width;
    var newHeight = Math.sin(radian) * newCanvas.width + Math.cos(radian) * newCanvas.height;
    newCanvas.width = Math.abs(newWidth);
    newCanvas.height = Math.abs(newHeight);
    context.clearRect(0,0,newCanvas.width,newCanvas.height);
    context.save();
    context.translate(oldCanvas.width/2,oldCanvas.height/2);
    context.rotate(degrees*Math.PI/180);
    context.drawImage(oldCanvas,-oldCanvas.width/2,-oldCanvas.height/2);
    context.restore();
};

// поворот на угол
map.controls.ExportImageControl.prototype.cloneContext_ = function(canvas) {
    //create a new canvas
    var newCanvas = document.createElement('canvas');
    var context = newCanvas.getContext('2d');
    //set dimensions
    newCanvas.width = canvas.width;
    newCanvas.height = canvas.height;
    //apply the old canvas to the new one
    context.drawImage(canvas, 0, 0);
    return newCanvas;
};



/************CAS**************/
/**
 * Контрол "Экспорт в png"
 * @constructor
 */
map.controls.CASExportImageControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-image';

    var needExport = goog.isDef(options.needExport) ?
        options.needExport : true;
    var needPrint = goog.isDef(options.needPrint) ?
        options.needPrint : true;

    this.canvas1 = undefined;
    this.canvas2 = undefined;


    this.isVisible = false;



    var tooltipLabelPrint = goog.isDef(options.tooltipLabelPrint) ?
        options.tooltipLabelPrint : gis_basecontrols_10;
    this.innerElementPrint = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-print',
        'type' : 'button',
        'title' : tooltipLabelPrint
    });

    goog.events.listen(this.innerElementPrint,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASExportImageControl.prototype.handleExportImageClick_,map.controls.PRINT_TYPE.PRINT), false, this);


    var tooltipLabelExport = goog.isDef(options.tooltipLabelExport) ?
        options.tooltipLabelExport : gis_basecontrols_11;
    this.innerElementExport = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-export',
        'type' : 'button',
        'title' : tooltipLabelExport
    });

    goog.events.listen(this.innerElementExport,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASExportImageControl.prototype.handleExportImageClick_,map.controls.PRINT_TYPE.EXPORT), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element;
    if(!needExport) this.innerElementExport = undefined;
    if(!needPrint) this.innerElementPrint = undefined;
    if(!needExport && !needPrint) options.noElement = true;
    if(options.noElement)
        element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    else
        element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.innerElementPrint, this.innerElementExport);
    goog.base(this, {
        element: element,
        target: options.target
    });


    goog.base(this, {
        element: element,
        target: options.target
    });
};
goog.inherits(map.controls.CASExportImageControl, ol.control.Control);

/**
 * Скрыть/показать список кнопок
 * @param visible
 * @private
 */
map.controls.CASExportImageControl.prototype.setVisible_ = function(visible) {
    if(visible)
        $('.map-image').css('visibility','visible');
    else
        $('.map-image').css('visibility','hidden');
    this.isVisible = visible;
};

/**
 * Реакция на нажатие кнопки экспорта изображения
 * @private
 */
map.controls.CASExportImageControl.prototype.handleExportImageClick_ = function(type) {
    var that = this;
    this.canvas1 = undefined;
    this.canvas2 = undefined;
    if(goog.isDef(WidgetMap.exportImageChooserControl)){
		this.setVisible_(false);
		WidgetMap.exportImageChooserControl.changeExportImageType(type);
    }
    if(goog.isDefAndNotNull(WidgetMap.map) && goog.isDefAndNotNull(WidgetMap.lmap)){
        WidgetMap.map.once('postcompose', function(event) {
            that.canvas1 = event.context.canvas;
            switch(type){
                case map.controls.PRINT_TYPE.EXPORT:{
                    that.mergeCanvasesAndExport_();
                    break;
                }
                case map.controls.PRINT_TYPE.PRINT:{
                    that.mergeCanvasesAndPrint_();
                    break;
                }
            }
        });
        WidgetMap.lmap.once('postcompose', function(event) {
            that.canvas2  = event.context.canvas;
            switch(type){
                case map.controls.PRINT_TYPE.EXPORT:{
                    that.mergeCanvasesAndExport_();
                    break;
                }
                case map.controls.PRINT_TYPE.PRINT:{
                    that.mergeCanvasesAndPrint_();
                    break;
                }
            }
        });
        WidgetMap.map.renderSync();
        WidgetMap.lmap.renderSync();
    }
};


/**
 * Объединяем легенду с графиками для печати
 * @param canvas1 графики
 * @param canvas2 легенда
 * @private
 */
map.controls.CASExportImageControl.prototype.mergeCanvasesAndPrint_ = function(){
    if(goog.isDef(this.canvas1) && goog.isDef(this.canvas2)){
        var canvas1 = this.canvas1;
        var canvas2 = this.canvas2;
        // create new canvas
        var newCanvas = document.createElement('canvas');
        newCanvas.width = canvas1.width+canvas2.width ;
        newCanvas.height = canvas1.height ;
        var newCanvasCtx = newCanvas.getContext('2d');
        newCanvasCtx.drawImage(canvas2,0,0);
        newCanvasCtx.drawImage(canvas1,canvas2.width,0);
        var img = newCanvas.toDataURL("image/png");
        //получаем элемент с линейкой масштаба
        var dsp = $('.map-dsp-label');
        var casRouteName = $('#casRouteNameDiv');
        var casHtml = '';
        if(casRouteName.length > 0)
            casHtml = casRouteName[0].outerHTML;
        var dspHtml = '';
        if(dsp.length > 0)
            dspHtml = dsp[0].outerHTML;
        //ie9 кидает ошибку,
        var ww = window.open('','','toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes');
        var resultHTML = '<head><meta http-equiv="X-UA-Compatible" content="IE=9" />' +
            '<link href="./css/print.css" rel="stylesheet"></head>' +
            '<body><input type="Button" onclick="window.print()" value="Печать"><br/>' +
            //'<div style="position: relative;height:'+newCanvasCtx.height+'px; width:'+newCanvasCtx.width+'px;">'+
            '<div style="position: relative;height:100% width:100%">'+
            dspHtml+
            casHtml+
            '<img style="height:'+newCanvas.height+'px; width:'+newCanvas.width+'px;" src="'+ img +'"/>'+
            '</div><br/>' +
            '<input type="Button" onclick="window.print()" value="Печать"></body>';
        ww.document.write(resultHTML);
        ww.document.close();//добавляем эту строку, чтобы в ie9 окошко для печати появлялось
        ww.focus();
    }
};

/**
 * Объединяем легенду с графиками для печати
 * @param canvas1 графики
 * @param canvas2 легенда
 * @private
 */
map.controls.CASExportImageControl.prototype.mergeCanvasesAndExport_ = function(){
    if(goog.isDef(this.canvas1) && goog.isDef(this.canvas2)){
        var canvas1 = this.canvas1;
        var canvas2 = this.canvas2;
        // create new canvas
        var newCanvas = document.createElement('canvas');
        newCanvas.width = canvas1.width+canvas2.width ;
        newCanvas.height = canvas1.height ;
        var newCanvasCtx = newCanvas.getContext('2d');

        var casRouteName = $('#casRouteNameDiv');
        var casText = casRouteName.text();
        var yOffset = 0;
        if(casText.length > 0){
            newCanvasCtx.font="13px Arial";
            newCanvasCtx.fillText(casText,2,15);
            yOffset = 20;
        }
        newCanvasCtx.drawImage(canvas2,0,yOffset);
        newCanvasCtx.drawImage(canvas1,canvas2.width,yOffset);

        var strData =  newCanvas.toDataURL('image/png');
        strData = strData.replace("data:image/png;base64,",'');
        var fileName = App.generateUUID() + ".png";
        BlockingUtil.wait();
        var requestCreateFileParams = map.controls.ExportImageControl.prototype.makeCreateImageReqParams(fileName, strData);
        App.getJsonNode(Services.createImageNode, requestCreateFileParams
            , function reqCreateFileResult(createResultXML) {
                BlockingUtil.ready();
                var er = HTTPServiceUtil.getError(createResultXML);
                if(er !== ''){
                    App.errorReport(gis_basecontrols_8, er, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_5'});
                    return;
                }
                //открываем урл с изображением
                BlockingUtil.ready();
                var win = window.open(App.config.UPLOAD_PATH + fileName ,'_blank');
                win.focus();
            },
            function reqCreateFileFault(createFaultXML) {
                BlockingUtil.ready();
                var er = HTTPServiceUtil.getError(createFaultXML);
                if(er !== ''){
                    App.errorReport(gis_basecontrols_8, er, undefined, {filename:gis_filename_430, functionname:'gis_filename_430_6'});
                }
            });



        //получаем элемент с линейкой масштаба
        /*var dsp = $('.map-dsp-label');
        var casRouteName = $('#casRouteNameDiv');
        var casHtml = '';
        if(casRouteName.length > 0)
            casHtml = casRouteName[0].outerHTML;
        var dspHtml = '';
        if(dsp.length > 0)
            dspHtml = dsp[0].outerHTML;
        //ie9 кидает ошибку,
        var ww = window.open('','','toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes');
        var resultHTML = '<head><meta http-equiv="X-UA-Compatible" content="IE=9" />' +
            '<link href="./ui/print.css" rel="stylesheet"></head>' +
            '<body><input type="Button" onclick="window.print()" value="Печать"><br/>' +
            '<div style="position: relative;height:'+newCanvasCtx.height+'px; width:'+newCanvasCtx.width+'px;">'+
            dspHtml+
            casHtml+
            '<img style="height:'+newCanvas.height+'px; width:'+newCanvas.width+'px;" src="'+ img +'"/>'+
            '</div><br/>' +
            '<input type="Button" onclick="window.print()" value="Печать"></body>';
        ww.document.write(resultHTML);
        ww.document.close();//добавляем эту строку, чтобы в ie9 окошко для печати появлялось
        ww.focus();*/
    }
};

map.controls.CASExportImageControl.prototype.cloneContext_ = function(canvas) {
    //create a new canvas
    var newCanvas = document.createElement('canvas');
    var context = newCanvas.getContext('2d');
    //set dimensions
    newCanvas.width = canvas.width;
    newCanvas.height = canvas.height;
    //apply the old canvas to the new one
    context.drawImage(canvas, 0, 0);
    return newCanvas;
};
/***************END_CAS******************/

/**
 * Контрол слайдер для зуммирования
 * @constructor
 */
map.controls.ZoomSliderControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    var className = options.className ? options.className : 'ol-zoomslider';
    this.minElement = goog.dom.createDom('DIV', {
        'type': 'div',
        'class': className + '-min '
    });
    this.isMin = true;
    goog.base(this, {
        target: options.target
    });

};

goog.inherits(map.controls.ZoomSliderControl, ol.control.ZoomSlider);

/**
 * Handle dragger drag events.
 *
 * @param {goog.fx.DragEvent} event The drag event.
 * @private
 */
map.controls.ZoomSliderControl.prototype.handleDraggerDrag_ = function(event) {
	var relativePosition = this.getRelativePosition_(event.left, event.top);
	this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
};


/**
 * Handle dragger end events.
 * @param {goog.fx.DragEvent} event The drag event.
 * @private
 */
map.controls.ZoomSliderControl.prototype.handleDraggerEnd_ = function(event) {
	var map = this.getMap();
	var view = map.getView();
	view.setHint(ol.ViewHint.INTERACTING, -1);
	goog.asserts.assert(this.currentResolution_,
		'this.currentResolution_ should be defined');
	var resolution = view.constrainResolution(this.currentResolution_);
	view.setResolution(resolution);
};

/**
 * Форсируем смену позиции полунка при смене режимов карты
 * @private
 */
map.controls.ZoomSliderControl.prototype.forceSetThumbPosition = function() {
    try{
	    this.setThumbPosition_(this.currentResolution_);
    }
    catch(ex){}
};


map.controls.ZoomSliderControl.prototype.setMap = function(map) {
    if (this.map_) {
        goog.dom.removeNode(this.element);
    }
    if (this.listenerKeys.length > 0) {
        this.listenerKeys.forEach(goog.events.unlistenByKey);
        this.listenerKeys.length = 0;
    }
    this.map_ = map;
    if (this.map_) {
        var target = this.target_ ?
            this.target_ : map.getOverlayContainerStopEvent();
        goog.events.listen(this.minElement, goog.events.EventType.DBLCLICK,
            this.handleContainerDblClick_, false, this);
        target.appendChild(this.minElement);

        goog.events.listen(this.element, goog.events.EventType.DBLCLICK,
            this.handleContainerDblClick_, false, this);
        target.appendChild(this.element);

        if (this.render !== ol.nullFunction) {
            this.listenerKeys.push(goog.events.listen(map,
                ol.MapEventType.POSTRENDER, this.render, false, this));
        }
        map.render();
    }
};

map.controls.ZoomSliderControl.prototype.handleContainerDblClick_ = function () {
    if(this.isMin){
        $('.ol-zoomslider').show();
        $('.ol-zoomslider-min').hide();
        $('.ol-zoom-out').css('margin-top','212px');
    }else {
        $('.ol-zoom-out').css('margin-top','10px');
        $('.ol-zoomslider').hide();
        $('.ol-zoomslider-min').show();
    }
    this.isMin = !this.isMin;
};/**
 * Контрол для перемещения руков на карте
 * @constructor
 */
map.controls.ClearCosmeticControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ?
        options.className : 'map-cosmetic';

    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_basecontrols_12;
    var panElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className+ '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });


    goog.events.listen(panElement,
        goog.events.EventType.CLICK, this.handleCosmeticClick_, false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;

    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, panElement);
    }
    goog.base(this, {
        element: element,
        target: options.target
    });
};

goog.inherits(map.controls.ClearCosmeticControl, ol.control.Control);


/**
 * Реация на нажатие кнопки "Очистить косметический слой"
 * @private
 */
map.controls.ClearCosmeticControl.prototype.handleCosmeticClick_ = function() {
    BlockingUtil.wait();
    try{
        var cosmeticLayer = WidgetMap.layerManager.getLayerByName('COSMETIC_OBJECT');
        if(goog.isDef(cosmeticLayer) && goog.isDef(cosmeticLayer.layer)){
            cosmeticLayer.layer.featureProjLayer.getSource().getSource().clear();
        }
        if(goog.isDefAndNotNull(WidgetMap.currentVectorLayer))
            WidgetMap.currentVectorLayer.getSource().clear();
        MapUtil.clearSelectionLayer();
        if(goog.isDefAndNotNull(WidgetMap.findPathLayer))
            WidgetMap.findPathLayer.getSource().clear();
        if(goog.isDefAndNotNull(WidgetMap.findPathLineLayer))
            WidgetMap.findPathLineLayer.getSource().clear();
        if(goog.isDefAndNotNull(WidgetMap.bufferLayer))
            WidgetMap.bufferLayer.getSource().clear();

        if(goog.isDefAndNotNull(WidgetMap.pipeLengthLayer))
            WidgetMap.pipeLengthLayer.getSource().clear();
        //удалить interaction и выставить ладошку
        map.controls.PanControl.prototype.handlePanClick_();
    }
    catch(ex){

    }
    finally{
	    //обнуляем массив подписей, который прятали при выделении объектов
	    if (goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0) {
		    WidgetMap.map.render();
		    WidgetMap.hideLabelsArr = [];
	    }
        BlockingUtil.ready();
    }
};






goog.provide('map.controls.GeometryLoaderControl');



/**
 * Контрол для поиска маршрута
 * @constructor
 */
map.controls.GeometryLoaderControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	this.loadingText = goog.isDef(options.loadingText) ?
		options.loadingText : '';
	this.descrText = goog.isDef(options.descrText) ?
		options.descrText : gis_loadercontrol_2;
	this.loadingElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
		className : 'map-geometry-loader'

	}, null, this.loadingText);
	this.descrElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
		className : 'map-geometry-loader__descr'
	}, null, this.descrText);
	this.innerElement = goog.dom.createDom(goog.dom.TagName.DIV, null, this.loadingElement, this.descrElement);
	goog.base(this, {
		element: this.innerElement,
		target: options.target
	});
};
goog.inherits(map.controls.GeometryLoaderControl, ol.control.Control);

map.controls.GeometryLoaderControl.prototype.setVisible = function (renderVisible) {
	if(renderVisible) {
		if (!goog.isNull(this.map_)) {
			var target = !goog.isNull(this.target_) ?
				this.target_ : this.map_.getOverlayContainerStopEvent();
			goog.dom.appendChild(target, this.innerElement);
		}
		else
			goog.dom.removeNode(this.innerElement);
	}
	else
		goog.dom.removeNode(this.innerElement);
};
goog.provide('map.controls.DSPControl');
/**
 * Контрол для отображения надписи ДСП
 * @constructor
 */
map.controls.DSPControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    var dsp = undefined;
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    if(mapConfig){
        dsp = mapConfig.label;
    }
    var position = '';
    var dspLabel = '';
    if(dsp !== undefined){
        var top = (dsp.top !== undefined && dsp.top !== '')? 'top:'+dsp.top+'px;': '';
        var bottom = (dsp.bottom !== undefined && dsp.bottom !== '')? 'bottom:'+dsp.bottom+'px;': '';
        var left = (dsp.left !== undefined && dsp.left !== '')? 'left:'+dsp.left+'px;': '';
        var right = (dsp.right !== undefined && dsp.right !== '')? 'right:'+dsp.right+'px;': '';
        var fontSize = (dsp.font_size !== undefined && dsp.font_size !== '')? 'font-size:'+dsp.font_size+'px;': '11px;';
        var fontFamily = (dsp.font !== undefined && dsp.font !== '')? 'font-family:'+dsp.font+';': 'Verdana,Arial,sans-serif;';
        position = top+bottom+left+right+fontSize+fontFamily;
        dspLabel = dsp.text;
    }

    var innerElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
        'style' : position,
        className : 'map-dsp-label'

    }, null, dspLabel);
    dspLabel = dspLabel.replace(/\\n/g, "<br />");
    $(innerElement).html(dspLabel);

    goog.base(this, {
        element: innerElement,
        target: options.target
    });
};
goog.inherits(map.controls.DSPControl, ol.control.Control);


goog.provide('map.controls.MapInfoControl');


map.controls.requestFindInfId = "GAZPROM_SYS_SEM.xml#FIND_INF_IDS";

/**
 * Кнопка получения информации по объекту на карте
 * @param opt_options
 * @constructor
 */
map.controls.MapInfoControl = function (opt_options) {
	var options = goog.isDef(opt_options) ? opt_options : {};
	this.coordX;
	this.coordY;

	this.searchX;
	this.searchY;

	//начальное положение панели свойств
	this.ppanelPosition = [NaN, NaN];

	this.data_;

	//array of selected features
	this.overFeatures = [];

	this.lastXpx;
	this.lastYpx;

	//если был клик с ctrl для объединения массивов
	//последний клик с отжатием открывает панель свойств
	this.withCtrlBtn = false;
	//если использовался при поиске ctrl
	this.useCtrl = false;
	//Массив всех выбранных объектов
	this.infoArr = [];
	//Массив их координат
	this.infoCoordArr = [];


	//текущий выполняемый запрос
	this.curRequest = undefined;
	//массив ссылкок, которые подгружаются в данный момент
	this.cadastreUrls = [];
	//массив ссылок с идентификаторами которые ждут обработки
	this.cadastreFeatures = [];
	//справочники по атрибутам данных изх росрееестра
	this.COL_DICT = undefined;
	this.COL_DICT_loaded = false;//файл был однажды загружен и обработан, поэтому дальше не грузим
	this.cadastreError = '';// ошибки, возникшие при

	//адреса сервисов получения информации по росреестру
	this.cadastreFeatureUrl = undefined;
	this.useEmailCadastre = false;
	//флаг, прикреплять ли к письму доп. данные(скриншот и ФИО)
	this.useEmailCadastreFullAttach = false;

	this.mapInfoRadius = goog.isDef(options.mapInfoRadius) ?
		options.mapInfoRadius : 5;


	var className = goog.isDef(options.className) ?
		options.className : 'map-info';


	var tooltipLabel = goog.isDef(options.tooltipLabel) ?
		options.tooltipLabel : gis_mapinfocontrol_4;
	this.innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-button',
		'type': 'button',
		'title': tooltipLabel
	});
	var that = this;
	goog.events.listen(this.innerElement,
		goog.events.EventType.CLICK, this.handleMapInfoClick_, false, this);
	//TODO недо будет в нормальном виде листенер добавить
	$('body').on('keyup', function (event) {
		if (event.keyCode == 17)
			that.handleMapInfoKeyUp_(that);
	});
	/*goog.events.listen('body',
	 goog.events.EventType.KEYUP, goog.partial(
	 map.controls.MapInfoControl.prototype.handleMapInfoKeyUp_), false, this);*/

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;
	if (options.noElement) {
		var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
	} else {
		var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.innerElement);
	}
	goog.base(this, {
		element: element,
		target: options.target
	});
};
goog.inherits(map.controls.MapInfoControl, ol.control.Control);


/**
 * Реация на нажатие "Получить информацию"
 * @private
 */
map.controls.MapInfoControl.prototype.handleMapInfoClick_ = function () {
	if (WidgetMap.currentMapButtonState === WidgetMap.MAP_BUTTON_STATE.INFO) {
		WidgetMap.handleEscClick_();
		return;
	}

	this.checkCadastreTileLayer();

	//временная проверка, что работаем с ПКа
	if (!goog.isDef(WidgetMap.LINE_ID)) {
		map.controls.PanControl.prototype.handlePanClick_();
	} else {
		//удаляем сначала перемещение мышью
		WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
		WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);
	}
	this.searchX = undefined;
	this.searchY = undefined;
	this.coordX = undefined;
	this.coordY = undefined;
	WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.INFO;
	WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.INFO, this.innerElement);
	WidgetMap.map.un(ol.MapBrowserEvent.EventType.CLICK, this.mapClickHandler_, this);
	WidgetMap.map.on(ol.MapBrowserEvent.EventType.CLICK, this.mapClickHandler_, this);
};


/**
 * Проверка, является ли данны слой кадастровыми тайлами
 * @returns {boolean}
 * @private
 */
map.controls.MapInfoControl.prototype.checkCadastreTileLayer = function () {
	this.cadastreFeatureUrl = undefined;
	this.useEmailCadastre = false;
	this.useEmailCadastreFullAttach = false;
	var checkCadastre = false;
	if (WidgetMap.BaseLayersParser === undefined || WidgetMap.BaseLayersParser.currentBaseLayers === undefined) {
		return false;
	}
	//TODO забрать адрес из конфига
	//upd. 16.09.21 принято решение, что отправка писем будет зависеть только от  флага в настройках пользователя
	//а не от флага в подложке, чтобы была возможность с любой карты отправлять письма через рореестр
	//upd. 26.11.21 Принято решение хардкодить id слоя с кадастром, чтобы была возможность открывать
	if(WidgetMap.sendCadastreEmail) {
		var currBaseLayers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayersArray();
		for (var i in currBaseLayers) {
			if (currBaseLayers[i].get('id') === 'KADASTR' && currBaseLayers[i].getVisible()) {
				this.cadastreFeatureUrl = 'https://pkk.rosreestr.ru/api/features/';
				this.useEmailCadastre = true;
				this.useEmailCadastreFullAttach = true;
				return WidgetMap.sendCadastreEmail;
			}
		}
	}
	return false;
		/*
        for (var i in currBaseLayers) {
            var source = currBaseLayers[i].getSource();
            if (source instanceof map.source.OSMWebService && source.useEmail && currBaseLayers[i].getVisible()) {
                this.cadastreFeatureUrl = source.cadastreFeatureURL;
                this.useEmailCadastre = true;
                this.useEmailCadastreFullAttach = source.useEmailFullAttach;
                checkCadastre = true;
            }
        }
	return false;*/
};


/**
 * Реация на нажатие кнопки на клавиатуре
 * @private
 */
map.controls.MapInfoControl.prototype.handleMapInfoKeyUp_ = function (event) {
	if (WidgetMap.currentMapButtonState === WidgetMap.MAP_BUTTON_STATE.INFO) {
		this.withCtrlBtn = false;
		if (this.infoArr.length > 0) {
			this.showPropertyPanel_(this.infoArr);
		}
	}
};

map.controls.MapInfoControl.prototype.mapClickHandler_ = function (event) {
	if (WidgetMap.currentMapButtonState === WidgetMap.MAP_BUTTON_STATE.INFO) {
		this.withCtrlBtn = event.browserEvent.ctrlKey;
		var pointX = event.coordinate[0];
		var pointY = event.coordinate[1];
		this.coordX = event.pixel[0];
		this.coordY = event.pixel[1];
		if (goog.isDef(this.curRequest)) {
			this.curRequest.abort();
			this.curRequest = undefined;
			this.cadastreUrls = [];
			this.cadastreError = '';
		}
		this.checkCadastreTileLayer();
		this.startFindObjects_(pointX, pointY);
	}
};


map.controls.MapInfoControl.prototype.startFindObjects_ = function (pointX, pointY) {
	if (!(goog.isNumber(pointX) && goog.isNumber(pointY)))
		return;
	this.searchX = pointX;
	this.searchY = pointY;
	this.startFindCacheObjects_([]);
};


/**
 * Отправка письма для последующей обработки и пересылки результата на почту пользователя
 * @param arr
 * @private
 */
map.controls.MapInfoControl.prototype.sendEmailToRosreestr_ = function (userFIO, userMail, dateTime, arr) {
	var that = this;
	//собираем текст + картинку
	//грузим данные по пользователю

	//получаем картинку
	try {
		if (that.useEmailCadastreFullAttach) {
			WidgetMap.map.once('postcompose', function (event) {
				var canvas = event.context.canvas;
				try {
					var strData = canvas.toDataURL('image/png');
					strData = strData.replace("data:image/png;base64,", '');
					var screenUid = App.generateUUID();
					var fileName = screenUid + ".png";
					var requestCreateFileParams = map.controls.ExportImageControl.prototype.makeCreateImageReqParams(fileName, strData);
					App.getJsonNode(Services.createImageNode, requestCreateFileParams,
						function reqCreateFileResult(createResultXML) {
							var er = HTTPServiceUtil.getError(createResultXML);
							if (er !== '') {
								that.sendMail_(userFIO, userMail, dateTime, arr, '');
								return;
							}
							that.sendMail_(userFIO, userMail, dateTime, arr, screenUid);
						}
						, function reqCreateFileFault() {
							that.sendMail_(userFIO, userMail, dateTime, arr, screenUid);
						});
				} catch (ex) {
					that.sendMail_(userFIO, userMail, dateTime, arr, '');
				}
			});
			WidgetMap.map.renderSync();
		} else
			that.sendMail_(userFIO, userMail, dateTime, arr, '');
	} catch (ex) {
		that.sendMail_(userFIO, userMail, dateTime, arr, '');
	}

};


//Получаем данные о текущем пользователе (вместе с его ролями)
map.controls.MapInfoControl.prototype.getCurrentUserData_ = function (arr) {
	var that = this;
	var requestUserWithRole = "ADM_SEM.xml#WEB50_B_USER_PRIVATE";

	function getCurrentUserDataParams(request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() +
				'" USER_LOGIN="' + userLogin.xmlEscape() +
				'" PODS_USER="' + userLogin.xmlEscape() +
				'">' +
				'<data FILTER="' + ' d.USER_ID=' + userId + '" />' +
				'</root>'
		};
	}

	function getCurrentUserDataResult(resultXml) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if (er !== '') {
			App.errorReport(gis_mapinfocontrol_5, er, undefined, {
				filename: gis_filename_459,
				functionname: 'gis_filename_459_1'
			});
			that.startFindRasterObjects_(that.searchX, that.searchY, arr);
			return;
		}
		that.longStr = '';
		//делаем разбор пришедших данных и добавляем их в mailMessage.text
		var userFIO = '';
		var userMail = '';
		var d = new Date();
		var mm = d.getMonth() + 1;
		var curDateTimeStr = ((d.getDate() < 10) ? '0' + d.getDate() : d.getDate()) + '.'
			+ ((mm < 10) ? '0' + mm : mm) + '.'
			+ d.getFullYear() + '  '
			+ ((d.getHours() < 10) ? '0' + d.getHours() : d.getHours()) + ':'
			+ ((d.getMinutes() < 10) ? '0' + d.getMinutes() : d.getMinutes()) + ':'
			+ ((d.getSeconds() < 10) ? '0' + d.getSeconds() : d.getSeconds());
		var resultXml = ($.parseXML(resultXml)).firstChild;
		var datas = resultXml.getElementsByTagName("data");
		if (datas.length > 0) {
			var data = datas[0];
			var ln = goog.isNull(data.getAttribute("LASTNAME")) ? '' : data.getAttribute("LASTNAME");
			var fn = goog.isNull(data.getAttribute("FIRSTNAME")) ? '' : data.getAttribute("FIRSTNAME");
			var sn = goog.isNull(data.getAttribute("SECONDNAME")) ? '' : data.getAttribute("SECONDNAME");
			userFIO = ln + ' ' + fn + ' ' + sn;
			userMail = data.getAttribute("MAIL");
			if (!goog.isNull(userMail) && userMail !== '')
				that.sendEmailToRosreestr_(userFIO, userMail, curDateTimeStr, arr);
			else {
				App.errorReport(gis_mapinfocontrol_6, gis_mapinfocontrol_7, undefined, {
					filename: gis_filename_459,
					functionname: 'gis_filename_459_2'
				});
				that.startFindRasterObjects_(that.searchX, that.searchY, arr);
			}
			return;
		}
		App.errorReport(gis_mapinfocontrol_5, gis_mapinfocontrol_5, undefined, {
			filename: gis_filename_459,
			functionname: 'gis_filename_459_3'
		});
		//продолжаем поиск на карте
		that.startFindRasterObjects_(that.searchX, that.searchY, arr);
	}

	function getCurrentUserDataFault(resultXml) {
		BlockingUtil.ready();
		App.errorReport(gis_mapinfocontrol_5, resultXml, undefined, {
			filename: gis_filename_459,
			functionname: 'gis_filename_459_4'
		});
		//продолжаем поиск на карте
		that.startFindRasterObjects_(that.searchX, that.searchY, arr);

	}

	BlockingUtil.wait();
	App.serverQueryXML2Node(Services.processQueryNode, getCurrentUserDataParams(requestUserWithRole), getCurrentUserDataResult, getCurrentUserDataFault);

};

map.controls.MapInfoControl.prototype.sendMail_ = function (userFIO, userMail, dateTime, arr, screenUid) {
	var that = this;
	//продолжаем поиск на карте
	that.startFindRasterObjects_(that.searchX, that.searchY, arr);

	function sendMailResult(resultXml) {
		var er = HTTPServiceUtil.getError(resultXml);
		if (er !== '') {
			App.errorReport(gis_mapinfocontrol_8 + gis_mapinfocontrol_9, resultXml, undefined, {
				filename: gis_filename_459,
				functionname: 'gis_filename_459_5'
			});
		}
	}

	function sendMailFault(resultXml) {
		App.errorReport(gis_mapinfocontrol_8 + gis_mapinfocontrol_9, resultXml, undefined, {
			filename: gis_filename_459,
			functionname: 'gis_filename_459_6'
		});
	}

	var center = GeoUtil.convertCoords([this.searchX, this.searchY], WidgetMap.DEFAULT_PROJECTION, GeoUtil.PROJS.WGS84);
	var zoom = WidgetMap.map.getView().getZoom();
	var tolerance = that.getToleranceByZoom_(zoom);
	var centerStr = ('' + center[1]).replace('.', ',') + ' ' + ('' + center[0]).replace('.', ',');
	var addText = 'text=' + centerStr + '&tolerance=' + tolerance + '&limit=2';
	var sendMailMessage = '';
	//20.09.17 из-за частых блокировок росреестра множественных запросов решено оставить только земельные участки и кадастровые кварталы
	/*if (this.zouitFeatureUrl != '')
	 sendMailMessage += '<url>' + this.zouitFeatureUrl + '10?' + addText + '</url>';*/
	if (this.cadastreFeatureUrl !== undefined && this.cadastreFeatureUrl !== '') {
		sendMailMessage += '<url>' + this.cadastreFeatureUrl + '1?' + addText + '</url>' +
			'<url>' + this.cadastreFeatureUrl + '2?' + addText + '</url>';
	} else {
		that.startFindRasterObjects_(that.searchX, that.searchY, arr);
		return;
	}

	sendMailMessage += '<EMAIL>' + userMail + '</EMAIL>';
	var fileName = '';
	if (screenUid !== '')
		fileName = App.config.UPLOAD_PATH + screenUid + '.png';
	if (!that.useEmailCadastreFullAttach)
		userFIO = gis_mapinfocontrol_10;
	App.getJsonTextNode(Services.sendMailNode, {
		addMailTo: goog.isDef(App.config.ROSREESTR_POP3_EMAIL) ? App.config.ROSREESTR_POP3_EMAIL : 'rosreestr@corelight.ru',
		subject: userFIO + '|' + dateTime,//ФИО|DATE , upd 08.11.17 - убираем ФИО  и добавляем флаг
		fileName1: fileName,
		isBodyHtml: false,
		message: sendMailMessage,
		to: goog.isDef(App.config.ROSREESTR_POP3_EMAIL) ? App.config.ROSREESTR_POP3_EMAIL : 'rosreestr@corelight.ru'
	}, sendMailResult, sendMailFault);
};


map.controls.MapInfoControl.prototype.startFindRasterObjects_ = function (pointX, pointY, arr) {
	var that = this;
	var currArr = arr;
	//если выставлен флаг не показывать подложку
	if (WidgetMap.config !== undefined && WidgetMap.config.showInfo === false) {
		this.showPropertyPanel_(currArr);
		return;
	}

	//сначала собираем все растровые слои
	var layers = WidgetMap.layerManager.getAllVisibleInScaleSortedRasterLayers();//getAllVisibleInScaleRasterLayers();
	var resultRasterLayers = [];
	//если в подложке выставлен флаг showInfo=false, то ищем пересечения с теми, которые можно показывать
	//добавляем в массив видимые слои, смотрим у них доступные группы(M_1,M_R,...)
	if (WidgetMap.baseLayersControl !== undefined && WidgetMap.BaseLayersParser !== undefined && WidgetMap.BaseLayersParser.currentBaseLayers !== undefined) {
		var bLayers = WidgetMap.BaseLayersParser.currentBaseLayers.getLayers(); //of ol.Group
		var bVisibleLayers = [];
		bLayers.forEach(//ol.Collection
			/**
			 * @param {ol.layer.Layer} layer Layer.
			 */
			function (layer) {
				if (layer.getVisible()) {
					try {
						for (var el in WidgetMap.BaseLayersParser.rasterLayers) {
							var rasterLayersObjs = WidgetMap.BaseLayersParser.rasterLayers[el].baselayerscontrolarray;
							for (var r = 0; r < rasterLayersObjs.length; r++) {
								if (layer.get('id') !== undefined && rasterLayersObjs[r].id === layer.get('id')) {
									bVisibleLayers = bVisibleLayers.concat(rasterLayersObjs[r].layers);
									break;
								}
							}
						}
					} catch (ex) {
					}
				}
			}, this);
	}

	// по условию нахождения в bVisibleLayers добавляем в финальную выборку слои
	layers.forEach(//ol.Collection
		/**
		 * @param {ol.layer.Layer} layer Layer.
		 */
		function (layer) {
			if (bVisibleLayers.indexOf(layer.modelName) != -1)
				resultRasterLayers.push(layer);
		}, this);


	if (resultRasterLayers.length > 0 || WidgetMap.isBaseLayerRosreestr) {
		var mapDescr = '<DRAWLAYERS>';
		for (var i = 0; i < layers.length; i++) {
			//если режим векторный, проверям, находится ли слой в векторных слоях, если находится,
			// то не запрашиваем, как растровый
			if (WidgetMap.CURRENT_MODE === WidgetMap.MODES.VECTOR) {
				var vecLayer = WidgetMap.layerManager.getVectorLayerByName(layers[i].id)
				if (vecLayer !== undefined)
					continue;
			}
			if (!layers[i].visible)
				continue;
			var currLayer = layers[i].layer;
			/* as map.layer.*/
			mapDescr += currLayer.toXML();
		}
		mapDescr += '</DRAWLAYERS>';
		var mapSize = WidgetMap.map.getSize();
		var leftTop = WidgetMap.map.getCoordinateFromPixel([0, 0]);

		var rightBottom = WidgetMap.map.getCoordinateFromPixel([mapSize[0], mapSize[1]]);
		var vSearchRad = 5;
		var source = new proj4.Proj(GeoUtil.PROJS.WGS84);
		var dest = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
		var cp = new proj4.toPoint([leftTop[0], leftTop[1]]);
		proj4.transform(dest, source, cp);

		var cp1 = new proj4.toPoint([rightBottom[0], rightBottom[1]]);
		proj4.transform(dest, source, cp1);

		var cp2 = new proj4.toPoint([pointX, pointY]);
		proj4.transform(dest, source, cp2);

		if (App.projection === GeoUtil.PROJS.Pulkovo42) {
			var p42WgsPnt = GeoUtil.WGSP42(cp.y, cp.x);
			cp = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);

			p42WgsPnt = GeoUtil.WGSP42(cp1.y, cp1.x);
			cp1 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);

			p42WgsPnt = GeoUtil.WGSP42(cp2.y, cp2.x);
			cp2 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
		}

		if (goog.isDefAndNotNull(this.mapInfoRadius))
			vSearchRad = this.mapInfoRadius;
		vSearchRad = vSearchRad * (cp1.x - cp.x) / mapSize[0];

		var reqParams = this.getReqParams_(cp2.x, cp2.y, vSearchRad, mapDescr);
		BlockingUtil.wait();
		App.serverQueryXMLWithTries(Services.mapInfoService, reqParams, function (resultXml) {
			BlockingUtil.ready();
			that.result_(resultXml, currArr);
		}, function (resultXml) {
			BlockingUtil.ready();
			that.fault_(resultXml, currArr);
		},4);
	} else {
		this.showPropertyPanel_(currArr);
	}
};

map.controls.MapInfoControl.prototype.startFindVectorObjects_ = function (arr) {
	//ищем вектор
	if (goog.isDef(WidgetMap.currentVectorGroupLayer)) {
		var vSearchRad = 5;
		if (goog.isDefAndNotNull(this.mapInfoRadius))
			vSearchRad = this.mapInfoRadius;
		//calculate bounds
		//`[minx, miny, maxx, maxy]`.
		var lastPx = [this.coordX, this.coordY];
		var leftBottom = WidgetMap.map.getCoordinateFromPixel([lastPx[0] - vSearchRad, lastPx[1] - vSearchRad]);
		var rightTop = WidgetMap.map.getCoordinateFromPixel([lastPx[0] + vSearchRad, lastPx[1] + vSearchRad]);

		//TODO добавить проверку на видимость в масштабе слоя
		var layers = WidgetMap.currentVectorGroupLayer.getLayersArray();
		// видимость слоя в масштабе
		var filteredMapLayersArray = [];
		var tt;
		for (tt in layers) {
			if (WidgetMap.map.getView().getResolution() <= layers[tt].get('maxResolution') && WidgetMap.map.getView().getResolution() >= layers[tt].get('minResolution') && layers[tt].get('visible') == true)
				filteredMapLayersArray.push(layers[tt]);
		}
		var resVectorArr = [];
		var findedObjects = [];
		var overFeatures = [];
		var of, t;
		for (of in filteredMapLayersArray) {
			var lId = filteredMapLayersArray[of].get('id');
			var layer = WidgetMap.layerManager.getLayerByName(lId);
			if (goog.isDef(lId) && goog.isDef(layer) && goog.isDef(layer.layer) && layer.layer.type != 'system') {
				overFeatures.push(filteredMapLayersArray[of]);
			}
		}
		var ext = [leftBottom[0], rightTop[1], rightTop[0], leftBottom[1]];
		for (t in overFeatures) {
			overFeatures[t].getSource().getSource().forEachFeatureIntersectingExtent(ext, function (feature) {
				findedObjects = findedObjects.concat(GeoUtil.getIntersectedGeometry(feature, ext));
			});
		}
		var curFeature;
		var k;
		for (k in findedObjects) {
			var obj = {};
			curFeature = findedObjects[k].feature;
			var objId = findedObjects[k].id
			var isSemanticId = false;//случай составного id для техсхемы кап ремонтов
			if (objId === undefined)
				continue;
			if(objId.indexOf('|') !== -1){//комбинированный случай, техсхема и слой ремонты КПГ
				objId = objId.split('|')[1];
				isSemanticId = true;
			}
			var layName = curFeature.get('layerId');
			var layType = curFeature.get('type');
			var typeStr = '';
			if (layType.indexOf('#') != -1) {
				var splitted = layType.split('#');
				layType = splitted[0];
				if (splitted.length > 1) {
					var sp = splitted[1].split('_');
					if (sp.length > 1) {
						//удаляем 0-й элемент, т.к. id, а остальные элементы массива - имя типа
						sp.splice(0, 1);
						typeStr = '_' + sp.join('_');
						layType += typeStr;
					}
				}
			}
			//TODO переписать логику
			var objectStyle = WidgetMap.layerManager.getStyleByName(layType);
			var layObj = WidgetMap.layerManager.getLayerByName(layName);
			var skip = false;
			var isCasLayer = false;

			if (layObj && layObj.layer) {// layObj.layer instanceof map.layer.CASLayer
				try {
					goog.asserts.assertInstanceof(layObj.layer, map.layer.CASLayer,
						'layer must be an map.layer.CASLayer instance');
					isCasLayer = true;
				} catch (ex) {
					isCasLayer = false;
				}
				//upd 23.10.20  Если слой тех схемы, то объект пытаемся показать. Далее сделать и для обычной карты. Регулировку показа панели свойств оставить на *layers.xml, атрибут type
				if (GeoUtil.PROJS['EPSG:5807'] !== WidgetMap.DEFAULT_PROJECTION || isCasLayer) {
					//если нет семантики, слой игнорируем
					if (goog.isDef(layObj.layer.dataProvider) && goog.isDef(layObj.layer.dataProvider.semantic) &&
						layObj.layer.dataProvider.semantic !== '') {
						//получаем стиль. если он не найден - игнорируем объект
						if (goog.isNull(objectStyle)) {
							objectStyle = WidgetMap.layerManager.getStyleByName(layObj.layer.name);
							if (goog.isNull(objectStyle)) {
								if (goog.isDef(layObj.layer.dataProvider) && goog.isDef(layObj.layer.dataProvider.style)) {
									objectStyle = WidgetMap.layerManager.getStyleByName(layObj.layer.dataProvider.style + typeStr);
									if (goog.isNull(objectStyle)) {
										objectStyle = WidgetMap.layerManager.getStyleByName(layObj.layer.dataProvider.style);
										if (goog.isNull(objectStyle))
											continue;
									}
								} else
									continue;
							}
						}
					} else
						skip = true;
				}
			}
			if (!skip) {
				if (layName.indexOf('#') != -1) {
					layName = layName.split('#')[0];
				}
				var geo = findedObjects[k].geo;
				if(isSemanticId){
					//geo = layObj.layer.getFull
					//geo = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(layObj.layer, [objId]);
					geo = undefined;
				}

				obj['id'] = layName + ':' + objId;
				obj['uniqueLayerName'] = curFeature.get('layerId');
				obj['USER_LAYER_NAME'] = layName;
				obj['ID'] = objId;
				obj['label'] = (goog.isDef(layObj)) ? layObj.layer.sourceDescr : layName;
				obj['geo'] = geo;
				obj['mapOrder'] = layObj.layer.mapOrder;
				obj['order'] = layObj.layer.order;
				if (layName === 'COSMETIC_OBJECT' && !goog.isNull(findedObjects[k].label)) {
					obj['LABEL'] = findedObjects[k].label;
				}
				resVectorArr.push(obj);
			}

		}
		//сортируем
		// generic comparison function
		var cmp = function (x, y) {
			return x > y ? 1 : x < y ? -1 : 0;
		};

		//sort name ascending then id descending
		resVectorArr = resVectorArr.sort(function (a, b) {
			//note the minus before -cmp, for descending order
			return cmp(
				[-cmp(a.mapOrder, b.mapOrder), cmp(a.order, b.order)],
				[-cmp(b.mapOrder, a.mapOrder), cmp(b.order, a.order)]
			);
		});
		if (resVectorArr.length > 0) {
			arr = resVectorArr.concat(arr);
		}

	}
	//пока ищем буфер
	if (goog.isDef(WidgetMap.bufferLayer)) {
		var vSearchRad = 5;
		if (goog.isDefAndNotNull(this.mapInfoRadius))
			vSearchRad = this.mapInfoRadius;
		//calculate bounds
		//`[minx, miny, maxx, maxy]`.
		var resArr = [];
		layName = 'COSMETIC_OBJECT';
		var leftBottom = /*WidgetMap.map.getCoordinateFromPixel(*/[this.searchX - vSearchRad, this.searchY - vSearchRad]/*)*/;
		var rightTop = /*WidgetMap.map.getCoordinateFromPixel(*/[this.searchX + vSearchRad, this.searchY + vSearchRad]/*)*/;
		var features = WidgetMap.bufferLayer.getSource().getFeaturesInExtent([leftBottom[0], leftBottom[1], rightTop[0], rightTop[1]]);
		for (var i in features) {
			var obj = {};
			var id = features[i].getId();
			if (!goog.isDef(features[i].get('labelType')))
				features[i].set('labelType', 'COSMETIC_OBJECT');
			var objs = GeoUtil.getIntersectedGeometry(features[i], [leftBottom[0], leftBottom[1], rightTop[0], rightTop[1]]);
			for (var t in objs) {
				obj['id'] = layName + ':' + objs[t].id;
				obj['USER_LAYER_NAME'] = layName;
				obj['ID'] = objs[t].id;
				obj['label'] = gis_mapinfocontrol_11;
				obj['geo'] = objs[t].geo;
				obj['LABEL'] = objs[t].label;
				resArr.push(obj);
			}
			/*obj['id'] = id;
			 obj['USER_LAYER_NAME'] = id.split(':')[0];
			 obj['ID'] = id.split(':')[1];
			 obj['label'] = 'Объект косметического слоя';
			 obj['geo'] = features[i].clone();
			 //obj['LABEL'] = findedObjects[k].label;
			 resArr.push(obj);*/
		}
		if (resArr.length > 0) {
			resArr = resArr.concat(arr);
			return resArr;
		}
	}
	return arr;
};


map.controls.MapInfoControl.prototype.startFindCacheObjects_ = function (arr) {
	if (!(goog.isNumber(this.searchX) && goog.isNumber(this.searchY)))
		return;
	//сначала собираем все растровые слои
	var isBaseLayerCadastre = WidgetMap.isBaseLayerCadastre;
	//isBaseLayerCadastre = true 
	if (!goog.isDefAndNotNull(arr))
		arr = [];
	if (!goog.isDef(App.config.ROSREESTR_URL) || (goog.isDef(App.config.ROSREESTR_URL) && App.config.ROSREESTR_URL.length == 0))
		isBaseLayerCadastre = false;
	if (this.useEmailCadastre) {
		if (WidgetMap.sendCadastreEmail)
			this.getCurrentUserData_(arr);
		else this.startFindRasterObjects_(this.searchX, this.searchY, arr);
	} else if (isBaseLayerCadastre)
		//this.startFindCadastreObjectsJSON_(this.searchX, this.searchY, arr);
		this.preloadCAD_NUM_XML_(this.searchX, this.searchY, arr);
	else
		this.startFindRasterObjects_(this.searchX, this.searchY, arr);
};


map.controls.MapInfoControl.prototype.getReqParams_ = function (x, y, radius, mapDescr) {
	var userId = Auth.getUid();
	return {
		user_uid: userId,
		x: x,
		y: y,
		radius: radius,
		mapDescr: mapDescr
	};
};

map.controls.MapInfoControl.prototype.result_ = function (resultXml, currArr) {
	var er = HTTPServiceUtil.getError(resultXml);
	if (er !== '') {
		this.showPropertyPanel_(currArr, er);
		//пробуем выставить стиль кнопки панели свойств в красный цвет и текстом с ошибкой
		//App.errorReport(gis_mapinfocontrol_1, er, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_7'});
	} else {
		var layerGeoXml = ($.parseXML(resultXml)).firstChild;
		var datas = layerGeoXml.getElementsByTagName("OBJECT");
		var arr = [];
		for (var i = 0; i < datas.length; i++) {
			var obj = {};
			var attrNamesList = datas[i].attributes;
			for (var j = 0; j < attrNamesList.length; j++) {
				var nodeName = attrNamesList[j].nodeName;
				var nodeValue = attrNamesList[j].nodeValue;
				if (nodeName === 'USER_LAYER_NAME') {
					obj[nodeName] = nodeValue;
					obj['label'] = nodeValue;// для панели свойств
				}
				if (nodeName === 'ID')
					obj[nodeName] = nodeValue;
			}
			obj['id'] = obj.USER_LAYER_NAME + ':' + obj.ID;
			var layerObj = WidgetMap.layerManager.getLayerByName(obj.USER_LAYER_NAME);
			if (goog.isDef(layerObj) && goog.isDef(layerObj.layer))
				obj['label'] = layerObj.layer.sourceDescr;
			else
				obj['label'] = obj.USER_LAYER_NAME;
			//добавляем проверку на cover и system
			if (layerObj.layer.type != 'system' && layerObj.layer.showInfo != 'false') {
				arr.push(obj);
			}
			if (layerObj.layer.cover == 'true') {
				var finalArr = currArr.concat(arr);
				this.showPropertyPanel_(finalArr);
				return;
			}
		}
		var finalArr = currArr.concat(arr);
		this.showPropertyPanel_(finalArr);
	}
};


map.controls.MapInfoControl.prototype.fault_ = function (resultXml, currArr) {
	//upd. 02.20.20 принято решение, в случае ошибки получения информации по подложке карты не отображать отдельным окном
	// и по вохможности выделить красным правую кнопку переключения на след. объект с тултипом с текстом ошибки
	var er = HTTPServiceUtil.getError(resultXml);
	/*if (er !== '')
		App.errorReport(gis_mapinfocontrol_1, er, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_8'});*/
	this.showPropertyPanel_(currArr, er);
};


/**
 * Подгружаем файл с расшифровкой атрибутов и значения из справочников
 * @param pointX
 * @param pointY
 * @param arr
 * @private
 */
map.controls.MapInfoControl.prototype.preloadCAD_NUM_XML_ = function (pointX, pointY, arr) {
	var that = this;
	if (this.COL_DICT_loaded) {
		that.startFindCadastreObjectsJSON_(pointX, pointY, arr);
		return;
	}
	function getLayersReqParams(fileName) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

		return {
			descrId: 'SYS_SEM.xml#GET_XML_FILE',
			descrType: 'select',
			data: '<root USER_ID="1045" USER_LOGIN="' + userLogin + '" PODS_USER="' + userId + '">' +
				'<data FILE="../../Public/Data/ROSREESTR/' + fileName + '"/>' +
				'</root>'
		};
	}

	function getPreloadResult(resultXml) {
		that.COL_DICT_loaded = true;
		var er = HTTPServiceUtil.getError(resultXml);
		if (er != "")
			that.startFindCadastreObjectsJSON_(pointX, pointY, arr);
		else {
			var value = ($.parseXML(resultXml)).firstChild;
			var zu = $(value).children('zu');
			var cad_kvartal = $(value).children('cad_kvartal');
			var cad_rayon = $(value).children('cad_rayon');
			var cad_okrug = $(value).children('cad_okrug');
			var zouit = $(value).children('zouit');
			var area_types = $(value).children('area_types');
			var unit_types = $(value).children('unit_types');
			var classid_types = $(value).children('classid_types');
			if (zu.length > 0 || cad_kvartal.length > 0 || cad_rayon.length > 0 || cad_okrug.length > 0 || zouit.length > 0 || area_types.length > 0 || unit_types.length > 0 || classid_types.length > 0)
				that.COL_DICT = {};
			if (zu.length > 0) that.COL_DICT.zu = {};
			if (cad_kvartal.length > 0) that.COL_DICT.cad_kvartal = {};
			if (cad_rayon.length > 0) that.COL_DICT.cad_rayon = {};
			if (cad_okrug.length > 0) that.COL_DICT.cad_okrug = {};
			if (zouit.length > 0) that.COL_DICT.zouit = {};
			if (area_types.length > 0) that.COL_DICT.area_types = {};
			if (unit_types.length > 0) that.COL_DICT.unit_types = {};
			if (classid_types.length > 0) that.COL_DICT.classid_types = {};
			var k;
			var cols = zu.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.zu[name] = value
			}
			cols = cad_kvartal.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.cad_kvartal[name] = value
			}
			cols = cad_rayon.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.cad_rayon[name] = value
			}
			cols = cad_okrug.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.cad_okrug[name] = value
			}
			cols = zouit.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.zouit[name] = value
			}
			cols = area_types.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.area_types[name] = value
			}
			cols = unit_types.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.unit_types[name] = value
			}
			cols = classid_types.children();
			for (k = 0; k < cols.length; k++) {
				//проходимся по всем и выбираем только файлы стилей, а не запросы
				var col = cols[k];
				var name = $(col).attr('name');
				var value = $(col).attr('value');
				that.COL_DICT.classid_types[name] = value
			}
			that.startFindCadastreObjectsJSON_(pointX, pointY, arr);
		}
	}

	function getPreloadFault() {
		that.COL_DICT_loaded = true;
		that.startFindCadastreObjectsJSON_(pointX, pointY, arr);
	}

	App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getLayersReqParams("COL_DICT.xml"), getPreloadResult, getPreloadFault);
};


map.controls.MapInfoControl.CADASTRE_INFO_URL = '';//'http://pkk5.rosreestr.ru/api/features/';
// •	1 - Земельные участки
// •	2 - Кварталы
// •	3 - Районы
// •	4 - Округи
// •	5 - ОКСы
// •	6 - Тер.зоны
// •	7 - Границы
// •	9 - ОМС
// •	10 - ЗОУИТы
// •	12 - Лесничества и лесопарки


map.controls.MapInfoControl.prototype.startFindCadastreObjectsJSON_ = function (pointX, pointY, arr) {
	var that = this;
	if (!(goog.isNumber(pointX) && goog.isNumber(pointY)))
		return;
	this.searchX = pointX;
	this.searchY = pointY;
	//получили группу
	var currBaseLayer = WidgetMap.BaseLayersParser.currentBaseLayers.getLayersArray();
	//преобразовываем точки в wgs
	var wgsPoint = GeoUtil.convertCoords([pointX, pointY], WidgetMap.DEFAULT_PROJECTION, GeoUtil.PROJS.WGS84);
	this.cadastreUrls = [];
	for (var i in currBaseLayer) {
		var cadastreLayer = currBaseLayer[i].getSource();
		if (goog.isDef(cadastreLayer.getGetFeatureInfoUrl)) {
			if (goog.isDef(App.config.ROSREESTR_URL) && App.config.ROSREESTR_URL.length > 0)
				map.controls.MapInfoControl.CADASTRE_INFO_URL = App.config.ROSREESTR_URL;
			//20.09.17 решено включать в получение информации только кварталы и земельные участки, чтобы меньше шансов быть забаненными
			/*if (cadastreLayer.restURL_.indexOf('ZONES') != -1)
			 this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '10');
			 else {*/
			this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '1');
			this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '2');
			/*this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '3');
			 this.cadastreUrls.push(map.controls.MapInfoControl.CADASTRE_INFO_URL + '4');
			 }*/
		}
	}
	that.loadCadastreJSON(wgsPoint, arr);
};

/**
 * Результат запроса к кадастру через новове api
 * @param res
 * @param arr
 * @private
 */
map.controls.MapInfoControl.prototype.resultCadastreJSON_ = function (res, center, url, arr) {
	var that = this;
	if (goog.isDef(res) && goog.isDef(res.features) && res.features.length > 0) {
		that.cadastreFeatures = res.features;
		this.loadCadastreFeatureJSON(url, center, arr);
	} else
		this.loadCadastreJSON(center, arr);
};


map.controls.MapInfoControl.prototype.loadCadastreFeatureJSON = function (url, center, arr) {
	var that = this;
	if (that.cadastreFeatures.length > 0) {
		var feature = that.cadastreFeatures[0];
		that.cadastreFeatures.splice(0, 1);
		if (goog.isDef(feature.attrs) && goog.isDef(feature.attrs.id)) {
			this.curRequest = App.serverQueryCadastreJSON(url + '/' + feature.attrs.id,
				function (resultJSON) {
					BlockingUtil.ready();
					that.resultCadastreJSONObject_(resultJSON, url, center, arr);
				}, function (result) {
					if (goog.isDef(result) && that.cadastreError == '')
						that.cadastreError = result;
					BlockingUtil.ready();
					//если есть ещё фичи, то их продолжаем обрабатывать
					if (that.cadastreFeatures.length > 0)
						that.loadCadastreFeatureJSON(url, center, arr);
					else
						that.loadCadastreJSON(center, arr);
				},4);
			return;
		}
		if (that.cadastreFeatures.length > 0)
			that.loadCadastreFeatureJSON(url, center, arr);
		else
			that.loadCadastreJSON(center, arr);
	} else {
		that.loadCadastreJSON(center, arr);
	}


};

/**
 * Результат запроса к кадастру - получение данных по объекту
 * @param res
 * @param arr
 * @private
 */
map.controls.MapInfoControl.prototype.resultCadastreJSONObject_ = function (res, url, center, arr) {
	var that = this;
	if (goog.isDef(res) && goog.isDef(res.feature)) {
		var feature = res.feature;
		if (goog.isDef(feature.attrs) && goog.isDef(feature.attrs.id) && goog.isDef(feature.type)) {
			//обабатываем
			var label = '';
			var fullId = '';
			if (feature.type == 4) {//кадастровый округ
				label = gis_mapinfocontrol_15;
				fullId = 'CADASTRE_DISTRICT_JSON';
			}
			if (feature.type == 3)//кадастровый район
			{
				label = gis_mapinfocontrol_16;
				fullId = 'CADASTRE_RAYON_JSON';
			}
			if (feature.type == 2)//кадастровый квартал
			{
				label = gis_mapinfocontrol_17;
				fullId = 'CADASTRE_KVARTAL_JSON';
			}
			if (feature.type == 1)//земельный участок
			{
				label = gis_mapinfocontrol_18;
				fullId = 'CADASTRE_PARCEL_JSON';
			}
			if (feature.type == 10)//ЗОУИТ
			{
				label = gis_mapinfocontrol_19;
				fullId = 'CADASTRE_ZOUIT_JSON';
			}
			var resultAttrs = [];
			var obj = {};
			obj.CODE = 'ID';
			obj.DESCR = feature.attrs.id;
			resultAttrs.push(obj);
			for (var attr in feature.attrs) {
				if (attr == 'json_documents')
					continue;
				obj = {};
				if (attr == 'cad_eng_data') {
					if (goog.isNull(feature.attrs[attr]))
						continue;
					obj.CODE = attr;
					obj.DESCR = feature.attrs[attr]['co_name'];
					resultAttrs.push(obj);
					continue;
				}
				var nodeName = that.replaceAttr(feature.type, attr);
				var nodeValue = feature.attrs[attr];
				if (nodeName == 'id') {
					//obj.CODE = 'ID';
					fullId += ':' + nodeValue;
					continue;
				} else {
					obj.CODE = nodeName;//map.controls.MapInfoControl.transliterate(nodeName);
				}
				obj.DESCR = that.replaceValue(nodeName, nodeValue);
				resultAttrs.push(obj);
			}
			arr.push({label: label, id: fullId, attrs: resultAttrs});
		}
	}
	if (that.cadastreFeatures.length > 0)
		that.loadCadastreFeatureJSON(url, center, arr);
	else
		that.loadCadastreJSON(center, arr);
};
/*замена значения из справочника*/
map.controls.MapInfoControl.prototype.replaceValue = function (attrName, value) {
	var resValue = value;
	if (goog.isDef(this.COL_DICT) && value != '') {
		switch (attrName) {
			case 'util_code':
				if (goog.isDef(this.COL_DICT.classid_types) && goog.isDef(this.COL_DICT.classid_types[value]))
					resValue = this.COL_DICT.classid_types[value];
				break;
			case 'area_type':
				if (goog.isDef(this.COL_DICT.area_types) && goog.isDef(this.COL_DICT.area_types[value]))
					resValue = this.COL_DICT.area_types[value];
				break;
			case 'area_unit':
			case 'cad_unit':
				if (goog.isDef(this.COL_DICT.unit_types) && goog.isDef(this.COL_DICT.unit_types[value]))
					resValue = this.COL_DICT.unit_types[value];
				break;
		}
	}
	return resValue;
};
/*замена названия из справочника*/
map.controls.MapInfoControl.prototype.replaceAttr = function (type, attr) {
	var resAttr = attr;
	if (goog.isDef(this.COL_DICT)) {
		if (type == 10 && goog.isDef(this.COL_DICT.zouit) && goog.isDef(this.COL_DICT.zouit[attr]) && this.COL_DICT.zouit[attr] != '')
			resAttr = this.COL_DICT.zouit[attr];
		if (type == 1 && goog.isDef(this.COL_DICT.zu) && goog.isDef(this.COL_DICT.zu[attr]) && this.COL_DICT.zu[attr] != '')
			resAttr = this.COL_DICT.zu[attr];
		if (type == 2 && goog.isDef(this.COL_DICT.cad_kvartal) && goog.isDef(this.COL_DICT.cad_kvartal[attr]) && this.COL_DICT.cad_kvartal[attr] != '')
			resAttr = this.COL_DICT.cad_kvartal[attr];
		if (type == 3 && goog.isDef(this.COL_DICT.cad_rayon) && goog.isDef(this.COL_DICT.cad_rayon[attr]) && this.COL_DICT.cad_rayon[attr] != '')
			resAttr = this.COL_DICT.cad_rayon[attr];
		if (type == 4 && goog.isDef(this.COL_DICT.cad_okrug) && goog.isDef(this.COL_DICT.cad_okrug[attr]) && this.COL_DICT.cad_okrug[attr] != '')
			resAttr = this.COL_DICT.cad_okrug[attr];

	}
	return resAttr;

};


map.controls.MapInfoControl.prototype.resultCadastre_ = function (resultXml, arr) {
	BlockingUtil.ready();
	var resultArr = [];
	var objIds = [];//массив ids пришедших, чтобы убрать дубли в результирущим массиве объектов
	if (resultXml.length > 0) {
		var datas = resultXml[0].getElementsByTagName("FIELDS");
		try {
			// собираем в виде attrs:[{name:'KluchSF', value:'166'},{name:'TekstoviyidentifikatorIPGU', value:'66:17:101018'}]})
			var i = 0;
			for (; i < datas.length; i++) {
				var resultAttrs = [];
				//проверяем к какому слою относится
				//значение по умолчанию, если не попали ни в один вид
				var label = gis_mapinfocontrol_12;
				var objId = '';
				var cadNumber = datas[i].getAttribute(gis_mapinfocontrol_13);
				var count = (cadNumber != "" && cadNumber != null) ? cadNumber.split(":").length - 1 : -1;
				var fullId = 'CADASTRE_OBJECT';
				//0 ":" - округ
				//1 ":" - район
				//2 ":" - квартал
				//3 ":" - земельный участок
				// иначе - кадастровый объект

				if ((count == 0) || (datas[i].getAttribute("RAYONS_CNT") != null) || (datas[i].getAttribute(gis_mapinfocontrol_20) != null)) {//кадастровый округ
					label = gis_mapinfocontrol_15;
					fullId = 'CADASTRE_DISTRICT';
				}
				if ((count == 1) || (datas[i].getAttribute(gis_mapinfocontrol_21) != null) || (datas[i].getAttribute("KVARTALS_CNT") != null && datas[i].getAttribute("RAYONS_CNT") == null) || (datas[i].getAttribute(gis_mapinfocontrol_22) != "" && datas[i].getAttribute(gis_mapinfocontrol_23) == ""))//кадастровый район
				{
					label = gis_mapinfocontrol_16;
					fullId = 'CADASTRE_RAYON';
				}
				if ((count == 2) || (datas[i].getAttribute(gis_mapinfocontrol_24) != null) || (datas[i].getAttribute("KVARTAL_ID") != null) || (datas[i].getAttribute(gis_mapinfocontrol_25) != null))//кадастровый квартал
				{
					label = gis_mapinfocontrol_17;
					fullId = 'CADASTRE_KVARTAL';
				}
				if ((count == 3) || (datas[i].getAttribute(gis_mapinfocontrol_26) != null) || datas[i].getAttribute("PARCEL_ID") != null)//земельный участок
				{
					label = gis_mapinfocontrol_18;
					fullId = 'CADASTRE_PARCEL';
				}
				if (datas[i].getAttribute("OKS_ID") != null)//объект капитального строительства
				{
					label = gis_mapinfocontrol_27;
					fullId = 'CADASTRE_OKS';
				}

				var attrNamesList = datas[i].attributes;
				var needAdd = true;

				var j = 0;
				for (; j < attrNamesList.length; j++) {
					var obj = {};
					var nodeName = attrNamesList[j].nodeName;
					var nodeValue = attrNamesList[j].nodeValue;
					if (nodeName == 'OBJECTID') {
						if (objIds.indexOf(nodeValue) != -1) {
							needAdd = false;
							break;
						}
						obj.name = 'ID';
						objIds.push(nodeValue);
						objId = nodeValue;
						fullId += ':' + nodeValue;
					} else {
						obj.name = map.controls.MapInfoControl.transliterate(nodeName);

					}
					obj.value = nodeValue;
					resultAttrs.push(obj);
				}

				if (needAdd == true)
					resultArr.push({label: label, id: fullId, attrs: resultAttrs});
			}
		} catch (ex) {
		}
	}
	if (!goog.isDefAndNotNull(arr))
		arr = [];
	var finalArr = arr.concat(resultArr);
	this.startFindRasterObjects_(this.searchX, this.searchY, finalArr);
};

/**
 * Функция открытия панели свойств
 * @param arr - массив на выдачу
 * @param error - сообщение об ошибке для случая получения информации из подложки
 * @private
 */
map.controls.MapInfoControl.prototype.showPropertyPanel_ = function (arr, error) {
	var that = this;
	//Если в модели не было выборки объектов или мы не нажимали CTRL - передаем info
	if (this.infoArr.length == 0 || this.withCtrlBtn == false) {
		//на первом клике чистим лой
		if (!this.useCtrl)
			MapUtil.clearSelectionLayer();
		//Если первую выборку делали с нажатым CTRL - берем только первый элемент массива
		//поэтому исходный массив обнуляем, чтобы потом добавить в него только первый объект
		if (this.withCtrlBtn == true && arr.length > 0)
			this.infoArr = [];
		else
			this.infoArr = arr;
	}
	if (this.withCtrlBtn == true) {
		this.useCtrl = true;
		var concatArr = [];
		arr = this.startFindVectorObjects_(arr);
		if (arr.length > 0) {
			for (var i = 0; i < arr.length; i++) {
				var isNewElem = true;
				for (var j = 0; j < this.infoArr.length; j++) {
					if (goog.isDef(arr[i].id) && goog.isDef(this.infoArr[j].id) && arr[i].id == this.infoArr[j].id) {
						isNewElem = false;
						break;
					}
				}
				//прошли по всем объектам существующего массива и не нашли с таким же ID - включаем
				if (isNewElem == true) {
					concatArr.push(arr[i]);
					break;
				}
			}
		}
		this.infoArr = this.infoArr.concat(concatArr);
		//в массив searchXY добавляем координаты точек, в которых жали с ctrl
		this.infoCoordArr.push({searchX: this.searchX, searchY: this.searchY});
	}
	if (this.withCtrlBtn == false) {
		if (!this.useCtrl) {
			arr = this.startFindVectorObjects_(arr);
			//выставляем в WidgetMap.mapSelectedObject массив выбранных объектов
			MapUtil.clearSelectionLayer();
		}

		/*проверка, что задача ПКА*/
		var exportToGpxKmlCallback = undefined;
		var centeringCallback = undefined;
		var deleteCASCallback = undefined;
		var calculateObjectSizeCallback = undefined;
		if (goog.isDef(WidgetMap.LINE_ID)) {
			exportToGpxKmlCallback = function () {
				return false;
			};
			centeringCallback = function () {
				return false;
			};
			deleteCASCallback = function () {
				App.errorReport(gis_mapinfocontrol_14, gis_mapinfocontrol_3, undefined, {
					filename: gis_filename_459,
					functionname: 'gis_filename_459_10'
				});
				return false;
			};
			//если не нашли объектов, не показываем панель свойств для ПКА
			if (arr.length === 0) {
				this.useCtrl = false;
				//для АСМО выполняем пересборку id в xml
				this.sendObjectsInfo_(arr);
				this.infoArr = [];
				this.infoCoordArr = [];

				return;
			}

		} else if (GeoUtil.PROJS['EPSG:5807'] === WidgetMap.DEFAULT_PROJECTION)
			calculateObjectSizeCallback = undefined;
		else {
			calculateObjectSizeCallback = function (params) {
				if (params && params.selector && params.object) {
					$(params.selector).text(MapUtil.calculateObjectSize(params.object));
				}
			};
		}

		var dontShowEmplyPanel = WidgetMap.config && WidgetMap.config.ppanel && WidgetMap.config.ppanel.showInfoEmptyMap === false && arr.length === 0;

		if (!dontShowEmplyPanel) {
			var mapPropPanelId = 'mapPPanel';
			var dId = getParameterByName('dialogId');
			if(dId){
				parent.App.resizeIframeMap(dId);
			}
			$('#' + mapPropPanelId).remove();
			var mapPropPanelDiv = '<div id="' + mapPropPanelId + '" class="gsi-zindex__ppanel"></div>';
			$('body').append(mapPropPanelDiv);
			$('#' + mapPropPanelId).myPropertiesPanel({
				coords: [this.searchX, this.searchY],
				error: error,
				withCtrl: this.useCtrl,
				objects: arr,
				position: that.ppanelPosition,
				opener: 'body',
				handlers: {
					dragPanelCallback: function (coords) {
						that.ppanelPosition = coords;
					},
					calculateObjectSizeCallback: calculateObjectSizeCallback,
					deleteCASCallback: deleteCASCallback,
					centeringCallback: centeringCallback,
					exportToGpxKmlCallback: exportToGpxKmlCallback,
					changePanelObjectCallback: function (dataObject, withCtrl) {
						//если не был нажат ctrl, то переформировываем выделение, иначе оставляем всё как есть.
						//используется для построения буферов по всем выбранным объектам
						if (withCtrl !== true) {
							//переформировываем для выделения
							var objects = [];
							if (dataObject.id.indexOf('CADASTRE') != -1)
								return;
							if (goog.isDef(dataObject.geo))
								objects.push({name: 'objects', value: dataObject.id, geo: dataObject.geo});
							else
								objects.push({name: 'objects', value: dataObject.id});
							objects.push({name: 'centering', value: 'false'});
							objects.push({name: 'uniqueLayerName', value: dataObject.uniqueLayerName});

							WidgetMap.showObjects(objects);
						}
					},
					closeCallback: function () {
						if (WidgetMap.currentCutFeature && WidgetMap.currentCutFeature[WidgetMap.mapSelectedObject]) {
							WidgetMap.addObjectControl.pasteFeature = undefined;
							WidgetMap.addObjectControl.moveFeature = undefined;
							map.controls.DeleteBufferObjectControl.revertCurrentObject([WidgetMap.mapSelectedObject]);
						}
						MapUtil.clearSelectionLayer();
						//обнуляем массив подписей, который прятали при выделении объектов
						if (goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0) {
							WidgetMap.map.render();
							WidgetMap.hideLabelsArr = [];
						}
					},
					semanticCallback: function (dataObject) {
						var syncOptions = {
							syncType: SyncTypes.TYPE_3,
							syncSender : 'ppanel',
							syncUniqueLayerName: undefined
						};
						var syncType = SyncTypes.TYPE_NO;
						syncOptions = undefined;
						var pasteFeature = undefined;
						var needBind = false;
						try{
							if (goog.isDef(WidgetMap.addObjectControl) && goog.isDef(WidgetMap.addObjectControl.pasteFeature)) {
								pasteFeature = WidgetMap.addObjectControl.pasteFeature;
								var objId = pasteFeature.get('objectId');
								if (objId) {//если редактировали на карте, нужно перепровернить привязку
									needBind = true;
								}
								//syncType = SyncTypes.TYPE_1;
							} else if (goog.isDef(WidgetMap.moveGeometryControl) && !goog.isDef(pasteFeature)) {
								//если двигали на карте, нужно перепровернить привязку
								pasteFeature = WidgetMap.moveGeometryControl.pasteFeature;
								needBind = true;
							}

							if (goog.isDef(pasteFeature)) {
								var layerName = pasteFeature.get('layerName');
								var semId = pasteFeature.get('objectId');
								var clonedFeature = GeoUtil.cloneFeature(pasteFeature, true, true);
								pasteFeature = GeoUtil.recreateFeatureGeometry(pasteFeature);
								var layObj = WidgetMap.layerManager.getLayerByName(layerName);
								var geo = clonedFeature.getGeometry();
								if(geo && geo.flatCoordinates.length === 0){ //если нет координат, то не привязываем
									needBind = false;
								}

								if (needBind) {
									var bindDataTypes = (goog.isDef(App.config.MAP_BIND_CLASSES) && App.config.MAP_BIND_CLASSES.length > 0) ? App.config.MAP_BIND_CLASSES.split(',') : [];
									if (goog.isDef(bindDataTypes) && bindDataTypes.length > 0 && bindDataTypes.indexOf(layerName) != -1) {
										map.controls.DrawGeometryControl.showBindForm(layerName, clonedFeature, ["PODS_ROUTE"], syncOptions);
									} else {
										var projection = (goog.isDef(layObj) && goog.isDef(layObj.layer)) ? layObj.layer.projection : GeoUtil.PROJS.Pulkovo42;
										GeoUtil.convertFeature(clonedFeature, WidgetMap.DEFAULT_PROJECTION, projection);
										//that.pasteFeature - уже наша отредактированная фича
										map.controls.DrawGeometryControl.updateGeometry_(semId, clonedFeature, pasteFeature, layerName, false, syncOptions);
									}
								} else {
									var projection = (goog.isDef(layObj) && goog.isDef(layObj.layer)) ? layObj.layer.projection : GeoUtil.PROJS.Pulkovo42;
									GeoUtil.convertFeature(clonedFeature, WidgetMap.DEFAULT_PROJECTION, projection);
									//that.pasteFeature - уже наша отредактированная фича
									map.controls.DrawGeometryControl.updateGeometry_(semId, clonedFeature, pasteFeature, layerName, false, syncOptions);
								}
								var selectedObject = layerName + ':' + semId;
								//СИНХРОНИЗАЦИЯ #H5
								App.syncManager.callSync(selectedObject, 'ppanel', undefined, syncType);

								WidgetMap.addObjectControl.pasteFeature = undefined;
								WidgetMap.addObjectControl.moveFeature = undefined;
								WidgetMap.handleEscClick_();
							}
							//если слой косметический
							else {
								var dataObj = dataObject.savingData;
								if (goog.isDef(dataObj)) {
									//<root USER_ID="1045" USER_LOGIN="editor" PODS_USER="editor"><data FILTER="ID=-657789252" SYS_FULL_ID="COSMETIC_OBJECT/-657789252" DB_SCHEMA_ID="COSMETIC" DB_TABLE_ID="OBJECT" SYS_CLASS_ID="COSMETIC_OBJECT" SYS_OBJ_ID="-657789252"  LABEL="qq1" NAME="Объект косметического слоя" /></root>
									//<root USER_ID="1045" USER_LOGIN="editor" PODS_USER="editor"><data FILTER="ID=1" SYS_FULL_ID="COSMETIC_OBJECT/1" DB_SCHEMA_ID="COSMETIC" DB_TABLE_ID="OBJECT" SYS_CLASS_ID="COSMETIC_OBJECT" SYS_OBJ_ID="1"  LABEL="sadsd" NAME="Объект косметического слоя" /></root>
									//забираем id слоя и объекта и обновляем информацию
									var layerGeoXml = ($.parseXML(dataObj)).firstChild;
									var data = layerGeoXml.getElementsByTagName("data");
									if (data.length >= 0) {
										var fullId = data[0].getAttribute('SYS_FULL_ID');
										if (fullId.indexOf('COSMETIC_OBJECT') != -1) {
											var splitted = fullId.split('/');
											if (splitted.length > 1) {
												var semId = splitted[1];
												var layObj = WidgetMap.layerManager.getLayerByName(splitted[0]);
												//пробуем искать в косметике, потом в буфере
												var found = false;
												var label = null;
												if (goog.isDef(layObj) && goog.isDef(layObj.layer)) {
													if (!goog.isNull(data[0].getAttribute(layObj.layer.labelField)) && data[0].getAttribute(layObj.layer.labelField) != 'NULL')
														label = data[0].getAttribute(layObj.layer.labelField);
													if (!goog.isNull(data[0].getAttribute('LABEL')))
														label = data[0].getAttribute('LABEL');
													found = layObj.layer.updateLabel(semId, label);
												}
												if (!found) {
													var features = WidgetMap.bufferLayer.getSource().getFeatures();
													var i = 0, j = 0;
													for (j; j < features.length; j++) {
														var labelsObj = features[j].get('labelsObj');
														if (!goog.isDef(labelsObj)) {
															var geoType = features[j].getGeometry().getType();
															switch (geoType) {
																case 'Point':
																	globalPointsLabels_[splitted[0]] = [{
																		label: label,
																		id: semId,
																		geo: features[j].getGeometry()
																	}];
																	break;
																case 'LineString':
																	globalLinesLabels_[splitted[0]] = [{
																		label: label,
																		id: semId,
																		geo: features[j].getGeometry()
																	}];
																	break;
																case 'Polygon':
																	globalPolygonsLabels_[splitted[0]] = [{
																		label: label,
																		id: semId,
																		geo: features[j].getGeometry()
																	}];
																	break;
															}
															features[j].set('labelsObj', [{
																label: label,
																id: semId,
																geo: features[j].getGeometry()
															}]);
														} else {
															for (i; i < labelsObj.length; i++) {
																if (labelsObj[i].id == semId) {
																	var geoType = features[j].getGeometry().getType();
																	switch (geoType) {
																		case 'Point':
																			for (var kk in globalPointsLabels_['COSMETIC_OBJECT'])
																				if (globalPointsLabels_['COSMETIC_OBJECT'][kk].id == semId) {
																					globalPointsLabels_['COSMETIC_OBJECT'][kk].label = label;
																					break;
																				}
																			break;
																		case 'LineString':
																			for (var kk in globalLinesLabels_['COSMETIC_OBJECT'])
																				if (globalLinesLabels_['COSMETIC_OBJECT'][kk].id == semId) {
																					globalLinesLabels_['COSMETIC_OBJECT'][kk].label = label;
																					break;
																				}
																			break;
																		case 'Polygon':
																			for (var kk in globalPolygonsLabels_['COSMETIC_OBJECT'])
																				if (globalPolygonsLabels_['COSMETIC_OBJECT'][kk].id == semId) {
																					globalPolygonsLabels_['COSMETIC_OBJECT'][kk].label = label;
																					break;
																				}
																			break;
																	}
																	labelsObj[i].label = label;
																	break;
																}
															}
														}
													}
													//WidgetMap.bufferLayer.changed();
												}
												//обнуляем массив подписей, который прятали при выделении объектов
												/*if(goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0){
												 WidgetMap.map.render();
												 WidgetMap.hideLabelsArr = [];
												 }*/
											}
										} else {
											//Если меняли стиль объекта TYPE_CL при сохранении семантики, то ищем его в фичах и переносим в новую или не трогаем
											var splitted = fullId.split('/');
											var label = null;
											if (splitted.length > 1) {
												var layerId = splitted[0];
												var semId = splitted[1];
												var layObj = WidgetMap.layerManager.getLayerByName(layerId);
												if (goog.isDef(layObj) && goog.isDef(layObj.layer)) {
													//сначала меняем подпить, если её меняли на сохранении семантики
													if (!goog.isNull(data[0].getAttribute(layObj.layer.labelField)) && data[0].getAttribute(layObj.layer.labelField) != 'NULL')
														label = data[0].getAttribute(layObj.layer.labelField);
													if (!goog.isNull(data[0].getAttribute('LABEL')))
														label = data[0].getAttribute('LABEL');
													var found = layObj.layer.updateLabel(semId, label);
													//меняем стиль отрисовки на карте
													layObj.layer.updateObjectGeoStyle(semId, data, dataObject);
												}
												var selectedObject = layerId + ':' + semId;
												//СИНХРОНИЗАЦИЯ #I5
												App.syncManager.callSync(selectedObject, 'ppanel', undefined, SyncTypes.TYPE_3);
											}
										}
									}
								}
							}
						}
						catch(ex){
							App.errorReport(gis_mapinfocontrol_29, ex.message, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_14'});
						}

					},
					successDeleteCallback: function (data) {
						if (goog.isDef(data) && goog.isDef(data.id) && data.id != '' && data.layerName != '') {
							var layObj = WidgetMap.layerManager.getLayerByName(data.layerName);
							if (goog.isDef(layObj) && goog.isDef(layObj.layer)) {
								layObj.layer.deleteObjectById(data.id);
							}
						}
						MapUtil.clearSelectionLayer();
						//обнуляем массив подписей, который прятали при выделении объектов
						if (goog.isDef(WidgetMap.hideLabelsArr) && WidgetMap.hideLabelsArr.length > 0) {
							WidgetMap.map.render();
							WidgetMap.hideLabelsArr = [];
						}
						//СИНХРОНИЗАЦИЯ #K6
						$('#mapPPanel').remove();
					}
				}
			});
		}

		this.useCtrl = false;
		//для АСМО выполняем пересборку id в xml
		this.sendObjectsInfo_(arr);
		this.infoArr = [];
		this.infoCoordArr = [];
	} else {
		//05.03.20 Новое поведение. Когда выбираем объект, то ставим не точку, а выделяем весь объект
		var k = this.infoArr.length - 1;
		//нашли объект и заносим его в слой выделения
		if (this.infoArr && this.infoArr.length > 0 && this.infoArr[k]) {
			this.addObjectToSelectionLayer_(this.infoArr[k], k);
		}
	}
};

/**
 * Добавляем выбранный объект в слой выделения на карте
 * @param object
 * @param index
 * @private
 */
map.controls.MapInfoControl.prototype.addObjectToSelectionLayer_ = function (object, index) {
	function getLayerGeoReqParams(filter, request) {
		var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
		var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
		return {
			descrId: request,
			descrType: 'select',
			data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' +
				'<data FILTER="' + filter + '"/>' +
				'</root>'
		};
	}
	function getLayerGeoRequest(filter, request, layerObj, indexId) {
		var filterStr = generateFilterStr(filter);
		App.serverQueryXMLNodeWithTries(Services.processQueryNodeGeo, getLayerGeoReqParams(filterStr, request), getLayerGeoResult, getLayerGeoFault,4);
		function getLayerGeoResult(resultXml) {
			try { // Иногда ответ в формате XML, а иногда в виде просто строки
				var er = HTTPServiceUtil.getError(resultXml);
				if (er !== ''){
					App.errorReport(gis_mapinfocontrol_28, er, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_13'});
				}
				else{
					var layerGeoXml = ($.parseXML(resultXml)).firstChild;
					var datas = layerGeoXml.getElementsByTagName("data");
					var stride = 2;
					for (var i = 0; i < datas.length; i++) {
						//парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
						var format = new ol.format.WKT({dimension: stride});
						var wktStr = datas[i].getAttribute("WKT");//;"POINT(-1 -1)";
						var idStr = datas[i].getAttribute("ID");
						var feature = undefined;
						try {
							feature = format.readFeature(wktStr);
						} catch (ex) {
							//для случая с видеозаписями, приходит 3 координаты
							stride = 3;
							format = new map.format.WKT({dimension: stride});
							feature = format.readFeature(wktStr);
						}
						if (goog.isDef(feature)) {
							//забираем координаты и переводим их в нормальную проекцию
							var flatCoordinates = feature.getGeometry().flatCoordinates;
							if (flatCoordinates.length > 1 && flatCoordinates[0] != -1 && flatCoordinates[1] != -1) {
								//устанавливаем в фичу стиль дефолтный
								if (stride == 3) {
									var newArr = [];
									for (var j = 0; j < flatCoordinates.length; j += stride) {
										var lng = flatCoordinates[j];
										var lat = flatCoordinates[j + 1];
										newArr.push(lng);
										newArr.push(lat);
									}
									//геометрия выделяемого участка трубопровода
									var geometry = new ol.geom.LineString(null);
									geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY, newArr);
									var newLineFeature = new ol.Feature(geometry);
									WidgetMap.layerManager.defaultSelectionStyle(newLineFeature);
									GeoUtil.convertFeature(newLineFeature, App.projection, WidgetMap.DEFAULT_PROJECTION);
									newLineFeature.setId('DEFAULT_SELECTED_' + idStr);
									WidgetMap.mapSelectionLayer.getSource().addFeature(newLineFeature);
								} else {
									WidgetMap.layerManager.defaultSelectionStyle(feature);
									GeoUtil.convertFeature(feature, App.projection, WidgetMap.DEFAULT_PROJECTION);
									feature.setId('DEFAULT_SELECTED_' + idStr);
									WidgetMap.mapSelectionLayer.getSource().addFeature(feature);
								}
							}
						}
					}
				}
			} catch (ex) {
			}
		}
		function getLayerGeoFault(resultXml) {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er !== '')
				App.errorReport(gis_mapinfocontrol_28, er, undefined, {filename:gis_filename_459, functionname:'gis_filename_459_12'});
		}
		function generateFilterStr(filter) {
			return "ID in (" + filter.join(",") + ")";
		}
	}

	if (object) {
		//если есть геометрия, то сразу добавляем
		if (object.geo) {
			var currFeature = new ol.Feature(object.geo.getGeometry());
			currFeature.setId('DEFAULT_SELECTED_' + index);
			WidgetMap.layerManager.defaultSelectionStyle(currFeature);
			WidgetMap.mapSelectionLayer.getSource().addFeature(currFeature);
		} else {
			//если нет гео, то смотрим, какой слой, растр или вектор
			var layerName = object.id.split(':')[0];
			var objId = object.id.split(':')[1];
			var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
			//если слоя нет в _rasterLayers
			var isRasterLayer = false;
			var layerRasterObj = WidgetMap.layerManager.getRasterLayerByName(layerName);
			if (layerRasterObj && WidgetMap.CURRENT_MODE === WidgetMap.MODES.RASTER)
				isRasterLayer = true;
			if (object.uniqueLayerName && !isRasterLayer) {//слой векторный
				var features = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(object.layerName, [objId]);
				WidgetMap.mapSelectionLayer.getSource().addFeatures(features);
			} else {
				//грузим растровые данные данные
				var spatialRequest = layerObj.dataProvider.spatial;
				getLayerGeoRequest([objId], spatialRequest, layerObj, index);
			}
		}
	}
};



/**
 * для АСМО выполняем пересборку id в xml
 * @param arr
 */
map.controls.MapInfoControl.prototype.sendObjectsInfo_ = function (arr) {
	var that = this;
	try {
		var screen = GeoUtil.convertCoords([this.searchX, this.searchY], WidgetMap.DEFAULT_PROJECTION, App.projection);
		var userId = '1';
		var sessionId = '1';
		var data = '<data x="' + this.searchX + '" y="' + this.searchY + '"  screen_x="' + screen[0] + '" screen_y="' + screen[1] + '" />';
		var reqData = '';
		var i, j;
		var c;
		var layer_name;
		var obj_id;
		var cls;
		//Среди растровых слоев могут быть трубы и прочие объекты - обрабатываем их
		var rLayers = WidgetMap.layerManager.getRasterLayers();
		var rLayersByName = {};
		for (j = 0; j < rLayers.length; j++) {
			var rLayer = rLayers[j];
			if (goog.isDef(rLayer) && goog.isDef(rLayer.layer) && rLayer.layer.name != '')
				rLayersByName[rLayer.layer.name] = rLayer;
		}
		var rLayersCache = WidgetMap.layerManager.getVectorLayersByMode();
		var rLayersByNameCache = {};
		for (j = 0; j < rLayersCache.length; j++) {
			var rLayer = rLayersCache[j];
			if (goog.isDef(rLayer) && goog.isDef(rLayer.layer) && goog.isDefAndNotNull(rLayer.layer.name) && rLayer.layer.name != '')
				rLayersByNameCache[rLayer.layer.name] = rLayer;
		}
		var hasChildren = false;
		for (i = 0; i < arr.length; i++) {
			var o = arr[i];
			if (!goog.isDef(o.VECTOR_LAYER) && goog.isDef(o.USER_LAYER_NAME) && goog.isDef(o.ID)) {
				var layDescr = o["USER_LAYER_NAME"];
				//Обрабатываем информацию с растровых труб и аналогичных слоев
				var curRasterLay = rLayersByName[layDescr];
				var curCacheLay = rLayersByNameCache[layDescr];
				//Просто растровую подложку не обрабатываем
				if (goog.isDef(curRasterLay) && goog.isDef(curRasterLay.layer) && curRasterLay.layer.name.indexOf('WEB50_M_') == -1) {
					var idStr = curRasterLay.layer.name + "/" + o.ID;
					cls = (goog.isDef(curRasterLay.layer.name)) ? curRasterLay.layer.name.replace("PODS_", "").replace("PKMETADATA_", "") : '';
					c = '<data OBJ_ID="' + o.ID + '" CLS="' + cls + '"  USER_ID="' + userId + '" SESSION_ID="' + sessionId + '" />';
					data += c;
					reqData += c;
					hasChildren = true;
				} else if (goog.isDef(curCacheLay) && goog.isDef(curCacheLay.layer) && curCacheLay.layer.name.indexOf('WEB50_M_') == -1) {
					obj_id = o.ID;
					layer_name = curCacheLay.layer.name;//o.CLS_NAME;
					obj_id = obj_id.substr(obj_id.indexOf("/") + 1);
					cls = (goog.isDef(layer_name)) ? layer_name.replace("PODS_", "").replace("PKMETADATA_", "") : '';
					c = '<data OBJ_ID="' + obj_id + '" CLS="' + cls + '"  USER_ID="' + userId + '" SESSION_ID="' + sessionId + '" />';
					data += c;
					reqData += c;
					hasChildren = true;
				}
			}
		}
		if (hasChildren) {
			function getLayersReqParams(data) {
				var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
				var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

				return {
					descrId: map.controls.requestFindInfId,
					descrType: 'select',
					data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '">' +
						data +
						'</root>'
				};
			}

			App.serverQueryXMLNodeWithTries(Services.processQueryNode, getLayersReqParams(reqData), function (resultXml) {
				that.resultAsmo_(resultXml);
			}, function (resultXml) {
				that.faultAsmo_(resultXml);
			});
		}

		data += '</data>';
		this.data_ = data;
		onObjectsInfo(this.data_);
	} catch (e) {

	}

};

map.controls.MapInfoControl.prototype.resultAsmo_ = function (resultXml) {
	var er = HTTPServiceUtil.getError(resultXml);
	this.data_ = this.data_.replace('</data>', '');
	if (er !== '') {
		return;
	} else {
		var layerGeoXml = ($.parseXML(resultXml)).firstChild;
		var datas = layerGeoXml.getElementsByTagName("root");
		var hasChildren = false;
		for (var i = 0; i < datas.length; i++) {
			var cls = (goog.isDef(datas[i].getAttribute('CLS'))) ? datas[i].getAttribute('CLS') : '';
			var c = '';
			if (cls != '') {
				c = '<item id="' + datas[i].getAttribute('ID') + '" cls="' + cls + '" obj_id="' + datas[i].getAttribute('OBJ_ID') + '" />';
				this.data_ += c;
			} else {
				if (parseFloat(datas[i].getAttribute('id')) > 0) {
					c = '<item id="' + datas[i].getAttribute('ID') + '" />';
					this.data_ += c;
				}
			}
		}
	}

	this.data_ += '</data>';
	if (hasChildren) {
		onObjectsInfo(this.data_);
	}

	this.data_ = '';
};

map.controls.MapInfoControl.prototype.faultAsmo_ = function (resultXml) {
	var er = HTTPServiceUtil.getError(resultXml);
	if (er !== '') {
		this.data_ = this.data_.replace('</data>', '');
		this.data_ += 'Error: ' + er;
		this.data_ += '</data>';
		onObjectsInfo(this.data_);
	}
	this.data_ = '';
};

map.controls.MapInfoControl.transliterate = function (word) {
	var answer = ""
		, a = {};

	a["Ё"] = "YO";
	a["Й"] = "I";
	a["Ц"] = "TS";
	a["У"] = "U";
	a["К"] = "K";
	a["Е"] = "E";
	a["Н"] = "N";
	a["Г"] = "G";
	a["Ш"] = "SH";
	a["Щ"] = "SCH";
	a["З"] = "Z";
	a["Х"] = "H";
	a["Ъ"] = "";
	a["ё"] = "yo";
	a["й"] = "i";
	a["ц"] = "ts";
	a["у"] = "u";
	a["к"] = "k";
	a["е"] = "e";
	a["н"] = "n";
	a["г"] = "g";
	a["ш"] = "sh";
	a["щ"] = "sch";
	a["з"] = "z";
	a["х"] = "h";
	a["ъ"] = "";
	a["Ф"] = "F";
	a["Ы"] = "I";
	a["В"] = "V";
	a["А"] = "a";
	a["П"] = "P";
	a["Р"] = "R";
	a["О"] = "O";
	a["Л"] = "L";
	a["Д"] = "D";
	a["Ж"] = "ZH";
	a["Э"] = "E";
	a["ф"] = "f";
	a["ы"] = "i";
	a["в"] = "v";
	a["а"] = "a";
	a["п"] = "p";
	a["р"] = "r";
	a["о"] = "o";
	a["л"] = "l";
	a["д"] = "d";
	a["ж"] = "zh";
	a["э"] = "e";
	a["Я"] = "Ya";
	a["Ч"] = "CH";
	a["С"] = "S";
	a["М"] = "M";
	a["И"] = "I";
	a["Т"] = "T";
	a["Ь"] = "";
	a["Б"] = "B";
	a["Ю"] = "YU";
	a["я"] = "ya";
	a["ч"] = "ch";
	a["с"] = "s";
	a["м"] = "m";
	a["и"] = "i";
	a["т"] = "t";
	a["ь"] = "";
	a["б"] = "b";
	a["ю"] = "yu";
	a["."] = "";
	var i;
	for (i in word) {
		if (word.hasOwnProperty(i)) {
			if (a[word[i]] === undefined) {
				answer += word[i];
			} else {
				answer += a[word[i]];
			}
		}
	}
	return answer;
	//2-й вариант
	var a = {
		"Ё": "YO",
		"Й": "I",
		"Ц": "TS",
		"У": "U",
		"К": "K",
		"Е": "E",
		"Н": "N",
		"Г": "G",
		"Ш": "SH",
		"Щ": "SCH",
		"З": "Z",
		"Х": "H",
		"Ъ": "'",
		"ё": "yo",
		"й": "i",
		"ц": "ts",
		"у": "u",
		"к": "k",
		"е": "e",
		"н": "n",
		"г": "g",
		"ш": "sh",
		"щ": "sch",
		"з": "z",
		"х": "h",
		"ъ": "'",
		"Ф": "F",
		"Ы": "I",
		"В": "V",
		"А": "a",
		"П": "P",
		"Р": "R",
		"О": "O",
		"Л": "L",
		"Д": "D",
		"Ж": "ZH",
		"Э": "E",
		"ф": "f",
		"ы": "i",
		"в": "v",
		"а": "a",
		"п": "p",
		"р": "r",
		"о": "o",
		"л": "l",
		"д": "d",
		"ж": "zh",
		"э": "e",
		"Я": "Ya",
		"Ч": "CH",
		"С": "S",
		"М": "M",
		"И": "I",
		"Т": "T",
		"Ь": "'",
		"Б": "B",
		"Ю": "YU",
		"я": "ya",
		"ч": "ch",
		"с": "s",
		"м": "m",
		"и": "i",
		"т": "t",
		"ь": "'",
		"б": "b",
		"ю": "yu"
	};

	function transliterate(word) {
		return word.split('').map(function (char) {
			return a[char] || char;
		}).join("");
	}
};


/***
 *  Подгрузка данные
 * @param urls
 * @param arr
 */
map.controls.MapInfoControl.prototype.loadCadastreJSON = function (center, arr) {
	var that = this;
	if (this.cadastreUrls.length == 0) {
		if (that.cadastreError != '')
			App.errorReport(gis_mapinfocontrol_2, that.cadastreError, undefined, {
				filename: gis_filename_459,
				functionname: 'gis_filename_459_11'
			});
		this.startFindRasterObjects_(this.searchX, this.searchY, arr);
		return;
	}
	var zoom = WidgetMap.map.getView().getZoom();
	var tolerance = this.getToleranceByZoom_(zoom);

	var url = this.cadastreUrls[0];
	this.cadastreUrls.splice(0, 1);
	var centerStr = ('' + center[1]).replace('.', ',') + ' ' + ('' + center[0]).replace('.', ',');
	var detailUrl = url + '?text=' + centerStr + '&tolerance=' + tolerance + '&limit=2';
	var proxyUrl = (goog.isDef(App.config.ROSREESTR_PROXY_URL) && App.config.ROSREESTR_PROXY_URL.length > 0) ? App.config.ROSREESTR_PROXY_URL : '';//'https://proxy.anonymster.com/browse.php?u=';
	if (proxyUrl != '') {
		detailUrl = detailUrl.replace(/\//g, '%2F').replace(/ /g, '%20').replace(/,/g, '%2C').replace(/:/g, '%3A').replace(/&/g, '%26').replace(/=/g, '%3D').replace(/\?/g, '%3F');
		detailUrl = proxyUrl + detailUrl;
	}

	that.curRequest = App.serverQueryCadastreJSON(detailUrl,
		function (resultJSON) {
			BlockingUtil.ready();
			that.resultCadastreJSON_(resultJSON, center, url, arr);
		}, function (result) {
			if (goog.isDef(result) && that.cadastreError == '')
				that.cadastreError = result;
			BlockingUtil.ready();
			that.loadCadastreJSON(center, arr);
		},4);

};

map.controls.MapInfoControl.prototype.getToleranceByZoom_ = function (zoom) {
	var tolerance = 1;
	switch (zoom) {
		case 19:
			tolerance = 2;
			break;
		case 18:
			tolerance = 4;
			break;
		case 17:
			tolerance = 8;
			break;
		case 16:
			tolerance = 16;
			break;
		case 15:
			tolerance = 32;
			break;
		case 14:
			tolerance = 64;
			break;
		case 13:
			tolerance = 128;
			break;
		case 12:
			tolerance = 258;
			break;
		case 11:
			tolerance = 512;
			break;
		case 10:
			tolerance = 1024;
			break;
		case 9:
			tolerance = 2048;
			break;
		case 8:
			tolerance = 4097;//4094;
			break;
		case 7:
			tolerance = 8195;
			break;
		case 6:
			tolerance = 16391;
			break;
		case 5:
			tolerance = 32782;
			break;
		case 4:
			tolerance = 65564;
			break;
		default:
			tolerance = 1;
	}
	return tolerance;
};


goog.provide('map.controls.CASZoomBoxControl');


/**
 * Контрол для кнопок увеличения/уменьшения в ПКА в виде лупы
 * @constructor
 */
map.controls.CASZoomBoxControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	var className = goog.isDef(options.className) ?
		options.className : 'map-zoombox';

	var tooltipLabelIn = goog.isDef(options.tooltipLabelZoomIn) ?
		options.tooltipLabelZoomIn : gis_caszoomboxcontrol_1;
	this.inElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-in',
		'type' : 'button',
		'title' : tooltipLabelIn
	});
	this.inElement.style.display = 'inline';

	goog.events.listen(this.inElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.CASZoomBoxControl.prototype.handleZoomBoxClick_,'zoomIn'), false, this);

	var tooltipLabelOut = goog.isDef(options.tooltipLabelZoomOut) ?
		options.tooltipLabelZoomOut : gis_caszoomboxcontrol_2;
	this.outElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-out',
		'type' : 'button',
		'title' : tooltipLabelOut
	});
	this.outElement.style.display = 'inline';

	goog.events.listen(this.outElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.CASZoomBoxControl.prototype.handleZoomBoxClick_,'zoomOut'), false, this);

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;

	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.inElement,
		this.outElement);

	goog.base(this, {
		element: element,
		target: options.target
	});

};
goog.inherits(map.controls.CASZoomBoxControl, ol.control.Control);

/**
 * Реация на нажатие кнопок зуммирования
 * @param type тип нажатой кнопки(zoomIn или zoomOut)
 * @private
 */
map.controls.CASZoomBoxControl.prototype.handleZoomBoxClick_ = function(type) {
	var that = this;
	var currB = (type === "zoomIn")?this.inElement:this.outElement;
	WidgetMap.changeToolState(WidgetMap.MAP_BUTTON_STATE.ZOOM, currB);
	//удаляем сначала перемещение мышью
	WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
	WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);

	var isZoomIn = type === "zoomIn";
	WidgetMap.baseInteraction =
		new map.interaction.CASDragZoomInOut({
			isZoomIn: isZoomIn,
			callbackFunc: function(bounds, isZoomIn){
				that.onZoom_(bounds, isZoomIn);
			}
		});
	WidgetMap.map.addInteraction(WidgetMap.baseInteraction);
};

/**
 * Обработка масштабирования
 * @param {ol.Extent} bound
 * @param {Boolean} isZoomIn
 * @private
 */
map.controls.CASZoomBoxControl.prototype.onZoom_ = function(bounds, isZoomIn){
	if(goog.isDef(bounds)){
		var startX = WidgetMap.curStartX;
		var endX = WidgetMap.curEndX;
		var absMin = 0;
		var absMax = Math.abs(WidgetMap.max_km - WidgetMap.min_km);
		var maxSliderLength = WidgetMap.MIN_START_END_KM_DELTA;
		//Если мы еще не достигли максимального масштаба, растягиваем, иначе - ничего не делаем
		if (!isZoomIn || Math.abs(WidgetMap.curEndX - WidgetMap.curStartX) > maxSliderLength){
			//По полученным lonLat нужно вычислить реальные километры (разделить на коэффициент растяжения)
			//если указываем значения меньше/больше граничных, ограничиваем их
			startX = Math.max(absMin, Math.min(ol.extent.getBottomLeft(bounds)[0]/WidgetMap.prevScaleXCoeff, ol.extent.getBottomRight(bounds)[0]/WidgetMap.prevScaleXCoeff, absMax));
			endX = Math.min(absMax, Math.max(ol.extent.getBottomLeft(bounds)[0]/WidgetMap.prevScaleXCoeff, ol.extent.getBottomRight(bounds)[0]/WidgetMap.prevScaleXCoeff, absMin));
			//Ограничиваем выбранные километры согласно maxSliderLength
			if (Math.abs(endX - startX)<=maxSliderLength){
				//Если перетаскивали только правый бегунок на слайдере
				if (WidgetMap.curStartX==startX)
					endX = startX + maxSliderLength;
				else
				//Если перетаскивали только левый бегунок на слайдере
				if (WidgetMap.curEndX==endX)
					startX = endX - maxSliderLength;
				else{
					//Если при перетаскивании самого слайдера изменились значения - пытаемся сохранить центр!
					var oldCenter = (endX + startX)/2;
					//Если центр слишком близко к левой границе
					if (oldCenter < absMin + maxSliderLength/2)
						oldCenter = absMin + maxSliderLength/2;
					//Если центр слишком близко к правой границе
					if (oldCenter > absMax - maxSliderLength/2)
						oldCenter = absMax - maxSliderLength/2;
					//Устанавливаем левое и правое значения относительно центра
					startX = oldCenter - maxSliderLength/2;
					endX = oldCenter + maxSliderLength/2;
				}
			}
			//Устанавливаем новые километры в панель центровки ПКА
			WidgetMap.setStartEndValues(WidgetMap.min_km + startX, WidgetMap.min_km + endX);
			//Вызываем функцию обработки смены километров в панели центровки ПКА для отображения результата на карте ПКА
			WidgetMap.OnKmChange();
		}
	}
};
goog.provide('map.controls.CASExportDataControl');



/**
 * Экспорт таблицы с данными
 * @constructor
 */
map.controls.CASExportDataControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    var className = goog.isDef(options.className) ?
        options.className : 'cas-exportdata';
    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_casexportdatacontrol_1;
    var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });

    goog.events.listen(innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASExportDataControl.prototype.handleExportDataClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);
        goog.base(this, {
            element: element,
            target: options.target
    });
};
goog.inherits(map.controls.CASExportDataControl, ol.control.Control);


/**
 * Реация на нажатие "Скопировать данные в буфер"
 * @private
 */
map.controls.CASExportDataControl.prototype.handleExportDataClick_ = function() {
    var casForm = new CASSettingsForm({type:CAS_SETTINGS_TYPES.EXPORT, title:gis_cas_exportdata_button_hint,
        curScaleXCoeff:WidgetMap.curScaleXCoeff,curMinX:WidgetMap.cur_min_km,curMaxX:WidgetMap.cur_max_km,minX:WidgetMap.min_km,maxX:WidgetMap.max_km});
    casForm.build();
};
goog.provide('map.controls.CASAllowTextControl');



/**
 * Контрол управляет включением/отключением подписей
 * @constructor
 */
map.controls.CASAllowTextControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    var className = goog.isDef(options.className) ?
        options.className : 'cas-allowtext';
    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_casallowtextcontrol_1;
    var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });

    goog.events.listen(innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASAllowTextControl.prototype.handleClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);
        goog.base(this, {
            element: element,
            target: options.target
    });
};
goog.inherits(map.controls.CASAllowTextControl, ol.control.Control);


/**
 * Реация на нажатие "Скопировать данные в буфер"
 * @private
 */
map.controls.CASAllowTextControl.prototype.handleClick_ = function() {
    var casForm = new CASSettingsForm({type:CAS_SETTINGS_TYPES.ALLOW_TEXT, title:gis_cas_allowtext_button_hint});
    casForm.build();
};
goog.provide('map.controls.CASLayersControl');

/**
 * Контрол для управления слоями ПКА
 * @constructor
 */
map.controls.CASLayersControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    var className = goog.isDef(options.className) ?
        options.className : 'cas-layers';
    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_cas_layers_button_hint;
    var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });

    goog.events.listen(innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASLayersControl.prototype.handleClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);
        goog.base(this, {
            element: element,
            target: options.target
    });
};
goog.inherits(map.controls.CASLayersControl, ol.control.Control);

/**
 * Реация на нажатие "Скопировать данные в буфер"
 * @private
 */
map.controls.CASLayersControl.prototype.handleClick_ = function() {
    this.buildLayersForm();
};

/**
 *
 * @param data  {lineId, lineDescr}
 */
map.controls.CASLayersControl.prototype.buildLayersForm = function(){
    var zoneId = getParameterByName('ZONE_ID');
    var casLayerForm = new CASLayersForm({
        closeCallback:function(){
            //грузим данные для всех видимых слоёв
            //cashelper.loadAllLayersData(true);
            cashelper.loadAllLayersData();
            cashelper.loadMapRect();
            var lineData = {
                LINE_ID: WidgetMap.LINE_ID,
                KM_START: WidgetMap.BEGIN_KM,
                KM_END: WidgetMap.END_KM,
            }
            var startKm = WidgetMap.BEGIN_KM;
            var finishKm = WidgetMap.END_KM;
            if(zoneId){
                lineData.ZONE_ID = zoneId;
                lineData.START_KM= startKm;
                lineData.FINISH_KM = finishKm;
            }
            WidgetMap.getLineProfile(lineData);
        }
    });
    casLayerForm.build();
}



goog.provide('map.controls.CASLayersOrderControl');



/**
 * Контрол управляет включением/отключением подписей
 * @constructor
 */
map.controls.CASLayersOrderControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    var className = goog.isDef(options.className) ?
        options.className : 'cas-layersorder';
    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_caslayersordercontrol_1;
    var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });

    goog.events.listen(innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASLayersOrderControl.prototype.handleClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);
        goog.base(this, {
            element: element,
            target: options.target
    });
};
goog.inherits(map.controls.CASLayersOrderControl, ol.control.Control);


/**
 * Реация на нажатие "Скопировать данные в буфер"
 * @private
 */
map.controls.CASLayersOrderControl.prototype.handleClick_ = function() {
    var casForm = new CASSettingsForm({type:CAS_SETTINGS_TYPES.LAYERS_ORDER,title:gis_cas_layersorder_button_hint});
    casForm.build();
};
goog.provide('map.controls.CASExpandControl');



/**
 * Контрол для изменения вертикального размера графика
 * @constructor
 */
map.controls.CASExpandControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    var className = goog.isDef(options.className) ?
        options.className : 'cas-expand';
    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_casexpandcontrol_1;
    var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });

    goog.events.listen(innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.CASExpandControl.prototype.handleExpandClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);
        goog.base(this, {
            element: element,
            target: options.target
    });
};
goog.inherits(map.controls.CASExpandControl, ol.control.Control);


/**
 * Реация на нажатие "Скопировать данные в буфер"
 * @private
 */
map.controls.CASExpandControl.prototype.handleExpandClick_ = function() {
    var casForm = new CASSettingsForm({type:CAS_SETTINGS_TYPES.EXPAND,title:gis_cas_expand_button_hint});
    casForm.build();
};
goog.provide('map.controls.ZoomControl');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.EventType');
goog.require('ol.animation');
goog.require('ol.control.Control');
goog.require('ol.css');
goog.require('ol.easing');
goog.require('ol.pointer.PointerEventHandler');



/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ZoomOptions=} opt_options Zoom options.
 * @api stable
 */
map.controls.ZoomControl = function(opt_options) {
    this.currTime = new Date().getTime();
    this.timer;
    var options = goog.isDef(opt_options) ? opt_options : {};

    var className = goog.isDef(options.className) ? options.className : 'ol-zoom';

    var delta = goog.isDef(options.delta) ? options.delta : 1;

    var zoomInLabel = goog.isDef(options.zoomInLabel) ?
        options.zoomInLabel : '+';
    var zoomOutLabel = goog.isDef(options.zoomOutLabel) ?
        options.zoomOutLabel : '\u2212';


    var inElement = goog.dom.createDom('BUTTON', {
        'class': className + '-in  ol-has-tooltip',
        'type' : 'button'
    }, zoomInLabel);
    inElement.style.backgroundColor = 'white';
    inElement.style.color = '#4C93C2';
    inElement.style.border = 'solid 1px';

    goog.events.listen(inElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ZoomControl.prototype.handleClick_, delta), false, this);


    var outElement = goog.dom.createDom('BUTTON', {
        'class': className + '-out  ol-has-tooltip',
        'type' : 'button'
    }, zoomOutLabel);

    outElement.style.backgroundColor = 'white';
    outElement.style.color = '#4C93C2';
    outElement.style.border = 'solid 1px';

    goog.events.listen(outElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.ZoomControl.prototype.handleClick_, -delta), false, this);


    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL +' mytable';
    var element = goog.dom.createDom('DIV', cssClasses, inElement,
        outElement);
    element.style.backgroundColor = '4C93C2';

    goog.base(this, {
        element: element,
        target: options.target
    });

    /**
     * @type {number}
     * @private
     */
    this.duration_ = goog.isDef(options.duration) ? options.duration : 200;

};
goog.inherits(map.controls.ZoomControl, ol.control.Control);


/**
 * @param {number} delta Zoom delta.
 * @param {goog.events.BrowserEvent} event The event to handle
 * @private
 */
map.controls.ZoomControl.prototype.handleClick_ = function(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
};



/**
 * @param {number} delta Zoom delta.
 * @private
 */
map.controls.ZoomControl.prototype.zoomByDelta_ = function(delta) {
    var map = this.getMap();
    var view = map.getView();
    if (goog.isNull(view)) {
        // the map does not have a view, so we can't act
        // upon it
        return;
    }
    var currentResolution = view.getResolution();
    if (goog.isDef(currentResolution)) {
        if (this.duration_ > 0) {
            if(goog.isDefAndNotNull(WidgetMap.kinetic))
            map.beforeRender(ol.animation.zoom({
                resolution: currentResolution,
                duration: this.duration_,
                easing: ol.easing.easeIn
            }));
        }
        var newResolution = view.constrainResolution(currentResolution, delta);
        view.setResolution(newResolution);
    }
    //WidgetMap.map.renderSync();
    //this.getMap().getView().setHint(ol.ViewHint.INTERACTING, -1);
};

goog.provide('map.controls.HistoryControl');

/**
 * Контрол для копирования вставки геометрии
 * @constructor
 */
map.controls.HistoryControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	var className = goog.isDef(options.className) ?
		options.className : 'map-history';

	this.mapHistory = options.mapHistory;

	var prevTooltip = goog.isDef(options.prevTooltip) ?
		options.prevTooltip : gis_historycontrol_1;
	this.inElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-prev',
		'type' : 'button',
		'title' : prevTooltip
	});

	this.clonedSelectedFeature = undefined;

	this.inElement.style.display = 'inline';

	goog.events.listen(this.inElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.HistoryControl.prototype.handleHistoryClick_, -1), false, this);

	var nextTooltip = goog.isDef(options.nextTooltip) ?
		options.nextTooltip : gis_historycontrol_2;
	this.outElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className + '-next map-disabled-button',
		'type' : 'button',
		'title' : nextTooltip
	});
	this.outElement.style.display = 'inline';

	goog.events.listen(this.outElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.HistoryControl.prototype.handleHistoryClick_, 1), false, this);

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;
    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, this.inElement,
            this.outElement);
    }

	if(goog.isDef(this.mapHistory)){
		this.mapHistory.historyControl = this;
	}

	goog.base(this, {
		element: element,
		target: options.target
	});

};
goog.inherits(map.controls.HistoryControl, ol.control.Control);


/**
 * Реация на нажатие кнопок копирования/вставки геометрии
 * @param type тип нажатой кнопки(copy или paste)
 * @private
 */
map.controls.HistoryControl.prototype.handleHistoryClick_ = function(type) {
	this.mapHistory.justChanged = true;
	this.mapHistory.setState(type);
};


goog.provide('map.controls.SendMailControl');




/**
 * Контрол для поиска маршрута
 * @constructor
 */
map.controls.SendMailControl = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};

    //запрос для получения данных о пользователе и его ролях
    this.requestUserWithRole = "ADM_SEM.xml#WEB50_B_USER_PRIVATE";

    var className = goog.isDef(options.className) ?
        options.className : 'map-sendmail';

    //строка, которую подставляем в общий текст при закрытии формы.
    this.longStr = '';
    var tooltipLabel = goog.isDef(options.tooltipLabel) ?
        options.tooltipLabel : gis_sendmailcontrol_19;
    var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
        'class': className + '-button',
        'type' : 'button',
        'title' : tooltipLabel
    });

    goog.events.listen(innerElement,
        goog.events.EventType.CLICK, goog.partial(
            map.controls.SendMailControl.prototype.handleSendMailClick_), false, this);

    var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
        ol.css.CLASS_CONTROL;
    if(options.noElement){
        var element = goog.dom.createDom(goog.dom.TagName.DIV, '', '');
    } else {
        var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);
    }
        goog.base(this, {
            element: element,
            target: options.target
    });
};
goog.inherits(map.controls.SendMailControl, ol.control.Control);


/**
 * Реация на нажатие "ссылка на карту"
 * @private
 */
map.controls.SendMailControl.prototype.handleSendMailClick_ = function() {
    var that = this;
    this.longStr = '';
    if(goog.isDefAndNotNull(WidgetMap.map)){
        //14.08.17 сообщение об ошибке во время генерации изображения не показываем,
        //к письму прикрепляем режим карты и ошибку по экспорту
        WidgetMap.map.once('postcompose', function(event) {
            var canvas = event.context.canvas;
            BlockingUtil.wait();
            try{
                var strData =  canvas.toDataURL('image/png');
                strData = strData.replace("data:image/png;base64,",'');
                var screenUid =  App.generateUUID();
                var fileName = screenUid + ".png";
                var requestCreateFileParams = map.controls.ExportImageControl.prototype.makeCreateImageReqParams(fileName, strData);
                App.getJsonNode(Services.createImageNode, requestCreateFileParams
                    , function reqCreateFileResult(createResultXML) {
                        var er = HTTPServiceUtil.getError(createResultXML);
		                var errorText = undefined;
                        if(er !== ''){
	                        screenUid = '';
	                        errorText = er;
                        }
                        BlockingUtil.ready();
                        that.showSendMailForm_(screenUid, errorText);
                    }
                    , function reqCreateFileFault(createFaultXML) {
		                var er = HTTPServiceUtil.getError(createFaultXML);
		                var errorText = undefined;
		                if(er !== ''){
			                errorText = er;
		                }
                        BlockingUtil.ready();
		                screenUid = '';
		                that.showSendMailForm_(screenUid, errorText);

                    });
            }
            catch(ex){
                BlockingUtil.ready();
	            that.showSendMailForm_('', ex);
               // App.errorReport("Не удалось экспортировать изображение", ex);
            }
        });
        WidgetMap.map.renderSync();
    }
};

/**
 * Показ формы составления письма с ошибкой
 * @param screenUid
 * @private
 */
map.controls.SendMailControl.prototype.showSendMailForm_ = function(screenUid, errorText) {
    var that = this;
    var currDialog = $('#sendMailDialog');
    if(currDialog.length == 0){
        $('body').append('<div id="sendMailDialog" style="overflow: hidden;"></div>');
        $('#sendMailDialog').hide();
        currDialog = $('#sendMailDialog');
    }

    var dlg = currDialog;
    dlg.load('ui/html/map/SendMailForm.html', build);

    function build() {
        dlg.dialog({
            modal: true,
            dialogClass: 'noCloseButton gsi-zindex__dialog',
            title: gis_sendmailcontrol_20,
            closeOnEscape: true,
            width: 365,
            height: 297,
            resizable: false
        });
        //заполняем данными элементы
        that.getCurrentUserData_();
        //кнопки "Отправить", "Отмена"
        $('#sendMailSend').on('click',function(){
            that.sendMail_(screenUid, errorText);
            $('#sendMailDialog').remove();
        });
        $('#sendMailCancel').on('click',function(){
            $('#sendMailDialog').remove();
        });
    }
};

//Получаем данные о текущем пользователе (вместе с его ролями)
map.controls.SendMailControl.prototype.getCurrentUserData_ = function() {
    var that = this;
    function getCurrentUserDataParams( request) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '">'+
            '<data FILTER="'+' d.USER_ID='+userId+'" />'+
            '</root>'
        };
    }

    function getCurrentUserDataResult(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.errorReport(gis_sendmailcontrol_11, resultXml, undefined, {filename:gis_filename_476, functionname:'gis_filename_476_1'});
            return;
        }
        that.longStr = '';
        //делаем разбор пришедших данных и добавляем их в mailMessage.text
        var userId = '';
        var userLogin = '';
        var userFIO = '';
        var userMail = '';
        var userStatus = '';
        var userRoles = '';
        var serverAddr = '';//URLResolver.getFullUrl("");
        var d = new Date();
        var curDateTimeStr = d.getDate()+'.'
            + d.getMonth()+'.'
            + d.getFullYear()+'  '
            + d.getHours()+':'
            + d.getMinutes()+':'
            + d.getSeconds();
        var resultXml = ($.parseXML(resultXml)).firstChild;
        var datas = resultXml.getElementsByTagName("data");
        if(datas.length>0){
            var data = datas[0];
            userId = data.getAttribute("USER_ID");
            userLogin = data.getAttribute("LOGIN");
            userFIO = goog.isNull(data.getAttribute("LASTNAME"))?'':data.getAttribute("LASTNAME")+' '+goog.isNull(data.getAttribute("FIRSTNAME"))?'':data.getAttribute("FIRSTNAME")+' '+goog.isNull(data.getAttribute("SECONDNAME"))?'':data.getAttribute("SECONDNAME");
            userMail = data.getAttribute("MAIL");
            userStatus = data.getAttribute("STATUS");
            if(!goog.isNull(data.getAttribute("ROLE_DESCR")))
                userRoles = data.getAttribute("ROLE_DESCR");
        }
        that.longStr = gis_sendmailcontrol_1;
        that.longStr += gis_sendmailcontrol_2+userId+"<br/>"+gis_sendmailcontrol_3+userLogin+"<br/>"+gis_sendmailcontrol_4+userFIO+"<br/>"
        +gis_sendmailcontrol_5+userMail+"<br/>"+gis_sendmailcontrol_6+userStatus+"<br/>";
        that.longStr += gis_sendmailcontrol_7+userRoles+"<br/>"+gis_sendmailcontrol_8+serverAddr+"<br/>"+gis_sendmailcontrol_9+curDateTimeStr+"<br/>";
        that.longStr += gis_sendmailcontrol_10;


        //сохраняем полученные данные в контролы формы
        $('#sendMailName').val(userLogin);
        $('#sendMailFIO').val(userFIO);

    }
    function getCurrentUserDataFault(resultXml) {
        BlockingUtil.ready();
        App.errorReport(gis_sendmailcontrol_11, resultXml, undefined, {filename:gis_filename_476, functionname:'gis_filename_476_2'});
    }

    BlockingUtil.wait();
    App.serverQueryXML2Node(Services.processQueryNode, getCurrentUserDataParams( this.requestUserWithRole ), getCurrentUserDataResult, getCurrentUserDataFault);

};

/**
 * Отправка письма
 * @private
 */
map.controls.SendMailControl.prototype.sendMail_ = function(screenUid, errorText) {
    //при закрытии добавляем данные в начало письма
    this.longStr = this.longStr +  $('#sendMailMessage').val();
    if(goog.isDef(WidgetMap.map))
    var center = WidgetMap.map.getView().getCenter();

    var cp = new proj4.toPoint([center[0], center[1]] );
    //случай ПКА
    if(WidgetMap.DEFAULT_PROJECTION !== GeoUtil.PROJS['EPSG:5807']){
        this.dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
        this.source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
        proj4.transform(this.source_, this.dest_, cp);
    }
    var detail = gis_sendmailcontrol_12+cp.x+gis_sendmailcontrol_21+cp.y+gis_sendmailcontrol_23;
    if(goog.isDef(WidgetMap.baseLayer))
	    detail += gis_sendmailcontrol_13+WidgetMap.baseLayer.label+gis_sendmailcontrol_22+WidgetMap.baseLayer.value+gis_sendmailcontrol_24+gis_sendmailcontrol_23;
    if(goog.isDef(errorText) && errorText != '')
	    detail += gis_sendmailcontrol_14+errorText+gis_sendmailcontrol_15;
    //Посылаем событие отправки E-mail
    function sendMailResult(result) {
        var er = HTTPServiceUtil.getError(result);
        if (er !== '') {
            App.errorReport( gis_sendmailcontrol_16+gis_sendmailcontrol_25, result, undefined, {filename:gis_filename_476, functionname:'gis_filename_476_3'});
        }
    }
    function sendMailFault(result) {
        App.errorReport(gis_sendmailcontrol_16+gis_sendmailcontrol_25, result, undefined, {filename:gis_filename_476, functionname:'gis_filename_476_4'});
    }
    var sendMailMessage =  this.longStr;
    sendMailMessage += gis_sendmailcontrol_17+"<br/><br/>"+detail+gis_sendmailcontrol_18;

    App.getJsonTextNode(Services.sendMailNode, {
        addMailTo : $('#sendMailAddress').val(),
        subject   : $('#sendMailErrorType option:selected').text(),
        fileName1  : (screenUid === '' || !goog.isDef(screenUid))?'':App.config.UPLOAD_PATH + screenUid+'.png',
        message   : sendMailMessage
    }, sendMailResult, sendMailFault);
};
goog.provide('map.controls.ManageLayersControl');


/**
 * Контрол для привязки геометрии
 * @constructor
 */
map.controls.ManageLayersControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	var className = goog.isDef(options.className) ?
		options.className : 'map-managelayers';

	this.needStyle = goog.isDef(options.needStyle) ?
		options.needStyle : true;

	this.changedStyles = [];
	var tooltip = goog.isDef(options.tooltip) ?
		options.tooltip : gis_managelayerscontrol_1;
	var innerElement = goog.dom.createDom(goog.dom.TagName.BUTTON, {
		'class': className+'-button',
		'type' : 'button',
		'title' : tooltip
	});

	goog.events.listen(innerElement,
		goog.events.EventType.CLICK, goog.partial(
			map.controls.ManageLayersControl.prototype.handleManageLayersClick_), false, this);

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;

	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, innerElement);

	goog.base(this, {
		element: element,
		target: options.target
	});
};
goog.inherits(map.controls.ManageLayersControl, ol.control.Control);

/**
 * Реация на нажатие кнопок редактиварония стиля
 * @private
 */
map.controls.ManageLayersControl.prototype.handleManageLayersClick_ = function() {
	var that = this;
	var currDialog = $('#manageLayersDialog');
	if(currDialog.length == 0){
		$('body').append('<div id="manageLayersDialog" style="overflow: hidden;"></div>');
		$('#manageLayersDialog').hide();
		currDialog = $('#manageLayersDialog');
	}

	var dlg = currDialog;
	dlg.load('ui/html/map/ManageLayersForm.html', build);
	var width = 396;
	if(!this.needStyle)
		width = 360;
	function build() {
		dlg.dialog({
			modal: true,
			title: gis_managelayerscontrol_2,
			closeOnEscape: true,
			dialogClass: 'gsi-zindex__dialog',
			width: width,
			height: 396,
			resizable: false
		});
		//заполняем данными элементы
		that.fillGrid_();
		//кнопки "Отправить", "Отмена"
		$('#manageLayersApply').on('click',function(){
			that.applyLayers_();
			$('#manageLayersDialog').remove();
		});
		$('#manageLayersCancel').on('click',function(){
			$('#manageLayersDialog').remove();
		});
	}
};

/**
 * Заполняем грид данными
 * @private
 */
map.controls.ManageLayersControl.prototype.fillGrid_ = function() {
	if(goog.isDef(WidgetMap.layerManager)){
		var layers = WidgetMap.layerManager.getAllSortedLayers();
		var treeGridLayers = [];
		for(var i=0; i<layers.length; i++){
			var obj = {LayerId:i, LayerName:layers[i].layer.sourceDescr, MapName:layers[i].layer.mapName, layer:layers[i].layer.name,visible:''+layers[i].visible,allowtext:''+layers[i].isTextAllow};
			treeGridLayers.push(obj);
		}
		var source = {
			dataType: "array",
			dataFields: [
				{ name: 'LayerID', type: 'number' },
				{ name: 'LayerName', type: 'string' },
				{ name: 'MapName', type: 'string' },
				{ name: 'layer', type: 'string'},
				{ name: "visible", type: "string" },
				{ name: 'icon', type: 'string' },
				{ name: "style", type: "string" },
				{ name: "allowtext", type: "string" }
			],
			hierarchy:{groupingDataFields:[{name: "MapName"}]},
			id: 'LayerID',
			localData: treeGridLayers
		};
		var dataAdapter = new $.jqx.dataAdapter(source, {
			loadComplete: function () {
			}
		});
		var columns = [
			{ text: gis_managelayerscontrol_3, dataField: 'LayerName', width: 295 },
			//{ text: "Name", align: "left", dataField: "name", width: 320 },
			{
				text: '', dataField: 'visible', width: 25,sortable:false,
				renderer: function (text, align, height) {
					return "<div><img id='manageLayersGridEyeHeaderImg' class='manageLayersGridEyeOn' style='margin-left: 2px;margin-top: 1px;' src='/ui/images/eye.png'/></div>";
				},
				cellsRenderer: function (rowKey, dataField, value, data) {
					if(value == 'true'){
						return "<div><input type='checkbox' style='margin-left: 5px;' onchange='map.controls.ManageLayersControl.prototype.setVisible(this,"+rowKey+")' checked></div>";
					}
					else{
						return "<div><input type='checkbox' style='margin-left: 5px;' onchange='map.controls.ManageLayersControl.prototype.setVisible(this,"+rowKey+")'></div>";
					}
				}
			},
			{
				text: '', dataField: 'allowtext', width: 25,sortable:false,
				renderer: function (text, align, height) {
					return "<div><img id='manageLayersAllowTextImg' class='manageLayersAllowTextImg' style='margin-left: 3px;margin-top: 1px;' src='/ui/images/font_icon.png'/></div>";
				},
				cellsRenderer: function (rowKey, dataField, value, data) {
					if(value == 'true'){
						return "<div><img style='width:20px;height:20px;' onclick='map.controls.ManageLayersControl.prototype.allowText(this,"+rowKey+")' src='/ui/images/font_icon.png' title='Скрыть подпись' /></div>";
					}
					else{
						return "<div><img style='opacity: 0.3;width:20px;height:20px;' onclick='map.controls.ManageLayersControl.prototype.allowText(this,"+rowKey+")' src='/ui/images/font_icon.png' title='Показать подпись' /></div>";
					}
				}
			}
		];
		if(this.needStyle){
			columns.push(
				{
					text: '', dataField: 'style', width: 25,sortable:false,
					renderer: function (text, align, height) {
						return "<div><img id='manageLayersEditStyleImg' class='manageLayersEditStyleImg' style='margin-left: 5px;margin-top: 2px;' src='/ui/images/editStyle.png'/></div>";
					},
					cellsRenderer: function (rowKey, dataField, value, data) {
						return "<div><img style='width:16px;height:16px;' onclick='map.controls.ManageLayersControl.prototype.editStyle(this,"+rowKey+")' src='/ui/images/editStyle.png' title='Редактировать стиль' /></div>";
					}
				})
		}
		$("#manageLayersGrid").jqxTreeGrid(
			{
				source: dataAdapter,
				altRows: true,
				sortable: true,
				width: 393,
				height: 332,
				columnsResize: false,
				localization: getLocalization('ru'),
				theme:'gis-blue-treegrid',
				icons: function (rowKey, rowData) {
					var level = rowData.level;
					if (level == 0) {
						return "/ui/images/folder_icon.png";
					}
					return false;
				},
				checkboxes: false,
				ready: function () {
					//$("#manageLayersGrid").jqxTreeGrid('expandRow', '1');
					//$("#manageLayersGrid").jqxTreeGrid('expandRow', '2');
				},
				columns: columns
			});
		$("#manageLayersGridEyeHeaderImg").click(function() {
			map.controls.ManageLayersControl.prototype.setAllVisible();
		});


		$("#manageLayersGrid .iconscontainer").remove();
	}
};

/**
 * Смена стиля для слоя с выбором топологии
 */
map.controls.ManageLayersControl.prototype.editStyle = function(img, rowKey){
	var that = this;
	//если видимость слоя выключили, то никаких реакций на кнопки не будет
	var item = $("#manageLayersGrid").jqxTreeGrid('getRow',rowKey);
	var errText = gis_managelayerscontrol_4;
	if(item.visible=='false'){
		App.confirmDialog(errText,null,{title:gis_core_1});
		return;
	}
	else{
		//если слой видимый, но данные ещё загружаются, то игнорируем
		var layer = WidgetMap.layerManager.getLayerByName(item.layer);
		if(goog.isDef(layer) && goog.isDef(layer.layer) && layer.layer.dataReady_==false){
			App.confirmDialog(errText,null,{title:gis_core_1});
			return;
		}

	}

	var row = $("#manageLayersGrid").jqxTreeGrid('getRow',rowKey);
	var layer = WidgetMap.layerManager.getLayerByName(row.layer);
	var layerStyleQuery = layer.layerQueryId.replace('_Layers.xml','_STYLE.xml');
	var dataRequest="ADM_SEM.xml#EDIT_STYLE_XML";
	//Получение описания всех слоев карты

	//Запрос получения описания стилей по имени файла стилей и ID стиля слоя (иначе попадут стили не от этого слоя)
	function getLayerStylesReqParams(styleFileName, styleId) {
		return {
			getSchema: false,
			descrId: dataRequest,
			toElements: false,
			descrType: 'select',
			data: '<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">'+
			'<data file="'+styleFileName+'" dataId="'+styleId+'"/>'+
			'</root>'
		};
	}
	//забираем все стили, которые связаны со слоем
	var styles = WidgetMap.layerManager.getAllStylesForLayerObj(layerStyleQuery,row.layer);
	//TODO надо теперь по этому массиву отсеить те, геометрий для которых нет
	var newStyles = this.getAllStylesForLayerWithGeo(row.layer, styles);

	var i = 0;
	for (i = 0; i < newStyles.length; i++) {
		newStyles[i].iconHtml = this.formatHref(newStyles[i]);
	}
	this.openForm(newStyles,layer.layer.drawTypes);
};
map.controls.ManageLayersControl.prototype.getAllStylesForLayerWithGeo = function(layerName, styles){
	var lay = WidgetMap.layerManager.getLayerByName(layerName);
	var resArr = [];
	var o;
	for(o in globalPointsLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['point'][sId])){
			resArr.push(styles['point'][sId]);
			styles['point'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['point'][layerName])){
				resArr.push(styles['point'][layerName]);
				delete styles['point'][layerName];
				continue;
			}

		}
	}
	for(o in globalLinesLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['line'][sId])){
			resArr.push(styles['line'][sId]);
			delete styles['line'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['line'][layerName])){
				resArr.push(styles['line'][layerName]);
				delete styles['line'][layerName];
				continue;
			}

		}
	}
	for(o in globalPolygonsLabels_){
		//находим все объекты
		if(o.split('/')[0] != layerName)
			continue;
		var sId = o.replace('/','_');
		if(goog.isDef(styles['polygon'][sId])){
			resArr.push(styles['polygon'][sId]);
			delete styles['polygon'][layerName];
			continue;
		}
		else{
			if(goog.isDef(styles['polygon'][layerName])){
				resArr.push(styles['polygon'][layerName]);
				delete styles['polygon'][layerName];
				continue;
			}
		}
	}
	return resArr;
	//lay.layer
	//globalPointsLabels_
};

map.controls.ManageLayersControl.prototype.openForm = function(dataArrr,drawTypes){
	var that = this;
	var dataArr = dataArrr;
	var selectedTopology = '';

	var currDialog = $('#editStyleTypeDialog');
	var source ={
		localdata: dataArr,
		datatype: "array"
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	if(true || currDialog.length == 0){
		$('body').append('<div id="editStyleTypeDialog" style="overflow: hidden;"></div>');
		currDialog = $('#editStyleTypeDialog');
		var dlg = currDialog;
		dlg.load('ui/html/map/EditStyleTypeForm.html', build);

		function build() {
			dlg.dialog({
				modal: true,
				dialogClass: 'noCloseButton gsi-zindex__dialog',
				title: gis_managelayerscontrol_7,
				closeOnEscape: false,
				width: 290,
				height: 195,
				resizable: false
			});
			$('#editStyleTypeDrop').jqxDropDownList({ source: dataAdapter, theme:'gis-blue-slider',
				selectedIndex: -1,
				placeHolder:gis_managelayerscontrol_8,
				disabled:false,
				displayMember: "descr",
				valueMember: "sId",
				width: 287, height: 20,
				enableBrowserBoundsDetection: true,
				dropDownWidth: 287,
				dropDownHeight: 187,
				renderer: function (index, label, value) {
					//var item = $('#editStyleTypeDrop').jqxDropDownList('getItem',index).originalItem;
					var datarecord = dataArr[index];
					var table = '<div>'+datarecord.iconHtml+label+'</div>';
					return table;
				}
			}).on('select', function (event) {
				var args = event.args;
				if (goog.isDef(args)) {
					var item = event.args.item;
					if(!goog.isNull(item))
						$('#editStyleTypeApply').prop('disabled', false).removeClass('disableButtonState');
				}
			});
			//var isPoint = drawTypes.indexOf('point')!=-1;
			//var isLine = drawTypes.indexOf('line')!=-1;
			//var isPolygon = drawTypes.indexOf('polygon')!=-1;
			var isPoint = drawTypes.indexOf('point')!=-1;
			var isLine = drawTypes.indexOf('line')!=-1;
			var isPolygon = drawTypes.indexOf('polygon')!=-1;
			$('#editStyleTypeTopologyPoint').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isPoint})
				.bind('change', function (event) {
					var checked = event.args.checked;
					if(checked){
						selectedTopology = 'Point';
						that.updateEditStyleTypeDrop_('point',dataArrr);
					}

				});
			$('#editStyleTypeTopologyLine').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isLine})
				.bind('change', function (event) {
					var checked = event.args.checked;
					if(checked){
						selectedTopology = 'LineString';
						that.updateEditStyleTypeDrop_('line',dataArrr);
					}
				});
			$('#editStyleTypeTopologyPolygon').jqxRadioButton({groupName:"style_topology",theme:'gis', disabled: !isPolygon})
				.bind('change', function (event) {
					var checked = event.args.checked;
					if(checked){
						selectedTopology = 'Polygon';
						that.updateEditStyleTypeDrop_('polygon',dataArrr);
					}
				});
			$('#editStyleTypeApply').on('click',function(){
				that.applyStyle_(selectedTopology);
				$('#editStyleTypeDialog').remove();
			});
			$('#editStyleTypeApply').prop('disabled', true).addClass('disableButtonState');


			$('#editStyleTypeCancel').on('click',function(){
				$('#editStyleTypeDialog').remove();
			});
			if(isPolygon)
				$('#editStyleTypeTopologyPolygon').jqxRadioButton('check');
			if(isLine)
				$('#editStyleTypeTopologyLine').jqxRadioButton('check');
			if(isPoint)
				$('#editStyleTypeTopologyPoint').jqxRadioButton('check');
		}
	}
	else{
		$('#editStyleTypeDrop').jqxDropDownList({ source: dataAdapter});
		$('#editStyleTypeDialog').dialog('open');
	}


};

/**
 * Обновляем список в зависимости от топологии
 * @param topologyType
 * @private
 */
map.controls.ManageLayersControl.prototype.updateEditStyleTypeDrop_ = function(topologyType,originalArray){
	var newArr = [];
	var i = 0;
	switch(topologyType){
		case 'point':
			for(i; i<originalArray.length;i++){
				if(goog.isDef(originalArray[i].pointObj))
					newArr.push(originalArray[i]);
			}
			break;
		case 'line':
			for(i; i<originalArray.length;i++){
				if(!goog.isDef(originalArray[i].polyObj))
					newArr.push(originalArray[i]);
			}
			break;
		case 'polygon':
			for(i; i<originalArray.length;i++){
				if(goog.isDef(originalArray[i].polyObj))
					newArr.push(originalArray[i]);
			}
			break;
	}
	var source ={
		localdata: newArr,
		datatype: "array"
	};
	var dataAdapter = new $.jqx.dataAdapter(source);
	$("#editStyleTypeDrop").jqxDropDownList('clear');
	$('#editStyleTypeDrop').jqxDropDownList({ source: dataAdapter});
};


map.controls.ManageLayersControl.prototype.applyStyle_ = function(topologyType){
	if(topologyType=='')return;
	var that = this;
	var objectType = $('#editStyleTypeDrop').jqxDropDownList('getSelectedItem').originalItem;

	WidgetMap.editStyleForm = new EditStyleForm({
		topologyType:topologyType,
		objectType:objectType,
		applyCallback:function(style){
			WidgetMap.managelayersControl.changedStyles.push(style);
		}
	});
	WidgetMap.editStyleForm.build();
};


//Функция сохранения атрибутов в объект
map.controls.ManageLayersControl.prototype.getObjectWithElementAttrs = function getObjectWithElementAttrs(elem) {
	var resultObj = {};
	if (elem!=undefined && elem!=null && elem.attributes!=undefined) {
		for (var ii = 0; ii < elem.attributes.length; ii++) {
			var attr = elem.attributes[ii];
			if (attr.specified == true) {
				resultObj[attr.name] = attr.value;
			}
		}
	}
	return resultObj;
};


//Функция предпросмотра стиля в иконке аналогично рубрикатору
map.controls.ManageLayersControl.prototype.parseTreeData = function parseTreeData(xmlElement,params,parent) {
	switch(xmlElement[0].tagName){
		case 'Style':
			if(!params.first)return;
			xmlElement.children().each(function(){parseTreeData($(this),params,xmlElement);});
			return;
			break;
		case 'LineStyle':
			if(!params.first)return;
			//условие, если у парента есть polyStyle, то продолжаем парсить, чтобы найти polystyle
			if(parent!=undefined && parent.children('PolyStyle').length>0){
				params.first = true;
			} else {
				params.first = false;
				xmlElement.children().each(function(){parseTreeData($(this),params);});
				params.iconHtml = '<div class="divIcon divIconLineStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: '+params.color+'"></div>';
			}
			break;
		case 'PolyStyle':
			if(!params.first)return;
			params.first = false;
			xmlElement.children().each(function(){parseTreeData($(this),params);});
			if(params.fill == '1')
				params.iconHtml = '<div class="divIcon divIconPolyStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: '+params.color+'"></div>';
			else
				params.iconHtml = '<div class="divIcon divIconPolyStyle divIconPolyStyleBorder gridButton" style="margin-right: 3px; display: inline-block;"></div>';
			break;
		case 'Icon':
			if(!params.first)return;
			params.first = false;
			xmlElement.children().each(function(){parseTreeData($(this),params);});
			if(params.href != undefined)
				params.iconHtml = '<div style="height: 20px; float: left;"><img src="./'+params.href+'" alt="'+params.alt+'" style="margin-right: 3px;"/></div>';
			break;
		case 'IconStyle':
			if(!params.first)return;
			xmlElement.children().each(function(){parseTreeData($(this),params);});
			if((params.form != undefined)&&(params.form != 'bitmap')) {
				var styleText = 'margin-right: 3px; display: inline-block; background-color: '+params.color+'; ';
				if (params.size != undefined) styleText += 'width:'+params.size+'px; height:'+params.size+'px;';
				params.iconHtml = '<div class="divIcon divIconStyle'+params.form+' gridButton" style="'+styleText+'"></div>';
			}
			break;
		case 'color':params['color'] = '#'+xmlElement.text().substr(2);break;
		case 'fill':params['fill'] = xmlElement.text();break;
		case 'width':params['width'] = xmlElement.text();break;
		case 'href':params['href'] = xmlElement.text();break;
		case 'form':params['form'] = xmlElement.text();break;
		case 'size':params['size'] = xmlElement.text();break;
	}
};

//Функция предпросмотра стиля в иконке аналогично рубрикатору
map.controls.ManageLayersControl.prototype.formatHref = function (object) {
	var topology = 'none';
	if(goog.isDef(object.pointObj))
		topology = 'point';
	if(goog.isDef(object.lineObj))
		topology = 'line';
	if(goog.isDef(object.polyObj))
		topology = 'polygon';

	switch(topology){
		case 'line':
			return '<div class="divIcon divIconLineStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: #'+object.lineObj.color.substring(2)+'"></div>';
			break;
		case 'polygon':
			if(object.fill == '1')
				return '<div class="divIcon divIconPolyStyle gridButton" style="margin-right: 3px; display: inline-block; background-color: #'+object.polyObj.color.substring(2)+'"></div>';
			else
				return '<div class="divIcon divIconPolyStyle divIconPolyStyleBorder gridButton" style="margin-right: 3px; display: inline-block;"></div>';
			break;
		case 'point':
			if((object.pointObj.form != undefined)&&(object.pointObj.form != 'bitmap')) {
				var styleText = 'margin-right: 3px; display: inline-block; background-color: #'+object.pointObj.color.substring(2)+'; ';
				if (object.size != undefined) styleText += 'width:'+object.pointObj.size+'px; height:'+object.pointObj.size+'px;';
				return '<div class="divIcon divIconStyle'+object.pointObj.form+' gridButton" style="'+styleText+'"></div>';
			}
			else if(object.pointObj.href != undefined)
				return '<div style="height: 20px; float: left;"><img src="./'+object.pointObj.href+'" style="margin-right: 3px;"/></div>';
			break;
	}
};



//Сортировка по свойству объекта (c учетом строкового/числового полей)
map.controls.ManageLayersControl.prototype.dynamicSort = function dynamicSort(property) {
	return function (obj1,obj2) {
		//Исправление для отсутствующего в данных поля - если поля нет, автоматически считаем это значение меньше
		if (obj1==undefined || obj1==null || !obj1.hasOwnProperty(property)) return -1;
		if (obj2==undefined || obj2==null || !obj2.hasOwnProperty(property)) return 1;
		//Внутренняя функция сортировки учитывает, что значения могут быть числовыми
		var value1 = obj1[property].toLowerCase();
		var value2 = obj2[property].toLowerCase();
		try {
			var tmpvalue1 = parseFloat(value1);
			var tmpvalue2 = parseFloat(value2);
			if (!isNaN(tmpvalue1) && !isNaN(tmpvalue2)) {
				if (tmpvalue1 < tmpvalue2) { return -1; }
				if (tmpvalue1 > tmpvalue2) { return 1; }
			} else {
				if (value1 < value2) { return -1; }
				if (value1 > value2) { return 1; }
			}
		} catch (error) {}
		return 0;
	}
};

/**
 * Смена видимости для всех слоёв
 */
map.controls.ManageLayersControl.prototype.setAllVisible = function(){
	//console.log('fdf');
	/*var opacity = ''+$('manageLayersGridEyeHeaderImg').css('opacity');
	if(opacity == '0.3')
		$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'allowtext','true');
	else
		$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'allowtext','false');*/
};

/**
 * Смена видимости для конкретного слоя
 * @param input чекбокс
 * @param rowKey id ключа
 */
map.controls.ManageLayersControl.prototype.setVisible = function(input, rowKey){
	//TODO сделать сдесь для слоёв загрузку данных, если они до этого не грузились
	//устанавливаем значение
	var isChecked = ''+$(input).prop('checked');
	$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'visible',isChecked);
	var item = $("#manageLayersGrid").jqxTreeGrid('getRow',rowKey);
	var layer = WidgetMap.layerManager.getLayerByName(item.layer);
	if(goog.isDef(layer) && goog.isDef(layer.layer)){
		if(item.visible == 'true'){
			if(goog.isDef(layer.layer.setVisible)){//если слой векторный
				WidgetMap.layerManager.enableLayer(item.layer);
				layer.layer.setVisible(true);
			}
			else
				layer.visible = true;
		}
		else{
			if(goog.isDef(layer.layer.setVisible)) {
				WidgetMap.layerManager.disableLayer(item.layer);
				layer.layer.setVisible(false);
			}
			else
				layer.visible = false;
		}
	}
};

/**
 * Вкл/выкл подписи на карте для слоя
 * @param img
 * @param rowKey
 */
map.controls.ManageLayersControl.prototype.allowText = function(img, rowKey){
	//устанавливаем значение
	//если видимость слоя выключили, то никаких реакций на кнопки не будет
	var item = $("#manageLayersGrid").jqxTreeGrid('getRow',rowKey);
	/*if(false && item.visible=='false')return;
	else{
		//если слой видимый, но данные ещё загружаются, то игнорируем
		var layer = WidgetMap.layerManager.getLayerByName(item.layer);
		if(goog.isDef(layer) && goog.isDef(layer.layer) && layer.layer.dataReady_==false)
			return;
	}*/

	var opacity = ''+$(img).css('opacity');
	if(opacity == '0.3')
		$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'allowtext','true');
	else
		$("#manageLayersGrid").jqxTreeGrid('setCellValue',rowKey,'allowtext','false');
};


/**
 * Применяем видимость и показ подписей к слоям
 * @private
 */
map.controls.ManageLayersControl.prototype.applyLayers_ = function() {
	var allLayers = WidgetMap.layerManager.getAllLayers();
	var rows = $("#manageLayersGrid").jqxTreeGrid('getRows');
	var i = 0,j=0;

	//проходим по исправленным стилям
	var s = 0;
	for(s;s<this.changedStyles.length;s++){
		//находим в layerManager стиль и подменяем
		var cStyle = this.changedStyles[s];
		var origStyle = WidgetMap.layerManager.getStyleByNameAndTypeWOZoom(cStyle.sId,cStyle.topologyType);
		var layer = WidgetMap.layerManager.getLayerByName(cStyle.layerId);
		if(!goog.isNull(origStyle)){
			if(goog.isArray(cStyle.style))
				origStyle.style = cStyle.style.reverse();
			else{
				var cStyleText = cStyle.style.getText();
				if(!goog.isNull(cStyleText)){
					var newAlign = 'center';
					if(cStyleText.getOffsetX()<0) newAlign = 'left';
					else if(cStyleText.getOffsetX()>0) newAlign = 'right';
					var newBaseLine = 'middle';
					if(cStyleText.getOffsetY()<0) newBaseLine = 'top';
					else if(cStyleText.getOffsetY()>0) newBaseLine = 'bottom';

					origStyle.text.align = newAlign+'|'+newBaseLine;
					origStyle.text.bold = cStyleText.getFont().indexOf('bold') != -1?'1':'0';
					origStyle.text.italic = cStyleText.getFont().indexOf('italic') != -1?'1':'0';
					if(!goog.isNull(cStyleText.getFill())){
						if(goog.isArray(cStyleText.getFill().getColor()) && cStyleText.getFill().getColor().length == 4){
							var r = cStyleText.getFill().getColor()[0].toString(16);
							if(r.length==1)r='0'+r;
							var g = cStyleText.getFill().getColor()[1].toString(16);
							if(g.length==1)g='0'+g;
							var b = cStyleText.getFill().getColor()[2].toString(16);
							if(b.length==1)b='0'+b;
							origStyle.text.color = 'ff'+r+g+b;
						}
						else
							origStyle.text.color = cStyleText.getFill().getColor();
					}
					var kk=0;
					var splittedFont = cStyleText.getFont().split(' ');
					for(;kk<splittedFont.length;kk++){
						if(splittedFont[kk].indexOf('px')!=-1){
							origStyle.text.fontSize = splittedFont[kk].replace('px','');
							break;
						}
					}
					origStyle.text.fontFamily = cStyleText.getFont().substring(cStyleText.getFont().indexOf('px ')+3);
				}
				origStyle.style = cStyle.style;
			}

		}
		if(goog.isDef(layer.layer.featureProjLayer)){
			layer.layer.featureProjLayer.getSource().setStyle(undefined);
			/*WidgetMap.layerManager.setStyleForLayer(cStyle.sId,cStyle.topologyType);
			var i = 0;
			for (i = 0; i < styles.length; i++) {
				styles[i].iconHtml = this.formatHref(styles[i]);
			}*/
		}
	}
	for(i in rows){
		j = 0;
		for(j;j<rows[i].records.length;j++){
			//если менялись данные, то слой обновляем
			var layer = WidgetMap.layerManager.getLayerByName(rows[i].records[j].layer);
			if(goog.isDef(layer)){
				var isCurrAllow = rows[i].records[j].allowtext=='true';
				if(isCurrAllow==layer.isTextAllow)
					continue;
				if(layer.layer instanceof map.layer.RasterLayer)
					return;
				/*if(rows[i].records[j].visible == 'true'){
					WidgetMap.layerManager.enableLayer(rows[i].records[j].layer);
					layer.layer.setVisible(true);
				}
				else{
					WidgetMap.layerManager.disableLayer(rows[i].records[j].layer);
					layer.layer.setVisible(false);
				}
				*/
				//if(layer.isTextAllow == false){
				//layer.layer.featureProjLayer.setStyle(undefined);
					//layer.layer.setVisibleText(layer.isTextAllow);
				//}
				layer.isTextAllow = rows[i].records[j].allowtext=='true';
				layer.layer.setVisibleText(layer.isTextAllow);
				layer.layer.featureProjLayer.getSource().changed();
				/*var newf = new ol.Feature(new ol.geom.Point([-100,-100]));
				layer.layer.featureProjLayer.getSource().getSource().addFeature(newf);
				layer.layer.featureProjLayer.getSource().getSource().removeFeature(newf);*/

			}

		}


	}

};



goog.provide('map.controls.PreviousSiteControl');

/**
 * Контрол перехода на предыдущую версию сайта
 * @constructor
 */
map.controls.PreviousSiteControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};

	var className = goog.isDef(options.className) ?
		options.className : 'map-prevsite';
	this.innerElement = undefined, this.descriptionElement = undefined;
	if(App.prevSite !== '')
		this.innerElement = goog.dom.createDom(goog.dom.TagName.A, {
			name: 'prevsite',
			href: '',
			target:'_self',
			className : className+'-label'
		},gis_prevsitecontrol_1);
	else
		className+= '-only-version';

	var versionElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
		name: 'siteversion',
		className : 'map-version-label'
	},gis_prevsitecontrol_2+App.config.SYSTEM_NAME);

	if(options.description){
		this.descriptionElement = goog.dom.createDom(goog.dom.TagName.LABEL, {
			name: 'description',
			className : 'map-description-label'
		}, options.description);
	}


	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;

	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, versionElement, this.innerElement, this.descriptionElement);

	goog.base(this, {
		element: element,
		target: options.target,
		render: map.controls.PreviousSiteControl.prototype.handleMapPostrender
	});
};

goog.inherits(map.controls.PreviousSiteControl, ol.control.Control);


/**
 * @inheritDoc
 */
map.controls.PreviousSiteControl.prototype.handleMapPostrender = function(mapEvent) {
	if(!goog.isDefAndNotNull(this.map_) || this.innerElement === undefined)
		return;
	var view = this.map_.getView();
	var center = view.getCenter();
	var zz = this.map_.getView().getZoom();
	var cp = new proj4.toPoint([center[0], center[1]] );
	this.dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
	this.source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
	proj4.transform(this.source_, this.dest_, cp);
	var coord_x = cp.x.toPrecision(12);
	var coord_y = cp.y.toPrecision(12);
	var currUrl = document.URL;
	var splittedUrl  = currUrl.split('#')[0].split('?');
	var smallurl = splittedUrl[0];
	var urlParams = splittedUrl[1];
	var splittedParams = urlParams.split('&');
	//отсекаем из url параметры ненужные
	for(var i=splittedParams.length-1; i>=0;i--){
		if(!(splittedParams[i].indexOf('task=') != -1 || splittedParams[i].indexOf('mdl=') != -1 )){
			splittedParams.splice(i,1);
		}
	}
	//urlParams = splittedParams.join('&');
	var prevTask = App.prevSite;
	urlParams = '?';
	if(prevTask !== undefined && prevTask.indexOf('task=') !== -1 && prevTask.indexOf('mdl=') !== -1)
		urlParams = '';
	var prevTask = App.prevSite;
	var selObjects = (goog.isDef(WidgetMap.mapSelectedObject))?'&objects='+WidgetMap.mapSelectedObject:'';
	var prevLink = prevTask/*smallurl*/+urlParams+'&ll='+coord_x+','+coord_y+'&z='+zz+selObjects;
	this.innerElement.setAttribute('href',prevLink+Auth.hash);
};
goog.provide('map.controls.FastTaskAccessControl');

/**
 * Контрол для быстрого открытия задачи, указанной в
 * @constructor
 */
map.controls.FastTaskAccessControl = function(opt_options){
	var options = goog.isDef(opt_options) ? opt_options : {};


	this.fastAccessConfig = goog.isDef(options.fastAccessConfig) ?
		options.fastAccessConfig : undefined;
	/*this.grids = [];
	this.tasks = [];
	if(this.fastAccessConfig){
		var grids = this.fastAccessConfig.grid;
		var tasks = this.fastAccessConfig.tasks;
		if(grids && grids.length)
			this.grids = grids;
		if(tasks && tasks.length)
			this.tasks = tasks;
	}*/
	this.taskUrl = goog.isDef(options.url) ?
		options.url : undefined;

	this.taskText = goog.isDef(options.text) ?
		options.text : '';

	this.taskTarget = goog.isDef(options.target) ?
		options.target : '_blank';

	var className = goog.isDef(options.className) ?
		options.className : 'map-fast-task-access';

	var tooltip = goog.isDef(options.tooltip) ?
		options.tooltip : gis_fasttaskaccesscontrol_1;
	var taskElement = undefined;
	/*if(this.grids &&  this.grids.length > 0){
		var grid = this.grids[0];
		taskElement = goog.dom.createDom(goog.dom.TagName.A, {
			'class': className + '-link',
			'title' : grid.title,
			'target': this.taskTarget
		}, grid.title );
		goog.events.listen(taskElement,
			goog.events.EventType.CLICK, goog.partial(
				map.controls.FastTaskAccessControl.prototype.handleClick_), false, this);
	}*/
		taskElement = goog.dom.createDom(goog.dom.TagName.A, {
			'class': className + '-link',
			'title' : tooltip,
			'href': this.taskUrl + Auth.hash,
			'target': this.taskTarget
		}, this.taskText );

	if(!this.taskUrl || !this.taskText){
		this.taskElement = undefined;
	}

	/**/

	var cssClasses = className + ' ' + ol.css.CLASS_UNSELECTABLE + ' ' +
		ol.css.CLASS_CONTROL;
	var element = goog.dom.createDom(goog.dom.TagName.DIV, cssClasses, taskElement);

	goog.base(this, {
		element: element,
		target: options.target
	});

};
goog.inherits(map.controls.FastTaskAccessControl, ol.control.Control);


/**
 * @private
 */
map.controls.FastTaskAccessControl.prototype.handleClick_ = function() {
	var pArr =  [
		{name: "template", value: "PODS_STO_SHURF_PLAN_LIST"},
		{name: "title", value: "'Участки пропуска снарядов'"},
		{name: "fullLayerId", value: "STO_Layers.xml*PODS_STO_SHURF_PLAN"}]
	openNewWindow(location.href, 'gridWindow', 'GRID', pArr);

};
/*** GLOBAL VARS  ***/
try{
	goog.provide('map.render.canvas.Replay');
}
catch(ex){}
try{
	goog.provide('map.renderer.vector');
}
catch(ex){}

var _TRANSFORM = {};
var _CONTEXT = undefined;
var _LABELS = [];
MAP_MATRIX_DX = 1;
MAP_MATRIX_DY = 1;
var _dx = MAP_MATRIX_DX;
var _dy = MAP_MATRIX_DY;
var _visibleMatrix = {};
var _visibleTextMatrix = {};
ol.render.canvas.BATCH_CONSTRUCTORS_ = {
	'Image': (map && map.render && map.render.canvas)?map.render.canvas.ImageReplay:ol.render.canvas.ImageReplay,
	'LineString': (map && map.render && map.render.canvas)?map.render.canvas.LineStringReplay:ol.render.canvas.LineStringReplay,
	'Polygon': (map && map.render && map.render.canvas)?map.render.canvas.PolygonReplay:ol.render.canvas.PolygonReplay,
	'Text': (map && map.render && map.render.canvas)?map.render.canvas.TextReplay:ol.render.canvas.TextReplay,
};
ol.renderer.vector.GEOMETRY_RENDERERS_['Point'] = (map && map.renderer && map.renderer.vector)?
	map.renderer.vector.renderPointGeometry_: ol.renderer.vector.renderPointGeometry_;
ol.renderer.vector.GEOMETRY_RENDERERS_['MultiPoint'] = (map && map.renderer && map.renderer.vector)?
	map.renderer.vector.renderMultiPointGeometry_:ol.renderer.vector.renderMultiPointGeometry_;
ol.renderer.vector.GEOMETRY_RENDERERS_['MultiLineString'] = (map && map.renderer && map.renderer.vector)?
	map.renderer.vector.renderMultiLineStringGeometry_:ol.renderer.vector.renderMultiLineStringGeometry_;
ol.renderer.vector.GEOMETRY_RENDERERS_['MultiPolygon'] =(map && map.renderer && map.renderer.vector)?
	map.renderer.vector.renderMultiPolygonGeometry_:ol.renderer.vector.renderMultiPolygonGeometry_;

var MAP_TYPE = {
	MAP: 'map',
	CAS: 'cas',
	SCHEMA: 'schema'
}

var CURRENT_MAP_TYPE = MAP_TYPE.MAP;
goog.provide('ru.corelight.classes.map');
ru.corelight.classes.map.BaseWidget = function(opt_options){
	this.map = undefined;
	this.kinetic = null;//new ol.Kinetic(-0.005, 0.05, 100);//дефолтные настройки перемещения карты
	//список предзагруженных ЛПУ, чтобы фильтры не подгружали данные;
	this.preloadLpuValues = undefined;
	//теже предзагруженные ЛПУ, только в виде справочника с ключом по коду ЛПУ
	this.preloadLpuValuesDict = {};
	//массив дефолтных идентификаторов ЛПУ для сверки с текущим. Если не совпадают с пользовательскими - гео данные из БД всегда
	this.defaultLpuIds = [];

	this.config = null;
	this.mapHistory = undefined;

	//текущая выбранная кнопка
	this.selectedMapButton = undefined;
	this.baseLayersControl = undefined;
	//текущий контрол для рисования, чтобы могли из любых мест его удалить
	this.drawControl = undefined;
	this.panControl = undefined;
	this.managelayersControl = undefined;
	this.mapInfoControl = undefined;
}

ru.corelight.classes.map.BaseWidget.prototype.build = function(){

}
ru.corelight.classes.map.BaseWidget.prototype.regenerateMatrix = function(layerId){
	//Значение ширины, которое добавляется к матрице слева и справа,
	//чтобы при разрядке точечные объекты не пропадали как только их центр выйдет за границы карты
	var matrixAddWidth = _dx;
	//Значение высоты, которое добавляется к матрице сверху и снизу,
	//чтобы при разрядке точечные объекты не пропадали как только их центр выйдет за границы карты
	var matrixAddHeight = _dy;
	//Расширяем матрицу при генерации, чтобы не происходила разрядка точечных объектов, центр которых вышел за границу но часть объекта должна отображаться
	var mapSize = WidgetMap.map.getSize();
	var i = Math.ceil((mapSize[0]*2 + matrixAddWidth*2) / _dx);
	var j = Math.ceil((mapSize[1]*2 + matrixAddHeight*2) / _dy);
	_visibleMatrix[layerId] = new Array(i);
	var k = 0;
	for (k; k<i; k++){
		_visibleMatrix[layerId][k] = new Array(j);
	}
	if(layerId == 'label'){
		i = Math.ceil((mapSize[0]*2 + matrixAddWidth*2) / _dx);
		j = Math.ceil((mapSize[1]*2 + matrixAddHeight*2) / _dy);
		_visibleTextMatrix[layerId] = new Array(i);
		var k = 0;
		for (k; k<i; k++){
			_visibleTextMatrix[layerId][k] = new Array(j);
		}
	}
};


ru.corelight.classes.map.BaseWidget.prototype.updateTopFilter = function (params) {
	var layerId = '';
	var j = 0;
	for (j; j < params.length; j++) {
		var curParam = params[j];
		if(curParam['name'] === 'layerId')
			layerId = curParam['value'];
	}
	for (j = 0; j < params.length; j++) {
		var curParam = params[j];
		if (!curParam.hasOwnProperty('name')) continue;
		var newFilters = [];
		var curFilters;
		switch (curParam['name']) {
			case 'filter':
			case 'roughFilter':
				curFilters = curParam['value'].split('|');
				for (var i = 0; i < curFilters.length; i++) {
					var nameValArr = curFilters[i].split(':');
					if (nameValArr && nameValArr.length == 2) {
						var newFilterObj = {name: nameValArr[0], value: nameValArr[1], layerName: layerId};
						newFilters.push(newFilterObj);
					}
				}

				if (curParam['name'] == 'filter') {
					//Переписываем массив фильтров верхнего уровня, из которых формируются запросы
					newFilters.forEach(function(val){
						if(val && val.name){
							if(WidgetMap.currentTopFilter.length == 0)
								WidgetMap.currentTopFilter = newFilters;
							else{
								var finded = false;
								for(var ni = 0; ni < WidgetMap.currentTopFilter.length; ni++){
									if(WidgetMap.currentTopFilter[ni].name !== undefined ){
										if(WidgetMap.currentTopFilter[ni].name === val.name ){
											WidgetMap.currentTopFilter[ni].value = val.value;
											finded = true;
											break;
										}
									}
								}
								if(!finded)
									WidgetMap.currentTopFilter.push(val);
							}
						}
						//WidgetMap.currentTopFilter = newFilters;
					});

				}
				else if (curParam['name'] == 'roughFilter') {
					//Переписываем массив фильтров среднего уровня, из которых формируются запросы
					WidgetMap.currentRoughFilter = newFilters;
				}
				break;
			case 'layerId':
				layerId = curParam['value'];
				break;
		}
	}

};

/**
 * Центрируемся на карте по экстенту
 * @param extent экстент текущей геометрии
 */
ru.corelight.classes.map.BaseWidget.prototype.centerOnMap = function(extent){
	if (App.config.MAP_CENTERING_MIN_ZOOM === undefined){
		App.errorReport(gis_core_17, 'MAP_CENTERING_MIN_ZOOM' + gis_core_18, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_13'});
		return;
	}
	var minZoom = App.config.MAP_CENTERING_MIN_ZOOM;
	if(goog.isDef(minZoom) && goog.isNumber(parseFloat(minZoom)) && parseFloat(minZoom) > 0 && WidgetMap.getZoomForExtent(extent) >= parseFloat(minZoom)){

		map.controls.FullMapControl.prototype.centerOn_(ol.extent.getCenter(extent),minZoom);
	}
	else{
		WidgetMap.map.getView().fit(extent, WidgetMap.map.getSize());
	}
};

/**
 * Получить зум для переданного экстента
 * @param extent
 * @returns {number}
 */
ru.corelight.classes.map.BaseWidget.prototype.getZoomForExtent = function(extent){
	var viewSize =  WidgetMap.map.getSize();
	var idealResolution ;//= Math.max(extent[0]/viewSize[0],extent[1] / viewSize[1]);
	var view = WidgetMap.map.getView();
	var RESOLUTION_TOLERANCE = 0.000001;
	idealResolution = Math.max(ol.extent.getWidth(extent)/ viewSize[0], ol.extent.getHeight(extent) / viewSize[1]);//view.getResolutionForExtent(extent,viewSize);
	var offset;
	var resolution = idealResolution;

	if (goog.isDef(resolution)) {
		var res, z = 0;
		do {
			res = view.constrainResolution(view.maxResolution_, z);
			if (res < resolution && Math.abs(res - resolution) > RESOLUTION_TOLERANCE) {
				offset = z;
				break;
			}
			++z;
		} while (res > view.minResolution_);
	}
	return z + view.minZoom_ - 1;//view.maxResolution_ соответствует minZoom, поэтому добавляем. И отнимаем 1, как во флеш
};

/**
 * Получить зум для переданной resolution
 * @param resolution
 * @returns {number}
 */
ru.corelight.classes.map.BaseWidget.prototype.getZoomForResolution = function(resolution){
	var offset;
	var view = WidgetMap.map.getView();
	if (goog.isDef(resolution)) {
		var res, z = 0;
		do {
			res = view.constrainResolution(view.maxResolution_, z);
			if (res == resolution) {
				offset = z;
				break;
			}
			++z;
		} while (res > view.minResolution_);
	}

	return goog.isDef(offset) ? view.minZoom_ + offset : offset;
};

ru.corelight.classes.map.BaseWidget.prototype.createVectorLayer = function(){
	//добавляем на карту векторный слой для рисования
	var source = new ol.source.Vector();
	WidgetMap.currentVectorLayer = new ol.layer.Vector({
		source: source
	});
	WidgetMap.map.addLayer(WidgetMap.currentVectorLayer);
};
/**
 * Слой для выделения объектов на карте
 *
 */
ru.corelight.classes.map.BaseWidget.prototype.addMapSelectionLayer = function(){
	if(goog.isDef(WidgetMap.map)) {
		try {
			var vector = new ol.layer.Vector({
				source: new ol.source.Vector({
				})
			});
			WidgetMap.mapSelectionLayer = vector;
			WidgetMap.map.addLayer(WidgetMap.mapSelectionLayer);
		}
		catch (ex) {
		}
	}
};

//прячем подписи по инциденту #1505
ru.corelight.classes.map.BaseWidget.prototype.hideLabels = function(layerName,objects){
	var layer = WidgetMap.layerManager.getLayerByName(layerName);
	if(goog.isDef(layer) && goog.isDef(layer.layer)){
		//проходим по всем фичам и забираем по id Объекта геометрию из _globalPointLabels,
		var features = layer.layer.featureProjLayer.getSource().getSource().getFeatures();
		var i = 0;
		var j = 0;
		var hideGeos = [];
		for(j;j<objects.length;j++){
			i = 0;
			for(i;i<features.length;i++){
				//ищем только в multiPoint
				var oId = objects[j];
				if(features[i].getGeometry().getType() == ol.geom.GeometryType.MULTI_POINT && goog.isDef(features[i].get('pointsObj')) && goog.isDef(features[i].get('pointsObj')[oId])){
					var coords = features[i].get('pointsObj')[oId].flatCoordinates;
					hideGeos.push({id:oId, unique:features[i].get('labelType')+'_'+coords[0]+'_'+coords[1]});
				}
			}
		}
		WidgetMap.hideLabelsArr = hideGeos;
		layer.layer.featureProjLayer.changed();
	}
};
/**
 * Оставить на карте выбранные объекты
 * @param layerName
 * @param layerIds
 * @param that
 */
ru.corelight.classes.map.BaseWidget.prototype.selectFeatures = function (layerName, layerIds, that, findCallback) {
	if(!checkMapExisting())
		return;
	var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
	if(goog.isDef(layerObj) && goog.isDef(layerObj.layer)) {
		if (!layerObj.layer.hasData) {//если данных нет в слое вообще
			if(findCallback)
				findCallback(false);
			else
				MapUtil.showObjectError(that, layerObj, this);
			return;
		}
		var features = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(layerObj.layer,layerIds);
		MapUtil.clearSelectionLayer();
		if(features.length == 0){
			/*if(showObjectsIsGroupButton == true)//если нажата была групповая кнопка, то не показываем ошибки
			 return;*/
			if(findCallback)
				findCallback(false);
			else
				MapUtil.showObjectError(that, layerObj, this);
		}
		else{
			if(findCallback)
				findCallback(true);
			var layer = WidgetMap.layerManager.getLayerByName(layerName);
			if(goog.isDef(layer) && goog.isDef(layer.layer))
				layer.layer.showObjectsByIds(layerIds, that.showObjectsCentering);
			//прячем подписи для слоя
			//WidgetMap.hideLabels(layerName,layerIds);
		}

	}
};
ru.corelight.classes.map.BaseWidget.prototype.selectAndCenterByFoundedGeom = function(centering){
	//добавляем массив найденных фич в слой для выделений
	//если надо, масштабируемся
	if(WidgetMap.rasterLayersFeatures.length==0)
		return;
	WidgetMap.mapSelectionLayer.getSource().addFeatures(WidgetMap.rasterLayersFeatures);
	WidgetMap.rasterLayersFeatures = [];
	//зуммируемся к ним
	var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
	if(centering){
		WidgetMap.centerOnMap(extent);
	}
};
ru.corelight.classes.map.BaseWidget.prototype.setStartupScenario = function(){
	try{
		if (goog.isDefAndNotNull(WidgetMap.config)) {
			var tree = WidgetMap.config.tree;
			if(tree && tree.trees && tree.trees.length > 0){
				var startupScenario = tree.trees[0].startupScenario;
				if(startupScenario){
					var openLayers =  startupScenario.openLayers;
					if(openLayers){
						WidgetMap.startupLayers = openLayers;
						//меняем порядок слодования, чтобы при добавлении в список через pop добавлялся первый
						//WidgetMap.startupLayers =  WidgetMap.startupLayers.reverse();
					}
				}
			}
		}
		//если выполниласьт обработка сценария с показом слоёв
		if(App.scenarioParams && App.scenarioParams.vars){
			WidgetMap.startupLayers = App.scenarioParams.vars.openLayers;
			App.scenarioParams = undefined;
		}
	}
	catch(ex){}
}
ru.corelight.classes.map.BaseWidget.prototype.changeMapView = function(maxZoom, viewName, projection){
	throw new Error(gis_core_error_4);
};
/**
 * Проверяем, есть ли в url параметры, пришедшие из внешней системы
 * Если есть, то работаем через externalFunctionaAPI
 */
ru.corelight.classes.map.BaseWidget.prototype.checkExternalParamsFromURL = function(){
	throw new Error(gis_core_error_4);
};
/**
 * Реакция на нажатие ESC
 * @private
 */
ru.corelight.classes.map.BaseWidget.prototype.handleEscClick_ = function () {
	throw new Error(gis_core_error_4);
};


/*** STATIC  ***/
ru.corelight.classes.map.BaseWidget.getHideButtonsConfig = function(){
	var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
	if (mapConfig) {
		var buttons = mapConfig.hideButtons;
		if (goog.isDef(buttons)) {
			return buttons;
		}
	}
	return [];
};

cashelper = {};
cashelper.onPreCompose = function(evt) {
	_CURRENT_RENDERED_LAYERS = [];
	_CONTEXT = evt.context;
	_visibleMatrix = {};
	WidgetMap.regenerateMatrix('label');
}
cashelper.onPostCompose = function(evt) {
	if(_pointLabels.length>0 && _LABELS.length == 0){//если на экстенте карты нет точечных объектов
		_LABELS = _pointLabels;
	}
	else
		_pointLabels = _LABELS;
	//console.log('draw1');
	var i=_LABELS.length-1;
	for(i; i >= 0;i--){
		_LABELS[i]['finded'] = false;
		_LABELS[i].hide = false;
	}
	//когда мы закончили рендерить, нужно отбросить неиспользуемые подписи
	var t=0;
	if(_LABELS.length>0) {
		for(t; t < _CURRENT_RENDERING_LAYERS.length; t++){
			var i=_LABELS.length-1;
			for(i; i >= 0;i--){
				if(_LABELS[i].unique.indexOf(_CURRENT_RENDERING_LAYERS[t]) != -1)
					_LABELS[i]['finded'] = true;
			}
		}
	}
	//проходимся ещё раз, чтобы проверить, что подписи попадают в отрисовку шкал
	if(_LABELS.length>0) {
		var i=_LABELS.length-1;
		for(i; i >= 0;i--){
			if(_LABELS[i].unique.indexOf('labelScale') != -1 || _LABELS[i].unique.indexOf('lineAdd') != -1 || _LABELS[i].unique.indexOf('labelLegend') != -1)
				_LABELS[i]['finded'] = true;
		}
	}
	//console.log('draw2');
	//удаляем
	var i=_LABELS.length-1;
	for(i; i >= 0;i--){
		if(_LABELS[i].finded != true)
			_LABELS.splice(i,1);
	}

	//console.log(_LABELS.length);
	if(goog.isDef(WidgetMap.hideLabelsArr)){
		var t=0;
		for(t;t<WidgetMap.hideLabelsArr.length;t++){
			var k = 0;
			for(k;k<_LABELS.length;k++){
				if(_LABELS[k].unique == WidgetMap.hideLabelsArr[t].unique){
					_LABELS[k].hide = true;
					break;
				}
			}
		}
	}
	if(_LABELS.length>0){
		//console.log('draw');
		var context = evt.context;
		var i = 0;
		for(i; i<_LABELS.length; i++){
			if( _LABELS[i].unique.indexOf('labelLegend') != -1)
				continue;
			/*if(i == 20)
			break;*/
			var obj = _LABELS[i];
			//если есть флаг, то не отрисовываем подпись
			if(obj.hide==true)
				continue;
			if(goog.isDef(obj.type)){
				var coordsXY = WidgetMap.map.getPixelFromCoordinate([obj.coordX, obj.coordY]);
				coordsXY[0]*=getBrowserZoom();
				coordsXY[1]*=getBrowserZoom();
				obj.textStyle.offsetY_ = -8;
				obj.x = coordsXY[0]+obj.textStyle.offsetX_;
				obj.y = coordsXY[1]+obj.textStyle.offsetY_;
			}
			else{
				var coordsXY = WidgetMap.map.getPixelFromCoordinate([obj.coordX, obj.coordY]);
				coordsXY[0]*=getBrowserZoom();
				coordsXY[1]*=getBrowserZoom();
				obj.x = coordsXY[0]+obj.textStyle.offsetX_-3;
				obj.y = coordsXY[1]+obj.textStyle.offsetY_-12;
				//obj.x = obj.x;
				//obj.y = obj.x;
			}
			context.font = obj.textStyle.getFont();
			context.textAlign = obj.textStyle.getTextAlign();
			context.textBaseline = obj.textStyle.getTextBaseline();
			//obj.y = obj.y;
			//obj.rotation = 0;
			obj.localTransform = _TRANSFORM;
			if (obj.scale != 1 || obj.rotation !== 0) {
				ol.vec.Mat4.makeTransform2D(
					obj.localTransform, obj.x, obj.y, obj.scale, obj.scale, obj.rotation, -obj.x, -obj.y);
				context.setTransform(
					goog.vec.Mat4.getElement(obj.localTransform, 0, 0),
					goog.vec.Mat4.getElement(obj.localTransform, 1, 0),
					goog.vec.Mat4.getElement(obj.localTransform, 0, 1),
					goog.vec.Mat4.getElement(obj.localTransform, 1, 1),
					goog.vec.Mat4.getElement(obj.localTransform, 0, 3),
					goog.vec.Mat4.getElement(obj.localTransform, 1, 3));
			}

			if (obj.stroke) {
				context.lineWidth = 2;
				context.strokeStyle = '#fff';//obj.textStyle.getStroke().getColor();
				context.strokeText(obj.text, obj.x, obj.y);
			}
			if (obj.fill) {//текст делаем черным, как во флеше
				context.fillStyle = obj.textStyle.getFill().getColor();;//'rgba(0,0,0,1)';//obj.textStyle.getFill().getColor();
				context.fillText(obj.text, obj.x, obj.y);
			}
			if (obj.scale != 1 || obj.rotation !== 0) {
				context.setTransform(1, 0, 0, 1, 0, 0);
			}
		}
	}
	_IS_FULL_REDRAW = false;
}
cashelper.onPostComposeLegend = function (evt) {
	if(_LABELS.length>0){
		var context = evt.context;
		var i = 0;
		for(i; i<_LABELS.length; i++){
			if( _LABELS[i].unique.indexOf('labelLegend') == -1)
				continue;

			var obj = _LABELS[i];
			if(goog.isDef(obj.type)){
				var coordsXY = WidgetMap.lmap.getPixelFromCoordinate([obj.coordX, obj.coordY]);
				coordsXY[0]*=getBrowserZoom();
				coordsXY[1]*=getBrowserZoom();
				obj.x = coordsXY[0]+obj.textStyle.offsetX_;
				obj.y = coordsXY[1]+obj.textStyle.offsetY_;
			}
			context.font = obj.textStyle.getFont();
			context.textAlign = obj.textStyle.getTextAlign();
			context.textBaseline = obj.textStyle.getTextBaseline();
			obj.localTransform = _TRANSFORM;
			//obj.rotation = 270*Math.PI/180;

			//разбиваем название, чтобы можно было переносить по словам
			var maxLen = 35;
			var newLayerName = '';
			var layName = obj.text;
			var resLayerName = '';
			var countt = 0;
			if(layName.length > maxLen){
				var splitted = layName.split(' ');
				if(splitted.length>0){
					newLayerName+=splitted[0];resLayerName+=splitted[0];
					var ii = 1;
					for(; ii<splitted.length;ii++){
						if((newLayerName+splitted[ii]).length < maxLen){
							newLayerName+=' '+splitted[ii];
							resLayerName+=' '+splitted[ii];
						}
						else{
							if (obj.stroke) {
								context.lineWidth = 2;
								context.strokeStyle = '#fff';
								context.strokeText(newLayerName, obj.x, obj.y+countt*10);
							}
							if (obj.fill) {
								context.fillStyle = obj.textStyle.getFill().getColor();
								context.fillText(newLayerName, obj.x, obj.y+countt*10);
							}
							countt++;
							resLayerName += '\n'+splitted[ii];
							newLayerName = splitted[ii];
						}
					}
					if (obj.stroke) {
						context.lineWidth = 2;
						context.strokeStyle = '#fff';
						context.strokeText(newLayerName, obj.x, obj.y+countt*10);
					}
					if (obj.fill) {
						context.fillStyle = obj.textStyle.getFill().getColor();
						context.fillText(newLayerName, obj.x, obj.y+countt*10);
					}
				}
			}
			else {
				if (obj.stroke) {
					context.lineWidth = 2;
					context.strokeStyle = '#fff';//obj.textStyle.getStroke().getColor();
					context.strokeText(obj.text, obj.x, obj.y);
				}
				if (obj.fill) {
					context.fillStyle = obj.textStyle.getFill().getColor();
					context.fillText(obj.text, obj.x, obj.y);
				}
			}


		}
	}
}
cashelper.onMoveEnd = function (evt) {
	if(goog.isDef(WidgetMap)){
		var i = 0;
		var needCenteringLayers = WidgetMap.layerManager.getNeedCenteringLayers();
		for(;i<needCenteringLayers.length;i++){
			needCenteringLayers[i].canFirstTimeCentering = false;
		}
	}
	_IS_FULL_REDRAW = true;
	_TEMP_LAYERS_LABELS = {};
}


//Функция очистки всех горизонтальных осей и шкал на горизонтальных осях
cashelper.clearAllHorizontalScales = function(){
	//слой для основной карты
	if (goog.isDef(WidgetMap.axesXVectorLayer)){
		WidgetMap.axesXVectorLayer.getSource().getSource().clear();
		//удаляем
		var i=_LABELS.length-1;
		for(i; i >= 0;i--){
			if(_LABELS[i].unique.indexOf('labelScale')!=-1)
				_LABELS.splice(i,1);
		}
		var i=_LABELS.length-1;
		for(i; i >= 0;i--){
			if(_LABELS[i].unique.indexOf('labelLegend')!=-1)
				_LABELS.splice(i,1);
		}
		delete globalLinesLabels_['labelScale'];
		globalLinesLabels_['labelScale'] = [];

		delete globalLinesGEOs_['labelScale'];
		globalLinesGEOs_['labelScale'] = {};

		delete globalPointsLabels_['labelLegend'];
		globalPointsLabels_['labelLegend'] = [];

		delete globalPointsGEOs_['labelLegend'];
		globalPointsGEOs_['labelLegend'] = {};
	}

	if (goog.isDef(WidgetMap.axesXLineVectorLayer))
		WidgetMap.axesXLineVectorLayer.getSource().clear();
	if (goog.isDef(WidgetMap.axesVectorLayer))
		WidgetMap.axesVectorLayer.getSource().clear();
	if (goog.isDef(WidgetMap.axesVectorLayerNameLegend)){
		WidgetMap.axesVectorLayerNameLegend.getSource().getSource().clear();
		//WidgetMap.axesVectorLayerNameLegend = undefined;
	}
	if (goog.isDef(WidgetMap.axesVectorLayerLegendY)){
		WidgetMap.axesVectorLayerLegendY.getSource().clear();
		//WidgetMap.axesVectorLayerNameLegend = undefined;
	}

	if (goog.isDef(WidgetMap.axesVectorLayerLegend)){
		WidgetMap.axesVectorLayerLegend.getSource().clear();
		//WidgetMap.axesVectorLayerLegend = undefined;
	}

};

//Функция очистки всех вертикальных осей и шкал на вертикальных осях
cashelper.clearAllVerticalScales = function(){
	//слой для основной карты
	if (goog.isDef(WidgetMap.axesYVectorLayer)){
		WidgetMap.axesYVectorLayer.getSource().getSource().clear();
		var i=_LABELS.length-1;
		for(i; i >= 0;i--){
			if(_LABELS[i].unique.indexOf('labelScaleY')!=-1)
				_LABELS.splice(i,1);
		}
		delete globalLinesLabels_['labelScaleY'];
		delete globalLinesGEOs_['labelScaleY'];
		globalLinesLabels_['labelScaleY'] = [];
		globalLinesGEOs_['labelScaleY'] = {};
	}
	if (goog.isDef(WidgetMap.axesYLineVectorLayer))
		WidgetMap.axesYLineVectorLayer.getSource().clear();
};

cashelper.clearAllCosmeticElements = function(){
	//слой для основной карты
	if (goog.isDef(WidgetMap.cosmeticYVectorLayer)){
		WidgetMap.cosmeticYVectorLayer.getSource().getSource().clear();
	}
};


//Функция очистки осей для каждого служебного слоя
cashelper.clearAllLayersAxes = function(){
	//слой для осей основной карты
	//добавляем на карту векторный слой для рисования
	if(!goog.isDef( WidgetMap.currentVectorLayer)){
		var source = new ol.source.Vector();
		WidgetMap.currentVectorLayer = new ol.layer.Vector({
			source: source
		});
		WidgetMap.map.addLayer(WidgetMap.currentVectorLayer);
	}
};


/**
 * Загрузка описания по обследованию. Километраж и дата обследования
 * @param inspectionId
 */
cashelper.loadInspectionDescription = function(inspectionId){
	var description = gis_widgetmap_27;
	if(inspectionId){
		function result(result) {
			try {
				if(result && !result.error){
					var data = result.data;
					if(data && data.length > 0){
						description = gis_widgetmap_26 + data[0].DESCR;
					}
				}
			}
			catch(e){
			}
			$('body').append('<div class="map-description-label">' + description + '</div>');
		}
		//т.к. просто текстовая надпись, то сообщение об ошибке не выводим
		function fault() {
			$('body').append('<div class="map-description-label">' + description + '</div>');
		}
		App.formattedQueryNode(Services.processQueryNode, App.composeRequestParams('GAZPROM_SYS_SEM.xml#GET_CAS_INSPECTION_DESCR', {ID:inspectionId}), result, fault,4);
	}
};

/**
 * Функция отрисовки 2-х горизонтальных осей со шкалой с шагом 10 (сверху и снизу) для каждого слоя
 * @param {Number}layPosition
 * @param {Number}layHeight
 */
cashelper.drawLegendHorizontalAxes = function(layPosition, layHeight, layName, lastDiagram){
	//Добавляем на основную карту риски шкалы
	//слой для легенды карты
	if(!goog.isDef(WidgetMap.axesVectorLayerLegend)){
		var source = new ol.source.Vector();
		WidgetMap.axesVectorLayerLegend = new ol.layer.Vector({
			source: source,
			id:WidgetMap.CONSTANTS.AXES_FEATURE_LAYER+'legend'
		});
		WidgetMap.lmap.addLayer(WidgetMap.axesVectorLayerLegend);
	}

	if(!goog.isDef(WidgetMap.axesVectorLayerLegendY)){
		var source = new ol.source.Vector();
		WidgetMap.axesVectorLayerLegendY = new ol.layer.Vector({
			source: source,
			id:WidgetMap.CONSTANTS.AXES_FEATURE_LAYER+'legendY'
		});
		WidgetMap.lmap.addLayer(WidgetMap.axesVectorLayerLegendY);
	}
	//Старый способ - просто нарисовать прямую линию из 2-х точек при растяжении данных
	//давал ошибку - линии становились жирными. Скорее всего, это из-за длины отрезка.
	//Новый способ - в линии делаем больше количество сегментов, рисуя линию участками
	//добавляем верхнюю границу
	var linePntArr = [];
	var legendWidth = WidgetMap.lmap.getCoordinateFromPixel([WidgetMap.CAS_LEGEND_WIDTH,0])[0]
	var firstPnt = [WidgetMap.lmap.getCoordinateFromPixel([0,0])[0], layPosition];
	var lastPoint = [legendWidth, layPosition];
	linePntArr.push(firstPnt);
	linePntArr.push(lastPoint);

	var axesScaleGeoAdd = undefined;
	var axesScaleGeoFirst = undefined;
	var axesScaleGeoVert = undefined;
	if(WidgetMap.CAS_GLOBAL_OFFSET != 0){
		firstPnt = [WidgetMap.lmap.getCoordinateFromPixel([0,0])[0], layPosition-WidgetMap.CAS_GLOBAL_OFFSET];
		lastPoint = [legendWidth, layPosition-WidgetMap.CAS_GLOBAL_OFFSET];
		if(lastDiagram !== true)//если не последний график, рисуем снизу всех линии разделительные
			axesScaleGeoAdd = new ol.geom.LineString([firstPnt,lastPoint],ol.geom.GeometryLayout.XY);

		firstPnt = [WidgetMap.lmap.getCoordinateFromPixel([0,0])[0], -WidgetMap.CAS_GLOBAL_FIRST_OFFSET];
		lastPoint = [legendWidth, -WidgetMap.CAS_GLOBAL_FIRST_OFFSET];
		axesScaleGeoFirst = new ol.geom.LineString([firstPnt,lastPoint],ol.geom.GeometryLayout.XY);
	}
	//Добавляем собственно шкалу
	var axesScaleGeoFtr = WidgetMap.axesVectorLayerLegend.getSource().getFeatureById('axesLegend');
	//Добавляем собственно шкалу
	var axesScaleGeo = new ol.geom.LineString(linePntArr,ol.geom.GeometryLayout.XY);
	var mAxeScaleGeo;
	//Добавляем незаметные линии по вертикали, чтобы удобнее было просматривать километры
	if (!goog.isDefAndNotNull(axesScaleGeoFtr)){
		mAxeScaleGeo = new ol.geom.MultiLineString(null);
		mAxeScaleGeo.appendLineString(axesScaleGeo);
		if(axesScaleGeoAdd !== undefined)
			mAxeScaleGeo.appendLineString(axesScaleGeoAdd);
		if(axesScaleGeoFirst !== undefined)
			mAxeScaleGeo.appendLineString(axesScaleGeoFirst);
		if(axesScaleGeoVert !== undefined)
			mAxeScaleGeo.appendLineString(axesScaleGeoVert);
		axesScaleGeoFtr = new ol.Feature(mAxeScaleGeo);
		axesScaleGeoFtr.setId('axesLegend');
		axesScaleGeoFtr.setStyle(function(){
			var s = WidgetMap.layerManager.getStyleByNameAndType(WidgetMap.CONSTANTS.CAS_AXES,'LineString');
			if(!goog.isNull(s)) {
				if (goog.isArray(s))
					return [s[0]];
				return [s];
			}
		});
		WidgetMap.axesVectorLayerLegend.getSource().addFeature(axesScaleGeoFtr);
	}
	else{
		mAxeScaleGeo = axesScaleGeoFtr.getGeometry();
		if (goog.isDef(mAxeScaleGeo))
			mAxeScaleGeo.appendLineString(axesScaleGeo);
		if(axesScaleGeoAdd !== undefined)
			mAxeScaleGeo.appendLineString(axesScaleGeoAdd);
		if(axesScaleGeoFirst !== undefined)
			mAxeScaleGeo.appendLineString(axesScaleGeoFirst);
		if(axesScaleGeoVert !== undefined)
			mAxeScaleGeo.appendLineString(axesScaleGeoVert);
	}


	//вертикальные оси
	//вертикальные оси
	var linePntArr = [];
	var firstPnt = [legendWidth, layPosition];
	var lastPoint = [legendWidth, layPosition+layHeight];
	linePntArr.push(firstPnt);
	linePntArr.push(lastPoint);
	//Добавляем собственно шкалу
	var axesScaleGeoFtr = WidgetMap.axesVectorLayerLegendY.getSource().getFeatureById('axesLegendY');
	//Добавляем собственно шкалу
	var axesScaleGeo = new ol.geom.LineString(linePntArr,ol.geom.GeometryLayout.XY);
	var mAxeScaleGeo;
	//Добавляем незаметные линии по вертикали, чтобы удобнее было просматривать километры
	if (!goog.isDefAndNotNull(axesScaleGeoFtr)){
		mAxeScaleGeo = new ol.geom.MultiLineString(null);
		mAxeScaleGeo.appendLineString(axesScaleGeo);
		axesScaleGeoFtr = new ol.Feature(mAxeScaleGeo);
		axesScaleGeoFtr.setId('axesLegendY');
		axesScaleGeoFtr.setStyle(function(){
			var s = WidgetMap.layerManager.getStyleByNameAndType(WidgetMap.CONSTANTS.CAS_AXES,'LineString');
			if(!goog.isNull(s)) {
				if (goog.isArray(s))
					return [s[0]];
				return [s];
			}
		});
		WidgetMap.axesVectorLayerLegendY.getSource().addFeature(axesScaleGeoFtr);
	}
	else{
		mAxeScaleGeo = axesScaleGeoFtr.getGeometry();
		if (goog.isDef(mAxeScaleGeo))
			mAxeScaleGeo.appendLineString(axesScaleGeo);
	}
	cashelper.drawLegendTextHorizontalAxes(layPosition, layHeight,layName);
};

/**
 * Отрисовка иконок легенды напротив текста
 * @param layPosition
 * @param layHeight
 * @param index
 */
cashelper.drawLegendIconAxes = function(layPosition, layHeight, index){
	return;
	if(!goog.isDef(WidgetMap.axesVectorLayerNameLegendIcon)){
		var source = new ol.source.Vector({
		});
		var imageVectorSource = new map.layer.ExtImageVector({
			source:source,
			id: WidgetMap.CONSTANTS.LEGEND_AXES_FEATURE_LAYER+'_icon',
			ratio:1
		});
		WidgetMap.axesVectorLayerNameLegendIcon = new ol.layer.Image({
			id: WidgetMap.CONSTANTS.LEGEND_AXES_FEATURE_LAYER+'_icon',
			source: imageVectorSource
		});
		WidgetMap.lmap.addLayer(WidgetMap.axesVectorLayerNameLegendIcon);
	}
	var legendLabelAxeGeo;
	index = index || 0;// начиная со второго группового графика
	var legendLabelAxeGeoFtr = WidgetMap.axesVectorLayerNameLegendIcon.getSource().getSource().getFeatureById('labelLegend');
	var centerPixel = [0,WidgetMap.lmap.getPixelFromCoordinate([0,layPosition+layHeight])[1]+7 + (index * 50)];
	var center = WidgetMap.lmap.getCoordinateFromPixel(centerPixel);
	//center = [40, -50];
	/*0: -0.32068908691405795
	1: -131.4023533630371
	2: 220.634091796875
	3: -3.6077522277831946*/
	var lineLabelGeo = new ol.geom.Point(center,ol.geom.GeometryLayout.XY);
	var stName = 'labelLegendIcon';
	if (!goog.isDefAndNotNull(legendLabelAxeGeoFtr)){
		legendLabelAxeGeo = new ol.geom.MultiPoint(null);
		legendLabelAxeGeo.appendPoint(lineLabelGeo);
		legendLabelAxeGeoFtr = new ol.Feature(legendLabelAxeGeo);
		legendLabelAxeGeoFtr.setId('labelLegendIcon');
		legendLabelAxeGeoFtr.set('type', WidgetMap.CONSTANTS.CAS_LEGEND_POINT);
		legendLabelAxeGeoFtr.set('layerId', stName);
		legendLabelAxeGeoFtr.set('labelType', stName);
		legendLabelAxeGeoFtr.set('labelsObj', globalPointsLabels_[stName]);//массив с id геометрии и её подписью
		legendLabelAxeGeoFtr.set('labelsObjAll', globalPointsLabels_[stName]);//массив с id геометрии и её подписью
		legendLabelAxeGeoFtr.set('pointsObj', globalPointsGEOs_[stName]);
		legendLabelAxeGeoFtr.set('pointsObjAll', globalPointsGEOs_[stName]);
		legendLabelAxeGeoFtr.setStyle(function(){
			var s = WidgetMap.layerManager.getDefaultCASCarouselStyle(index);
			return [s];
		});
		WidgetMap.axesVectorLayerNameLegendIcon.getSource().getSource().addFeature(legendLabelAxeGeoFtr);
	}
	else{
		legendLabelAxeGeo = legendLabelAxeGeoFtr.getGeometry();
		if (goog.isDef(legendLabelAxeGeo)){
			legendLabelAxeGeo.appendPoint(lineLabelGeo);
		}
	}
}

/**
 * Функция отрисовки названий графиков на легенде
 * @param layPosition
 * @param layHeight
 */
cashelper.drawLegendTextHorizontalAxes = function(layPosition, layHeight, legendName, index, groupId){
	if(index){
		cashelper.drawLegendIconAxes(layPosition, layHeight, index);
	}

	if(!goog.isDef(WidgetMap.axesVectorLayerNameLegend)){
		var source = new ol.source.Vector({
		});
		var imageVectorSource = new map.layer.ExtImageVector({
			source:source,
			id: WidgetMap.CONSTANTS.LEGEND_AXES_FEATURE_LAYER,
			ratio:1
		});
		WidgetMap.axesVectorLayerNameLegend = new ol.layer.Image({
			id: WidgetMap.CONSTANTS.LEGEND_AXES_FEATURE_LAYER,
			source: imageVectorSource
		});
		WidgetMap.lmap.addLayer(WidgetMap.axesVectorLayerNameLegend);
	}
	var legendLabelAxeGeo;
	index = index || 0;// начиная со второго группового графика
	var legendLabelAxeGeoFtr = WidgetMap.axesVectorLayerNameLegend.getSource().getSource().getFeatureById('labelLegend');
	var centerPixel = [0,WidgetMap.lmap.getPixelFromCoordinate([0,layPosition+layHeight])[1]+7 + (index * 50)];
	centerPixel[0]/=getBrowserZoom();
	centerPixel[1]/=getBrowserZoom();
	var center = WidgetMap.lmap.getCoordinateFromPixel(centerPixel);
	var lineLabelGeo = new ol.geom.Point(center,ol.geom.GeometryLayout.XY);
	var stName = 'labelLegend';
	var geoId = stName + Math.abs(layPosition + Date.now()).toString();
	if (!goog.isDefAndNotNull(legendLabelAxeGeoFtr)){
		legendLabelAxeGeo = new ol.geom.MultiPoint(null);
		legendLabelAxeGeo.appendPoint(lineLabelGeo);
		legendLabelAxeGeoFtr = new ol.Feature(legendLabelAxeGeo);
		legendLabelAxeGeoFtr.setId('labelLegend');
		legendLabelAxeGeoFtr.set('type', WidgetMap.CONSTANTS.CAS_LEGEND_POINT);
		legendLabelAxeGeoFtr.set('layerId', stName);
		legendLabelAxeGeoFtr.set('labelType', stName);
		legendLabelAxeGeoFtr.set('labelsObj', globalPointsLabels_[stName]);//массив с id геометрии и её подписью
		legendLabelAxeGeoFtr.set('labelsObjAll', globalPointsLabels_[stName]);//массив с id геометрии и её подписью
		legendLabelAxeGeoFtr.set('pointsObj', globalPointsGEOs_[stName]);
		legendLabelAxeGeoFtr.set('pointsObjAll', globalPointsGEOs_[stName]);
		legendLabelAxeGeoFtr.setStyle(function(){
			var s = WidgetMap.layerManager.getDefaultCASPointStyle();
			if(!goog.isNull(s)) {
				if (goog.isDef(globalPointsLabels_['labelLegend']) ) {
					var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(WidgetMap.CONSTANTS.CAS_LEGEND, 'LineString');
					if (!goog.isNull(textstyle) && textstyle.fontSize != '-1')
						map.layer.VectorLayer.prototype.setTextStyle(s, textstyle);
					else
						map.layer.VectorLayer.prototype.setTextStyle(s, null);
				}
				if (goog.isArray(s))
					return [s[0]];
				return [s];
			}
		});
		WidgetMap.axesVectorLayerNameLegend.getSource().getSource().addFeature(legendLabelAxeGeoFtr);
	}
	else{
		legendLabelAxeGeo = legendLabelAxeGeoFtr.getGeometry();
		if (goog.isDef(legendLabelAxeGeo)){
			legendLabelAxeGeo.appendPoint(lineLabelGeo);
		}
	}
	//финальное название слоя в легенде с отсечением текста, которые не помещается по высоте
	var resLayName = cashelper.sliceLegendLayerName(legendName,layHeight, groupId);
	globalPointsLabels_[stName].push({label:resLayName,id:geoId,geo:lineLabelGeo});
	globalPointsGEOs_[stName][geoId] = lineLabelGeo;
};

/**
 * Возвращаем минимальные значения границы графика, включает и подсчитанные анализы
 * @param {String} layName
 */
cashelper.getOriginalMinBounds = function(layName){
	if(goog.isDef(WidgetMap.yScaleData) && goog.isDef(WidgetMap.yScaleData[layName])){
		return WidgetMap.yScaleData[layName].minValue;
	}
	return NaN;
};
/**
 * Возвращаем минимальные значения границы графика, включает и подсчитанные анализы
 * @param {String} layName
 */
cashelper.getOriginalMaxBounds = function(layName){
	if(goog.isDef(WidgetMap.yScaleData) && goog.isDef(WidgetMap.yScaleData[layName])){
		return WidgetMap.yScaleData[layName].maxValue;
	}
	return NaN;
};


//финальное название слоя в легенде с отсечением текста, которые не помещается по высоте
cashelper.sliceLegendLayerName = function(name, layHeight, groupId){
	//высота 10.5 = 6 строк текста;  10.5 - c у четом корректирующего коэффициента
	var lines = (groupId) ? 3 : 6;
	var maxCount = parseInt(lines * layHeight / 10.5);
	var resName = name;
	//разбиваем название, чтобы можно было переносить по словам
	var maxLen = 35;
	//сколько сейчас строк текста в строке
	var curCount = 1;
	var curStr = '';//текст в текущей строке
	if (name.length > maxLen) {
		var splitted = name.split(' ');
		var i = 1;
		resName = splitted[0];
		curStr = resName;
		for (; i < splitted.length; i++) {
			var cur = curStr + ' ' + splitted[i];
			if (cur.length + 3 >= maxLen) {
				curCount++;
				curStr = splitted[i];
				if (curCount > maxCount) {
					resName += '...';
					break;
				}
			} else curStr += ' ' + splitted[i];
			resName += ' ' + splitted[i];
		}
	}
	return resName;
};

/**
 * Функция отрисовки дополнительных неинтерактивных элементов на графике для слоя
 * @param {Number} layPosition
 * @param {map.layer.CASLayer} layer
 */
cashelper.drawCosmeticElements = function(layPosition, layer){
	return;
	if(!goog.isDef(layPosition) || !goog.isDef(layer))
		return;

	if(!goog.isDef(WidgetMap.cosmeticYVectorLayer)){
		var source = new ol.source.Vector({
		});
		var imageVectorSource = new map.layer.ExtImageVector({
			source:source,
			id: WidgetMap.CONSTANTS.AXES_Y_COSMETIC_FEATURE_LAYER,
			ratio:1
		});
		WidgetMap.cosmeticYVectorLayer = new ol.layer.Image({
			id: WidgetMap.CONSTANTS.AXES_Y_COSMETIC_FEATURE_LAYER,
			source: imageVectorSource
		});
		WidgetMap.map.addLayer(WidgetMap.cosmeticYVectorLayer);
	}

	//косметика
	var cosmeticFeature = WidgetMap.cosmeticYVectorLayer.getSource().getSource().getFeatureById('cosmetic');
	var legendLabelAxeGeo;
	//добавляем нижнюю границу
	var linePntArr = [];
	for(var k=0; k < layer.cosmeticElements.length; k++){
		var elem = layer.cosmeticElements[k];
		var stride = 2;
		for (var kk=0; kk < elem.coords.length; kk += stride){
			linePntArr.push([elem.coords[kk],elem.coords[kk+1]]);
		}
		//Добавляем косметику
		var axeScaleGeo = new ol.geom.LineString(linePntArr,ol.geom.GeometryLayout.XY);
		var mAxeScaleGeo = new ol.geom.MultiLineString(null);
		mAxeScaleGeo.appendLineString(axeScaleGeo);
		var cosmeticFeature = new ol.Feature(mAxeScaleGeo);
		cosmeticFeature.setStyle(function(){
			var s = WidgetMap.layerManager.getStyleByNameAndType(elem.style,item.topology);
			if(!goog.isNull(s)) {
				if (goog.isArray(s))
					return [s[0]];
				return [s];
			}
		});
		WidgetMap.cosmeticYVectorLayer.getSource().getSource().addFeature(cosmeticFeature);
	}
};

/**
 * Функция отрисовки 2-х горизонтальных осей со шкалой с шагом 10 (сверху и снизу) для каждого слоя
 * @param {Number}layPosition
 * @param {Number}layHeight
 */
cashelper.drawHorizontalAxes = function(layPosition, layHeight){
	//Добавляем на основную карту риски шкалы
	//слой для основной карты
	if(!goog.isDef(WidgetMap.axesVectorLayer)){
		var source = new ol.source.Vector();
		WidgetMap.axesVectorLayer = new ol.layer.Vector({
			source: source,
			id:WidgetMap.CONSTANTS.AXES_FEATURE_LAYER
		});
		WidgetMap.map.addLayer(WidgetMap.axesVectorLayer);
	}
	//Старый способ - просто нарисовать прямую линию из 2-х точек при растяжении данных
	//давал ошибку - линии становились жирными. Скорее всего, это из-за длины отрезка.
	//Новый способ - в линии делаем больше количество сегментов, рисуя линию участками
	var xDelta = WidgetMap.map.getSize()[0]/WidgetMap.COL_X_SCALE_STEPS;
	//добавляем верхнюю границу
	var linePntArr = [];
	var firstPnt = [WidgetMap.map.getCoordinateFromPixel([0,0])[0], layPosition+layHeight];
	linePntArr.push(firstPnt);
	for (var i=0; i<WidgetMap.COL_X_SCALE_STEPS; i++){
		var pntAxeScale;
		var lonLat = WidgetMap.map.getCoordinateFromPixel([xDelta*(i+1),0]);
		var lonLatEnd = WidgetMap.map.getCoordinateFromPixel([xDelta*(i+2),0]);
		pntAxeScale = [lonLat[0], layPosition + layHeight];
		linePntArr.push(pntAxeScale);
		pntAxeScale = [lonLatEnd[0], layPosition + layHeight];
		linePntArr.push(pntAxeScale);
		pntAxeScale = [lonLat[0], layPosition + layHeight];
		linePntArr.push(pntAxeScale);
		pntAxeScale = [lonLatEnd[0], layPosition + layHeight];
		linePntArr.push(pntAxeScale);
	}
	//Добавляем собственно шкалу
	var axesScaleGeoFtr = WidgetMap.axesVectorLayer.getSource().getFeatureById('axes');
	//Добавляем собственно шкалу
	var axesScaleGeo = new ol.geom.LineString(linePntArr,ol.geom.GeometryLayout.XY);
	var mAxeScaleGeo;
	//Добавляем незаметные линии по вертикали, чтобы удобнее было просматривать километры
	if (!goog.isDefAndNotNull(axesScaleGeoFtr)){
		mAxeScaleGeo = new ol.geom.MultiLineString(null);
		mAxeScaleGeo.appendLineString(axesScaleGeo);
		axesScaleGeoFtr = new ol.Feature(mAxeScaleGeo);
		axesScaleGeoFtr.setId('axes');
		axesScaleGeoFtr.setStyle(function(){
			var s = WidgetMap.layerManager.getStyleByNameAndType(WidgetMap.CONSTANTS.CAS_AXES,'LineString');
			if(!goog.isNull(s)) {
				if (goog.isArray(s))
					return [s[0]];
				return [s];
			}
		});
		WidgetMap.axesVectorLayer.getSource().addFeature(axesScaleGeoFtr);
	}
	else{
		mAxeScaleGeo = axesScaleGeoFtr.getGeometry();
		if (goog.isDef(mAxeScaleGeo))
			mAxeScaleGeo.appendLineString(axesScaleGeo);
	}
};

//Устанавливаем начальное положение карты ПКА и легенды
cashelper.loadMapRect = function(){
	if(goog.isDef(WidgetMap.map)){
		WidgetMap.map.getView().setCenter([0, 0]);
		WidgetMap.map.getView(WidgetMap.START_ZOOM);
		var topLeft = WidgetMap.map.getCoordinateFromPixel([0, 0]);
		var topLeftControls = WidgetMap.map.getCoordinateFromPixel([0,0]);
		if(!topLeft || !topLeftControls)
			return;
		//Высота контролов в lonLat, сохраняем для дальнейших пересчетов высоты карты при изменении ее размера по вертикали
		WidgetMap.controlsHeightLat =  Math.abs(topLeftControls[0] - topLeft[0]);
		//Рассчитываем минимальную позицию вертикального скролла
		cashelper.calcMinScrollY();
		WidgetMap.maxScrollY = WidgetMap.minScrollY;
		WidgetMap.map.getView().setCenter([0, -WidgetMap.minScrollY]);
		WidgetMap.map.getView().setZoom(WidgetMap.START_ZOOM);

		//для легенды
		WidgetMap.lmap.getView().setCenter([0, -WidgetMap.minScrollY]);
		WidgetMap.lmap.getView().setZoom(WidgetMap.START_ZOOM);
	}
};

//Функция расчета минимальной позиции вертикального скролла исходя из текущих размеров карты и высоты контролов
cashelper.calcMinScrollY = function() {
	//Вычитаем из maxScrollY старое значение minScrollY, чтобы получить текущую высоту слоев. Если слоев еще нет, то maxScrollY будет перезатерт в функции loadMapRect
	WidgetMap.maxScrollY = WidgetMap.maxScrollY + WidgetMap.minScrollY;
	var topLeft = WidgetMap.map.getCoordinateFromPixel([0, 0]);
	var bottomRight = WidgetMap.map.getCoordinateFromPixel(WidgetMap.map.getSize());
	//Как минимальную для вертикального скролла запоминаем позицию
	//равную половине высоты без высоты управляющих контролов.
	WidgetMap.minScrollY = (topLeft[1] - WidgetMap.controlsHeightLat - bottomRight[1])/2;
	//После обновления minScrollY нужно обновить maxScrollY
	WidgetMap.maxScrollY = WidgetMap.maxScrollY - WidgetMap.minScrollY;
};

/**
 * Обновляем горизонтальные шкалы у слоёв
 */
cashelper.refreshXAxis = function(){
	//чистим подписи
	var i=_LABELS.length-1;
	for(i; i >= 0;i--){
		if(_LABELS[i].unique.indexOf('labelScale')!=-1)
			_LABELS.splice(i,1);
	}
	//чистим слой с подписями
	if (goog.isDef(WidgetMap.axesXVectorLayer)){
		WidgetMap.axesXVectorLayer.getSource().getSource().clear();
	}

	if (goog.isDef(WidgetMap.axesXLineVectorLayer)){
		WidgetMap.axesXLineVectorLayer.getSource().clear();
	}

	delete globalLinesLabels_['labelScale'];
	globalLinesLabels_['labelScale'] = [];

	delete globalLinesGEOs_['labelScale'];
	globalLinesGEOs_['labelScale'] = {};

	if (WidgetMap.positionsArr && WidgetMap.positionsArr.length>0){
		var k=0;
		for (; k< WidgetMap.positionsArr.length; k++){
			var layObj = WidgetMap.positionsArr[k];
			if (goog.isDef(layObj) && goog.isDef(layObj.layer) && layObj.layer.needScale == true){
				WidgetMap.drawHorizontalScale(layObj.position, WidgetMap.COL_X_SCALE_STEPS, layObj.height);
			}
			if(goog.isDef(layObj) && goog.isDef(layObj.layer) && layObj.layer.cosmeticElements.length > 0){
				cashelper.drawCosmeticElements(layObj.position,layObj.layer);
			}
		}
	}

	WidgetMap.map.renderSync();
};


/**
 * Обновляем текст в легенде
 */
cashelper.refreshLegend = function(){
	//чистим подписи
	var i=_LABELS.length-1;
	for(i; i >= 0;i--){
		if(_LABELS[i].unique.indexOf('labelLegend')!=-1)
			_LABELS.splice(i,1);
	}
	//чистим слой с подписями
	if (goog.isDef(WidgetMap.axesVectorLayerNameLegend)){
		WidgetMap.axesVectorLayerNameLegend.getSource().getSource().clear();
	}

	delete globalPointsLabels_['labelLegend'];
	globalPointsLabels_['labelLegend'] = [];

	delete globalPointsGEOs_['labelLegend'];
	globalPointsGEOs_['labelLegend'] = {};

	if (WidgetMap.positionsArr && WidgetMap.positionsArr.length>0){
		var k=0;
		for (; k< WidgetMap.positionsArr.length; k++){
			var layObj = WidgetMap.positionsArr[k];
			var layerLabel = layObj.layer.sourceDescr;
			if(goog.isDef(layObj.layer.spatialVariables) && goog.isDef(layObj.layer.spatialVariables.LABEL))
				layerLabel = layObj.layer.spatialVariables.LABEL;
			if(layObj.layer.legendDescr !='')
				layerLabel = layObj.layer.legendDescr;
			cashelper.drawLegendTextHorizontalAxes(layObj.position, layObj.height, layerLabel);
		}
	}
	WidgetMap.lmap.renderSync();
};

/**
 *
 * @param weak флаг слабой ссылки. доступ к слоями из widgetmap.baselayes
 */
cashelper.loadAllLayersData = function(weak, dataLoadedCallback){
	if(WidgetMap.isModelsVector == true){
		var layers = WidgetMap.finalLayers;// WidgetMap.layerManager.getAllLayers();//все векторые слои
		WidgetMap.totalLayersCount = layers.length;
		var i;
		try{
			var treeDiv = $('#treeDiv');
			if(treeDiv.length){
				var filter = $('#treeDiv').myCategories('callbackFilter', {params: {windowId: ''}});
				WidgetMap.updateTopFilter(filter.params);
			}
		}
		catch(ex){}
		var horizontalPosition = 0;
		for(i in layers){
			var layerObj = WidgetMap.layerManager.getVectorLayerByUniqueName(layers[i].LayerId);
			if(layerObj && layerObj.visible === 'true' || layerObj.visible == true && !layerObj.layer.dataReady_){
				//Сразу подгружаем переменные слоя. Пересечения с загрузкой данных не будет - данные запросятся после получения переменных.
				layerObj.layer.layerLoadCallback = function(layer, maxMeasure){
					// if(dataLoadedCallback) dataLoadedCallback(maxMeasure);
					WidgetMap.firstProcessAllLayersVariables(layer);
				};
				if(layerObj.groupId){
					layerObj.layer.groupIndex = horizontalPosition++;
				}

				layerObj.layer.loadSpatial(weak);
				//WidgetMap.layerManager.enableLayer(layerObj.id);
			}
			else{
				--WidgetMap.totalLayersCount;
				//WidgetMap.layerManager.disableLayer(layerObj.id);
			}
		}
	}
};

cashelper.loadLayersData = function(layers, callback){
		for(var i in layers){
			var layerObj = WidgetMap.layerManager.getVectorLayerByUniqueName(layers[i].uniqueLayerName);
			layerObj.layer.dataReady_ = false;
			layerObj.layer.layerLoadCallback = callback;
			//Сразу подгружаем переменные слоя. Пересечения с загрузкой данных не будет - данные запросятся после получения переменных.
			/*layerObj.layer.layerLoadCallback = function(layer, maxMeasure){
				// if(dataLoadedCallback) dataLoadedCallback(maxMeasure);
				//WidgetMap.firstProcessAllLayersVariables(layer);
			};*/
			layerObj.layer.loadSpatial(true);
			//WidgetMap.layerManager.enableLayer(layerObj.id);
		}
};
goog.provide('ru.corelight.classes.map.CasWidgetMap');
ru.corelight.classes.map.CasWidgetMap = function(opt_options){
    this.lmap = undefined;

    //Количество загружаемых слоев. Нужно для выяснения момента нанесения данных всех слоев.
    this.totalLayersCount = 0;
    //Объект для сохранения слоев, для которых необходимо выполнить первоначальную фильтрацию
    //Слои первоначально фильтруются по запросу, находящемуся в переменной START_FILTER
    this.firstFilerObject = {};
    this.startFilterLoadedCount_ = 0;



    this.hideHScroll = false;


    //слои с рисками шкалы для слоя основной карты
    this.axesXVectorLayer = undefined;
    this.axesVectorLayer = undefined;
    this.axesYVectorLayer = undefined;
    this.axesXLineVectorLayer = undefined;
    this.axesYLineVectorLayer = undefined;
    //слои для косметических элементов графиков
    this.cosmeticYVectorLayer = undefined;
    //слои легенды
    this.axesXVectorLayerLegend = undefined;
    this.axesXLineVectorLayerLegend = undefined;
    //слой с названием графика
    this.axesVectorLayerNameLegend = undefined;

    /***  CONSTANTS  ***/
    this.CONSTANTS = {
        LEGEND_AXES_FEATURE_LAYER : 'LEGEND_AXES_FEATURE_LAYER',  //слой для осей легенды
        AXES_FEATURE_LAYER: 'AXES_FEATURE_LAYER',//слой для осей основной карты
        AXES_X_SCALE_FEATURE_LAYER: 'AXES_X_SCALE_FEATURE_LAYER',//слои с рисками шкалы для слоя основной карты
        AXES_Y_SCALE_FEATURE_LAYER: 'AXES_Y_SCALE_FEATURE_LAYER',//слои с рисками шкалы для слоя основной карты
        AXES_Y_COSMETIC_FEATURE_LAYER: 'AXES_Y_COSMETIC_FEATURE_LAYER',
        CAS_LEGEND: 'CAS_LEGEND', //название стилей для легенды и единиц измерений
        CAS_UNITS: 'CAS_UNITS', //название стилей для легенды и единиц измерений
        CAS_LEGEND_POINT: 'CAS_LEGEND_POINT',
        CAS_LIGHT_AXES: 'CAS_LIGHT_AXES', //стили сетки на карте
        CAS_AXES: 'CAS_AXES',//стиль шкал на карте,
        REQUEST_LINE_PROFILE: 'GAZPROM_SYS_SEM.xml#NEW_CAS_MG_PROFILE',//запрос для получения профиля по LINE_ID, KM_START, KM_END
        KM_REQUEST_SOURCE: 'GAZPROM_SYS_SEM.xml#PIPE_START_END',//запрос получения километража по id линии
    };
    goog.base(this);
};
goog.inherits(ru.corelight.classes.map.CasWidgetMap, ru.corelight.classes.map.BaseWidget);


ru.corelight.classes.map.CasWidgetMap.prototype.setConfig = function(config){
    this.config = config;
    if(config && config.cas){
        var casConfig = config.cas;
        if(casConfig.requests && casConfig.requests){
            var requests = casConfig.requests;
            if(requests.profileBoundsRequest)
                this.CONSTANTS.REQUEST_LINE_PROFILE = requests.profileBoundsRequest;
        }
    }
}

/**
 * Получение настроек начального масштабирования данных
 * @returns {{x: number, y: number, cutY: boolean}}
 */
ru.corelight.classes.map.CasWidgetMap.prototype.getScale = function(){
    var scale = { x: 1, y: 1, cutY: false};
    if(this.config && this.config.cas && this.config.cas.scale){
        var sc = this.config.cas.scale;
        if(sc.x !== undefined) scale.x = sc.x;
        if(sc.y !== undefined) scale.y = sc.y;
        if(sc.cut_y !== undefined) scale.cutY = sc.cut_y;
    }
    return scale;
}

/**
 * TODO перевести на вызов события
 * @param currentState  WidgetMap.MAP_BUTTON_STATE
 * @param currentButton  Текущий контрол, чтобы, по возможности, мы могли его удалить с карты
 */
ru.corelight.classes.map.CasWidgetMap.prototype.changeToolState = function(currentState, currentButton){
    if(goog.isDef(WidgetMap.selectedMapButton))
        $(WidgetMap.selectedMapButton).removeClass('selectedMapButton');
    switch(currentState){
        case WidgetMap.MAP_BUTTON_STATE.PAN:
            WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.PAN;
            map.controls.ZoomBoxControl.reset();
            break;
        case WidgetMap.MAP_BUTTON_STATE.ZOOM:
            WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.ZOOM;
            map.controls.PanControl.reset();
            break;
    }
    if(goog.isDefAndNotNull(currentButton))
        $(currentButton).addClass('selectedMapButton');
    WidgetMap.selectedMapButton = currentButton;
};
//Флаг, для первоначального отображения кнопки "показать трубопровод"
ru.corelight.classes.map.CasWidgetMap.prototype.getMapDrawParams = function(){
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    if (mapConfig) {
        if (mapConfig.MAP_Label_Len_Ratio !== undefined)
            MAX_LABEL_RATIO = parseFloat(mapConfig.MAP_Label_Len_Ratio);
        if (mapConfig.MAP_Len_Ratio !== undefined)
            MIN_VISIBLE_RATIO = parseFloat(mapConfig.MAP_Len_Ratio);
        if (mapConfig.MAP_Label_Font_Ratio !== undefined)
            LABEL_FONT_RATIO = parseFloat(mapConfig.MAP_Label_Font_Ratio);
        if (mapConfig.MAP_Label_Repeat_Ratio !== undefined)
            LABEL_REPEAT_RATIO = parseFloat(mapConfig.MAP_Label_Repeat_Ratio);
        if (mapConfig.MAP_Label_Cut_Tolerance !== undefined)
            LABEL_CUT_TOLERANCE = parseFloat(mapConfig.MAP_Label_Cut_Tolerance);
        if (mapConfig.MAP_Label_Cut_Ratio !== undefined)
            LABEL_CUT_RATIO = parseFloat(mapConfig.MAP_Label_Cut_Ratio);
        if (mapConfig.MAP_Label_Offset !== undefined)
            LABEL_OFFSET = parseFloat(mapConfig.MAP_Label_Offset);
        if (mapConfig.MAP_Label_Draw_Type !== undefined)
            LABEL_DRAW_TYPE = mapConfig.MAP_Label_Draw_Type;
        if (mapConfig.MAP_Use_Kinetic !== undefined && mapConfig.MAP_Use_Kinetic)
            WidgetMap.kinetic = new ol.Kinetic(-0.005, 0.05, 100);

        if (mapConfig.MAP_Matrix_DX !== undefined)
            MAP_MATRIX_DX = mapConfig.MAP_Matrix_DX;
        if (mapConfig.MAP_Matrix_DY !== undefined)
            MAP_MATRIX_DX = mapConfig.MAP_Matrix_DY;
        if (mapConfig.MAP_Legend_Width !== undefined)
            WidgetMap.CAS_LEGEND_WIDTH = mapConfig.MAP_Legend_Width;
        if (mapConfig.MAP_First_Diagram_Offset !== undefined)
            WidgetMap.CAS_GLOBAL_FIRST_OFFSET = parseFloat(mapConfig.MAP_First_Diagram_Offset);
        if (mapConfig.MAP_Diagram_Offset !== undefined)
            WidgetMap.CAS_GLOBAL_OFFSET = parseFloat(mapConfig.MAP_Diagram_Offset);
    }
};
ru.corelight.classes.map.CasWidgetMap.prototype.showObjects = function(params, clearSelectionLayer, ignoreErrors, isCurrentTab, findCallback){
    var that = this;
    that.showObjectsCentering = false;// для ПКА не центрируемся
    that.showObjectsSelect = true;
    that.showObjectsValue = '';
    that.showObjectsGeo= undefined;
    that.showObjectsLayerDescr = '';
    that.ignoreErrors = false;
    //для ПКА
    that.showObjectsUniqueLayerName = undefined;
    that.showObjectError= '';
    that.showObjectsIsGroupButton= true;
    that.showObjectsErrorHandler = undefined;
    that.showObjectsFromFilter = false;
    that.ignoreErrors = false;
    that.loadDynamicData = true;

    var i= 0;
    for (i; i < params.length; i++) {
        var objects = params[i];
        if (objects.name == "objects") {
            that.showObjectsValue = objects.value;
            if(goog.isDef(objects.geo))
                that.showObjectsGeo = objects.geo;
        }
        //для ПКА не центрируемся
        /*if (objects.name == "centering") {
            that.showObjectsCentering = (objects.value=='true' || objects.value == true);
        }*/
        if (objects.name == "select") that.showObjectsSelect = (objects.value=='true' || objects.value == true);
        if (objects.name == "uniqueLayerName") that.showObjectsUniqueLayerName = objects.value;
        if (objects.name == "gridCenteringResultFunction") that.showObjectsErrorHandler = objects.gridCenteringResultFunction;
        if (objects.name == "isGroupButton") that.showObjectsIsGroupButton = (objects.value=='true' || objects.value == true);
        if (objects.name == "fromFilter") that.showObjectsFromFilter = (objects.value=='true' || objects.value == true);
        if (objects.name == "ignoreErrors") that.ignoreErrors = (objects.value == 'true' || objects.value == true);
        if (objects.name == "loadDynamicData") that.loadDynamicData = (objects.value == 'true' || objects.value == true);
    }
    if(that.showObjectsValue != ''){
        var arr = that.showObjectsValue.split(':');
        var layerName = arr[0];
        var layerIds = arr[1].split(',');//array
        if(goog.isDef(that.showObjectsUniqueLayerName))
            layerName = that.showObjectsUniqueLayerName;
        var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
        //если слоя нет в _rasterLayers
        if(goog.isDef(layerObj) && goog.isDef(layerObj.layer))
            that.showObjectsLayerDescr = layerObj.layer.sourceDescr;
        else {
            if(!that.ignoreErrors)
                App.errorReport(gis_widgetmap_1, gis_widgetmap_6, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_20'});
            return;
        }
        if(goog.isDef(that.showObjectsGeo)){
            MapUtil.clearSelectionLayer();
            //переустанавливаем стиль у клона геометрии на тот, дефолтный для выделения
            WidgetMap.layerManager.defaultSelectionStyle(that.showObjectsGeo);

            WidgetMap.mapSelectionLayer.getSource().addFeature(that.showObjectsGeo);
            //добавляем выбранный объект в глобальную переменную
            WidgetMap.mapSelectedObject = that.showObjectsValue;
            WidgetMap.hideLabels(layerName,layerIds);
            //зуммируемся к ним
            if(that.showObjectsCentering){
                var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
                WidgetMap.centerOnMap(extent);
            }
            return;
        }
        //формируем строку ошибочную, если не найдем геометрию
        that.showObjectError = gis_widgetmapcas_3 + ': ' + that.showObjectsLayerDescr + gis_widgetmapcas_17 + that.showObjectsLayerDescr + ':' + arr[1];
        that.showObjectNoDataError = gis_widgetmapcas_4 + ': ' + that.showObjectsLayerDescr;

        //TODO сделать кооректным поведение при подсветке вектора, растра
        if(WidgetMap.isModelsVector == true && goog.isDef(layerObj) && goog.isDef(layerObj.layer.zIndex) ){//zindex - только в векторных слоях есть, либо использовать другой параметр
            if(layerObj.visible){
                //если не нашли из фильтров, то не показываем сообщение об ошибке
                if(that.showObjectsFromFilter == true && layerIds.length == 1 && layerIds[0] == '')
                    return;
                if(layerObj.layer.dataReady_ == false){
                    layerObj.layer.layerLoadCallback = function(result){
                        if(that.showObjectsSelect)
                            WidgetMap.highlightFeatures(layerName, layerIds, that);
                        else
                            WidgetMap.selectFeatures(layerName, layerIds, that);
                        WidgetMap.mapSelectedObject = that.showObjectsValue;
                    };
                    layerObj.layer.loadData();
                }
                else{
                    //ищем геометрии, выделяем по ним и, если надо, центрируемся
                    //нужно разделить ids с PODS_COMPRESSOR_STATION:13001654,13001655 на массив PODS_COMPRESSOR_STATION/13001654, PODS_COMPRESSOR_STATION/13001655
                    if(that.showObjectsSelect)
                        WidgetMap.highlightFeatures(layerName,layerIds, that);
                    else
                        WidgetMap.selectFeatures(layerName, layerIds, that);
                    WidgetMap.mapSelectedObject = that.showObjectsValue;
                }
            }
            else{
                if(that.showObjectsFromFilter == true)
                    return;
                //добавляем callback, чтобы после загрузки прицентрироваться
                if(layerObj.layer.dataReady_ == false){
                    if(that.loadDynamicData) {
                        layerObj.layer.layerLoadCallback = function (result) {
                            if (that.showObjectsSelect)
                                WidgetMap.highlightFeatures(layerName, layerIds, that);
                            else
                                WidgetMap.selectFeatures(layerName, layerIds, that);
                            WidgetMap.mapSelectedObject = that.showObjectsValue;
                        };
                        WidgetMap.layerManager.enableLayer(layerName);
                    }
                }
                else{
                    if(that.loadDynamicData) {
                        WidgetMap.layerManager.enableLayer(layerName);
                        //нужно разделить ids с PODS_COMPRESSOR_STATION:13001654,13001655 на массив PODS_COMPRESSOR_STATION/13001654, PODS_COMPRESSOR_STATION/13001655
                        if (that.showObjectsSelect)
                            WidgetMap.highlightFeatures(layerName, layerIds, that);
                        else
                            WidgetMap.selectFeatures(layerName, layerIds, that);
                        WidgetMap.mapSelectedObject = that.showObjectsValue;
                    }
                }
            }
        }
    }
};
/**
 * Подсветить на карте выбранные объекты
 * @param layerName
 * @param layerIds
 * @param that
 * @param findCallback
 */
ru.corelight.classes.map.CasWidgetMap.prototype.highlightFeatures = function (layerName, layerIds, that, findCallback) {
    var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
    if(goog.isDef(layerObj) && goog.isDef(layerObj.layer)){
        if(!layerObj.layer.hasData){//если данных нет в слое вообще
            if(findCallback)
                findCallback(false);
            else
                MapUtil.showObjectError(that, layerObj, this);
            return;
        }
        var features = WidgetMap.layerManager.getGeometryByLayerNameAndObjId(layerObj.layer,layerIds);
        MapUtil.clearSelectionLayer();
        if(features.length == 0){
            /*if(showObjectsIsGroupButton == true)//если нажата была групповая кнопка, то не показываем ошибки
             return;*/
            if(findCallback)
                findCallback(false);
            else
                MapUtil.showObjectError(that, layerObj, this);
        }
        else{
            if(findCallback)
                findCallback(true);
            var geomPosition = layerObj.layer.layPosition_ + layerObj.layer.layHeight_/2;
            var firstCoord = WidgetMap.layerManager.multSelectedData(features, WidgetMap.prevScaleXCoeff, geomPosition, layerObj.layer.scaleYCoeff_, -layerObj.layer.layPosition_);

            if(firstCoord){
                //выставляем только через value, чтобы не выходить за пределы доступных километражей
                //тут высчитываем значение км по координате
                var n = WidgetMap.positionsArr[WidgetMap.positionsArr.length - 1].position;
                var max = $("#vScrollKm").jqxScrollBar('max');
                var l = layerObj.layer.layPosition_;
                var vValue = max * Math.abs(l)/Math.abs(n);
                $("#vScrollKm").jqxScrollBar('value', vValue);

                //высчитываем через пропорцию положение по X
                //var scale = WidgetMap.mapScaleXCoeff;
                var lastCoord = (WidgetMap.max_km - WidgetMap.min_km) * WidgetMap.prevScaleXCoeff;
                var firstScroll = WidgetMap.min_km;//$("#hScrollKm").jqxScrollBar('min');
                var xCoord = firstCoord[0];
                var xScroll = (WidgetMap.max_km - WidgetMap.min_km) * xCoord / lastCoord + firstScroll;
                var canScroll = (xScroll <= WidgetMap.max_km && xScroll >= WidgetMap.min_km);
                var disabled = WidgetMap.cur_min_km === WidgetMap.min_km && WidgetMap.cur_max_km === WidgetMap.max_km;
                //if(!$("#hScrollKm").jqxScrollBar('disabled'))
                if(canScroll && !disabled)
                    $("#hScrollKm").jqxScrollBar('value', xScroll);
            }
            WidgetMap.mapSelectionLayer.getSource().addFeatures(features);
        }
    }
};
ru.corelight.classes.map.CasWidgetMap.prototype.addModelLayers = function(){
    if(!goog.isDef(WidgetMap.currentVectorGroupLayer)) {
        //добавляем групповой слой на карту
        WidgetMap.currentVectorGroupLayer = new ol.layer.Group();
        WidgetMap.map.addLayer(WidgetMap.currentVectorGroupLayer);

        if(!goog.isDefAndNotNull(WidgetMap.layerManager))
            WidgetMap.layerManager = new LayerManager();

        var models = WidgetMap.config.vectorlayers;
        WidgetMap.isModelsVector = true;
        var mapOrder = 0;
        for(var i=0;i < models.length; i++){
            var modelName = models[i];
            var name = modelName.replace('_Layers.xml','');
            if (goog.isDefAndNotNull(name)) {
                WidgetMap.currentVectorGroupLayerModel[modelName] = new ol.layer.Group();
                WidgetMap.layerManager._vectorMapOrders[name] = mapOrder++;
                WidgetMap.layerManager.parseLayersDescr(modelName);
            }
        }
    }
};
ru.corelight.classes.map.CasWidgetMap.prototype.addBaseControls = function(){
    var that = this;
    try{
        var hideButtons = ru.corelight.classes.map.BaseWidget.getHideButtonsConfig();
        this.hideHScroll = hideButtons.indexOf('HScroll') !== -1;
        //.jqx-scrollbar-thumb-state-hover-horizontal
        //.jqx-fill-state-pressed
        var hiddenElements = (WidgetMap.config && WidgetMap.config.cas && WidgetMap.config.cas.appearance && WidgetMap.config.cas.appearance.hiddenElements)?WidgetMap.config.cas.appearance.hiddenElements:[];
        var sliderWidth = WidgetMap.map.getSize()[0]-80+190-8;//700;
        var hideScrollButtons = hiddenElements.indexOf('scroll-km') !== -1;
        if(hideScrollButtons) sliderWidth += 80;
        $('#hScrollKm').jqxScrollBar({showButtons: true, disabled:false,thumbSize:WidgetMap.getCurrHScrollThumbSize(WidgetMap.BEGIN_KM,WidgetMap.END_KM),
            height: 18, width:sliderWidth, min:WidgetMap.BEGIN_KM,max:WidgetMap.END_KM,
            step:WidgetMap.MIN_START_END_KM_DELTA, theme:'cas'
        })
            .css('position','absolute')
            .css('margin-left','43px')
            .on('valuechanged', function (event) {
                WidgetMap.changeHScrollPosition_();
            });
        if(hideScrollButtons)
            $("#hScrollKm").css('margin-left','0');
        $('#hScrollKm').jqxScrollBar({disabled:true});
        $('#hScrollBeginKm').jqxNumberInput({promptChar: "", textAlign: "right",inputMode: 'simple',
            decimalDigits: 2, groupSeparator: "", min:Number.MIN_VALUE, max:Number.MAX_VALUE, disabled:false,  height: '21px', width: '40px'})
            .css('position','absolute')
            .keydown(function(event) {
                if (event.keyCode === 13) {
                    WidgetMap.onStartEndKmValueChange_(event);
                    return false;
                }
            });

        $('#hScrollEndKm').jqxNumberInput({promptChar: "", textAlign: "left",inputMode: 'simple',
            decimalDigits: 2, groupSeparator: "", min:Number.MIN_VALUE, max:Number.MAX_VALUE,disabled:false,  height: '21px', width: '40px'})
            .css('position','absolute')
            .css('right','32px')
            .keydown(function(event) {
                if (event.keyCode === 13) {
                    WidgetMap.onStartEndKmValueChange_(event);
                    return false;
                }
            });
        if(hideScrollButtons || that.hideHScroll){
            $('#hScrollKm').parent().css('display', 'none');
            $('#hScrollBeginKm').css('display', 'none');
            $('#hScrollEndKm').css('display', 'none');
        }
        if(hiddenElements.indexOf('route-name') !== -1){
            $('#casRouteNameDiv').remove();
        }
        $("#vScrollKm").jqxScrollBar({theme:'cas',vertical: true,width:20,height:'100%',min:0,max:3500}).css('position','absolute').css('right','0px').css('top','0px')
            .on('valuechanged', function (event){
                var currentValue = event.currentValue;
                WidgetMap.map.getView().setCenter([WidgetMap.map.getView().getCenter()[0], -currentValue]);
                WidgetMap.lmap.getView().setCenter([0, -currentValue]);
            });


        //добавляем контролы для зуммирования
        if (hideButtons.indexOf("CASZoomBox") === -1) {
            WidgetMap.map.addControl(new map.controls.CASZoomBoxControl({
                tooltipLabelZoomIn: gis_cas_zoomin_button_hint,
                tooltipLabelZoomOut: gis_cas_zoomout_button_hint
            }));
        }
        //если есть в url id обследования, то подгружаем описание по этому обследованию
        if(WidgetMap.INSPECTION_ID)
            cashelper.loadInspectionDescription(WidgetMap.INSPECTION_ID);
        if (hideButtons.indexOf("PrevSite") == -1) {
            WidgetMap.map.addControl(new map.controls.PreviousSiteControl());
        }
        if (hideButtons.indexOf("CASExportData") == -1)
            WidgetMap.map.addControl(new map.controls.CASExportDataControl({tooltipLabel:gis_cas_exportdata_button_hint}));
        if (hideButtons.indexOf("CASExpand") == -1)
            WidgetMap.map.addControl(new map.controls.CASExpandControl({tooltipLabel:gis_cas_expand_button_hint}));
        if (hideButtons.indexOf("CASLayersOrder") == -1)
            WidgetMap.map.addControl(new map.controls.CASLayersOrderControl({tooltipLabel:gis_cas_layersorder_button_hint}));
        if (hideButtons.indexOf("CASLayers") == -1)
            WidgetMap.map.addControl(new map.controls.CASLayersControl({tooltipLabel:gis_cas_layers_button_hint}));
        if (hideButtons.indexOf("CASAllowText") == -1)
            WidgetMap.map.addControl(new map.controls.CASAllowTextControl({tooltipLabel:gis_cas_allowtext_button_hint}));
        if (hideButtons.indexOf("MapInfo") == -1) {
            WidgetMap.mapInfoControl = new map.controls.MapInfoControl({tooltipLabel: gis_cas_mapinfo_button_hint});
            WidgetMap.map.addControl(WidgetMap.mapInfoControl);
            WidgetMap.mapInfoControl.handleMapInfoClick_();
        }
        /*WidgetMap.managelayersControl = new map.controls.ManageLayersControl();
        WidgetMap.map.addControl(WidgetMap.managelayersControl);*/
        if (hideButtons.indexOf("ExportImageChooser") == -1) {
            WidgetMap.exportImageChooserControl = new map.controls.ExportImageChooserControl({isCas:true, tooltipLabel: gis_cas_print_choose_button_hint});
            WidgetMap.map.addControl(WidgetMap.exportImageChooserControl);

            WidgetMap.exportImageControl = new map.controls.CASExportImageControl({
                tooltipLabelPrint: gis_cas_print_button_hint,
                tooltipLabelExport: gis_cas_exportimage_button_hint

            });
            WidgetMap.map.addControl(WidgetMap.exportImageControl);
        }
        if (hideButtons.indexOf("DSP") == -1)
            WidgetMap.map.addControl(new map.controls.DSPControl());
        if (hideButtons.indexOf("SendMail") == -1)
            WidgetMap.map.addControl(new map.controls.SendMailControl({tooltipLabel:gis_cas_sendmail_button_hint}));

        //кнопки редактирования векторных данных
        /*if (hideButtons.indexOf("EditGeometryChooser") === -1) {
            if (hideButtons.indexOf("EditGeometryControl") === -1) {
                WidgetMap.editGeometryControl = new map.controls.EditGeometryControl();
                WidgetMap.map.addControl(WidgetMap.editGeometryControl);
            }
            if (hideButtons.indexOf("MoveGeometry") === -1) {
                WidgetMap.moveGeometryControl = new map.controls.MoveGeometryControl();
                WidgetMap.map.addControl(WidgetMap.moveGeometryControl);
            }
            if (hideButtons.indexOf("CopyPasteGeometry") === -1) {
                WidgetMap.copyPasteGeometryControl = new map.controls.CopyPasteGeometryControl();
                WidgetMap.map.addControl(WidgetMap.copyPasteGeometryControl);

            }
            if (hideButtons.indexOf("LinkGeometry") === -1) {
                WidgetMap.linkControl = new map.controls.LinkControl();
                WidgetMap.map.addControl(WidgetMap.linkControl);

            }
            if (hideButtons.indexOf("AddObject") === -1) {
                WidgetMap.addObjectControl = new map.controls.AddObjectControl();
                WidgetMap.map.addControl(WidgetMap.addObjectControl);
            }
            if (hideButtons.indexOf("DeleteBufferObject") === -1) {
                WidgetMap.deleteBufferObjectControl = new map.controls.DeleteBufferObjectControl();
                WidgetMap.map.addControl(WidgetMap.deleteBufferObjectControl);
            }

            WidgetMap.map.addControl(new map.controls.EditGeometryChooserControl());
        }*/

    }
    catch(ex){
        App.errorReport(gis_widgetmapcas_20+ ex, ex , undefined, {filename:gis_filename_408, functionname:'gis_filename_408_10'});
    }
};
//добавляем на карту слои с осями
ru.corelight.classes.map.CasWidgetMap.prototype.addVerticalScaleLayers = function(){
    //Добавляем на основную карту риски шкалы
    //слой для основной карты
    if(!goog.isDef(WidgetMap.axesYVectorLayer)){
        var source = new ol.source.Vector({
        });
        var imageVectorSource = new map.layer.ExtImageVector({
            source:source,
            id: WidgetMap.CONSTANTS.AXES_Y_SCALE_FEATURE_LAYER,
            ratio:1
        });
        WidgetMap.axesYVectorLayer = new ol.layer.Image({
            id: WidgetMap.CONSTANTS.AXES_Y_SCALE_FEATURE_LAYER,
            source: imageVectorSource
        });
        WidgetMap.map.addLayer(WidgetMap.axesYVectorLayer);
    }
    if(!goog.isDef(WidgetMap.axesYLineVectorLayer)){
        var source = new ol.source.Vector();
        WidgetMap.axesYLineVectorLayer = new ol.layer.Vector({
            source: source,
            id:WidgetMap.CONSTANTS.AXES_Y_SCALE_FEATURE_LAYER+'_line'
        });
        WidgetMap.map.addLayer(WidgetMap.axesYLineVectorLayer);
    }
};
ru.corelight.classes.map.CasWidgetMap.prototype.firstProcessAllLayersVariables = function(layer){
    if(this.totalLayersCount != 0){
        //Если в переменных есть START_FILTER - включаем для начальной фильтрации
        if(goog.isDef(layer) && goog.isDef(layer.spatialVariables) && goog.isDef(layer.spatialVariables.START_FILTER)
            && goog.isDef(this.firstFilerObject)
            && !goog.isDef(this.firstFilerObject[layer.name])){
            WidgetMap.firstFilerObject[layer.name] = {layer:layer,startFilter:layer.spatialVariables.START_FILTER, completed:false};
        }
        return;
    }
    //Очистка осей
    cashelper.clearAllLayersAxes();
    //Если уже меняли координаты, тогда сперва откатываем их в начальное положение.
    //Остается смещение отрицательных графиков и растяжение 2D графиков !!!
    if (WidgetMap.positionsArr && WidgetMap.positionsArr.length>0){
        //Отменяем смещение слоев
        WidgetMap.moveAllLayersToPosition(true);
    }
    //Смещаем по X
    WidgetMap.multMapData();
    WidgetMap.moveAllLayersToPosition();
    //Изменяем минимальное и максимальное значения вертикального скролла
    WidgetMap.setVScrollMinMaxValues();
    setTimeout(function(){
        $('#CAS').css('visibility','visible');
    },1000);
    //Фильтруем слои (по начальным и установленным из формы управления слоями фильтрам)
    //WidgetMap.startFirstFilter();
};
ru.corelight.classes.map.CasWidgetMap.prototype.getLayerGeoReqParams = function(filter, request) {
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
    return {
        getSchema: false,
        descrId: request,
        toElements: false,
        descrType: 'select',
        data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '" '+ topFiltersStr+''+
            '>'+
            '<data FILTER="ID='+filter+'"/>'+
            '</root>'
    };
};
//когда мы распарсили всё, то смотрим на урл и забирает objects, lineId,..
ru.corelight.classes.map.CasWidgetMap.prototype.layersAndStylesParsed = function(){
    if(goog.isDef(WidgetMap.layerManager)){
        if(WidgetMap.layerManager._rasterLayersQuery == 0 &&
            WidgetMap.layerManager._layersQuery == 0 &&
            WidgetMap.layerManager._styleQuery == 0){
            //подгружаем стили
            for(var i in WidgetMap.layerManager.stylesQueue){
                WidgetMap.layerManager.parseLayersDescr(WidgetMap.layerManager.stylesQueue[i])
            }
            WidgetMap.layerManager.stylesQueue = [];
            MapUtil.reorderVectorLayers();
            WidgetMap.baseLayers = WidgetMap.layerManager.getAllLayersWeak()
            //показываем окно управления слоями/фильтрами
            //и после выбора грузим данные
            var profiles = getParameterByName('PROFILES');
            var zoneId = getParameterByName('ZONE_ID');
            var startKm = WidgetMap.BEGIN_KM;
            var finishKm = WidgetMap.END_KM;
            if(profiles){
                var profilesArr = JSON.parse(decodeURIComponent(profiles));
                WidgetMap.startupLayers = [];
                WidgetMap.waterwayProfiles = profilesArr;
                profilesArr.forEach(function(profile){
                    WidgetMap.startupLayers.push('CAS_MAIN');
                })
                var casLayerForm = new CASLayersBaseForm({
                    startupLayers: WidgetMap.startupLayers,
                    waterwayProfiles: WidgetMap.waterwayProfiles,
                    closeCallback:function(){
                        if(false && getParameterByName('func') == 'showCAS')
                            WidgetMap.checkExternalParamsFromURL();
                        else{
                            //грузим данные для всех видимых слоёв
                            cashelper.loadAllLayersData(false);
                            cashelper.loadMapRect();
                            //TODO передать id запроса, пердаем zone_id, километры
                            var profileData = {
                                ZONE_ID: zoneId,
                                START_KM: startKm,
                                FINISH_KM: finishKm,
                            };
                            WidgetMap.getLineProfile(profileData);
                        }
                    }
                });
                casLayerForm.build();
                return;
            }
            var casLayerForm = new CASLayersBaseForm({
                startupLayers: WidgetMap.startupLayers,
                closeCallback:function(){
                    if(false && getParameterByName('func') == 'showCAS')
                        WidgetMap.checkExternalParamsFromURL();
                    else{
                        //грузим данные для всех видимых слоёв
                        cashelper.loadAllLayersData();
                        cashelper.loadMapRect();

                        var lineData = {
                            LINE_ID: WidgetMap.LINE_ID,
                            KM_START: WidgetMap.BEGIN_KM,
                            KM_END: WidgetMap.END_KM,
                            ZONE_ID: zoneId,
                            START_KM: WidgetMap.BEGIN_KM,
                            FINISH_KM: WidgetMap.END_KM
                        }
                        WidgetMap.getLineProfile(lineData);
                    }

                }
            });
            casLayerForm.build();
        }
    }
};
ru.corelight.classes.map.CasWidgetMap.prototype.setInspectionId = function(){
    var config = WidgetMap.config;
    if(getParameterByName('id') !== ''){
        WidgetMap.INSPECTION_ID = getParameterByName('id')
    }
}
ru.corelight.classes.map.CasWidgetMap.prototype.loadLineData = function(){
    //устанавливаем параметр inspectionId, если работаем с ЭХЗ ПКА
    this.setInspectionId();
    this.setStartupScenario();
    //WidgetMap.checkExternalParamsFromURL();
    if(getParameterByName('func') != 'showCAS'){
        if(getParameterByName('lineId')!='')
            WidgetMap.LINE_ID = getParameterByName('lineId');
        if(getParameterByName('beginKm')!=''){
            WidgetMap.BEGIN_KM = parseFloat(getParameterByName('beginKm'));
            WidgetMap.CURR_MIN_KM =  WidgetMap.BEGIN_KM;
        }
        if(getParameterByName('endKm')!=''){
            WidgetMap.END_KM = parseFloat(getParameterByName('endKm'));
            WidgetMap.CURR_MAX_KM =  WidgetMap.END_KM;
        }
        if(getParameterByName('zoneId')!=''){
            WidgetMap.WATERWAY_TASK = true;
        }
    }
    var queryDataProvider;
    //если открываем ПКА по ЭХЗ и приходит inspection_id, то выставляем описание обследования
    if(WidgetMap.INSPECTION_ID !== undefined){
        queryDataProvider = new QueryDataProvider({
            requestSource: "PODS_SEM_DICT.xml#PODS_PI_CP_INSPECTION",
            resultHandler: function(result){
                if(this.length > 0){
                    var i = 0;
                    var founded = false;
                    for (; i < this.length; i++) {
                        if(this[i].CODE == WidgetMap.INSPECTION_ID){
                            WidgetMap.LINE_DESCR = this[i].DESCR;
                            //если километраж попал в границы скрываем форму и открываем карту
                            WidgetMap.onManualLineChange();
                            founded = true;
                            break;
                        }
                    }
                    if(!founded)
                        App.errorReport(gis_core_error_1,gis_widgetmapcas_22+WidgetMap.INSPECTION_ID, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_20'});
                }
                else
                    App.errorReport(gis_core_error_1,gis_widgetmapcas_22+WidgetMap.INSPECTION_ID, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_21'});
            }
        });
    }
    else{
        queryDataProvider = new QueryDataProvider({
            requestSource: "GAZPROM_SYS_SEM.xml#PIPE_LIST_START_END",
            resultHandler: function(result){
                if(this.length>0){
                    var i = 0;
                    var founded = false;
                    for (; i < this.length; i++) {
                        if(this[i].LINE_ID == WidgetMap.LINE_ID){
                            WidgetMap.LINE_DESCR = this[i].DESCR;
                            //если километраж попал в границы скрываем форму и открываем карту
                            WidgetMap.onManualLineChange();
                            founded = true;
                            break;
                        }
                    }
                    if(!founded)
                        App.errorReport(gis_core_error_1,gis_widgetmapcas_21+WidgetMap.LINE_ID, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_14'});
                }
                else
                    App.errorReport(gis_core_error_1,gis_widgetmapcas_21+WidgetMap.LINE_ID, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_15'});
            }
        });
    }
};
/**
 * Функция обновления карты с графиками после изменения размеров окна
 */
ru.corelight.classes.map.CasWidgetMap.prototype.mapSizeChanged = function(){
    WidgetMap.setCoeffStartEnd(WidgetMap.casScaleCoeff, WidgetMap.curStartX, WidgetMap.curEndX);
    //пересчитываем минимальную позицию вертикального скролла, после изменения габарита карты она будет новой
    cashelper.calcMinScrollY();
    //Изменяем минимальное и максимальное значения вертикального скролла
    WidgetMap.setVScrollMinMaxValues();
    //Устанавливаем текущую позицию в позицию текущего скролла
    //WidgetMap.onVScrollChange();
};
ru.corelight.classes.map.CasWidgetMap.prototype.onManualLineChange = function(){
    function getReqParams() {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: WidgetMap.CONSTANTS.KM_REQUEST_SOURCE,
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+
                '" >'+
                '<data LINE_ID="' + WidgetMap.LINE_ID + '" />'+
                '</root>'
        };
    }

    function getReqResult(resultXml) {
        try {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') {
                App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_16'});
                return;
            }
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var datas = $(layerGeoXml).find("data");
            if(datas.length==1){
                var d = $(datas[0]);
                var profiles = getParameterByName('PROFILES');
                var km_start =  d.attr('KM_START');
                var km_end =  d.attr('KM_END');
                //TODO 03.02.22 Принято решение, если задача водных переходов, то игнорируем результат этого запроса для сверки
                if(profiles){
                    km_start = WidgetMap.BEGIN_KM;
                    km_end = WidgetMap.END_KM;
                }
                //если пришедшие границы вне достунупных границ, выдаем сообщение об ошибке
                if((parseFloat(WidgetMap.END_KM) > parseFloat(km_end) && parseFloat(WidgetMap.BEGIN_KM) > parseFloat(km_end))
                    || (parseFloat(WidgetMap.END_KM) < parseFloat(km_start) && parseFloat(WidgetMap.BEGIN_KM) < parseFloat(km_start))
                    || (parseFloat(WidgetMap.END_KM) < parseFloat(WidgetMap.BEGIN_KM))){
                    var ERROR_KM_MESSAGE = gis_widgetmapcas_9+WidgetMap.BEGIN_KM+gis_widgetmapcas_10+WidgetMap.END_KM+gis_widgetmapcas_11+km_start+gis_widgetmapcas_12+km_end+gis_widgetmapcas_13;
                    App.errorReport(gis_core_error_1,ERROR_KM_MESSAGE, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_17'});
                }
                else{
                    //корректируем километраж
                    if(parseFloat(WidgetMap.END_KM) > parseFloat(km_end)){
                        WidgetMap.END_KM = km_end;
                        WidgetMap.CURR_MAX_KM = km_end;
                    }
                    if(parseFloat(WidgetMap.BEGIN_KM) < parseFloat(km_start)){
                        WidgetMap.BEGIN_KM = km_start;
                        WidgetMap.CURR_MIN_KM = km_start;
                    }
                    if(WidgetMap.BEGIN_KM === WidgetMap.END_KM){
                        WidgetMap.BEGIN_KM -= 0.3;
                        WidgetMap.END_KM += 0.3;
                        if(WidgetMap.BEGIN_KM < 0){
                            WidgetMap.BEGIN_KM = 0;
                            WidgetMap.END_KM += 0.3;
                        }
                        WidgetMap.CURR_MIN_KM = WidgetMap.BEGIN_KM;
                        WidgetMap.CURR_MAX_KM = WidgetMap.END_KM;
                    }
                    WidgetMap.BEGIN_KM = parseFloat(WidgetMap.BEGIN_KM).toFixed(2);
                    WidgetMap.END_KM = parseFloat(WidgetMap.END_KM).toFixed(2);
                    WidgetMap.CURR_MIN_KM = WidgetMap.BEGIN_KM;
                    WidgetMap.CURR_MAX_KM = WidgetMap.END_KM;
                    WidgetMap.init();
                }
            }
            else{
                App.errorReport(gis_core_error_1,er, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_18'});
            }
        }
        catch(e){
        }
        finally{
            BlockingUtil.ready();
        }
    }
    function getReqFault(resultXml) {
        App.errorReport(gis_core_error_1,resultXml, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_19'});
    }
    BlockingUtil.wait();
    //При выборе МГ подгружам километры к нему.
    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getReqParams(), getReqResult, getReqFault,4);
};
/**
 * Функция обработки значений начальной фильтрации из переменной START_FILTER
 */
ru.corelight.classes.map.CasWidgetMap.prototype.startFirstFilter = function(){
    function getReqParams(firstFilerObject) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: firstFilerObject.startFilter,
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+
                '" >'+
                '<data LINE_ID="' + WidgetMap.LINE_ID + '" START_KM="' + WidgetMap.BEGIN_KM + '"  FINISH_KM="' + WidgetMap.END_KM + '"   FILTERED_LAY_NAME="' + ffo.layer.name + '" />'+
                '</root>'
        };
    }

    function getReqResult(resultXml) {
        --this.startFilterLoadedCount_;
        try{
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '')
                App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_5'});
            else{
                var datas = resultXml.getElementsByTagName("data");
                var filterObj = {};
                for (var i = 0; i < datas.length; i++) {
                    //парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
                    filterObj[datas[i].getAttribute("ID")] = true;
                }
            }
        } catch (e) {
        } finally {
            BlockingUtil.ready();
        }
    }
    function getReqFault(resultXml) {
        BlockingUtil.ready();
        --this.startFilterLoadedCount_;
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== '')
            App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_6'});
    }
    for (var layName in this.firstFilerObject){
        var ffo = this.firstFilerObject[layName];
        if ( ffo.completed==false && ffo.layer.visible){
            this.firstFilerObject[layName].completed = true;
            this.startFilterLoadedCount_++;
            /*var layer = WidgetMap.layerManager.getVectorLayerByUniqueName(layName);
            if(goog.isDef(layer) && goog.isDef(layer.layer)){
                layer.layer.loadStartFilter();
            }*/
            BlockingUtil.wait();
            App.serverQueryXML2Node(Services.processQueryNode, getReqParams(ffo), getReqResult, getReqFault);
        }
    }
};
//Изменение предельных значений вертикального скролла
ru.corelight.classes.map.CasWidgetMap.prototype.setVScrollMinMaxValues = function(){
    if (!isNaN(WidgetMap.minScrollY) && !isNaN(WidgetMap.maxScrollY)){
        var disabled = WidgetMap.minScrollY == WidgetMap.maxScrollY;
        $("#vScrollKm").jqxScrollBar({ disabled:disabled, min:WidgetMap.minScrollY, max:WidgetMap.maxScrollY,
            step:(WidgetMap.maxScrollY - WidgetMap.minScrollY)/10,
            largestep:(WidgetMap.maxScrollY - WidgetMap.minScrollY)/10});
    }
};
//Располагаем слои на карте в соответствии с переменными из файлов запросов геометрии этих слоев (обрабатываем эти переменные)
ru.corelight.classes.map.CasWidgetMap.prototype.processAllLayersVariables = function(layer){
    if(this.totalLayersCount != 0){
        //Если в переменных есть START_FILTER - включаем для начальной фильтрации
        if(goog.isDef(layer) && goog.isDef(layer.spatialVariables) && goog.isDef(layer.spatialVariables.START_FILTER)
            && goog.isDef(this.firstFilerObject)
            && !goog.isDef(this.firstFilerObject[layer.name])){
            this.firstFilerObject[layer.name] = {layer:layer,startFilter:layer.spatialVariables.START_FILTER, completed:false};
        }
        return;
    }
    //WidgetMap.formatClearMaxMeasure()
    //Очистка осей
    cashelper.clearAllLayersAxes();
    //upd. 09.06.21 принято решение чистить при каждом масштабировании, смене параетров чистить
    MapUtil.clearSelectionLayer();
    //Если уже меняли координаты, тогда сперва откатываем их в начальное положение.
    //Остается смещение отрицательных графиков и растяжение 2D графиков !!!
    if (WidgetMap.positionsArr && WidgetMap.positionsArr.length>0){
        //Отменяем смещение слоев
        WidgetMap.moveAllLayersToPosition(true);
    }
    //Смещаем по X
    WidgetMap.multMapData();
    WidgetMap.moveAllLayersToPosition();
    //Изменяем минимальное и максимальное значения вертикального скролла
    WidgetMap.setVScrollMinMaxValues();
    //Фильтруем слои (по начальным и установленным из формы управления слоями фильтрам)
    //WidgetMap.startFirstFilter();
};
/**
 * Перерисовка всех графиков, если меняли порядок слоёв, изменяли высоту
 * по оси x можно не откатывать изменения
 */
ru.corelight.classes.map.CasWidgetMap.prototype.redrawAllLayers = function(){
    WidgetMap.processAllLayersVariables();
    //Если уже меняли координаты, тогда сперва откатываем их в начальное положение.
    //Остается смещение отрицательных графиков и растяжение 2D графиков !!!
    /*if (WidgetMap.positionsArr && WidgetMap.positionsArr.length>0){
        //Отменяем смещение слоев
        WidgetMap.moveAllLayersToPosition(true);
    }
    WidgetMap.moveAllLayersToPosition();

    //Изменяем минимальное и максимальное значения вертикального скролла
    WidgetMap.setVScrollMinMaxValues();*/
};
/**
 * Функция отрисовки вертикальной шкалы для каждого 2D графика
 * @param {String}layId
 * @param {number}layPosition
 * @param {number}layHeight
 * @param {number}maxValue
 * @param {number}minValue
 * @param {number}colSteps
 */
ru.corelight.classes.map.CasWidgetMap.prototype.drawVerticalScale = function(layId, layPosition, layHeight, maxValue, minValue, colSteps, cutYMin){
    if(!goog.isDef(layId) || !goog.isDef(layPosition) || !goog.isDef(layPosition) || maxValue==minValue)
        return;
    var mapLay = WidgetMap.layerManager.getVectorLayerByUniqueName(layId);
    WidgetMap.addVerticalScaleLayers();
    //Смещение, которое будем каждый раз прибавлять к y для отрисовки следующей риски
    var yDelta = layHeight/colSteps;
    var scaleDelta = (maxValue - minValue)/colSteps;
    //Если у нас есть сохраненные значения для этого слоя - пользуемся ими !!!
    if (goog.isDef(WidgetMap.yScaleData) && goog.isDef(WidgetMap.yScaleData[layId])){
        //Но некоторые параметры нужно перезаписать (layPosition, layHeight, colSteps) !!!
        WidgetMap.yScaleData[layId].layPosition = layPosition;
        WidgetMap.yScaleData[layId].layHeight = layHeight;
        WidgetMap.yScaleData[layId].colSteps = colSteps;
        WidgetMap.yScaleData[layId].minValue = minValue;
        WidgetMap.yScaleData[layId].maxValue = maxValue;
    }
    else{
        WidgetMap.yScaleData[layId] = {yDelta:yDelta, scaleDelta:scaleDelta, layId:layId, layPosition:layPosition, layHeight:layHeight, maxValue:maxValue, minValue:minValue, colSteps:colSteps};
    }
    //
    var legendLabelAxeGeoFtr = WidgetMap.axesYVectorLayer.getSource().getSource().getFeatureById('labelScaleY');
    var legendLabelAxeGeo;
    //добавляем нижнюю границу
    var linePntArr = [], flatCoords = [];

    for (var i=0; i<colSteps+1; i++){
        var pntAxeScale;
        var lonLat = WidgetMap.map.getCoordinateFromPixel([0,0]);
        pntAxeScale = [lonLat[0], layPosition + yDelta * i];
        linePntArr.push(pntAxeScale);
        pntAxeScale = [lonLat[0] + 1, layPosition + yDelta*i];
        linePntArr.push(pntAxeScale);
        pntAxeScale = [lonLat[0], layPosition + yDelta*i];
        linePntArr.push(pntAxeScale);
        pntAxeScale = [lonLat[0], layPosition + yDelta*(i+1)];
        linePntArr.push(pntAxeScale);
        var curScaleText = (minValue + scaleDelta * i).toFixed(1);
        //Если в подписи шкалы (верт., гор.) целое число - не выводить ".0"
        curScaleText = parseFloat(curScaleText.toString());
        //curScaleText = new util.StringUtil().removeTrailingZeros(curScaleText);
        var labelPosition = layPosition;
        //Рисуем невидимую линию длиной в 100 у.е., чтобы подпись показывалась в любом случае (слишком короткие линии могут не отображаться и подпись пропадет).
        var labelPnt1 = [lonLat[0] + 1, labelPosition + yDelta*i - 1];
        var labelPnt2 = [lonLat[0] + 10, labelPosition + yDelta*i - 1];
        var lineLabelGeo = new ol.geom.LineString([labelPnt1,labelPnt2],ol.geom.GeometryLayout.XY);
        if(mapLay.layer.featureProjLayer.getSource().getSource().getFeatures().length>0){
            var stName = 'labelScaleY';
            var geoId = 'label'+layId+Math.abs(layPosition + i).toString();
            if (!goog.isDefAndNotNull(legendLabelAxeGeoFtr)){
                legendLabelAxeGeo = new ol.geom.MultiLineString(null);
                legendLabelAxeGeo.appendLineString(lineLabelGeo);
                legendLabelAxeGeoFtr = new ol.Feature(legendLabelAxeGeo);
                legendLabelAxeGeoFtr.setId('labelScaleY');
                legendLabelAxeGeoFtr.set('type', WidgetMap.CONSTANTS.CAS_UNITS);
                legendLabelAxeGeoFtr.set('layerId', stName);
                legendLabelAxeGeoFtr.set('labelType', stName);
                legendLabelAxeGeoFtr.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
                legendLabelAxeGeoFtr.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
                legendLabelAxeGeoFtr.set('pointsObj', globalLinesGEOs_[stName]);
                legendLabelAxeGeoFtr.set('pointsObjAll', globalLinesGEOs_[stName]);
                legendLabelAxeGeoFtr.setStyle(function(){
                    var s = WidgetMap.layerManager.getStyleByNameAndType(WidgetMap.CONSTANTS.CAS_UNITS,'LineString');
                    if(!goog.isNull(s)) {
                        if (goog.isDef(globalLinesLabels_['labelScaleY']) ) {
                            var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(WidgetMap.CONSTANTS.CAS_UNITS, 'LineString');
                            if (!goog.isNull(textstyle) && textstyle.fontSize != '-1')//TODO заменить на нормальную функцию
                                map.layer.VectorLayer.prototype.setTextStyle(s, textstyle);
                            else
                                map.layer.VectorLayer.prototype.setTextStyle(s, null);
                        }
                        if (goog.isArray(s))
                            return [s[0]];
                        return [s];
                    }
                });
                WidgetMap.axesYVectorLayer.getSource().getSource().addFeature(legendLabelAxeGeoFtr);
            }
            else{
                legendLabelAxeGeo = legendLabelAxeGeoFtr.getGeometry();
                if (goog.isDef(legendLabelAxeGeo)){// && !legendLabelAxeGeoFtr.data.hasOwnProperty(lineLabelGeo.id) && legendLabelAxeGeo.addComponent(lineLabelGeo)){
                    //legendLabelAxeGeoFtr.data[lineLabelGeo.id] = {geo:lineLabelGeo, ID:lineLabelGeo.id, LABEL:curKmText};
                    legendLabelAxeGeo.appendLineString(lineLabelGeo);
                }
            }
            globalLinesLabels_[stName].push({label:curScaleText,id:geoId,geo:lineLabelGeo});
            globalLinesGEOs_[stName][geoId] = lineLabelGeo;
        }
    }
};
/**
 * Функция отрисовки горизонтальной шкалы для горизонтальных осей каждой карты и вертикальных линий по всей карте
 * @param {Number} layPosition
 * @param {Number} colSteps default=10
 */
ru.corelight.classes.map.CasWidgetMap.prototype.drawHorizontalScale = function(layPosition, colSteps, layHeight){
    //проверка верхнего уровня, указывается в настройках задачи
    var hiddenElements = (WidgetMap.config && WidgetMap.config.cas && WidgetMap.config.cas.appearance && WidgetMap.config.cas.appearance.hiddenElements)?WidgetMap.config.cas.appearance.hiddenElements:[];
    var needDrawScales = hiddenElements.indexOf('horizontal-scale') === -1;
    if(!goog.isDef(layPosition) || !goog.isDef(colSteps))
        return;

    //Добавляем на основную карту риски шкалы
    //слой для основной карты
    if(!goog.isDef(WidgetMap.axesXVectorLayer)){
        var source = new ol.source.Vector({
        });
        var imageVectorSource = new map.layer.ExtImageVector({
            source:source,
            id: WidgetMap.CONSTANTS.AXES_X_SCALE_FEATURE_LAYER,
            ratio:1
        });
        WidgetMap.axesXVectorLayer = new ol.layer.Image({
            id: WidgetMap.CONSTANTS.AXES_X_SCALE_FEATURE_LAYER,
            source: imageVectorSource
        });
        if(needDrawScales)
            WidgetMap.map.addLayer(WidgetMap.axesXVectorLayer);
    }
    if(!goog.isDef(WidgetMap.axesXLineVectorLayer)){
        var source = new ol.source.Vector();
        WidgetMap.axesXLineVectorLayer = new ol.layer.Vector({
            source: source,
            id:WidgetMap.CONSTANTS.AXES_X_SCALE_FEATURE_LAYER+'_line'
        });
        WidgetMap.map.addLayer(WidgetMap.axesXLineVectorLayer);
    }

    //Смещение, которое будем каждый раз прибавлять к x для отрисовки следующей риски
    var xDelta = WidgetMap.map.getSize()[0]/colSteps;
    var kmDelta = (WidgetMap.curEndX - WidgetMap.curStartX)/colSteps;
    //Незаметные дополнительные вертикальные линии
    var lineAddAxeGeoFtr = WidgetMap.axesXVectorLayer.getSource().getSource().getFeatureById('lineAdd');
    var lineAddAxeGeo;
    //Шкала
    var legendLabelAxeGeoFtr = WidgetMap.axesXVectorLayer.getSource().getSource().getFeatureById('labelScale');
    var legendLabelAxeGeo;
    //добавляем нижнюю границу
    var linePntArr = [];
    var firstPnt = [WidgetMap.map.getCoordinateFromPixel([0,0])[0], layPosition];
    linePntArr.push(firstPnt);
    for (var i=0; i<colSteps; i++){
        var pntAxeScale;
        var lonLat = WidgetMap.map.getCoordinateFromPixel([xDelta*(i+1),0]);
        var lonLatEnd = WidgetMap.map.getCoordinateFromPixel([xDelta*(i+2),0]);
        pntAxeScale = [lonLat[0], layPosition];
        linePntArr.push(pntAxeScale);
        pntAxeScale = [lonLat[0], layPosition+1];
        linePntArr.push(pntAxeScale);
        pntAxeScale = [lonLat[0], layPosition-1];
        linePntArr.push(pntAxeScale);
        pntAxeScale = [lonLat[0], layPosition];
        linePntArr.push(pntAxeScale);
        pntAxeScale = [lonLatEnd[0], layPosition];
        linePntArr.push(pntAxeScale);

        //Добавляем на карту текстовые подписи c километром для каждой риски
        var curKmText = (WidgetMap.min_km + WidgetMap.curStartX + kmDelta*(i+1)).toFixed(2);
        //curKmText = new util.StringUtil().removeTrailingZeros(curKmText);
        //Рассчитываем позицию подписи
        var labelPosition = layPosition;
        var labelPnt1 = [lonLat[0] - 3, labelPosition];
        var labelPnt2 = [lonLatEnd[0] - 5, labelPosition];
        var lineLabelGeo = new ol.geom.LineString([labelPnt1,labelPnt2],ol.geom.GeometryLayout.XY);
        var stName = 'labelScale';
        var geoId = stName+Math.abs(layPosition + i).toString();
        if (!goog.isDefAndNotNull(legendLabelAxeGeoFtr)){
            legendLabelAxeGeo = new ol.geom.MultiLineString(null);
            legendLabelAxeGeo.appendLineString(lineLabelGeo);
            legendLabelAxeGeoFtr = new ol.Feature(legendLabelAxeGeo);
            legendLabelAxeGeoFtr.setId('labelScale');
            legendLabelAxeGeoFtr.set('type', WidgetMap.CONSTANTS.CAS_UNITS);
            legendLabelAxeGeoFtr.set('layerId', stName);
            legendLabelAxeGeoFtr.set('labelType', stName);
            legendLabelAxeGeoFtr.set('labelsObj', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
            legendLabelAxeGeoFtr.set('labelsObjAll', globalLinesLabels_[stName]);//массив с id геометрии и её подписью
            legendLabelAxeGeoFtr.set('pointsObj', globalLinesGEOs_[stName]);
            legendLabelAxeGeoFtr.set('pointsObjAll', globalLinesGEOs_[stName]);
            legendLabelAxeGeoFtr.setStyle(function(){
                var s = WidgetMap.layerManager.getStyleByNameAndType(WidgetMap.CONSTANTS.CAS_UNITS,'LineString');
                if(!goog.isNull(s)) {
                    if (goog.isDef(globalLinesLabels_['labelScale']) ) {
                        var textstyle = WidgetMap.layerManager.getTextStyleByNameAndType(WidgetMap.CONSTANTS.CAS_UNITS, 'LineString');
                        if (!goog.isNull(textstyle) && textstyle.fontSize != '-1')//TODO заменить на нормальную функцию
                            map.layer.VectorLayer.prototype.setTextStyle(s, textstyle);
                        else
                            map.layer.VectorLayer.prototype.setTextStyle(s, null);
                    }
                    if (goog.isArray(s))
                        return [s[0]];
                    return [s];
                }
            });
            WidgetMap.axesXVectorLayer.getSource().getSource().addFeature(legendLabelAxeGeoFtr);
        }
        else{
            legendLabelAxeGeo = legendLabelAxeGeoFtr.getGeometry();
            if (goog.isDef(legendLabelAxeGeo)){// && !legendLabelAxeGeoFtr.data.hasOwnProperty(lineLabelGeo.id) && legendLabelAxeGeo.addComponent(lineLabelGeo)){
                //legendLabelAxeGeoFtr.data[lineLabelGeo.id] = {geo:lineLabelGeo, ID:lineLabelGeo.id, LABEL:curKmText};
                legendLabelAxeGeo.appendLineString(lineLabelGeo);
            }
        }
        globalLinesLabels_[stName].push({label:curKmText,id:geoId,geo:lineLabelGeo});
        globalLinesGEOs_[stName][geoId] = lineLabelGeo;

        //Точки незаметных дополнительных вертикальных линий
        var pntAdd1 = [lonLat[0], layPosition];
        var pntAdd2 = [lonLat[0], layPosition+layHeight];
        var lineAddGeo = new ol.geom.LineString([pntAdd1,pntAdd2],ol.geom.GeometryLayout.XY);
        //Добавляем незаметные линии по вертикали, чтобы удобнее было просматривать километры
        if (!goog.isDefAndNotNull(lineAddAxeGeoFtr)){
            lineAddAxeGeo = new ol.geom.MultiLineString(null);
            lineAddAxeGeo.appendLineString(lineAddGeo);
            lineAddAxeGeoFtr = new ol.Feature(lineAddAxeGeo);
            lineAddAxeGeoFtr.setStyle(function(){
                    var s = WidgetMap.layerManager.getStyleByNameAndType(WidgetMap.CONSTANTS.CAS_LIGHT_AXES,'LineString');
                    if(!goog.isNull(s)) {
                        if (goog.isArray(s))
                            return [s];
                        return [s];
                    }
                }
            );

            WidgetMap.axesXLineVectorLayer.getSource().addFeature(lineAddAxeGeoFtr);
        }
        else{
            lineAddAxeGeo = lineAddAxeGeoFtr.getGeometry();
            if (goog.isDef(lineAddAxeGeo))
                lineAddAxeGeo.appendLineString(lineAddGeo);
        }

    }
    //Добавляем собственно шкалу
    var axeScaleGeo = new ol.geom.LineString(linePntArr,ol.geom.GeometryLayout.XY);
    var mAxeScaleGeo = new ol.geom.MultiLineString(null);
    mAxeScaleGeo.appendLineString(axeScaleGeo);
    var axeScaleGeoFtr = new ol.Feature(mAxeScaleGeo);
    axeScaleGeoFtr.setStyle(function(){
        var s = WidgetMap.layerManager.getStyleByNameAndType(WidgetMap.CONSTANTS.CAS_AXES,'LineString');
        if(!goog.isNull(s)) {
            if (goog.isArray(s))
                return [s[0]];
            return [s];
        }
    });
    WidgetMap.axesXLineVectorLayer.getSource().addFeature(axeScaleGeoFtr);
};
/**
 * Запрашиваем по идентификаторам геометрию. Когда подгрузится - обновляем экстент карты
 */
ru.corelight.classes.map.CasWidgetMap.prototype.processRasterLayerGeometry = function(request, centering){
    //Не используется
};
ru.corelight.classes.map.CasWidgetMap.prototype.changeMapView = function(maxZoom){
    var cc = WidgetMap.map.getView().getCenter();
    var resolutions = [];
    var minZoom = 4;
    //дизейблим форму перехода по координатам, если она открыта

    WidgetMap.map.setView(new ol.View({
        maxZoom: maxZoom,
        projection: WidgetMap.DEFAULT_PROJECTION,
        minZoom: minZoom,
        center: cc,
        zoom: 7,
        resolutions:resolutions
    }));
};
/**
 * Проверяем, есть ли в url параметры, пришедшие из внешней системы
 * Если есть, то работаем через externalFunctionaAPI
 */
ru.corelight.classes.map.CasWidgetMap.prototype.checkExternalParamsFromURL = function(){
    if(getParameterByName('func') == 'showCAS')
        showCAS(getParameterByName('type'), getParameterByName('systemId'), getParameterByName('lineId'),getParameterByName('objectName'), getParameterByName('beginKm'), getParameterByName('endKm'));
};
/**
 * Реакция на нажатие ESC
 * @private
 */
ru.corelight.classes.map.CasWidgetMap.prototype.handleEscClick_ = function () {
    BlockingUtil.wait();
    try {
        //прячем попап с измерениями линейкой
        if(map.controls.MeasureControl)
            map.controls.MeasureControl.reset()
        if (goog.isDef(WidgetMap.baseInteraction) && goog.isDef(WidgetMap.baseInteraction.abortDrawing_))
            WidgetMap.baseInteraction.abortDrawing_();
        if (goog.isDef(WidgetMap.currentVectorLayer))
            WidgetMap.currentVectorLayer.getSource().clear();
        WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
        WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);
        WidgetMap.map.removeControl(WidgetMap.drawControl);
        //удалить interaction и выставить ладошку
        if(goog.isDef(WidgetMap.panControl))
            map.controls.PanControl.prototype.handlePanClick_();
        //WidgetMap.infoControl.handleMapInfoClick_();

    }
    catch (ex) {}
    finally {
        BlockingUtil.ready();
    }
};

var WidgetMap = new ru.corelight.classes.map.CasWidgetMap();



_CURRENT_RENDERING_LAYERS = [];//массив слоёв, которые в данные момент перерисовываются полностью при отпускании мыши

WidgetMap.MAP_BUTTON_STATE = {
    PAN:'pan',
    ZOOM:'zoom',
    INFO:'info'
};

WidgetMap.CAS_GLOBAL_OFFSET = 0;
WidgetMap.CAS_GLOBAL_FIRST_OFFSET = 0;
WidgetMap.CAS_LEGEND_WIDTH = 190;

WidgetMap.MULTI_MODE_LAYERS = [];
WidgetMap.MODES = {
    VECTOR:'vector',
    RASTER:'raster'
};

//список удаленных с карты объектов, чтобы в дальнейшем была возможность их восстановить после закрытия панели свойств
WidgetMap.recentlyDeletedObjectsFromMap = {};
// объект на карте, который подвергается удалению узлов для корректного отката геометрии в случае закрытия панели свойств или ошибочная команда в БД
WidgetMap.currentCutFeature = {};
WidgetMap.CURRENT_MODE = WidgetMap.MODES.VECTOR;


//временный слой, в который помещается выделенный объект, чтобы прятать подписи
WidgetMap.tempLayerWithoutLabels = {layerName:'',allowText:true};

WidgetMap.currentMapButtonState = WidgetMap.MAP_BUTTON_STATE.PAN;

//текущие данные для привязки объекта при сохранении
WidgetMap.CURRENT_SAVING_BIND_GEOMETRY = undefined;
//текущие данные для привязки объекта при сохранении без геометрии
WidgetMap.CURRENT_SAVING_BIND_WO_GEOMETRY = undefined;

WidgetMap.canFirstTimeCentering = true;

/*  Какого типа модель в задачах(вектор или быстрые кеши). Используется, чтобы определить в каком виде изначально зуммироваться
 * через вектор или через сервис */
WidgetMap.isModelsVector = false;

//список слоёв для добавления в стартовый результирующий список
WidgetMap.startupLayers = undefined;
//километраж из переменных или flashVars
//переменная для задачи пка эхз
WidgetMap.INSPECTION_ID = undefined;

//флаг, что работаем с задачей водных переходов, где в url присутствует zoneId, для корректировки геометрий при загрузке
WidgetMap.WATERWAY_TASK = false;
WidgetMap.LINE_ID =	1300012;
WidgetMap.LINE_DESCR =	'';
WidgetMap.BEGIN_KM = 1593.7;
WidgetMap.END_KM = 1700;
WidgetMap.CURR_MAX_KM = 1700;
WidgetMap.CURR_MIN_KM = 1593.7;
//переменная ограничиваем минимальную длину слайдера
WidgetMap.MIN_START_END_KM_DELTA = 0.1;
WidgetMap.CONTROLS_HEIGHT = 0;//23


WidgetMap.START_X = 40;
WidgetMap.START_Y = 58;
WidgetMap.START_ZOOM = 9;
WidgetMap.DEFAULT_PROJECTION = 'EPSG:5807';

//Фильтры верхнего уровня по-умолчанию, которые передаются в запрос
WidgetMap.currentTopFilter = [
    //{name: 'LPU_ACCESS_FILTER', value: '13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0'}
];

//Фильтры среднего уровня по-умолчанию, которые передаются в запрос
WidgetMap.currentRoughFilter = [];
//текущие фильтры для слоя
WidgetMap.currentFilter = {};

WidgetMap.layerManager = undefined;

//векторный слоя для рисования
WidgetMap.currentVectorLayer = undefined;


WidgetMap.mapSelectionLayer = undefined;
//текущий выбранный объект
WidgetMap.mapSelectedObject = undefined;


//флаг, можно ли искать в данной подложке по растрам
WidgetMap.showRasterInfo = false;

//базовое взаимодействие на карте. Чтобы была возможность менять его при режиме зуммирования, перемещения,..
WidgetMap.baseInteraction = undefined;
/*TODO потом всё объединить в объект с массивом интеракций для каждой кнопки*/
WidgetMap.baseInteractionEditGeometry = undefined;

//текущий групповой слой с данными из распарсенных настроек карты <Models>
WidgetMap.currentVectorGroupLayer = undefined;
WidgetMap.currentVectorGroupLayerModel = {};

var MIN_VISIBLE_RATIO = 0.001;
var MAX_LABEL_RATIO = 1.5;
var LABEL_FONT_RATIO = 0.9;
var LABEL_REPEAT_RATIO = 0.8;
var LABEL_CUT_TOLERANCE = 20;
var LABEL_CUT_RATIO = 0.3;
var LABEL_OFFSET = 0;
var LABEL_DRAW_TYPE = 'cut';

//Разрядка карты легенды по X и Y
WidgetMap.MAP_LEGEND_MATRIX_DX = 10;
WidgetMap.MAP_LEGEND_MATRIX_DY = 10;

//Предыдущий коэфффициент, на который умножались все координаты X
WidgetMap.prevScaleXCoeff = 1;

//коэффициент, на который растягивается ряд чтобы поместиться ровно в карту
WidgetMap.mapScaleXCoeff = 1;
//коэффициент, на который растягивается ряд чтобы поместить участок ровно в карту
WidgetMap.casScaleCoeff = 1;
//Текущий начальный километр
WidgetMap.curStartX = 0;
//Текущий конечный километр
WidgetMap.curEndX = 0;

//Коллекция километров и линейных дистанций для трубопровода
WidgetMap.dataColl = undefined;

//Число делений на горизонтальной шкале основной карты
WidgetMap.COL_X_SCALE_STEPS = 10;


//Массив с позициями каждого слоя, заполняется по ходу перебора массива слоев.
//Потом используется для возврата координат в исходную позицию (при этом растяжение останется!)
WidgetMap.positionsArr = [];

//Объект с сохраненными в нем данными для отрисовки значений на вертикальных шкалах
//с начальными значениями (до любых смещений)
WidgetMap.yScaleData = {};

//перечень начальных выбранных профилей водных переходов
//TODO убрать хардкод для задачи водных перезходов
WidgetMap.waterwayProfiles = undefined;

WidgetMap.maxScrollY;
WidgetMap.minScrollY;
WidgetMap.controlsHeightLat = 0;

//список слоёв с копиями на показ на карте
WidgetMap.finalLayers = [];

WidgetMap.commonFilters = {};//все фильтры выпадающие и выбранные в них значения, чтобы потом не заполнять в подобных слоях

WidgetMap.baseLayers = [];

//создаем 2 флага, чтобы различать, было ли просто вкл/выкл видимости из рубрикатора или движение карты
var _TEMP_LAYERS_LABELS = {};// временные подписи, если просто вкл/выкл видимость слоя
var _IS_CHANGE_LAYER_VISIBILITY = {};//заносим сюда подписи из отдельных слоев
var _IS_FULL_REDRAW = false; // в этом случае перерисовывается все векторы, т.к. зхуммировались или т.п.

var _CURRENT_RENDERED_LAYERS = [];

WidgetMap.init = function () {
    CURRENT_MAP_TYPE = MAP_TYPE.CAS;
    WidgetMap.getMapDrawParams();
    WidgetMap.addMap();
    //загружаем дефолтные стили
    if(!goog.isDefAndNotNull(WidgetMap.layerManager))
        WidgetMap.layerManager = new LayerManager({layersReadyCallback:WidgetMap.layersAndStylesParsed});
    WidgetMap.layerManager.loadDefaultStyles('Default_STYLE.xml', "default_cas_style.xml");
    WidgetMap.addModelLayers();
    WidgetMap.addMapSelectionLayer();
    WidgetMap.addBaseControls();
};

WidgetMap.addMap = function(){
    //забираем из url параметры
    if(getParameterByName('func') != 'showCAS'){
        if(getParameterByName('lineId')!='')
            WidgetMap.LINE_ID = getParameterByName('lineId');
        if(getParameterByName('beginKm')!=''){
            WidgetMap.BEGIN_KM = parseFloat(getParameterByName('beginKm'));
            WidgetMap.CURR_MIN_KM =  WidgetMap.BEGIN_KM;
        }

        if(getParameterByName('endKm')!=''){
            WidgetMap.END_KM = parseFloat(getParameterByName('endKm'));
            WidgetMap.CURR_MAX_KM =  WidgetMap.END_KM;
        }
        if(WidgetMap.BEGIN_KM === WidgetMap.END_KM){
            WidgetMap.BEGIN_KM -= 0.3;
            WidgetMap.END_KM += 0.3;
            if(WidgetMap.BEGIN_KM < 0){
                WidgetMap.BEGIN_KM = 0;
                WidgetMap.END_KM += 0.3;
            }
            WidgetMap.CURR_MIN_KM = WidgetMap.BEGIN_KM;
            WidgetMap.CURR_MAX_KM = WidgetMap.END_KM;
        }
        WidgetMap.BEGIN_KM = parseFloat(WidgetMap.BEGIN_KM).toFixed(2);
        WidgetMap.END_KM = parseFloat(WidgetMap.END_KM).toFixed(2);
        WidgetMap.CURR_MIN_KM = WidgetMap.BEGIN_KM;
        WidgetMap.CURR_MAX_KM = WidgetMap.END_KM;
    }

    var kmStr =  gis_widgetmapcas_15 + parseFloat(WidgetMap.BEGIN_KM).toFixed(2) + gis_widgetmapcas_16 + parseFloat(WidgetMap.END_KM).toFixed(2) + ')';
    if(getParameterByName('objectName')!=''){
        var objectName = getParameterByName('objectName');
        $('#casRouteName').text(objectName + kmStr);
    }
    else if(WidgetMap.LINE_DESCR!='')
        if(WidgetMap.INSPECTION_ID !== undefined)
            $('#casRouteName').text(WidgetMap.LINE_DESCR);
        else
            $('#casRouteName').text(WidgetMap.LINE_DESCR + kmStr);
    else
        $('#casRouteNameDiv').remove();
    //устанавливаем дефолтные элементы взаимодействия
    var interactions = new ol.Collection();
    //устанавливаем базовое взаимодействие на карте
    /*WidgetMap.baseInteraction = new ol.interaction.DragPan({
        kinetic: (goog.isDef(WidgetMap.kinetic))?WidgetMap.kinetic:null
    });
    interactions.push(WidgetMap.baseInteraction);*/

    var projection = new ol.proj.Projection({
        code: 'EPSG:5807',
        // The extent is used to determine zoom level 0. Recommended values for a
        // projection's validity extent can be found at http://epsg.io/.
        extent: [-10508.34,-10508.34,10508.34,10508.34],//-1000000,-10508.34,1000000,10508.34
        units: 'm'
    });
    ol.proj.addProjection(projection);
    var nominalResolution = 1.40625;
    nominalResolution *= 20;
    var numZoomLevels = 16;
    var resolutions = [];
    resolutions.push(nominalResolution);
    var i = 1;
    for(; i < numZoomLevels; i++){
        resolutions.push(resolutions[i-1]/2);
    }
    //устанавливаем легенду
    WidgetMap.lmap = new ol.Map({
        target: 'lmap',
        renderer: 'canvas',
        ol3Logo: false,
        view: new ol.View({
            maxZoom: 16,
            projection: WidgetMap.DEFAULT_PROJECTION,
            minZoom:WidgetMap.START_ZOOM,
            center:[0,0],
            zoom: WidgetMap.START_ZOOM
        }),
        interactions: new ol.Collection(),
        controls: new ol.Collection()
    });

    //устанавливаем карту
    WidgetMap.map = new ol.Map({
        target: 'map',
        renderer: 'canvas',
        ol3Logo: false,
        view: new ol.View({
            maxZoom: 16,
            projection: WidgetMap.DEFAULT_PROJECTION,
            minZoom:WidgetMap.START_ZOOM,
            center:[0,0],
            zoom: WidgetMap.START_ZOOM
        }),
        interactions: interactions,
        controls: new ol.Collection()
    });


    WidgetMap.map.on('precompose', cashelper.onPreCompose);
    WidgetMap.map.on('postcompose', cashelper.onPostCompose);
    WidgetMap.lmap.on('postcompose', cashelper.onPostComposeLegend);
    //TODO такое же событие повесить на движение обзорной карты
    WidgetMap.map.on('moveend', cashelper.onMoveEnd);
    WidgetMap.mapHistory = new MapHistory({map:WidgetMap.map});
    //добавляем на карту листенер по esc, отменять все интеракции и включать ладошку
    $('body').on('keyup',function(event){
        if(event.keyCode == 27 && WidgetMap.currentMapButtonState != WidgetMap.MAP_BUTTON_STATE.PAN){
            if(goog.isDef(WidgetMap.baseInteraction) && goog.isDef(WidgetMap.baseInteraction.box_)){
                WidgetMap.baseInteraction.box_.setMap(null);
            }
            WidgetMap.map.removeInteraction(WidgetMap.baseInteraction);
            WidgetMap.map.removeInteraction(WidgetMap.baseInteractionEditGeometry);
            WidgetMap.map.removeControl(WidgetMap.drawControl);
            if(goog.isDef(WidgetMap.mapInfoControl))
                WidgetMap.mapInfoControl.handleMapInfoClick_();
        }
    });
};

/**
 * Динамически получить размеры ползунка
 * @returns {number}
 */
WidgetMap.getCurrHScrollThumbSize = function(min,max){
    var newSize = parseInt((max-min)*200/20);
    if(newSize<=20)
        newSize = 20;
    return newSize;
};

/**
 * Функция отслеживает изменение позиции скролла (перетаскивание бегунка) и отражает изменение на карту ПКА
 * @private
 */
WidgetMap.changeHScrollPosition_ = function(){
    //проверить, что не просто клик по ползунку
    //Рассчитываем ширину в километрах отображаемого участка
    var curLength = WidgetMap.cur_max_km - WidgetMap.cur_min_km;
    if(curLength == 0)
        return;
    //прошлый центр:
    var currVal = $("#hScrollKm").jqxScrollBar('value');
    if(!isNaN(currVal)){
        WidgetMap.cur_max_km = currVal + curLength/2;
        WidgetMap.cur_min_km = currVal - curLength/2;
    }
    if(WidgetMap.cur_max_km > WidgetMap.max_km){
        WidgetMap.cur_max_km = WidgetMap.max_km;
    }
    if(WidgetMap.cur_min_km < WidgetMap.min_km){
        WidgetMap.cur_min_km = WidgetMap.min_km;
    }
    WidgetMap.refreshScrollToolTip();
    WidgetMap.OnKmChange();
};

WidgetMap.onStartEndKmValueChange_ = function(event){
    var startValue = $('#hScrollBeginKm').jqxNumberInput('val');
    var endValue = $('#hScrollEndKm').jqxNumberInput('val');
    var disabled = (startValue == WidgetMap.min_km && endValue == WidgetMap.max_km);
    $('#hScrollKm').jqxScrollBar({disabled:disabled});
    //Если устанавливаем точно такие же начальный и конечный километры - ничего не делаем
    var minimum = WidgetMap.min_km;
    var maximum = WidgetMap.max_km;
    if (!isNaN(startValue) && !isNaN(endValue)
        && (WidgetMap.cur_min_km!=startValue || WidgetMap.cur_max_km!=endValue)){
        //устанавливаем текущие начало/конец отрезка
        if(startValue < minimum  || startValue > maximum || endValue < minimum || endValue > maximum ){
            App.confirmDialog(gis_widgetmapcas_6);
            $('#hScrollBeginKm').jqxNumberInput('val',WidgetMap.cur_min_km);
            $('#hScrollEndKm').jqxNumberInput('val',WidgetMap.cur_max_km);
            return;
        }
        else if(startValue > endValue ){
            if(goog.isDef(event)){
                var nId =  $(event.currentTarget).attr('id');
                //var ns:NumericStepper = event.currentTarget as NumericStepper;
                if(goog.isDef(nId) && nId == "hScrollBeginKm"){
                    WidgetMap.cur_max_km = endValue;
                    startValue = endValue - WidgetMap.MIN_START_END_KM_DELTA;
                    WidgetMap.cur_min_km = startValue;
                }
                if(goog.isDef(nId) && nId == "hScrollEndKm"){
                    WidgetMap.cur_min_km = startValue;
                    endValue = startValue + WidgetMap.MIN_START_END_KM_DELTA;
                    WidgetMap.cur_max_km = endValue;
                }
            }
        }
        else{
            WidgetMap.cur_min_km = startValue;
            WidgetMap.cur_max_km = endValue;
        }

        WidgetMap.refreshScrollToolTip();
        //Устанавливаем ширину скроллинга и параметры скроллирования исходя из принятых начала/конца отрезка
        WidgetMap.changeHScrollParams();
    }
    WidgetMap.OnKmChange();

};


/**
 * TODO перенести в контрол перемещения по километру
 */
//Константа минимальной длины отображаемого участка профиля
WidgetMap.minLength = 1/Number.MAX_VALUE;

WidgetMap.minMeasure = 0;
WidgetMap.min_km = 0;			// минимальный километр
WidgetMap.max_km = 0.01;			// максимальный километр
WidgetMap.cur_min_km = 0;		// текущий минимальный километр
WidgetMap.cur_max_km = 0.01;		// текущий максимальный километр
WidgetMap._xScale = 1000;			// текущий масштаб
//Здась хранится коэффициент растяжения скроллинга, нужен при вычислениях
WidgetMap.coeff = 1;
//Получение профиля трубопровода
WidgetMap.needLoadLineProfile = true;
WidgetMap.getLineProfile = function(params, callback){
    params = params || {};
    function getLayerGeoReqParams(request) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        // '<data LINE_ID="'+WidgetMap.LINE_ID+'" KM_START="'+WidgetMap.BEGIN_KM+'" KM_END="'+WidgetMap.END_KM+'" />'+
        var dataStr = DBUtil.serializeData(params);
        return {
            descrId: request,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '" >' +
            dataStr +
            '</root>'
        };
    }
    function getLayerGeoResult(resultXml) {
        try {
            var er = HTTPServiceUtil.getError(resultXml);
            if (er !== '') {
                App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_11'});
                return;
            }
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var datas = $(layerGeoXml).find("data");
            WidgetMap.cur_min_km = Number.MIN_VALUE;
            WidgetMap.cur_max_km = Number.MIN_VALUE;
            if(datas.length>0){
                WidgetMap.minMeasure = parseFloat($(datas[0]).attr("ABS_MEASURE"));
                var minAbsMeasure = parseFloat($(datas[0]).attr("ABS_MEASURE"));
                var maxAbsMeasure = parseFloat($(datas[datas.length-1]).attr("ABS_MEASURE"));
                //maxAbsMeasure = 1474.4249;
                WidgetMap.setStartEndLineKms(minAbsMeasure, maxAbsMeasure);
                WidgetMap.setStartEndValues(WidgetMap.min_km, WidgetMap.max_km);
                //Передаем изменения на карту ПКА
                WidgetMap.dataColl = datas;
                WidgetMap.OnKmChange();
                if(callback) callback();
            }
        }
        catch(e){
        }
    }
    function getLayerGeoFault(resultXml) {
        App.errorReport(gis_core_error_1, resultXml, undefined, {filename:gis_filename_408, functionname:'gis_filename_408_12'});
    }
    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getLayerGeoReqParams(WidgetMap.CONSTANTS.REQUEST_LINE_PROFILE), getLayerGeoResult, getLayerGeoFault,4);
};

//Установка минимального начального и максимального конечного километров для LINE
WidgetMap.setStartEndLineKms = function(startLineKm, endLineKm){
    WidgetMap.min_km = startLineKm; //Number(_currentLine.@KM_START);
    if (isNaN(WidgetMap.min_km))
        WidgetMap.min_km = 0;
    if (WidgetMap.min_km >= 0){
        WidgetMap.max_km = endLineKm; //Number(_currentLine.@KM_END);
        WidgetMap.max_km = !isNaN(WidgetMap.max_km) ? WidgetMap.max_km : WidgetMap.min_km + 1/Number.MAX_VALUE;
        //Если min_km > max_km, меняем их местами
        if (WidgetMap.min_km > WidgetMap.max_km){
            var tmpVal = WidgetMap.min_km;
            WidgetMap.min_km = WidgetMap.max_km;
            WidgetMap.max_km = tmpVal;
        }
        WidgetMap.BEGIN_KM = WidgetMap.min_km;
        WidgetMap.END_KM = WidgetMap.max_km;
        WidgetMap.CURR_MAX_KM =  WidgetMap.END_KM;
        WidgetMap.CURR_MIN_KM = WidgetMap.BEGIN_KM;
        WidgetMap.BEGIN_KM = parseFloat(WidgetMap.BEGIN_KM).toFixed(2);
        WidgetMap.END_KM = parseFloat(WidgetMap.END_KM).toFixed(2);
        WidgetMap.CURR_MIN_KM = parseFloat(WidgetMap.CURR_MIN_KM).toFixed(2);
        WidgetMap.CURR_MAX_KM = parseFloat(WidgetMap.CURR_MAX_KM).toFixed(2);
        //Устанавливаем минимальную длину
        WidgetMap.minLength = WidgetMap.MIN_START_END_KM_DELTA;

        //Устанавливаем значения максимума, минимума и текущих километров в поля ввода
        $('#hScrollBeginKm').jqxNumberInput('val',WidgetMap.min_km);
        var tick = Math.abs(WidgetMap.min_km - WidgetMap.max_km)/10;
        tick = parseFloat(tick.toFixed(2));
        var min = WidgetMap.min_km+tick;
        var max = WidgetMap.max_km-tick;
        $('#hScrollKm').jqxScrollBar({min:min, max:max,step:tick});
        $('#hScrollEndKm').jqxNumberInput('val',WidgetMap.max_km);
    }
};
//Функция для установки текущего начального и конечного километров (используется при масштабировании инструментами)
WidgetMap.setStartEndValues = function(startValue, endValue){
//Если устанавливаем точно такие же начальный и конечный километры - ничего не делаем
    if (WidgetMap.cur_min_km != startValue || WidgetMap.cur_max_km != endValue){
        //устанавливаем текущие начало/конец отрезка
        WidgetMap.cur_min_km = startValue;
        WidgetMap.cur_max_km = endValue;
        //раздизейбливаем элементы
        var disabled = !(WidgetMap.cur_min_km != WidgetMap.min_km && WidgetMap.cur_max_km != WidgetMap.max_km);
        $('#hScrollKm').jqxScrollBar({disabled:disabled});
        if (WidgetMap.cur_min_km > WidgetMap.cur_max_km){
            var tmpVal = WidgetMap.cur_min_km;
            WidgetMap.cur_min_km = WidgetMap.cur_max_km;
            WidgetMap.cur_max_km = tmpVal;
        }
        WidgetMap.refreshScrollToolTip();
        //Устанавливаем ширину скроллинга и параметры скроллирования исходя из принятых начала/конца отрезка
        WidgetMap.changeHScrollParams();
    }
};

//Функция отображения в подписи бегунка текущих начального и конечного километров
WidgetMap.refreshScrollToolTip = function(){
    //Здесь же обновляем значения в полях ввода километров startKm и endKm
    $('#hScrollBeginKm').jqxNumberInput('value',WidgetMap.cur_min_km);
    $('#hScrollEndKm').jqxNumberInput('val',WidgetMap.cur_max_km);
};

//Изменение скролла при изменении начального и конечного километров
//На самом деле меняем ширину innerCanv, чтобы скроллинг на mainCanv автоматически растянулся до нужного размера
WidgetMap.changeHScrollParams = function(){
    var that = this;
    //upd. 09.06.21 принято решение чистить при каждом масштабировании, смене параетров чистить
    MapUtil.clearSelectionLayer();

    //рассчитываем коэффициент растяжения по текущим километрам
    WidgetMap.coeff = (WidgetMap.max_km - WidgetMap.min_km)/(WidgetMap.cur_max_km - WidgetMap.cur_min_km);
    //Рассчитываем центр в километрах
    var center = WidgetMap.min_km + ((WidgetMap.cur_min_km - WidgetMap.min_km) + (WidgetMap.cur_max_km - WidgetMap.min_km))/2;
    //Рассчитываем ширину в километрах отображаемого участка
    var curLength = WidgetMap.cur_max_km - WidgetMap.cur_min_km;
    //Рассчитываем минимальный и максимальный километр для позиции скролла
    var minKmScroll = WidgetMap.min_km + curLength/2;
    var maxKmScroll = WidgetMap.max_km - curLength/2;
    if (maxKmScroll != minKmScroll) {
        var tick = Math.abs(WidgetMap.cur_min_km - WidgetMap.cur_max_km) / 10;
        tick = parseFloat(tick.toFixed(2));
        //$("#hScrollKm").jqxScrollBar({value: center, min: minKmScroll, max: maxKmScroll, step: tick});
        if(!that.hideHScroll){
            $("#hScrollKm").jqxScrollBar({thumbSize: WidgetMap.getCurrHScrollThumbSize(WidgetMap.cur_min_km, WidgetMap.cur_max_km)});
            $("#hScrollKm").jqxScrollBar({value: center, min: minKmScroll, max: maxKmScroll, step: tick});
        }
       /* else
            $("#hScrollKm").jqxScrollBar({value: center});*/
    }
};

/* Функция изменения текущих километров - отправляет событие карте для растяжения и смещения
* основные данные для ПКА отправляются в атрибутах drawMapEvt.descr :
* @CAS_COEFF - отношения длины текущего выбранного участка к общей длине трубы
* @MIN_KM - текущий минимальный километр
* @MAX_KM - текущий максимальный километр
*/
WidgetMap.OnKmChange = function(){
    var that = this;
    var datas = WidgetMap.dataColl;
    //смещаем карту ПКА в новую позицию
    if(datas.length>0){
        //Для ПКА рассчитываем по формуле, в какое место нужно центроваться (по Y не центруемся)
        //передаем только centerX, это значит что по y смещаться НЕ будем

        //Рассчитываем absMeasure для начала и конца отрезка
        var absMeasureMin = Math.min( parseFloat($(datas[0]).attr("ABS_MEASURE")) , WidgetMap.min_km);
        var absMeasureMax = Math.max( parseFloat($(datas[datas.length-1]).attr("ABS_MEASURE")), WidgetMap.max_km);
        
        var curAbsMeasureMin = absMeasureMin + (absMeasureMax - absMeasureMin) * (WidgetMap.cur_min_km - WidgetMap.min_km)/(WidgetMap.max_km - WidgetMap.min_km);
        var curAbsMeasureMax = absMeasureMin + (absMeasureMax - absMeasureMin) * (WidgetMap.cur_max_km - WidgetMap.min_km)/(WidgetMap.max_km - WidgetMap.min_km);
        //Рассчитываем положение начала и конца отрезка для ПКА
        var curXmin = curAbsMeasureMin - WidgetMap.min_km;
        var curXmax = curAbsMeasureMax - WidgetMap.min_km;
        //Выводим значения
        //Если не нашли минимального или максимального километра по значениям, центруемся по абсолютным
        if (isNaN(curXmin)){
            curXmin = absMeasureMin - WidgetMap.min_km;
        }
        if (isNaN(curXmax)){
            curXmax = absMeasureMax - WidgetMap.min_km;
        }
        var lineXmin = (absMeasureMin - WidgetMap.min_km);
        var lineXmax = (absMeasureMax - WidgetMap.min_km);
        //Устанавливаем нужные для ПКА параметры
        // @CAS_COEFF - отношения длины текущего выбранного участка к общей длине трубы
        // @MIN_KM - текущий минимальный километр
        // @MAX_KM - текущий максимальный километр
        var CAS_COEFF = (lineXmax - lineXmin)/(curXmax - curXmin);
        WidgetMap.setCoeffStartEnd(CAS_COEFF,curXmin,curXmax);
    }
};
/****
 *
 *
 * ФУНКЦИИ ДЛЯ РАБОТЫ С ПКА
 *
 *
 * ****/

//Функция установки масштабного коэффициента и начального/конечного километра
WidgetMap.setCoeffStartEnd = function(coeff, startX, endX){
    WidgetMap.casScaleCoeff = coeff;
    WidgetMap.curStartX = startX;
    WidgetMap.curEndX = endX;
    //Считаем коэффициент растяжения максимума и минимума пикетажа по максимуму и минимуму карты
    //чтобы начало и конец данных по X вставали ровно в 0 и map.width карты
    var kmStartPx = WidgetMap.map.getPixelFromCoordinate([0,0]);
    var kmEndPx = WidgetMap.map.getPixelFromCoordinate([WidgetMap.CURR_MAX_KM - WidgetMap.CURR_MIN_KM,0]);
    kmStartPx[0]*=getBrowserZoom();
    kmStartPx[1]*=getBrowserZoom();
    kmEndPx[0]*=getBrowserZoom();
    kmEndPx[1]*=getBrowserZoom();
    //Для расчета используем mapCanvas.width, так как ширина карты обновиться НЕ УСПЕВАЕТ !
    WidgetMap.mapScaleXCoeff = WidgetMap.map.getSize()[0]/(kmEndPx[0] - kmStartPx[0]);
    //Заново рисуем оси с делениями по X и по Y
    cashelper.clearAllHorizontalScales();
    cashelper.clearAllVerticalScales();
    cashelper.clearAllCosmeticElements();
    //пересчитываем координаты X
    WidgetMap.multMapData();
    WidgetMap.map.renderSync();
    //WidgetMap.lmap.getView().setCenter([0,WidgetMap.lmap.getView().getCenter()[1]]);
    //В positionsArr храниться информация, является ли слой замыкающим для карты и размер шага
    if (WidgetMap.positionsArr && WidgetMap.positionsArr.length>0){
        var k=0;
        for (; k< WidgetMap.positionsArr.length; k++){
            var layObj = WidgetMap.positionsArr[k];
            //Перерисовываем горизонтальные оси
            if (layObj && goog.isDef(layObj.position) && goog.isDef(layObj.height)){
                cashelper.drawHorizontalAxes(layObj.position, layObj.height);
                if(layObj.layer.needScale)
                    WidgetMap.drawHorizontalScale(layObj.position, WidgetMap.COL_X_SCALE_STEPS, layObj.height);
                if(layObj.layer.cosmeticElements.length > 0){
                    cashelper.drawCosmeticElements(layObj.position,layObj.layer);
                }
            }

            var siblingGroupPosition = null;
            if(layObj.groupId){
                //var zOrder = WidgetMap.layerManager.getHorizontalPosition(layersArr[i].groupId);
                WidgetMap.positionsArr.forEach(function(p){
                    if(p.layer.groupId === layObj.groupId )
                        siblingGroupPosition = p;
                });
            }
            var layerLabel = layObj.layer.sourceDescr;
            if(goog.isDef(layObj.layer.spatialVariables) && goog.isDef(layObj.layer.spatialVariables.LABEL))
                layerLabel = layObj.layer.spatialVariables.LABEL;
            if(layObj.layer.legendDescr !='')
                layerLabel = layObj.layer.legendDescr;
            var lastDiagram = k == WidgetMap.positionsArr.length-1;
            if(!layObj.groupId){
                cashelper.drawLegendHorizontalAxes(layObj.position, layObj.height, layerLabel, lastDiagram);
            }
            else{
                //cashelper.drawLegendHorizontalAxes(layObj.position, layObj.height, layerLabel, lastDiagram);
                cashelper.drawLegendTextHorizontalAxes(siblingGroupPosition.position, layObj.height, layerLabel, layObj.groupId);
            }

        }
    }
    //В yScaleData храниться информация для отрисовки вертикальных шкал
    for (var layId in WidgetMap.yScaleData){
        var mapLay = WidgetMap.layerManager.getVectorLayerByUniqueName(layId);

        //Перерисовывать шкалы будем только если их слои видимы
        if (goog.isDef(mapLay) && goog.isDef(mapLay.layer) && mapLay.visible){
            var cutY =mapLay.layer.cutYMin;
            WidgetMap.drawVerticalScale(layId, WidgetMap.yScaleData[layId].layPosition, WidgetMap.yScaleData[layId].layHeight,
                WidgetMap.yScaleData[layId].maxValue, WidgetMap.yScaleData[layId].minValue, WidgetMap.yScaleData[layId].colSteps);
        }
    }
    WidgetMap.map.renderSync();
};

//Функция пересчета координат X при событии изменения километров или изменения размеров карты
WidgetMap.multMapData = function(){
    var newScaleXCoeff = WidgetMap.mapScaleXCoeff * WidgetMap.casScaleCoeff;
    var curScaleXCoeff = newScaleXCoeff/WidgetMap.prevScaleXCoeff;
    //Пробегаемся по всем слоям карты ПКА, умножая координату X на коэффициент
    //Изменение координат X в слоях (если данные не нанесены, они будут умножены при нанесении)
    var layersArr = WidgetMap.layerManager.getVectorLayersByMode();
    var i=0;
    for (; i<layersArr.length; i++){
        var layer = layersArr[i].layer;
        if(goog.isDef(layer)){
            layer.setScaleXCoeff(curScaleXCoeff);
            layer.newScaleXCoeff = newScaleXCoeff;
        }
    }
    //сохранение нового коэффициента как предыдущего
    WidgetMap.prevScaleXCoeff = newScaleXCoeff;
    //Установка нового центра для карты
    var newX = newScaleXCoeff * (WidgetMap.curStartX + WidgetMap.curEndX)/2;

    //При изменении высоты карты нужно передвинуть центр так, чтобы map.extent.top = 0
    var newY = WidgetMap.map.getView().getCenter()[1];

    //При установке масштаба за базовый берем константу MAP_ZOOM (все данные будут показываться в нем)
    WidgetMap.map.getView().setCenter([newX, newY]);
    //WidgetMap.map.getView(WidgetMap.START_ZOOM);
};



WidgetMap.formatClearMaxMeasure = function(){
    var maxMeasure = 1574.39;
    /*var layersArr = WidgetMap.layerManager.getVectorLayersByMode();
    var i=0;
    for (; i<layersArr.length; i++){
        var layer = layersArr[i].layer;
        if(goog.isDef(layer)){
        }
    }*/
    //Показываю весь профиль
    //Меняем значения текущих километров на минимальное и максимальное
    WidgetMap.setStartEndLineKms(WidgetMap.min_km, maxMeasure);
    WidgetMap.setStartEndValues(WidgetMap.min_km, WidgetMap.max_km);
}

//Функция смещения данных всех слоев массива layersArr по Y и отката смещения для возврата слоев в исходное положение по Y (при rollback==true)
WidgetMap.moveAllLayersToPosition = function(rollback){
    cashelper.clearAllHorizontalScales();
    cashelper.clearAllVerticalScales();
    cashelper.clearAllCosmeticElements();
    //Откатываем координаты в начальное положение.
    //Остается смещение отрицательных графиков и растяжение 2D графиков !!!
    if(rollback == true){
        if(goog.isDef(WidgetMap.positionsArr) && WidgetMap.positionsArr.length>0)
            for(var i in WidgetMap.positionsArr){
                var layObj = WidgetMap.positionsArr[i];
                //Позиция слоя - это позиция предыдущего слоя плюс текущая высота
                layObj.lastLayPosition = null;
                layObj.colXScaleSteps = null;
                if (goog.isDef(layObj) && goog.isDef(layObj.layer) && goog.isDef(layObj.position)
                    && goog.isDef(layObj.height) && goog.isDef(layObj.type) ){
                    var casLayer = layObj.layer ;
                    var originMin = cashelper.getOriginalMinBounds(layObj.layer.uniqueLayerName);
                    var originMax = cashelper.getOriginalMaxBounds(layObj.layer.uniqueLayerName);
                    //Нанесенную геометрию слоя смещаем обратно в начальную позицию
                    WidgetMap.moveLayerToPosition(casLayer, layObj.position, layObj.height, layObj.type, rollback,4,false,originMin,originMax);
                }
            }
        WidgetMap.positionsArr = [];
        return;
    }
    var layersArr = WidgetMap.layerManager.getVectorLayersByMode();
    var i=0;
    //Накапливаем высоту слоев одной и той же карты чтобы сделать общую подпись
    var mapName = '';
    var mapNameHeight = 0;
    var lastLayPosition = 0;
    //обнуляем перед рисование осей объекты
    globalLinesLabels_['labelScale'] = [];
    globalPointsLabels_['labelLegend'] = [];
    globalLinesLabels_['labelScaleY'] = [];
    globalLinesGEOs_['labelScale'] = {};
    globalPointsGEOs_['labelLegend'] = {};
    globalLinesGEOs_['labelScaleY'] = {};
    var groupPosition = {} // временное

    for (; i<layersArr.length; i++) {
        var layer = layersArr[i].layer;
        if(!layersArr[i].visible)
            continue;
        if(layer.groupId && !groupPosition[layer.groupId]){
           groupPosition[layer.groupId] = {height: -1};
        }
        //Проверяем название карты - если слой уже из другой карты нужно отрисовывать ту
        if (mapName!="" && layer.mapName != mapName){
            //Сохраняем в последний объект массива positionsArr признак что слой завершает карту
            if (WidgetMap.positionsArr && WidgetMap.positionsArr.length>0){
                WidgetMap.positionsArr[WidgetMap.positionsArr.length-1].lastLayPosition = lastLayPosition;
                WidgetMap.positionsArr[WidgetMap.positionsArr.length-1].colXScaleSteps = WidgetMap.COL_X_SCALE_STEPS;
            }
            if(layer.needScale)
                WidgetMap.drawHorizontalScale(lastLayPosition,WidgetMap.COL_X_SCALE_STEPS, mapNameHeight);
            if(layer.cosmeticElements.length > 0){
                cashelper.drawCosmeticElements(lastLayPosition,layer);
            }
            mapName = layer.mapName;
            mapNameHeight = 0;
        }
        //Получаем переменные для отрисовки осей
        //Позиция слоя - это позиция предыдущего слоя плюс текущая высота
        var layPosition;
        var layHeight;
        var layLabel = '';
        var layLabelUnit = '';
        var layDiagType = 'ID';
        //Переменная количества делений на вертикальной шкале
        var colYScaleSteps = 4;
        var groupId = layer.groupId;
        for(var nameAttr in layer.spatialVariables){
            switch(nameAttr){
                case 'HEIGHT':
                    //коэффициент, чтобы по высоте с фйлешом совпадало
                    var hCoef = 0.7;
                    layHeight = hCoef * parseFloat(layer.spatialVariables[nameAttr]);
                    if(groupId){
                        //выбираем максимальую высоту группы графиков
                        //TODO пройтись по всем слоям из группы и получить макс высоту
                        if(layHeight > groupPosition[groupId].height) groupPosition[groupId].height = layHeight;
                        else layHeight = groupPosition[groupId].height;
                    }
                    break;
                case 'LABEL':
                    layLabel = layer.spatialVariables[nameAttr];
                    break;
                case 'LABEL_UNIT':
                    layLabelUnit = layer.spatialVariables[nameAttr];
                    break;
                case 'TYPE':
                    //Тип диаграммы - если не 2D считаем ее 1D
                    var valueAttr = layer.spatialVariables[nameAttr];
                    switch(valueAttr){
                        case '2D':
                        case 'interval':
                            layDiagType = valueAttr;
                            break;
                        default:{
                            layDiagType = '1D';
                            break;
                        }
                    }
                    break;
                case 'Y_STEPS':
                    colYScaleSteps = parseFloat(layer.spatialVariables[nameAttr]);
                    break;
            }
        }
        //высота в пикселях
        var firstPx = WidgetMap.map.getPixelFromCoordinate([0, 0]);
        var secondPx = WidgetMap.map.getPixelFromCoordinate([layHeight, 0]);
        firstPx[0]*=getBrowserZoom();
        firstPx[1]*=getBrowserZoom();
        secondPx[0]*=getBrowserZoom();
        secondPx[1]*=getBrowserZoom();
        if(goog.isNull(firstPx) || goog.isNull(secondPx))
            return;
        var defaultHeight =  Math.abs(parseInt(secondPx[0] - firstPx[0]));
        //Если нужные параметры были найдены - рисуем оси
        if(isNaN(layer.expandValue))
            layer.expandValue = defaultHeight;
        layHeight = layer.expandValue*layHeight/defaultHeight;
        if (!isNaN(layHeight)){
            layPosition = WidgetMap.positionsArr.length>0 ? WidgetMap.positionsArr[WidgetMap.positionsArr.length-1].position - layHeight : -layHeight;
            //layPosition = -layHeight;
            //если слой из группы, то проставляем ему горизонтальную позицию

            if(WidgetMap.CAS_GLOBAL_OFFSET != 0 && i != 0)
                layPosition -= WidgetMap.CAS_GLOBAL_OFFSET;
            if(WidgetMap.CAS_GLOBAL_FIRST_OFFSET != 0 && i == 0)
                layPosition -= WidgetMap.CAS_GLOBAL_FIRST_OFFSET;
            //ищем позицию в уже сохраненных слоях с таким же groupId
            var siblingGroupPosition = null;
            if(layersArr[i].groupId){
                //var zOrder = WidgetMap.layerManager.getHorizontalPosition(layersArr[i].groupId);
                WidgetMap.positionsArr.forEach(function(p){
                    if(p.layer.groupId === layer.groupId )
                        siblingGroupPosition = p;
                });
            }
            //если нашли позицию, то
            if(siblingGroupPosition){
                WidgetMap.positionsArr.push({layer:layer, position:siblingGroupPosition.position, height:layHeight, type:layDiagType, lastLayPosition:null, colXScaleSteps:null, groupId: layersArr[i].groupId});
            }
            else{
                WidgetMap.positionsArr.push({layer:layer, position:layPosition, height:layHeight, type:layDiagType, lastLayPosition:null, colXScaleSteps:null, groupId: layersArr[i].groupId});
            }

            //Сохраняем mapName, mapNameHeight и lastLayPosition для отрисовки общей подписи карты
            mapName = layer.mapName;
            mapNameHeight += layHeight;
            var layerLabel = layer.sourceDescr;
            if(goog.isDef(layer.spatialVariables) && goog.isDef(layer.spatialVariables.LABEL))
                layerLabel = layer.spatialVariables.LABEL;
            if(layer.legendDescr !='')
                layerLabel = layer.legendDescr;
            var lastDiagram = false;
            if( i == layersArr.length-1)
                lastDiagram = true;

            if(!siblingGroupPosition){
                lastLayPosition = layPosition;
                //Сохраняем максимальную позицию для вертикального скролла только если текущий слой выходит за пределы карты
                //если слой не последний
                //if(i != layersArr.length-1)
                WidgetMap.maxScrollY = Math.abs(layPosition - layHeight) > Math.abs(WidgetMap.minScrollY*2) ? Math.abs(layPosition - layHeight) - WidgetMap.minScrollY : WidgetMap.minScrollY;
                //Если диаграмма не 2D - layLabelUnit обнуляем.
                if (layDiagType!="2D" && layDiagType!="interval") layLabelUnit = "";
                //Рисуем оси согласно текущей позиции и высоте и добавляем индекс слоя, если это чья-то копия
                //WidgetMap.drawLayerAxes(layId, layPosition, layHeight, layLabel+lay.cloneAppendixStr, layLabelUnit);

                //Добавляем на основную карту оси для текущего слоя
                cashelper.drawHorizontalAxes(layPosition, layHeight);
                cashelper.drawLegendHorizontalAxes(layPosition, layHeight, layerLabel, lastDiagram);
                if(layer.needScale)
                    WidgetMap.drawHorizontalScale(layPosition,WidgetMap.COL_X_SCALE_STEPS,layHeight);
                if(layer.cosmeticElements.length > 0){
                    cashelper.drawCosmeticElements(lastLayPosition,layer);
                }
                //Нанесенную геометрию слоя смещаем в свою позицию
                //перепроверить minbounds
                var originMin = cashelper.getOriginalMinBounds(layer.uniqueLayerName);
                var originMax = cashelper.getOriginalMaxBounds(layer.uniqueLayerName);

                WidgetMap.moveLayerToPosition(layer, layPosition, layHeight, layDiagType, false, colYScaleSteps, false, originMin, originMax );
            }
            else{
                var groupIndex = Number(siblingGroupPosition.layer.groupIndex) + 1;
                cashelper.drawLegendTextHorizontalAxes(siblingGroupPosition.position, layHeight, layerLabel, groupIndex, layersArr[i].groupId);
                WidgetMap.moveLayerToPosition(layer, siblingGroupPosition.position, layHeight, layDiagType, false, colYScaleSteps, false, originMin, originMax );
            }

        }
    }
    //Отрисовываем название последней карты
    if (lastLayPosition!=0 && mapNameHeight!=0){
        //drawLayersMapName(lastLayPosition, mapNameHeight, mapName);
        //Сохраняем в последний объект массива positionsArr признак что слой завершает карту
        if (WidgetMap.positionsArr && WidgetMap.positionsArr.length>0){
            WidgetMap.positionsArr[WidgetMap.positionsArr.length-1].lastLayPosition = lastLayPosition;
            WidgetMap.positionsArr[WidgetMap.positionsArr.length-1].colXScaleSteps = WidgetMap.COL_X_SCALE_STEPS;
        }
        //пересчитываем коэффициент
        WidgetMap.maxScrollY  = Math.abs(lastLayPosition)-WidgetMap.minScrollY+20;
        if( WidgetMap.maxScrollY<WidgetMap.minScrollY)
            WidgetMap.maxScrollY = WidgetMap.minScrollY;
        var disabled = WidgetMap.minScrollY == WidgetMap.maxScrollY;
        $("#vScrollKm").jqxScrollBar({ disabled:disabled, min:WidgetMap.minScrollY, max:WidgetMap.maxScrollY,
            step:(WidgetMap.maxScrollY - WidgetMap.minScrollY)/10,
            largestep:(WidgetMap.maxScrollY - WidgetMap.minScrollY)/10});
    }

};

/**
 * Функция смещения геометрии слоя по заданным параметрам позиции, высоты, типа диаграммы в заданную позицию по оси Y
 * @param {map.layer.CASLayer} lay
 * @param {Number} layPosition
 * @param {Number} layHeight
 * @param {String} layDiagType
 * @param {Boolean} rollback
 * @param {Number} ySteps
 * @param {Boolean} isAnalysis
 * @param {Number} globalMinY
 * @param {Number} globalMaxY
 */
WidgetMap.moveLayerToPosition = function(lay, layPosition, layHeight, layDiagType, rollback, ySteps, isAnalysis, globalMinY, globalMaxY){
    if(goog.isDef(lay) && goog.isDef(lay.featureProjLayer)){
        lay.minMeasure = WidgetMap.minMeasure;
        lay.moveLayerToPosition(layPosition,layHeight, layDiagType, rollback, ySteps, globalMinY, globalMaxY);

        //В зависимости от максимального и минимального значенией границ наносим вертикальную шкалу для 2D графика
        if ((layDiagType=="2D" || layDiagType=="interval") && !rollback && !isAnalysis){
            //перепроверить minbounds
            var originMin = cashelper.getOriginalMinBounds(lay.uniqueLayerName);
            var originMax = cashelper.getOriginalMaxBounds(lay.uniqueLayerName);
            var cutYMin = (lay)? lay.cutYMin: 0;
            var minValue = (isNaN(originMin))?lay.originalMinValue_:originMin;
            var maxValue = (isNaN(originMax))?lay.originalMaxValue_:originMax;
            WidgetMap.drawVerticalScale(lay.uniqueLayerName, layPosition, layHeight, maxValue+cutYMin ,minValue+cutYMin, ySteps, cutYMin);
        }
    }
};

//функции взаимодействия
/**
 * Получение ширины карты
 * @returns {string}
 */
WidgetMap.getMapWidth = function(){
    if(goog.isDef(WidgetMap.map)){
        var mapCenter = WidgetMap.map.getView().getCenter();
        var mapExtent = WidgetMap.map.getView().calculateExtent(WidgetMap.map.getSize());
        var mapW = (20106193*Math.cos(Math.PI/2 - 2.0 *
            Math.atan(Math.exp(-mapCenter[0]/6378137))))*
            ((mapExtent[2]-mapExtent[0])/20037508);
        return mapW.toFixed(2);
    }
    return 'null';
};

/**
 * Поиск объекта по идентификаторам системы и объекта.
 *
 * @param systemId - идентификатор системы.
 * @param objectId - идентификатор объекта.
 */
WidgetMap.findExternalObject = function(systemId, objectId, needBind, lineId, beginKm, endKm){
	WidgetMap.canFirstTimeCentering = false;
    if(systemId == '2')
        systemId = 'INFOTEH';

    var requestName = 'WIDGET_SYS_SEM.xml#FIND_EXT_OBJ_ID';

    function finishOperation(success){
        findExternalObject(success);
    }

    function getExternalObjectReqParams() {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: requestName,
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data CURRENT_USER_ID="'+userId.xmlEscape()+
            '" CURRENT_USER_LOGIN="'+userLogin.xmlEscape()+
            '" SYSTEM_ID="'+systemId+'" OBJ_ID="'+objectId+'">'+
            '</data>'+
            '</root>'
        };
    }
    function onGateObjectResult(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            finishOperation(false);
            return;
        }
        try { // Иногда ответ в формате XML, а иногда в виде просто строки
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var objs = layerGeoXml.getElementsByTagName("data");
            MapUtil.clearSelectionLayer();
            if(objs.length == 0){
                //разветвление по привязке, когда не нашли объект
                if(needBind == true){
                    if(lineId!='')//если передался id трубы
                        WidgetMap.findExternalPipeKm(systemId, lineId, parseFloat(beginKm), parseFloat(endKm), needBind);
                    else
                        WidgetMap.linkObject(systemId, objectId);
                }
                else
                    finishOperation(false);

                return;
            }
            var _resId = {};
            var layerName = '';
            var i;
            for (i = 0; i < objs.length; i++) {
                //парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
                layerName = objs[i].getAttribute("OWNER")+'_'+objs[i].getAttribute("TABLE_NAME");
                var layerObj = WidgetMap.layerManager.getLayerByName(layerName);
                if(goog.isDef(layerObj) && layerObj.visible){
                    if(!goog.isDef(_resId[layerName]))
                        _resId[layerName] = [];
                    _resId[layerName].push(objs[i].getAttribute("KEY_VALUES"));
                }
            }
            if (layerName != '' ){
                //формируем id
                var ids = [{name:'objects',value:layerName+':'+_resId[layerName].join(',')}];
                //LogUtil.sendLog('$$ onGateObjectResult ids=' +ids);
                WidgetMap.showObjects(ids);
                finishOperation(true);
                return;
            }
            finishOperation(false);

        }
        catch(ex) {
            finishOperation(false);
        }
    }

    function onGateObjectError(resultXml) {
        finishOperation(false);
    }
    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getExternalObjectReqParams(), onGateObjectResult,onGateObjectError,4);

};

/**
 * Поиск километра на газопроводе по идентификаторам системы и объекта и километру.
 * @param systemId - идентификатор системы.
 * @param objectId - идентификатор объекта.
 * @param km
 * @param endKm
 */
WidgetMap.findExternalPipeKm = function(systemId, objectId, km, endKm, needBind){
	WidgetMap.canFirstTimeCentering = false;
    function finishOperation(success){
        if(WidgetMap.externalFunc !='')
            WidgetMap.checkSecondExternalFunction();
        if(goog.isDef(endKm))
            findExternalPipePart(success);
        else
            findExternalPipeKm(success);
    }

    function onPipeResult(resultXml){
        var layerGeoXml = ($.parseXML(resultXml)).firstChild;
        var datas = layerGeoXml.getElementsByTagName("data");
        MapUtil.clearSelectionLayer();
        if(datas.length == 0){
            if(needBind == true)
                WidgetMap.linkObject(systemId, objectId);
            else
                finishOperation(false);
            return;
        }
        var i;
        var finded = false;
        for (i = 0; i < datas.length; i++) {
            //парсим фичу, меняем проекцию, добавляем в слой для выделенных объектов
            var format = new ol.format.WKT();
            var wktStr = datas[i].getAttribute("WKT");
            if(!wktStr)
                continue;
            finded = true;
            var feature = format.readFeature(wktStr);
            //забираем координаты и переводим их в нормальную проекцию
            var flatCoordinates = feature.getGeometry().flatCoordinates;
            if(flatCoordinates.length > 1 && flatCoordinates[0] != -1 && flatCoordinates[1] != -1){
                //устанавливаем в фичу стиль дефолтный
                WidgetMap.layerManager.defaultSelectionStyle(feature);
                GeoUtil.convertFeature(feature, App.projection, WidgetMap.DEFAULT_PROJECTION);
                WidgetMap.mapSelectionLayer.getSource().addFeature(feature);
            }
            else{
                finishOperation(false);
                return;
            }
        }
        if(finded){
            //масштабируемся к ним
            var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
            WidgetMap.centerOnMap(extent);
            finishOperation(true);
        }
        else
            finishOperation(false);

    }

    function onCoordResult(resultXml){
        var layerGeoXml = ($.parseXML(resultXml)).firstChild;
        var objs = layerGeoXml.getElementsByTagName("data");
        MapUtil.clearSelectionLayer();
        if(objs.length == 0){
            if(needBind == true)
                WidgetMap.linkObject(systemId, objectId);
            else
                finishOperation(false);
            return;
        }
        if(objs.length >0){
            moveToPoint(parseFloat(objs[0].getAttribute("X")),parseFloat(objs[0].getAttribute("Y")));
            finishOperation(true);
        }
    }

    function moveToPoint(x, y){
	    var dest_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
	    var source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
	    var pnt= new proj4.toPoint([x, y]);
	    if(App.projection == GeoUtil.PROJS.Pulkovo42){
		    var p42WgsPnt = GeoUtil.P42WGS(pnt.y, pnt.x);
		    pnt= new proj4.toPoint([ p42WgsPnt.x, p42WgsPnt.y]);
	    }
	    proj4.transform(source_, dest_, pnt);
	    if(isNaN(pnt.x) || isNaN(pnt.y))
	        return;
        //геометрия выделяемого участка трубопровода
        var geometry = new ol.geom.Point(null);
        geometry.setFlatCoordinates(ol.geom.GeometryLayout.XY,[pnt.x,pnt.y]);

        var pointFeature = new ol.Feature(geometry);
        WidgetMap.layerManager.defaultSelectionStyle(pointFeature,'DEFAULT_FIND_ADDRESS');
        WidgetMap.mapSelectionLayer.getSource().addFeature(pointFeature);

        //масштабируемся к ним
        var extent = WidgetMap.mapSelectionLayer.getSource().getExtent();
        WidgetMap.centerOnMap(extent);
    }

    function getExternalPipeReqParams(lineId) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        var requestName = 'WIDGET_SYS_SEM.xml#FIND_PIPE_KM_BY_LINE';
        if(goog.isDef(endKm)){
            requestName = 'WIDGET_SYS_SEM.xml#FIND_PART_LINE';
            return {
                getSchema: false,
                descrId: requestName,
                toElements: false,
                descrType: 'select',
                data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
                '<data CURRENT_USER_ID="'+userId.xmlEscape()+
                '" CURRENT_USER_LOGIN="'+userLogin.xmlEscape()+
                '" LINE_ID="'+lineId+'" KM_START="'+km+'" KM_END="'+endKm+'">'+
                '</data>'+
                '</root>'
            };
        }
        return {
            getSchema: false,
            descrId: requestName,
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data CURRENT_USER_ID="'+userId.xmlEscape()+
            '" CURRENT_USER_LOGIN="'+userLogin.xmlEscape()+
            '" LINE_ID="'+lineId+'" KM="'+km+'">'+
            '</data>'+
            '</root>'
        };
    }



    function getExternalObjectReqParams() {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: 'WIDGET_SYS_SEM.xml#FIND_EXT_OBJ_ID',
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data CURRENT_USER_ID="'+userId.xmlEscape()+
            '" CURRENT_USER_LOGIN="'+userLogin.xmlEscape()+
            '" SYSTEM_ID="'+systemId+'" OBJ_ID="'+objectId+'">'+
            '</data>'+
            '</root>'
        };
    }
    function onGateObjectResult(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== '') {
            finishOperation(false);
            return;
        }
        var layerGeoXml = ($.parseXML(resultXml)).firstChild;
        var objs = layerGeoXml.getElementsByTagName("data");
        if(objs.length == 0){
            if(needBind == true)
                WidgetMap.linkObject(systemId, objectId);
            else
                finishOperation(false);
        }
        var i;
        for (i = 0; i < objs.length; i++) {
            if(objs[i].getAttribute("TABLE_NAME") == 'LINE'){
                var lineId = objs[i].getAttribute("KEY_VALUES");
                if(goog.isDef(endKm))
                    App.serverQueryXMLNodeWithTries(Services.processQueryNodeGeo, getExternalPipeReqParams(lineId), onPipeResult,onGateObjectError,4);
                else
                    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getExternalPipeReqParams(lineId), onCoordResult,onGateObjectError,4);
                return;
            }
        }
    }
    function onGateObjectError(resultXml) {
        finishOperation(false);
    }
    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getExternalObjectReqParams(), onGateObjectResult,onGateObjectError,4);
};

/**
 * Выдаем сообщение о возможности привязать ненайденный объект
 * @param systemId
 * @param objectId
 */
WidgetMap.linkObject = function(systemId, objectId){
    function finishOperation(success){
        findExternalObject(success);
    }
    function closeDialog(){
        finishOperation(false);
        dlg.dialog('destroy');
        dlg.remove();
    }
    function linkToObject(){
        WidgetMap.ExternalLinkToObject(systemId,objectId);
        finishOperation(false);
        closeDialog();
    }
    var buttons = [
        {text:gis_ppanel_6,  click:linkToObject},
        {text:gis_ppanel_7, click:closeDialog}
    ];
    var txt = gis_widgetmapexternal_1;
    var dlg = App.confirmDialog(txt,buttons,{title:gis_core_1});
};

/**
 * Получение координаты центра карты.
 * @returns {string}
 */
WidgetMap.getMapCenter = function(){
    if(goog.isDef(WidgetMap.map)){
        var mapCenter = WidgetMap.map.getView().getCenter();
        //с двойной трансформацей отлет 2 метра пропадает
        var source_ =  new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
        var dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
        var pnt= new proj4.toPoint(mapCenter);
        proj4.transform(source_, dest_, pnt);
        return pnt.y.toString()+","+pnt.x.toString();
    }
    return 'null';
};

/**
 * Получение положения карты в формате
 * «ll=широта,долгота&amp;spn=ширина_карты_в_градусах,высота_карты_в_градусах&amp;z= номер_масштаба».
 * @returns {string}
 */
WidgetMap.getPosition = function(){
    if(goog.isDef(WidgetMap.map)){
        var mapCenter = WidgetMap.map.getView().getCenter();
        //с двойной трансформацей отлет 2 метра пропадает
        var source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
        var dest_ =  new proj4.Proj(GeoUtil.PROJS.WGS84);
        var pnt= new proj4.toPoint(mapCenter);
        proj4.transform(source_, dest_, pnt);
        return "ll="+pnt.y+","+pnt.x+"&spn="+","+"&z="+WidgetMap.map.getView().getZoom();
    }
    return 'null';
};

/**
 * Обновление данных слоя.
 * @param layerName - системное имя слоя
 * @param params
 */
WidgetMap.refreshLayer = function(layerName, params){
	WidgetMap.canFirstTimeCentering = false;
    var layer = WidgetMap.layerManager.getLayerByName(layerName);
    var requestName = 'GAZPROM_SYS_SEM.xml#FIND_LAYER_EXT_ID';

    function updateTopFilter(filterName,filterValue){
        var filter = $('#treeDiv').myCategories('callbackFilter',{params:params});
        var mapParams = [];
        if(filter.params.length > 0){
            mapParams.push(filter.params[0]);
        }
        if(goog.isDef(layer)&& goog.isDef(layer.filter) && layer.filter != '') {
            mapParams.push({name: 'layerId', value: layerName});
            if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
                WidgetMap.layerManager.enableLayer(layerName);
            }
            //upd. 20.09.18. Ошибка лтг. Проверяем, если в верхнем фильтра есть VOID, то выдаем сообщение и ничего не запрашиваем
	        var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
	        var roughFiltersStr = LayerManager.getRoughFiltersString(WidgetMap.currentRoughFilter);
            if((topFiltersStr != '' && topFiltersStr.indexOf('VOID') != -1) ||(roughFiltersStr != '' && roughFiltersStr.indexOf('VOID') != -1) ){
	            App.confirmDialog(gis_widgetmapexternal_3,null,{title:gis_core_1});
	            return;
            }
            ExternalInteraction.callFunction('', 'updateCacheLayer', mapParams, true);
            WidgetMap.currentFilter[layerName] = [];
            WidgetMap.currentFilter[layerName].push({layerName:layerName,filter:filterName,value:filterValue});
            layer.layer.dataReady_ = false;
            layer.layer.canFirstTimeCentering = true;
            layer.layer.setVisible(true);
        }
    }

    function finishOperation(success){
        if(WidgetMap.externalFunc !='')
            WidgetMap.checkSecondExternalFunction();
        refreshLayer(success);
    }
    function getExternalObjectReqParams(data) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: requestName,
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            data+
            '</root>'
        };
    }
    function onGateObjectResult(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            finishOperation(false);
            return;
        }
        try { // Иногда ответ в формате XML, а иногда в виде просто строки
            var datasXml = ($.parseXML(resultXml)).firstChild;
            var objs = datasXml.getElementsByTagName("data");
            if(objs.length == 0){
                finishOperation(false);
                return;
            }
            var paramsXml = ($.parseXML(params)).firstChild;
            if(objs.length > 0){
                var extData = '<data '+objs[0].getAttribute("ID_FIELD")+'="'+objs[0].getAttribute("ID")+'" ></data>';
                var ids = objs[0].getAttribute("ID");
                //Если пришел атрибут TOP_FILTER="ILI_INSP_FILTER" - обновляем по ID объекта наш верхний фильтр (чтобы в нем были выбраны именно эти отчеты)
                if (params.indexOf("TOP_FILTER") != -1){
                    //добавляем атрибут OBJ_IDS для найденного идентификатора
                    var newData = '<data OBJ_IDS="' + objs[0].getAttribute("ID") + '" TOP_FILTER="'+ paramsXml.getAttribute("TOP_FILTER") +'" ></data>';
                    $('#treeDiv').myCategories('updateTopFilter',{params:newData});
                }
                //обновляем глобальные значения фильтра
                updateTopFilter(paramsXml.getAttribute("TOP_FILTER"),ids);
            }
        }
        catch(ex) {
            finishOperation(false);
        }
    }

    function onGateObjectError(resultXml) {
        finishOperation(false);
    }
    if(goog.isDefAndNotNull(layer)){
        if(params.indexOf('SYSTEM_ID')!=-1)
            App.serverQueryXMLNodeWithTries(Services.processQueryNode, getExternalObjectReqParams(params), onGateObjectResult,onGateObjectError,4);
        return;
    }
    finishOperation(false);
};

/**
 * Очистка слоя.
 *
 * @param layerName - системное имя слоя
 */
WidgetMap.clearLayer = function(layerName){

};

/**
 * Обновление данных слоев модели (группы слоев)
 *
 * @param modelName - системное имя модели
 * @param params - XML с параметрами вида <data ILI_INSPECTION_ID=’123’>;
 */
WidgetMap.refreshModel = function(modelName, params){
    var layers = WidgetMap.layerManager.getLayersByModel(modelName);
    var i;
    for(i in layers){
        WidgetMap.refreshLayer(layers[i].id, params);
    }
};

/**
 * Очистка данных слоев модели (группы слоев)
 *
 * @param modelName - системное имя модели
 */
WidgetMap.clearModel = function(modelName){
    var layers = WidgetMap.layerManager.getLayersByModel(modelName);
    var i;
    for(i in layers){
        WidgetMap.clearLayer(layers[i].id);
    }
};

/**
 * Обновление данных слоев карты (группы слоев)
 *
 * @param modelName - системное имя модели
 * @param params - XML с параметрами вида <data ILI_INSPECTION_ID=’123’>;
 */
WidgetMap.refreshMap = function(modelName, params){
    WidgetMap.refreshModel(modelName, params);
};

/**
 * Очистка данных слоев карты
 *
 * @param modelName - системное имя модели
 */
WidgetMap.clearMap = function(modelName){
    WidgetMap.clearModel(modelName);
};



/**
 * Поиск объекта по идентификаторам системы и объекта для ПКА
 *
 * @param systemId - идентификатор системы.
 * @param objectId - идентификатор объекта.
 */
WidgetMap.showCAS = function(type, systemId, objectId, objectName, kmBegin, kmEnd){
    if(systemId == '2')
        systemId = 'INFOTEH';

    var requestName = 'WIDGET_SYS_SEM.xml#CAS_FIND_EXT_OBJ_ID';

    function finishOperation(success){
        findExternalObject(success);
    }

    function getExternalObjectReqParams() {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';

        return {
            getSchema: false,
            descrId: requestName,
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data CURRENT_USER_ID="'+userId.xmlEscape()+
            '" CURRENT_USER_LOGIN="'+userLogin.xmlEscape()+
            '" SYSTEM_ID="'+systemId+'" OBJ_ID="'+objectId+'" KM_BEGIN="'+kmBegin+'" KM_END="'+kmEnd+'">'+
            '</data>'+
            '</root>'
        };
    }
    function onGateObjectResult(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            finishOperation(false);
            //LogUtil.sendLog(gis_widgetmapexternal_2 + er);
            return;
        }
        try { // Иногда ответ в формате XML, а иногда в виде просто строки
            var layerGeoXml = ($.parseXML(resultXml)).firstChild;
            var objs = $(layerGeoXml).find("data");
            MapUtil.clearSelectionLayer();
            if(objs.length == 0){
                //разветвление по привязке, когда не нашли объект
                finishOperation(false);
                //LogUtil.sendLog(gis_widgetmapexternal_2 + resultXml);
                return;
            }
            var obj = $(objs[0]);
            WidgetMap.LINE_ID = obj.attr("OBJ_ID");
            WidgetMap.BEGIN_KM = parseFloat(obj.attr("KM_BEGIN"));
            WidgetMap.CURR_MIN_KM =  WidgetMap.BEGIN_KM;
            WidgetMap.END_KM = parseFloat(obj.attr("KM_END"));
            WidgetMap.CURR_MAX_KM =  WidgetMap.END_KM;
            WidgetMap.loadLineData();
            finishOperation(true);

        }
        catch(ex) {
            finishOperation(false);
            //LogUtil.sendLog(gis_widgetmapexternal_2 + resultXml);
        }
    }

    function onGateObjectError(resultXml) {
        finishOperation(false);
    }
    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getExternalObjectReqParams(), onGateObjectResult,onGateObjectError,4);

};
/**
* Класс для навигации кнопками положений карты
*/
MapHistory = function(opt_options){
    var options = goog.isDef(opt_options) ? opt_options : {};
    this.map = options.map;
    this.justChanged = false;
    // центр карты, масштаб отображения, текущая проекция базового слоя
    this.mapCenterLonLat = NaN;
    this.mapZoom = NaN;
    // история перемещений
    this.history_ = [];
    this.positionCursor_ = -1;
    //контрол с кнопками
    this.historyControl = undefined;
    var that = this;
    if(goog.isDef(this.map))
        this.map.on('moveend', function(){
            that.saveCurrentState();
        });
};

MapHistory.prototype.clearHistory = function(){
    this.justChanged = false;
    this.mapCenterLonLat = NaN;
    this.mapZoom = NaN;
    this.history_ = [];//массив положений
    this.positionCursor_ = -1;// текущее положение карты
    this.saveCurrentState();
};

MapHistory.prototype.saveCurrentState = function(){
    if(!goog.isDef(this.map))
        return;
    if(this.justChanged == false){
        this.history_.splice(this.positionCursor_+ 1);
        //сохраняем центр в wgs
        var cp = new proj4.toPoint(this.map.getView().getCenter() );
        this.dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
        if(GeoUtil.PROJS['EPSG:5807'] !== WidgetMap.DEFAULT_PROJECTION){
            this.source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
            proj4.transform(this.source_, this.dest_, cp);
        }
        this.mapCenterLonLat = [cp.x, cp.y];
        this.mapZoom = this.map.getView().getZoom();
        this.history_.push({zoom:this.mapZoom, lonlat:this.mapCenterLonLat});
        this.positionCursor_ = this.history_.length - 1;

    }
    if(goog.isDef(this.historyControl)){
        //в зависимости от текущего курсора выставляем стили кнопкам
        if(this.positionCursor_ == 0){
            $(this.historyControl.inElement).addClass('map-disabled-button');
        }
        else{
            $(this.historyControl.inElement).removeClass('map-disabled-button');
        }
        if(this.positionCursor_ == this.history_.length - 1){
            $(this.historyControl.outElement).addClass('map-disabled-button');
        }
        else{
            $(this.historyControl.outElement).removeClass('map-disabled-button');
        }
    }

    this.justChanged = false;
};

MapHistory.prototype.setState = function(state){
    this.positionCursor_ += state;
    var currPosition  = this.history_[this.positionCursor_];
    if(!goog.isDef(currPosition)){
        this.positionCursor_ -= state;
        this.justChanged = false;
        return;
    }
    //преобразуем центр в проекцию подложки
    var cp = new proj4.toPoint(currPosition.lonlat );
    this.source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
    if(GeoUtil.PROJS['EPSG:5807'] !== WidgetMap.DEFAULT_PROJECTION){
        this.dest_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
        proj4.transform(this.source_, this.dest_, cp);
    }
    this.map.getView().setCenter([cp.x,cp.y]);
    this.map.getView().setZoom(currPosition.zoom);
};
/*
 * Общие глобальные функции
 */
/*
 * Расширение стадартноего объекто String. Экранирование XML символов.
 */
if(!String.prototype.xmlEscape) {
    String.prototype.xmlEscape = function () {
        return this
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    };
};

/* 
 * Эмуляция наследования для старых браузеров 
 */
//if(typeof Object.create !== 'function') {
Object.create = function (o) {
    function F() {}
    F.prototype = o;
    return new F();
};
//}


// Настройки datepicker
$.datepicker.setDefaults($.datepicker.regional['ru']);
$.datepicker.setDefaults({
    dateFormat: 'dd-mm-yy',
    changeYear: true,
    yearRange: '-100:+100'
});


$.cookie.raw = true;

App = {};
//уникальный идентификатор окна. Будет использоваться в синхронизации
App.UNIQUE_ID = undefined;
//счетчик открытия ПКА для дальнейшей выдачи сообщения, что могут быть артефакты из-за некорректной работы ie - не чистит память нормально
App.GLOBAL_CAS_OPEN_LIMIT = 5;
App.GLOBAL_MAP_OPEN_LIMIT = 5;
//Строка для проверки на пустой файл
App.EMPTY_FILE_RESPONSE = '<string><root fileName=';
App.EMPTY_FILE_TEMPLATE = '<string><root/></string>';

App.name = gis_app_55_1;
App.version = gis_app_55_2;

App.SERVER_ERRORS = {
    'OK':gis_app_55_25, //случай, если запросили тип xml, а пришло не то
    'Internal Server Error':gis_app_55_26,
    'error':gis_app_55_27,
    'abort':gis_app_55_28,
    'Not Found':gis_app_55_30,
    'Service Unavailable':gis_app_55_30,//случай, если не работает сервер nodejs
    'Proxy Error':gis_app_55_30,//случай, если не работает сервер nodejs
    '404':gis_app_55_31 // файл не найден
};

/**
 * Возврачает читаемый текст ошибки от сервера
 * @param textStatus
 * @param errorThrown
 * @returns {string|*}
 */
App.prettyCodeError = function(textStatus, errorThrown){
    if(textStatus === '' || errorThrown === '')
        textStatus = gis_app_55_26 + '. ' + gis_app_55_23 + '. textStatus='+textStatus ;
    var result = textStatus;
    try{
        if(App.SERVER_ERRORS[errorThrown] !== undefined)
            result = App.SERVER_ERRORS[errorThrown];
        else if(App.SERVER_ERRORS[textStatus] !== undefined)
            result = App.SERVER_ERRORS[textStatus];
        else if(errorThrown.indexOf('Service Unavailable'))
            result = App.SERVER_ERRORS['Service Unavailable'] + '. textStatus='+textStatus;
        else if(errorThrown.indexOf('Internal Server Error'))
            result = App.SERVER_ERRORS['Internal Server Error'] + '. textStatus='+textStatus;
        return result;
    }
    catch(ex){}

    return textStatus;
};


/**
 * Возврачает читаемый текст ошибки от сервера, если он вернулся в успешном результате
 * @param textStatus
 * @param errorThrown
 * @returns {string|*}
 */
App.prettyCodeSuccessError = function(text){
    var result = text;
    try{
        if(text && text !== ''){
            if(text.indexOf(App.SERVER_ERRORS['Internal Server Error']) !== -1)
                result = App.SERVER_ERRORS['Internal Server Error'] + '. ' + text;
            if(text.indexOf(App.SERVER_ERRORS['Service Unavailable']) !== -1)
                result = App.SERVER_ERRORS['Service Unavailable'] + '. ' + text;
        }
        return result;
    }
    catch(ex){}

    return result;
};

/**
 * Возвращает читаемы текст ошибки без спец символов в окно с ошибкой
 * @param str
 * @returns {*}
 */
App.formatErrorString = function(str){
    try{
        if (str.indexOf('&amp;') != -1) {
            str = str.replace(/&amp;/g, '&');
        }
        if (str.indexOf('&lt;') != -1) {
            str = str.replace(/&lt;/g, '<');
        }
        if (str.indexOf('&gt;') != -1) {
            str = str.replace(/&gt;/g, '>');
        }
        if (str.indexOf('&quot;') != -1) {
            str = str.replace(/&quot;/g, '"');
        }
        if (str.indexOf('&#39;') != -1) {
            str = str.replace(/&#39;/g, '\'');
        }
        if (str.indexOf('&#xA;') != -1) {
            str = str.replace(/&#xA;/g, '\\n');
        }
        if (str.indexOf('\\"') != -1) {
            str = str.replace(/\\"/g, '"');
        }
    }
    catch(e){}
    return str;
};

/**
 * НОРМАЛЬНАЯ обертка для отправки запросов на сервер.
 * При успехе вызывается функция callbackResult с содержимым из тега <string></string>
 * При ошибке вызывается функция callbackFail с текстом критической ошибки.
 * Функция возвращает ссылку на запрос для возможности отмены запроса через .abort()
 */

App.serverQueryXML = function (url, params, callbackResult, callbackFail, returnReq) {
    var req = $.ajax({
        type: "POST",
        url: url,
        data: params,
        timeout: App.clientRequestTimeout,
        dataType: 'xml'
    });

    var xmlData = "";

    req.done(function (resp) {
        xmlData = $(resp).find('string').text();
        //Вызываем переданную функцию для обработки результата
        callbackResult(xmlData);
    });

    req.fail(function (jqXHR, textStatus, errorThrown) {
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText === "timeout") {
            xmlData = gis_app_55_13;
        }
        //Вызываем переданную функцию для обработки результата
        callbackFail(xmlData);
    });

    return req;
};

App.serverQueryXMLWithTries = function (url, params, callbackResult, callbackFail, triesCount) {
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount) {
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'xml'
        });
        var xmlData = "";
        req.done(function (resp) {
            xmlData = $(resp).find('string').text();
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(triesCount);
};

App.serverQueryXMLGrid = function (url, params, callbackResult, callbackFail, returnReq) {
    var internalServerErrorCounter = 5;
    function sendRequest(internalServerErrorCounter){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'xml'
        });

        var xmlData = "";

        req.done(function (resp) {
            xmlData = $(resp).find('string').text();
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);
};

App.serverQueryXMLGridNew = function (url, params, callbackResult, callbackFail, returnReq, processId) {
    var internalServerErrorCounter = 5;
    function sendRequest(internalServerErrorCounter){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'xml'
        });

        var xmlData = "";

        req.done(function (resp) {
            xmlData = $(resp).find('string').text();
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData, processId);
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData, processId);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);
};




/**
 * Запрос для получения информации по кадастровому слою
 * @param url
 * @param callbackResult
 * @param callbackFail
 * @returns {*}
 */
App.serverCadastreQueryXML = function (url, callbackResult, callbackFail) {
    $.support.cors = true;
    // Create the XHR object.
    function createCORSRequest(method, url) {
        var xhr = new XMLHttpRequest();
        if ("withCredentials" in xhr) {
            // XHR for Chrome/Firefox/Opera/Safari.
            xhr.open(method, url, true);
        } else if (typeof XDomainRequest != "undefined") {
            // XDomainRequest for IE.
            xhr = new XDomainRequest();
            xhr.open(method, url);
        } else {
            // CORS not supported.
            xhr = null;
        }
        return xhr;
    }

    // Make the actual CORS request.
    function makeCorsRequest(url) {
        // All HTML5 Rocks properties support CORS.
        var xhr = createCORSRequest('GET', url);
        xhr.timeout = 5000;//30 секунд = 30000 (в миллисекундах)
        if (!xhr) {
            callbackFail('CORS not supported');
            return;
        }
        var res = false;

        // Response handlers.
        xhr.onload = function() {
            res = true;
            var text = xhr.responseText;
            try{
                var doc = $($.parseXML(text));
                var xmlData = $(doc).children('FeatureInfoResponse');
                //Вызываем переданную функцию для обработки результата
                callbackResult(xmlData);
            }
            catch(ex){
                callbackFail(text);
            }
        };
        xhr.ontimeout  = function() {
            res = true;
            callbackFail(gis_app_55_18);
        };
        xhr.onerror = function(xhr, textStatus, errorThrown) {
            res = true;
            callbackFail(gis_app_55_17);
        };
        xhr.onabort = function() {
            res = true;
            callbackFail(gis_app_55_16);
        };
        /*xhr.onreadystatechange = function() {
            if (this.readyState != 4) return;
            // по окончании запроса доступны:
            // status, statusText
            // responseText, responseXML (при content-type: text/xml)
            if (this.status != 200) {
                // обработать ошибку
                alert( 'ошибка: ' + (this.status ? this.statusText : 'запрос не удался') );
                return;
            }
            // получить результат из this.responseText или this.responseXML
        };*/
        function abortRequest(){
            xhr.abort();
            if( !res )
                callbackFail(gis_app_55_19);
        }

        setTimeout(abortRequest,5000);
        xhr.send();
    }
    makeCorsRequest(url);
    return;

};

/**
 * Отчет об ошибке
 * @param text - основной текст ошибки
 * @param detail - детализация
 * @param closeCallback - колбек на закрытие
 * @param params - дополнительные параметры, которые уйдут в письме
 */
App.errorReport = function(text, detail, closeCallback, params) {
    var errDetail = detail;
    detail = App.formatErrorString(detail);
    var genId = App.generateUUID();
    var id = 'errorReportDialog_'+genId;
    var smallDivErrText = 'smallDivErrText_'+genId;
    var dlg = undefined;
    var dId = getParameterByName('dialogId');
    if(dId){
        parent.App.resizeIframeMap(dId);
    }
   /* if(parent){
        parent.$('body').append('<div id="'+id+'" class="error-report-dialog" title="'+gis_app_55_5+'"></div>');
        dlg = parent.$('#'+id);
    }
    else{*/
        $('body').append('<div id="'+id+'" class="error-report-dialog" title="'+gis_app_55_5+'"></div>');
        dlg = $('#'+id);
    /*}*/

    var buttons = [];
    if(detail) {
        buttons.push({text:gis_app_55_6, click:moreHandler, 'class':'errorReportDialogMore', tabindex:-1});
    }
    buttons.push({text:gis_app_55_8, click:send, tabindex:-1, 'class':'errorReportDialogMail'});
    buttons.push({text:gis_app_55_9, click:close, tabindex:1,'class':'errorReportDialogOk'});

    var smallErr = '<div><table cellpadding="0" cellspacing="0" class="error-dialog-table">'+
        '<tbody><tr>'+
        '<td class="error-dialog-img">'+
        '<img src="/ui/images/err.png" width="50" height="50">'+
        '</td><td><div id="'+smallDivErrText+'" class="text"></div></td></tr></tbody></table>' +
        '</div>' +
        '<div class="detail" contenteditable="true" style="width:100%;height: 100%;"></div>';

    dlg.append(smallErr);
    $('#'+smallDivErrText).text(text);
    if(detail) {
        var address = (App.config && App.config.SUPPORT_ADDRESS !== undefined)?App.config.SUPPORT_ADDRESS:'';
        var paramStr = '';
        if(params !== undefined) {
            if(params.filename != undefined)
                paramStr += gis_senderrorreportdialog_16 + params.filename+"\n";
            if(params.functionname != undefined)
                paramStr += gis_senderrorreportdialog_17 + params.functionname+"\n";
            if(params.rawresponse != undefined)
                paramStr += 'rawresponse:' + params.rawresponse+"\n";
        }
        $('.detail', dlg).text(paramStr+gis_app_55_22+detail+'\n\n'+address);
    }
    dlg.dialog({
        resizable: false,
        modal:     true,
        dialogClass: 'ui-error-dialog gsi-zindex__global',
        width:     705,
        height:    135,
        close:     close,
        buttons:   buttons
    });

    function send() {
        var text   = $('.text',   dlg).text();
        var detail = errDetail;//$('.detail', dlg).text();

        var dialog = Object.create(SendErrorReportDialog);
        dialog.setData(
            gis_app_55_10+
            text+"\n\n"+
            gis_app_55_11+
            detail+"\n\n"
            , params, id, closeCallback);

        dialog.build();
    }

    function close() {
        if(closeCallback != undefined)
            closeCallback();
        dlg.dialog("close");
    }

    function moreHandler() {
        var detail = $('.detail', dlg);
        var text = $('.ui-dialog-buttonset .ui-button.errorReportDialogMore span.ui-button-text');
        if(detail.is(':visible')) {
            dlg.dialog({resizable:false, width:705, height: 135});
            text.text(gis_app_55_6);
            $('.error-dialog-table').show();
            detail.hide();
        }
        else {
            dlg.css({width: 705, height: 358});
            dlg.dialog({resizable:true});
            text.text(gis_app_55_7);
            $('.error-dialog-table').hide();
            detail.show();
        }
    }
};

/**
 * Диалог
 */
App.confirmDialog = function(text, buttons, params) {

    var dlg = undefined;
    /*if(parent){
        parent.$('body').append('<div class="confirmDialog"></div>');
        dlg = parent.$('.confirmDialog');
    }
    else{
        $('body').append('<div class="confirmDialog"></div>');
        dlg = $('.confirmDialog');
    }*/
    var dlg = $('<div class="confirmDialog"></div>');
    dlg.appendTo('body');
    if(params && params.html){
        dlg.html(text);
    }
    else{
        dlg.text(text);
    }
    var bts = buttons || {"   OK   ": function() { App.destroyDialog(null, dlg) }};
    var dialogClass = (params && params.dialogClass)? params.dialogClass: 'gsi-zindex__global';
    var defaultParams = {
        resizable: true,
        modal:     true,
        buttons:   bts,
        width:     400,
        minWidth:  150,
        maxWidth:  4000,
        minHeight: 10,
        dialogClass: dialogClass
    };
    dlg.dialog($.extend(defaultParams, params));
    return dlg;
};

App.infoDialog = function(text, id) {
    var defaultParams = {
        resizable: false,
        modal:     true,
        buttons:   null,
        width:     200,
        height:  55,
        dialogClass: 'ui-dialog-confirm noCloseButton'
    };
    id = id || App.generateUUID();
    var dlg = $('<div class="infoDialog" id="'+id+'"></div>');
    dlg.appendTo('body');
    dlg.text(text);
    dlg.dialog(defaultParams);
    return dlg;
};

App.showConfirmForm = function(opt_options) {
    var options = opt_options ? opt_options : {};
    var title = options.title || gis_core_1;
    var descr = options.descr || gis_core_17;
    var successCallback = options.successCallback;
    var bts = {
        "Да": function() {
            if(successCallback) successCallback();
            $( this ).dialog("close");
        },
        "Нет": function() {
            $( this ).dialog("close");
    }
    };

    var defaultParams = {
        resizable: false,
        modal:     true,
        buttons:   bts,
        width:     400,
        minWidth:  150,
        maxWidth:  400,
        minHeight: 10,
        title: title,
        dialogClass: 'ui-dialog-confirm'
    };

    var dlg = $('<div class="confirmDialog"></div>');
    dlg.appendTo('body');
    dlg.html(descr);
    dlg.dialog(defaultParams);
    return dlg;
};

/**
 * Диалог
 */
App.notSupportedDialog = function(text, buttons, params) {
    var bts = buttons || {"   OK   ": function() { $( this ).dialog("close"); }};

    var defaultParams = {
        resizable: true,
        modal:     true,
        buttons:   bts,
        width:     400,
        minWidth:  150,
        maxWidth:  4000,
        minHeight: 10
    };


    var dlg = $('<div class="confirmDialog"></div>');
    dlg.appendTo('body');
    dlg
        .text((text) ? text : gis_core_error_0)
        .dialog($.extend(defaultParams, params));

    return dlg;
};

/**
 * Открывает задачу. Структура Task может формироваться объектом UserSettings
 */
App.openTask = function(task, authStr, params) {
    // Хардкодные компоненты
    var dialog;
    var paramsStr = '';
    if(params){
        for(var p in params)
            paramsStr+='&'+p+'='+params[p];
    }
    if(task.name && (task.name === 'USER_OFFICE_DIALOG' || task.name === 'USER_OFFICE')) {
        dialog = Object.create(UserOfficeDialog);
        dialog.init();
        dialog.build();
    }
    else if(task.name && (task.name === 'TASK_OFFICE_DIALOG' || task.name === 'TASK_OFFICE')) {
        dialog = new TaskOfficeForm();
        dialog.build();
    }
    else if(task.name && task.name == 'USER_CHANGE') {
        dialog = new UserChangeDialog();
        dialog.setTargetUrl('main.html');
        dialog.build();
    }
        // Статическая HTML страничка в новом окне браузера
    // В mdl задан URL статического HTML файла
    else if(task.mdl && /\.html$/.test(task.mdl)) {
        //Условие для добавления к тестовому гриду параметров task и mdl, необходимых для корректной работы открытого окна
        //window.open(task.mdl, 'STATIC__'+task.name, 'height=600,width=800,menubar=no,location=no,directories=no,status=no,resizable=yes,scrollbars=yes');
        var url = task.mdl+
            "?task="+escape(task.name)+
            "&mdl="+escape(task.mdl) +
            "&rand="+Math.random()*1000000+escape(paramsStr);
        var currAuth  = '';
        if(task.auth == 'true'){
            if(authStr)
                currAuth = authStr;
            else
                currAuth = Auth.getAuthStr();
            url += '#'+currAuth;
        }
        if(task.newWindow == 'true')
            window.open(task.mdl+currAuth, 'EXTRA__'+task.name, 'height=600,width=800,menubar=no,location=no,directories=no,status=no,resizable=yes,scrollbars=yes');
        else
            window.location.href = url;
    }
        // Дополнительное окно с модулем в новом окне браузера
    // В mdl задан URL страницы mail.html с дополнительными параметрами
    else if(task.mdl && /\.html?$/.test(task.mdl)) {
        //window.open(task.mdl, 'EXTRA__'+task.name, 'height=600,width=800,menubar=no,location=no,directories=no,status=no,resizable=yes,scrollbars=yes');
        window.location.href = task.mdl;
    }
        // Переход на другую задачу в том же самом окне браузера
    // Иначе открываем задачу в том же самом окне
    else if(task.name && task.mdl) {
        //если флеш вариант, то выходим из main_js.html и переводим для обработки в main.html
        var url =
            "main.html"+
            "?task="+escape(task.name)+
            "&mdl="+escape(task.mdl) +
            "&rand="+Math.random()*1000000;
        if(task.mdl.indexOf('http://') !== -1 || task.mdl.indexOf('https://') !== -1) {
            url = task.mdl;
            var target = (task.newWindow !== 'true')?'_self':'_blank';
            window.open(url, target);
            return;
        }

        if(authStr) {
            url += '#'+authStr;
        }
        else {
            url += '#'+Auth.getAuthStr();
        }

        window.location.href = url;
    }
    else {
        //В остальных случаях генерируем ошибку, чтобы знать, почему не удалось запустить задачу
        App.errorReport(gis_app_55_14,gis_app_55_15+' name='+task.name+', mdl='+task.mdl,undefined,{filename:gis_filename_9, functionname:'App.openTask'});
    }
};


/*
 * Аналог config-a - объект, в котором хранятся все глобальные переменные
 * Получаем и парсим web.config так: var config = App.getClientConfig();
 * Используем так: var someParameter = App.config.hasOwnProperty(someProperty);
 * */
App.config = null;
/* Сразу по получению web.config'a нужно установить requestTimeout, чтобы все запросы уходили с этим таймаутом (значение таймаута в минутах) */
App.clientRequestTimeout = 0;
//путь к криватной директории из web.config
App.privatePath = "";
//Проекция геоданных из БД
App.projection = 'EPSG:4284';
//путь к предыдущей версии сайта
App.prevSite = '';//'/old55/main_js.html?task=MULT_MAIN&mdl=main_js.html';
App.newSite = '';
//флаг использования сервисов nodejs напрямую минуя апач
App.useDirectlyNodeService = false;
//Считывание конфига из web.config
App.getClientConfig = function(resultCallback){
    if (App.config===null) {
        function onGetClientConfigResult(resultXml) {
            App.config = {};
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                var doc = $($.parseXML(resultXml));
                //var nodes = doc.children('configuration').children('appSettings').children('add');
                var nodes = doc.find('add');
                // Цикл по текущему уровню
                nodes.each(function(){
                    var node = $(this);
                    //Обязательно поднимаем регистр ключа
                    App.config[node.attr('key').toUpperCase()] = node.attr('value');
                });
                //Сразу устанавливаем значение App.clientRequestTimeout из App.config['REQUEST_TIMEOUT']
                if (App.config.hasOwnProperty('REQUEST_TIMEOUT')) {
                    var timeout = parseFloat(App.config['REQUEST_TIMEOUT']);
                    if (timeout && timeout != undefined && !isNaN(timeout)) {
                        App.clientRequestTimeout = Math.round(timeout*60*1000);
                    }
                }
                if (App.config.hasOwnProperty('USE_DIRECTLY_NODEJS')) {
                    App.useDirectlyNodeService = App.config['USE_DIRECTLY_NODEJS'] === 'true';
                }

                //Сразу устанавливаем значение приватной директории App.PrivatePath из App.config['PRIVATE_PATH']
                if (App.config.hasOwnProperty('PRIVATE_PATH'))
                    App.privatePath = App.config['PRIVATE_PATH'];

                //Сразу устанавливаем значение приватной директории App.PrivatePath из App.config['PRIVATE_PATH']
                if (App.config.hasOwnProperty('PROJECTION'))
                    App.projection = App.config['PROJECTION'];
                if(App.config.hasOwnProperty('APP_60_SERVER')){
                    Services.updateMonoServices();
                }
            }
            catch(e) { // Распарсить XML не удалось, видимо это просто строка
                //Конфиг запрашиваем 1 раз для приложения, поэтому при любых ошибках сохраняем конфиг как пустой объект
            }
            finally {
                if(resultCallback)
                    resultCallback();
            }
        }

        function onGetClientConfigFail(resultXml) {
            App.config = {};
            if (resultXml.indexOf(gis_app_55_30) !== -1){
                App.errorReport(gis_app_55_33, resultXml.toString(),undefined,{filename:gis_filename_9, functionname:'App.getClientConfig_onGetClientConfigFail'});
                return;
            }
            App.errorReport(gis_app_55_20, resultXml.toString(),undefined,{filename:gis_filename_9, functionname:'App.getClientConfig_onGetClientConfigFail'});
            if(resultCallback)
                resultCallback();
        }

        function getReqParams() {
            return {
                descrId: 'SYS_SEM.xml#GET_CLIENT_CONFIG',
                descrType: 'select',
                data:'<root><data FILE="../../Web.config" /></root>'
            };
        }

        //При обращении к сервису без параметров, все равно нужно указывать пустой объект (null вызовет ошибку сервиса)
        //Возвращаем ссылку на запрос
        return App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getReqParams(), onGetClientConfigResult, onGetClientConfigFail);
    }
    else {
        //Конфиг уже загружен, возвращаем его
        if(resultCallback)
            resultCallback();
        return App.config;
    }
};


/*
 * Создание динамических iframe-ов
 * */
App.iframeIdsCount = 0;
//Создание очередного iframe с новым id по переданной ссылке
App.createIFrame = function(linkUrl,name){
    //Прибавляем общее количество iframe
    App.iframeIdsCount++;
    var iframe = document.createElement('iframe');
    iframe.frameBorder=0;
    iframe.name = name;
    iframe.width="100%";
    iframe.height="100%";
    iframe.id="iframe" + App.iframeIdsCount;
    iframe.setAttribute("src", linkUrl);
    return iframe;
};

/**
 * Функция генерайции UUID
 * */

App.generateUUID = function generateUUID() {
    var d = new Date().getTime();
    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = (d + Math.random()*16)%16 | 0;
        d = Math.floor(d/16);
        return (c=='x' ? r : (r&0x7|0x8)).toString(16);
    });
    return uuid;
};

// Установим заголовки приложения
$(document).ready(function(){
    //document.title = App.name+' '+App.version;
    //$('body.login h1').text(App.name+' '+App.version);
});



//устанавливаем куки
App.setCookie = function(cookieName, value, expires){
    var options = {
        path:    '/',
        expires: expires || 365*20 // Запомнить на 20 лет
    };
    $.cookie(cookieName, value, options);
};

//удаляем куки
App.removeCookie = function(cookieName){
    //код из флеша, т.к jquery $.removeCookie(this.cookieName);  не удаляет куки
    function  setCookie(name, value, days){
        if (days) {
            var date = new Date();
            date.setTime(date.getTime()+(days*24*60*60*1000));
            var expires = '; expires='+date.toGMTString();
        }
        else
            var expires = '';
        document.cookie = name + '=' + value+expires+'; path=/';
    }
    setCookie(cookieName,'',-1);
};

//проверяем наличие куков
App.hasCookie = function(cookieName){
    if(!$.cookie || !$.cookie(cookieName)) {
        return false;
    }
    return true;
};

App.getCookie = function(cookieName){
    return $.cookie(cookieName);
};

App.serverQueryXMLSplit1 = function (url, params, callbackResult, callbackFail) {
    var filename = params.descrId.split('#')[1];
    var xmlIndex =  params.xmlIndex;
    filename = filename+'_'+xmlIndex+'.xml';
    filename = filename.replace('_0.xml','.xml');//нулевой элемент без индекса
    var lpuHash = '';
    //добавлено хэширование лпу для доступа к персональной папке геокэша. Используем начальные ЛПУ
    if (WidgetMap.preloadLpuValues) {
        var lpus = [];
        WidgetMap.preloadLpuValues.forEach(function(lpu){
            if(lpu)lpus.push(Number(lpu.CODE));
        })
        lpuHash = CryptoJS.MD5(lpus.sort().join()) + '/';
    }

    var reqParams = {
        descrId: 'SYS_SEM.xml#GET_XML_FILE',
        descrType: 'select',
        dataType: 'text',
        data: '<root><data FILE="../../../' + App.privatePath + '/geo/' + lpuHash + filename + '"/></root>'
    };
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, reqParams, callbackResult, callbackFail, undefined, undefined, false);

    return undefined;
};

App.serverQueryJSON = function (url, callbackResult, callbackFail, triesCount) {
    if(!triesCount) triesCount = 4;
    var fileName = url.substr(url.lastIndexOf('/')+1);
    function sendRequest(triesCount){
        var req = $.ajax({
            url: url,
            timeout: 20000,
            cache: false,
            dataType: "json",
        });
        req.done(function(data) {
            callbackResult(data);
        });
        req.fail(function(jqXHR, textStatus, errorThrown){
            if(errorThrown === 'Not Found') errorThrown = '404'
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            if (fileName && textStatus === gis_app_55_31)
                textStatus = textStatus.replace(gis_app_55_34,gis_app_55_34 + ': ' + fileName);
            if(textStatus.indexOf('timeout')!=-1)
                callbackFail(gis_app_55_13+textStatus+' .'+errorThrown);
            else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(textStatus+'. '+errorThrown);
        });
        return req;
    }
    return sendRequest(triesCount);
};

App.serverQueryCadastreJSON = function (url, callbackResult, callbackFail,triesCount) {
    if(!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            url: url,
            timeout: 20000,
            cache: false,
            dataType: "json",
        });
        req.done(function(data) {
            callbackResult(data);
        });
        req.fail(function(jqXHR, textStatus, errorThrown){
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            if(textStatus.indexOf('timeout')!=-1)
                callbackFail(gis_app_55_21+textStatus+' .'+errorThrown);
            else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(textStatus+'. '+errorThrown);
        });
        return req;
    }
    return sendRequest(triesCount);
};

/**
 * Полное удаление диалогового окна
 * @param selector
 */
App.destroyDialog = function(id, selector){
    if(id)
        selector = '#' + id;
    try{
        $(selector).empty();
        $(selector).dialog('destroy').remove();
    }
    catch(ex){
    }
    finally {
        $(selector).empty();
    }
};

App.serverQueryXMLNode = function (url, params, callbackResult, callbackFail, returnReq) {
    url = App.formatNodeServiceUrl(url);
    var req = $.ajax({
        type: "POST",
        url: url,
        data: params,
        timeout: App.clientRequestTimeout,
        dataType: 'text'
    });

    var xmlData = "";

    req.done(function (resp) {
        xmlData = resp;//$(resp).find('string').text();
        //Вызываем переданную функцию для обработки результата
        callbackResult(xmlData);
    });

    req.fail(function (jqXHR, textStatus, errorThrown) {
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText=="timeout") {
            xmlData = gis_app_55_13;
        }
        //Вызываем переданную функцию для обработки результата
        callbackFail(xmlData);
    });

    return req;
};

App.serverQueryXMLNodeWithTries = function (url, params, callbackResult, callbackFail, triesCount) {
    url = App.formatNodeServiceUrl(url);
    if(!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });
        var xmlData = "";
        req.done(function (resp) {
            xmlData = resp;//$(resp).find('string').text();
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000);
                return;
            }
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(triesCount);
};


App.serverQueryXML2Node = function (url, params, callbackResult, callbackFail, handleEmptyFileError) {
    url = App.formatNodeServiceUrl(url);
    var internalServerErrorCounter = 5;
    handleEmptyFileError = handleEmptyFileError !== false;
    function sendRequest(internalServerErrorCounter){
        //url = window.location.origin+':3000'+ url.replace('.','');
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });

        var xmlData = "";

        req.done(function (resp) {
            var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(resp, 'fileName') + '. '+ gis_core_19);
            else{
                if(isEmptyFile) resp = App.EMPTY_FILE_TEMPLATE;
                xmlData = resp.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
                callbackResult(xmlData);
            }
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state()=="rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            else{
                if(jqXHR.statusText !== '' || jqXHR.statusText !== 'error')
                    xmlData = jqXHR.statusText;
                else xmlData = gis_app_55_23;
                xmlData = '<error>'+xmlData+'</error>';
            }

            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);

};

App.serverQueryXML3Node = function (url, params, callbackResult, callbackFail, handleEmptyFileError) {
    url = App.formatNodeServiceUrl(url);
    var internalServerErrorCounter = 5;
    handleEmptyFileError = handleEmptyFileError !== false;
    function sendRequest(internalServerErrorCounter){
        //url = window.location.origin+':3000'+ url.replace('.','');
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });

        var xmlData = "";

        req.done(function (resp) {
            var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(resp, 'fileName') + '. '+ gis_core_19);
            else{
                if(isEmptyFile) resp = App.EMPTY_FILE_TEMPLATE;
                xmlData = resp.replace(/&amp;/g, "&");//.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
                callbackResult(xmlData);
            }
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state()=="rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            else{
                if(jqXHR.statusText !== '' || jqXHR.statusText !== 'error')
                    xmlData = jqXHR.statusText;
                else xmlData = gis_app_55_23;
                xmlData = '<error>'+xmlData+'</error>';
            }

            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);

};

/**
 * Обертка для отправки запросов на сервер.
 * При успехе - возвращает вложенную XML.
 */
App.serverQueryNode = function(url, params, callback, fault) {
    url = App.formatNodeServiceUrl(url);
    var dfd = new $.Deferred();
    params.user =  Auth.getUserId();
    //url = window.location.origin+':3000'+ url.replace('.','');
    var req = $.ajax({
        type:     'POST',
        url:      url,
        data:     params,
        timeout:  App.clientRequestTimeout,
        dataType: 'text'
    });

    req.done(function(resp){
        var xmlData = resp;
        var doc;
        var errorText;

        try { // Иногда ответ в формате XML, а иногда в виде просто строки
            doc = $($.parseXML(xmlData));
            errorText = doc.find('error').text();
        }
        catch(e) { // Распарсить XML не удалось, видимо это просто строка
            doc = xmlData;
        }

        if(errorText) {
            if(fault)
                fault(errorText);
            dfd.rejectWith(null, [errorText]);
        }
        else {
            if(callback) {
                callback(doc);
            }
            dfd.resolveWith(null, [doc]);
        }
    });

    req.fail(function(jqXHR, textStatus, errorThrown){
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText === "timeout") {
            errorText = gis_app_55_13;
        }
        if(fault)
            fault(errorText);
        dfd.rejectWith(null, [errorText]);
    });

    return dfd;
};
/**
 *
 * @param {*} url
 * @param {*} params
 * @param {*} callbackResult
 * @param {*} callbackFail
 * @param {*} triesCount количество попыток
 * @param {*} handleEmptyFileError являющийся флагом, который используется для регулирования показа сообщения об ошибке.
 * @returns
 */
App.serverQueryNodeWithTries = function(url, params, callbackResult, callbackFail, triesCount, handleEmptyFileError) {
    url = App.formatNodeServiceUrl(url);
    handleEmptyFileError = handleEmptyFileError !== false;
    if (!triesCount)
        triesCount = 4;
    var dfd = new $.Deferred();
    params.user =  Auth.getUserId();
    //url = window.location.origin+':3000'+ url.replace('.','');
    function sendRequest(triesCount){
        var req = $.ajax({
            type:     'POST',
            url:      url,
            data:     params,
            timeout:  App.clientRequestTimeout,
            dataType: 'text'
        });
        req.done(function(resp){
            var xmlData = resp, doc, errorText;
            var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(xmlData, 'fileName') + '. '+ gis_core_19);
            else{
                if(isEmptyFile) xmlData = App.EMPTY_FILE_TEMPLATE;
                try { // Иногда ответ в формате XML, а иногда в виде просто строки
                    doc = $($.parseXML(xmlData));
                    errorText = doc.find('error').text();
                }
                catch(e) { // Распарсить XML не удалось, видимо это просто строка
                    doc = xmlData;
                }

                if(errorText) {
                    if(callbackFail)
                        callbackFail(errorText);
                    dfd.rejectWith(null, [errorText]);
                }
                else {
                    if(callbackResult) {
                        callbackResult(doc);
                    }
                    dfd.resolveWith(null, [doc]);
                }
            }
        });
        req.fail(function(jqXHR, textStatus, errorThrown){
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                errorText = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            if(callbackFail)
                callbackFail(errorText);
            dfd.rejectWith(null, [errorText]);
            callbackFail(xmlData);
        });
        return dfd;
    }
    return sendRequest(triesCount);
};


App.serverQueryXMLGridNode = function (url, params, callbackResult, callbackFail, canAbort) {
    url = App.formatNodeServiceUrl(url);
    var internalServerErrorCounter = 5;
    //url = window.location.origin+':3000'+ url.replace('.','');
    function sendRequest(internalServerErrorCounter){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });

        var xmlData = "";

        req.done(function (resp) {
            xmlData = resp;
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //случай, если происходит отмена запроса во время фильтра грида
            if(canAbort === true && errorThrown === 'abort' && jqXHR.status === 0){
                return;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);
};


App.serverQueryXMLNode1 = function (url, params, callbackResult, callbackFail, returnReq) {
    url = App.formatNodeServiceUrl(url);
    var req = $.ajax({
        type: "POST",
        url: url,
        data: params,
        timeout: App.clientRequestTimeout,
        dataType: 'xml'
    });

    var xmlData = "";

    req.done(function (resp) {
        xmlData = $(resp).find('string').text();
        //Вызываем переданную функцию для обработки результата
        callbackResult(xmlData);
    });

    req.fail(function (jqXHR, textStatus, errorThrown) {
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText === "timeout") {
            xmlData = gis_app_55_13;
        }
        //Вызываем переданную функцию для обработки результата
        callbackFail(xmlData);
    });

    return req;
};

App.serverQueryXML2Node1 = function (url, params, callbackResult, callbackFail) {
    var internalServerErrorCounter = 5;
    function sendRequest(internalServerErrorCounter){
        url = App.formatNodeServiceUrl(url);
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });

        var xmlData = "";

        req.done(function (resp) {
            xmlData = resp.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            //Вызываем переданную функцию для обработки результата
            callbackResult(xmlData);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);

};

App.serverQueryXMLGridNewNode = function (url, params, result, fail, returnReq, processId) {
    var internalServerErrorCounter = 5;
    function sendRequest(internalServerErrorCounter){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            jsonp: "jsonp",
            cache: false
        });

        var xmlData = "";
        //результат может прийти, как удачный json, там и ошибка в xml
        req.done(function (resp) {
            try{
                if(resp){
                    var xmlData = $(resp).find('string').text();
                    if(xmlData !== '')
                        resp = $(resp);
                }
            }
            catch (e) {}
            if(result){
                result(resp, processId);
            }
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            //если запрос вызвал Internal Server Error апачем, то
            else if(jqXHR.state() === "rejected" && internalServerErrorCounter>0){
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            //Вызываем переданную функцию для обработки результата
            if(fail)
                fail(xmlData, processId);
        });
        return req;
    }
    return sendRequest(internalServerErrorCounter);
};

/******** nodejs json requests *********/
App.getJsonNode = function(url, params, result, fault, method, triesCount) {
    if(!triesCount) triesCount = 4;
    if(!method) method = 'POST';
    url = App.formatNodeServiceUrl(url);
    var url = App.formatNodeServiceUrl(url );
    if(params === undefined)
        params = {};
    function sendRequest(triesCount){
        var req = $.ajax({
            type: method,
            url: url,
            data:params,
            timeout: App.clientRequestTimeout,
            dataType: 'json',
            jsonp: "jsonp",
            cache: false
        });
        req.done(function (resp) {
            (resp && (resp.status === 200 || resp.code === 200 )) ?
                result(resp) : fault(resp);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
            }else if(fault) {
                fault(textStatus);
            }
        });
        return req;
    }
    return sendRequest(triesCount);
};

App.jsonNode = function(url, params, result, fault, method, triesCount) {
    if(!triesCount) triesCount = 4;
    if(!method) method = 'POST';
    function sendRequest(triesCount){
        var req = $.ajax({
            type: method,
            url: url,
            data: params || {},
            timeout: App.clientRequestTimeout,
            dataType: 'json',
            jsonp: "jsonp",
            cache: false
        });
        req.done(function (resp) {
            (resp && (resp.status === 200 || resp.code === 200 )) ?
                result(resp) : fault(resp);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
            }else if(fault) {
                fault(textStatus);
            }
        });
        return req;
    }
    return sendRequest(triesCount);
};

/**
 *
 * @param url
 * @param params
 * @param result
 * @param fault
 * @param processId
 * @param triesCount
 * @param requestOptions
 * @returns {*}
 */
App.getJsonTextNode = function (url, params, result, fault, processId, requestOptions, triesCount) {
    var url = App.formatNodeServiceUrl(url);
    if (!triesCount)
        triesCount = 4;
    if (params === undefined)
        params = {};
    var method = (requestOptions && requestOptions.method) ? requestOptions.method : 'POST';
    var dataType = (requestOptions && requestOptions.dataType) ? requestOptions.dataType : 'text';

    function sendRequest(triesCount) {
        var req = $.ajax({
            type: method,
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: dataType,
            jsonp: "jsonp",
            cache: false
        });
        req.done(function (resp) {
            if(result)
                result(resp, processId);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            textStatus = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                textStatus = gis_app_55_13;
            }
            else if (triesCount > 0) {
                --triesCount;
                setTimeout(function () {
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            if (fault)
                fault(textStatus, processId);
        });
        return req;
    }

    return sendRequest(triesCount);
};

App.getUTEProcessStatus = function(processId, isNodeMonitor, result, fault) {
    var url = App.formatNodeServiceUrl('./api/status/ute-process-status');
    var req = $.ajax({
        type: "GET",
        url: url,
        data: { processId: processId, place: (isNodeMonitor)?'node':'ute'},
        timeout: 9000,// на секунду меньше, чем интервал вызова
        dataType: 'json',
        jsonp: "jsonp",
        cache: false
    });
    req.done(function (resp) {
        result(resp);
    });
    req.fail(function (jqXHR, textStatus, errorThrown) {
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        textStatus = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
        fault(textStatus);
    });
    return req;
};
//upd. 03.03.21 принято решение не выносить в конфиг
App.REQUEST_ERROR_TRIES = 5;
App.getUTEProcessStatus1 = function(processId, result, fault) {
    var internalServerErrorCounter = App.REQUEST_ERROR_TRIES; //5
    function sendRequest(internalServerErrorCounter) {
        var url = App.formatNodeServiceUrl('./api/status/ute-process-status');
        var req = $.ajax({
            type: "GET",
            url: url,
            data: {processId: processId},
            dataType: 'json',
            jsonp: "jsonp",
            cache: false
        });
        req.done(function (resp) {
            result(resp);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            if (internalServerErrorCounter > 0) {
                --internalServerErrorCounter;
                sendRequest(internalServerErrorCounter);
                return;
            }
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            fault(textStatus);
        });
    };
    return sendRequest(internalServerErrorCounter);
}


/**
 *
 * @param url
 * @param params
 * @param callbackResult
 * @param callbackFail
 * @param method
 * @param triesCount количество попыток
 * @param handleEmptyFileError являющийся флагом, который используется для регулирования показа сообщения об ошибке.
 * @returns {jQuery|{getAllResponseHeaders: function(): *|null, abort: function(*=): this, setRequestHeader: function(*=, *): this, readyState: number, getResponseHeader: function(*): null|*, overrideMimeType: function(*): this, statusCode: function(*=): this}}
 */
App.serverQueryXmlFileNodeWithTries = function (url, params, callbackResult, callbackFail, method, triesCount, handleEmptyFileError) {
    if(!method) method = 'POST';
    url = App.formatNodeServiceUrl(url);
    handleEmptyFileError = handleEmptyFileError !== false;
    if(!triesCount)
        triesCount = 4;

    function sendRequest(triesCount){
        var req = $.ajax({
            type: method,
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });
        req.done(function (resp) {
            var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(resp, 'fileName') + '. '+ gis_core_19);
            else{
                if(isEmptyFile) resp = App.EMPTY_FILE_TEMPLATE;
                callbackResult(resp);
            }

        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }
            else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(xmlData);
        });
        return req;
    }
    return sendRequest(triesCount);
};
/**
 *
 * @param {*} url
 * @param {*} descrId
 * @param {*} fileName
 * @param {*} callback
 * @param {*} handleEmptyFileError являющийся флагом, который используется для регулирования показа сообщения об ошибке.
 * @returns
 */
App.serverQueryXmlFileNode1 = function(url, descrId, fileName, callback, handleEmptyFileError) {
    url = App.formatNodeServiceUrl(url);
    handleEmptyFileError = handleEmptyFileError !== false;
    var params = {
        descrId: descrId,
        descrType: 'select',
        data:'<root ><data FILE="'+fileName+'"/></root>'
    };
    var dfd = new $.Deferred();
    params.user =  Auth.getUserId();
    var req = $.ajax({
        type:     "POST",
        url:      url,
        data:     params,
        timeout:  App.clientRequestTimeout,
        dataType: 'text'
    });

    req.done(function(resp){
        var xmlData = resp, doc, errorText;
        var isEmptyFile = resp.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;

        if (isEmptyFile && handleEmptyFileError)
            callback(gis_core_21 + App.getAttributeFromXml(xmlData, 'fileName') + '. '+ gis_core_19);
        else{
            if (isEmptyFile) xmlData = App.EMPTY_FILE_TEMPLATE;
            try { // Иногда ответ в формате XML, а иногда в виде просто строки
                doc = $($.parseXML(xmlData));
                errorText = doc.find('error').text();
            }
            catch(e) { // Распарсить XML не удалось, видимо это просто строка
                doc = xmlData;
            }
            if(errorText) {
                dfd.rejectWith(null, [errorText]);
            }
            else {
                if(callback)
                    callback(doc);
                dfd.resolveWith(null, [doc]);
            }
        }
    });

    req.fail(function(jqXHR, textStatus, errorThrown){
        textStatus = App.prettyCodeError(textStatus, errorThrown);
        var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
        //Отдельно обрабатываем если таймаут
        if (jqXHR.statusText === "timeout") {
            errorText = gis_app_55_13;
        }
        dfd.rejectWith(null, [errorText]);
    });

    return dfd;
};

App.formatNodeServiceUrl = function(url){
    $.support.cors = true;
    if(App.useDirectlyNodeService){
        if(window.location.origin)
            url = window.location.origin+':3000'+ url.replace('.','');
        else
            url = window.location.protocol+'//'+window.location.host+':3000'+ url.replace('.','');
    }
    return url;
}

App.areCookiesEnabled = function() {
    try {
        document.cookie = 'cookietest=1';
        var cookiesEnabled = document.cookie.indexOf('cookietest=') !== -1;
        document.cookie = 'cookietest=1; expires=Thu, 01-Jan-1970 00:00:01 GMT';
        return cookiesEnabled;
    } catch (e) {
        return false;
    }
}

App.showCookieMessage = function(message){
    var div = $('.cookie-button');
    if(div.length > 0)
        div.remove();

    $('body').append('<div class="cookie-button show" >' + message + '<button>X</button></div>');
    $('.cookie-button :button').click(function(){
        $('.cookie-button').remove();
    });
}


/**
 * Базовая функция подготовки параметров запроса.
 * @param requestId
 * @param data
 */
App.composeRequestParams = function(requestId, data){
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    return {
        descrId: requestId,
        descrType: 'select',
        data:  '<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+
            '" >'+
            DBUtil.serializeData(data) +
            '</root>'
    };
};



App.formattedQueryNode = function (url, params, callbackResult, callbackFail,triesCount) {
    url = App.formatNodeServiceUrl(url);
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: "POST",
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text'
        });
        var xmlData = "";
        req.done(function (resp) {
            try{
                var er = HTTPServiceUtil.getError(resp);
                if (er !== '') {
                    callbackResult({error:er});
                }
                else{
                    var resData = $($.parseXML(resp)).find("data");
                    var resArr = [];
                    if(resData && resData.length > 0 ){
                        var obj = {};
                        for (var i=0; i< resData[0].attributes.length; i++) {
                            obj[resData[0].attributes[i].name] = resData[0].attributes[i].value;
                        }
                        resArr.push(obj);
                    }
                    callbackResult({data: resArr});
                }
            }
            catch(ex){
                callbackResult({error:ex.message});
            }
        });

        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText=="timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            //Вызываем переданную функцию для обработки результата
            callbackFail({error: xmlData});
        });
        return req;
    }
    return sendRequest(triesCount);
};

App.saveMultigeomDataWithTries = function (dataObject, pasteMultiFeature,callbackResult, callbackFail, triesCount) {  
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: 'POST',
            url: dataObject.requestUrl,
            data: dataObject.requestParams,
            timeout: App.clientRequestTimeout,
            dataType: 'xml',
        });
        req.done(function (resp) {
            callbackResult(resp);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(xmlData);
        });
    }
    return sendRequest(triesCount);
};
App.getClosestPointWithTries = function (url,callbackResult,callbackFail,triesCount){
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: "GET",
            url: url,
            data: {},
            timeout: 5000,
            dataType: 'json',
            jsonp: "jsonp",
            cache: true
        });
        req.done(function (data) {
            callbackResult(data);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail();
        });
        //Возвращаем ссылку на запрос (для возможности отмены запроса)
        return req;
    }
    return sendRequest(triesCount);
}

App.getClosestPathWithTries = function (url,callbackResult,callbackFail,triesCount){
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: "GET",
            url: url,
            data: {},
            timeout: 5000,
            dataType: 'json',
            jsonp: "jsonp",
            cache: true
        });
        req.done(function (data) {
            callbackResult(data);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var xmlData = '<error>' + gis_app_55_3 + '. ' + textStatus + '. ' + errorThrown + '</error>';
            if (jqXHR.statusText === "timeout") {
                xmlData = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(xmlData);
        });
        //Возвращаем ссылку на запрос (для возможности отмены запроса)
        return req;
    }
    return sendRequest(triesCount);
}
App.serverQueryStringWithTries = function (url, params, callbackResult, callbackFail, triesCount){
    if (!triesCount)
        triesCount = 4;
    function sendRequest(triesCount){
        var req = $.ajax({
            type: 'POST',
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'xml',
        });
        req.done(function (data) {
            callbackResult(data);
        });
        req.fail(function(jqXHR, textStatus, errorThrown){
            var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                errorText = gis_app_55_13;
            }else if(triesCount > 0){
                --triesCount;
                setTimeout(function(){
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(errorText);
        });
        return req;
    }
    return sendRequest(triesCount);
}

App.serverQueryStringNodeWithTries = function (url, params, callbackResult, callbackFail, triesCount){
    if (!triesCount)
        triesCount = 4;

    function sendRequest(triesCount) {
        var req = $.ajax({
            type: 'POST',
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text',
        });
        req.done(function (data) {
            callbackResult(data);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                errorText = gis_app_55_13;
            } else if (triesCount > 0) {
                --triesCount;
                setTimeout(function () {
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(textStatus);
        });
        return req;
    }
    return sendRequest(triesCount);    
}
/**
 *
 * @param {*} url
 * @param {*} params
 * @param {*} callbackResult
 * @param {*} callbackFail
 * @param {*} triesCount
 * @param {*} handleEmptyFileError являющийся флагом, который используется для регулирования показа сообщения об ошибке.
 * @returns
 */
App.serverQueryNodeWithTries2 = function(url, params, callbackResult, callbackFail, triesCount, handleEmptyFileError){
    if (!triesCount)
        triesCount = 4;
    handleEmptyFileError= handleEmptyFileError !== false;
    function sendRequest(triesCount) {
        var req = $.ajax({
            type: 'POST',
            url: url,
            data: params,
            timeout: App.clientRequestTimeout,
            dataType: 'text',
        });
        req.done(function (data) {
            var isEmptyFile = data.indexOf(App.EMPTY_FILE_RESPONSE) !== -1;
            if (isEmptyFile) data = App.EMPTY_FILE_TEMPLATE;
            if (isEmptyFile && handleEmptyFileError)
                callbackFail(gis_core_21 + App.getAttributeFromXml(data, 'fileName') + '. '+ gis_core_19);
            else
                callbackResult(data);
        });
        req.fail(function (jqXHR, textStatus, errorThrown) {
            var errorText = gis_app_55_4 + '. ' + textStatus + '. ' + errorThrown;
            //Отдельно обрабатываем если таймаут
            if (jqXHR.statusText === "timeout") {
                errorText = gis_app_55_13;
            } else if (triesCount > 0) {
                --triesCount;
                setTimeout(function () {
                    sendRequest(triesCount);
                }, 2000)
                return;
            }
            callbackFail(errorText);
        });
        return req;
    }
    return sendRequest(triesCount);
}
/**
 * Пасринг ошибки при отсутсвие на сервере файла.
 * @param {*} inputXmlStr <string><root attributes/></string>
 * @returns значение атрибута
 */
App.getAttributeFromXml = function (inputXmlStr, attribute) {
    try{
        //Получаем xml с данными в виде структуры (берем корневой элемент, т.е. root)
        var inputXml = ($.parseXML(inputXmlStr)).firstChild;
        return inputXml.firstElementChild.getAttribute(attribute);
    }catch(ex){};
};


App.convertDataXmlToArray = function(inputDataStr, toUpper){
    var dataArr = []
    try{
        $(inputDataStr).find('data').each(function () {
            var newDataObj = {};
            //TODO то modern loop
            for (var curAttrInd = 0; curAttrInd < this.attributes.length; curAttrInd++) {
                var name = this.attributes[curAttrInd].name;
                if(toUpper) name = name.toUpperCase();
                newDataObj[name] = this.attributes[curAttrInd].value;
            }
            dataArr.push(newDataObj);
        });
    }
    catch (ex){}
    return dataArr;
}

/**
 * Функция ресайза карты, открытой в iframe
 *
 * @param dialogId
 */
App.resizeIframeMap = function(dialogId){
    var dashboard = App.dashboardManager.getCurrentDashboard();
    var maps = dashboard.getMaps();
    maps.forEach(function(map){
        if(map.mapId === dialogId){
            var mapDlg = $('#'+map.mapId);
            mapDlg.dialog("option", "height", $(window).height() - 40);
            mapDlg.dialog("option", "width", $(window).width() - 40);
            mapDlg.dialog("option", "position", [20, 20]);
        }
        //var parent = mapDlg.parent();
    });
}
/**
 * Всякие действия по авторизации
 */
Auth = {};
Auth.getParameterByName = function(name){
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
};

// Запомитаем хеш с которым была открыта страница (а то потом он будет убран из адресной строки)
Auth.hash = window.location.hash;

// Сотрем хеш, если не указана флешка.
// Иначе хеш потребуется самой флешке, которая его прочитает и сама потом почистит
if(! /task=([^&#\^]+)&mdl=([^&#\^]+)/.test(window.location.href)) {
    var m = /^(.*)#(.*)$/.exec(window.location.href);
    if(m) {
        window.location.href = m[1]+'#';
    }
}

Auth.cookieName = "gis_gots_web53_cookie";

/**
 * Пытаемся залогинится.
 * Если не получилось то ругаемся.
 * Если получилось, то переходим на дефолтную страницу пользователя
 */
Auth.login = function(login, password, remember, targetUrl) {
    function rememberLastLogin(login) {
        var options = {
            path:    '/',
            expires: 365*20 // Запомнить на 20 лет
        };
        var str = 'login='+login;
        $.cookie(Auth.cookieName+'_last_login', str, options);
    }

    var loginDfd = $.Deferred();

    // Запрашиваем авторизацию
    $.post(Services.loginNode, {login:login, password:password},
        function(resp){
        var er = HTTPServiceUtil.getError(resp);
        if(er !== ''){
            //вызываем доп форматирование ошибки логина, чтобы не выводило пользователям пароль в чистом виде
            er = HTTPServiceUtil.getLoginError(resp, login);
            //send audit event
            LogUtil.sendAuditEvent( login, AuditEventType.USER_LOGIN, 'false');
            App.errorReport(gis_auth_55_1 + gis_auth_55_1_1, er, undefined,{filename:gis_filename_110, functionname:'gis_filename_110_8'});
            loginDfd.rejectWith(this, [er]);
            return;
        }
        var jsonData = JSON.parse(resp);

        Auth._removeCookie();
        // Нам вернули юзера. Запомним в куках.
        if(jsonData.id) {
            var chk    = CryptoJS.MD5(login+'system_check'+login);
            var uid    = jsonData.uid;
            var userId = jsonData.id;

            //Проверяем, первый ли раз мы заходим под этим пользователем. Если первый - нужно выдавать диалог смены пароля.
            var userLogonTime = null;
            var requestParams = { descrType: 'select', descrId: 'SYS_SEM.xml#WEB50_B_USER_PRIVATE', toElements: false, getSchema: false,
                data: '<root USER_ID="'+userId+'" USER_LOGIN="'+login+'" PODS_USER="'+login+'" ><data SYS_OBJ_ID="'+userId+'"/></root>' };
            //Устанавливаем курсор ожидания
            BlockingUtil.wait();
            App.serverQueryXMLNodeWithTries(Services.processQueryNode, requestParams, function onCheckUserResult(resultXML){
                //Снимаем курсор ожидания
                BlockingUtil.ready();
                if (resultXML) {
                    var er = HTTPServiceUtil.getError(resultXML);
                    if (er=='') {
                        userLogonTime = $($.parseXML(resultXML)).find('data').attr('LOGONTIME');
                        checkLogon(userLogonTime);
                    } else {
                        App.errorReport(gis_auth_55_1, er, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_1'});
                    }
                }
            },
            function onCheckUserFault(resultXML){
                //Снимаем курсор ожидания
                BlockingUtil.ready();
                if (resultXML) {
                    var er = HTTPServiceUtil.getError(resultXML);
                    App.errorReport(gis_auth_55_1, er, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_2'});
                }
                //checkLogon();
            });
            function checkLogon(userLogonTime){
                //Пользователь залогинился успешно, но устанавливать  - устанавли
                //Если первый раз заходим - атрибута нет или в нем пусто
                if (!userLogonTime || userLogonTime=='') {
                    //Показываем форму смены пароля
                    var dialog = Object.create(ChangeFirstPasswordDialog);
                    dialog.userLoginPassChange = login;
                    dialog.userIdChange = userId;
                    dialog.build();
                    loginDfd.reject(this);
                    return;
                } else {
                    //Иначе фиксируем последнее время входа
                    var requestParams = { descrType: 'update', descrId: 'SYS_SEM.xml#WEB50_B_USER_PRIVATE_REG', toElements: false, getSchema: false,
                        data: '<root><data SYS_OBJ_ID="'+userId+'"/></root>' };
                    App.serverQueryNodeWithTries(Services.processQueryNode, requestParams);
                }

                // Выбрано "запомнить"
                if(remember) {
                    var str = "login="+login+"||UID="+uid+"||chk="+chk+"||ID="+userId;
                    var options = {
                        path:    '/',
                        expires: 365*20 // Запомнить на 20 лет
                    };
                    $.cookie(Auth.cookieName, str, options);
                }

                // Надо считать главное меню, чтобы перети на дефолтную задачу пользователя
                var tasksDef = $.get(Services.userTasksNode, {user:login,"_": $.now()}, null, 'text');
                tasksDef.done(function(resultXml){
                    var er = HTTPServiceUtil.getError(resultXml);
                    if(er !== ''){
                        App.errorReport(gis_main55_4, er, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_3'});
                        return;
                    }
                    //var xml = $($.parseXML(xmlData));
                    var xml = $($.parseXML(resultXml));
                    var menu = new UserSettings();
                    menu.setContainer($('nav.menu'));
                    menu.setXml(xml);

                    var defaultTask = menu.getDefaultTask();
                    var authStr = Auth.makeAuthStr(login, uid, userId);

                    //проверка, если в url указан task, то он должен быть в списке новом, иначе игнорируем и грузим дефолтную задачу
                    var urlTask = Auth.getParameterByName('task');
                    var urlMdl = Auth.getParameterByName('mdl');

                    if(!menu.hasTaskAndMdlInMenu(urlTask,urlMdl)){
                        if(urlTask != '' && urlMdl != '' && targetUrl != undefined){
                            App.errorReport(gis_auth_55_7, gis_auth_55_8, function(){
                                var splitHref = window.location.href.split('?')[0];
                                window.location.href = splitHref;//+'?#'+authStr;
                            });
                        }
                        else{
                            if(defaultTask) {
                                App.openTask(defaultTask, authStr);
                            }
                            // Нет дефолтной задачи у этого пользователя
                            else {
                                var splitHref = window.location.href.split('?')[0];
                                window.location.href = splitHref + '?#' + authStr;
                            }
                        }
                    }else{
                        // Переходим на URL если какой то был задан
                        if(targetUrl) {
                            window.location.href = targetUrl+'#'+authStr;
                        }
                        else {
                            // Переходим на дефолтную задачу
                            if(defaultTask) {
                                App.openTask(defaultTask, authStr);
                            }
                            // Нет дефолтной задачи у этого пользователя
                            else {
                                var splitHref = window.location.href.split('?')[0];
                                window.location.href = splitHref+'?#'+authStr;
                            }
                        }
                    }
                    rememberLastLogin(login);

                    loginDfd.resolveWith(this, [login]);
                });
            }

        }
        // Не пустили
        else if(resp) {
            //send audit event
            LogUtil.sendAuditEvent(login, AuditEventType.USER_LOGIN, 'false');

            var errorText = resp;
            App.errorReport(gis_auth_55_1, errorText, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_5'});
            loginDfd.rejectWith(this, [errorText]);
        }
        // Вообще неадекватный ответ сервера
        else {
            //send audit event
            LogUtil.sendAuditEvent(login, AuditEventType.USER_LOGIN, Auth.getUid(), 'false');
            App.errorReport(gis_auth_55_1, gis_auth_55_2, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_6'});
            loginDfd.reject(this);
        }
    }, 'text')
        .fail(function(jqXHR, textStatus, errorThrown) {
            textStatus = App.prettyCodeError(textStatus, errorThrown);
            App.errorReport(gis_auth_55_1, textStatus, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_7'});
            loginDfd.reject(this);
        });

    return loginDfd.promise(this);
};

/**
 * Устанавливает хеш авторизации, если параметры были запомнены в куках
 */
Auth.autoAuthorization = function(){
    // Уже авторизованы
    if(Auth.isAuthorized()) {
        //send audit event
        LogUtil.sendAuditEvent(Auth.getUserId(), AuditEventType.USER_LOGIN, 'true');
        return;
    }

    // Нет куки
    if(!$.cookie || !$.cookie(Auth.cookieName)) {
        return;
    }
    /*if($.cookie(Auth.cookieName)==null)
        return;*/

    var targetUrl;
    var m = /task=([^&#\^]+)&mdl=([^&#\^]+)([^$#]*)/.exec(window.location.href);
    if(m) {
        targetUrl = 'main_js.html?task='+m[1]+'&mdl='+m[2]+'&rand='+Math.random()+m[3];
    }
    else {
        targetUrl = 'main_js.html?rand='+Math.random();
    }

    var authStr = Auth.makeAuthStr(
        Auth.parseCookiePart('user'),
        Auth.parseCookiePart('uid'),
        Auth.parseCookiePart('id')
    );

    window.location.href = targetUrl+'#'+authStr;
};

/**
 * Выход и перескок на стартовую страницу
 */
Auth.logout = function() {
    //send audit event
    LogUtil.sendAuditEvent(Auth.getUserId(), AuditEventType.USER_LOGOUT, 'true');

    Auth._removeCookie();
    window.location.href = 'login.html';
};

/**
 * Проверка что мы авторизованы (по параметрам их хэша)
 */
Auth.isAuthorized = function() {
    return !!Auth.getUserName() && !!Auth.getUserId() && Auth.isChkOk();
};

Auth.isChkOk = function() {
    return (Auth.parseHashPart('chk') === CryptoJS.MD5(Auth.getUserName() + 'system_check' + Auth.getUserName()).toString());
};

Auth.getUserName = function() {
    return Auth.parseHashPart('user');
};

Auth.getUserId = function() {
    return Auth.parseHashPart('id');
};

Auth.getUid = function() {
    return Auth.parseHashPart('uid');
};

Auth.getPass = function(){
    if(!!Auth.hash){
        var arr = Auth.hash.split('&');
        var i = 0;
        for(;i<arr.length;i++){
            if(arr[i].indexOf('pass=') != -1){
                return arr[i].substring(5);
            }
        }
    }
    return null;
};

Auth._removeCookie = function() {
    //код из флеша, т.к jquery $.removeCookie(Auth.cookieName);  не удаляет куки
    function  setCookie(name, value, days){
        if (days) {
            var date = new Date();
            date.setTime(date.getTime()+(days*24*60*60*1000));
            var expires = '; expires='+date.toGMTString();
        }
        else
            var expires = '';
        document.cookie = name + '=' + value+expires+'; path=/';
    }
    setCookie(Auth.cookieName,'',-1);
};


/**
 * Возвращает якорную строку авторизации для текущего пользователя
 */
Auth.getAuthStr = function() {
    if(!Auth.getUserName()) {
        return null;
    }
    else {
        var str =
            "login=" + Auth.getUserName() +
            "&UID="  + Auth.getUid() +
            "&chk="  + CryptoJS.MD5(Auth.getUserName() + 'system_check' + Auth.getUserName()) +
            "&ID="   + Auth.getUserId();
        return str;
    }
};

Auth.makeAuthStr = function(userName, uid, userId) {
    var str = "";
    str += "login=" + userName;
    str += "&UID="  + uid ;
    str += "&chk="  + CryptoJS.MD5(userName + 'system_check' + userName).toString();
    str += "&ID="   + userId;
    return str;
};

/**
 * Вытаскивает запрошенный кусок из авторизационной куки
 */
Auth.parseCookiePart = function(partName) {
    var str = $.cookie(Auth.cookieName);

    var m = /^login=(.+)\|\|UID=(.+)\|\|chk=(.+)\|\|ID=(.+)$/.exec(str);
    if(m) {
        var parts = {user:m[1], uid:m[2], chk:m[3], id:m[4]};
        return parts[partName];
    }
    return null;
};

Auth.parseHashPart = function(partName) {
    //замена парминха хэш части
    if(!!Auth.hash){
        var parts = {};
        var authStr = Auth.hash.replace('#','');
        var arr = authStr.split('&');
        var i = 0;
        for(;i<arr.length;i++){
            if(arr[i].indexOf('pass=') != -1){
                parts['pass'] = arr[i].substring(5);
            }
            if(arr[i].indexOf('chk=') != -1){
                parts['chk'] = arr[i].substring(4);
            }
            if(arr[i].indexOf('ID=') != -1){
                parts['id'] = arr[i].substring(3);
            }
            if(arr[i].indexOf('login=') != -1){
                parts['user'] = arr[i].substring(6);
            }
            if(arr[i].indexOf('UID=') != -1){
                parts['uid'] = arr[i].substring(4);
            }
        }
        return parts[partName];
    }
    return null;
    var m = /^#login=(.+)&UID=(.+)&chk=(.+)&ID=(.+)$/.exec(Auth.hash);
    if(m) {
        var parts = {user:m[1], uid:m[2], chk:m[3], id:m[4]};
        return parts[partName];
    }
    return null;
};

Auth.registration = function() {
    var text = gis_auth_55_3;

    var buttons = [
        {text:gis_core_4,  click:launchRegistrationDialog},
        {text:gis_core_5, click:closeDialog}
    ];

    var dlg = App.confirmDialog(text, buttons, {title:gis_auth_55_6, width:700});

    function closeDialog() {
        dlg.dialog('destroy');
        dlg.remove();
    }

    function launchRegistrationDialog() {
        closeDialog();

        var dialog = Object.create(UserRegistrationDialog);
        dialog.init();
        dialog.build();
    }
};

Auth.getLastLogin = function() {
    var lastLoginStr = $.cookie(Auth.cookieName+'_last_login');
    var re = /^login=([a-z0-9\.\_\-]+)$/i;
    var m = re.exec(lastLoginStr);
    if(m) {
        return m[1];
    }
    else {
        return '';
    }
};

Auth.Autorization = function(){
    //Устанавливаем параметры авторизации из cookies, если их нет (перезагружаем страницу с добавленными в url параметрами авторизации)
    //Новая проверка на наличие атрибука pass в хэше
    if(!!Auth.getPass()){
        var userPass = Auth.getPass();
        //удаляем из хеша pass
        var str = '&pass='+userPass;
        window.location.href = window.location.href.replace(str,'');
        Auth.hash = Auth.hash.replace(str,'');
        var userN = Auth.getUserName();
        Auth.login(userN, userPass, true);
        return;
    }

    Auth.autoAuthorization();

    // Если не авторизованы, то просим авторизовываться
    if(!Auth.isAuthorized()) {
        var dialog = new UserLoginDialog();
        dialog.setTargetUrl(window.location.href);
        dialog.build();
    }
    // Если авторизованы, то загружаем меню задач
    else {
        //Функция обратного вызова для получения списка задач пользователя
        function onGetUserTasksResult(resultXml){
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                if(App.userTasksLoadErrorCounter > 1)
                    if(resultXml.indexOf(gis_app_55_13) != -1) {
                        --App.userTasksLoadErrorCounter;
                        reLoadUserTasks();
                        return;
                    }
                App.errorReport(gis_main55_4, er, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_9'});
                return;
            }
            App.userTasksLoadErrorCounter = 0;
            //если в mdl есть .html, то остается на main_js.html, иначе редирект на main.html c теми же параметрами
            if(window.location.pathname.indexOf('main_js.html') != -1  && window.location.search.indexOf('mdl=') != -1){
                if (window.location.search.indexOf('.html') == -1){
                    window.location.href = window.location.pathname.replace('main_js.html','main.html')+window.location.search+window.location.hash;
                    return;
                }
            }
            var xml = $($.parseXML(resultXml));
            var menu = new UserSettings();
            menu.setContainer($('nav.menu-user'));
            menu.setXml(xml);
            menu.onChoice(function(task){
                App.openTask(task);
            });
            //Сохраняем экземпляр меню в App.menu
            App.menu = menu;
            // Если страница открыта без соответствующих параметров task и mdl, то откроем задачу по умолчанию
            if(!/task=([^&#\^]+)&mdl=([^&#\^]+)([^$#]*)/.test(window.location.href)) {
                var task = menu.getDefaultTask();
                if(task) {
                    App.openTask(task);
                }
                $('nav').show();
                menu.build();
            }
            // Страница загружена со всеми нужными параметрами
            else {
                menu.setMask(menu.getTaskFromUrl());
                var type = menu.getTaskType(menu.getTaskFromUrl());
                //если нашли по задаче из url её тип
                //прячем меню изначально(показываем, если тип задачи подходит)
                $('nav').hide();
                if(type !== undefined){
                    //если тип == "", то не показываем меню
                    if(type !== ''){
                        $('nav').show();
                        menu.build();
                    }
                    else{
                        fixSizes(false);
                    }
                    menu.setTitleByCurrentTask();
                }
                else{
                    //добавляем проверку, есть ли эта задачи в private/uitasks
                    fixSizes(false);
                }

                // Если авторизованы и загружено главное меню, то выясняем какой нам нужен swf
                if(Auth.isAuthorized()) {
                    //Менеджер панелей, конструирует по описанию задачи панели, в которых содержатся отдельные модули
                    $('.taskContent').append('<div class="panels" style="width:100%; height:100%; padding:0">'+gis_main55_1+'</div>');
                    //Запускаем получение описания задачи
                    var taskName = menu.getTaskFromUrl();
                    var urlMdl = menu.getMdlFromUrl();
                    var pm = new PanelManagerJson();
                    pm.setContainer($('.panels'));
                    if(urlMdl !== null && (urlMdl === 'main_js.html' || urlMdl === 'tech_schema_js.html'))
                        taskName = taskName.toLowerCase();
                    var taskMdl = menu.getTaskMdl(taskName);
                    //условие, что работаем с новой версией. Если не нашли в нижнем регистре, пробуем в верхнем
                    if(taskMdl !== null && (taskMdl === 'main_js.html' || taskMdl === 'shurf_schema_js.html' || taskMdl === 'tech_schema_js.html' )
                        || taskMdl === 'cas_js.html'
                    ){
                        App.serverQueryJSON('./Core/UITasks/'+taskName.toLowerCase()+'.json', result, fault);
                        function fault(res) {
                            App.errorReport(gis_main55_2, res, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_12'});
                        }
                        function result(res) {
                            try {
                                if (res !== undefined && res.code === 200) {
                                    pm.build(res, taskName);
                                }
                            }
                            catch(ex) {
                                App.errorReport(gis_main55_2, ex.message, undefined, {filename:gis_filename_110, functionname:'gis_filename_483_6'});
                            }
                        }
                    }else{
                        //проверка, является ли задача приватной, если да, то грузим её
                        App.getJsonNode(Services.hasTaskNode, {task: taskName}, function result(res) {
                            if (res !== undefined && res.code === 200) {
                                App.getJsonNode(Services.userTaskNode, {task: taskName}, function result(res) {
                                    try {
                                        if (res !== undefined && res.code === 200) {
                                           if(res.bRoleToTasks && res.bRoleToTasks.type === 'main'){
                                               $('nav').show();
                                               menu.build();
                                           }
                                            pm.build(res, taskName);
                                        }
                                    }
                                    catch(ex) {
                                        App.errorReport(gis_main55_2, ex.message, undefined, {filename:gis_filename_110, functionname:'gis_filename_483_6'});
                                    }
                                }, function fault(res) {
                                    App.errorReport(gis_main55_2, res.message, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_15'});
                                }, 'GET');
                            }
                        }, function fault(res) {
                            App.errorReport(gis_main55_2, res.message, undefined, {filename:gis_filename_110, functionname:'gis_filename_110_16'});
                        }, 'GET');
                    }
                }
                else if (menu.getTaskFromUrl().indexOf('GRID') >= 0) {
                    App.errorReport(gis_main55_3, '', {filename:gis_filename_110, functionname:'gis_filename_110_13'});
                }
            }

        }

        //Функция обратного вызова для получения списка задач пользователя
        function onGetUserTasksFail(resultXml){
            if(App.userTasksLoadErrorCounter > 1)
                if(resultXml.indexOf(gis_app_55_13) != -1) {
                    --App.userTasksLoadErrorCounter;
                    reLoadUserTasks();
                    return;
                }
            App.userTasksLoadErrorCounter = 0;
            App.errorReport(gis_main55_4, resultXml.toString(), undefined, {filename:gis_filename_110, functionname:'gis_filename_110_14'});
        }
        function reLoadUserTasks(){
            var getUserTasksParams = {user:Auth.getUserName()};
            App.serverQueryXmlFileNodeWithTries(Services.userTasksNode,getUserTasksParams, onGetUserTasksResult, onGetUserTasksFail, 'GET');
        }

        //Запускаем получение списка задач пользователя
        var getUserTasksParams = {user:Auth.getUserName()};
        App.serverQueryXmlFileNodeWithTries(Services.userTasksNode,getUserTasksParams, onGetUserTasksResult, onGetUserTasksFail, 'GET');
    }
}

App.collectUserTasks = function(response){
    var xmlTasks = $('<data></data>');
    if(response){
        response.find('tasks').each(function () {
            xmlTasks.append($(this).children());
        });
    }
    return xmlTasks
}

/*
 * Построитель форм по MXML файлу
 */
function Form() {
    this.container = null;
    this.xml = null;
    this.values = {};
    this._width = null;
    this._height = null;
};

/*
 * Установка контейнера, в котором строим форму
 */
Form.prototype.setContainer = function(container) {
    this.container = container;
};

/*
 * Задает XML с описанием структуры формы
 */
Form.prototype.setXml = function(xml) {
    this.xml = xml;
};

/*
 * Задает значения полей в виде структуры имя-значение
 */
Form.prototype.setValues = function(values) {
    this.values = values;
};

/*
 * Возвращае текущие значения в элементах управления формы в виде структуры ключ-значение
 */
Form.prototype.getValues = function() {
    var values = {};
    
    this.container.find('input[name][type="text"], select[name]').each(function(){
        var input = $(this);        
        values[ input.attr('name') ] = input.val();
    });
    //обработка для чекбоксов и радио
    this.container.find('input[name][type="checkbox"]').each(function(){
        var input = $(this);
        values[ input.attr('name') ] = input.prop('checked');
    });
    this.container.find('input[name][type="radio"]').each(function(){
        var input = $(this);
        values[ input.attr('value') ] = input.prop('checked');
    });
    //обработка случая для атрибута THEME личных настроек, туда заносится строка json
    if(values.map_mode_raster !== undefined){
        //пока хардкодятся элементы
        values['theme']=JSON.stringify({
            MAP_MODE: (values.map_mode_raster === true)?'raster':'vector',
            SHOW_OVERVIEW_MAP: values.show_overview_map === true,
            SHOW_TREE: values.show_tree === true,
            SEND_CADASTRE_EMAIL: values.send_cadastre_email === true,
            SHOW_CENTER_MAP: values.show_center_map === true,
            COORD_MODE: (values.coord_mode_decimal === true)?'decimal':'grad',
            USE_SYNCHRONIZATION: values.use_synchronization === true,
        });
    }
    return values;
};

/*
 * Строит форму по заранее настроенным свойствам
 */
Form.prototype.build = function() {    
    // Рекурсивный пробег по MXML и строим по ней элементы управления
    function walkLevel(container, xmlNodes) {
        xmlNodes.each(function(){
            var xmlNode = $(this);
            var elem;
            // Считываем общие аттрибуты
            var cssWidth;                    
            var width = xmlNode.attr('width');
            if(/^(\d+)%$/) { // А вдруг указаны проценты
                cssWidth = width;
            }
            else if(width > 0) {
                cssWidth = width + 'px';
            }                    
            var percentWidth = xmlNode.attr('percentWidth');
            if(percentWidth > 0) {
                cssWidth = percentWidth*1 + '%';
            }
            var cssHeight = xmlNode.attr('height');
            if(cssHeight) { cssHeight += 'px'; }

            var cssTextAlign = xmlNode.attr('textAlign');                 

            var name = xmlNode.attr('id');
            if(name) {
                name = name.toLowerCase();
            }    
            var readOnly = (xmlNode.attr('editable') === 'false') || (xmlNode.attr('disabled') === 'true');
            var selected = (xmlNode.attr('selected') === 'true');
            var maxChars = xmlNode.attr('maxChars');
            var text = xmlNode.attr('text');
            var visible = (xmlNode.attr('visible') !== "false");
            var tooltip = xmlNode.attr('tooltip');
            var tabindex = xmlNode.attr('tabindex');
            //для радиокнопок
            var groupname = xmlNode.attr('groupName');
            var radiovalue = xmlNode.attr('value');
            var inp;
            // Вложенные контейнеры. Будет запущена рекурсия.
            if(xmlNode.is('mx\\:VBox')) {
                elem = $('<div class="vBox clearfix"></div>');
                if(cssWidth) { elem.css('width', cssWidth); }

                walkLevel(elem, xmlNode.children());
            }
            else if(xmlNode.is('mx\\:HBox')) {
                elem = $('<div class="hBox clearfix"></div>');
                if(cssWidth) { elem.css('width', cssWidth); }

                walkLevel(elem, xmlNode.children());
            }            
            
            // Прочие элементы управления
            else if(xmlNode.is('mx\\:Text')) {
                elem = $('<div class="control"><div class="text"></div></div>');
                text = $('.text', elem).text(text);
                if(cssWidth) { text.css('width', cssWidth); }
                if(cssTextAlign) { text.css('textAlign', cssTextAlign); }                
            }            
            else if(xmlNode.is('mx\\:TextInput')) {                
                if(xmlNode.attr('displayAsPassword') == "true") {
                    elem = $('<div class="control"><input type="password" /></div>');
                }
                else {
                    elem = $('<div class="control"><input type="text" /></div>');
                }                
                inp = $('input', elem);
                $('input', elem).attr('name', name);
                if(text)      { inp.attr('value', text); }             
                if(maxChars)  { inp.attr('maxlength', maxChars); }                        
                if(readOnly)  { inp.attr('readonly', 'readonly').addClass('readOnly');  }                        
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }                                                
                if(cssWidth)  { elem.css('width', cssWidth); }           
                if(!visible) { elem.css('visibility', 'hidden'); }
            }            
            else if(xmlNode.is('controls\\:NumberInput')) {
                elem = $('<div class="control"><input type="text" class="number" /></div>');
                inp = $('input', elem);

                inp.attr('name', name);
                if(readOnly) { inp.attr('readonly', 'readonly').addClass('readOnly');  }                        
                if(cssWidth) { elem.css('width', cssWidth); }                        
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }                                                
            }            
            else if(xmlNode.is('mx\\:ComboBox')) {                
                elem = $('<div class="control"><div class="selectWrap"><select /></div></div>');
                inp = $('select', elem);
                var wrap = $('.selectWrap', elem);
                inp.attr('name', name);
                if(readOnly) {
                    inp.attr('disabled', 'disabled');
                    wrap.addClass('readOnly'); 
                }                        
                xmlNode.children("mx\\:dataProvider, dataProvider").children('mx\\:Object, Object').each(function(){
                    var code  = $(this).attr('CODE').toLowerCase();                            
                    var label = $(this).attr('label');
                    var option = $('<option>').attr('value', code).text(label);                                                        
                    inp.append(option);
                });
                if(cssWidth) { elem.css('width', cssWidth); }                                
                
                if(!cssHeight) { cssHeight = '20px'; } // По умолчанию
                if(cssHeight) { wrap.css({'height':cssHeight, 'line-height':cssHeight}); } 
            }                           
            else if(xmlNode.is('mx\\:DateField')) {
                elem = $('<div class="control"><input type="text" class="date" maxlength="12" /></div>');
                inp = $('input', elem);

                if(readOnly) { inp.attr('readonly', 'readonly').addClass('readOnly');  }                        
                inp.attr('name', name);
                if(cssWidth) { elem.css('width', cssWidth); }
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }                                                
            }
            else if(xmlNode.is('mx\\:RadioButton')) {
                elem = $('<div class="control"><input type="radio"></div>');
                inp = $('input', elem);
                inp.attr('id', name);
                if(groupname) { inp.attr('name', groupname); }
                if(radiovalue) { inp.attr('value', radiovalue); }
                if(selected)  { inp.prop('checked', selected);  }
                if(cssWidth) { elem.css('width', cssWidth); }
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }
            }
            else if(xmlNode.is('mx\\:CheckBox')) {
                elem = $('<div class="control"><input type="checkbox"></div>');
                inp = $('input', elem);
                if(selected)  { inp.prop('checked', selected);  }
                inp.attr('name', name);
                if(cssWidth) { elem.css('width', cssWidth); }
                if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }

            }
            // Непонятный элемент            
            else {
                elem = $('<div class="unknown"></div>').text('<' + xmlNode.prop('tagName') + '>');
            }

            // Попробуем добавить tooltip
            if(tooltip && $(elem).is('div.control')) {
                $(elem).attr('title', tooltip);
            }
            // Попробуем добавить tabindex
            if(tabindex && $(elem).has('input, select').length > 0) {
                $('input, select', elem).attr('tabindex', tabindex);
            }

            // Добавляем построенный элемент в текущий контейнер
            if(elem) {
                container.append(elem);
            }
        });
    }        

    // Подготавливаем обвязку формы
    var mxForm = $('<div class="mxForm" />').appendTo(this.container);    
    this._width  = this.xml.children('DATA_EDIT_FORM').attr('width');
    this._height = this.xml.children('DATA_EDIT_FORM').attr('height');    
    if(this._width > 0) {
        mxForm.css('width', this._width+'px');
    }
    
    // Начальный запуск рекурсии обхода MXML
    walkLevel(mxForm, this.xml.children('DATA_EDIT_FORM').children('mx\\:VBox, VBox, mx\\:HBox, HBox'));

    // Устанавливаем значения в элементы управления
    $.each(this.values, function(name, value){             
        name = name.toLowerCase();
        var input = $('input[name="'+name+'"], select[name="'+name+'"]', mxForm);
        
        // Для полей типа "дата" - преобразуем формат даты
        if(input.hasClass('date')) {
            var date = /^(\d{4})\-(\d{1,2})\-(\d{1,2})/.exec(value);//YYYY-MM-DD
            if(!date){
                date = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(value);//DD.MM.YYYY
                value = date[1]+'.'+date[2]+'.'+date[3];
                //date = /^(\d{1,2})[.\/](\d{1,2})[.\/](\d{4})$/.exec(value);//DD.MM.YYYY
            }
            else
                value = date[3]+'.'+date[2]+'.'+date[1];
        }
        // Для списков - ловеркэйсим значения
        else if(input.is('select')) {
            value = value.toLowerCase();            
        }

        input.val(value);     
    });
    //обработка values колонки theme формата json
    if(this.values.THEME !== undefined){
        try{
            var theme = JSON.parse(this.values.THEME.replace(/&quot;/g,'"'));
            var showOverviewMap = theme.SHOW_OVERVIEW_MAP === true;
            var showTree = theme.SHOW_TREE === true;
            var sendCadastreEmail = theme.SEND_CADASTRE_EMAIL === true;
            var useSynchronization = theme.USE_SYNCHRONIZATION === true;
            var showCenterMap = theme.SHOW_CENTER_MAP === true;
            var selector = 'SHOW_OVERVIEW_MAP';
            var input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', showOverviewMap);
            selector = 'MAP_MODE'+(theme.MAP_MODE === 'raster'?'_RASTER':'_VECTOR');
            input = $('input[id="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', true);
            selector = 'SHOW_TREE';
            input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', showTree);
            selector = 'SEND_CADASTRE_EMAIL';
            input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', sendCadastreEmail);
            selector = 'USE_SYNCHRONIZATION';
            input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', useSynchronization);
            selector = 'SHOW_CENTER_MAP';
            input = $('input[name="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', showCenterMap);
            selector = 'COORD_MODE'+(theme.COORD_MODE === 'decimal'?'_DECIMAL':'_GRAD');
            input = $('input[id="'+selector.toLowerCase()+'"]', mxForm);
            input.prop('checked', true);

        }
        catch(e){}

    }

    // Для полей типа даты, которые доступны к редактированию устанавливаем datepicker
    $('input.date', this.container).not('.readOnly').datepicker();
    
    $('.control').wrapInner('<div class="spacer" />');
};




/*
 * Возвращает ширину заданную в MXML
 */
Form.prototype.getWidth = function() {
    return parseFloat(this._width);
};

/*
 * Возвращает высоту заданную в MXML
 */
Form.prototype.getHeight = function() {
    return parseFloat(this._height);
};
/**
 * Класс для управления синхронизациями в приложении(перезагрузки гридов, центровки в других вкладках,..)
 *
 */
//перечень типов синхронизаций
SyncTypes = {
	TYPE_NO: -1,// ничего не должно происходить
	TYPE_1: 1,// таже вкладка, id слоя совпадает, в гриде нет фильтров - перезапрос + центровка
	TYPE_2: 2,// центровка без перезапроса по всем вкладкам при условии, что id слоя совпадает
	TYPE_3: 3,// грид должен перезаполняться и всё
	TYPE_4: 4,// перезапрос геометрии в других вкладках. В рамках задачи СУ ТС ТПА, чтобы при смене ранга опасности менялся цвет на карте в iframe
	TYPE_5: 5,// комбинация типа 3 и 4
}

function SyncManager(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	//флаг, включена ли синхронизация
	this.isOn = false;
	//храним интервал, чтобы при необходимости выключить синхронизацию
	this.interval;
	//находится ли в процессе выполнения синхронизация
	this.syncPending = false;
	//отправитель команды.
	this.commandSender = undefined; // ppanel$123123-12312f-343-34$PODS_VALVE:123
}

/**
 * Функция отключения мониторинга синхронизации
 */
SyncManager.prototype.turnOff = function () {
	if (this.isOn)
		clearInterval(this.interval);
}

/**
 * Функция включает миниторинг синхронизации
 */
SyncManager.prototype.turnOn = function () {
	var that = this;
	if (this.isOn)
		return;
	this.isOn = App.syncEnabled;
	this.interval = setInterval(function () {
		if (!App.syncEnabled)
			return;
		var syncObjectFromCookie = App.getCookie('gis_web77_sync_select_object');
		if (syncObjectFromCookie && !that.syncPending) {
			that.syncPending = true;
			setTimeout(function () {
				that.syncPending = false;
				var secondTryFromCookie = App.getCookie('gis_web77_sync_select_object');
				//случай, когда где-то кликнули быстро и кука поменяла значение, чтобы старый объект не выделять
				if (secondTryFromCookie !== undefined && syncObjectFromCookie !== secondTryFromCookie) {
					return;
				}
				that.dispatchSync(syncObjectFromCookie);
			}, 2000)// делаем подтормаживание в секунду, чтобы кука умерла и не
		}
	}, App.config.SYNC_INTERVAL * 1000 || 1000);
}


/**
 * Диспетчеризация пришедшей синхронизации
 * @param {string} syncDataFromCookie
 */
SyncManager.prototype.dispatchSync = function (syncDataFromCookie) {
	var that = this;
	if (!syncDataFromCookie)
		return;
	var uniqueWindowId = syncDataFromCookie.split('$')[0];
	var selectedObjectFromCookie = syncDataFromCookie.split('$')[1];
	var uniqueLayerName = syncDataFromCookie.split('$')[2];
	var syncType = this.parseSyncType_(syncDataFromCookie.split('$')[3]);//Number(syncDataFromCookie.split('$')[3]);
	if (uniqueLayerName === 'undefined')
		uniqueLayerName = undefined;
	var isCurrentTab = uniqueWindowId === App.UNIQUE_ID;
	if(isCurrentTab && (syncType === SyncTypes.TYPE_4 || syncType === SyncTypes.TYPE_5)) isCurrentTab = false;
	var ignoreErrors = !isCurrentTab;
	if (!isCurrentTab) {//текущая вкладка
		that.findObjectInGrid_(selectedObjectFromCookie, isCurrentTab, syncType);
		that.findObjectInMap_(selectedObjectFromCookie, ignoreErrors, isCurrentTab, uniqueLayerName, syncType);
	}
};


/**
 * Поиск объекта в гриде
 * @param selectedObject
 * @param {boolean} isCurrentTab
 * @param {SyncTypes} syncType
 * @private
 */
SyncManager.prototype.findObjectInGrid_ = function (selectedObject, isCurrentTab, syncType) {
	var that = this;
	if(syncType === SyncTypes.TYPE_4 || syncType === SyncTypes.TYPE_5)
		return;
	if (selectedObject && selectedObject.indexOf(':') !== -1) {
		var layId = selectedObject.split(':')[0];
		var semIdStr = selectedObject.split(':')[1];

		var tabNav = $('#gridTabNavigator');
		if (tabNav.length === 0)
			return;
		var tabLength = tabNav.jqxTabs('length');
		var isTabSelected = false;
		for (var i = 0; i < tabLength; i++) {
			var selectedContent = tabNav.jqxTabs('getContentAt', i)[0];
			var selector = $(selectedContent).find('.gridTabContentElement');
			if (selector.length === 0 && $(selectedContent).hasClass('gridTabContentElement')) {
				selector = $(selectedContent);
			}
			selector.each(function () {
				var gridContentId = $(this).attr('id');
				var dataAdapter = $('#jqxgrid' + gridContentId).jqxGrid('source');
				var currentGridDescr = dataAdapter.currentGridDescr;
				if (!currentGridDescr)
					return;
				var layerName = currentGridDescr.layerId;
				if (!checkMapExisting())
					return;
				var layers = WidgetMap.layerManager.getLayersBySynonym(layerName);
				layers.forEach(function (layerId) {
					if (layId === layerId) {
						var rows = $('#jqxgrid' + gridContentId).jqxGrid('getrows');
						var semIds = [];
						if (semIdStr && semIdStr.indexOf(',') !== -1)
							semIds = semIdStr.split(',');
						else {
							semIds = [semIdStr];
						}
						var finded = false;
						$('#jqxgrid' + gridContentId).jqxGrid('clearselection');
						semIds.forEach(function (semId, rowIndex) {
							rows.forEach(function (item, rowIndex) {
								if (item.ID === semId) {
									finded = true;
									if (!isTabSelected) {
										isTabSelected = true;
										tabNav.jqxTabs('select', i);
									}
									var dataInfo = $('#jqxgrid' + gridContentId).jqxGrid('getdatainformation');
									if (dataInfo && dataInfo.paginginformation) {
										rowIndex = rowIndex + dataInfo.paginginformation.pagesize * dataInfo.paginginformation.pagenum;
									}
									$('#jqxgrid' + gridContentId).jqxGrid('ensureRowVisible', 0);
									$('#jqxgrid' + gridContentId).jqxGrid('selectrow', rowIndex);
									$('#jqxgrid' + gridContentId).jqxGrid('ensureRowVisible', rowIndex);
									//$('#jqxgrid' + gridContentId).jqxGrid('selectrow', item);
								}
							});
						});

						if (finded) {
							//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
							widgetMoveWindowToPosition('grid', 'restore');
						} else {
							//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
							var titlebar = !(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.titlebar === false);
							if (titlebar)
								widgetMoveWindowToPosition('grid');
						}
					}
				})
			});
		}
	}
};


/**
 * Функция поиска объекта на карте
 * @param selectedObject строка из куков  LAYER_NAME:ID1,ID2...
 * @param {boolean} ignoreErrors
 * @param {boolean} isCurrentTab
 * @param uniqueLayerName
 * @param {SyncTypes} syncType
 * @private
 */
SyncManager.prototype.findObjectInMap_ = function (selectedObject, ignoreErrors, isCurrentTab, uniqueLayerName, syncType) {
	var that = this;
	if (selectedObject && selectedObject.indexOf(':') !== -1) {
		var layName = selectedObject.split(':')[0];
		var semId = selectedObject.split(':')[1];
		/*if(syncType === SyncTypes.TYPE_4){
			var mapWidgetFrame = $('#mapWidgetInlineFrame');//TODO поменять селектор на класс
			if(mapWidgetFrame.length){
				try{
					$('#mapWidgetInlineFrame')[0].contentWindow.WidgetMap.syncShowObjects(layName, uniqueLayerName, selectedObject, ignoreErrors);
				}
				catch(ex){}
			}
			return;
		}*/
		if (!checkMapExisting())
			return;
		var layers = WidgetMap.layerManager.getLayersBySynonym(layName);
		//upd. 21.04.21 принято решение, если текущая вкладка, то центровка на карте по-старому без синхронизации
		if (!isCurrentTab) {
			var objParams = [];
			layers.forEach(function (layerId) {
				var objParams = [];
				if (CURRENT_MAP_TYPE === MAP_TYPE.CAS) {// обрабатываем случай ПКА, когда центрируемся из карты
					var layer = WidgetMap.layerManager.getCasLayerByName(layerId);
					if (layer && layer.layer)
						uniqueLayerName = layer.layer.uniqueLayerName;
					else
						layer = WidgetMap.layerManager.getCasLayerByName(layerId.split('#')[0]);
					if (layer && layer.layer) {
						uniqueLayerName = layer.layer.uniqueLayerName;
					}
					else
						return;
				}
				objParams.push({name: 'centering', value: true});
				objParams.push({name: 'objects', value: selectedObject.replace(layName, layerId)});
				objParams.push({name: 'uniqueLayerName', value: uniqueLayerName});
				objParams.push({name: 'isGroupButton', value: false});
				objParams.push({name: 'select', value: true});
				objParams.push({name: 'fromFilter', value: false});
				objParams.push({name: 'ignoreErrors', value: ignoreErrors === true ? ignoreErrors : false});
				objParams.push({name: 'loadDynamicData', value: false});//нужно ли грузить слой с динамической подгрузкой данных
				WidgetMap.showObjects(objParams, undefined, ignoreErrors, isCurrentTab, function () {

				});
			});
		}
	}
}

/**
 * Поиск объекта в других слоях-синономах, в случае, если не найден объект в основном.
 * handler возвраает результат результат поиска в слое
 * @param layers
 * @param selectedObject
 * @param ignoreErrors
 * @param isCurrentTab
 * @param uniqueLayerName
 * @param isMainLayer
 * @private
 */
SyncManager.prototype.findObjectInMapHandler_ = function (layers, selectedObject, ignoreErrors, isCurrentTab, uniqueLayerName, isMainLayer) {
	var that = this;
	var layName = selectedObject.split(':')[0];
	var layerId = layName;
	if (layers && layers.length > 0)
		layerId = layers.shift();
	var objParams = [];
	if (!uniqueLayerName)
		uniqueLayerName = layerId;

	objParams.push({name: 'centering', value: true});
	objParams.push({name: 'objects', value: selectedObject.replace(layName, layerId)});
	objParams.push({name: 'uniqueLayerName', value: uniqueLayerName});
	objParams.push({name: 'isGroupButton', value: false});
	objParams.push({name: 'select', value: true});
	objParams.push({name: 'fromFilter', value: false});
	objParams.push({name: 'ignoreErrors', value: ignoreErrors === true ? ignoreErrors : false});
	objParams.push({name: 'loadDynamicData', value: false});//нужно ли грузить слой с динамической подгрузкой данных
	//если не основной слой, то выставляем флаг будто в другой вкладке работаем, чтобы не подгружать данные по синонимичному слою
	if (!isMainLayer)
		isCurrentTab = false;
	WidgetMap.showObjects(objParams, undefined, ignoreErrors, isCurrentTab, function (finded) {
		if (!finded) {
			that.findObjectInMapHandler_(layers, selectedObject, ignoreErrors, isCurrentTab, undefined, false);
		}
	});
};



SyncManager.prototype.refreshGrid = function(curObject, isCurrentTab, syncType, force, refreshGridCallback){
	if (curObject && isCurrentTab && syncType){
		if (App.GridManager){
			var fullLayerId = App.GridManager.getFullLayerIdByLayerName(curObject.split(':')[0]);
			if (fullLayerId){
				var gridWidgets = GridUtil.findAllGridWidgetByFullLayerId(fullLayerId);
				if (gridWidgets && gridWidgets.length > 0 ) {
					gridWidgets.forEach(function(gridWidget){
						if(!gridWidget.modified || force) //если грид не менялся(не фильтровался, не было сортировок), то мы имеем право его обновить
							if(gridWidget.modified) force = false;
							GridWidget.refreshGrid('jqxgrid' + gridWidget.id, force, refreshGridCallback);
					});
				}
			}
		}
	}
};

/**
 * Команда установки данных синхронизации
 * @param selectedObject выбранный объект LAYER_NAME:123
 * @param sender отправитель команды grid|ppanel
 * @param uniqueLayerName
 * @param {SyncTypes} syncType перечень типов синхронизаций
 */
SyncManager.prototype.callSync = function (selectedObject, sender, uniqueLayerName, syncType) {
	if (!App.syncEnabled){// если выставлен флаг в настройках, использовать режим синхронизации
		this.callCurrentTabSync_(selectedObject, sender, uniqueLayerName, syncType);//25.11.2021 Vartanian правка в рамках инцидента 2565, отработка по замечанию
		return;
	}
	if (!syncType) syncType = SyncTypes.TYPE_NO;
	var areCookiesEnabled = App.areCookiesEnabled();//если включены куки
	//если текущая вкладка, то часть функционала не прогоняем через куки(центровка)
	this.callCurrentTabSync_(selectedObject, sender, uniqueLayerName, syncType)
	if (areCookiesEnabled && selectedObject) {
		var cookieTimeout = App.config.SYNC_TIMEOUT || 2;
		var date = new Date();
		date.setTime(date.getTime() + (cookieTimeout * 1000)); // 5 seconds
		this.commandSender = [sender, App.UNIQUE_ID, selectedObject].join('$');
		App.setCookie('gis_web77_sync_select_object', [App.UNIQUE_ID, selectedObject, uniqueLayerName, syncType].join('$'), date);
	}
};

/**
 * Команда запуска функций синхронизации для текущей вкладки(центровка). При обработке кук, центровка будет игнорироваться в текущей вкладке
 * @param selectedObject выбранный объект LAYER_NAME:123
 * @param sender отправитель команды  grid|ppanel|grid_ppanel
 * @param uniqueLayerName
 * @param {SyncTypes} syncType перечень типов синхронизаций
 * @private
 */
SyncManager.prototype.callCurrentTabSync_ = function (selectedObject, sender, uniqueLayerName, syncType) {
	var isCurrentTab = true;
	var ignoreErrors = false;
	var that = this;
	switch (syncType) { //12.10.2021 Vartanian рефакторинг
		case SyncTypes.TYPE_1:
		case SyncTypes.TYPE_2:
			if(uniqueLayerName){// случай ПКА
				selectedObject = uniqueLayerName + ':' + selectedObject.split(':')[1];
			}
			var funcName = "showObjects";
			var params = [{name:"objects", value:selectedObject}, {name:"select", value:true}, {name:"centering", value:true}, {name:"gridCenteringResultFunction", value:App.errorReport}];
			ExternalInteraction.callFunction("", funcName, params);
			//если не кнопка удалить, то не ищем объект в гриде, соответственно не сворачиваем его
			//TODO grid_ppanel посмотреть, где устанавливается grid_ppanel и оптимизировать
			if (sender !== 'grid_ppanel' && sender !== 'grid_delete' && sender !== 'grid_refresh')
				that.findObjectInGrid_(selectedObject, isCurrentTab, syncType);
			if(syncType === SyncTypes.TYPE_1){
				that.refreshGrid(selectedObject, isCurrentTab, syncType, true, function(){
					if (sender !== 'grid_ppanel' && sender !== 'grid_delete' && sender !== 'grid_refresh')
						that.findObjectInGrid_(selectedObject, isCurrentTab, syncType);
				});
			}
			break;
		case SyncTypes.TYPE_3:
		case SyncTypes.TYPE_5:
			that.refreshGrid(selectedObject, isCurrentTab, syncType, true, function(){
				if (sender !== 'grid_ppanel' && sender !== 'grid_delete' && sender !== 'grid_refresh')
					that.findObjectInGrid_(selectedObject, isCurrentTab, syncType);
			});
			break;
	}
};



/**
 *
 * @param syncTypeString
 * @returns {SyncTypes}
 * @private
 */
SyncManager.prototype.parseSyncType_ = function (syncTypeString) {
	if (syncTypeString) {
		try {
			var syncType = SyncTypes['TYPE_' + syncTypeString];
			if (syncType !== undefined)
				return syncType;
		} catch (ex) {

		}
	}
	return SyncTypes.TYPE_NO;
}


App.syncManager = new SyncManager();

/**
 * Класс управления сценариями
 * @param opt_options
 * @constructor
 */

function ScenarioManager(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.config = goog.isDef(options.config) ?
		options.config : undefined;
	//начальное событие, которое срабатывает перед всеми другими(водные/дорожные переходы)
	this.startEvent = undefined;
	//необходимые параметры для работы задачи(могут быть получены из url/либо внешних функций)
	this.requiredParams = [];
	//перечень гридов, которые открываются при старте задачи
	this.openTables = [];
	//перечень слоёв карты, у которых включается видимость при старте задачи
	this.openLayers = [];
	//фильтр. какого вида фильтр будет использоваться (верхний|средний)
	this.filter = undefined;

}

ScenarioManager.prototype.setConfig = function(config){
	if(!this.config)
		this.config = config;
	this.parseConfig_();
}
ScenarioManager.prototype.parseConfig_ = function(){
	var config = this.config || null;
	if(config){
		this.startEvent = config.startEvent || undefined;
		this.requiredParams = config.requiredParams || [];
		this.filter = config.filter || undefined;
		this.openTables = config.openTables || [];
		this.openLayers = config.openLayers || [];
	}
}

/**
 * Функция вызова сценария. После успешного выполнения сценария происходит загрузка карты
 * @param callback
 */
ScenarioManager.prototype.call = function(callback){
	var urlParams = {};
	var topFilterArr = [];
	var hasAllRequiredParams = true;
	if(this.config && this.config.urlParams && this.config.urlParams.length > 0){
		hasAllRequiredParams = 0;
		this.config.urlParams.forEach(function(urlParam){
			var paramValue = getParameterByName(urlParam);
			urlParams[urlParam] = paramValue;
			topFilterArr.push(urlParam+':'+paramValue);
			hasAllRequiredParams |= !!paramValue;
		});
		if(hasAllRequiredParams){
			this.setAppFilters(urlParams, topFilterArr, callback);
			var vars = this.createVars_();
			this.callSubScenario(this.openLayers, false, vars, callback)
			return;
		}
	}
	this.callScenario(callback);
}
/**
 * Функция, которая проставляет в верхний/нижний фильтры параметры, пришедшие из url
 * @param params
 */
ScenarioManager.prototype.setAppFilters = function(params, topFilterArr, callback){
	if(this.filter){
		var setTopFilter = (this.filter.type && this.filter.type.indexOf('top') !== -1);
		var setMiddleFilter = (this.filter.type && this.filter.type.indexOf('middle') !== -1);
		if(setTopFilter){
			//устанавливаем выбранное значение в верхний фильтр
			if(topFilterArr && topFilterArr.length){
				var prms = [{
					name: 'filter',
					value:topFilterArr.join('|')
				}]
				WidgetMap.updateTopFilter(prms);
				if(this.openLayers.length){
					this.openLayers.forEach(function(layerName){
						WidgetMap.currentFilter[layerName] = [];
						topFilterArr.forEach(function(topFilter){
							WidgetMap.currentFilter[layerName].push({
								layerName: layerName,
								filter: topFilter.split(':')[0],
								value: topFilter.split(':')[1]
							});
						})
					})
				}
			}
		}
		if(setMiddleFilter){
			if (this.openLayers.length) {
				this.openLayers.forEach(function (layerName) {
					//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
					WidgetMap.currentFilter[layerName] = [];
					WidgetMap.currentRoughFilter = [];
					topFilterArr.forEach(function(topFilter){
						WidgetMap.currentFilter[layerName].push({
							layerName: layerName,
							filter: topFilter.split(':')[0],
							value: topFilter.split(':')[1]
						});
						WidgetMap.currentRoughFilter.push({name: topFilter.split(':')[0], value: topFilter.split(':')[1], layerName: layerName});
					})
				});
			}
		}
	}

	/*if(callback)
		callback.apply();*/

}

/**
 *
 * @returns {{openLayers: ([]|*), queryFileName: *[], openTableGridId: *[], querySource: *[], openTableTitle: *[], openTableInterval: undefined, queryLayerId: *[], openTableLevelParams: *[]}}
 * @private
 */
ScenarioManager.prototype.createVars_ = function(){
	var vars = {};
	if(this.config){
		vars = {
			openLayers: this.config.openLayers,
			openTableInterval: undefined,
			openTableTitle: [],
			openTableGridId: [],
			openTableLevelParams: [],
			openTableShowDashboard: [],
			querySource: [],
			queryLayerId: [],
			queryFileName: [],
			mainScenario: true,
		};
		if(this.filter){
			//vars.filterType = this.filter.type;
			//vars.topFilterSource = this.filter.topDataSource;
			//vars.middleFilterSource = this.filter.middleDataSource;
		}
		/*данные для открытия грида*/
		this.config.openTables.forEach(function(tableObj){
			vars.openTableGridId.push(tableObj.gridId);
			if(tableObj.minimize)
				vars.openTableMinimize = true;
			vars.openTableTitle.push(tableObj.title);
			vars.openTableLevelParams.push(tableObj.levelParams);
			vars.openTableShowDashboard.push(tableObj.showDashboard);
			if(tableObj.query){
				vars.querySource.push(tableObj.query.source);
				vars.queryLayerId.push(tableObj.query.LAYER_ID);
				vars.queryFileName.push(tableObj.query.FILE_NAME);
			}
		});
		vars.openTableGridId = vars.openTableGridId.join('|');
		vars.openTableTitle = vars.openTableTitle.join('|');
		vars.openTableLevelParams = vars.openTableLevelParams.join('|');
		vars.openTableShowDashboard = vars.openTableShowDashboard.join('|');
		vars.querySource = vars.querySource.join('|');
		vars.queryLayerId = vars.queryLayerId.join('|');
		vars.queryFileName = vars.queryFileName.join('|');
	}
	return vars;
};
/**
 * Запуск сценария по открытию фильтров/гридов и включению слоёв(перенос из TreeUtils)
 */
ScenarioManager.prototype.callScenario = function(callback){
	var that  = this;
	//забираем флаг открытия среднегно фильтрна, список на открытие гридов и список на включение слоёв
	var middleFilterDataSource = (this.filter) ? this.filter.middleDataSource : '';//'MIDDLE_ILI_FILTER';
	var topFilterDataSource = (this.filter) ? this.filter.topDataSource : '';//'ILI_INSP_FILTER;
	var filterType = (this.filter) ? this.filter.type : '';
	var hideButtons = this.filter ? this.filter.hideButtons : [];
	var showLayers = this.openLayers;//['PODS_ILI_DATA','PODS_ILI_DATA_FEATURE'];
	var vars = this.createVars_();
	if (middleFilterDataSource !== '') {
		if (Array.isArray(middleFilterDataSource)) {
			that.showSelectableFilter(filterType, topFilterDataSource, middleFilterDataSource, showLayers, function (selectedFilterIndex) {
				//выбираем тот средний фильтр за основу, который пришел из формы выбора
				var middleFilterSource = middleFilterDataSource[0];
				if (selectedFilterIndex < middleFilterDataSource.length)
					middleFilterSource = middleFilterDataSource[selectedFilterIndex];
				if (selectedFilterIndex !== -1) {
					that.showFilter(filterType, topFilterDataSource, middleFilterSource, showLayers, function () {
						that.callSubScenario(showLayers, false, vars, callback);
					},hideButtons);
				} else {
					//если selectedFilterIndex = -1 , значит выбрать всё
					that.callSubScenario(showLayers, true, vars, callback);
				}
			})
		} else {
			that.showFilter(filterType, topFilterDataSource, middleFilterDataSource, showLayers, function () {
				//TODO рефакторинг
				/*if (WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.fullLayerId){
					var pArr = [],
						fullLayerId = WidgetMap.config.grid.fullLayerId.replace('#', '*');
					for (var key in WidgetMap.config.grid)
						pArr.push({name: key, value: WidgetMap.config.grid[key]});
					ExternalInteraction.openGrid({
						pArr: pArr,
						reload: useExistList,
						fullLayerId: fullLayerId,
						forceTopFilter: true,
					});
					return;
				}*/
				that.callSubScenario(showLayers, false, vars, callback);
			},hideButtons);
		}
	} else {
		that.callSubScenario(showLayers, false, vars, callback);
	}
};

/**
 * вызов функции открытия гридов и включения видимости слоя, когда карта загрузится
 */
ScenarioManager.prototype.callSubScenario = function(showLayers, clearFilter, vars, callback){
	if(!App.scenarioParams && (showLayers.length > 0 || vars.mainScenario !== undefined)){
		App.scenarioParams = {
			vars: vars,
			mainScenario: true,//TODO сделать нормальный вызов, чтобы treeutil корректно обрабатывал loadScenario
		}
		if(showLayers.length > 0)
			App.scenarioParams.vars.openLayers = showLayers;
	}
	if(callback){
		callback.apply(vars);
	}

	/*this.showLayersFnc(showLayers, clearFilter);
	this.openTablesFnc(vars);*/
}




/**
 * Показать перед фильтром форму с выбором, какой из фильтров использовать
 * @param filterType
 * @param topFilterDataSource
 * @param middleFilterDataSource
 * @param showLayers
 * @param applyHandler
 */
ScenarioManager.prototype.showSelectableFilter = function (filterType, topFilterDataSource, middleFilterDataSource, showLayers, applyHandler) {
	//сначала грузим все
	ExternalInteraction.loadFiltersDescr(middleFilterDataSource, [], function (filters) {
		$('#selectableFilterFormDialog').remove();
		var divv = '<div id="selectableFilterFormDialog">' +
			'<div class="filter-form-div">';
		divv += '<div>' + gis_treeutils_12 + '</div><br/>';
		var checked = '';
		var height = 160;
		for (var i = 0; i < filters.length; i++) {
			checked = (i === 0) ? 'checked' : '';
			divv += '<div class="filter-form-radio">';
			divv += '   <input name="filterRadio" id="filterRadio_' + i + '" type="radio" ' + checked + ' value="' + i + '"/>';
			divv += '   <label for="filterRadio_' + i + '" style="margin-left: 5px;">' + filters[i].title + '</label>';
			divv += '</div>';
			height += 30;
		}
		divv += '<br/><div>' + gis_treeutils_13 + '</div>';
		divv += '</div></div>';
		$('body').append(divv);
		var dlg = $('#selectableFilterFormDialog');
		var buttons = [{
			text: gis_core_16,
			click: function () {
				var selectedFilterIndex = Number($("input[name='filterRadio']:checked", dlg).val());
				if (applyHandler)
					applyHandler(selectedFilterIndex);
				$('#selectableFilterFormDialog').remove();
			}
		},
			{
				text: gis_treeutils_9,
				click: function () {
					if (applyHandler)
						applyHandler(-1);
					$('#selectableFilterFormDialog').remove();
				}
			}];
		dlg.dialog({
			modal: true,
			title: gis_treeutils_8,
			dialogClass: 'noCloseButton gsi-zindex__dialog',
			closeOnEscape: true,
			width: 470,
			height: height,
			resizable: false,
			buttons: buttons,
		});
	});
};

/**
*  Показать фильтр
 *  @param filterType тип фильтра
 *  @param topFilterSource
 *  @param middleFilterSource
 *  @param showLayers
 *  @param applyHandler
 *  @param hideButtons флаг для скрытия кнопок фильтра
*/
ScenarioManager.prototype.showFilter = function (filterType, topFilterSource, middleFilterSource, showLayers, applyHandler, hideButtons) {
	var isMiddleFilter = topFilterSource === undefined || topFilterSource === '';
	var that = this;
	var setTopFilter = (filterType && filterType.indexOf('top') !== -1)? true: false;
	var setMiddleFilter = (filterType && filterType.indexOf('middle') !== -1)? true: false;
	//если уже был открыт средний фильтр, то игнорируем. Обход ситуации, когда от каждого фильтра рубрикатора вызывается checkHeadRadioHandler
	if ($('#middleFilterDialog').length > 0)
		return;
	$('body').append('<div id="middleFilterDialog"></div>');
	var dlg = $('#middleFilterDialog');
	dlg.append('<div id="middleFilterDiv"></div>');
	var middleFilterDiv = $('#middleFilterDiv');
	middleFilterDiv.myFilters({
		dataSource: middleFilterSource,
		hideButtons: hideButtons,
		handlers: {
			cancelHandler: function (params) {
				$('#middleFilterDialog').remove();
			},
			applyHandler: function (params) {
				//устанавливаем верхний фильтр
				var resFilterValues = middleFilterDiv.myFilters('getFilterValuesArray');
				var dotSplitArr = resFilterValues[0].values;
				//Если не выбрано ни одной записи или выбраны все - не включаем в фильтрацию
				var roughArr = [];
				for (var j = 0; j < dotSplitArr.length; j++) {
					roughArr.push(dotSplitArr[j].code);
				}
				if (dotSplitArr.length == 0) {
					roughArr.push('NULL');
				}
				var showInfo = false;
				$('#middleFilterDialog').remove();
				var idFilter = resFilterValues[0].idFilter;
				if(setTopFilter){
					//устанавливаем выбранное значение в верхний фильтр
					var prms = [{
						name: 'filter',
						value:idFilter+':'+roughArr.join()
					}]
					WidgetMap.updateTopFilter(prms);
					if(that.openLayers.length){
						that.openLayers.forEach(function(layerName){
							WidgetMap.currentFilter[layerName] = [];
							WidgetMap.currentFilter[layerName].push({
								layerName: layerName,
								filter: idFilter,
								value: roughArr.join()
							});
						})
					}
				}
				if (setMiddleFilter) {
					var rr = [];
					WidgetMap.currentRoughFilter = [];
					for (var k = 0; k < showLayers.length; k++) {
						//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
						var smallLayerId = showLayers[k];
						rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
						WidgetMap.currentFilter[smallLayerId] = [];
						WidgetMap.currentFilter[smallLayerId].push({
							layerName: smallLayerId,
							filter: idFilter,
							value: roughArr.join(",")
						});
						WidgetMap.currentRoughFilter.push({name: idFilter, value: roughArr.join(","), layerName: smallLayerId});
					}
					//WidgetMap.currentRoughFilter = [{name:idFilter, value:}];
					if (applyHandler !== undefined)
						applyHandler();
				}
				//если был объявлен верхний фильтр, то при работе со средним выбранные значения будут заноситься в верхний
				else {
					//если открывался ещё средний фильтр, то выставляем currentRoughFilter для корректного нанесения геометрии на карту
					if (middleFilterSource !== undefined && middleFilterSource !== '' && filterType.indexOf('middle') !== -1) {
						var rr = [];
						WidgetMap.currentRoughFilter = [];
						for (var t = 0; t < showLayers.length; t++) {
							//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
							var smallLayerId = showLayers[t];
							rr.push({name: "roughFilter", value: roughArr.join(","), layerName: smallLayerId});
						}
						WidgetMap.currentRoughFilter.push({name: idFilter, value: roughArr.join(","), layerName: smallLayerId});
					}
					var newData = '<data OBJ_IDS="' + roughArr.join(',') + '" TOP_FILTER="' + idFilter + '" ></data>';
					var treeDiv = $('#treeDiv');
					if(treeDiv.length > 0)
						treeDiv.myCategories('updateTopFilter', {params: newData});

					function checkFilter(filter) {
						WidgetMap.updateTopFilter(filter.params);
						var splittedFilter = filter.params[0].value.split('|');
						for (var i = 0; i < splittedFilter.length; i++) {
							if (splittedFilter[i].indexOf(filterName) != -1) {
								var filterValue = splittedFilter[i].split(':')[1];
								for (var k = 0; k < showLayers.length; k++) {
									//устанавливаем в объект идентификаторы всех показываемых на карте слоёв
									var smallLayerId = showLayers[k];
									WidgetMap.currentFilter[smallLayerId] = [];
									WidgetMap.currentFilter[smallLayerId].push({
										layerName: smallLayerId,
										filter: filterName,
										value: filterValue
									});
								}
								if (filterValue == '' || filterValue == 'VOID') {
									showInfo = true;
								}
								if (filterValue !== roughArr.join(',')) {
									return false;
								}
								break;
							}
						}
						return true;
					}

					var filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: {}}) : undefined;
					if (filter && filter.params && filter.params.length > 0) {
						//добавляем проверку на выбранное кол-во записей перед открытием грида
						if (goog.isDef(idFilter)) {
							var filterName = idFilter;
							var start = Date.now();
							var timeout = 0;
							while (!checkFilter(filter) && timeout < 1000) {
								filter = (treeDiv.length > 0) ? treeDiv.myCategories('callbackFilter', {params: {}}) : undefined;
								timeout = Date.now() - start;
							}
						}
					}
					if (showInfo) {
						var text = gis_treeutils_3;
						var title = gis_treeutils_4;
						var buttons = [
							{text: gis_core_4, click: showGridDialog},
							{text: gis_core_5, click: closeDialog}
						];
						var dlg = App.confirmDialog(text, buttons, {title: title, width: 400});

						function closeDialog() {
							dlg.dialog('destroy');
							dlg.remove();
						}

						function showGridDialog() {
							if (applyHandler !== undefined)
								applyHandler();
							closeDialog();
						}
					} else if (applyHandler !== undefined)
						applyHandler(roughArr);
				}
			}
		}
	});

	var closeDiv = '<div id="middleFilterCloseDiv" class="middleFilterCloseDiv"></div>';
	middleFilterDiv.append(closeDiv);
	$('#middleFilterCloseDiv').on('click', function (event) {
		$('#middleFilterDialog').remove();
	});
	dlg.dialog({
		resizable: false,
		modal: true,
		dialogClass: 'noCloseButton noTitleBar gsi-zindex__dialog',
		width: 605,
		height: 440,
		title: ''
	});

};
ScenarioManager.prototype.updateTopFilter = function(){

}
ScenarioManager.prototype.updateRoughFilter = function(){

}


ScenarioManager.prototype.show = function(showLayers, clearFilter, vars){
	this.showLayersFnc(showLayers, clearFilter);
	this.openTablesFnc(vars);
}

ScenarioManager.prototype.showLayersFnc = function (showLayers, clearFilter) {
	if (showLayers.length > 0) {
		if (WidgetMap.layerManager != undefined) {
			for (var index = 0; index < showLayers.length; index++) {
				var smallLayerId = showLayers[index];
				var layer = WidgetMap.layerManager.getLayerByName(smallLayerId);
				if (goog.isDef(layer)) {

					if (layer.filter !== undefined && layer.filter !== '' && WidgetMap.isModelsVector == true) {
						//если векторный слоё, и слой с фильтром, то очищасем слой и перезапрашиваем данные
						WidgetMap.layerManager.clearLayer(smallLayerId, true);
					}
					if(clearFilter === true){
						layer.filter = undefined;
						layer.filters = undefined;
						if(layer.layer){
							layer.layer.filter = undefined;
							layer.layer.filters = undefined;
						}
					}
					if (layer.visible != true)
						WidgetMap.layerManager.updateLayer(smallLayerId);
					WidgetMap.layerManager.enableLayer(smallLayerId);
				}
			}
		}
	}
}

ScenarioManager.prototype.openTablesFnc = function (scenarioParams) {
	var timeout = 3000;
	if (scenarioParams !== undefined) {
		if (scenarioParams.interval !== undefined)
			timeout = scenarioParams.interval;
		//сначала подгружаем часть стиля для получения title грида
		var openTableTitle = scenarioParams.title;
		var openTableGridId = scenarioParams.gridId;
		var openTableLevelParams = scenarioParams.levelParams;
		var querySource = scenarioParams.querySource;
		var queryLayerId = scenarioParams.queryLayerId;
		var queryFileName = scenarioParams.queryFileName;
		//если есть данные для открытия гридов
		if (openTableTitle !== undefined && openTableGridId !== undefined && openTableLevelParams !== undefined
			&& querySource !== undefined && queryLayerId !== undefined && queryFileName !== undefined) {
			var openTableTitleArr = openTableTitle.replace('undefined|', '').split('|');
			var openTableGridIdArr = openTableGridId.replace('undefined|', '').split('|');
			var openTableLevelParamsArr = openTableLevelParams.replace('undefined|', '').split('|');
			var querySourceArr = querySource.replace('undefined|', '').split('|');
			var queryLayerIdArr = queryLayerId.replace('undefined|', '').split('|');
			var queryFileNameArr = queryFileName.replace('undefined|', '').split('|');
			var gridArr = [];
			function loadStyle() {
				if (gridArr.length > 0) {
					var gridItem = gridArr.pop();
					if (gridItem.title.indexOf('{') == -1) {
						ExternalInteraction.openTable(gridItem.gridId, gridItem.title, gridItem.levelParams);
						setTimeout(function () {
							loadStyle();
						}, timeout)
					} else
						App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml,
							{
								descrId: gridItem.source,
								descrType: 'select',
								getSchema: false,
								toElements: false,
								data: '<root><data LAYER_ID="' + gridItem.layerId + '" FILE_NAME="' + gridItem.fileName + '"/></root>'
							},
							function (xmlElement) {
								var xmlData = ($.parseXML(xmlElement)).firstChild;
								var styles = xmlData.getElementsByTagName("Style");
								var i = 0;
								if (styles.length > 0) {
									var curStyle = styles[0];
									var descr = curStyle.getAttribute('descr');
									//открываем грид
									if (descr !== undefined && descr !== '') {
										ExternalInteraction.openTable(gridItem.gridId, descr, gridItem.levelParams);
										setTimeout(function () {
											loadStyle();
										}, timeout)
									}
								}
							},
							function (xmlElement) {
							});
				}
			}
			//если количество данных для открытия гридов совпадает
			if (openTableTitleArr.length == openTableGridIdArr.length && openTableTitleArr.length == openTableLevelParamsArr.length &&
				openTableTitleArr.length == querySourceArr.length && openTableTitleArr.length == queryLayerIdArr.length &&
				openTableTitleArr.length == queryFileNameArr.length) {
				for (var i = 0; i < querySourceArr.length; i++) {
					gridArr.push({
						title: openTableTitleArr[i],
						source: querySourceArr[i],
						layerId: queryLayerIdArr[i],
						fileName: queryFileNameArr[i],
						gridId: openTableGridIdArr[i],
						levelParams: openTableLevelParamsArr[i]
					});
				}
				loadStyle();
			}
		}
	}
}

App.scenarioManager = new ScenarioManager();
/**
 * Абстрактный класс диалога с формой редактирования записей БД
 * Умеет считывать конфигурацию формы, загружать в нее данны и сохранять их на диске
 * Формирует всплывающий диалог и кнопочками. По умолчанию есть кнопки Сохранить и Отменить
 */

/* TEXT CONSTANTS */
var ABSTRACT_FORM_DIALOG_BUTTON_SAVE = gis_abstractformdialog_1;
var ABSTRACT_FORM_DIALOG_BUTTON_CLOSE = gis_abstractformdialog_2;
var ABSTRACT_FORM_DIALOG_LOADING_TEXT = gis_abstractformdialog_3;
var ABSTRACT_FORM_DIALOG_ERROR_LOADING_FORM = gis_abstractformdialog_4;
var ABSTRACT_FORM_DIALOG_ERROR_CREATING_FORM = gis_abstractformdialog_5;
var ABSTRACT_FORM_DIALOG_ERROR_SAVE_FORM = gis_abstractformdialog_6;
/**/


AbstractFormDialog = {};

AbstractFormDialog.dialogId = 'popupDialog';
 
AbstractFormDialog.form = null;

AbstractFormDialog.defaultValues = {};

AbstractFormDialog.loadData = true;
AbstractFormDialog.sendUser = true;

AbstractFormDialog.title = 'AbstractFormDialog';
AbstractFormDialog.formDescrId = null;
AbstractFormDialog.sysClassId = null;
AbstractFormDialog.descrId = null;
AbstractFormDialog.dbSchemaId = null; 
AbstractFormDialog.dbTableId = null; 
AbstractFormDialog.saveDescrType = 'update'; 
AbstractFormDialog.buttons = {                
    save           :ABSTRACT_FORM_DIALOG_BUTTON_SAVE,
    close          :ABSTRACT_FORM_DIALOG_BUTTON_CLOSE
};    
AbstractFormDialog.defaultAction = 'save';

AbstractFormDialog.init = function() {   
    this.form = new Form();
    
    var m = /^([^_]+)_(.+)$/.exec(this.sysClassId);
    if(m) {
        this.dbSchemaId = m[1]; // sysClassId до первого подчеркивания
        this.dbTableId  = m[2]; // sysClassId после первого подчеркивания
    }
};

AbstractFormDialog.makeLoadDataReqParams = function() {
    var userId    = this.sendUser ? ''+Auth.getUserId()   : '-1';
    var userLogin = this.sendUser ? ''+Auth.getUserName() : 'guest';

    return {
        getSchema:  false,
        descrId:    this.descrId,
        toElements: false,
        descrType:  'select',
        data:
            '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data SYS_FULL_ID="'+this.sysClassId+'/'+userId.xmlEscape()+'" SYS_CLASS_ID="'+this.sysClassId+'" SYS_OBJ_ID="'+userId.xmlEscape()+'" DB_SCHEMA_ID="'+this.dbSchemaId+'" DB_TABLE_ID="'+this.dbTableId+'" CURRENT_USER_LOGIN="'+userLogin.xmlEscape()+'" CURRENT_USER_ID="'+userId.xmlEscape()+'" />'+
            '</root>'
    };
};

AbstractFormDialog.makeSaveDataReqParams = function(values) {
    var userId    = this.sendUser ? ''+Auth.getUserId()   : '-1';
    var userLogin = this.sendUser ? ''+Auth.getUserName() : 'guest';

    return {
        descrType:  this.saveDescrType,
        getSchema:  false,
        descrId:    this.descrId,
        toElements: false,
        data:              
            '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'">'+
            '<data '+this.structToXmlAttrs(values)+' SYS_FULL_ID="'+this.sysClassId+'/'+userId.xmlEscape()+'" SYS_CLASS_ID="'+this.sysClassId+'" SYS_OBJ_ID="'+userId.xmlEscape()+'" DB_SCHEMA_ID="'+this.dbSchemaId+'" />'+
            '</root>'                                  
    };       
};

AbstractFormDialog.structToXmlAttrs = function(values) {
    var fieldsAttrs = '';
    $.each(values, function(name, value){
        fieldsAttrs += ' '+name.toUpperCase()+'="'+value.toString().xmlEscape()+'"';
    });        
    return fieldsAttrs;
};

/*
 * Построение всего диалога и обработка событий
 */
AbstractFormDialog.build = function() {    
    var that = this;
    
    // Создадим диалог. Сначала пустой
    $('#'+this.dialogId).remove();
    $('body').append('<div id="'+this.dialogId+'">'+ABSTRACT_FORM_DIALOG_LOADING_TEXT+'</div>');
    $('#'+this.dialogId+'').dialog({
        dialogClass: 'appDialog',
        modal  : true,
        title  : this.title,
        width  : 800,
        height : 100        
    });

    //Устанавливаем курсор ожидания
    BlockingUtil.wait();
    try {
        // Запрос данных
        var values = this.defaultValues;
        function dataReq() {
            return App.serverQueryNodeWithTries(Services.processQueryNode, that.makeLoadDataReqParams(), function(xml){
                $.each(xml.find('data:first').get(0).attributes, function(){
                    if(this.specified) {
                        values[this.name] = this.value;                        
                    }                                    
                });                         
            });
        }        

        // Запрос структуры формы
        var formStruct;
        function formReq() {
            var fileName = '../../Public/Modules/Form/'+that.formDescrId+'.mxml';
            return App.serverQueryXmlFileNode1(Services.processQueryNodeXml, 'SYS_SEM.xml#GET_XML_FILE', fileName,
                function (xml) {
                var er = HTTPServiceUtil.getError(xml);
                if (er !== '')
                    App.errorReport(gis_core_error_1, er,undefined,{filename:gis_filename_4, functionname:'gis_filename_4_1'});
                else 
                    formStruct = xml;
            });
        }

        // Построим форму, когда данные и описание формы загрузятся
        var prom;
        if(this.loadData) {
            prom = $.when(formReq(), dataReq());
        }
        else {
            prom = $.when(formReq());
        }
        
        prom.then(function(){     
            var dlg = $('#'+that.dialogId);
            dlg
                .empty()
                .append('<form class="form" method="post"></form>');

            that.form.setContainer($('.form', dlg));
            that.form.setXml(formStruct);
            that.form.setValues(values);
            that.form.build();                                 

            // Ставим фокус на первое поле
            $('form input[type="text"]:first', dlg).attr('autofocus', 'autofocus').focus();

            var w = that.form.getWidth();
            var h = that.form.getHeight();                

            // Готовим кнопки, и добавляем обработчики
            var buttons = [];
            $.each(that.buttons, function(name, text){                
                buttons.push({ 
                    text: text,
                    click: function(){
                        var funcName = name+'Action';
                        if(that[funcName]) {
                            that[funcName].apply(that);
                        }
                    }
                });                    
            });

            // Формируем диалог
            dlg.dialog({
                width   : w ? w+10  : 800,
                height  : h ? h     : 'auto',                    
                buttons : buttons                  
            }); 
                        
            // Костыль: Исправление бага в Chrome который приводит к скаканию высоты диалога при наличии в нем select-ов            
            $('select', dlg).hide().show();                       
            
            // При нажатии Enter автоматичеcки делаем действие по умолчанию
            dlg.keydown(function(event) {
                if (event.keyCode == 13) {                    
                    var func = that[that.defaultAction+'Action'];
                    if(func) {
                        func.apply(that);
                    }                    
                    event.preventDefault();
                    return false;
                }                
            });
            //Снимаем курсор ожидания
            BlockingUtil.ready();
        });
        prom.fail(function(){
            //Снимаем курсор ожидания
            BlockingUtil.ready();
            App.errorReport(ABSTRACT_FORM_DIALOG_ERROR_LOADING_FORM+' "'+that.title+'"', '',undefined,{filename:gis_filename_4, functionname:'AbstractFormDialog.build_fail'});
        });
    }
    catch(e) {
        //Снимаем курсор ожидания
        BlockingUtil.ready();
        App.errorReport(ABSTRACT_FORM_DIALOG_ERROR_CREATING_FORM+' "'+that.title+'"', e,undefined,{filename:gis_filename_4, functionname:'AbstractFormDialog.build_catch'});
    }               
};

AbstractFormDialog.saveAction = function() {
    var that = this;
    //Устанавливаем курсор ожидания
    BlockingUtil.wait();

    var formValues = this.form.getValues();

    if(formValues.theme !== undefined){
        //пока хардкодятся элементы
        var mode = (formValues.map_mode_raster === true) ? WidgetMap.MODES.RASTER : WidgetMap.MODES.VECTOR;
        mode = MapUtil.getAvailableMapMode(mode);
        MapUtil.applyThemeParams({
            mapMode: mode,
            showOverviewMap: formValues.show_overview_map === true,
            showTree: formValues.show_tree === true,
            sendCadastreEmail: formValues.send_cadastre_email === true,
            showCenterMap: formValues.show_center_map === true,
            coordMode: (formValues.coord_mode_decimal === true)?'decimal':'grad',
            useSynchronization: formValues.use_synchronization === true,
        });
    }

    var req = App.serverQueryNode(Services.processQueryNode, this.makeSaveDataReqParams(formValues));
    req.done(function(resultXml){
        var er = HTTPServiceUtil.getError(resultXml);
        if (er !== ''){
            App.errorReport(ABSTRACT_FORM_DIALOG_ERROR_SAVE_FORM+' "'+that.title+'"', er,undefined,{filename:gis_filename_4, functionname:'AbstractFormDialog.saveAction_done'});
            BlockingUtil.ready();
        }
        else {
            //Снимаем курсор ожидания
            BlockingUtil.ready();
            $('#'+that.dialogId).dialog('destroy').remove();
        }
    }); 
    req.fail(function(errorText){
        var er = HTTPServiceUtil.getError(errorText);
        if (er !== '')
            App.errorReport(ABSTRACT_FORM_DIALOG_ERROR_SAVE_FORM+' "'+that.title+'"', er,undefined,{filename:gis_filename_4, functionname:'AbstractFormDialog.saveAction_fail'});
        //Снимаем курсор ожидания
        BlockingUtil.ready();
        //BlockingUtil.unblockApplication();
        
    });        
};

AbstractFormDialog.closeAction = function() {
    $('#'+this.dialogId).dialog('destroy').remove(); 
};


UserOfficeDialog = Object.create(AbstractFormDialog);
UserOfficeDialog.title          = gis_userofficedialog_1;
UserOfficeDialog.formDescrId    = 'WEB50_B_USER_PRIVATE';
UserOfficeDialog.sysClassId     = 'WEB50_B_USER_PRIVATE';
UserOfficeDialog.descrId        = 'SYS_SEM.xml#WEB50_B_USER_PRIVATE';
UserOfficeDialog.buttons = {     
    changePassword :gis_userofficedialog_2,
    save           :gis_core_2,
    close          :gis_core_6
};   
UserOfficeDialog.defaultAction = null;

UserOfficeDialog.changePasswordAction = function() {    
    var dialog = Object.create(ChangePasswordDialog);
    dialog.build();
};

/**
 * Класс формы управления задачами
 */
function TaskOfficeForm(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.callback = options.callback;
}
TaskOfficeForm.prototype.build = function() {
	var that = this;
	var dcf = new DashboardChooserForm();
	dcf.build();
	/*$('#taskOfficeDialog').remove();
	var divv = '<div id="taskOfficeDialog">' +
		'<div style="display: flex;margin-top: 9px;justify-content: space-around;">' +
		'<input type="button" class="map-dialog-button" style="width: 123px;" id="taskArchive" name="archive"  value="'+ gis_taskofficedialog_1 + '" >' +
		'<input type="button" class="map-dialog-button" style="width: 123px;" id="taskSave" name="save" value="'+ gis_taskofficedialog_2 + '" >' +
		'</div>'
	'</div>';
	$('body').append(divv);
	var dlg = $('#taskOfficeDialog');
	dlg.dialog({
		modal: false,
		title: gis_taskofficedialog_3,
		dialogClass: 'gsi-zindex__task-office',
		closeOnEscape: true,
		width: 260,
		height: 80,
		resizable: false,
		close: function () {
			try {
				$(this).dialog('destroy').remove();
			} catch (e) { }
		}
	});
	$('#taskArchive').on('click',function(){
		var dcf = new DashboardChooserForm();
		dcf.build();
		App.destroyDialog(null, dlg);
	});
	$('#taskSave').on('click',function(){
		var dashboard = App.dashboardManager.getDashboard(null);
		if(dashboard)
			App.dashboardManager.showSaveDashboardForm(dashboard.id);
		App.destroyDialog(null, dlg);
	});*/
};


/*
 * Диалог регистрации пользователя
 */
UserRegistrationDialog = Object.create(AbstractFormDialog);

UserRegistrationDialog.loadData = false;
UserRegistrationDialog.sendUser = false;

UserRegistrationDialog.title          = gis_userregistrationdialog_1;
UserRegistrationDialog.formDescrId    = 'WEB50_B_USER_PRIVATE_REG';
UserRegistrationDialog.sysClassId     = 'WEB50_B_USER_PRIVATE_REG';
UserRegistrationDialog.descrId        = 'SYS_SEM.xml#WEB50_B_USER_PRIVATE_REG';
UserRegistrationDialog.saveDescrType  = 'insert';
UserRegistrationDialog.defaultValues  = {status:'B'};

UserRegistrationDialog.buttons = {         
    register : gis_userregistrationdialog_2,
    cancel   : gis_userregistrationdialog_3
};   
UserRegistrationDialog.defaultAction = null;

/**  
 * Нажатие на кнопку отмены
 */
UserRegistrationDialog.cancelAction = function() {       
    var that = this;
    
    var buttons = [
        {text:gis_core_4,  click:yesAction},
        {text:gis_core_5, click:noAction}
    ];
    
    var dlg = App.confirmDialog(gis_userregistrationdialog_6, buttons, {title:gis_userregistrationdialog_7});

    function noAction() {        
        dlg.dialog('destroy').remove();
    }
    
    function yesAction() {                
        that.closeAction();
        dlg.dialog('destroy').remove();
    }    
};

/**  
 * Нажатие на кнопку регистрации
 */
UserRegistrationDialog.registerAction = function() {       
    var that = this;
    
    var buttons = [
        {text:gis_core_4,  click:yesAction},
        {text:gis_core_5, click:noAction}
    ];
    
    var dlg = App.confirmDialog(gis_userregistrationdialog_8, buttons, {title:gis_userregistrationdialog_9});

    function noAction() {        
        dlg.dialog('destroy').remove();
    }
    
    function yesAction() {                
        that.saveAction();
        dlg.dialog('destroy').remove();
    }    
};

/**  
 * Переопределение действия сохранения формы
 */
UserRegistrationDialog.saveAction = function() {       
    req = App.serverQueryNode(Services.processQueryNode, this.makeSaveDataReqParams(this.form.getValues()));
    
    req.done(function(doc){
        var id = doc.find('data:first').attr('ID');
        if(id) {
            $('#userOfficeDialog').dialog('close').remove();
            App.confirmDialog(gis_userregistrationdialog_10, null, {title:gis_userregistrationdialog_1});
        }
    }); 
    
    req.fail(function(errorText){
        App.errorReport(gis_userregistrationdialog_12, errorText, undefined, {filename:gis_filename_293, functionname:'gis_filename_293_1'});
    });        
};


/**
 * Класс диалога смены пользователя
 */
/* TEXT CONSTANTS */
var USER_CHANGE_DIALOG_TITLE = gis_userchangedialog_1;
/**/

function UserChangeDialog() {    
    this.targetUrl = null;
    this.title = USER_CHANGE_DIALOG_TITLE;
    this.closable = true;    
    this.htmlUrl = 'ui/html/UserChangeDialog.html';    
};

UserChangeDialog.prototype._anonimUpdate = function () {           
    var dlg = $('#userChangeDialog');
    
    var fields = $("input[name='login'], input[name='password'], input[name='remember']", dlg);
    if($('input[name="anonimous"]', dlg).is(':checked')) {
        fields.addClass('readOnly').attr('disabled', 'disabled');
    }
    else {
        fields.removeClass('readOnly').removeAttr('disabled');
    }        
 };

UserChangeDialog.prototype.build = function() {
    var that = this;
    
    $('#userChangeDialog').remove();
    $('body').append('<div id="userChangeDialog"></div>');
    var dlg = $('#userChangeDialog');
    dlg.load(this.htmlUrl, build);    
    
    function build() {        
        dlg.dialog({
            modal  : true,
            title  : that.title,
            dialogClass   : that.closable ? '' : 'noCloseButton',
            closeOnEscape : that.closable,
            width  : 248,
            height : 154
        });       
 

 
        // Пятаемся перелогинится и по нажатию Enter тоже
        $('input[name="login"], input[name="password"]', dlg).keypress(function(e){       
            if(e.which == 13) {
                that.change();
            }
        });       
        
        // Блокируем поля ввода если надо войти анонимно
        $('input[name="anonimous"]', dlg).change(function(){
            that._anonimUpdate();
        });  
        
        // Кнопки
        $("input[name='change']",       dlg).click(function(){ that.change(); });
        $("input[name='cancel']",       dlg).click(function(){ that.cancel(); });        
        $("input[name='registration']", dlg).click(function(){ that.registration(); });      
        
        // Подставим последний логин
        $('input[name="login"]', dlg).val(Auth.getLastLogin());
    }
};

UserChangeDialog.prototype.setTargetUrl = function(url) {
    this.targetUrl = url;
};

UserChangeDialog.prototype.change = function() { 
    var that = this;
    
    var dlg = $('#userChangeDialog');
    var login    = $("input[name='login']",    dlg).val();
    var password = $("input[name='password']", dlg).val();
    var remember = $("input[name='remember']", dlg).is(':checked');

    // Или анонимно, если стоит чекбокс
    if($('input[name="anonimous"]', dlg).is(':checked')) {
        login    = 'guest';
        password = 'guest';
    }
    
    $('input', dlg).attr('disabled', 'disabled');
    var promise = Auth.login(login, password, remember);
    promise.always(function(){
        $('input', dlg).removeAttr('disabled');
        that._anonimUpdate();
    });       
};

UserChangeDialog.prototype.logout = function() {
    Auth.logout();
};

UserChangeDialog.prototype.cancel = function() {
    $('#userChangeDialog').remove();
};

UserChangeDialog.prototype.registration = function() {
    Auth.registration();
};

function UserLoginDialog() {
    this.title = gis_userlogindialog_1;
    this.htmlUrl = 'ui/html/UserLoginDialog.html';    
    this.closable = false;
}

UserLoginDialog.prototype = new UserChangeDialog();

UserLoginDialog.prototype.build = function() {
    var that = this;

    $('#userChangeDialog').remove();
    $('body').append('<div id="userChangeDialog"></div>');
    var dlg = $('#userChangeDialog');
    dlg.load(this.htmlUrl, build);

    function build() {
        dlg.dialog({
            modal  : true,
            title  : that.title,
            dialogClass   : that.closable ? '' : 'noCloseButton',
            closeOnEscape : that.closable,
            width  : 265,
            height : 143
        });



        // Пятаемся перелогинится и по нажатию Enter тоже
        $('input[name="login"], input[name="password"]', dlg).keypress(function(e){
            if(e.which == 13) {
                that.change();
            }
        });

        // Блокируем поля ввода если надо войти анонимно
        $('input[name="anonimous"]', dlg).change(function(){
            that._anonimUpdate();
        });

        // Кнопки
        $("input[name='change']",       dlg).click(function(){ that.change(); });
        $("input[name='cancel']",       dlg).click(function(){ that.cancel(); });
        $("input[name='registration']", dlg).click(function(){ that.registration(); });

        // Подставим последний логин
        $('input[name="login"]', dlg).val(Auth.getLastLogin());
    }
};

UserLoginDialog.prototype.change = function() { 
    var that = this;
    
    var dlg = $('#userChangeDialog');
    var login    = $("input[name='login']",    dlg).val();
    var password = $("input[name='password']", dlg).val();
    var remember = $("input[name='remember']", dlg).is(':checked');

    // Если страница открыта с параметрами (например нам прислали ссылку по email)
    // От попробуетм открыть именно с такими параметрами
    var targetUrl;
    var m = /task=([^&#\^]+)&mdl=([^&#\^]+)([^$#]*)/.exec(window.location.href);
    if(m) {
        var splittedUrl  = window.location.href.split('#')[0].split('?');
        var smallurl = splittedUrl[0];
        targetUrl = smallurl+'?task='+m[1]+'&mdl='+m[2]+'&rand='+Math.random()+m[3];
    }    

    $('input', dlg).attr('disabled', 'disabled');    
    var promise = Auth.login(login, password, remember, targetUrl);        
    promise.always(function(){
        $('input', dlg).removeAttr('disabled');
        that._anonimUpdate();
    });    
};
/**
 * Класс диалога смены пароля
 */
ChangePasswordDialog = {
    build: function() {
        var that = this;

        if (!that.hasOwnProperty('changingUserLogin') || that.changingUserLogin==undefined || that.changingUserLogin==null) that.changingUserLogin = '';

        function build() {
            dlg.dialog({
                modal : true,
                dialogClass: 'gsi-zindex__dialog',
                title : gis_changepassworddialog_1,
                width : 380,
                buttons: [
                    {text:gis_changepassworddialog_2, click: function (){ that.change(that.changingUserLogin);} },
                    {text:gis_core_6, click: that.cancel}
                ]
            });
            var wgt = dlg.dialog('widget');

            dlg.keydown(function(event) {
                if (event.keyCode == 13) {
                    $('.ui-dialog-buttonset button:first', wgt).click();
                    return false;
                }
            });
        }

        $('#changePasswordDialog').remove();
        $('body').append('<div id="changePasswordDialog"></div>');
        var dlg = $('#changePasswordDialog');
        dlg.load('ui/html/ChangePasswordDialog.html', build);
    },
    
    change: function(changingUserLogin) {
        var dlg = $('#changePasswordDialog');
        
        var oldPassword  = $("input[name='oldPassword']",  dlg).val();
        var newPassword  = $("input[name='newPassword']",  dlg).val();
        var newPassword2 = $("input[name='newPassword2']", dlg).val();
        
        var error = null;
        var errorTitle = null;
        if(!/^.{1,}$/.test(newPassword)) {
            error = gis_changepassworddialog_4;
            errorTitle = gis_changepassworddialog_7;
        }
        /* Условие проверки - пароль не менее 8 символов, состоящий из латинских букв, хотя бы 1 цифры и хотя бы 1 спецсимвола */
        else if (newPassword.length<8 || !newPassword.match(/\d/) || !newPassword.match(/[a-zA-Z]/) || !newPassword.match(/[!,@,#,$,%,^,&,*,\(,\),\-,\+,?,_,:,;,~]/)) {
            error = gis_changepassworddialog_5;
            errorTitle = gis_changepassworddialog_6;
        }
        else if(newPassword !== newPassword2) {
            error = gis_changepassworddialog_8;
            errorTitle = gis_changepassworddialog_9;
        }
        
        if(error) {
            App.confirmDialog(error, null, {title:errorTitle});
        }
        else {
            //Для административной задачи вставляем условие, что если передали свойство currentUserLogin, то меняем пароль для него
            var userLoginPassChange = changingUserLogin!=undefined && changingUserLogin ? changingUserLogin : '';
            App.getJsonTextNode(Services.changePassNode, {
                newPassword	: CryptoJS.MD5(newPassword).toString(),
                password	: oldPassword,
                changeLogin	: userLoginPassChange,
                useExtAuth	: 'false',
                login       : Auth.getUserName()
            },function(resultXml){
                var er = HTTPServiceUtil.getError(resultXml);
                if(er !== ''){
                    App.errorReport(gis_admchangepassform_6, er, undefined, {filename:gis_filename_302, functionname:'gis_filename_302_3'});
                    return;
                }
                $('#changePasswordDialog').remove();
                App.confirmDialog(gis_changepassworddialog_10, null, {title:gis_changepassworddialog_11});
            },function(error){
                App.errorReport(error);
            });
        }
    },

    cancel: function() {
        $('#changePasswordDialog').remove();
    }        
};




/**
 * Класс диалога отправки отчета об ошибке
 */
SendErrorReportDialog = {
    dialogId: 'sendErrorReportDialog',    
    data: '',
    params: '',
	opener:undefined,
	closeCallback: undefined,//функция закрытия из формы ошибки
    
    setData: function(data, params, opener, closeCallback){
        this.data = data;
		this.closeCallback = closeCallback;
        //если дополнительные данные пришли(название файла, название функции,..), то заполняем переменную
        if(params !== undefined) {
            if(params.filename != undefined)
	            this.params += gis_senderrorreportdialog_16 + params.filename+"\n\n";
	        if(params.functionname != undefined)
	            this.params += gis_senderrorreportdialog_17 + params.functionname+"\n\n";
	        if(params.datatext != undefined)
		        this.params += gis_senderrorreportdialog_18 + params.datatext+"\n\n";
        }
        this.opener = opener;
    },
    
    build: function() {
        var that = this;

        $('#'+this.dialogId).remove();
        $('body').append('<div id="'+this.dialogId+'"></div>');
        var dlg = $('#'+this.dialogId);
        dlg.load('ui/html/SendErrorReportDialog.html', build);
        function build() {
            $('input[name="user"]',    dlg).val(Auth.getUserName());
            $('textarea[name="data"]', dlg).val(that.data);
	        $('textarea[name="paramsdata"]', dlg).val(that.params);

	        var buttons = {};
	        buttons[gis_senderrorreportdialog_19] = function(){ that.send()};
		    buttons[gis_senderrorreportdialog_20] = function(){ that.cancel()};

            dlg.dialog({
                modal : true,
                title : gis_senderrorreportdialog_1,
	            dialogClass: 'ui-send-error-dialog',
                width : 460,
                buttons: buttons
            });
        }
    },
    
    send: function() { 
        var that = this;
        
        var dlg = $('#'+this.dialogId);
        
        var type        = $("select[name='type']",          dlg).val();
        var email       = $("input[name='email']",          dlg).val();        
        var name        = $("input[name='name']",           dlg).val();
        var description = $("textarea[name='description']", dlg).val();
        var data        = $("textarea[name='data']",        dlg).val();
	    var paramsdata  = $("textarea[name='paramsdata']",  dlg).val();



	    if(paramsdata != '')
		    data += gis_senderrorreportdialog_15 + paramsdata + gis_app_55_12;
	    else
		    data += gis_app_55_12;

        var message =
	        gis_senderrorreportdialog_2 + Auth.getUserId() + "<br>" +
	        gis_senderrorreportdialog_3 + Auth.getUserName() + "<br>" +
	        gis_senderrorreportdialog_4 + name + "<br>" +
	        gis_senderrorreportdialog_5 + "<br><pre>"+description+"</pre><br>"+
	        gis_senderrorreportdialog_6 + "<br><pre>"+data+"</pre><br>";

	    App.getJsonTextNode(Services.sendMailNode, {
            addMailTo : email,
            subject   : type,
            fileName1  : '',
            message   : message
        },function(resp){
	    },function(textError){
		    App.errorReport(gis_senderrorreportdialog_11,gis_senderrorreportdialog_9+'. '+textError, undefined, {filename:gis_filename_292, functionname:'gis_filename_292_1'});
	    });
	    if(this.closeCallback)
		    this.closeCallback();
        App.destroyDialog(that.dialogId);
        if(this.opener)
	        App.destroyDialog(this.opener);
    },
    cancel: function() {
    	if(this.closeCallback)
		    this.closeCallback();
        App.destroyDialog(this.dialogId);
    }        
};




/**
 * Менеджер панелей задачи в json формате
 */
function PanelManagerJson() {
    this.container = null;
    this.json = null;
    /*Объект с возможными id панелей в качестве ключей и константами с текстом загрузки в качестве значений*/
    this.panelLoadingTextDict = {MAPSERVICE:gis_panelmanager55_2, WIDGET_GRID:gis_panelmanager55_3, CAS:gis_panelmanager55_4};
};

/**
 * Установка контейнера для панели с модулями
 */
PanelManagerJson.prototype.setContainer = function(container) {
    this.container = container;
};


//Парсинг структуры XML данных в div-ы с модулями
PanelManagerJson.prototype.build = function(json, taskName) {
    var that = this;
    if(json === undefined) return;
    try {
        var panelId = json.id;
        if(json.previous_site !== undefined && json.previous_site !== '')
            App.prevSite = json.previous_site;
        if(json.new_site !== undefined && json.new_site !== '')
            App.newSite = json.new_site;
        if (panelId === undefined){
            App.errorReport(gis_core_17,'В файле задач - ' + taskName + ' отсутствует id.' + gis_core_19, undefined, {filename:gis_filename_288, functionname:'gis_filename_288_3'});
            return;
        }
        var element = $('<div class="panel" id="'+panelId+'"/>');
        element.attr('style','width : 100%; height : 100%');
        this.container.empty().append(element);
        if(App.config !== undefined && json.ppanel !== undefined){
            App.config.SHOW_SYSTEM_INFO = json.ppanel.showSystemInfo;
        }
        if(App.scenarioManager){
            //устанавливаем конфиг сценариев
            App.scenarioManager.setConfig(json.startupScenario);
            App.scenarioManager.call(function(){
                that.loadTask(panelId, json);
            })
        }
        else{
            this.loadTask(panelId, json);
        }
    }
    catch(e) { // Распарсить XML не удалось
        App.errorReport(gis_panelmanager55_5, e, undefined, {filename:gis_filename_288, functionname:'gis_filename_288_2'});
        //Очищаем панель задач
        this.container.empty();
    }

};

/**
 * Функция загрузки задачи
 * @param panelId идентификатор задачи
 * @param json настройки задачи
 */
PanelManagerJson.prototype.loadTask = function(panelId, json){
    var panels = ['MAPSERVICE', 'MAPSERVICE_ADM_TREE', 'MAPTECHSERVICE', 'adm_lib_doc'];
    if(panels.indexOf(panelId) !== -1 ){
        //для карты парсим её настройки в отдельнфй объект карты
        if(!goog.isDefAndNotNull(WidgetMap.config)){
            WidgetMap.config = json;
            WidgetMap.treeConfig = json.tree;
            WidgetMap.videoConfig = json.video;
        }
        if(panelId === "MAPTECHSERVICE") {
            var browserScale = getBrowserZoom();
            if(browserScale !== 1){
                App.confirmDialog(gis_core_23, null, {title:gis_core_1, dialogClass: 'noCloseButton', closeOnEscape: false});
            }
        }
        App.PreloadUser(panelId, true);
    }
    else if(panelId === "CAS"){
        //для ПКА парсим её настройки в отдельнфй объект карты
        if(!goog.isDefAndNotNull(WidgetMap.config))
            WidgetMap.setConfig(json);
        App.PreloadUser(panelId,true);
        //App.PreloadCAS(panelId,true);
    }
}

/**
 * Класс js-виджета грида (встраивается функцией build в элемент с id=widgetElementId)
 */
GridWidget.DEFAULT_FILTER = "8=8";
//глобавлая переменная с описаниями гридов для работы кнопки фильтрации вначале при открытии грида
GlobalGridDescr = {};

function GridWidget(opt_options) {
	var options = opt_options !== undefined ? opt_options : {};
	this.layerId = '';
	this.fullLayerId = options.fullLayerId;
	this.id = options.id; //ex. id5828_GRID
	this.title = options.title || '';
	this.gridDescriptionXml = null;
	this.gridDescriptionJson = null;
	this.dataAdapter = undefined;
	//флаг указывает, были ли какие-то манипуляции с контентом грида(фильтрация, сортировка, смена кол-ва записей)
	this.modified = false;
	this.refreshGridCallback = undefined;
	this.ignoreAllFilter = false;
	//флаг начального открытия формы фильтров для дашбордов
	this.showDashboard = options.showDashboard;
	//условия раскраски ячеек
	this.colorValidations = {};
	//условие раскраски строк
	//формат расцветки(выбрано или нет условие и массив расцветки) {selected: false, array:[]};
	this.colorRowValidations = {};
	this.colorRowSelectType = 0;//не выделять строки грида после расцветки. 1 - выделить некритичные, 2 - выделить критичные
	this.maxCriticalColor = undefined;
	this.minCriticalColor = undefined;
	//фильтр, пришедший извне
	this.filter = options.filter;
	this.checkedList = [1];
	//название грида в тулбаре от названия выбранной колонки
	this.titleGridColumn = undefined;
	//нужно ли игнорировать отрисовку колонки(для случая наличия кнопки "Показать все записи")
	this.ignoreLabelColumn = (options.ignoreLabelColumn !== undefined) ? options.ignoreLabelColumn: true;

	//идентификаторы родительского грида и потомка
	this.parentGrid = options.parentGrid;
	this.childGrid = options.childGrid;

	//фильтры из родительского грида, которые попадают как есть в переменную FILTER_SQLITE
	this.parentRoughFilter = options.parentRoughFilter;
	//храним родительский фильтр для использования при переходе наружу
	this.staticParentRoughFilter = options.staticParentRoughFilter;
	//переменные из родительского грида, которые попадают в <var> - являются содержимым колонок грида
	this.parentRoughParams = options.parentRoughParams;
	this.parentGridRowId = options.parentGridRowId;
	this.parentGridFilter = options.parentGridFilter;
	this.showFirstBottomFilterMessage = false; // флаг показа сообщения, что был переход из дочернего грида и нельзя выставить скалярные значения
	if(this.parentGridFilter && this.parentGridFilter.length > 0)
		this.showFirstBottomFilterMessage = true;

	if(!this.parentRoughFilter)
		this.ignoreLabelColumn = true;
	//флаг, нужно ли центроватьна карте сразу при открытии грида
	this.filterMap = options.filterMap;

	//перечень колонок грида
	this.columns = [];
	//перечень скрытых на данный момент колонок грида
	this.hiddenColumns = undefined;

	/********* Начало блока для предзагрузки данных ************/
	//закэшированные изначальные данные со всеми колонками
	this.cachedRecords = []; //pageSize * 10 = 500 записей

	//массив отображаемых записей в гриде.
	this.cachedContentRecords = [];

	this.pageSize = 30;//количество записей на страницу
	this.pageCacheSize = 150;//количество закешированных записей
	this.pageCursor = 1;//начальное положение, по достижению лимита 120 записей(this.pageCacheSize-this.pageSize) отправляем запрос на догрузку новых данных

	/********* Конец блока для предзагрузки данных ************/
	//список идентификаторов, которые на данный момент находятся в заполненном гриде.
	//используется в рамках синхронизации с картой
	this.currentRequestedIds = [];

	//начальное состояние настроек грида
	this.defaultState = null;
	//используется для хранения промежуточной информации, например, когда скрываем колонки
	this.currentState = null;

	//Функция обратного вызова для передачи данных в плагин jqxDataAdapter после их успешного возвращения
	this.jqxDataAdapterCallback = undefined;

	this.primaryKeyField = 'ID';
	this.foreignKeyField = '';

	//фильтры из build
	this.filters = [
		{name: 'LPU_ACCESS_FILTER', value: '13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0'}
	];
}

GridWidget.prototype.build = function(widgetElementId, gridTemplate, fullLayerId, gridTitle) {
	var that = this;
	that.title = gridTitle;
	//Уникальный идентификатор грида формируем на основе идентификатора элемента
	var jqxGridId = "jqxgrid" + widgetElementId;
	//Формируем обертку, в которой будем создавать грид
	var widgetContent =
		'<div id="jqxDockPanel' + jqxGridId + '" style="width: 100%; height: 100%">' +
		'<div dock="left" id="gridButtons' + jqxGridId + '" class="gridButtonsPanel">' +
		'</div>' +
		'<div id="jqxWidget' + jqxGridId + '" dock="right" style="width: 100%; height: 100%;">' +
		'<div id="' + jqxGridId + '" class="mainGrid" data-layerid="' + fullLayerId + '" >' + getLocalization('ru').loadtext +
		'</div>' +
		'</div>' +
		'</div>';
	$('#' + widgetElementId).html(widgetContent);
	//Создаем панель с возможностью процентного и фиксированного layout
	$("#jqxDockPanel"+jqxGridId).jqxDockPanel({ width: '100%', height: '100%'});
	//id запроса на данные и количество записей
	var currentGridMessageId = undefined; //Это не ID запроса. Это сам текущий запрос на грид, который можно отменить через currentGridMessageId.abort()
	var isDataAborted = false;
	//Источник данных текущего грида (сделан публичным для обновления грида)
	var gridSource = {};

	//Фильтры верхнего уровня по-умолчанию, которые передаются в запрос
	var filters = [
		{name: 'LPU_ACCESS_FILTER', value: '13006,13022,13009,13011,13004,13003,13000,13023,13008,13013,13002,13005,13001,13007,13021,0'}
	];
	this.filters = filters;
	//количество загруженных справочников
	var loadingFilterCount = 0;

	//Фильтры среднего уровня по-умолчанию, которые передаются в запрос
	var roughFilters = [];

	//Сразу парсим и получаем слой грида через LayerManager
	var layerManagerInst;
	if (WidgetMap !== undefined && WidgetMap.layerManager !== undefined) {
		layerManagerInst = WidgetMap.layerManager;
	} else {
		//Устанавливаем fullLayerId в нормальный (с разделителем # вместо *)
		var gridFullLayerId = fullLayerId.replace('*','#');
		var gridFullLayerIdArr = gridFullLayerId.split('#');
		var gridLayerFileName = gridFullLayerIdArr[0];
		var gridLayerId = gridFullLayerIdArr[1];

		layerManagerInst = new LayerManager();
		layerManagerInst.parseLayersDescr(gridLayerFileName);
	}
	var cancelGridProcess = function () {
		if (currentGridMessageId) {
			isDataAborted = true;
			currentGridMessageId.abort();
			currentGridMessageId = undefined;
			//Снимаем курсор ожидания
			BlockingUtil.ready();
			//Не обновляем грид - это делается в endProcess.
		}
	};

	/* Получение описания нашего грида */
	function getGridDescription(gridDescrId) {
		//Получаем объект запроса из описания грида
		var gridDescrRequest = GridWidget.prototype.makeLoadGridDescrReqParams(gridDescrId);
		//Устанавливаем курсор ожидания
		BlockingUtil.wait();
		//BlockingUtil.blockApplication();
		//Делаем запрос на получение описания грида
		return App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, gridDescrRequest, onLoadGridDescrResult, onLoadGridDescrFail, undefined, 4);
	}

	//Функция обратного вызова для получения описания грида
	function onLoadGridDescrResult(resultXml) {
		//Снимаем курсор ожидания
		BlockingUtil.ready();
		//BlockingUtil.unblockApplication();
		if (resultXml) {
			var er = HTTPServiceUtil.getError(resultXml);
			if (er != "")
				App.errorReport(gis_gridwidget_3, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_1'});
			else {
				if ($('#' + widgetElementId).length > 0) {
					//Получаем из описания грида необходимые нам переменные и структуру грида
					parseGridDescription(resultXml);
				} else {
					//Иначе это означает, что мы уже закрыли грид до того как пришло его описание
				}
			}
		}
	}

	//Функция обратного вызова для получения описания грида
	function onLoadGridDescrFail(resultXml) {
		//Снимаем курсор ожидания
		BlockingUtil.ready();
		//BlockingUtil.unblockApplication();
		App.errorReport(gis_gridwidget_3, resultXml.toString(), undefined, {filename:gis_filename_243, functionname:'gis_filename_243_2'});
	}

	// Вызов всех необходимых для виджета грида функций
	function callWidgetGridFunctions(layerId) {
		try {
			/*Получаем список фильтров для подстановки в запрос данных
			 Если параметр в массиве params один и это layer - это первоначальный запрос на передачу в грид данных фильтрации,
			 Иначе это вызов из грида фильтрации на карте*/
			var layerObj = {name: 'layer', value: layerId};
			var params = [layerObj];
			//Сохраняем функцию для приема ответа в App.callbackFilter (таким образом получим результат в текущий грид)
			ExternalInteraction.callbackFilter = callbackFilterFnc;
			// Теперь вызываем функцию для начала получения фильтра из виджета карты
			var filterRes = callbackFunction(widgetElementId, 'callbackFilter', params); //ExternalInteraction.callbackFunction(widgetElementId, 'callbackFilter', params);//
			if (filterRes === 0) {
				App.errorReport(gis_gridwidget_5, filterRes, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_3'});
			}
		}
		catch (e) { // Вызов функции не сработал
			App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_4'});
		}
	}

	// Функция обратного вызова для получения результата фильтра верхнего уровня.
	// Называется тоже callbackFilter, 2 параметра - params (массив) и winId (строка).
	function callbackFilterFnc(params) {
		try {
			for (var j = 0; j < params.length; j++) {
				var curParam = params[j];
				if (!curParam.hasOwnProperty('name')) continue;

				var newFilters = [];
				var curFilters;
				switch (curParam['name']) {
					case 'filter':
					case 'roughFilter':
						curFilters = curParam['value'].split('|');
						for (var i = 0; i < curFilters.length; i++) {
							var nameValArr = curFilters[i].split(':');
							if (nameValArr && nameValArr.length >= 2) {
								//для кадастровых районов вида "1:23:23.."
								var nameVal = nameValArr[0];
								nameValArr.splice(0,1);
								var newFilterObj = { name: nameVal, value: nameValArr.join(':') };
								newFilters.push(newFilterObj);
							}
						}

						if (curParam['name'] == 'filter') {
							//Переписываем массив фильтров верхнего уровня, из которых формируются запросы
							filters = newFilters;
							that.filters = newFilters;
						}
						else if (curParam['name'] == 'roughFilter') {
							//Переписываем массив фильтров среднего уровня, из которых формируются запросы
							roughFilters = newFilters;
						}
						break;
				}
			}
		}
		catch (e) { // Вызов функции не сработал
			App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_5'});
		}

		//объединяем верхние фильтры с фильтрами, которые пришли в грид извне
		for(var item in that.filter){
			filters.push({name:item, value: that.filter[item]});
			that.filters.push({name:item, value: that.filter[item]});
		}
	}

	//Парсинг пришедшего описания грида (колонки, запросы и т.д.)
	function parseGridDescription(gridDescription) {
		try {
			if (gridDescription !== undefined && gridDescription !== null) {
				//Получаем описание грида в виде структуры (берем корневой элемент, т.е. grids:Grid)
				//var gridDescriptionXml = ($.parseXML(gridDescription)).firstChild;
				var gridDescriptionXml = $($.parseXML(gridDescription)).find('grids\\:Grid:first-child');//($.parseXML(gridDescription)).firstChild;
				//Создаем пока что пустой грид по его описанию
				createGrid(gridDescriptionXml[0], gridTitle);
			}
		}
		catch (e) { // Распарсить XML не удалось
			App.errorReport(gis_gridwidget_4, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_6'});
		}
	}

	//Установка/снятие доступности групповых кнопок грида в зависимости от атрибута "isenabled" кнопки и выбранных записей
	function setEnableToGroupButtons() {
		try {
			//Получаем количество выделенных в гриде рядов
			var rowindexes = $("#" + jqxGridId).jqxGrid('getselectedrowindexes'); //Если length==0, то не выбран ни 1 ряд
			var isSelected = rowindexes && rowindexes.length > 0;
			//Получаем список групповых кнопок грида
			var groupButtons = $('#gridButtons' + jqxGridId)[0].childNodes;
			for (var i = 0; i < groupButtons.length; i++) {
				var curGroupBtn = groupButtons[i];
				for (var j = 0; j < curGroupBtn.attributes.length; j++) {
					var curAttribute = curGroupBtn.attributes[j];
					if (curAttribute.nodeName=="isenabled") {
						//Обрабатываем атибут доступности согласно выделению в гриде (если == "length" - то доступна если выделен хотя бы 1 объект, иначе всегда доступна)
						if (curAttribute.nodeValue=="false") {
							$(curGroupBtn).jqxButton({ disabled: !isSelected});
						} //Если же кнопка всегда доступна - ничего не делаем, поскольку доступность кнопок меняться не будет
						break;
					}
				}
			}
		} catch (e) {
			//Ничего не делаем
		}
	}

	/* Создание грида по полученному описанию грида */
	function createGrid(gridDescriptionXml, gridTitle) {
		that.gridDescriptionXml = gridDescriptionXml;
		//объект, в который сохраняем описание грида
		var currentGridDescr = {};
		//Получаем id слоя для грида (нужен для получения фильтров)
		var layerId = gridDescriptionXml.getAttribute('layerId');
		layerId = that.setLayerId(layerId);
		//Вызываем функции, необходимые для заполнения переменных виджета
		callWidgetGridFunctions(layerId);
		var i = 0;
		//Менеджер фильтров - хранит загруженные справочники для отображения в гриде и фильтрации
		var gridFilterManager = new FilterManager();
		//промежуточные результаты фильтра, чтобы могли работать с данными, пока загружаются данные
		var filterDataCntPureResponse = undefined;
		var filterDataPureResponse = undefined;
		//Получаем запрос данных для грида
		var dataRequest = gridDescriptionXml.getAttribute('dataRequest');
		if(that.filterMap){
			GridUtil.centerOnMap(layerId, that.parentRoughFilter, dataRequest);
			that.filterMap = false;
		}
		//Флаг редактирования грида
		var isGridEditable = gridDescriptionXml.getAttribute('editable');
		//Начальная сортировака колонок
		var initialSortField = gridDescriptionXml.getAttribute('initialSortField');
		//Количество фиксированных колонок
		var lockedColumnCount = gridDescriptionXml.getAttribute('lockedColumnCount');
		//высота колонки
		var columnVertSize = gridDescriptionXml.getAttribute('headerVertSize');
		//заголовок таблицы около нумерации
		var titleGridColumn = gridDescriptionXml.getAttribute('labelColumn');
		//перечень колонок, которые необходимо скрывать, если "проваливаемся" в дочерний грид
		var hideColumnWhenLabel = gridDescriptionXml.getAttribute('hideColumnWhenLabel');
		//первичный ключ для использования в механизме копипасты
		var primaryKeyField = gridDescriptionXml.getAttribute('primaryKeyField') || 'ID';
		that.primaryKeyField = primaryKeyField;
		var foreignKeyField = gridDescriptionXml.getAttribute('foreignKeyField') || '';
		that.foreignKeyField = (foreignKeyField) ? foreignKeyField.split(','): [];
		//количество записей на страницу
		var pageSize = gridDescriptionXml.getAttribute('pageSize');
		var pageSizeOptions =  [25, 50, 100, 500, 1000, 5000];
		if(pageSize === null || pageSize === ''){
			pageSize = 100;
		}
		else{
			pageSize = parseInt(pageSize);
			//если pageSize нет в массиве pageSizeOptions, то помещаем его в него на соответствующее место
			if(pageSizeOptions.indexOf(pageSize) === -1){
				var inserted = false;
				for(var p = 0; p < pageSizeOptions.length; p++){
					if(pageSize < pageSizeOptions[p]){
						pageSizeOptions.splice( p, 0, pageSize );
						inserted = true;
						break;
					}
				}
				if(!inserted)
					pageSizeOptions.push(pageSize);
			}
		}

		//Дополнительный запрос для экспорта в Excel - если есть, используем его для группового экспорта
		var excelDataRequest = gridDescriptionXml.getAttribute('excelDataRequest');
		if (excelDataRequest==undefined || excelDataRequest==null || excelDataRequest=='') excelDataRequest = dataRequest;
		//Дополнительное ограничение числа записей для экспорта в Excel - если есть, используем его вместо ограничения из конфига
		var excelMaxExport = gridDescriptionXml.getAttribute('excelMaxExport');
		//колонки грида
		var gridColumns = [];

		//Колонки с маппингом данных (для dataAdapter)
		var dataFields = [];
		//Получаем описание групповых кнопок грида
		var descrGroupButtons = gridDescriptionXml.getElementsByTagName("picPutton:GridButton");
		if (descrGroupButtons.length == 0) {
			descrGroupButtons = gridDescriptionXml.getElementsByTagName("GridButton");
		}
		//Получаем все имеющиеся описания колонок
		var descrColumns = gridDescriptionXml.getElementsByTagName("columns:GridColumn");
		if (descrColumns.length == 0) {
			descrColumns = gridDescriptionXml.getElementsByTagName("GridColumn");
		}
		//рендерер выбора грида
		var listChooserRenderer = function listChooserRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
				//В данном случае используем columnfield для определения номера колонки, которая рендерится
				if (columnfield < columns.length && columns[columnfield].colItemRendererParams) {
					var listRendererParams = columns[columnfield].colItemListRendererParams;
					var rendererParams = columns[columnfield]['colItemRendererParams'];
					var paramsObj = {
						path: '', eventname: '', tooltip: '', request: '', task: '', layerid: '', gridid: '', templatename: '',
						ext_data_id: '', opennewwnd: 'false', width: '', height: '', syncmap: '', paneltitle: '',
						classname:'',
						columns:'',/*перечень колонок, которые будут использоваться в качестве верхнего фильтра при открытиии нового грида */
						filter:'',/*фильтр для "проваливания в дочерний грид"*/
					}; //Объект для доступа к параметрам рендерера по их имени
					for (var k = 0; k < rendererParams.length; k++) {
						var paramName = rendererParams[k]['name'].toLowerCase(); //Обязательно переводим в нижний регистр!
						var paramValue = rendererParams[k]['value'];
						paramsObj[paramName] = paramValue;
					}
					var imageBtnHtml = '';
					if(paramsObj['text']){
						//Сохраняем в атрибуты кнопки все необходимые значения (path, eventName, toolTip, layerId, templateName, ext_data_id)
						imageBtnHtml = '<div class="grid-cell-style"><input type="submit" onClick="GridWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')" '
							+' style="padding: 0;'+'" class="'+paramsObj["classname"]+'" descrcolumns="'+paramsObj["columns"]+'"  value="'+paramsObj["text"]+'" title="'+paramsObj["tooltip"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" syncmap="'+paramsObj["syncmap"]+'" task="'+paramsObj["task"]+'" opennewwnd="'+paramsObj["opennewwnd"]+'"  paneltitle="'+paramsObj["paneltitle"]+'" openwndwidth="'+paramsObj["width"]+'" openwndheight="'
							+paramsObj["height"]+'" gridid="'+paramsObj["gridid"]+'"  layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'" request="'+paramsObj["request"]+'" '
							+' ext_data_id="'+paramsObj["ext_data_id"]+'"  listrendererparams="'+listRendererParams+'"  filterparams="'+paramsObj["filterparams"]+'" /></div>';
					}
					else{
						imageBtnHtml = '<div class="grid-cell-style"><input type="submit" onClick="GridWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')"  class="gridButton" '
							+' style="padding: 0;'+" background-image: url('./"+paramsObj["path"]+"');"+'"  descrcolumns="'+paramsObj["columns"]+'"  value=" " title="'+paramsObj["tooltip"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" syncmap="'+paramsObj["syncmap"]+'" task="'+paramsObj["task"]+'" opennewwnd="'+paramsObj["opennewwnd"]+'"  paneltitle="'+paramsObj["paneltitle"]+'" openwndwidth="'+paramsObj["width"]+'" openwndheight="'
							+paramsObj["height"]+'" gridid="'+paramsObj["gridid"]+'"  layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'" request="'+paramsObj["request"]+'" '
							+' ext_data_id="'+paramsObj["ext_data_id"]+'"  listrendererparams="'+listRendererParams+'"  filterparams="'+paramsObj["filterparams"]+'" /></div>';
					}
					return imageBtnHtml;
				}
			} catch (e) {}
			return ''; //не можем отрендерить как картинку
		}
		//Рендерер кнопки-иконки
		var imageRenderer = function imageRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
				//В данном случае используем columnfield для определения номера колонки, которая рендерится
				if (columnfield < columns.length && columns[columnfield].hasOwnProperty('colItemRendererParams')) {
					var rendererParams = columns[columnfield]['colItemRendererParams'];
					var paramsObj = {
						path: '', eventname: '', tooltip: '', request: '', task: '', layerid: '', gridid: '', templatename: '',
						ext_data_id: '', opennewwnd: 'false', width: '', height: '', syncmap: '', paneltitle: '',
						classname:'',
						columns:''/*перечень колонок, которые будут использоваться в качестве верхнего фильтра при открытиии нового грида */,
					}; //Объект для доступа к параметрам рендерера по их имени
					for (var k = 0; k < rendererParams.length; k++) {
						var paramName = rendererParams[k]['name'].toLowerCase(); //Обязательно переводим в нижний регистр!
						var paramValue = rendererParams[k]['value'];
						paramsObj[paramName] = paramValue;
					}
					if(!paramsObj["paneltitle"])
						paramsObj["paneltitle"] = '';
					var imageBtnHtml = '';
					if(paramsObj['text']){
						//Сохраняем в атрибуты кнопки все необходимые значения (path, eventName, toolTip, layerId, templateName, ext_data_id)
						imageBtnHtml = '<div class="grid-cell-style"><input type="submit" onClick="GridWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')" '
							+' style="padding: 0;'+'" class="'+paramsObj["classname"]+'" descrcolumns="'+paramsObj["columns"]+'"  value="'+paramsObj["text"]+'" title="'+paramsObj["tooltip"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" syncmap="'+paramsObj["syncmap"]+'" task="'+paramsObj["task"]+'" opennewwnd="'+paramsObj["opennewwnd"]+'"  paneltitle="'+paramsObj["paneltitle"]+'" openwndwidth="'+paramsObj["width"]+'" openwndheight="'
							+paramsObj["height"]+'" gridid="'+paramsObj["gridid"]+'"  layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'" request="'+paramsObj["request"]+'" '
							+' ext_data_id="'+paramsObj["ext_data_id"]+'"/></div>';
					}
					else{
						//Сохраняем в атрибуты кнопки все необходимые значения (path, eventName, toolTip, layerId, templateName, ext_data_id)
						imageBtnHtml = '<div class="grid-cell-style"><input type="submit" onClick="GridWidget.prototype.imageButtonClick(event,'+jqxGridId+','+row+',\''+gridTitle+'\')" class="gridButton"'
							+' style="padding: 0;'+" background-image: url('./"+paramsObj["path"]+"');"+'" value=" " title="'+paramsObj["tooltip"]+'"'
							+' id="btn_'+jqxGridId+'_'+columnfield+'_'+row+'" eventname="'+paramsObj["eventname"]+'" syncmap="'+paramsObj["syncmap"]+'" task="'+paramsObj["task"]+'" opennewwnd="'+paramsObj["opennewwnd"]+'"  paneltitle="'+paramsObj["paneltitle"]+'"  openwndwidth="'+paramsObj["width"]+'" openwndheight="'
							+paramsObj["height"]+'"  layerid="'+paramsObj["layerid"]+'" templatename="'+paramsObj["templatename"]+'" data-request="'+paramsObj["request"]+'" request="'+paramsObj["request"]+'"'
							+' ext_data_id="'+paramsObj["ext_data_id"]+'"/></div>';
					}
					return imageBtnHtml;
				}
			} catch (e) {}
			return ''; //не можем отрендерить как картинку
		};

		//Рендерер символьной строки
		var stringRenderer = function stringRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var colorRowColumn = '';
				var colorRow = undefined;
				var noPaddingsHtml = $(defaulthtml);
				noPaddingsHtml.addClass("grid-cell-style");
				var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', row);
				gridItem = GridUtil.getFullRowDataById({id: jqxGridId}, gridItem);
				var selectedColorValidation = {critical: -999999};
				for(var item in that.colorRowValidations){
					if(that.colorRowValidations[item].selected){
						//находим элемент в текущей строке грида
						var gridItemValueNumber = parseFloat(gridItem[item]);
						var gridItemValueString = gridItem[item];
						that.colorRowValidations[item].array.forEach(function (curValue, index, array) {
							if(curValue){
								if(curValue.type === 'string'){
									if(gridItemValueString && gridItemValueString === curValue.min && gridItemValueString === curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
								if(curValue.type === 'number'){
									if(!isNaN(gridItemValueNumber) && gridItemValueNumber >= curValue.min && gridItemValueNumber <= curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
							}
						});
					}
				}
				if(selectedColorValidation.critical !== -999999)
					noPaddingsHtml.css('background', selectedColorValidation.color);
				//22.10.21 доп. проверка для дат из внешних источников, если данные пришли в миллисекундах
				if(columnproperties && columnproperties.columntype === 'date'){
					//upd. 03.11.21 проверка случая в задаче су тс тпа, когда из sqlite проходит значение даты вместо NULL значение 0
					if(value === '0'){
						var resultHtml = noPaddingsHtml[0].outerHTML;
						resultHtml = resultHtml.replace(">"+value+"<", "><");
						return resultHtml;
					}
					if(value && (''+value).length > 10 && !isNaN(Number(value))){
						var newValue = new Date(Number(value)).format('dd.mm.yyyy');
						var resultHtml = noPaddingsHtml[0].outerHTML;
						resultHtml = resultHtml.replace(">"+value+"<", ">"+newValue+"<");
						return resultHtml;
					}

					/*var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
					//В данном случае используем columnfield для определения номера колонки, которая рендерится
					for(var col = 0; col < columns.length; col++){
						if(columns[col].datafield === columnfield && columns[col].colItemRendererParams && columns[col].colItemRendererParams.length > 0){
							for(var colI = 0; colI < columns[col].colItemRendererParams.length; colI ++){
								if(columns[col].colItemRendererParams[colI].name === 'dateFormat' && columns[col].colItemRendererParams[colI].value === 'bigint'){

								}
							}
						}
					}*/
				}
				//17.02.20 Добавлено условие для дат, т.к. нет отдельного обработчика DateRenderer
				//если есть текст "T00:00:00" - отбрасываем правую часть
				//Возвращаем элемент с нужными стилями
				var returnStr = noPaddingsHtml[0].outerHTML;
				if(value && value.indexOf("T00:00:00") !== -1)
					returnStr = returnStr.replace(value.substring(value.indexOf("T00:00:00")),'');
				return returnStr;
			} catch (e) {}
			return ''; //не можем отрендерить
		};

		//Рендерер чисел с округлением до числа знаков после запятой, указанного в параметре buffer рендерера (2 по дефолту)
		var numberRenderer = function numberRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var noPaddingsHtml = $(defaulthtml);
				noPaddingsHtml.addClass("grid-cell-style");
				//Возвращаем элемент с нужными стилями
				var resultHtml = undefined;
				var newValue = value;
				if(newValue && newValue.indexOf(',') !== -1)
					newValue = newValue.replace(',','.');
				var numberVal = parseFloat(newValue);
				var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', row);
				gridItem = GridUtil.getFullRowDataById({id: jqxGridId}, gridItem);
				var selectedColorValidation = {critical: -999999};
				for(var item in that.colorRowValidations){
					if(that.colorRowValidations[item].selected){
						//находим элемент в текущей строке грида
						var gridItemValueNumber = parseFloat(gridItem[item]);
						var gridItemValueString = gridItem[item];
						that.colorRowValidations[item].array.forEach(function (curValue, index, array) {
							if(curValue){
								if(curValue.type === 'string'){
									if(gridItemValueString && gridItemValueString === curValue.min && gridItemValueString === curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
								if(curValue.type === 'number'){
									if(!isNaN(gridItemValueNumber) && gridItemValueNumber >= curValue.min && gridItemValueNumber <= curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
							}
						});
					}
				}
				if(selectedColorValidation.critical !== -999999)
					noPaddingsHtml.css('background', selectedColorValidation.color);
				if (!isNaN(numberVal)) {
					//Обрезаем число до 6 знаков после запятой (если в рендерере не указан format=<число>)
					var numPrecision = 6;
					var indexColumn;
					//В данном случае используем columnfield для определения номера колонки, которая рендерится
					for(var i=0; i<gridDescription.columns.length; ++i){
						if(gridDescription.columns[i]['datafield'] === columnfield){
							indexColumn = i;
							break;
						}
					}
					if (gridDescription.columns[indexColumn].hasOwnProperty('colItemRendererParams')) {
						for(var i=0; i<gridDescription.columns[indexColumn]['colItemRendererParams'].length; ++i) {
							var rendererParams = gridDescription.columns[indexColumn]['colItemRendererParams'][i];
							if (rendererParams && rendererParams.hasOwnProperty('name') && (rendererParams['name'] === 'format') && rendererParams.hasOwnProperty('value') && !isNaN(parseInt(rendererParams['value']))){
								numPrecision = parseInt(rendererParams['value']);
							}
						}
					}
					var numVal = parseFloat(numberVal.toFixed(numPrecision));
					var numValStr = (isNaN(numVal))?'':numVal.toString();
					numValStr = numValStr.replace(/\.00$/,"");
					resultHtml = noPaddingsHtml[0].outerHTML;
					resultHtml = resultHtml.replace(">"+value+"<", ">"+numValStr+"<");
					//value = numValStr;
					return resultHtml;
				}
				resultHtml = noPaddingsHtml[0].outerHTML;
				//Возвращаем элемент с нужными стилями
				return resultHtml;
			} catch (e) {}
			return ''; //не можем отрендерить
		};

		var booleanRenderer = function booleanRenderer(row, columnfield, value, defaulthtml, columnproperties) {
			try {
				var noPaddingsHtml = $(defaulthtml);
				noPaddingsHtml.addClass("grid-cell-style");
				//Возвращаем элемент с нужными стилями
				var resultHtml = undefined;
				var booleanVal = (value === '0')? gis_core_5: gis_core_4;
				resultHtml = noPaddingsHtml[0].outerHTML;
				resultHtml = resultHtml.replace(">"+value+"<", ">"+booleanVal+"<");
				return resultHtml;
			} catch (e) {}
			return ''; //не можем отрендерить
		};

		//Добавляем особый рендерер, который будет забирать из FilterManager нужное значение для отображения
		var filterCellRenderer = function filterCellRenderer(index, datafield, value, defaulthtml, column, rowdata) {
			try {
				var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
				var noPaddingsHtml = $(defaulthtml);
				noPaddingsHtml.addClass("grid-cell-style");
				var filterData = [];
				var curFilterRequestiId;
				for (i = 0; i < columns.length; i++) {
					var curCol = columns[i];
					if (curCol.datafield == datafield) {
						curFilterRequestiId = curCol.filterrequestid;
						filterData = gridFilterManager.getArrayData(curCol.filterrequestid);
						break;
					}
				}

				var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', index);
				gridItem = GridUtil.getFullRowDataById({id: jqxGridId}, gridItem);
				var selectedColorValidation = {critical: -999999};
				for(var item in that.colorRowValidations){
					if(that.colorRowValidations[item].selected){
						//находим элемент в текущей строке грида
						var gridItemValueNumber = parseFloat(gridItem[item]);
						var gridItemValueString = gridItem[item];
						that.colorRowValidations[item].array.forEach(function (curValue, index, array) {
							if(curValue){
								if(curValue.type === 'string'){
									if(gridItemValueString && gridItemValueString === curValue.min && gridItemValueString === curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
								if(curValue.type === 'number'){
									if(!isNaN(gridItemValueNumber) && gridItemValueNumber >= curValue.min && gridItemValueNumber <= curValue.max){
										//устанавливаем объект с самой высокой критичностью
										if(curValue.critical > selectedColorValidation.critical)
											selectedColorValidation = curValue;
									}
								}
							}
						});
					}
				}
				if(selectedColorValidation.critical !== -999999)
					noPaddingsHtml.css('background', selectedColorValidation.color);
				defaulthtml = noPaddingsHtml[0].outerHTML;
				var curDescr = gridFilterManager.EMPTY_NAME;
				//Ищем в полученном справочнике текущее значение и забираем его описание
				if (filterData!=null && filterData.hasOwnProperty('codehash') && filterData.codehash[value]!=undefined && filterData.codehash[value]!=null) {
					curDescr = filterData.codehash[value];
				} else {
					/*if(filterData == 'loading') {
						var guidErrorDict = 'cell_guid_'+App.generateUUID();
						console.log(guidErrorDict)
						defaulthtml = defaulthtml.replace('class="grid-cell-style"', 'class="grid-cell-style ' + guidErrorDict + '"');
						return defaulthtml.replace(">" + value + "<", "><");
					}*/
					if(value == '')
						curDescr = value;
					else{
						//Иначе однократно сообщаем, что такого значения в справочнике нет
						if (that.notFoundCodeHash==undefined || !that.notFoundCodeHash.hasOwnProperty(datafield) || !that.notFoundCodeHash[datafield].hasOwnProperty(value)) {
							if (that.notFoundCodeHash==undefined) that.notFoundCodeHash = {};
							if (!that.notFoundCodeHash.hasOwnProperty(datafield)) that.notFoundCodeHash[datafield] = {};
							that.notFoundCodeHash[datafield][value] = value;
							//Показываем однократное сообщение об ошибке, что для этого значения не найдено значение справочника
							if(WidgetMap !== undefined && WidgetMap.getShowErrorInGridDictationary() == false){}//если выставлен флаг, то не показываем сообения
							else{
								var guidErrorDict = 'cell_guid_'+App.generateUUID();
								//console.log(guidErrorDict)
								defaulthtml = defaulthtml.replace('class="grid-cell-style"', 'class="grid-cell-style ' + guidErrorDict + '"');
								var confirm = App.infoDialog(gis_gridwidget_142, guidErrorDict);
								gridFilterManager.reloadDictationary(curCol.filterrequestid, function(arr){
									filterData = gridFilterManager.getArrayData(curCol.filterrequestid);
									if(filterData && filterData.codehash && filterData.codehash[value]!=undefined && filterData.codehash[value]!=null){
										gridElem.jqxGrid('setcellvalue', index, datafield, value);
									}
									App.destroyDialog(guidErrorDict);
								});
							}
						}
					}
				}
				//Заменяем подстроку значения включая > и <, чтобы не заменить где-то кроме самой ячейки
				if(WidgetMap !== undefined && WidgetMap.getShowErrorInGridDictationary() == false && curDescr == gridFilterManager.EMPTY_NAME)
					return defaulthtml.replace(">"+value+"<", ">"+curDescr+":"+value+"<");
				return defaulthtml.replace(">"+value+"<", ">"+curDescr+"<");
			} catch (e) {}
			return ''; //не можем отрендерить
		};

		var filterCount = [];//количество справочников

		for (i = 0; i < descrColumns.length; i++) {
			var curColumn = descrColumns[i];
			//Определяем тип колонки и что именно она будет рендерить по атрибуту itemRenderer
			var listRendererParams = [];
			if (curColumn === undefined || !curColumn || !curColumn.hasAttribute('itemRenderer')){ } //continue;
			else{
				//Обрабатываем атрибут itemRenderer
				var colItemRendererSrc = curColumn.getAttribute('itemRenderer');

				var colItemRendererArr = colItemRendererSrc.split('?'); //В строке itemRenderer тип рендерера отделяется от параметров символом '?';
				var colItemRendererType = 'ru.corelight.view.renderer.StringRenderer'; //по-умолчанию - обычная строка
				var colItemRendererParams = []; //по-умолчанию параметров у рендерера нет
				if (colItemRendererArr && colItemRendererArr.length > 0) {
					//Сохраняем тип рендерера колонки
					colItemRendererType = colItemRendererArr[0];
					//Если у рендерера есть параметры - парсим их в массив параметров colItemRendererParams
					if (colItemRendererArr.length > 1) {
						var paramsArr = colItemRendererArr[1].split(';'); // параметры всегда содержатся во 2 элементе массива и разделяются символом ';'
						for (var j = 0; j < paramsArr.length; j++) {
							var nameValArr = paramsArr[j].split('='); //имя параметра отделяется от его значения символом '='
							if (nameValArr.length > 1) {
								var paramObj = {name: nameValArr[0], value: nameValArr[1]};
								colItemRendererParams.push(paramObj);
							}
						}
					}
					if(colItemRendererType === 'ru.corelight.view.renderer.ImageListRenderer'){
						for (var atr=0; atr<curColumn.attributes.length; atr++) {
							if(curColumn.attributes[atr].name.indexOf('rendererParams') !== -1)
								listRendererParams.push(curColumn.attributes[atr].value);
							if(curColumn.attributes[atr].name === 'filter'){
								//прокидываем параметр filter
								colItemRendererParams.push({name: 'filterparams', value: curColumn.attributes[atr].value});
							}
						}

					}
				}
			}
			//Получаем из атрибутов параметры для маппинга и описания очередной колонки грида
			//В dataField для колонок, которые являются кнопками, сохраняем порядковый номер колонки, иначе просто сохраняем dataField
			var colDataField = curColumn.hasAttribute('dataField') ? curColumn.getAttribute('dataField') : i; //dataField ОБЯЗАТЕЛЬНО должно быть уникальным !
			var colDataFieldSynonym = curColumn.hasAttribute('dataFieldSynonym') ? curColumn.getAttribute('dataFieldSynonym') : undefined; //dataField ОБЯЗАТЕЛЬНО должно быть уникальным !
			var colHeaderText = curColumn.hasAttribute('headerText') ? curColumn.getAttribute('headerText') : '';
			var colWidth = curColumn.hasAttribute('width') ? curColumn.getAttribute('width') : 0; //Если ширина не указана то дефолтная будет = 0
			var colEditable = curColumn.hasAttribute('editable') && curColumn.getAttribute('editable') === 'true'; //Если ширина не указана то дефолтная будет = 0

			//проверяем наличие условий расцветки ячеек
			var colorValidations = curColumn.getElementsByTagName("colorValidation");
			if(colorValidations !== undefined && colorValidations.length > 0 ) {
				that.colorValidations[colDataField] = {selected: false, descr: colHeaderText, array:[]};
				that.colorRowValidations[colDataField] = {selected: false, descr: colHeaderText, array:[]};
				for (var v = 0; v < colorValidations.length; v++) {
					var cvItem = colorValidations[v];
					var cvMin = cvItem.getAttribute('min');
					var cvMax = cvItem.getAttribute('max');
					var cvColor = cvItem.getAttribute('color');
					var cvPreload = cvItem.getAttribute('preload') === 'true';
					var cvCriticalLevel = parseInt(cvItem.getAttribute('critical'));
					var cvMode = cvItem.getAttribute('mode') === 'row' ? 'row' : 'cell';
					var cvType = cvItem.getAttribute('type') === 'string' ? 'string' : 'number';
					if (cvMin !== null && cvMax !== null && cvColor !== '') {
						if(cvType === 'number'){
							cvMin = (cvMin === '-infinity') ? Number.NEGATIVE_INFINITY : parseFloat(cvMin);
							cvMax = (cvMax === 'infinity') ? Number.POSITIVE_INFINITY : parseFloat(cvMax);
						}
					}
					var colObj = {
						mode: cvMode,
						min: cvMin,
						max: cvMax,
						type: cvType,
						color: '#' + cvColor,
						critical: cvCriticalLevel,
						preload: cvPreload
					};
					if(cvMode === 'cell') {
						that.colorValidations[colDataField].array.push(colObj);
						if(cvPreload)
							that.colorValidations[colDataField].selected = true;
					}
					else{
						that.colorRowValidations[colDataField].array.push(colObj);
						if(cvPreload)
							that.colorRowValidations[colDataField].selected = true;
					}
				}
			}

			//Отдельные атрибуты для фильтрации
			var colFilterRequestId = curColumn.hasAttribute('filterRequestId') ? curColumn.getAttribute('filterRequestId') : undefined; //Запрос справочника значений
			var colFilterComparisionType = curColumn.hasAttribute('filterComparisionType') ? curColumn.getAttribute('filterComparisionType') : undefined; //Тип фильтра
			//TODO костыль. Обработка случая фильтра с большим количеством записей(распределители)
			var colFilterInfinite = curColumn.hasAttribute('infinite') ? curColumn.getAttribute('infinite') === 'true' : false; //
			var colSortField = curColumn.hasAttribute('sortField') ? curColumn.getAttribute('sortField') : undefined; //Поле для сортировки справочника
			var colSortable = colFilterComparisionType !== undefined;

			//Скрытая ли колонка
			var colHidden = curColumn.hasAttribute('hidden') ? curColumn.getAttribute('hidden') === 'true' : false; //Запрос справочника значений
			// флаг, что грид показывается весь. Если показываем шапку - значит можно скрывать колонку(если она описана в )
			if(!that.ignoreLabelColumn){
				if(hideColumnWhenLabel && hideColumnWhenLabel.split(',').indexOf(colDataField) !== -1)
					colHidden = true;
			}
			//Маппинг - для маппинга xml-атрибута заключаем в квадратные скобки, для массива - не нужно
			/*var colMapping = '['+curColumn.getAttribute('dataField')+']';*/
			var colMapping = curColumn.hasAttribute('dataField') ? curColumn.getAttribute('dataField') : i;
			//Пока что все считаем строкой, в будущем нужно определять тип колонки по itemRenderer или по filterComparisionType
			var colType = 'string';

			//pinned - зафиксированная колонка или нет
			var colIsPinned = i < lockedColumnCount-1;

			var columnrenderer = function(value, align, columnsheight) {
				var splitted = value.split('\\n');
				var newVal = splitted.join('<br/>');

				return '<div style="text-align: left; margin-top: 2px;">' + newVal + '</div>';
			};
			//Объект с описанием колонки
			var columnObj = {text: colHeaderText,
				editable: colEditable,
				datafield: colDataField, width: colWidth, minwidth: 0, pinned: colIsPinned, hidden: colHidden,
				filterrequestid: colFilterRequestId, filtercomparisiontype: colFilterComparisionType, filterinfinite: colFilterInfinite,
				sortfield: colSortField, sortable: colSortable,
			};
			//Дефолтный рендерер - убираем избыточные отступы и выдаем просто текст
			columnObj['cellsrenderer'] = stringRenderer;
			columnObj['columntype'] = 'string';
			if(colDataFieldSynonym)
				columnObj['datafieldsynonym'] = colDataFieldSynonym;

			//Если тип рендерера - 'ru.corelight.view.renderer.NumberRenderer', меняем на численный с точностью (параметр format, 2 знака после запятой по дефолту)
			if (colItemRendererType==='ru.corelight.view.renderer.NumberRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['cellsrenderer'] = numberRenderer;
				columnObj['columntype'] = 'stringnumber';
			}
			if (colItemRendererType==='ru.corelight.view.renderer.BooleanRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['cellsrenderer'] = booleanRenderer;
				columnObj['columntype'] = 'boolean';
			}
			if (colItemRendererType==='ru.corelight.view.renderer.StringRenderer' || colItemRendererType.indexOf('StringRenderer') !== -1) {
				if(colDataField === 'RWN')
					columnObj['editable'] = false;
			}
			// тип рендерера - для показа окна с выбором списков, в которые погружаемся
			if (colItemRendererType==='ru.corelight.view.renderer.ImageListRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['colItemListRendererParams'] = listRendererParams.join('|');// добавляем самостоятельные параметры
				if (columnObj['width'] < 25) {
					columnObj['width'] = 25;
				}
				columnObj['cellsrenderer'] = listChooserRenderer;
				columnObj['editable'] = false;
				columnObj['columntype'] = 'image';
			}
			//Если тип рендерера = 'ru.corelight.view.renderer.ImageRenderer', добавляем рендерер для колонки с кнопкой
			if (colItemRendererType==='ru.corelight.view.renderer.ImageRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				if (columnObj['width'] < 25) {
					columnObj['width'] = 25;
				}
				columnObj['cellsrenderer'] = imageRenderer;
				columnObj['editable'] = false;
				columnObj['columntype'] = 'image';
			}
			//Если тип рендерера - 'ru.corelight.view.renderer.DateRenderer', убираем возможность редактирования этой колонки
			if (colItemRendererType==='ru.corelight.view.renderer.DateRenderer') {
				columnObj['colItemRendererParams'] = colItemRendererParams;
				columnObj['columntype'] = 'date';
				//Тип даты(либо в миллисекунда, либо текстовое представление)
				var colDateFormat = curColumn.hasAttribute('dateFormat') ? curColumn.getAttribute('dateFormat') : 'text';
				columnObj['dateformat'] = colDateFormat;
			}
			//Объект маппинга данных
			var dataFieldObj = {name: colDataField, map: colMapping, type: colType};
			if(colDataFieldSynonym)
				dataFieldObj['synonym'] = colDataFieldSynonym;

			//Если есть свойство filterRequestId - добавляем displayfield и запрашиваем значения справочника (они должны быть доступны, когда грид загрузится)
			if (colFilterRequestId !== undefined) {
				//Добавляем особый рендерер, который будет забирать из FilterManager нужное значение для отображения
				columnObj['cellsrenderer'] = filterCellRenderer;
				columnObj['columntype'] = 'filter';
				//Сразу при создании колонки запрашиваем данные справочника
				//var curFilterData = gridFilterManager.getArrayData(colFilterRequestId);
				if(filterCount.indexOf(colFilterRequestId)==-1)
					filterCount.push(colFilterRequestId);
			}

			columnObj['renderer'] = columnrenderer;
			//Добавляем колонку
			that.columns.push(columnObj);
			/*if(columnObj.hidden === true && columnObj.datafield !== 'ID')
				continue;*/
			gridColumns.push(columnObj);
			//Добавляем поля данных (маппинг)
			dataFields.push(dataFieldObj);
		}
		loadingFilterCount = filterCount.length;
		for(var a in filterCount){
			gridFilterManager.getArrayData(filterCount[a], onFilterLoadedCallback);
		}

		//Функция формирует строку сортировки из массива
		var getSortStringFromArr = function getSortStringFromArr(sortArr) {
			var sortStr = "";
			var columns = (that.columns && that.columns.length > 0) ? that.columns : gridDescription.columns//gridDescription.columns;
			if (sortArr && sortArr!==undefined && sortArr.length>0) {
				var tmpSortArr = [];
				for (var i = 0; i < sortArr.length; i++) {
					var sortinformation = sortArr[i];
					//Теперь если мы добавляем сортировку и этот элемент уже был - меняем его (или убираем если сортировка отменена), иначе просто добавляем
					if (sortinformation.sortdirection.ascending || sortinformation.sortdirection.descending) {
						for (var j = 0; j < currentGridDescr.gridColumns.length; j++) {
							//Ищем среди колонок ту, по которой сортируем и забираем значение из ее свойства sortfield
							//Если такого свойста у колонки нет, сортируем по datafield
							var curGridCol = currentGridDescr.gridColumns[j];
							if (curGridCol.hasOwnProperty('datafield') && curGridCol.datafield==sortinformation.sortcolumn) {
								var tmpSortStr = curGridCol.hasOwnProperty('sortfield') && curGridCol.sortfield!=undefined ? curGridCol.sortfield : curGridCol.datafield;
								if (sortinformation.sortdirection.descending)
									tmpSortStr += " DESC";
								tmpSortArr.push(tmpSortStr);
							}
						}
					}
				}
				//Собираем получившийся массив в строку, разделенную запятой
				sortStr = tmpSortArr.join(",");
			}
			else{//иначе проходим по колонкам в gridDescription, ищем соответствующие initialSortField поля сортировки
				if(columns != undefined){
					if(initialSortField!=null){
						var i=0;
						var sortArr = [];
						var isf = initialSortField.split(',');

						for(i; i<isf.length;i++){
							var j=0;
							var found = false;
							for(j; j<columns.length;j++){
								if(isf[i] == columns[j].datafield && columns[j].sortfield!=undefined && columns[j].sortfield!=''){
									sortArr.push(columns[j].sortfield);
									found = true;
									break;
								}
							}
							if(!found)
								sortArr.push(isf[i]);
						}
						sortStr = sortArr.join(',');
					}
				}
			}
			//по-умолчанию возвращаем первоначальный порядок сортировки
			if (sortStr=="") sortStr = initialSortField;
			return sortStr;
		};
		//Описание групповых кнопок в тулбаре
		var gridToolbarGroupButtons = [];
		//Сохраняем описание грида
		currentGridDescr = {
			layerId: layerId,
			colorRowValidations: that.colorRowValidations,
			colorValidations: that.colorValidations,
			colorRowSelectType: 0,
			maxCriticalColor: undefined,
			minCriticalColor: undefined,//тип выделения ячеек после цветового анализа
			dataRequest: dataRequest,
			initialSortField: initialSortField,
			gridColumns: gridColumns,
			dataFields: dataFields,
			descrGroupButtons: descrGroupButtons,
			layerManager: layerManagerInst,
			gridFilterManager: gridFilterManager,
			topFilter: that.filters,
			roughFilter: roughFilters,
			currentFilter: [],
			currentSort: [],
			selecting: false,
			centering: false,
			propPanelWidth: 800,
			propPanelHeight: 280,
			excelDataRequest: excelDataRequest,
			excelMaxExport: excelMaxExport
		};
		GlobalGridDescr[jqxGridId] = currentGridDescr;
		for (i = 0; i < descrGroupButtons.length; i++) {
			var curButton = descrGroupButtons[i];
			//Получаем из атрибутов параметры для описания очередной групповой кнопки грида
			//В исходных путях присутствует ненужное указание выхода на директорию из поддиректории '../../' - убираем его (путь формируем от корня сайта)
			var btnSource = curButton.hasAttribute('source') ? curButton.getAttribute('source').replace('../../','') : '';
			var btnTooltip = curButton.hasAttribute('tooltip') ? curButton.getAttribute('tooltip') : '';
			var btnClickEvent = curButton.hasAttribute('clickEvent') ? curButton.getAttribute('clickEvent') : '';
			//Параметр isEnabled принимает значения: 'true' или 'null' - всегда доступна, иначе (в т.ч. если нет этого параметра) - доступна если выбрана хотя бы 1 запись
			var btnIsEnabled = curButton.hasAttribute('isEnabled') && (curButton.getAttribute('isEnabled')=='true' || curButton.getAttribute('isEnabled')=='null');
			var btnDisabled = !btnIsEnabled; //По-умолчанию недоступными будут кнопки, доступность которых регулируется выбором записей грида
			var btnSelectedObjects = curButton.hasAttribute('selectedObjects') ? curButton.getAttribute('selectedObjects') : ''; //Не нужно - доступность групповых кнопок регулируется только через isEnabled
			var btnPosition = curButton.hasAttribute('position') ? curButton.getAttribute('position') : 'left'; //Позиция кнопки - в левой панели ('left') или сверху ('top')
			var btnWidth = curButton.hasAttribute('width') ? curButton.getAttribute('width') : '200'; //Ширина кнопки
			var btnHeight = curButton.hasAttribute('height') ? curButton.getAttribute('height') : '27'; //Высота кнопки
			var btnTemplate = curButton.hasAttribute('template') ? curButton.getAttribute('template') : '';
			var btnGridId = curButton.hasAttribute('gridId') ? curButton.getAttribute('gridId') : '';
			var btnSyncMap = curButton.hasAttribute('syncMap') ? curButton.getAttribute('syncMap') : '';
			var btnPanelTitle = curButton.hasAttribute('panelTitle') ? curButton.getAttribute('panelTitle') : '';
			var btnTask = curButton.hasAttribute('task') ? curButton.getAttribute('task') : '';
			var btnOpenNewWnd = curButton.hasAttribute('openNewWnd') ? curButton.getAttribute('openNewWnd') : '';
			var clickEventParams = btnClickEvent.split('?')[1];
			var btnQuery = '';
			if(clickEventParams){
				clickEventParams.split(';').forEach(function(p){
					if(p && p.split('=')[0] === 'request')
						btnQuery = p.split('=')[1]
				});
			}
			btnClickEvent = btnClickEvent.split('?')[0];
			var curButtonHtml = '<input type="submit" onClick="GridWidget.prototype.groupButtonClick(event,'+jqxGridId+')" class="gridGroupButton"'
				+' style="padding: 10px; '+" background-image: url('./"+btnSource+"');"+'" value=" " title="'+btnTooltip+'"'
				+' id="btngroup_'+jqxGridId+'_'+i+'" layerid="'+layerId+'" clickevent="'+btnClickEvent+'"  opennewwnd="'+btnOpenNewWnd+'"  ' +
				'task="'+btnTask+'"  syncmap="'+btnSyncMap+'" paneltitle="'+btnPanelTitle+'" ' +
				'request="'+btnQuery+'"  ' +
				'isenabled="'+btnIsEnabled+'" selectedobjects="'+btnSelectedObjects+'" template="'+btnTemplate+'"  ' +
				'gridid="'+btnGridId+'" />';
			//Добавляем очередную кнопку в панель с групповыми кнопками грида
			if (btnPosition.indexOf('top') !== -1) {
				var btnFloat = (btnPosition.split('|').length > 1 && btnPosition.split('|')[1] === 'right')?' float: right; ':' float: left; ';
				var btnText = curButton.hasAttribute('text') ? curButton.getAttribute('text') : btnTooltip;
				var parentGridId = curButton.hasAttribute('parentGridId') ? curButton.getAttribute('parentGridId') : '';
				if(btnClickEvent === 'showParentGridEvent'){
					if(that.ignoreLabelColumn ){// если самостоятельный грид, то в нем не показываем кнопку "перейни на уровень вверх"
						continue;
					}
				}
				if(btnClickEvent === 'showAllDataEvent'){
					if(that.ignoreLabelColumn ){// если самостоятельный грид, то в нем не показываем кнопку "перейни на уровень вверх"
						continue;
					}
				}

				//Для административных гридов сохраняем кнопки для верхнего тулбара
				var curButtonFullHtml = '<input type="submit" onClick="GridWidget.prototype.groupButtonClick(event,'+jqxGridId+')" class="myButton"'
					+'value="'+btnText+'" title="'+btnTooltip+'" style="display: inline;padding: 0px; '+btnFloat+' white-space: normal;" data-btnwidth="'+btnWidth+'" data-btnheight="'+btnHeight+'"'
					+' id="btngrouptoolbar_'+jqxGridId+'_'+gridToolbarGroupButtons.length+'" request="'+btnQuery+'" layerid="'+layerId+'" opennewwnd="'+btnOpenNewWnd+'"  task="'+btnTask+'" clickevent="'+btnClickEvent+'"  syncmap="'+btnSyncMap+'" isenabled="'+btnIsEnabled+'" selectedobjects="'+btnSelectedObjects+'"' +
					'" gridlayerid="'+gridLayerId+'"  paneltitle="'+btnPanelTitle+'" parentgridid="'+parentGridId+'"/>';
				gridToolbarGroupButtons.push(curButtonFullHtml);
			}
			else {
				$('#gridButtons' + jqxGridId).append(curButtonHtml);
				//Делаем нормальную кнопку, в которую добавляем текущее состояние (доступна или нет изначально)
				$('#btngroup_'+jqxGridId+'_'+i).jqxButton({ theme: 'gis-blueorange', disabled: btnDisabled});
			}
		}
		//Не устанавливаем доступность групповых кнопок, она выставлена правильно при создании кнопок
		/*setEnableToGroupButtons();*/
		//Функция-рендерер тулбара административных гридов
		//TODO перенос из админских панелей
		function admGridRenderToolbar(toolbar) {
			try {
				//Если в тулбаре уже добавлен этот div, 2 раз не добавляем, а также проверяем что кнопки вставляются после постраничности (когда тулбар заполнен чем-то)
				if ($('#btngrouptoolbardiv_'+jqxGridId).length > 0 || toolbar.children().length==0) return;
				var container = $('<div id="btngrouptoolbardiv_'+jqxGridId+'" style="display: inline;margin: 0px; padding-top: 25px;padding-left: 5px; font-size: 14px;"></div>');
				toolbar.append(container);
				for (var ii = 0; ii < gridToolbarGroupButtons.length; ii++) {
					var curGroupBtnInput = gridToolbarGroupButtons[ii];
					container.prepend(curGroupBtnInput);
					var curGroupBtn = $('#btngrouptoolbar_'+jqxGridId+'_'+ii);
					var btnWidth = parseInt(curGroupBtn.attr('data-btnwidth')); //ширина кнопки
					if (btnWidth==undefined || btnWidth==null || isNaN(btnWidth)) btnWidth = 200;
					var btnHeight = parseInt(curGroupBtn.attr('data-btnheight')); //высота кнопки
					if (btnHeight==undefined || btnHeight==null || isNaN(btnHeight)) btnHeight = 27;
					var btnDisabled = false; //curGroupBtn.attr('isenabled')!="true";
					curGroupBtn.jqxButton({ width: btnWidth, height: btnHeight, disabled: btnDisabled});
				}

			} catch (e) {
			}
		}
		//описание грида
		//Сохраняем в gridSource, чтобы подставить в него данные после загрузки
		gridSource = {
			datatype: "text",
			datafields: dataFields,
			formatdata: function (data) {
				//Перед отправкой запроса устанавливаем в него нижний и верхний пределы согласно выбранным границам
				var lowLimit = data.pagenum * data.pagesize + 1;
				var highLimit = (data.pagenum + 1) * data.pagesize;
				that.pageSize = data.pagesize;
				/*var lowLimit = (that.pageCursor - 1) * that.pageSize + 1;
				var highLimit = lowLimit + that.pageCacheSize -1;
				that.pageCursor++;*/
				if(that.parentGridFilter !== undefined && that.parentGridFilter.length > 0){
					gridDescription.source.currentGridDescr.currentFilter = that.parentGridFilter;
					that.parentGridFilter = undefined;
				}
				var bottomFilters = gridDescription.source.currentGridDescr.currentFilter;
				//Текущая сортировка (получаем из массива объектов колонок)
				var gridSortStr = getSortStringFromArr(gridDescription.source.currentGridDescr.currentSort);
				//проброс флага не использовать фильтр
				var ignoreAllFilter = that.ignoreAllFilter;
				that.ignoreAllFilter = false;
				//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
				return GridWidget.prototype.makeLoadDataReqParams(dataRequest, bottomFilters, gridSortStr, lowLimit, highLimit, that.filters, roughFilters, that.parentRoughFilter, that.parentRoughParams, ignoreAllFilter);
			},
			url: Services.processQueryNode
		};
		//Создаем адаптер данных для грида
		var dataAdapterSettings = { contentType: 'application/xml; charset=utf-8',
			type: "POST",
			formatData: function (data) {
				return data;
			},
			beforeSend: function (jqXHR, settings) {
				return null;
			},
			loadError: function (jqXHR, status, error) {
				onLoadGridDataFail(error);
			},

			beforeLoadComplete: function (records) {
				return records;
			},
			loadComplete: function (data) {
				try {
					//Вызываем функцию центровки только если устанавливали в true флаг selecting или centering при фильтрации
					if (data.records && data.records.length > 0
						&& ((gridDescription.source.currentGridDescr.hasOwnProperty('selecting') && gridDescription.source.currentGridDescr.selecting == true)
							|| (gridDescription.source.currentGridDescr.hasOwnProperty('centering') && gridDescription.source.currentGridDescr.centering == true))) {
						var selecting = gridDescription.source.currentGridDescr.selecting;
						var centering = gridDescription.source.currentGridDescr.centering;
						//Затираем значения в gridDescription.source.currentGridDescr, иначе при переключении на следующие записи снова произойдет центровка
						gridDescription.source.currentGridDescr.selecting = false;
						gridDescription.source.currentGridDescr.centering = false;
						//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
						var curLayerObj = layerManagerInst.getLayerByName(layerId);
						if (curLayerObj==undefined || curLayerObj==null)
							return data;
						//Формируем параметры для вызова функции центровки
						var objectsStr = layerId + ":";
						for (i = 0; i < data.records.length; i++) {
							if (!data.records[i].hasOwnProperty("ID")) continue;
							objectsStr += data.records[i]["ID"];
							//К последнему ID сзади запятую не добавляем
							if (i < data.records.length - 1) {
								objectsStr += ",";
							}
						}
					}
					if (data.records && data.records.length > 0){
						//забираем последний RWN, если он меньше, чем в запрашиваемом, то ограничиваем totalrecords
					}
					if(that.showDashboard){
						//TODO пока временно положил сюда запуск заполнения пресетов
						if(WidgetMap && WidgetMap.config && WidgetMap.config.dashboard && (WidgetMap.config.dashboard.preset || WidgetMap.config.dashboard.charts || WidgetMap.config.charts)){
							var dashboard = WidgetMap.config.dashboard.preset || WidgetMap.config.dashboard;
							WidgetMap.config.dashboard.preset = undefined; // отключаем запуск пресетов, чтобы не срабатывали при переключении между гридами
							if(WidgetMap.config.charts && WidgetMap.config.dashboard){//временное решение
								WidgetMap.config.dashboard.charts = WidgetMap.config.charts;
							}
							if(WidgetMap.config.goals && WidgetMap.config.dashboard){//временное решение
								WidgetMap.config.dashboard.goals = WidgetMap.config.goals;
							}
							dashboard.canvas = WidgetMap.config.canvas;
							App.dashboardManager.loadDashboard(dashboard, function(dashboardConf){
								that.showDashboard = false;
								var currentGrid = $("#" + jqxGridId);
								var da = $(currentGrid).jqxGrid('source');
								if(da.currentGridDescr !== undefined){
									//TODO хардод. избавиться
									if($('#searchEngine_'+jqxGridId).length > 0){
										$('#searchEngine_'+jqxGridId).toggle();
									}
									else{
										$('.search-engine-filters__grid').remove();
										var fltrs = GridUtil.formatFilters2SearchFrom(da.currentGridDescr.gridColumns, function(filters){
											var filterView = new SearchEngineGridFiltersForm({
												opener: 'grid',
												openerId: jqxGridId,
												curDataAdapter: da,
												currentGrid: currentGrid,
												layerName: gridDescription.source.currentGridDescr.layerId,
												settings:{
													dashboard: dashboardConf,
													noTitle:true,
												},
												config: filters,
												applyCallback: function(filters, boolFilters, dateFilters, sender){
													//применяем фильтр
													var curFilter = GridUtil.reformatFilters(filters, boolFilters, dateFilters);
													da.currentGridDescr.currentFilter = curFilter;
													if(sender !== 'dashboard')
														GridWidget.refreshGrid(jqxGridId);
												}
											});
											filterView.build();
										});
									}
								}
							});
						}
						else{
							that.showDashboard = false;
							var currentGrid = $("#" + jqxGridId);
							var da = $(currentGrid).jqxGrid('source');
							if(da.currentGridDescr !== undefined){
								//TODO хардод. избавиться
								if($('#searchEngine_'+jqxGridId).length > 0){
									$('#searchEngine_'+jqxGridId).toggle();
								}
								else{
									$('.search-engine-filters__grid').remove();
									var fltrs = GridUtil.formatFilters2SearchFrom(da.currentGridDescr.gridColumns, function(filters){
										var filterView = new SearchEngineGridFiltersForm({
											opener: 'grid',
											openerId: jqxGridId,
											curDataAdapter: da,
											currentGrid: currentGrid,
											layerName: gridDescription.source.currentGridDescr.layerId,
											settings:{
												noTitle:true,
											},
											config: filters,
											applyCallback: function(filters, boolFilters, dateFilters, sender){
												//применяем фильтр
												var curFilter = GridUtil.reformatFilters(filters, boolFilters, dateFilters);
												da.currentGridDescr.currentFilter = curFilter;
												if(sender !== 'dashboard')
													GridWidget.refreshGrid(jqxGridId);
											}
										});
										filterView.build();
									});
								}
							}
						}
					}
					//that.currentState = $("#" + jqxGridId).jqxGrid('savestate');
				} catch (e) {
					App.errorReport(gis_gridwidget_12, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_8'});
				}

				return data;
			},
			loadServerData: function (serverdata, source, callback) {
				//Показываем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
				try { $("#" + jqxGridId).jqxGrid('showloadelement'); } catch (err) {}
				//Здесь будет непрямая ссылка на callback для отправки результата запроса данных в плагин jqxDataAdapter
				that.jqxDataAdapterCallback = callback;
				delete dataAdapter.currentGridDescr.rows4Update;
				currentGridMessageId = App.serverQueryXMLGridNode(Services.processQueryNode, serverdata, onLoadGridDataResult, onLoadGridDataFail, true);
			}
		};

		//В адаптер добавляем параметры, отвечающие за постраничную обработку результата
		var dataAdapter = new $.jqx.dataAdapter(gridSource, dataAdapterSettings);
		dataAdapter.currentGridDescr = currentGridDescr;
		that.dataAdapter = dataAdapter;
		//22.12.2021 Vartanian Правка по инц 2566
        var layer = currentGridDescr.layerManager.getLayerByName(layerId);
		var	editable = true;
		if(!layer || !layer.dataProvider || !layer.dataProvider.semantic){
			editable = false;
		}

		var gridDescription = {
			width: '100%',
			height: '100%',
			rowsheight: 20,
			source: [],
			sortable: true,
			altrows: true,
			columns: gridColumns,
			/*showstatusbar:true,
			renderstatusbar: function(statusbar){
				GridUtil.renderStatusBar(statusbar, jqxGridId, that);
			},
			statusbarheight: 25,*/
			toolbarheight: 40,
			columnsmenu: false,
			theme: 'gis-blueorange',
			showtoolbar: true,
			columnsresize: true,
			pageable: true,
			pagesizeoptions: pageSizeOptions,
			pagesize: pageSize,
			pagerheight: 1,
			localization: getLocalization('ru'),
			//enablebrowserselection: true,//+
			clipboard: false,//+
			virtualmode: true,
			editable: editable,
			editmode: 'dblclick',
			selectionmode: 'checkbox',
			rendergridrows: function (args) {
				return args.data;
			},
			ready: function(){
				that.defaultState = $("#" + jqxGridId).jqxGrid('savestate');
				//that.defaultState = $.extend({}, that.defaultState);
				that.currentState = $("#" + jqxGridId).jqxGrid('savestate');//$.extend({}, that.defaultState);
			},
			rendered: function gridRenderedFunction(){
				//обнуляем после рендеринга переменную, чтобы не выделялись строки
				that.colorRowSelectType = 0;
			},
			rendertoolbar: admGridRenderToolbar

		};
		if(columnVertSize !== null)
			gridDescription['columnsheight'] = columnVertSize;
		if(titleGridColumn !== null)
			that.titleGridColumn = titleGridColumn;
		//Загружаем общее количество записей - запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
		var gridDataRefresh = function (evt) {
			//перед обновлением грида, отменяем прошлые запросы
			cancelGridProcess();
			//Если id в событии есть но не совпадает с id текущего грида - обновление не запускаем
			if (evt && evt.gridId && evt.gridId==jqxGridId) {
				//Показываем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
				try { $("#" + jqxGridId).jqxGrid('showloadelement'); } catch (err) {}
				if(evt.force === true) {
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = false;
					callWidgetGridFunctions(that.layerId);
					//gridDescription.topFilter = that.filters;
					dataAdapter.currentGridDescr.topFilter = that.filters;
				}
				that.ignoreAllFilter = !!evt.ignoreAllFilter;
				gridSource.totalrecords = 99999999;
				var gridElem = $("#" + jqxGridId);
				if(evt.force === true) {
					//that.pageCursor = 1;
					//gridElem.off('sort');
					//Создаем грид только после получения количества записей
					if(that.currentState){
						try{
							gridElem.jqxGrid('loadstate', that.currentState);
						}
						catch(ex){
						}
					}
					else {
						try{
							gridElem.jqxGrid('removesort');
						}
						catch(ex){ }
						try{
							gridElem.jqxGrid('loadstate', that.defaultState);
						}
						catch(ex){ }
						that.currentState = $("#" + jqxGridId).jqxGrid('savestate');
					}
					gridElem.jqxGrid('clearselection');
					callWidgetGridFunctions(that.layerId);
					//gridDescription.topFilter = that.filters;
					dataAdapter.currentGridDescr.topFilter = that.filters;
					that.refreshGridCallback = evt.refreshGridCallback;
					return;
				}
				//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
				if (gridElem.length === 0) return;
				//Если грид пересоздается (применили фильтр) - сохраняем информацию постраничности (важно, сколько страниц показываем)
				var paginginformation = gridElem.jqxGrid('getpaginginformation');
				if (paginginformation !== undefined) {
					gridDescription.pagesize = paginginformation.pagesize;
				}
				//Удаляем старые слушатели с элемента грида
				gridElem.off('rowselect');
				gridElem.off('rowunselect');
				gridElem.off('rowclick');
				gridElem.off('pagechanged');
				gridElem.off('sort');
				gridElem.off('columnresized');
				//Создаем грид только после получения количества записей
				gridDescription.source = dataAdapter;
				gridElem.jqxGrid(gridDescription);
				//Прячем спиннер загрузки данных
				//gridElem.jqxGrid('hideloadelement');
				/*После создания грида биндимся к нужным событиям*/
				//Биндим события изменения выбора в гриде для установки доступности групповых кнопок
				gridElem.on('rowselect', function (event) {
					setEnableToGroupButtons();
				});
				gridElem.on('rowunselect', function (event) {
					setEnableToGroupButtons();
				});
				gridElem.on('columnresized', function (event) {
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = true;
					if(document.selection !== undefined && document.selection.empty !== undefined)
						document.selection.empty();
				});
				gridElem.on('cellendedit', function (event) {
					// event arguments.
					var args = event.args;
					// cell value
					var value = args.value;
					// cell old value.
					var oldvalue = args.oldvalue;
					var dataField = event.args.datafield;
					// row's bound index.
					var rowBoundIndex = event.args.rowindex;
					var columntype = event.args.columntype;
					var rwn = rowBoundIndex;
					var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', rwn);
					//эмуляция currentGrid, чтобы использовать id грида при поиске
					gridItem = GridUtil.getFullRowDataById({id: widgetElementId}, gridItem);
					if(gridItem && gridItem.RWN)
						rwn = gridItem.RWN;
					dataAdapter.currentGridDescr.lastEditedCell = { rwn:rwn, boundIndex: rowBoundIndex, dataField: dataField, event: event} ;

					if(value === oldvalue){
						//that  - GridWidget
						return;
					}
					//валидируем ячейки
					var validateResult = GridUtil.validateCell(value, columntype);
					var origValue = GridUtil.prepareCellValue(value, columntype)
					value = '' + GridUtil.prepareCellValue(value, columntype);
					if(validateResult !== ''){
						App.confirmDialog(validateResult, null, {title:gis_core_1});
						GridUtil.revertCell(gridElem, event);
						return;
					}

					//сохраняем измененное значение в общий массив измененных записей
					//уникальным считаю ID.
					if(!dataAdapter.currentGridDescr.rows4Update)
						dataAdapter.currentGridDescr.rows4Update = {};
					if(!dataAdapter.currentGridDescr.rows4Update[gridItem.ID]){
						dataAdapter.currentGridDescr.rows4Update[gridItem.ID] = JSON.parse(JSON.stringify(gridItem));//клонируем объект
					}
					//обновляем измененным значением временный список
					var synonym = undefined;
					var gridColumns = dataAdapter.currentGridDescr.gridColumns;
					var fieldName = dataField;
					for (i = 0; i < gridColumns.length; i++) {
						//Так исключаем колонки с иконками, а также колонку с номером
						if (gridColumns[i].datafield === dataField && gridColumns[i].datafieldsynonym)
							fieldName = gridColumns[i].datafieldsynonym;
					}
					dataAdapter.currentGridDescr.rows4Update[gridItem.ID][fieldName] = value;
					dataAdapter.currentGridDescr.rows4Update[gridItem.ID][dataField] = value;
				});
				//Биндим событие смены страницы для снятия выделения грида при переключении страниц
				gridElem.on('pagechanged', function (event) {
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = true;

					gridElem.jqxGrid('clearselection');
				});
				//Биндим событие выбора сортировки (будем перезапрашивать данные грида)
				gridElem.on("sort", function (event) {
					//Перед сортировкой очищаем выделение, иначе чекбокс будет в том же месте, но уже на другой записи.
					gridElem.jqxGrid('clearselection');
					var gridWidget = App.GridManager.getByGridId(widgetElementId);
					if(gridWidget) gridWidget.modified = true;
					var sortinformation = event.args.sortinformation;
					//Поскольку когда сортировка отменяется в событии не указывается колонка - очищаем весь массив
					currentGridDescr.currentSort.splice(0);
					if (sortinformation && sortinformation.sortcolumn && sortinformation.sortcolumn!=undefined)
						currentGridDescr.currentSort.push(sortinformation);
					//Перезапрашиваем данные грида
					gridElem.jqxGrid('updatebounddata', 'sort');
				});
			}
		};

		//Чтобы сразу показались колонки, устанавливаем то же описание грида, но без источника данных.
		var gridElem = $("#" + jqxGridId);
		//устанавливаем dataAdapter
		//gridDescription.source = dataAdapter;

		gridElem.jqxGrid(gridDescription);

		gridElem.data('parentGrid', that.parentGrid);
		gridElem.data('childGrid', that.childGrid);

		//Слушатель завершения отрисовки пустого грида
		setTimeout(function (event) {
			//Прячем надпись "Нет данных для отображения"
			gridElem.find('span:contains('+gridDescription.localization.emptydatastring+')').hide();
		}, 10);

		//Добавляем слушатель события обновления грида
		$("body").on(GridEvent.REFRESH_GRID+"_"+jqxGridId, gridDataRefresh);
		//Однократно вызываем обновление для самого первого отображения данных грида
		GridWidget.refreshGrid(jqxGridId);
	}

	//Функция обратного вызова для получения данных грида
	function onLoadGridDataResult(resultXml) {
		try {
			//если справочники ещё не подгрузились - ждём, иначе работаем по прошлой схеме
			if(loadingFilterCount != 0 ){
				//сохраняем в data пришедшие данные
				$("#" + jqxGridId).data('resultXml',resultXml);
				return;
			}
			if(resultXml === undefined)
				return;
			//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
			try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}

			var gridElem = $("#" + jqxGridId);
			//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
			if (gridElem.length==0) return;
			if (resultXml) {
				var er = HTTPServiceUtil.getError(resultXml);
				if (er != ""){
					App.errorReport(gis_gridwidget_1, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_9'});
				}
				else {
					var hiddenColumns = [];
					/*if(that.hiddenColumns !== undefined)//если уже устанавливали колонки через управление, то переприсваиваем
						hiddenColumns = that.hiddenColumns;*/
					for(var idx = 0; idx < that.columns.length; idx++){
						if(that.columns[idx].hidden === true && that.columns[idx].datafield !== 'ID')
							hiddenColumns.push(that.columns[idx].datafield);
					}
					var dataArr = GridWidget.prototype.getDataFromXmlByAttr(resultXml, 'data');

					that.cachedRecords = GridWidget.prototype.getDataFromXmlByAttr(resultXml, 'data');;
					//that.cachedRecords.concat(dataArr);
					/********************/
					//TODO хардкодим подпись к гриду
					try{
						var titleGridColumn =  $('#btngrouptoolbardiv_'+jqxGridId);
						/*if(eventParamsObj.layerid === 'PODS_STO_REPAIR_SHEET_RELOAD')
						titleDiv.addClass('toolbar-title-grid-clearfix')*/
						if (titleGridColumn.length > 0  && that.titleGridColumn &&  that.titleGridColumn !== ''){//&& titleGridColumn.text() === ''
							var toolbarTitle = titleGridColumn.parent().find('.toolbar-title-grid');
							if(dataArr.length > 0  && dataArr[0][that.titleGridColumn] ) {//если нет заголовка - добавляем
								//если нет кнопок, то добавляем стиль, где нет смещения
								if( toolbarTitle.length === 0){ //если заголовок есть, удаляем стары и добавляем новый
									var clearFixStyle = '';
									if(!titleGridColumn.has( "input" ).length)
										clearFixStyle = 'toolbar-title-grid-clearfix';
									var elem = $('<div class="toolbar-title-grid  ' + clearFixStyle + '"></div>').text(dataArr[0][that.titleGridColumn]);
									$(titleGridColumn).parent().append(elem);
								}
								else{
									$(titleGridColumn).parent().find('.toolbar-title-grid').text(dataArr[0][that.titleGridColumn]);
								}
							}
							if(that.ignoreLabelColumn === true){
								try{
									$(titleGridColumn).parent().find('.toolbar-title-grid').text('');
								}
								catch(ex){}
							}
						}
						//TODO хардкод. устанавливаем в годовом плане заголовок с годом обследования
						var shurfPlanLayerName = $("#" + jqxGridId).data('layerid');
						if(shurfPlanLayerName && shurfPlanLayerName.indexOf('*') !== -1){
							shurfPlanLayerName = shurfPlanLayerName.split('*')[1];
						}
						/*if (titleGridColumn.length > 0  && that.titleGridColumn &&  that.titleGridColumn !== ''){//&& titleGridColumn.text() === ''
							var toolbarTitle = titleGridColumn.parent().find('.toolbar-title-grid');
							if(dataArr.length > 0  && dataArr[0][that.titleGridColumn] && toolbarTitle.length === 0 ) {
								//если нет кнопок, то добавляем стиль, где нет смещения
								var clearFixStyle = '';
								if(!titleGridColumn.has( "input" ).length)
									clearFixStyle = 'toolbar-title-grid-clearfix';
								var elem = $('<div class="toolbar-title-grid  ' + clearFixStyle + '"></div>').text(dataArr[0][that.titleGridColumn]);
								$(titleGridColumn).parent().append(elem);
								// titleGridColumn.text(dataArr[0][that.titleGridColumn]);
							}
						}*/
					}
					catch(ex){}

					/**************/
					var totalrecords = gridSource.hasOwnProperty('totalrecords') ? gridSource.totalrecords : 100000;
					//нужно оставить только те, которые попадают в отображение по курсору
					var visibleDataArr = dataArr;//dataArr.slice(0, (that.pageCursor - 1)  * that.pageSize);

					//Устанавливаем реальное число записей в грид
					gridSource.totalrecords = totalrecords;//visibleDataArr.length;
					totalrecords = visibleDataArr.length;

					visibleDataArr = GridUtil.filterDataFromJson(visibleDataArr, hiddenColumns);

					that.currentRequestedIds = GridUtil.convertGridDataToIdsArray(dataArr);


					//Добавляем полученные данные в грид
					if (that.jqxDataAdapterCallback !== undefined) {
						var resultObj = {
							records: visibleDataArr,
							totalrecords: 100000//totalrecords
						};
						//Указываем, с какую по какую запись загрузили
						if (dataArr && gridSource && gridSource.hasOwnProperty('recordstartindex') && gridSource.hasOwnProperty('recordendindex')) {
							gridSource.recordstartindex = dataArr.length > 0 ? dataArr[0]['RWN'] - 1 : 0;
							gridSource.recordendindex = dataArr.length > 0 ? dataArr[dataArr.length - 1]['RWN'] - 1 : 0;
							var pageSize = that.pageSize;
							if(dataArr.length > 0 && dataArr.length < pageSize){
								resultObj.totalrecords = Number(dataArr[dataArr.length - 1]['RWN']);
							}
						}
						//забираем последний RWN, если он меньше, чем в запрашиваемом, то ограничиваем totalrecords
						//Добавляем через имеющуюся функцию обратного вызова плагина jqxDataAdapter
						that.jqxDataAdapterCallback(resultObj);
					}
					else {
						//Добавляем как обычно, просто массивом (тогда не обрабатывается серверная постраничность)
						addDataToGrid(visibleDataArr);
					}

					if(that.refreshGridCallback){
						that.refreshGridCallback();
						that.refreshGridCallback = undefined;
					}
					if(that.parentGridRowId !== undefined){
						var rows = gridElem.jqxGrid('getrows');
						rows.forEach(function (item, rowIndex) {
							if (item.ID == that.parentGridRowId) {
								//var gridItem = $("#" + jqxGridId).jqxGrid('getrowdatabyid', row);
								gridElem.jqxGrid('ensureRowVisible', 0);
								gridElem.jqxGrid('selectrow', rowIndex);
								gridElem.jqxGrid('ensureRowVisible', rowIndex);
								//$(currentGrid).jqxGrid('selectrow', data.selectedIndexes[item] );
							}
						});
						that.parentGridRowId = undefined;

					}

				}
			}
		} catch (e) {
			//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
			try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}
			if(e.message === 'Недостаточно памяти')
				App.errorReport(gis_gridwidget_1_1, 'ex=' + e.message+';data='+resultXml.toString(), undefined, {filename:gis_filename_243, functionname:'gis_filename_243_100'});
			else
				App.errorReport(gis_gridwidget_1, 'ex=' + e.message+';data='+resultXml.toString(), undefined, {filename:gis_filename_243, functionname:'gis_filename_243_10'});

		}
	}
	//Функция обратного вызова для получения данных грида
	function onLoadGridDataFail(resultXml) {
		currentGridMessageId = undefined;
		//Прячем спиннер загрузки данных, если можем (при первоначальной загрузке грида еще нет)
		try { $("#" + jqxGridId).jqxGrid('hideloadelement'); } catch (err) {}
		App.errorReport(gis_gridwidget_1, resultXml.toString(), undefined, {filename:gis_filename_243, functionname:'gis_filename_243_11'});
	}
	//колбек на загрузку каждого справочника
	function onFilterLoadedCallback(){
		--loadingFilterCount;
		if(loadingFilterCount == 0){
			var resultXml = $("#" + jqxGridId).data('resultXml');
			if(resultXml)
				onLoadGridDataResult(resultXml);
		}
	}

	/* Добавление в грид полученных данных */
	function addDataToGrid(gridData) {
		gridSource.localdata = gridData;
		//Обновляем записи в гриде
		$("#"+jqxGridId).jqxGrid({ source: gridSource });
	}

	//Запускаем получение описания грида по названию его шаблона
	if(App && App.GridManager && App.GridManager.has(that.fullLayerId)){
		var gridWidget = App.GridManager.get(that.fullLayerId);
		if(gridWidget && gridWidget.gridDescriptionXml){
			createGrid(gridWidget.gridDescriptionXml, gridTitle);
		}
		else{
			getGridDescription(gridTemplate);
		}
	}
	else{
		getGridDescription(gridTemplate);
	}

	//если открывали грид из другого, то устанавливаем связь
	try{
		if(this.parentGrid)
			$(this.parentGrid).data('childGrid', jqxGridId);
		if(this.childGrid)
			$(this.childGrid).data('parentGrid', jqxGridId);
	}
	catch(ex){

	}

	//Возвращаем построенный элемент грида
	return $('#'+widgetElementId);
};

// Запрос xml-файла с описанием грида
GridWidget.prototype.makeLoadGridDescrReqParams = function (gridDescrId) {
	var userId = Auth.getUserId();
	var userLogin = Auth.getUserName();
	var gridName = (gridDescrId && gridDescrId.indexOf('.xml') === -1) ? gridDescrId + '.xml' : gridDescrId;

	return {
		getSchema: false,
		descrId: 'SYS_SEM.xml#GET_XML_FILE',
		toElements: false,
		descrType: 'select',
		data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userId.xmlEscape() + '">' +
			'<data FILE="../../Public/Modules/Grid/' + gridName.xmlEscape() + '"/>' +
			'</root>'
	};
};

//Получение по значению данных его обертки для отправки в запрос (для строк добавляет кавычки)
GridWidget.prototype.getStrOrNumVal = function (val) {
	var valueStr = '';
	if($.isNumeric(val))
		valueStr += val;
	else if(val === "NULL")
		valueStr += val;
	else if(val === "")
		valueStr += 'NULL';
	else
		valueStr += "'"+val+"'";
	valueStr = valueStr.replace(/''/g, "'");//случай, если пришел уже в одинарных кавычках
	//if(val === '') valueStr = "''";//вариант, если пришла пустая строка
	return valueStr;
};
//Получение из массива фильтров строки со всеми фильтрами верхнего уровня (передаются в тег root, разделяются пробелами)
GridWidget.prototype.getTopFiltersString = function (filtersArr, bottomFilterArr) {
	var resultStr = '';
	if (filtersArr) {
		for (var i = 0; i < filtersArr.length; i++) {
			var curObj = filtersArr[i];
			var curObjName = curObj['name'];
			//Для фильтра верхнего уровня не передаем в запрос OLD_LPU_ACCESS_FILTER (но он передается в нижнем фильтре)
			if (curObjName=='OLD_LPU_ACCESS_FILTER') continue;
			var curObjValue = ""+curObj['value'];

			var curObjValArr = curObjValue.split(',');
			var valuesStr = '';
			if(curObjName === 'ROUTE_DESCR' || curObjName === 'ILI_LBL' || curObjName === 'GRID_TITLE'){//TODO УБРАТЬ хардкод! сделано, чтобы не разбивался текст, который пробрасывали из дргуого грида в запрос
				curObjValArr = [];
				if(curObjValue !== '')
					valuesStr += GridWidget.prototype.getStrOrNumVal(curObjValue);
				valuesStr = valuesStr.replace("'","");
			}
			var findYear = false;
			if(bottomFilterArr && bottomFilterArr.length > 0){
				//ищем YEAR_INSP
				for (var k = 0; k < bottomFilterArr.length; k++) {
					//TODO хардкод если поле YEAR_INSP, то в нижним фильтре игнорируем
					if (bottomFilterArr[k].fld === 'YEAR_INSP'){
						findYear = true;
						if(bottomFilterArr[k].val && bottomFilterArr[k].val.length > 0)
							bottomFilterArr[k].val.forEach(function(t){
								valuesStr += GridWidget.prototype.getStrOrNumVal("'"+t.CODE+"'") + ",";
							});
						break;
					}
				}
			}
			for (var j=0; j < curObjValArr.length; j++) {
				var fVal = curObjValArr[j];
				//TODO хардкод дляшурфовок
				if(curObjName === 'YEAR_INSP' ){
					if(findYear)//если фильтр забрали из нижнего, то не используем верхний
						break;
					//забираем из нижнего фильтра год, если выбрали, т.к. в запросе используется переменная YEAR_INSP, а не фильтр
					if (fVal === '') fVal = '999';//недостижимое число, чтобы скрипт работал
					valuesStr += GridWidget.prototype.getStrOrNumVal("'"+fVal+"'") + ",";
				}
				else
					valuesStr += GridWidget.prototype.getStrOrNumVal(fVal) + ",";
			}

			//убираем последнюю ","
			valuesStr = valuesStr.substr(0, valuesStr.length-1);
			//Если valuesStr=="''", заменяем на NULL (если выбираем в верхнем фильре 0 обследований, как во флеш-версии)
			if (valuesStr=="''") valuesStr = 'NULL';
			//Формируем общую строку со всеми фильтрами
			resultStr += curObjName + '="' + valuesStr + '" '; //Сзади добавляем пробел для разделения с последующими значениями
		}
	}
	return resultStr.replace(/&amp;#60;/g, '&amp;lt;'); //Фиксим баг #1016 - Если задать условие "<" , то ничего не найдется.
};
//Получение из массива фильтров строки со всеми фильтрами среднего уровня (передаются в тег data в атрибут FILTER, разделяются словом ' AND ')
GridWidget.prototype.getRoughFiltersString = function (filtersArr) {
	var resultStr = '';
	if (filtersArr) {
		for (var i = 0; i < filtersArr.length; i++) {
			var curObj = filtersArr[i];
			var curObjName = curObj['name'];
			var curObjValue = curObj['value'];
			var curObjValArr = curObjValue.split(',');
			//Средний фильтр добавляем в конец атрибута FILTER через AND, используем IN для перечисления
			var valuesStr = ' AND ' + curObjName + ' IN ('; //Спереди добавляем пробел для разделения с последующими значениями
			for (var j=0; j < curObjValArr.length; j++) {
				var fVal = curObjValArr[j];
				//TODO хардкод дляшурфовок
				if(curObjName === 'YEAR_INSP'){
					if (fVal === '') fVal = '999';//недостижимое число, чтобы скрипт работал
					valuesStr += GridWidget.prototype.getStrOrNumVal("'"+fVal+"'") + ",";
				}
				else
					valuesStr += GridWidget.prototype.getStrOrNumVal(fVal) + ",";
			}
			//убираем последнюю ",", добавляем закрывающую ")"
			valuesStr = valuesStr.substr(0, valuesStr.length-1) + ")";
			//Формируем общую строку со всеми фильтрами
			resultStr += valuesStr;
		}
	}

	return resultStr.replace(/&amp;#60;/g, '&amp;lt;'); //Фиксим баг #1016 - Если задать условие "<" , то ничего не найдется.
};
// Запрос получения данных грида
GridWidget.prototype.makeLoadDataReqParams = function (dataRequest, bottomFilters, initialSortField, lowLimit, highLimit, topFilters, roughFilters, parentRoughFilter, parentRoughParams, ignoreAllFilter) {
	var userId = Auth.getUserId();
	var userLogin = Auth.getUserName();
	lowLimit = isNaN(lowLimit) ? 1 : lowLimit;
	highLimit = isNaN(highLimit) ? 100 : highLimit;
	//Строка с фильтрами верхнего уровня (добавляем в конце всех атрибутов, причем и в тег root, и в тег data)
	var topFiltersStr = GridWidget.prototype.getTopFiltersString(topFilters, bottomFilters);
	//Строка с фильтрами среднего уровня (добавляем в конце атрибута FILTER в теге data)
	var roughFilterStr = GridWidget.prototype.getRoughFiltersString(roughFilters);
	//Строка с фильтрами нижнего уровня (добавляем в начало атрибута FILTER в теге data)
	var bottomFiltersStr = GridWidget.prototype.getBottomFilterString(bottomFilters, parentRoughFilter);
	var parentVars = (parentRoughParams && parentRoughParams.length) ? parentRoughParams[parentRoughParams.length - 1] : undefined;
	var parentRoughFilterParams = GridUtil.composeFilterVarByColumns(parentVars);
	//Поле начальной сортировки (если ничего не передано - сортируем по полю ID )
	var orderColumnsField = initialSortField!=null && initialSortField!="" && initialSortField!="ID" ? initialSortField+',ID' : 'ID';

	if(ignoreAllFilter){
		roughFilterStr = ''; bottomFiltersStr = '8=8'; parentRoughFilterParams = '';
	}
	return {
		descrId: dataRequest,
		descrType: 'select',
		data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" '+topFiltersStr+'>' +
			'<data ' + parentRoughFilterParams + ' FILTER="'+bottomFiltersStr+roughFilterStr.xmlEscape()+'" ' +
			'ORDER_COLUMNS="'+orderColumnsField+'" LOW_LIMIT="'+lowLimit+'" HIGH_LIMIT="'+highLimit+'" '+topFiltersStr+'/>' +
			'</root>'
	};
};
// Запрос получения данных геометрии по выбранными ID грида
GridWidget.prototype.makeLoadGeoDataReqParams = function (dataRequest, filterStr) {
	var userId = Auth.getUserId();
	var userLogin = Auth.getUserName();

	return {
		descrId: dataRequest,
		descrType: 'select',
		data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" >' +
			'<data FILTER="'+filterStr.xmlEscape()+'" />' +
			'</root>'
	};
};
// Строка с фильтрами для центровки на карте (добавляется специальное поле COLUMNS_FILTER="ID")
GridWidget.prototype.makeFilterXMLForCentering = function (bottomFilters, initialSortField, topFilters, roughFilters, parentRoughFilter) {
	//Строка с фильтрами верхнего уровня (добавляем в конце всех атрибутов, причем и в тег root, и в тег data)
	var topFiltersStr = GridWidget.prototype.getTopFiltersString(topFilters, bottomFilters);
	//ДАТЫ ОБРАБАТЫВАЕМ ОТДЕЛЬНО - включаем как переменные на уровень тега <data >, например: <data CURRENT_DATE="20.05.2015">
	if (bottomFilters && bottomFilters.length > 0) {
		for (var i = 0; i < bottomFilters.length; i++) {
			var filterObj = bottomFilters[i];
			if (filterObj.hasOwnProperty('hasType') && filterObj.hasType=='date' && filterObj.fld!=undefined && filterObj.val!=undefined) {
				topFiltersStr += ' '+filterObj.fld+'="'+filterObj.val+'" ';
			}
		}
	}
	//Строка с фильтрами среднего уровня (добавляем в конце атрибута FILTER в теге data)
	var roughFilterStr = GridWidget.prototype.getRoughFiltersString(roughFilters);
	//Строка с фильтрами нижнего уровня (добавляем в начало атрибута FILTER в теге data)
	//TODO перейти на статический метод
	//GridUtil.getBottomFilterString(bottomFilters, parentRoughFilter);
	var bottomFiltersStr = GridWidget.prototype.getBottomFilterString(bottomFilters, parentRoughFilter);
	//Поле начальной сортировки (если ничего не передано - сортируем по полю ID )
	var orderColumnsField = initialSortField!=null && initialSortField!="" && initialSortField!="ID" ? initialSortField+',ID' : 'ID';

	return '<data FILTER="'+bottomFiltersStr.xmlEscape()+roughFilterStr.xmlEscape()+'" ORDER_COLUMNS="'+orderColumnsField.xmlEscape()+'" '+topFiltersStr+' COLUMNS_FILTER="ID"/>';
};

//Функция получения из xml с данными массива данных (в виде объектов)
GridWidget.prototype.getDataFromXmlByAttr = function (inputXmlStr, dataAttrName, excludeColumns) {
	var retArr = [];
	//Получаем xml с данными в виде структуры (берем корневой элемент, т.е. root)
	var inputXml = ($.parseXML(inputXmlStr)).firstChild;
	var items = inputXml.getElementsByTagName(dataAttrName);

	for (var i = 0; i < items.length; i++) {
		var curItem = items[i];
		var attrNameNodeMap = curItem.attributes;
		if(attrNameNodeMap.length === 0) continue;
		//добавляем в виде объекта со свойствами согласно именам атрибутов
		var addItem = {};
		for (var j = 0; j < attrNameNodeMap.length; j++) {
			var node = attrNameNodeMap[j];
			if(excludeColumns && excludeColumns.length > 0 && excludeColumns.indexOf(node.nodeName.toUpperCase()) !== -1)
				continue;
			addItem[node.nodeName.toUpperCase()] = node.nodeValue;
		}
		retArr.push(addItem);
	}

	return retArr;
};

//Функция обработки щелчка на кнопке в колонке грида
GridWidget.prototype.imageButtonClick = function (event, currentGrid, value, gridTitle) {
	try {
		var imgButton = event.target;
		var idArr = imgButton.id.split('_');
		if (idArr && idArr.length==5) {
			//Грид берет колонку не по ее номеру, а по ее dataField, но в dataField колонок с кнопками как раз находятся их номера
			var rowNum = idArr[4];
			//Данные выбранной строки грида
			var curRowData = $(currentGrid).jqxGrid('getrowdatabyid', rowNum);
			//Получаем необходимые значения из атрибутов кнопки
			var paramsObj = {
				index: value,
				path: '',
				eventname: '',
				tooltip: '',
				request: '',
				task: '',
				opennewwnd: '',
				openwndwidth: '',
				openwndheight: '',
				layerid: '',gridid: '',
				templatename: '',
				ext_data_id: '',
				syncmap:'',
				paneltitle:'',
				descrcolumns:'',
				listrendererparams:'',
				filterparams:'',
			};
			for (var i = 0; i < imgButton.attributes.length; i++) {
				var curAttr = imgButton.attributes[i];
				var attrName = curAttr.nodeName;
				var attrValue = curAttr.nodeValue;
				if (paramsObj.hasOwnProperty(attrName)) {
					paramsObj[attrName] = attrValue;
				}
			}

			//т.к. часть данных в скрытых колонках, то из cachedRecords забираем весь набор атрибутов для выбраннй записи
			curRowData = GridUtil.getFullRowDataById(currentGrid, curRowData);
			var selectedArr = [curRowData];

			//По содержимому объекта paramsObj будем вызывать соответствующую внешнюю функцию грида на данных selectedArr
			GridWidget.prototype.callExternalGridFunction(paramsObj, selectedArr, currentGrid, gridTitle, rowNum, event);

			//В dataAdapter в records хранятся все записи. В _source.datafields хранится описание колонок.
			/*var curDataAdapter = $(currentGrid).jqxGrid('source');
			 var curRowData = curDataAdapter.records[rowNum];*/
		} else {
			App.errorReport(gis_gridwidget_5);
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_14'});
	}
};

//Функция обработки щелчка на групповой кнопке грида
GridWidget.prototype.groupButtonClick = function (event, currentGrid) {
	try {
		var imgGroupButton = event.target;
		var idArr = imgGroupButton.id.split('_');
		if (idArr) {
			//Получаем необходимые значения из атрибутов кнопки
			var paramsObj = {source:'', clickevent:'', tooltip:'', request:'', isenabled:'',
				selectedobjects:'', layerid:'', template:'', gridid:'', syncmap:'',
				parentgridid:'',paneltitle:'', task: '', opennewwnd: '', filter: '',
			};

			var i;
			for (i = 0; i < imgGroupButton.attributes.length; i++) {
				var curAttr = imgGroupButton.attributes[i];
				var attrName = curAttr.nodeName;
				var attrValue = curAttr.nodeValue;
				if (paramsObj.hasOwnProperty(attrName)) {
					paramsObj[attrName] = attrValue;
				}
			}
			//Данные выбранных строк грида
			var selectedArr = [];
			var rowindexes = $(currentGrid).jqxGrid('getselectedrowindexes');
			for (i = 0; i < rowindexes.length; i++) {
				var curRowData = $(currentGrid).jqxGrid('getrowdatabyid', rowindexes[i]);
				//Для еще не подгруженных данных грида элементы массива с недогруженными номерами будут undefined
				if (curRowData && curRowData.hasOwnProperty("ID")) {
					//т.к. часть данных в скрытых колонках, то из cachedRecords забираем весь набор атрибутов для выбраннй записи
					curRowData = GridUtil.getFullRowDataById(currentGrid, curRowData);
					selectedArr.push(curRowData);
				}
			}
			var isFiltering = false;
			//если в процессе фильтрации, то нельзя получить доступ к выбранным элементам, например, при экспорте
			if(rowindexes.length !== selectedArr)
				isFiltering = true;

			//По содержимому объекта paramsObj будем вызывать соответствующую внешнюю функцию грида на данных selectedArr
			GridWidget.prototype.callExternalGridFunction(paramsObj, selectedArr, currentGrid, isFiltering);

			//В dataAdapter в records хранятся все записи. В _source.datafields хранится описание колонок.
			/*var curDataAdapter = $(currentGrid).jqxGrid('source');
			 var curRowData = curDataAdapter.records[rowNum];*/
		} else {
			App.errorReport(gis_gridwidget_5);
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_16'});
	}
};

//Функция вызова внешней функции взаимодействия по переданным данным (выбранные ряды грида) и объекту с типом события
//eventParamsObj - объект, полученный от кнопки грида вида {path:'', eventname:'', tooltip:'', layerid:'', templatename:'', ext_data_id:''}
//dataObj - объект с данными (массив выбранных записей грида)
GridWidget.prototype.callExternalGridFunction = function (eventParamsObj, dataObj, currentGrid, gridTitle, rowNum, event) {
	try {
		var that = this;
		//Если переданы все параметры
		if (eventParamsObj && dataObj) {
			var i = 0;
			var windowId = "";
			var funcName = "";
			var params = [];
			var objectsStr = "";
			//Дополнительные переменные перед разделением на групповую и строковую операции
			var filterStr, dataRequest, curLayerObj, layerManagerInst, layerId, gridLayerId;
			var curDataAdapter = $(currentGrid).jqxGrid('source');
			if(curDataAdapter !== undefined && curDataAdapter.currentGridDescr === undefined && GlobalGridDescr[currentGrid.id] !== undefined ){//условие самого начала работы с гридом. Используем описание грида по умолчанию
				curDataAdapter.currentGridDescr = GlobalGridDescr[currentGrid.id];
			}
			var deletingObject, fileName, extDataId, deletingArr, deleteConfirmationForm, limitExportExcel, alertForm, dialog;
			/* переменные для административных задач */
			var deleteArray, currentTemplate;
			var currentMessageId; //Это не ID запроса. Это сам текущий запрос, который можно отменить через currentMessageId.abort()
			var requestParams, sendingData, gridPropPanelId, gridPropPanelDiv, routeIds, curObjectId, _baseOutputData;
			/* Задача администрирования трубопроводов */
			var kmCalcArray, lrsCalcArray, makeSrvDistrBndArray, offlineBindingByRouteArray;
			/* Задача администрирования отчетов ВТД */
			var iliCalcArray, iliCalcPressureArray, iliCalcPressureInput, iliCalcClusterArray, iliCalcClusterInput, iliCalcSTOArray, iliCalcSTOInput, iliCalcSTOforEHZArray, iliCalcSTOforEHZInput;
			/* Задача администрирования отчетов ЭХЗ */
			var cpCalcArray;
			/* Задача администрирования учетных записей */
			var addRolesToUsersArray;
			/* Задача администрирования ролей */
			var createRolesByLPUArray;
			/* Задача администрирования политик доступа */
			var addRolesToPoliciesArray, addPolicyRulesArray;
			/* Задача администрирования видеомониторинга */
			var addRoutesToVideosArray;
			/* Задача администрирования ЛПУ */
			var addZonesToLpuArray, addNomenclaturesToLpuArray;

			//Функция для вызова именно из грида сообщения об ошибке центровки
			var gridCenteringResultFunction = function (shortText, fullText) {
				App.confirmDialog(shortText, null, {title:gis_core_1});
			};
			//Функция для вызова именно из грида сообщения об ошибке центровки
			var noErrorFunction = function (shortText, fullText) {
				//App.confirmDialog(gis_bindtolineform_4, null, {title:gis_core_1});
			};

			//слушатель результата выполнения задачи
			var onShurfResult = function onResult(resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				if (resultXML) {
					var er = HTTPServiceUtil.getError(resultXML);
					if (GridWidget.processStatusForm)
						GridWidget.processStatusForm.processResultString(er);
				}
			};
			//слушатель результата выполнения задачи
			var onShurfFault = function (resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				if (resultXML) {
					var er = HTTPServiceUtil.getError(resultXML);
					if (GridWidget.processStatusForm)
						GridWidget.processStatusForm.processResultString(er);
				}
			};
			var cancelShurfProcess = function cancelProcess() {
				if (currentMessageId)
					currentMessageId.abort();
				currentMessageId = undefined;
				BlockingUtil.ready();
			};

			//Функция обновления грида после добавления
			var refreshGridAfterDelete = function (errorsCount, processedCount, isCancel, layerName, ids) {
				//После удаления обновляем грид
				//СИНХРОНИЗАЦИЯ #K6
				//СИНХРОНИЗАЦИЯ #S5
				//СИНХРОНИЗАЦИЯ #U5
				if(layerName && ids){//Рефакторинг Vartanian 25.11.2021
					var selectedObject = layerName + ':' + ids.join(',');
					App.syncManager.callSync(selectedObject, 'grid_delete', undefined, SyncTypes.TYPE_3);
				}
			};
			var refreshGridAfterProcEnd = function (layerName, ids) {
				//После удаления обновляем грид
				//СИНХРОНИЗАЦИЯ #K6
				//СИНХРОНИЗАЦИЯ #S5
				//СИНХРОНИЗАЦИЯ #U5
				if(layerName && ids){//Рефакторинг Vartanian 25.11.2021
					var selectedObject = layerName + ':' + ids.join(',');
					App.syncManager.callSync(selectedObject, 'grid_refresh', undefined, SyncTypes.TYPE_3);
				}
			};
			var refreshDataAfterProcEnd = function (layerName, ids) {
				//После удаления обновляем грид
				//СИНХРОНИЗАЦИЯ #K6
				//СИНХРОНИЗАЦИЯ #S5
				//СИНХРОНИЗАЦИЯ #U5
				if(layerName && ids){//Рефакторинг Vartanian 25.11.2021
					var selectedObject = layerName + ':' + ids.join(',');
					App.syncManager.callSync(selectedObject, 'grid_refresh', undefined, SyncTypes.TYPE_3);
					var layer = WidgetMap.layerManager.getLayerByName(layerName);
					if(layer && layer.layer){
						layer.layer.loadDataByIds(ids, false);
					}
				}
			};
			var refreshGridAfterDeleteWithSyncMap = function (errorsCount, processedCount, isCancel, layerName, ids) {
				//После удаления обновляем грид
				GridWidget.refreshGrid(currentGrid.id);
				/*//ВЫЗОВ ФУНКЦИИ СИНХРОНИЗАЦИИ
				//Не смог воспроизвести синхронизацию(не отвечает за ячейки из екселя по реакциям)
				//Нужно удалить блок кода.
				if(layerName && ids){
					var selectedObject = layerName + ':' + ids.join(',');
					App.syncManager.callSync(selectedObject, 'grid', undefined, SyncTypes.TYPE_3);
				}*/
				if(MapUtil){
					/*if(ids.length > 100)
						MapUtil.updateLayerData(layerName, [], false);
					else*/
					MapUtil.updateLayerData(layerName, ids, false);
				}
			};


			//слушатель результата выполнения задачи
			var onResult = function onResult(resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				if (resultXML) {
					var er = HTTPServiceUtil.getError(resultXML);
					var showAlertMessage = function showAlertMessage(alertMsg, alertTitle) {
						if (er != "")
							App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_18'});
						else {
							alertForm = new AlertForm();
							alertForm.width = 320;
							alertForm.build("gridAdmTaskAlertForm", alertMsg, alertTitle, AlertForm.OK);
						}
					};
					switch (currentTemplate) {
						/* Задача администрирования отчетов ВТД */
						case "ILI_INSP_Proc.xml":
						case "ILI_Pressure.xml":
						case "ILI_Cluster.xml":
						case "STO_ILI_INSP_Proc.xml":
						case "STO_EHZ_INSP_Proc.xml":
						case "gridAdmPiCPBindToLine":
						case "gridAdmPiCISBindToLine":
						case "UnlinkReperTemplate":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							break;
						case "IliReportCalcCorrTemplate":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							GridWidget.successIliReportCalcCorr();
							break;
						case "ILI_INSP_ProcRevert.xml":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							if(er === ''){
								showAlertMessage(gis_gridwidget_157, gis_gridwidget_14);
								refreshGridAfterOperation();
							}
							break;
						/* Задача администрирования отчетов ВТД */
						case "gridAdmIliBindToRoute":
							showAlertMessage(gis_gridwidget_13, gis_gridwidget_14);
							break;
						default:
							if (er != "")
								App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_19'});
							break;
					}
				}
			};
			//слушатель результата выполнения задачи
			var onFault = function onFault(resultXML) {
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				if (resultXML) {
					var er = HTTPServiceUtil.getError(resultXML);
					switch (currentTemplate) {
						/* Задача администрирования отчетов ВТД */
						case "ILI_INSP_Proc.xml":
						case "ILI_Pressure.xml":
						case "ILI_Cluster.xml":
						case "STO_ILI_INSP_Proc.xml":
						case "STO_EHZ_INSP_Proc.xml":
						case "gridAdmPiCPBindToLine":
						case "gridAdmPiCISBindToLine":
						case "UnlinkReperTemplate":
						case "ILI_INSP_ProcRevert.xml":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							break;
						case "IliReportCalcCorrTemplate":
							if (GridAdmWidget.processStatusForm)
								GridAdmWidget.processStatusForm.processResultString(er);
							break;
						case "gridAdmIliBindToRoute":
						default:
							App.errorReport(gis_gridadmwidget_1, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_20'});
							break;
					}
				}
			};
			//Окончание обработки групповой операции
			var endProcess = function endProcess() {
				//Не снимаем курсор ожидания - это делают onResult, onFault и cancelProcess
				//BlockingUtil.ready();
				//BlockingUtil.unblockApplication();
				deleteArray = null;
				/* Задача администрирования трубопроводов */
				kmCalcArray, lrsCalcArray, makeSrvDistrBndArray, offlineBindingByRouteArray = null;
				/* Задача администрирования отчетов ВТД */
				iliCalcArray, iliCalcPressureArray, iliCalcPressureInput, iliCalcClusterArray, iliCalcClusterInput, iliCalcSTOArray, iliCalcSTOInput, iliCalcSTOforEHZArray, iliCalcSTOforEHZInput = null;
				/* Задача администрирования отчетов ЭХЗ */
				cpCalcArray = null;
				/* Задача администрирования учетных записей */
				addRolesToUsersArray = null;
				/* Задача администрирования ролей */
				createRolesByLPUArray = null;
				/* Задача администрирования политик */
				addRolesToPoliciesArray, addPolicyRulesArray = null;
				/* Задача администрирования видеомониторинга */
				addRoutesToVideosArray = null;
				/* Задача администрирования ЛПУ */
				addZonesToLpuArray, addNomenclaturesToLpuArray = null;
				//Очищаем форму статуса процесса
				GridAdmWidget.processStatusForm = null;
				//обновляем грид
				refreshGridAfterOperation();
			};
			//Функция обновления грида после удаления
			var refreshGridAfterOperation = function refreshGridAfterOperation() {
				//После удаления обновляем грид
				GridWidget.refreshGrid(currentGrid.id);
			};

			//Отмена текущего выполняемого запроса. Особенность - даже при отмене отработает функция onFault с ошибкой abort. abort.
			var cancelProcess = function cancelProcess() {
				if (currentMessageId)
					currentMessageId.abort();
				currentMessageId = undefined;
				//Снимаем курсор ожидания
				BlockingUtil.ready();
				//Не обновляем грид - это делается в endProcess.
			};
			//Простая функция для перевода JSON Object с примитивными атрибутами (без массива) в xml с тегом <input />
			var convertSimpleObjectToXml = function convertSimpleObjectToXml(simpleObj) {
				var resXml = '<input />';
				for (var attrName in simpleObj) {
					var attrValue = simpleObj[attrName];
					//Значения "Y" и "N" переводим в true и false для админских серверных задач
					if (attrValue == "Y" || attrValue == "N") attrValue = attrValue == "Y";
					//Добавляем к результирующей строке
					resXml = resXml.replace('/>', attrName + '="' + attrValue + '" />');
				}
				// resXml = resXml.replace('<', '&lt;');
				// resXml = resXml.replace('>', '&gt;');
				return resXml;
			};

			//Простая функция для перевода xml с примитивными атрибутами в JSON Object (обязательно надо чтобы заканчивался на '" />' а не '"/>')
			var convertXmlToSimpleObject = function convertXmlToSimpleObject(simpleXml) {
				var resObj = {};
				//root_path="|zip_file_name="|do_calc_inspection="true|do_read_about="true|data_file_name="data.xml"
				simpleXml = simpleXml.replace('<input ', '');
				simpleXml = simpleXml.replace('/>', '');
				var xmlSplitArr = simpleXml.split('" ');
				for (var i = 0; i < xmlSplitArr.length; i++) {
					var paramSplitArr = xmlSplitArr[i].split('="');
					if (paramSplitArr.length == 2) {
						//Значения true и false переводим в "Y" и "N" для админских серверных задач
						var paramValue = paramSplitArr[1];
						if (paramValue == true || paramValue == false) paramValue = paramValue ? "Y" : "N";
						resObj[paramSplitArr[0]] = paramSplitArr[1];
					}
				}
				return resObj;
			};
			function closeDialog() {
				dlg.dialog('destroy');
				dlg.remove();
			}
			//Обрабатываем полученный объект.
			/* КНОПКА В СТРОКЕ ГРИДА. Если есть свойство eventname - значит это вызов с кнопки для персонального ряда. Нужно обработать вызов согласно eventname
			 Типы eventName: ru.corelight.business.events.ExportToGPXEvent, ru.corelight.business.events.ShowOnMapEvent,
			 ru.corelight.business.events.ExportToExcelEvent, ru.corelight.business.events.RemoveGridRowEvent
			 */
			if (eventParamsObj.hasOwnProperty('eventname')) {
				if(rowNum !== undefined){
					if(eventParamsObj['eventname'] !== 'showDetailEvent'){ // при "проваливании" в дочерний грид у текущего грида нет выполняем команды(он закрывается)
						$(currentGrid).jqxGrid('clearselection');
						$(currentGrid).jqxGrid('selectrow', Number(rowNum));
					}
				}

				if (GridButtonsWithPopup && GridButtonsWithPopup.indexOf(eventParamsObj['eventname']) !== -1)
					widgetMoveWindowToPosition('grid','restore_default');
				switch (eventParamsObj['eventname']) {
					//Экспорт пикетажа по всему газопроводу
					case 'gridAdmRoutesExportPicketingByLine':
						if(dataObj[0] === undefined) break;
						//Формируем список routeIds из поля LINE_ID
						var rId = undefined;
						if(dataObj.length>0 && goog.isDef(dataObj[0]["LINE_ID"]))
							rId = dataObj[0]["LINE_ID"];
						extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_LINE';
						//Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде "русскоязычный заголовок колонки":value
						ExportUtil.exportAdmPicketingToExcel([{LINE_ID:rId}], 'server_export', extDataId);
						break;
					case 'ru.corelight.business.events.ExportToExcelPicketingByRouteEvent':
						if(dataObj[0] === undefined) break;
						var rId = undefined;
						var lId = undefined;
						if(dataObj.length>0 && goog.isDef(dataObj[0]["ID"]))
							rId = dataObj[0]["ID"];
						if(dataObj.length>0 && goog.isDef(dataObj[0]["LINE_ID"]))
							lId = dataObj[0]["LINE_ID"];
						extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE';


					function build() {
						//Создаем диалоговую форму
						dlg.dialog({
							modal: true,
							title: gis_gridwidget_15,
							dialogClass: 'noCloseButton gsi-zindex__dialog',
							closeOnEscape: true,
							width: 300,
							height: 180
						});

						//Кнопки Ок и отмены
						$("input[name='export']", dlg).click(function () {
							if($('input[id="radioPicketingByRoute"]', dlg).is(':checked'))
								ExportUtil.exportAdmPicketingToExcel([{ROUTE_ID: rId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE');
							else
								ExportUtil.exportAdmPicketingToExcel([{LINE_ID: lId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_LINE');
							$('#exportPicketingToExcelForm').remove();
						});
						$("input[name='cancel']", dlg).click(function () {
							$('#exportPicketingToExcelForm').remove();
						});
					}
						var elementId = 'exportPicketingToExcelForm';
						$('#'+elementId).remove();
						$('body').append('<div id="'+elementId+'"></div>');
						var dlg = $('#'+elementId);
						dlg.load('ui/html/ExportPicketingToExcelForm.html', build);
						break;
					case 'ru.corelight.business.events.ExportToGPXEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						filterStr = "ID = " + dataObj[0]["ID"];
						//Экспортируем объекты
						GridWidget.prototype.exportObjectsToGPX(filterStr, curDataAdapter.currentGridDescr);
						break;
					case 'ru.corelight.business.events.ShowOnMapEvent':
						//Формируем параметры для вызова функции центровки
						try {
							if(dataObj[0] === undefined) break;
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							//закомментировал, чтобы выдавалось сообщение, что не найден слой
							//if (curLayerObj==undefined || curLayerObj==null) break;
							var titlebar = !(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.titlebar === false);
							objectsStr = eventParamsObj["layerid"] + ":" + dataObj[0]["ID"];
							funcName = "showObjects";
							params = [{name: "objects", value: objectsStr}, {name: "select", value: true}, {name: "centering", value: true}, {name: "gridCenteringResultFunction",value: gridCenteringResultFunction},{name: "isGroupButton", value: false}];
							if(!App.syncEnabled){
								//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
								ExternalInteraction.callFunction(windowId, funcName, params);
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								if(titlebar)//TODO заглушка, чтобы не сворачивать грид
									widgetMoveWindowToPosition('grid');
							}
							else {

								//1. для клика из самой вкладки делаем первоначальною центровку
								//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
								//ExternalInteraction.callFunction(windowId, funcName, params);
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								if(titlebar)
									widgetMoveWindowToPosition('grid');
								//2. и параллельно отправляем событие на центровку через синхронизацию
								//СИНХРОНИЗАЦИЯ #Z5
								//СИНХРОНИЗАЦИЯ #V6
								//СИНХРОНИЗАЦИЯ #V7
								var selectedObject = objectsStr;
								if(selectedObject)
									App.syncManager.callSync(selectedObject, 'grid', undefined, SyncTypes.TYPE_2);
							}
						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_21'});
						}
						break;
					case 'ru.corelight.business.events.ExportToExcelEvent':
						if(dataObj[0] === undefined) break;
						//забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
						limitExportExcel = NaN;
						if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
							limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						// isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
						if (limitExportExcel && dataObj.length > limitExportExcel && false && isNaN(limitExportExcel))
						{
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+gis_gridwidget_18+limitExportExcel+".<br/>"
								+gis_gridwidget_19+limitExportExcel+gis_gridwidget_20,gis_gridwidget_21);
						}
						else
						{
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+ gis_gridwidget_22,gis_gridwidget_23);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								//TODO переделать описание грида, чтобы в нем явно был указан шаблон для выгрузки в Excel (для PODS_ANODE_LIST.XML он например не указан)
								fileName = App.generateUUID() + ".xls";
								//Если вызов экспорта одиночной записи - при отсутствии templatename подставляем tamplate='export'
								layerId = eventParamsObj.hasOwnProperty('templatename') && eventParamsObj.templatename!='' ? eventParamsObj.templatename : curDataAdapter.currentGridDescr.layerId;
								extDataId = eventParamsObj.hasOwnProperty('ext_data_id') && eventParamsObj.ext_data_id!='' ? eventParamsObj.ext_data_id : '';
								//Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде "русскоязычный заголовок колонки":value
								if (extDataId=='') {
									var newDataObj = {};
									var gridColArr = curDataAdapter.currentGridDescr.gridColumns;
									for (i = 0; i < gridColArr.length; i++) {
										//Так исключаем колонки с иконками, а также колонку с номером
										if (gridColArr[i].text=='' || gridColArr[i].datafield=="RWN" || !dataObj[0].hasOwnProperty(gridColArr[i].datafield)) continue;
										var curColHeaderText = gridColArr[i].text;
										//upd 27.05.20.заменяем \n в колонках на '', чтобы в excel в названиях не было _n
										curColHeaderText = curColHeaderText.replace(/(\\r\\n|\\n|\\r)/gm,'');
										var repl = /[^0-9a-zA-Zа-яА-Я_]/gi;
										curColHeaderText = curColHeaderText.replace(repl, "_");
										newDataObj[curColHeaderText] = dataObj[0][gridColArr[i].datafield];
									}
									ExportUtil.exportToExcel([newDataObj], fileName, layerId, 'export');
								} else {
									ExportUtil.exportToExcel(dataObj, fileName, layerId, extDataId);
								}
							}
						});
						break;
					case 'ru.corelight.business.events.RemoveGridRowEvent':
						try {
							if(dataObj[0] === undefined) break;
							var syncMap = (eventParamsObj && eventParamsObj.syncmap === 'true');

							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							if (curLayerObj==undefined || curLayerObj==null) {
								//Если слоя нет - делаем как во флеше (там ничего не происходило, даже запрос не отправлялся, здесь Володя сказал должна быть форма с сообщением)
								alertForm = new AlertForm();
								alertForm.build("gridDeleteNoLayerAlertForm",gis_gridwidget_24,gis_gridwidget_25,AlertForm.OK);
								//Чистим выделение в гриде
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							//удаление ТОЛЬКО СЕМАНТИКИ (исправить provider на dataRequest = "", чтобы прошел полный алгоритм удаления сначала геометрии затем семантики)
							dataRequest = curLayerObj.dataProvider.semantic;
							//выставил PropertyPanelName="" как для случая групповой операции удаления было сделано
							deletingObject = {rowData:dataObj[0], classId:layerId, objectId:dataObj[0]["ID"], provider:dataRequest, propertyPanelName:""};
							deletingArr = [];
							deletingArr.push(deletingObject);

							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_26,deletingArr,that,(syncMap)?that.deleteObjectWithSyncMap:that.deleteObject,
										(syncMap)?refreshGridAfterDeleteWithSyncMap:refreshGridAfterDelete, null, true);
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_22'});
						}
						break;
					case 'ru.corelight.business.events.ShowOnCASEvent':
						if(dataObj[0] === undefined) break;//qq
						//проверяем , есть ли lineId, если нет то не открываем ПКА
						function buildCasForm(data) {
							var taskName = 'CAS_JS';
							var params = {
								lineId: data["LINE_ID"],
								beginKm: stationBegin,
								endKm: stationEnd,
							}
							//ПКА просто открываем в новом окне без функций взаимодействия
							function confirm(){
								App.destroyDialog(null, dlgC);
								GridUtil.showOnCas(taskName, params);
							}
							var browserScale = getBrowserZoom();
							if(browserScale !== 1)
								var dlgC = App.confirmDialog(gis_gridwidget_50, [{text:gis_app_55_9,  click:confirm}], {title:gis_core_1, dialogClass: 'noCloseButton', closeOnEscape: false});
							else
								GridUtil.showOnCas(taskName, params);
						}
						var stationBegin = dataObj[0]["STATION_BEG"];
						var stationEnd =  dataObj[0]["STATION_END"];
						if( stationBegin === undefined || stationEnd === undefined){
							if(dataObj[0]["STATION"] !== undefined){
								var station = parseFloat(dataObj[0]["STATION"]);
								if(isNaN(station)){
									App.errorReport(gis_gridwidget_46, gis_gridwidget_49, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_43'});
									return;
								}
								//для километров выставляем +- 300 метров от station
								stationBegin = (station - 0.3).toFixed(2);
								stationEnd = (station + 0.3).toFixed(2);
							}
							else{
								App.errorReport(gis_gridwidget_46, gis_gridwidget_49, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_37'});
								return;
							}
						}
						if(dataObj[0].LINE_ID === undefined){
							if(dataObj[0].ROUTE_ID === undefined){
								App.errorReport(gis_gridwidget_46, gis_gridwidget_47, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_33'});
								return;
							}
							else{
								function onFaultLine(inputXmlStr){
									App.errorReport(gis_gridwidget_46, gis_gridwidget_48, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_35'});
								}
								function onResultLine(inputXmlStr){
									//Получаем xml с данными в виде структуры (берем корневой элемент, т.е. root)
									var inputXml = ($.parseXML(inputXmlStr)).firstChild;
									var items = inputXml.getElementsByTagName('data');
									if(items.length > 0){
										var attrNameNodeMap = items[0].attributes;
										//добавляем в виде объекта со свойствами согласно именам атрибутов
										for (var j = 0; j < attrNameNodeMap.length; j++) {
											var node = attrNameNodeMap[j];
											if(node.nodeName.toUpperCase() === 'LINE_ID'){
												dataObj[0].LINE_ID =  node.nodeValue;
												buildCasForm(dataObj[0]);
												return;
											}
										}
									}
									App.errorReport(gis_gridwidget_46, gis_gridwidget_48, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_36'});
								}
								sendingData = '<data FILTER="ROUTE_ID=' + dataObj[0].ROUTE_ID + '" />';
								var userId = Auth.getUserId();
								var userLogin = Auth.getUserName();
								requestParams = {
									descrId: 'GAZPROM_ADM_SEM.xml#PODS_ROUTE',
									descrType: 'select',
									data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' + sendingData + '</root>'
								};
								App.serverQueryXMLNodeWithTries(Services.processQueryNode, requestParams, onResultLine, onFaultLine,4);
								return;
							}
						}
						else
							buildCasForm(dataObj[0]);
						break;
					//обработка клика по кнопке из задачи ЭХЗ. В ПКА передается дополнительно идентификатор обследования
					case 'showOnCASEHZEvent':
						if(dataObj[0] === undefined) break;
						var stationBegin = dataObj[0]["STATION_BEG"];
						var stationEnd =  dataObj[0]["STATION_END"];
						if( stationBegin === undefined || stationEnd === undefined){
							if(dataObj[0]["STATION"] !== undefined){
								var station = parseFloat(dataObj[0]["STATION"]);
								//для километров выставляем +- 300 метров от station
								stationBegin = (station - 0.3).toFixed(2);
								stationEnd = (station + 0.3).toFixed(2);
							}
							else{
								App.errorReport(gis_gridwidget_46, gis_gridwidget_49, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_38'});
								return;
							}
						}
						var taskName = "cas_ehz";
						if(eventParamsObj !== undefined){
							if(eventParamsObj.task !== undefined && eventParamsObj.task !== '')
								taskName = eventParamsObj.task;
						}
						var params = {
							lineId: dataObj[0]["LINE_ID"],
							beginKm: stationBegin,
							endKm: stationEnd,
							id: dataObj[0]["ID"],
						}
						//ПКА просто открываем в новом окне без функций взаимодействия
						function confirm(){
							App.destroyDialog(null, dlgC);
							GridUtil.showOnCas(taskName, params);
						}
						var browserScale = getBrowserZoom();
						if(browserScale !== 1)
							var dlgC = App.confirmDialog(gis_gridwidget_50, [ {text:gis_app_55_9,  click:confirm} ], {title:gis_core_1, dialogClass: 'noCloseButton', closeOnEscape: false});
						else
							GridUtil.showOnCas(taskName, params);
						break;
					case 'ru.corelight.business.events.ShowVideoEvent':
						if(dataObj[0] === undefined) break;
						/*funcName = "showVideo";
						 params = [{name:"docId", value:dataObj[0]["ID"]}, {name:"videoUrl", value:dataObj[0]["FILE_NAME"]}];
						 //Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
						 ExternalInteraction.callFunction(windowId, funcName, params);*/
						//Вызываем через функцию виджет-взаимодействия js, а не через вызов флеша
						showVideo(dataObj[0]["ID"], dataObj[0]["FILE_NAME"],dataObj[0]["NAME"]);
						//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
						widgetMoveWindowToPosition('grid');
						break;
					case 'ru.corelight.business.events.ExportWRLEvent':
						if(dataObj[0] === undefined) break;
						ExportUtil.exportToWRL(dataObj[0].ID, dataObj[0].FILE_NAME);
						break;
					case 'ru.corelight.business.events.ExportIMGEvent':
						if(dataObj[0] === undefined) break;
						ExportUtil.exportToIMG(dataObj[0].ID, dataObj[0].FILE_NAME);
						break;
					case 'showInfoEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if (curRowData && curRowData.ID) {
							//Добавляем доп. условие. Если грид годового плана шурфовок, что нужно открывать панель свойств PODS_ILI_INSPECTION
							layerId = curDataAdapter.currentGridDescr.layerId;
							var currentGridDescr = curDataAdapter.currentGridDescr;
							var curObjectId = layerId + ":" + curRowData.ID;
							var centeringCallback = undefined;
							var addObj = {};//доп.данные для панели свойств
							//заголовок забирается из панели свойств
							if(layerId === 'PODS_STO_SHEET_EXCAVATE' || layerId === 'PODS_STO_SHEET_MTR' || layerId === 'PODS_STO_SHEET_REPAIR'
								|| layerId === "PODS_STO_SHURF_PLAN" || layerId === "PODS_STO_ILI_DATA_SHEET_RELOAD"){
								gridTitle = "";
							}
							if(layerId === "PODS_STO_SHURF_PLAN"){
								curObjectId = "PODS_ILI_INSPECTION" + ":" + curRowData.ID;
							}
							if( layerId === "PODS_STO_ILI_DATA_SHEET_RELOAD" || layerId === 'PODS_STO_REPAIR_SHEET_RELOAD' ){
								if(curRowData.ILI_CLUSTER_ID && curRowData.ILI_CLUSTER_ID !== '')
									curObjectId = "PODS_ILI_CLUSTER" + ":" + curRowData.ID;
								else
									curObjectId = "PODS_ILI_DATA" + ":" + curRowData.ID;
							}
							if(layerId === "PODS_STO_ILI_DATA_SHEET_BASE"){
								// принято решение убрать двойной клик по этому гриду
								return;
							}
							if(layerId === "PODS_STO_SHEET_EXCAVATE" || layerId === 'PODS_STO_SHEET_MTR' || layerId === 'PODS_STO_SHEET_REPAIR'){
								centeringCallback = function(data, opts){
									if(WidgetMap ){
										WidgetMap.loadLineProfile(curRowData.LINE_ID, curRowData.STATION_BEG, curRowData.STATION_END);
									}

								}
							}
							if(curObjectId.indexOf("PODS_ILI_DATA:") === 0){
								addObj.ILI_DATA_ID = curRowData.ILI_DATA_ID;
								if(curRowData.ILI_CLUSTER_ID)
									addObj.ILI_CLUSTER_ID = curRowData.ILI_CLUSTER_ID;
							}

							//Добавляем div панели свойств текущего грида
							var gridPropPanelId = 'divPPanel' + currentGrid.id;
							var widgetElementId = currentGrid.id.replace('jqxgrid','')
							var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
							$('#' + gridPropPanelId).remove();
							var opener = "#" + widgetElementId;
							if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
								opener = 'body';
								$('body').append(gridPropPanelDiv);
							}
							else{
								$('#' + widgetElementId).append(gridPropPanelDiv);
							}
							var gridCurrentHeight = currentGridDescr.propPanelHeight;
							var gridCurrentWidth = currentGridDescr.propPanelWidth;
							if($('#' + widgetElementId).outerHeight()<currentGridDescr.propPanelHeight) gridCurrentHeight = $('#' + widgetElementId).outerHeight();
							if($('#' + widgetElementId).outerWidth()<currentGridDescr.propPanelWidth) gridCurrentWidth = $('#' + widgetElementId).outerWidth();
							//Создаем панель свойств для текущего объекта
							$('#' + gridPropPanelId).myPropertiesPanel({
								zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
								objects:[{id: curObjectId, label: gridTitle, curRowData:curRowData}],
								opener: opener,
								openerType: 'grid',
								data: addObj,
								panelSize: {propPanelWidth:gridCurrentWidth, propPanelHeight:gridCurrentHeight},
								handlers:{
									calculateObjectSizeCallback: function(params){
									},
									centeringCallback: centeringCallback,
									closeCallback: function (dataObj) {
										//Сохраняем размеры панели свойств, которую уже открывали, чтобы следующие открываемые были того же размера (но не со свернувшейся)
										if ($('#' + gridPropPanelId).outerWidth()>50 && $('#' + gridPropPanelId).outerHeight()>50) {
											currentGridDescr.propPanelWidth = $('#' + gridPropPanelId).outerWidth() - 6; // -6 чтобы панель свойств не росла при каждом закрытии/открытии
											currentGridDescr.propPanelHeight = $('#' + gridPropPanelId).outerHeight() - 6; // -6 чтобы панель свойств не росла при каждом закрытии/открытии
										}
									},
									successDeleteCallback:function(data){
										if(goog.isDef(data) && goog.isDef(data.id) && data.id != '' && data.layerName != ''){
											var layObj = currentGridDescr.layerManager.getLayerByName(data.layerName);
											if(goog.isDef(layObj) && goog.isDef(layObj.layer)){
												layObj.layer.deleteObjectById(data.id);
											}
										}
										if(MapUtil)
											MapUtil.clearSelectionLayer();
										$('#' + gridPropPanelId).remove();
										var selectedObject = undefined;
										if (data.layerName && data.id)
											selectedObject = data.layerName + ':' + data.id;
										if (selectedObject) {
											//СИНХРОНИЗАЦИЯ #Y5-OK
											var syncType = SyncTypes.TYPE_5;
											App.syncManager.callSync(selectedObject, 'grid_delete', undefined, syncType);//Vartanian рефакторинг 25.11.2021
										}
									},
									semanticCallback: function (dataObj) {//Vartanian рефакторинг 25.11.2021
										if(dataObj.success === true && dataObj.retObj){
											var layerName = dataObj.retObj.layerId;
											var semId = dataObj.retObj.id;
											var selectedObject = layerName;
											if(semId){
												selectedObject += ':' + semId;
												//СИНХРОНИЗАЦИЯ #W5
												var syncType = SyncTypes.TYPE_5;
												App.syncManager.callSync(selectedObject, 'grid_refresh', undefined, syncType);
											}
										}
									},
								}
							});
						}
						break;

					//Задача шурфовки. Начало
					//Внести расчетные данные по отчету
					case 'addStoIliDataAdvEvent':
						if(dataObj[0] === undefined)
							break;
						try {
							//jqxGridId, gridElem, dataAdapter, event

							that.pasteFromExcelStoIliDataAdvDialog(currentGrid, curDataAdapter, dataObj[0]);
						}
						catch(ex){
						}


						break;
					//Грид "Подготовить выгрузку данных для ССД ИНФОТЕХ"
					case 'exportInfotehShurfEvent':
						if(dataObj[0] === undefined)
							break;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_INFOTEH_ANOMALY_DATA";
								extDataId = "STO_EXPORT.xml#STO_INFOTEH_ANOMALY_DATA";
								ExportUtil.exportToExcel([dataObj[0]], fileName, layerId, extDataId);
							}
						});
						break;
					//задача "Сформировать акт приемка результатов ВТД"
					case 'createActOfILIResultsEvent':
						if(dataObj[0] === undefined)
							break;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								//Если вызов экспорта одиночной записи - при отсутствии templatename подставляем tamplate='export'
								layerId = "STO_ALLOW_ILI";
								extDataId = "STO_EXPORT.xml#STO_ALLOW_ILI";
								ExportUtil.exportToExcel([dataObj[0]], fileName, layerId, extDataId);
							}
						});
						break;

					//сформировать/выбрать новую ведомость шуррфовок на межкрановом участке
					case 'selectSheetShurfEvent':
						if(dataObj[0] === undefined)
							break;
					function createNewExcavateSheet(){
						GridUtil.getCountStoIliDataAdv(dataObj[0], function(isEmptySheet, hasIliDataAdv){
							var gridSTOILIRangeForm = new GridSTOILIRangeForm({
								dataProvider: "STO_SEM.xml#STO_DICT_1",
								item: dataObj[0],
								type: 'excavate',
								gridId: currentGrid.id,
								hasIliDataAdv: hasIliDataAdv,
								eventParams: eventParamsObj,
								saveCallback: function(sheetId, rangeData){
									if(rangeData && rangeData.uid)
										delete rangeData.uid;
									if(isEmptySheet){//upd. 02.12.20 создаем пустую ведомость, если нет доп. сведений по дефектам
										var duplicateGrid = (WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true)
										ExternalInteraction.openGrid({
											data: {
												ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
												BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
												END_MEASURE: rangeData.END_MEASURE,
												ROUTE_ID: rangeData.ROUTE_ID,
												SHEET_ID: sheetId,
												STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
												//upd. 08.10.20 при создании не пробрасываем заголовок, т.к. он соответствует всему обследованию, а не участку
												//upd. 04.03.21 название берется из новой колонки
												ROUTE_DESCR:rangeData.ROUTE_DESCR//проброс в запрос на получение заголовка грида
											},
											//при создании новой ведомости не должно быть кнопки "добавить дефект"
											gridId: eventParamsObj.layerid+"_LIST",
											label: gis_gridwidget_73,
											fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid,
											position: 2,
											reload: true,
											forceTopFilter: true,
										});
										return;
									}
									BlockingUtil.wait();
									var reqParams = DBUtil.getReqParams('STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH', DBUtil.serializeData(rangeData), 'insert');
									App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
										BlockingUtil.ready();
										if (resultXML) {
											var er = HTTPServiceUtil.getError(resultXML);
											if (er !== ""){
												App.errorReport(gis_gridwidget_82, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_50'});
												return;
											}
											var duplicateGrid = (WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true)
											ExternalInteraction.openGrid({
												data: {
													ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
													BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
													END_MEASURE: rangeData.END_MEASURE,
													ROUTE_ID: rangeData.ROUTE_ID,
													SHEET_ID: sheetId,
													STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
													//upd. 08.10.20 при создании не пробрасываем заголовок, т.к. он соответствует всему обследованию, а не участку
													//upd. 04.03.21 название берется из новой колонки
													ROUTE_DESCR:rangeData.ROUTE_DESCR//проброс в запрос на получение заголовка грида
												},
												//при создании новой ведомости не должно быть кнопки "добавить дефект"
												gridId: eventParamsObj.layerid+"_LIST",
												label: gis_gridwidget_73,
												fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid,
												position: 2,
												reload: true,
												forceTopFilter: true,
											});

										}
									}, function (resultXML) {
										BlockingUtil.ready();
										var er = HTTPServiceUtil.getError(resultXML);
										if (er !== "")
											App.errorReport(gis_gridwidget_82, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_51'});
									},4);
								}
							});
							gridSTOILIRangeForm.build();
						})

						closeDialog();
					}
					function selectExcavateSheet(){
						var gridSTOILIArchiveForm = new GridSTOILIArchiveForm({
							dataProvider: "STO_SEM.xml#STO_DATA_EXC_CHOOSE",
							item: dataObj[0],
							type:'excavate'
						});
						gridSTOILIArchiveForm.build();
						closeDialog();
					}
						//TODO сначала запрашиваем список ведомостей из архива. Если их нет, то сразу выдаем форму создания новой ведомости
						var buttons = [
							{text:gis_gridwidget_70, click:createNewExcavateSheet},
							{text:gis_gridwidget_71, click:selectExcavateSheet}
						];
						var dlg = App.confirmDialog(gis_gridwidget_72, buttons, {title:gis_core_1, width:400});
						break;
					//сформировать /выбрать ведомость материально-технических ресурсов по межкрановому участку
					case 'selectSheetMTRShurfEvent':
						if(dataObj[0] === undefined)
							break;
					function createNewMTRSheet(){
						var gridSTOILIRangeForm = new GridSTOILIRangeForm({
							dataProvider: "STO_SEM.xml#STO_DICT_1",
							item: dataObj[0],
							type:'mtr',
							eventParams: eventParamsObj,
							saveCallback: function(datas, sheetId, rangeData){
								App.notSupportedDialog('Нет возможности открыть созданную ведомость МТР, т.к. данный функционал не реализован');
								return;
								ExternalInteraction.openGrid({
									data: {
										ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
										BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
										END_MEASURE: rangeData.END_MEASURE,
										ROUTE_ID: rangeData.ROUTE_ID,
										SHEET_ID: sheetId,
										STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
										ROUTE_DESCR:rangeData.ILI_LBL//проброс в запрос на получение заголовка грида
									},
									gridId: eventParamsObj.layerid+"_LIST",
									label: gis_gridwidget_75,
									fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid
								});
							}
						});
						gridSTOILIRangeForm.build();
						closeDialog();
					}
					function selectMTRSheet(){
						var gridSTOILIArchiveForm = new GridSTOILIArchiveForm({
							dataProvider: "STO_SEM.xml#STO_DATA_MTD_CHOOSE",
							item: dataObj[0],
							type:'mtr'
						});
						gridSTOILIArchiveForm.build();
						closeDialog();
					}
						//TODO сначала запрашиваем список ведомостей из архива. Если их нет, то сразу выдаем форму создания новой ведомости
						var buttons = [
							{text:gis_gridwidget_70, click:createNewMTRSheet},
							{text:gis_gridwidget_71, click:selectMTRSheet}
						];
						var dlg = App.confirmDialog(gis_gridwidget_72, buttons, {title:gis_core_1, width:400});
						break;
					//Сформировать/выбрать перечень ремонтов
					case 'selectSheetRepairShurfEvent':
						if(dataObj[0] === undefined)
							break;
					function createNewRepairSheet(){
						var gridSTOILIRangeForm = new GridSTOILIRangeForm({
							dataProvider: "STO_SEM.xml#STO_DICT_1",
							item: dataObj[0],
							type:'repair',
							eventParams: eventParamsObj,
							saveCallback: function(datas, sheetId, rangeData){
								ExternalInteraction.openGrid({
									data: {
										ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
										BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
										END_MEASURE: rangeData.END_MEASURE,
										ROUTE_ID: rangeData.ROUTE_ID,
										SHEET_ID: sheetId,
										STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
										ROUTE_DESCR:rangeData.ILI_LBL//проброс в запрос на получение заголовка грида
									},
									gridId: eventParamsObj.layerid+"_LIST",
									label: gis_gridwidget_74,
									fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid
								});
							}
						});
						gridSTOILIRangeForm.build();
						closeDialog();
					}
					function selectRepairSheet(){
						var gridSTOILIArchiveForm = new GridSTOILIArchiveForm({
							dataProvider: "STO_SEM.xml#STO_DATA_REP_CHOOSE",
							item: dataObj[0],
							type:'repair'
						});
						gridSTOILIArchiveForm.build();
						closeDialog();
					}

						//TODO сначала запрашиваем список ведомостей из архива. Если их нет, то сразу выдаем форму создания новой ведомости
						var buttons = [
							{text:gis_gridwidget_70, click:createNewRepairSheet},
							{text:gis_gridwidget_71, click:selectRepairSheet}
						];
						var dlg = App.confirmDialog(gis_gridwidget_72, buttons, {title:gis_core_1, width:400});
						break;
					//Задача "сформировать перечень обследованных дефектов"
					case 'createInspectedILIDataEvent':
						if(dataObj[0] === undefined)
							break;
						alert('Задача "сформировать перечень обследованных дефектов" не реализована');
						break;
					/*Грид "Ведомость аномалий"*/
					//Задача "внести информацию о выполненном наружном обследовании"
					case 'updateSheetExcavateEvent':
						if(dataObj[0] === undefined)
							break;
						//Создаем панель свойств по классу объекта - она сохраняет новый объект
						var curObjectId = "PODS_STO_SHEET_EXCAVATE_LIST:"+dataObj[0].ID;
						var clusterId = (dataObj[0].ILI_CLUSTER_ID)?dataObj[0].ILI_CLUSTER_ID:undefined;
						//Добавляем div панели свойств текущего грида
						var gridPropPanelId = 'divPPanel' + currentGrid.id;
						var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var opener = "#" + widgetElementId;
						if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
							opener = 'body';
							$('body').append(gridPropPanelDiv);
						}
						else{
							$('#' + widgetElementId).append(gridPropPanelDiv);
						}
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: ''}],
							opener: opener,
							openerType: 'grid',
							data: {LIST_ID:dataObj[0].LIST_ID, ILI_CLUSTER_ID:clusterId},
							panelSize: {propPanelWidth:curDataAdapter.currentGridDescr.propPanelWidth, propPanelHeight:curDataAdapter.currentGridDescr.propPanelHeight},
							handlers:{
								calculateObjectSizeCallback: function(params){

								},
								closeCallback: function (dataObj) {
									//Сохраняем размеры панели свойств, которую уже открывали, чтобы следующие открываемые были того же размера (но не со свернувшейся)
									if ($('#' + gridPropPanelId).outerWidth()>50 && $('#' + gridPropPanelId).outerHeight()>50) {
										curDataAdapter.currentGridDescr.propPanelWidth = $('#' + gridPropPanelId).outerWidth();
										curDataAdapter.currentGridDescr.propPanelHeight = $('#' + gridPropPanelId).outerHeight();
									}
								}
							}
						});
						break;
					//вызов задачи 'Внести информацию о выполненном ремонте'
					case 'updateSheetRepairEvent':
						if(dataObj[0] === undefined)
							break;
						//сначала получаем sheet_id из sto_sheet_repair
						// Запрос получения данных геометрии по выбранными ID грида
						var sheetObj = {};
						//забираем из верхнего фильтра
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "ILI_INSPECTION_ID" || item.name == "STO_ILI_INSP_EVENT_ID"){
									sheetObj[item.name]= item.value;
								}
							});
						}
						openSTOSheetRepairListForm();
					function openSTOSheetRepairListForm(sheetId){
						var curObjectId = 'PODS_STO_SHEET_REPAIR_LIST:'+dataObj[0].ID;//передаем ili_data_id
						var clusterId = (dataObj[0].ILI_CLUSTER_ID)?dataObj[0].ILI_CLUSTER_ID:undefined;
						//Добавляем div панели свойств текущего грида
						//ищем ILI_INPECTION_ID и EVENT_ID, чтобы передать дальше в панель свойств
						var sheetObj = {};
						sheetObj.ILI_DATA_ID = dataObj[0].ID;
						if(dataObj[0].ILI_CLUSTER_ID){
							sheetObj.ILI_DATA_ID = dataObj[0].ILI_CLUSTER_ID;
							sheetObj.ILI_CLUSTER_ID = dataObj[0].ILI_CLUSTER_ID;
						}
						/*if(sheetId)
							sheetObj.SHEET_ID = sheetId;*/
						var gridPropPanelId = 'divPPanel' + currentGrid.id;
						var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var opener = "#" + widgetElementId;
						if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
							opener = 'body';
							$('body').append(gridPropPanelDiv);
						}
						else{
							$('#' + widgetElementId).append(gridPropPanelDiv);
						}
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: ''}],
							data: sheetObj,
							opener: opener,
							openerType: 'grid',
							panelSize: {propPanelWidth:curDataAdapter.currentGridDescr.propPanelWidth, propPanelHeight:curDataAdapter.currentGridDescr.propPanelHeight},
							handlers:{
								calculateObjectSizeCallback: function(params){

								},
								closeCallback: function (dataObject) {
									//Сохраняем размеры панели свойств, которую уже открывали, чтобы следующие открываемые были того же размера (но не со свернувшейся)
									if ($('#' + gridPropPanelId).outerWidth()>50 && $('#' + gridPropPanelId).outerHeight()>50) {
										curDataAdapter.currentGridDescr.propPanelWidth = $('#' + gridPropPanelId).outerWidth();
										curDataAdapter.currentGridDescr.propPanelHeight = $('#' + gridPropPanelId).outerHeight();
									}
								},
								semanticCallback: function (dataObject) {
									//СИНХРОНИЗАЦИЯ #W5
									var selectedObject = curObjectId;
									App.syncManager.callSync(selectedObject,'grid', undefined, SyncTypes.TYPE_3);
								},
							}
						});
					}
						break;
					// задача "удалить запись из списка аномалий"
					case 'deleteSheetExcavateListEvent':
						try {
							if(dataObj[0] === undefined) break;
							//SHEET_ID забираем из верхнего фильтра, который пришел извне
							//если нет SHEET_ID, то это новая ведомость и удаляем только строку
							//если есть - удаляем из БД
							var sheetId = undefined;
							if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
								//получаем из фильтра, который пришел от родительского грида
								curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
									if(item.name === "SHEET_ID"){
										sheetId = item.value;
									}
								});
							}
							if(sheetId === undefined && eventParamsObj && eventParamsObj.index && eventParamsObj.index !==''){
								$(currentGrid).jqxGrid('deleterow', eventParamsObj.index);
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST';
							var clId = curDataAdapter.currentGridDescr.layerId;
							if(curDataAdapter.currentGridDescr.layerId === 'PODS_STO_REPAIR_SHEET_RELOAD'){
								dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
							}
							//выставил PropertyPanelName="" как для случая групповой операции удаления было сделано
							deletingObject = {rowData:dataObj[0], classId:clId, objectId:dataObj[0].LIST_ID, provider:dataRequest, propertyPanelName:""};
							deletingArr = [];
							deletingArr.push(deletingObject);
							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_26,deletingArr,that,that.deleteObject,
										refreshGridAfterDelete, null, true);
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_42'});
						}
						break;

					//показать на карте дефект
					case 'showOnMapShurfEvent':
						//Формируем параметры для вызова функции центровки
						try {
							if(dataObj[0] === undefined) break;
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							if(eventParamsObj["layerid"] !== undefined && eventParamsObj["layerid"] !== ''){
								var splittedLayersIds = eventParamsObj["layerid"].split(',');
								//ВЫСТАВЛЯЕМ ВЕРХНИЙ ФИЛЬТР, чтобы каждлый клик на показать на карте в слое PODS_ILI_DATA обновлялись корретнео данные
								var lpuFilter = MapUtil.getTopFilterByName('LPU_ACCESS_FILTER');
								WidgetMap.currentTopFilter = undefined;
								WidgetMap.currentTopFilter = (curDataAdapter.currentGridDescr.topFilter)?[lpuFilter].concat(curDataAdapter.currentGridDescr.topFilter):[];

								var iliInspFilter = {};
								curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
									if(item.name === "ILI_INSPECTION_ID" ){
										iliInspFilter = {name:'ILI_INSP_FILTER',value:item.value};
										var finded = false;
										for(var it in WidgetMap.currentTopFilter){
											if(WidgetMap.currentTopFilter[it].name === 'ILI_INSP_FILTER')
												finded = true;
										}
										if(!finded)
											WidgetMap.currentTopFilter.push({name:'ILI_INSP_FILTER', value: item.value});
									}
								});
								splittedLayersIds.forEach(function(val){
									layerId = val;
									layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
									if(layerId === 'PODS_ILI_DATA' && dataObj[0].ILI_CLUSTER_ID && dataObj[0].ILI_CLUSTER_ID !== '')
										layerId = 'PODS_ILI_CLUSTER';
									curLayerObj = layerManagerInst.getLayerByName(layerId);
									var needReloadLayer = true;
									if(WidgetMap.currentFilter[layerId]){
										WidgetMap.currentFilter[layerId].forEach(function(filter){
											if(filter.filter === iliInspFilter.name && filter.value === iliInspFilter.value){
												needReloadLayer = false;
											}
										});
									}
									if(needReloadLayer){
										WidgetMap.currentFilter[layerId] = [];
										WidgetMap.currentFilter[layerId].push({
											layerName: layerId,
											filter: iliInspFilter.name,
											value: iliInspFilter.value
										});
										layerManagerInst.clearLayer(layerId, true);
									}
									if(dataObj[0].ILI_CLUSTER_ID && dataObj[0].ILI_CLUSTER_ID !== '')
										objectsStr = "PODS_ILI_CLUSTER:" + dataObj[0]["ID"];
									else
										objectsStr = "PODS_ILI_DATA:" + dataObj[0]["ID"];
									curLayerObj.layer.layerLoadCallback = undefined;
									var preparedParams = [{name: "objects", value: objectsStr},
										{name: "select", value: true },
										{name: "centering", value: true},
										{name: "gridCenteringResultFunction", value: noErrorFunction },
										{name: "isGroupButton", value: false}];

									if(curLayerObj && curLayerObj.layer){
										if(layerId === 'PODS_ILI_DATA' || layerId === 'PODS_ILI_CLUSTER'){
											if(needReloadLayer)
												curLayerObj.layer.layerLoadCallback = function(){
													//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
													WidgetMap.showObjects(preparedParams);
												};
											else {
												WidgetMap.showObjects(preparedParams, false, function(finded){
													if(!finded) {
														curLayerObj.layer.layerLoadCallback = function(){
															//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
															WidgetMap.showObjects(preparedParams);
														};
													}
												});
											}
										}
										if(needReloadLayer)
											curLayerObj.layer.setVisible(true);
									}
								});
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								widgetMoveWindowToPosition('grid');
							}
						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_21'});
						}
						break;
					//показать участок на карте
					case 'showOnMapPipePartEvent':
						try {
							if(dataObj[0] === undefined) break;
							if(WidgetMap){
								WidgetMap.loadLineProfile(dataObj[0].LINE_ID, dataObj[0].STATION_BEG, dataObj[0].STATION_END);
							}
							//if(eventParamsObj["request"] !== undefined && eventParamsObj["request"] !== '' && WidgetMap && dataObj[0].LINE_ID && dataObj[0].LINE_ID !== ''){
							//проверям, заполнен список с routeId, чтобы там найти соответственный lineId, чтобы потом выделить участок
							/*if(WidgetMap.preloadRoutesWithLinesList === undefined){
								WidgetMap.loadRoutesWithLines({
									request: eventParamsObj["request"],
									loadedCallback: function(){
										var lineId = WidgetMap.preloadRoutesWithLinesList[dataObj[0].ROUTE_ID];
										if(lineId !== undefined){
											var requestLineProfile = 'GAZPROM_SYS_SEM.xml#MG_PROFILE';
										}
									}
								});
							}
							else{
								var lineId = WidgetMap.preloadRoutesWithLinesList[dataObj[0].ROUTE_ID];
								if(lineId !== undefined){

								}
							}*/
							//}

						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_21'});
						}
						break;
					//вызов задачи 'Сформировать ведомость шурфовок'
					case 'exportExcelShurfSheetEvent':
						if(dataObj[0] === undefined || dataObj[0].ILI_INSPECTION_ID === undefined) break;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_ANOM_LIST";
								extDataId = "STO_EXPORT.xml#STO_ANOM_LIST";
								ExportUtil.exportToExcel([{ID:dataObj[0].ID}], fileName, layerId, extDataId);
							}
						});
						break;
					//вызов задачи 'Сформировать ведомость обследовний'
					case 'createInspectionsSheetEvent':
						//забираем SHEET_ID, который пришел извне
						if(dataObj[0] === undefined) break;
						if(!dataObj[0].ID){
							App.errorReport(gis_gridwidget_53, gis_gridwidget_54, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_39'});
							break;
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_PHYS_INSP_LIST";
								extDataId = "STO_EXPORT.xml#STO_PHYS_INSP_LIST";
								ExportUtil.exportToExcel([{ID:dataObj[0].ID}], fileName, layerId, extDataId);
							}
						});
						break;
					case 'addShurfEvent':
						if(dataObj[0] === undefined) break;
						var addFilter = ' STO_ILI_INSP_EVENT_ID="' + dataObj[0].STO_ILI_INSP_EVENT_ID + '" BEGIN_MEASURE="' + dataObj[0].BEGIN_MEASURE + '"' +
							' END_MEASURE="' + dataObj[0].END_MEASURE + '" ROUTE_ID="' + dataObj[0].ROUTE_ID + '" SHEET_ID="' + dataObj[0].ID + '"' +
							' ROUTE_DESCR="' + dataObj[0].ROUTE_DESCR + '" ILI_INSPECTION_ID="' + dataObj[0].ILI_INSPECTION_ID + '" ';
						if(curDataAdapter.currentGridDescr !== undefined){
							var gridSTOILIDataListForm = new GridSTOILIDataListForm({
								gridId:currentGrid.id,
								sheetId:dataObj[0].ID,
								dataProvider:'STO_SEM.xml#PODS_STO_ILI_DATA_SHEET_ADD',
								items: [],//массив дефектов для выбранной ведомости
								layerId:curDataAdapter.currentGridDescr.layerId,
								filter:curDataAdapter.currentGridDescr.topFilter,
								addFilter: addFilter,
								applyCallback:function(array){
									var allDatas = array;
									//в цикле сохраняем все записи из грида
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_55,allDatas,that,
										function (obj) {
											//Заведомо обнуляем поля перед сохранением
											delete obj.TYPE;
											delete obj.DESCRIPTION;
											delete obj.COMMENTS;
											//у ремонтов доп. поля
											var prvd = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST';
											if(curDataAdapter.currentGridDescr.layerId === "PODS_STO_REPAIR_SHEET_RELOAD"){
												delete obj.WIDTH;
												delete obj.LENGTH;
												prvd = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
											}
											var reqParams = DBUtil.getReqParams(prvd, DBUtil.serializeData(obj), 'insert');
											BlockingUtil.wait();
											currentMessageId = App.serverQueryXMLNode(Services.processQueryNode, reqParams, onShurfResult, onShurfFault);
										},
										function(){
											refreshGridAfterProcEnd(curDataAdapter.currentGridDescr.layerId, []);
										}, cancelShurfProcess, true);
								}
							});
							gridSTOILIDataListForm.build();
						}
						break;
					//Задача шурфовки. Конец
					//кнопка в гридах архивах - дублирование двойного клика
					case 'doubleClickEvent':
						if(dataObj[0] === undefined) break;
						var curObjectId = curDataAdapter.currentGridDescr.layerId + ":" + dataObj[0].ID;
						//Добавляем div панели свойств текущего грида
						var gridPropPanelId = 'divPPanel' + currentGrid.id;
						var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var opener = "#" + widgetElementId;
						if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
							opener = 'body';
							$('body').append(gridPropPanelDiv);
						}
						else{
							$('#' + widgetElementId).append(gridPropPanelDiv);
						}
						//Создаем панель свойств для текущего объекта
						$('#' + gridPropPanelId).myPropertiesPanel({
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							objects:[{id: curObjectId, label: ''}],
							opener: opener,
							openerType: 'grid',
							panelSize: {propPanelWidth:curDataAdapter.currentGridDescr.propPanelWidth, propPanelHeight:curDataAdapter.currentGridDescr.propPanelHeight},
							handlers:{
								calculateObjectSizeCallback: function(params){

								},
								closeCallback: function (dataObj) {
									//Сохраняем размеры панели свойств, которую уже открывали, чтобы следующие открываемые были того же размера (но не со свернувшейся)
									if ($('#' + gridPropPanelId).outerWidth()>50 && $('#' + gridPropPanelId).outerHeight()>50) {
										curDataAdapter.currentGridDescr.propPanelWidth = $('#' + gridPropPanelId).outerWidth();
										curDataAdapter.currentGridDescr.propPanelHeight = $('#' + gridPropPanelId).outerHeight();
									}
								}
							}
						});
						break;

					//ДЕТАЛИЗАЦИЯ из годового плана
					case 'shurfDetailEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования. из годового плана
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(curRowData && curRowData.ID && eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var preParentFilter = undefined;
							var fullLayerId = '';
							var parentRoughParams = curRowData;
							var parentData = undefined;
							if(gridWidget) {
								preParentFilter = gridWidget.staticParentRoughFilter;
								fullLayerId = gridWidget.fullLayerId;
								parentData = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams : [];
								parentRoughParams.PARENT_FULL_LAYER_ID = fullLayerId.replace('*','#');
								parentRoughParams.PARENT_GRID_TITLE = gridWidget.title;
								parentRoughParams.PARENT_GRID_FILTER = gridWidget.dataAdapter.currentGridDescr.currentFilter;
								parentRoughParams.PARENT_GRID_ROW_ID = dataObj[0].ID;
								parentData.push(parentRoughParams);
								parentRoughFilter = '8=8';
							}
							var panelTitle = gis_gridwidget_136;
							ExternalInteraction.openGrid({
								data: {
									ILI_INSP_FILTER:dataObj[0].ID,
									ILI_LBL:dataObj[0].ILI_LBL//проброс в запрос на получение заголовка грида
								},
								gridId: eventParamsObj.layerid+"_LIST",
								label: panelTitle,
								parentRoughFilter: parentRoughFilter,
								parentRoughParams: parentData,
								staticParentRoughFilter: preParentFilter,
								fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid,
								parentGrid: currentGrid.id,
								position: 1,//2-я по очереди,
								reload: true,
								forceTopFilter: true,
							}, function(childGridId){
								var ch = childGridId+'|'+eventParamsObj.layerid+'|'+curRowData.ID
								$(currentGrid).data('gridChild', ch );
							});
						}
						break;
					//ДЕТАЛИЗАЦИЯ грид шурфовок
					case 'showSheetEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var panelTitle = gis_gridwidget_73;
							var openInSameTab = false;
							var position = 2;
							if(eventParamsObj.layerid === 'PODS_STO_REPAIR_SHEET_RELOAD') {
								panelTitle = gis_gridwidget_74;
								position = -1;
							}
							else {
								//openInSameTab = true;
								position = 2;
							}
							var ili_label = '';
							var lblSelector = $('#btngrouptoolbardiv_'+currentGrid.id);//btngrouptoolbardiv_jqxgridid4504_GRID
							if(lblSelector.length > 0) {
								var titleDiv = lblSelector.parent().find('.toolbar-title-grid');
								if(titleDiv.length){
									ili_label = titleDiv.text();
								}

							}
							var iliInspFilter = undefined;
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "ILI_INSP_FILTER" )
									iliInspFilter = item.value;
							});
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var preParentFilter = undefined;
							var fullLayerId = '';
							var parentRoughParams = curRowData;
							var parentData = undefined;
							if(gridWidget) {
								preParentFilter = gridWidget.staticParentRoughFilter;
								fullLayerId = gridWidget.fullLayerId;
								parentData = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams : [];
								parentRoughParams.PARENT_FULL_LAYER_ID = fullLayerId.replace('*','#');
								parentRoughParams.PARENT_GRID_TITLE = gridWidget.title;
								parentRoughParams.PARENT_GRID_FILTER = gridWidget.dataAdapter.currentGridDescr.currentFilter;
								parentRoughParams.PARENT_GRID_ROW_ID = dataObj[0].ID;
								parentData.push(parentRoughParams);
								parentRoughFilter = '8=8';
							}
							var selectedIndex = GridUtil.getSelectedTab();
							ExternalInteraction.openGrid({
								data: {
									ILI_INSP_FILTER: iliInspFilter, // обязательное условие!
									ILI_INSPECTION_ID: dataObj[0].ILI_INSPECTION_ID,
									BEGIN_MEASURE: dataObj[0].BEGIN_MEASURE,
									END_MEASURE: dataObj[0].END_MEASURE,
									ROUTE_ID: dataObj[0].ROUTE_ID,
									SHEET_ID: dataObj[0].ID,
									STO_ILI_INSP_EVENT_ID:dataObj[0].STO_ILI_INSP_EVENT_ID,
									ROUTE_DESCR:dataObj[0].ROUTE_DESCR,//проброс в запрос на получение заголовка грида
									PARENT_DESCR: ili_label
								},
								gridId: eventParamsObj.layerid+"_LIST",
								label: panelTitle,
								parentRoughFilter: parentRoughFilter,
								parentRoughParams: parentData,
								staticParentRoughFilter: preParentFilter,
								fullLayerId: 'STO_Layers.xml#'+eventParamsObj.layerid,
								parentGrid: currentGrid.id,
								position: position,//3-я по очереди
								reload: true,
								forceTopFilter: true,
							}, function(childGridId){
								var ch = childGridId+'|'+eventParamsObj.layerid+'|'+curRowData.ID
								$(currentGrid).data('gridChild', ch );
							});
							if(openInSameTab)
								GridUtil.closeTab(selectedIndex);
						}
						break;
					case 'showDetailEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var preParentFilter = undefined;
							var fullLayerId = '';
							var parentRoughParams = curRowData;
							var parentData = undefined;
							if(gridWidget) {
								preParentFilter = gridWidget.staticParentRoughFilter;
								fullLayerId = gridWidget.fullLayerId;
								parentData = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams : [];
								parentRoughParams.PARENT_FULL_LAYER_ID = fullLayerId.replace('*','#');
								parentRoughParams.PARENT_GRID_TITLE = gridWidget.title;
								parentRoughParams.PARENT_GRID_FILTER = gridWidget.dataAdapter.currentGridDescr.currentFilter;
								parentRoughParams.PARENT_GRID_ROW_ID = dataObj[0].ID;
								parentData.push(parentRoughParams)
							}
							var parentRoughFilter = '';
							if(eventParamsObj.layerid.indexOf('SUTSTPA') !== -1){
								var layers = (eventParamsObj.layerid)? eventParamsObj.layerid.split('|'):[];
								var grids = (eventParamsObj.gridid)? eventParamsObj.gridid.split('|'):[];
								var panelTitles = (eventParamsObj.paneltitle)? eventParamsObj.paneltitle.split('|'):[];
								var descrColumns = (eventParamsObj.descrcolumns)? eventParamsObj.descrcolumns.split('|'):[];
								if(descrColumns && descrColumns.length > 0){
									var pFilterArr = [];
									descrColumns.forEach(function(col){
										var val = curRowData[col.toUpperCase()];
										if(val) val = val.xmlEscape();
										if(col=== 'sql_query')
											pFilterArr.push(val);
										else
											pFilterArr.push(col + "='" + val + "'");
										//data[col] = curRowData[col.toUpperCase()];
									})
									if(pFilterArr.length > 0)
										parentRoughFilter = pFilterArr.join(' and ');
								}
								layers.forEach(function(layerName, i){
									var childFullLayerId = layerName;
									if(layerName.indexOf('#') === -1){
										var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(layerName);
										childFullLayerId = (layer && layer.layerQueryId) ? layer.layerQueryId + '#' + layerName : '';
									}
									else layerName = layerName.split('#')[1];
									var gridId = layerName + '_LIST';
									if(grids[i]) gridId = grids[i];
									var panelTitle = (panelTitles[i])?panelTitles[i]:'';
									//удаляем все формы фильтра для дашбордов
									var filterMap = i === 0;
									$('.search-engine-filters__grid').remove();
									ExternalInteraction.openGrid({
										singleTab: true, /// открывать грид только в одной гладке в TabManager
										parentRoughFilter: parentRoughFilter,
										parentRoughParams: parentData,
										staticParentRoughFilter: preParentFilter,
										gridId: gridId,
										label: panelTitle,
										fullLayerId: childFullLayerId,
										parentGrid: currentGrid.id,
										reload: true,
										forceTopFilter: true,
										showDashboard: (WidgetMap && WidgetMap.config && WidgetMap.config.dashboard && WidgetMap.config.dashboard.showDashboard === false)?false:true,
										ignoreLabelColumn: false,
										filterMap: filterMap,
									});
								})
							}
						}
						break;
					case 'showDetailKranSvodEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var parentRoughFilter = '';
							if(eventParamsObj.layerid.indexOf('SUTSTPA') !== -1){
								var layers = (eventParamsObj.layerid)? eventParamsObj.layerid.split('|'):[];
								var panelTitles = (eventParamsObj.paneltitle)? eventParamsObj.paneltitle.split('|'):[];
								var descrColumns = (eventParamsObj.descrcolumns)? eventParamsObj.descrcolumns.split('|'):[];
								if(descrColumns && descrColumns.length > 0){
									var pFilterArr = [];
									descrColumns.forEach(function(col){
										var val = curRowData[col.toUpperCase()];
										if(val) val = val.xmlEscape();
										if(col=== 'sql_query')
											pFilterArr.push(val);
										else
											pFilterArr.push(col + "='" + val + "'");
										//data[col] = curRowData[col.toUpperCase()];
									})
									if(pFilterArr.length > 0)
										parentRoughFilter = pFilterArr.join(' and ');
								}
								//откарываем форму выбора диаметров
								GridUtil.showDiametersDialog(function(diams){
									layers.forEach(function(layerName, i){
										if(diams)
											parentRoughFilter = parentRoughFilter.replace('{DIAM}', diams);
										var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(layerName);
										var fullLayerId = (layer && layer.layerQueryId) ? layer.layerQueryId + '#' + layerName : '';
										var panelTitle = (panelTitles[i])?panelTitles[i]:'';
										var filterMap = i === 0;
										ExternalInteraction.openGrid({
											parentRoughFilter: parentRoughFilter,
											gridId: layerName+"_LIST",
											label: panelTitle,
											fullLayerId: fullLayerId,
											parentGrid: currentGrid.id,
											reload: true,
											forceTopFilter: true,
											filterMap: filterMap,
										});
										GridUtil.centerOnMap(layerName, parentRoughFilter);
									})
								});
							}
						}
						break;
					case 'showDetailKranUselSvodEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						if(eventParamsObj && eventParamsObj.layerid && eventParamsObj.layerid !== ''){
							var parentRoughFilter = '';
							if(eventParamsObj.layerid.indexOf('SUTSTPA') !== -1){
								var layers = (eventParamsObj.layerid)? eventParamsObj.layerid.split('|'):[];
								var panelTitles = (eventParamsObj.paneltitle)? eventParamsObj.paneltitle.split('|'):[];
								var descrColumns = (eventParamsObj.descrcolumns)? eventParamsObj.descrcolumns.split('|'):[];
								if(descrColumns && descrColumns.length > 0){
									var pFilterArr = [];
									descrColumns.forEach(function(col){
										var val = curRowData[col.toUpperCase()];
										if(val) val = val.xmlEscape();
										if(col=== 'sql_query')
											pFilterArr.push(val);
										else
											pFilterArr.push(col + "='" + val + "'");
										//data[col] = curRowData[col.toUpperCase()];
									})
									if(pFilterArr.length > 0)
										parentRoughFilter = pFilterArr.join(' and ');
								}
								//откарываем форму выбора диаметров
								GridUtil.showLpusDialog(function(lpus){
									layers.forEach(function(layerName, i){
										if(lpus)
											parentRoughFilter = parentRoughFilter.replace('{LPU}', lpus);
										var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(layerName);
										var fullLayerId = (layer && layer.layerQueryId) ? layer.layerQueryId + '#' + layerName : '';
										var panelTitle = (panelTitles[i])?panelTitles[i]:'';
										var filterMap = i === 0;
										ExternalInteraction.openGrid({
											parentRoughFilter: parentRoughFilter,
											gridId: layerName+"_LIST",
											label: panelTitle,
											fullLayerId: fullLayerId,
											parentGrid: currentGrid.id,
											reload: true,
											forceTopFilter: true,
											filterMap: filterMap,
										});
										//GridUtil.centerOnMap(layerName, parentRoughFilter);
									})
								});
							}
						}
						break;
					case 'ShowCarouselEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						var carouselForm = new CarouselForm({data:curRowData, layerName: curDataAdapter.currentGridDescr.layerId});
						carouselForm.build()
						break;
					case 'ShowMapEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						params = [{name:"mdl", value:"main_js.html"}];
						
						if(eventParamsObj.layerid === 'WATERWAY_CROSS'){
							if(curRowData.ZONE_ID !== undefined)
								params.push( {name:"ZONE_ID", value:curRowData.ZONE_ID});
						}
						else{
							//ex. objects=PODS_COMPRESSOR_STATION:13001863
							params.push( {name:"objects", value:eventParamsObj.layerid+':'+dataObj[0].ID});
							params.push( {name:"centering", value: true});
						}
						if(eventParamsObj !== undefined){
							if(eventParamsObj.task !== undefined && eventParamsObj.task !== '')
								taskName = eventParamsObj.task;
						}
							
						if(eventParamsObj.request || eventParamsObj.layerid === 'WATERWAY_CROSS' ){
							GridUtil.checkAvailableShowMap(curRowData.ZONE_ID, eventParamsObj.request, function(res){
								if(res) {
									//upd. 09.02.22 ищем координаты и масштаб водного перехода и передаем ll,z в урл, для точечной центровки в задаче
									MapUtil.getWaterwayGeoById(eventParamsObj.layerid, dataObj[0].ID, function(geo){
										if(geo){
											var minZoom = (App.config.MAP_CENTERING_MIN_ZOOM) ? Number(App.config.MAP_CENTERING_MIN_ZOOM) : 18;
											if (minZoom > 18 /* в 1см 13м */)
												minZoom = 18;
											params.push({name:'ll', value: geo.join()});
											params.push({name:'z', value: minZoom});
											GridUtil.showOnMap(taskName, params);
										}
										else App.confirmDialog(gis_gridwidget_158, null, {title: gis_core_1});
									});
								}
								else App.confirmDialog(gis_gridwidget_158, null, {title: gis_core_1});
							});
						}
						else
							GridUtil.showOnMap(taskName, params)
						
						break;
					case 'ShowCasEvent':
						if(dataObj[0] === undefined) break;
						var curRowData = dataObj[0];
						var stationBegin = curRowData.STATION_BEGIN;
						var stationEnd =  curRowData.STATION_END;
						if( stationBegin === undefined || stationEnd === undefined){
							if(curRowData.STATION !== undefined){
								var station = parseFloat(curRowData.STATION);
								//для километров выставляем +/- 300 метров от station
								stationBegin = (station - 0.3).toFixed(2);
								stationEnd = (station + 0.3).toFixed(2);
							}
							else{
								App.errorReport(gis_gridwidget_46, gis_gridwidget_49, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_64'});
								return;
							}
						}
						if(eventParamsObj && eventParamsObj.task)
							taskName = eventParamsObj.task;
						if(eventParamsObj && eventParamsObj.layerid === 'WATERWAY_CROSS'){
							params = {
								lineId: curRowData.LINE_ID,
								beginKm: stationBegin,
								endKm: stationEnd,
								ZONE_ID: curRowData.ZONE_ID,
								title: gis_head55_4,
							}
							var profileChooserForm  = new CASProfileChooserForm({
								zoneId:  curRowData.ZONE_ID,
								callback: function(profiles){
									//TODO добавить обработку выбранных профилей
									params.PROFILES = encodeURIComponent(JSON.stringify(profiles));
									GridUtil.showOnCas(taskName, params);
								}
							});
							profileChooserForm.build();
						}
						else{
							params = {
								lineId: curRowData.LINE_ID,
								beginKm: stationBegin,
								endKm: stationEnd,
							}
							GridUtil.showOnCas(taskName, params);
						}

						break;
					//вызов задачи 'Отвязать репер' Разрыв связи репера с точкой на карте
					case 'UnlinkReperEvent':
						if(dataObj[0] === undefined || dataObj[0].ID === undefined) break;
						function fault(inputXmlStr){
						}
						function result(inputXmlStr){
						}
						sendingData = '<data ID="' + dataObj[0].ID + '" />';
						var userId = Auth.getUserId();
						var userLogin = Auth.getUserName();
						requestParams = {
							descrId: 'GAZPROM_ADM_SEM.xml#VTD_CORR_UNLINK',
							descrType: 'insert',
							data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' + sendingData + '</root>'
						};
						App.serverQueryXMLNodeWithTries(Services.processQueryNode, requestParams, result, fault);
					break;
					//Выполнение произвольных команд с передачей в них выбранных идентификаторов
					case 'ExecuteQueryEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						var requestId = eventParamsObj['request'];
						var selectedIds = [dataObj[0]["ID"]];
						GridUtil.executeQuery(requestId, 'insert', selectedIds, function(){
							layerId = curDataAdapter.currentGridDescr.layerId;
							var selectedObject = layerId + ':' + selectedIds.join();
							App.syncManager.callSync(selectedObject,'grid', undefined, SyncTypes.TYPE_3);
							App.confirmDialog(gis_gridwidget_157, null, {title:gis_core_1});
						});
						break;
					//Выполнение произвольных запросов с передачей в них выбранных идентификаторов и результат выводить в excel
					case 'ExecuteExcelQueryEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						var requestId = eventParamsObj['request'];
						var selectedIds = [dataObj[0]["ID"]];
						GridUtil.executeExcelQuery(requestId, 'select', selectedIds);
						break;
					//показ окна выбора гридов для "проваливания" внутрь
					case 'ListChooserEvent':
						if(dataObj[0] === undefined) break;
						//запрашиваем данные из нашего сервиса (используем полученные из описания грида параметры)
						if(eventParamsObj && eventParamsObj.listrendererparams) {
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var preParentFilter = undefined;
							var fullLayerId = '';
							var parentRoughParams = dataObj[0];
							var parentData = undefined;
							if(gridWidget) {
								preParentFilter = gridWidget.parentRoughFilter;
								fullLayerId = gridWidget.fullLayerId;
								// если был открыт родителем
								parentData = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams : [];
								parentRoughParams.PARENT_FULL_LAYER_ID = fullLayerId.replace('*','#');
								parentRoughParams.PARENT_GRID_TITLE = gridWidget.title;
								parentRoughParams.PARENT_GRID_FILTER = gridWidget.dataAdapter.currentGridDescr.currentFilter;
								parentRoughParams.PARENT_GRID_ROW_ID = dataObj[0].ID;
								parentData.push(parentRoughParams)
							}
							var position = [event.clientX, event.clientY];//[event.x, event.y];

							//отправляем в фильтр значения в колонках в качестве параметров <var>
							GridUtil.showGridListForm(eventParamsObj.listrendererparams, position, function(selectedGridObj){
								//var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(selectedGridObj.layerId);
								var childFullLayerId = selectedGridObj.layerId;
								//upd. 14.02.22 возможность указать отдельный фильтр для каждой кнопки
								parentRoughFilter = GridUtil.composeFilterStrByData(selectedGridObj.filter, dataObj[0]);
								ExternalInteraction.openGrid({
									singleTab: true, /// открывать грид только в одной гладке в TabManager
									parentRoughFilter: parentRoughFilter,
									parentRoughParams: parentData,
									staticParentRoughFilter: preParentFilter,
									gridId: selectedGridObj.gridId,
									label: selectedGridObj.title,
									fullLayerId: childFullLayerId,
									parentGrid: currentGrid.id,
									reload: true,
									forceTopFilter: true,
									showDashboard: (WidgetMap && WidgetMap.config && WidgetMap.config.dashboard && WidgetMap.config.dashboard.showDashboard === false)?false:true,
									ignoreLabelColumn: false,
									filterMap: true,
								});
							});
						}
						break;
				}
			}

			/* ГРУППОВАЯ КНОПКА ГРИДА. Если есть свойство clickevent - значит это вызов с групповой кнопки грида. Нужно обработать вызов согласно clickevent
			 Типы clickevent: ru.corelight.business.events.GridFilterEvent, ru.corelight.business.events.ExportToGPXEvent, ru.corelight.business.events.CreateObjectEvent,
			 ru.corelight.business.events.ShowOnMapEvent, ru.corelight.business.events.ExportToExcelEvent, ru.corelight.business.events.RemoveGridRowEvent
			 */
			if (eventParamsObj.hasOwnProperty('clickevent')) {
				if (GridButtonsWithPopup && GridButtonsWithPopup.indexOf(eventParamsObj['clickevent']) !== -1)
					widgetMoveWindowToPosition('grid','restore_default');
				switch (eventParamsObj['clickevent']) {
					/*началоо задач по шурфовкам*/
					/*грид "годовой план шурфовок"*/
					//ГРУППА.ПЕРЕЙТИ НА УРОВЕНЬ ВВЕРХ из потомка грида
					case 'showDetailFromChildEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования из отдельной ведомости шурфовок
						var ili_label = '';
						var lblSelector = $('#btngrouptoolbardiv_'+currentGrid.id);//btngrouptoolbardiv_jqxgridid4504_GRID
						if(lblSelector.length > 0){
							var titleDiv = lblSelector.parent().find('.toolbar-title-grid');
							if(titleDiv.length)
								ili_label = titleDiv.text();
						}

						var topFilter = curDataAdapter.currentGridDescr.topFilter;
						var duplicateGrid = (WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true)
						if(eventParamsObj){
							var panelTitle = eventParamsObj.paneltitle;
							var parentGrid = $(currentGrid).data('parentGrid');
							var data = {};
							if(topFilter){
								topFilter.forEach(function(item){
									data[item.name] = item.value
									/*if(item.name === "ILI_INSP_FILTER" || item.name === "ILI_INSPECTION_ID")
										iliInspFilter = item.value;*/
									if(item.name === 'PARENT_DESCR')// если пришла шапка от родителя, то в него же и пробрасываем назад
										ili_label = item.value;
								});
							}
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							var parentFullLayerId = '', parentLayerId = '';
							if(gridWidget) {
								parentFullLayerId = (gridWidget.parentRoughParams)?gridWidget.parentRoughParams.PARENT_FULL_LAYER_ID:'';
								parentLayerId = parentFullLayerId.split('#')[1];
								panelTitle = (gridWidget.parentRoughParams)?gridWidget.parentRoughParams.PARENT_GRID_TITLE:'';
							}
							var fullLayerId = parentFullLayerId;
							ExternalInteraction.openGrid({
								data: data,
								gridId: parentLayerId+"_LIST",
								label: panelTitle,
								fullLayerId: fullLayerId,
								childGrid: currentGrid.id,
								position: -1,
								reload: true,
								forceTopFilter: true,
							}, function(parentGridId){
								$(currentGrid).data('parentGrid', 'jqxgrid' + parentGridId );
							});
						}
						else
							App.confirmDialog(gis_gridwidget_138)
						break;
					//ГРУППА. Показать всё. Для случая открытия грида из родительского
					case 'showAllDataEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования из отдельной ведомости шурфовок
						GridUtil.emulateShowAllClick(currentGrid.id, false, false);
						break;
					//ГРУППА. Перейти на уровень вверх
					case 'showParentGridEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования из отдельной ведомости шурфовок
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var gridWidget = App.GridManager.getByGridId(widgetElementId);
						var staticParentRoughFilter = undefined;
						var parentFullLayerId = '', parentLayerId = '', panelTitle = '';
						var parentData = undefined;
						var parentGridFilter = undefined;
						var parentGridRowId = undefined;//идентификатор родителя, чтобы его выделить при переходе
						if(gridWidget) {
							staticParentRoughFilter = gridWidget.staticParentRoughFilter;
							//забираем последний элемент - это первый родитель
							var parentParams = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams.pop():{};
							parentData = gridWidget.parentRoughParams;
							parentFullLayerId = parentParams.PARENT_FULL_LAYER_ID || '';
							panelTitle = parentParams.PARENT_GRID_TITLE || '';
							parentGridFilter = parentParams.PARENT_GRID_FILTER;
							parentGridRowId = parentParams.PARENT_GRID_ROW_ID;
							parentLayerId = parentFullLayerId.split('#')[1];
						}
						if(!parentFullLayerId){
							App.confirmDialog(gis_gridwidget_138, null, {title: gis_core_1});
							break;
						}
						//TODO временно тут удаляем прошлый фильтр
						$('.search-engine-filters__grid').remove();
						ExternalInteraction.openGrid({
							gridId: parentLayerId + "_LIST",
							label: panelTitle,
							parentGridFilter: parentGridFilter,
							parentGridRowId: parentGridRowId,
							fullLayerId: parentFullLayerId,
							parentRoughFilter: staticParentRoughFilter,
							parentRoughParams: parentData,
							reload: true,
							forceTopFilter: true,
							singleTab: true,
							showDashboard: (WidgetMap && WidgetMap.config && WidgetMap.config.dashboard && WidgetMap.config.dashboard.showDashboard === false)?false:true,
						});
						break;
					//ГРУППА.ПЕРЕЙТИ НА УРОВЕНЬ ВВЕРХ  из списка ведомостей и списка дефектов у ведомости
					case 'shurfDetailFromSheetEvent':// открытие грида с перечнем всех ведомостей для конкретного обследования из отдельной ведомости шурфовок
						var ili_label = '';
						var lblSelector = $('#btngrouptoolbardiv_'+currentGrid.id);//btngrouptoolbardiv_jqxgridid4504_GRID
						if(lblSelector.length > 0){
							var titleDiv = lblSelector.parent().find('.toolbar-title-grid');
							if(titleDiv.length)
								ili_label = titleDiv.text();
						}
						var topFilter = curDataAdapter.currentGridDescr.topFilter;
						var iliInspFilter = '';
						var yearInspFilter = '';
						if(topFilter){
							topFilter.forEach(function(item){
								if(item.name === "ILI_INSP_FILTER" || item.name === "ILI_INSPECTION_ID"){
									if(item.value)
										iliInspFilter = item.value;
								}
								if(item.name === 'PARENT_DESCR')// если пришла шапка от родителя, то в него же и пробрасываем назад
									ili_label = item.value;
								if(item.name === 'YEAR_INSP')// если пришла шапка от родителя, то в него же и пробрасываем назад
									yearInspFilter = item.value;
							});
						}
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						var gridWidget = App.GridManager.getByGridId(widgetElementId);
						var staticParentRoughFilter = undefined;
						var parentFullLayerId = '', parentLayerId = '', panelTitle = '';
						var parentData = undefined;
						if(gridWidget) {
							staticParentRoughFilter = gridWidget.staticParentRoughFilter;
							//забираем последний элемент - это первый родитель
							var parentParams = (gridWidget.parentRoughParams && gridWidget.parentRoughParams.length) ? gridWidget.parentRoughParams.pop():{};
							parentData = gridWidget.parentRoughParams;
							parentFullLayerId = parentParams.PARENT_FULL_LAYER_ID || '';
							panelTitle = parentParams.PARENT_GRID_TITLE || '';
							parentLayerId = parentFullLayerId.split('#')[1];
						}
						if(!parentFullLayerId){
							App.confirmDialog(gis_gridwidget_138, null, {title: gis_core_1});
							break;
						}
						if(!iliInspFilter) {
							App.confirmDialog(gis_gridwidget_138, null, {title: gis_core_1});
						}
						else{
							var data = {};
							if(parentFullLayerId.indexOf('PODS_STO_SHURF_PLAN') !== -1){
								data.YEAR_INSP = yearInspFilter;
							}
							else{
								data.ILI_INSP_FILTER = iliInspFilter;
								data.ILI_LBL = ili_label;//проброс в запрос на получение заголовка грида,
							}
							ExternalInteraction.openGrid({
								data: data,
								gridId: parentLayerId + "_LIST",
								label: panelTitle,
								parentRoughFilter: staticParentRoughFilter,
								parentRoughParams: parentData,
								fullLayerId: parentFullLayerId,
								childGrid: currentGrid.id,
								position: (parentFullLayerId.indexOf('PODS_STO_SHURF_PLAN') !== -1) ? 0 : 1,
								reload: true,
								forceTopFilter: true,
							}, function(parentGridId){
								$(currentGrid).data('parentGrid', 'jqxgrid' + parentGridId );
							});
						}

						break;
					//ГРУППА.вызов задачи 'Экспорт в эксель в задаче шурфовки'
					case 'exportToExcelFuturePlanEvent':
						//забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
						limitExportExcel = NaN;
						if (curDataAdapter.currentGridDescr.excelMaxExport!==undefined && curDataAdapter.currentGridDescr.excelMaxExport!==null && !isNaN(curDataAdapter.currentGridDescr.excelMaxExport)) {
							limitExportExcel = parseInt(curDataAdapter.currentGridDescr.excelMaxExport);
						} else if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
							limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						// isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
						if (limitExportExcel && !isNaN(limitExportExcel) && dataObj.length > limitExportExcel)
						{
							alertForm.width = 350;
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+gis_gridwidget_18+limitExportExcel+".<br/>"
								+gis_gridwidget_19+limitExportExcel+gis_gridwidget_20,gis_gridwidget_21);
							//Устанавливаем реальный лимит, который прописан в конфиге, чтобы избежать ошибки сервера (во флеше нельзя было выбрать более 1000 записей в принципе)
							dataObj = dataObj.slice(0,limitExportExcel);
						}
						else
						{
							//Вместо dataObj.length выводим общее число записей грида
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+ gis_gridwidget_22,gis_gridwidget_23);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_FUTURE_PLAN_LIST";
								extDataId = "STO_EXPORT.xml#STO_FUTURE_PLAN_LIST";
								ExportUtil.exportShurfToExcel(dataObj, fileName, layerId, extDataId); //excelTemplate для группы всегда "server_export"
							}
						});
						break;
					//ГРУППА.вызов задачи 'Редактировать характеристики трубопровода'
					case 'editRouteOptionsEvent':
						if(dataObj[0] === undefined)
							break;
						var routeIds = [];
						var lineIds = [];
						dataObj.forEach(function(value){
							if(value.ROUTE_ID) routeIds.push(value.ROUTE_ID);
							if(value.LINE_ID) lineIds.push(value.LINE_ID);
						});

						var smallLayerId = 'PODS_STO_PIPE_SEGMENT_PARAMS';
						var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(smallLayerId);
						if (layer !== undefined && layer.filter !== '') {
							var rr = [];
							rr.push({name: "LINE_ID", value: lineIds.join(), layerName: smallLayerId});
							WidgetMap.currentRoughFilter = rr;
							WidgetMap.currentFilter[smallLayerId] = [];
							WidgetMap.currentFilter[smallLayerId].push({
								layerName: smallLayerId,
								filter: 'LINE_ID',
								value: lineIds.join()
							});
							if (goog.isDefAndNotNull(WidgetMap.layerManager)) {
								curDataAdapter.currentGridDescr.layerManager.clearLayer(smallLayerId, true);
								//curDataAdapter.currentGridDescr.layerManager.enableLayer(smallLayerId);
								layer.layer.setVisible(true);
							}
						}

						ExternalInteraction.openGrid({
							data: {
								ROUTE_ID_FILTER:routeIds.join()
							},
							gridId: "PODS_STO_PIPE_SEGMENT_PARAMS_LIST",
							label: 'Опросный лист',
							fullLayerId: 'PODS_INSP_Layers.xml#PODS_STO_PIPE_SEGMENT_PARAMS'
						});
						break;
					//ГРУППА.Сформировать MapInfo-комплект
					case 'createMapInfoShurfEvent':
						if(dataObj[0] === undefined)
							break;
						var inspectionIds = [];
						dataObj.forEach(function(value){
							if(value.ID)
								inspectionIds.push(value.ID);
						});
						ExportUtil.exportAdmPicketingToExcel([{ILI_INSP_FILTER:inspectionIds.join()}], 'server_export', 'STO_EXPORT.xml#STO_ILI_MAPINFO');
						break;
					//ГРУППА.вызов задачи 'Рассчитать срок проведения следующей ВТД'(Удалена)
					case 'calcFutureDateILIEvent':
						alert("вызов задачи 'Рассчитать сок проведения следующей ВТД");
						break;
					//ГРУППА.вызов задачи 'Сформировать сводную таблицу планирования ВТД'(Удалена)
					case 'createILIFormPlanEvent':
						alert("вызов задачи 'Сформировать сводную таблицу планирования ВТД");
						break;

					/*Грид "Ведомость аномалий"*/
					//ГРУППА.задача "добавить дефект"
					case 'addShurfEvent':
						if(curDataAdapter.currentGridDescr !== undefined){
							var rows = GridUtil.getFullRowsData(currentGrid);
							var gridSTOILIDataListForm = new GridSTOILIDataListForm({
								gridId:currentGrid.id,
								dataProvider:'STO_SEM.xml#PODS_STO_ILI_DATA_SHEET_ADD',
								items: rows,
								layerId:curDataAdapter.currentGridDescr.layerId,
								filter:curDataAdapter.currentGridDescr.topFilter,
								applyCallback:function(array){
									var allDatas = array;

									//в цикле сохраняем все записи из грида
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_55,allDatas,that,
										function (obj) {
											//Заведомо обнуляем поля перед сохранением
											delete obj.TYPE;
											delete obj.DESCRIPTION;
											delete obj.COMMENTS;
											//у ремонтов доп. поля
											var prvd = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST';
											if(curDataAdapter.currentGridDescr.layerId === "PODS_STO_REPAIR_SHEET_RELOAD"){
												delete obj.WIDTH;
												delete obj.LENGTH;
												prvd = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
											}
											var reqParams = DBUtil.getReqParams(prvd, DBUtil.serializeData(obj), 'insert');
											BlockingUtil.wait();
											currentMessageId = App.serverQueryXMLNode(Services.processQueryNode, reqParams, onShurfResult, onShurfFault);
										},
										function(){
											refreshGridAfterProcEnd(curDataAdapter.currentGridDescr.layerId, []);
										}, cancelShurfProcess, true);
								}
							});
							gridSTOILIDataListForm.build();
						}
						break;
					//ГРУППА.задача "выполнить анализ для определения дефектов подлежащих шурфовке"
					case 'gridColorFilterEvent':
						var rows = GridUtil.getFullRowsData(currentGrid);
						if(rows.length == 0){
							App.confirmDialog(gis_gridwidget_80);
							break;
						}
						if(curDataAdapter.currentGridDescr !== undefined){
							var сolorFilterForm = new ColorFilterForm({
								items: rows,
								currentGridDescr:curDataAdapter.currentGridDescr,
								currentGrid: currentGrid,
								colorRowValidations: curDataAdapter.currentGridDescr.colorRowValidations,
								colorValidations: curDataAdapter.currentGridDescr.colorValidations,
								closeCallback: that.onColorFilterFormClose,
								gridThat: that
							});
							сolorFilterForm.build(currentGrid.id+'_gridColorFilter');
						}
						break;
					//ГРУППА.вызов задачи 'Сформировать схему шурфовок'
					case 'createShurfSchemaEvent':
						var dObj = {};
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "ILI_INSPECTION_ID" || item.name === "BEGIN_MEASURE" || item.name === "END_MEASURE" ||
									item.name === "ROUTE_ID" || item.name === "SHEET_ID")
									dObj[item.name] = item.value;
							});
						}
						/*params.push({name:'ILI_INSPECTION_ID', value:dObj.ILI_INSPECTION_ID});
						params.push({name:'BEGIN_MEASURE', value:dObj.BEGIN_MEASURE});
						params.push({name:'END_MEASURE', value:dObj.END_MEASURE});
						params.push({name:'ROUTE_ID', value:dObj.ROUTE_ID});
						params.push({name:'EVENT_ID', value:dObj.EVENT_ID});*/
						var ssstr = 'shurf_schema_js.html?task=sto_shurf_schema&mdl=main_js.html&rand=46565.01184217632'
							+'&ILI_INSPECTION_ID='+dObj.ILI_INSPECTION_ID+'&BEGIN_MEASURE='+dObj.BEGIN_MEASURE+'&END_MEASURE='+dObj.END_MEASURE
							+'&ROUTE_ID='+dObj.ROUTE_ID+'&SHEET_ID='+dObj.SHEET_ID
							+'#login=editor&UID=e0e513c6-f802-4ae0-8129-df1d8087bfc2&chk=96383555b5bd11140c528aaade1227b5&ID=1045';
						window.open(ssstr);
						/*App.openTask('sto_shurf_schema', Auth.getAuthStr(),{
							ILI_INSPECTION_ID: dObj.ILI_INSPECTION_ID,
							BEGIN_MEASURE:dObj.BEGIN_MEASURE,
							END_MEASURE:dObj.END_MEASURE,
							ROUTE_ID:dObj.ROUTE_ID,
							SHEET_ID:dObj.SHEET_ID
						});*/
						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость ремонтов'
					case 'exportExcelRepairSheetEvent':
						var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
						var dObj = (firstElement.ID)?GridUtil.getFullRowDataById(currentGrid, firstElement):firstElement;
						var inspectionId = undefined;
						if(!dObj || !dObj.ID)
							break;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;

						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_REPAIR_LIST";
								extDataId = "STO_EXPORT.xml#STO_REPAIR_LIST";
								ExportUtil.exportToExcel([{ID: dObj.SHEET_ID}], fileName, layerId, extDataId);
							}
						});
						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость шурфовок'
					case 'exportExcelShurfSheetEvent':
						var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
						var dObj = (firstElement.ID)?GridUtil.getFullRowDataById(currentGrid, firstElement):firstElement;
						var sheetId = undefined;
						if(!dObj || !dObj.SHEET_ID)
							break;
						sheetId = dObj.SHEET_ID;
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail == 1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_ANOM_LIST";
								extDataId = "STO_EXPORT.xml#STO_ANOM_LIST";
								ExportUtil.exportToExcel([{ID:sheetId}], fileName, layerId, extDataId);
							}
						});
						break;
					//ГРУППА.Сохранить вариант ведомости шурфовок
					case 'createExcavateSheetEvent':
						//ищем ILI_INPECTION_ID и EVENT_ID, чтобы передать дальше в панель свойств
						var sheetObj = {};
						var rangeData = {};
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							rangeData = GridUtil.formatTopFilterToObject(curDataAdapter.currentGridDescr.topFilter);
							sheetObj.ILI_INSPECTION_ID = rangeData.ILI_INSPECTION_ID;
							sheetObj.STO_ILI_INSP_EVENT_ID = rangeData.STO_ILI_INSP_EVENT_ID;
						}
						var gridSheetForm = new GridSTOSheetForm({
							data:sheetObj,
							sheetType:'excavate',
							applyCallback:function(sheetId){
								var rows = GridUtil.getFullRowsData(currentGrid);
								var allDatas = rows;
								//добавляем к каждой записи атрибут SHEET_ID для вставки
								allDatas.forEach(function(value){
									value.SHEET_ID = sheetId;
								});
								rangeData.SHEET_ID_OLD = rangeData.SHEET_ID;
								rangeData.SHEET_ID = sheetId;

								var topFilter = curDataAdapter.currentGridDescr.topFilter;
								var ili_label = '';
								if(topFilter){
									topFilter.forEach(function(item){
										if(item.name === 'PARENT_DESCR')// если пришла шапка от родителя, то в него же и пробрасываем назад
											ili_label = item.value;
									});
								}
								var reqParams = DBUtil.getReqParams('STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH_RECREATE', DBUtil.serializeData(rangeData), 'insert');
								App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
									BlockingUtil.ready();
									if (resultXML) {
										var er = HTTPServiceUtil.getError(resultXML);
										if (er !== ""){
											App.errorReport(gis_gridwidget_82, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_50'});
											return;
										}
										var duplicateGrid = (WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.duplicate === true)
										ExternalInteraction.openGrid({
											data: {
												ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
												BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
												END_MEASURE: rangeData.END_MEASURE,
												ROUTE_ID: rangeData.ROUTE_ID,
												SHEET_ID: sheetId,
												STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
												ROUTE_DESCR:rangeData.ROUTE_DESCR,//проброс в запрос на получение заголовка грида
												PARENT_DESCR:rangeData.PARENT_DESCR//проброс в запрос на получение заголовка родительского грида грида
											},
											gridId: eventParamsObj.gridid+"_LIST",
											label: gis_gridwidget_73,
											fullLayerId: 'STO_Layers.xml#'+eventParamsObj.gridid,
											position: 2,
											reload: true,
											forceTopFilter: true,
										});

									}
								}, function (resultXML) {
									BlockingUtil.ready();
									var er = HTTPServiceUtil.getError(resultXML);
									if (er !== "")
										App.errorReport(gis_gridwidget_82, gis_gridwidget_8 + er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_51'});
								});
							}
						});
						gridSheetForm.buildNewSheet_();
						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость МТР'
					case 'createMTRSheetEvent':
						if(dataObj[0] === undefined)
							break;
						//Добавляем div панели свойств текущего грида
						//ищем ILI_INPECTION_ID и EVENT_ID, чтобы передать дальше в панель свойств
						var sheetObj = {};
						var rangeData = {};
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							rangeData = GridUtil.formatTopFilterToObject(curDataAdapter.currentGridDescr.topFilter);
							sheetObj.ILI_INSPECTION_ID = rangeData.ILI_INSPECTION_ID;
							sheetObj.STO_ILI_INSP_EVENT_ID = rangeData.STO_ILI_INSP_EVENT_ID;
						}
						var gridSheetForm = new GridSTOSheetForm({
							iliDataId:sheetObj.ILI_INSPECTION_ID,
							data:sheetObj,
							sheetType:'mtr',
							applyCallback:function(sheetId){
								if(sheetId !== undefined){
									App.notSupportedDialog('Нет возможности открыть ведомость созданную МТР, т.к. данный функционал не реализован');
								}
							}
						});
						gridSheetForm.buildNewSheet_();
						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость ремонтов'
					case 'createRepairSheetEvent':
						if(dataObj[0] === undefined)
							break;
						//Добавляем div панели свойств текущего грида
						//ищем ILI_INPECTION_ID и EVENT_ID, чтобы передать дальше в панель свойств
						var sheetObj = {};
						var rangeData = {};
						if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
							//получаем из фильтра, который пришел от родительского грида
							rangeData = GridUtil.formatTopFilterToObject(curDataAdapter.currentGridDescr.topFilter);
							sheetObj.ILI_INSPECTION_ID = rangeData.ILI_INSPECTION_ID;
							sheetObj.STO_ILI_INSP_EVENT_ID = rangeData.STO_ILI_INSP_EVENT_ID;
						}
						var gridSheetForm = new GridSTOSheetForm({
							iliDataId:sheetObj.ILI_INSPECTION_ID,
							data:sheetObj,
							sheetType:'repair',
							applyCallback:function(sheetId){
								if(sheetId !== undefined){
									var allDatas = dataObj;
									allDatas.forEach(function(value){
										//value.ILI_DATA_ID = value.ID;
										value.SHEET_ID = sheetId;
									});
									//в цикле сохраняем все записи из грида
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_55,allDatas,that,
										function (obj) {
											//Заведомо обнуляем поля перед сохранением
											delete obj.TYPE;
											delete obj.DESCRIPTION;
											delete obj.COMMENTS;
											//у ремонтов доп. поля
											delete obj.WIDTH;
											delete obj.LENGTH;
											var prvd = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
											var reqParams = DBUtil.getReqParams(prvd, DBUtil.serializeData(obj), 'insert');
											BlockingUtil.wait();
											currentMessageId = App.serverQueryXMLNode(Services.processQueryNode, reqParams, onShurfResult, onShurfFault);
										},
										function(){
											ExternalInteraction.openGrid({
												data: {
													ILI_INSPECTION_ID: rangeData.ILI_INSPECTION_ID,
													BEGIN_MEASURE: rangeData.BEGIN_MEASURE,
													END_MEASURE: rangeData.END_MEASURE,
													ROUTE_ID: rangeData.ROUTE_ID,
													SHEET_ID: sheetId,
													STO_ILI_INSP_EVENT_ID:rangeData.STO_ILI_INSP_EVENT_ID,
													ROUTE_DESCR:rangeData.ROUTE_DESCR//проброс в запрос на получение заголовка грида
												},
												gridId: eventParamsObj.gridid+"_LIST",
												label: gis_gridwidget_74,
												fullLayerId: 'STO_Layers.xml#'+eventParamsObj.gridid,
												position: -1,
												reload: true,
												forceTopFilter: true,
											});
											var clId = 'PODS_STO_REPAIR_SHEET_RELOAD';
											refreshGridAfterDelete(0, 1, false, clId);
											GridWidget.processStatusForm = null;
										}, cancelShurfProcess, true);
								}
							}
						});
						gridSheetForm.buildNewSheet_();

						break;
					//ГРУППА.вызов задачи 'Сформировать ведомость обследовний'
					case 'createInspectionsSheetEvent':
						//забираем SHEET_ID, который пришел извне
						var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
						var dObj = (firstElement.ID)?GridUtil.getFullRowDataById(currentGrid, firstElement):firstElement;
						var sheetId = undefined;
						if((dObj === undefined || dObj.SHEET_ID === undefined) && (curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined)){
							//получаем из фильтра, который пришел от родительского грида
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "SHEET_ID")
									sheetId = item.value;
							});
						}
						if(!sheetId && dObj && dObj.SHEET_ID)
							sheetId = dObj.SHEET_ID;
						if(!sheetId){
							App.errorReport(gis_gridwidget_53, gis_gridwidget_54, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_39'});
							break;
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;

						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_PHYS_INSP_LIST";
								extDataId = "STO_EXPORT.xml#STO_PHYS_INSP_LIST";
								ExportUtil.exportToExcel([{ID:sheetId}], fileName, layerId, extDataId);
							}
						});
						break;
					//ГРУППА.вызов задачи 'Сформировать акт дополнительного дефектоскопического контроля'
					case 'createAdditionalActDefectoscopeControlEvent':
						//забираем SHEET_ID, который пришел извне
						var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
						var dObj = (firstElement.ID)?GridUtil.getFullRowDataById(currentGrid, firstElement):firstElement;
						var sheetId = undefined;
						if((dObj === undefined || dObj.SHEET_ID === undefined) && (curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined)){
							//получаем из фильтра, который пришел от родительского грида
							curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
								if(item.name === "SHEET_ID")
									sheetId = item.value;
							});
						}
						if(!sheetId && dObj && dObj.SHEET_ID)
							sheetId = dObj.SHEET_ID;
						if(sheetId === undefined ){
							App.errorReport(gis_gridwidget_53, gis_gridwidget_54, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_40'});
							break;
						}

						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+"1.<br/>"
							+ gis_gridwidget_22,gis_gridwidget_23);
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								layerId = "STO_DOP_PHYS_LIST";
								extDataId = "STO_EXPORT.xml#STO_DOP_PHYS_LIST";
								ExportUtil.exportToExcel([{ID:sheetId}], fileName, layerId, extDataId);
							}
						});
						break;
					//ГРУППА.задача "удалить записи из списка аномалий"
					case 'deleteGroupSheetExcavateListEvent':
						try {
							dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH';
							var clId = 'PODS_STO_ILI_DATA_SHEET_RELOAD';
							if(curDataAdapter.currentGridDescr.layerId === 'PODS_STO_REPAIR_SHEET_RELOAD'){
								dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
								clId = 'PODS_STO_REPAIR_SHEET_RELOAD';
							}

							//добавляем форму выбора "удалить выбранные" либо "удалить не выбранные"
							function removeCheckedRows(){
								deletingArr = [];
								for (i = 0; i < dataObj.length; i++) {
									deletingArr.push(dataObj[i].LIST_ID);
								}
								deleteConfirmationForm = new DeleteConfirmationForm();
								deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
								var deletingIds = {ID:deletingArr.join(',')};
								//Добавляем слушатель закрытия формы
								$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
									$("body").off(CloseEvent.CLOSE);
									if (evt && evt.detail==1) {
										var reqParams = DBUtil.getReqParams('STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH', DBUtil.serializeData(deletingIds), 'delete');
										App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
											BlockingUtil.ready();
											if (resultXML) {
												var er = HTTPServiceUtil.getError(resultXML);
												if (er !== "") {
													App.errorReport(gis_gridwidget_83, gis_gridwidget_8 + er, undefined, {
														filename: gis_filename_243,
														functionname: 'gis_filename_243_52'
													});
													return;
												}
												refreshGridAfterDelete(0, deletingArr.length, false, clId, deletingArr);
											}
										},function (resultXML) {
											BlockingUtil.ready();
											var er = HTTPServiceUtil.getError(resultXML);
											if (er !== "") {
												App.errorReport(gis_gridwidget_83, gis_gridwidget_8 + er, undefined, {
													filename: gis_filename_243,
													functionname: 'gis_filename_243_53'
												});
											}
										},4);
										$(currentGrid).jqxGrid('clearselection');
									}
								});
								closeDialog();
							}
							function removeUnCheckedRows(){
								deletingArr = [];
								var rows = GridUtil.getFullRowsData(currentGrid);
								var allData = rows;
								//dataObj // тут все выбранные объекты
								//проходим по всем выделенным объектам и постепенно удаляем их из массива со всеми данными allData
								for(var item in dataObj){
									var dataId = dataObj[item].ID;
									for(var subItem in allData){
										if(allData[subItem].ID === dataId){
											allData.splice(subItem, 1);
											break;
										}
									}
								}
								for (i = 0; i < allData.length; i++) {
									deletingArr.push(allData[i].LIST_ID);
								}
								deleteConfirmationForm = new DeleteConfirmationForm();
								deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
								var deletingIds = {ID:deletingArr.join(',')};
								//Добавляем слушатель закрытия формы
								$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
									$("body").off(CloseEvent.CLOSE);
									if (evt && evt.detail==1) {
										var reqParams = DBUtil.getReqParams('STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST_BATCH', DBUtil.serializeData(deletingIds), 'delete');
										App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
											BlockingUtil.ready();
											if (resultXML) {
												var er = HTTPServiceUtil.getError(resultXML);
												if (er !== "") {
													App.errorReport(gis_gridwidget_83, gis_gridwidget_8 + er, undefined, {
														filename: gis_filename_243,
														functionname: 'gis_filename_243_54'
													});
													return;
												}
												refreshGridAfterDelete(0, deletingArr.length, false, clId, deletingArr);
											}
										},function (resultXML) {
											BlockingUtil.ready();
											var er = HTTPServiceUtil.getError(resultXML);
											if (er !== "") {
												App.errorReport(gis_gridwidget_83, gis_gridwidget_8 + er, undefined, {
													filename: gis_filename_243,
													functionname: 'gis_filename_243_55'
												});
											}
										},4);
										//Снимаем выделение, поскольку выделенные элементы будут удалены
										$(currentGrid).jqxGrid('clearselection');
									}
								});
								closeDialog();
							}
							var buttons = [
								{text:gis_gridwidget_77, click:removeCheckedRows},
								{text:gis_gridwidget_78, click:removeUnCheckedRows}
							];
							var dlg = App.confirmDialog(gis_gridwidget_79, buttons, {title:gis_core_1, width:400});

							break;


						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_41'});
						}
						break;
					//ГРУППА.задача "удалить записи из списка"
					case 'deleteGroupSheetListEvent':
						try {
							dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST';
							var clId = 'PODS_STO_SHEET_EXCAVATE_LIST';
							if(curDataAdapter.currentGridDescr.layerId === 'PODS_STO_REPAIR_SHEET_RELOAD'){
								dataRequest = 'STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST';
								clId = 'PODS_STO_SHEET_REPAIR_LIST';
							}
							deletingArr = [];
							for (i = 0; i < dataObj.length; i++) {
								deletingObject = {rowData:dataObj[i], classId:clId, objectId:dataObj[i].LIST_ID, provider:dataRequest, propertyPanelName:""};
								deletingArr.push(deletingObject);
							}
							//SHEET_ID забираем из верхнего фильтра, который пришел извне
							//если нет SHEET_ID, то это новая ведомость и удаляем только строку
							//если есть - удаляем из БД
							var sheetId = undefined;
							if(curDataAdapter.currentGridDescr !== undefined && curDataAdapter.currentGridDescr.topFilter !== undefined){
								//получаем из фильтра, который пришел от родительского грида
								curDataAdapter.currentGridDescr.topFilter.forEach(function(item){
									if(item.name === "SHEET_ID"){
										sheetId = item.value;
									}
								});
							}
							if(sheetId === undefined){
								var rowindexes = $(currentGrid).jqxGrid('getselectedrowindexes');
								$(currentGrid).jqxGrid('deleterow', rowindexes);
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_28,deletingArr,that,that.deleteObject,
										refreshGridAfterDelete, null, true);
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_41'});
						}
						break;

					/*ГРУППА.конец задачи по шурфовкам*/
					/*ГРУППА */
					case 'ManageColumnsEvent'://заглушка на добавление 1-й колонки
						var da = $(currentGrid).jqxGrid('source');
						if(da.currentGridDescr !== undefined){
							var columns = GridUtil.getGridColumns(currentGrid);
							try{
								//пробуем отменить редактирование ячейки, если было начато.
								$(currentGrid).jqxGrid('endcelledit', 0, columns[0].name, true);
							}
							catch(ex){}
							var manageGridColumnsForm = new ManageGridColumnsForm({
								columns: columns,
								applyCallback: function(columns){
									that.updateDataWithColumns(currentGrid, columns);
								}
							});
							manageGridColumnsForm.build(currentGrid.id+'_manageColumns');
						}
						break;
					//ГРУППА. обвновленная версия фильтра, которая будет отображать окошко левее с гридом
					case 'ru.corelight.business.events.ExtendedGridFilterEvent':

						break;
					case 'ru.corelight.business.events.GridFilterEvent':
						//Фильтрация грида
						var da = $(currentGrid).jqxGrid('source');
						if(da.currentGridDescr !== undefined){
							curLayerObj = da.currentGridDescr.layerManager.getLayerByName(curDataAdapter.currentGridDescr.layerId);
							var showFirstBottomFilterMessage = false;
							var gw = GridUtil.getGridWidget(currentGrid);
							if(gw) {
								showFirstBottomFilterMessage = gw.showFirstBottomFilterMessage;
								gw.showFirstBottomFilterMessage = false;
							}
							var bottomFilterForm = new BottomFilterForm();
							bottomFilterForm.showFirstBottomFilterMessage = showFirstBottomFilterMessage;
							bottomFilterForm.currentGridDescr = da.currentGridDescr;
							bottomFilterForm.currentGrid = currentGrid;
							bottomFilterForm.currentFilters = da.currentGridDescr.currentFilter;
							bottomFilterForm.topFilters = da.currentGridDescr.topFilter;
							bottomFilterForm.roughFilters = da.currentGridDescr.roughFilter;
							if (curLayerObj && curLayerObj.dataProvider && !curLayerObj.dataProvider.spatial
								|| !curLayerObj || !curLayerObj.dataProvider)
								bottomFilterForm.hasSpatial = false;
							bottomFilterForm.build(currentGrid.id+'_bottomFilter');

							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, that.onBottomFilterFormClose);
						}
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.ExportToGPXEvent':
						filterStr = undefined;
						if(dataObj.length){
							var ids = [];
							dataObj.forEach(function(curObj){
								ids.push(curObj.ID);
							})
							filterStr =  'ID IN (' + ids.join(',') + ')';
						}
						//upd. 29.10.21 сказано использовать данное событие вместо самостоятельного, чтобы не менять гриды
						GridWidget.prototype.exportImportObjectsToGpxKml(filterStr, curDataAdapter.currentGridDescr, currentGrid.id);
						break;
					//ГРУППА. Импорт/Экспорт GPX/KML
					case 'ImportExportGpxKmlEvent':
						filterStr = undefined;
						if(dataObj.length){
							var ids = [];
							dataObj.forEach(function(curObj){
								ids.push(curObj.ID);
							})
							filterStr =  'ID IN (' + ids.join(',') + ')';
						}
						GridWidget.prototype.exportImportObjectsToGpxKml(filterStr, curDataAdapter.currentGridDescr, currentGrid.id);
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.CreateObjectEvent':
						//Создаем панель свойств по классу объекта - она сохраняет новый объект
						var curObjectId = eventParamsObj["layerid"];
						var bindDataTypes = (App.config.MAP_BIND_CLASSES && App.config.MAP_BIND_CLASSES.length > 0) ? App.config.MAP_BIND_CLASSES.split(',') : [];
						if (bindDataTypes.length > 0 && bindDataTypes.indexOf(curObjectId) != -1) {
							map.controls.AddObjectControl.showBindToLineForm(curObjectId, undefined, curDataAdapter.currentGridDescr.layerManager, function(){
								GridWidget.refreshGrid(currentGrid.id, false)
							});
						}
						else{

							//Добавляем div панели свойств текущего грида
							var gridPropPanelId = 'divPPanel' + currentGrid.id;
							var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
							$('#' + gridPropPanelId).remove();
							var widgetElementId = currentGrid.id.replace("jqxgrid",'');
							var opener = "#" + widgetElementId;
							var gridWidget = App.GridManager.getByGridId(widgetElementId);
							if(WidgetMap && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.ppanel && WidgetMap.config.grid.ppanel.position === 'global'){
								opener = 'body';
								$('body').append(gridPropPanelDiv);
							}
							else{
								$('#' + widgetElementId).append(gridPropPanelDiv);
							}
							var parentParams = undefined;
							if(gridWidget){
								if(gridWidget.parentRoughParams && gridWidget.parentRoughParams.length > 0){
									parentParams = gridWidget.parentRoughParams[gridWidget.parentRoughParams.length -1];
								}
							}
							//Создаем панель свойств для текущего объекта
							$('#' + gridPropPanelId).myPropertiesPanel({
								zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
								objects:[{id: curObjectId, label: ''}],
								opener: opener,
								data: parentParams,
								openerType: 'grid',
								//panelSize: {propPanelWidth:curDataAdapter.currentGridDescr.propPanelWidth, propPanelHeight:curDataAdapter.currentGridDescr.propPanelHeight},
								handlers:{
									calculateObjectSizeCallback: function(params){

									},
									semanticCallback: function (dataObject) {
										if(dataObject.retObj && dataObject.success == true){
											var layerName = dataObject.retObj.layerId;
											var semId = dataObject.retObj.id;
											var selectedObject = layerName;
											if(semId){
												selectedObject += ':' + semId;
												//СИНХРОНИЗАЦИЯ #R5
												//25.11.2021 исправлени в рамках инц 2565
												App.syncManager.callSync(selectedObject,'grid_refresh', undefined, SyncTypes.TYPE_3);
											}
										}
									},
								}
							});
						}
						break
					//ГРУППА.
					case 'ru.corelight.business.events.CreateObjectFromMapEvent':
						//Создаем панель свойств по классу объекта - она сохраняет новый объект
						var curObjectId = eventParamsObj["layerid"];
						try{
							var roughFilter = curDataAdapter.currentGridDescr.roughFilter;
							if(WidgetMap.addObjectControl)
								WidgetMap.addObjectControl.handleAddObjectClick_({addFromTree: true, layerName: curObjectId, roughFilter:roughFilter});
						}
						catch(ex){}
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.ShowOnMapEvent':
						try {
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							if (curLayerObj==undefined || curLayerObj==null)
								break;
							//Формируем параметры для вызова функции центровки
							objectsStr = eventParamsObj["layerid"] + ":";
							var selectedItemsCount = dataObj.length;
							if(App.syncEnabled && dataObj.length > 150)//количество доступных идентификаторов для хранения в куках
								selectedItemsCount = 150;
							for (i = 0; i < selectedItemsCount; i++) {
								objectsStr += dataObj[i]["ID"];
								//К последнему ID сзади запятую не добавляем
								if (i < dataObj.length - 1) {
									objectsStr += ",";
								}
							}
							funcName = "showObjects";
							params = [{name: "objects", value: objectsStr}, {name: "select", value: true}, {name: "centering", value: true}, {name: "gridCenteringResultFunction", value: gridCenteringResultFunction},{name: "isGroupButton", value: true}];

							if(!App.syncEnabled){
								//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
								ExternalInteraction.callFunction(windowId, funcName, params);
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								widgetMoveWindowToPosition('grid');
							}
							else {
								/*var syncObjectFromCookie = App.getCookie('gis_web77_sync_select_object');
								if(syncObjectFromCookie && syncObjectFromCookie.indexOf('$') !== -1){
									var uniqueWindowId = syncObjectFromCookie.split('$')[0];
									if(uniqueWindowId === App.UNIQUE_ID);
										widgetMoveWindowToPosition('grid');
								}*/

								//1. для клика из самой вкладки делаем первоначальною центровку
								//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
								//ExternalInteraction.callFunction(windowId, funcName, params);
								//Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
								widgetMoveWindowToPosition('grid');
								//2. и параллельно отправляем событие на центровку через синхронизацию
								//СИНХРОНИЗАЦИЯ #T6
								//СИНХРОНИЗАЦИЯ #T7
								//СИНХРОНИЗАЦИЯ #T8
								var selectedObject = objectsStr;
								if (selectedObject)
									App.syncManager.callSync(selectedObject, 'grid', undefined, SyncTypes.TYPE_2);
								if(selectedItemsCount !== dataObj.length)
									App.confirmDialog(gis_gridwidget_139, null, {title:gis_core_1, width:400, html: true});
							}


						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_23'});
						}
						break;

					//ГРУППА. персональный групповой экспорт в эксель. Из кнопки передается идентификатор шаблона, в который требуется выгружать данные
					// эмуляция строчной кнопки грида
					case 'ru.corelight.business.events.GroupExportToExcelEvent':
						fileName = App.generateUUID() + ".xls";
						extDataId =  eventParamsObj.request;
						ExportUtil.exportToExcel(dataObj, fileName, eventParamsObj.layerid, extDataId, undefined, true);
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.ExportToExcelEvent':
						//забираем из конфига параметр TABLE_MAX_EXPORT_EXCEL для ограничения количества экспортируемых записей
						limitExportExcel = NaN;
						if (curDataAdapter.currentGridDescr.excelMaxExport!==undefined && curDataAdapter.currentGridDescr.excelMaxExport!==null && !isNaN(curDataAdapter.currentGridDescr.excelMaxExport)) {
							limitExportExcel = parseInt(curDataAdapter.currentGridDescr.excelMaxExport);
						} else if(App.config !== null && App.config !== undefined && App.config.hasOwnProperty('TABLE_MAX_EXPORT_EXCEL')) {
							limitExportExcel = parseInt(App.config.TABLE_MAX_EXPORT_EXCEL);
						}
						alertForm = new AlertForm();
						//Меняем кнопки на "Да" и "Нет"
						alertForm.alertOkButtonText = gis_ppanel_6;
						alertForm.alertCancelButtonText = gis_ppanel_7;
						alertForm.width = 230;
						// isNaN(limitExportExcel) - я так понимаю это спецусловие для того чтобы всегда выгружалось через второй алерт
						if (limitExportExcel && !isNaN(limitExportExcel) && dataObj.length > limitExportExcel)
						{
							alertForm.width = 350;
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+gis_gridwidget_18+limitExportExcel+".<br/>"
								+gis_gridwidget_19+limitExportExcel+gis_gridwidget_20,gis_gridwidget_21);
							//Устанавливаем реальный лимит, который прописан в конфиге, чтобы избежать ошибки сервера (во флеше нельзя было выбрать более 1000 записей в принципе)
							dataObj = dataObj.slice(0,limitExportExcel);
						}
						else
						{
							//Вместо dataObj.length выводим общее число записей грида
							alertForm.build("gridExportLimitAlertForm",gis_gridwidget_17+dataObj.length+".<br/>"
								+ gis_gridwidget_22,gis_gridwidget_23);
						}
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function gridExportLimitAlertFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							if (evt && evt.detail==1) {
								fileName = App.generateUUID() + ".xls";
								extDataId = curDataAdapter.currentGridDescr.excelDataRequest;
								ExportUtil.exportToExcel(dataObj, fileName, "server_export", extDataId); //excelTemplate для группы всегда "server_export"
							}
						});
						break;
					//ГРУППА.
					case 'CopyToExcelEvent':
						try {
							if (dataObj[0] === undefined) {
								App.confirmDialog(gis_gridwidget_129);
								break;
							}
							var idColumn = 'ID';
							var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
							if(gridWidget) {
								idColumn = gridWidget.primaryKeyField || 'ID';
							}
							GridUtil.copyToExcelEvent(curDataAdapter.currentGridDescr.gridColumns, dataObj, idColumn );
						}
						catch(ex){
						}
						break;
					//ГРУППА.
					case 'PasteFromExcelEvent':
						try {
							//jqxGridId, gridElem, dataAdapter, event
							var syncMap = (eventParamsObj && eventParamsObj.syncmap === 'true');

							that.pasteFromExcelDialog(currentGrid, curDataAdapter, syncMap);
						}
						catch(ex){
						}
						break;
					//ГРУППА.
					case 'ApplyUpdatedCellEvent':
						try {
							var syncMap = (eventParamsObj && eventParamsObj.syncmap === 'true');
							that.saveUpdatedCellDialog(currentGrid, curDataAdapter, syncMap);
						}
						catch(ex){
						}
						break;
					//ГРУППА.
					case 'TestEvent':
						var obj = dataObj;
						$(currentGrid).jqxGrid('selectrow', 31);
						$(currentGrid).jqxGrid('ensureRowVisible', 31);
						break;
					//ГРУППА.
					case 'ru.corelight.business.events.RemoveGridRowEvent':
						try {
							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							var syncMap = (eventParamsObj && eventParamsObj.syncmap === 'true');
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							if (curLayerObj==undefined || curLayerObj==null) {
								//Если слоя нет - делаем как во флеше (там ничего не происходило, даже запрос не отправлялся, здесь Володя сказал должна быть форма с сообщением)
								alertForm = new AlertForm();
								alertForm.build("gridDeleteNoLayerAlertForm",gis_gridwidget_24,gis_gridwidget_25,AlertForm.OK);
								//Чистим выделение в гриде
								$(currentGrid).jqxGrid('clearselection');
								break;
							}
							//удаление ТОЛЬКО СЕМАНТИКИ (исправить provider на dataRequest = "", чтобы прошел полный алгоритм удаления сначала геометрии затем семантики)
							dataRequest = curLayerObj.dataProvider.semantic;
							deletingArr = [];
							for (i = 0; i < dataObj.length; i++) {
								deletingObject = {rowData:dataObj[i], classId:layerId, objectId:dataObj[i]["ID"], provider:dataRequest, propertyPanelName:""};
								deletingArr.push(deletingObject);
							}

							deleteConfirmationForm = new DeleteConfirmationForm();
							deleteConfirmationForm.build("deleteConfirmationForm", deletingArr.length);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function (evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail==1) {
									GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_28,deletingArr,that,(syncMap)?that.deleteObjectWithSyncMap:that.deleteObject,
										(syncMap)?refreshGridAfterDeleteWithSyncMap:refreshGridAfterDelete, null, true);
									//Снимаем выделение, поскольку выделенные элементы будут удалены
									$(currentGrid).jqxGrid('clearselection');
								}
							});
						} catch (e) {
							App.errorReport(gis_gridwidget_27, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_24'});
						}
						break;
					//ГРУППА.
					case 'showPPanelEvent':
						//Формируем параметры для вызова функции центровки
						if (dataObj[0] === undefined) break;
						break;
					//Административные задачи
					//ГРУППА.Привязать отчет к трубе
					case 'gridAdmIliBindToRoute':
						//В форме один комбобокс начинает заполняться только после выбора значения в другом, пока такой логики в панели свойств нет
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliBindToRouteForm";
						var gridAdmIliBindToRouteForm = new GridAdmIliBindToRouteForm();
						gridAdmIliBindToRouteForm.build(gridPropPanelId);
						var sendingData,requestParams,currentTemplate;
						//Добавляем слушатель закрытия формы
						$("body").on(CloseEvent.CLOSE, function onGridAdmIliBindToRouteFormClose(evt/*CloseEvent*/) {
							$("body").off(CloseEvent.CLOSE);
							//Для этой формы в evt.detail при отмене придет -1, при ошибке выбора комбобокса придет 0 или корректное значение curRouteId в остальных случаях
							if (evt && evt.detail != -1) {
								if (evt.detail == 0)
									App.errorReport(gis_gridwidget_5, gis_gridwidget_29, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_25'});
								else {
									var curRouteId = evt.detail;
									sendingData = '<data ILI_INSPECTION_ID="' + dataObj[0].ID.xmlEscape() + '" ROUTE_ID="' + curRouteId.xmlEscape() + '"/>';
									//Получаем параметры для запроса и исправляем их на нужные нам
									var userId = Auth.getUserId();
									var userLogin = Auth.getUserName();
									requestParams = {
										descrId: 'GAZPROM_ADM_SEM.xml#BIND_ILI_INSPECTION_TO_ROUTE',
										descrType: 'update',
										data: '<root USER_ID="' + userId.xmlEscape() + '" USER_LOGIN="' + userLogin.xmlEscape() + '" PODS_USER="' + userLogin.xmlEscape() + '" >' + sendingData + '</root>'
									};
									//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
									currentTemplate = "gridAdmIliBindToRoute";
									//Устанавливаем курсор ожидания
									BlockingUtil.wait();
									//BlockingUtil.blockApplication();
									App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
								}
							}
						});
						break;
					//ГРУППА.Привязка отчета к трубе(Интенсивы)
					case 'gridAdmPiCPBindToLine':
						if (dataObj.length > 0){
							GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_141, dataObj, that,
								function processSingleBinding(curObj){
									if (curObj && curObj.hasOwnProperty("ID")){
										var userId = Auth.getUserId();
										var userLogin = Auth.getUserName();
										sendingData = '<data REPORT_ID="'+curObj.ID+'" LINE_ID="'+curObj.LINE_ID+'" STATION_BEGIN="'+curObj.STATION_BEG+'" STATION_END="'+curObj.STATION_END+'"/>';
										//Получаем параметры для запроса и исправляем их на нужные нам
										requestParams = { getSchema: false, descrId: 'UTE_SEM.xml#CALC_CALC_CP', toElements: false, descrType: 'update',
											data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" >' + sendingData + '</root>' };
										//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
										currentTemplate = "gridAdmPiCPBindToLine";
										//Устанавливаем курсор ожидания
										BlockingUtil.wait();
										App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
									}else if (GridAdmWidget.processStatusForm)
										GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
								},
								endProcess, cancelProcess, true);
						}else {
							App.errorReport(gis_gridwidget_5, gis_gridwidget_140, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_49'});
						}
						break;
					//ГРУППА.Привязка отчета к трубе(КИП)
					case 'gridAdmPiCISBindToLine':
						if (dataObj.length > 0){
							GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_141, dataObj, that,
								function processSingleBinding(curObj){
									if (curObj && curObj.hasOwnProperty("ID")){
										var userId = Auth.getUserId();
										var userLogin = Auth.getUserName();
										sendingData = '<data REPORT_ID="'+curObj.ID+'" ROUTE_ID="'+curObj.ROUTE_ID+'"/>';
										//Получаем параметры для запроса и исправляем их на нужные нам
										requestParams = { getSchema: false, descrId: 'UTE_SEM.xml#CALC_CALC_CIS', toElements: false, descrType: 'update',
											data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" >' + sendingData + '</root>' };
										//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
										currentTemplate = "gridAdmPiCISBindToLine";
										//Устанавливаем курсор ожидания
										BlockingUtil.wait();
										App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
									}else if (GridAdmWidget.processStatusForm)
										GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
								},
								endProcess, cancelProcess, true);
						}else {
							App.errorReport(gis_gridwidget_5, gis_gridwidget_140, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_49'});
						}
						break;
					//ГРУППА. Задача "ВТД. Коррекция". Пересчет отчетов.
					case 'IliReportCalcCorrEvent':
						var fakeObj = [{rowData: {ID:1}, classId:'fakeClass', objectId:'fakeId', provider:'fakeRequest', propertyPanelName:""}];
						GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_160, fakeObj, that,
							function (curObj){
								if(curObj){
									var guid = GridAdmInternal.generateProcessGUID();
									var processGuid = guid;//'78e29bcf';
									var iliInpectionId = MapUtil.getTopFilterByName('ILI_INSP_FILTER');
									if(iliInpectionId)
										iliInpectionId = iliInpectionId.value;
									var sendingData = GridAdmInternal.convertSimpleObjectToXml_({
										inspection_id: iliInpectionId, link_repers: 'N', ps_idx: 'N', process_id: processGuid,
									}); /*'<input/>';*/
									currentTemplate = "IliReportCalcCorrTemplate";
									var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
									BlockingUtil.wait();
									var currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliInspCalc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
									GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId,onResult, onFault, GridAdmInternal.cancelRequest, true);
								}
								else if (GridAdmWidget.processStatusForm)
									GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_155);
							},
							endProcess, cancelProcess, true);
						break;
					//ГРУППА. Задача "ВТД. Коррекция". Развернуть отчет ВТД и выполнить пересчет
					case 'IliReportReverseEvent':
						try{
							var iliInpectionId = MapUtil.getTopFilterByName('ILI_INSP_FILTER');
							if(iliInpectionId)
								iliInpectionId = iliInpectionId.value;
							var dataRequest = 'GAZPROM_ADM_SEM.xml#VTD_CORR_REVERSE';
							var descrType = 'insert';
							var dto = {
								ILI_INSPECTION_ID: iliInpectionId,
							}
							var alertForm = new AlertForm();
							alertForm.alertOkButtonText = gis_core_4;
							alertForm.alertCancelButtonText = gis_core_5;
							alertForm.build("btnReportReverseAlertForm",gis_gridwidget_161, gis_gridwidget_162);
							//Добавляем слушатель закрытия формы
							$("body").on(CloseEvent.CLOSE, function btnReportReverseAlertFormClose(evt/*CloseEvent*/) {
								$("body").off(CloseEvent.CLOSE);
								if (evt && evt.detail == 1) {
									var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(dto), descrType);
									App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
										if (resultXML) {
											var er = HTTPServiceUtil.getError(resultXML);
											if (er !== "") {
												App.errorReport(gis_core_error_1, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_69'})
												return;
											}
											var guid = GridAdmInternal.generateProcessGUID();
											var processGuid = guid;//'78e29bcf';
											var sendingData = GridAdmInternal.convertSimpleObjectToXml_({
												inspection_id: iliInpectionId,
												link_repers: 'Y',
												ps_idx: 'N',
												process_id: processGuid,
											}); /*'<input/>';*/
											currentTemplate = "ILI_INSP_ProcRevert.xml";
											var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
											BlockingUtil.wait();
											var currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliInspLink, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
											GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
										}
									}, function (resultXML) {
										var er = HTTPServiceUtil.getError(resultXML);
										if (er === "") er = resultXML;
										App.errorReport(gis_core_error_7, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_69'})
									});
								}
							});


						}catch(ex){
							App.errorReport(gis_core_error_7, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_69'})
						}

						break;
					//ГРУППА. Задача "ВТД. Коррекция". вызов задачи 'Отвязать репер' Разрыв связи репера с точкой на карте
					case 'UnlinkReperEvent':
						if (dataObj.length > 0){
							GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_154, dataObj, that,
								function (curObj){
									if (curObj && curObj.ID){
										var userId = Auth.getUserId();
										var userLogin = Auth.getUserName();
										sendingData = '<data ID="'+curObj.ID+'" />';
										//Получаем параметры для запроса и исправляем их на нужные нам
										requestParams = { descrId: 'GAZPROM_ADM_SEM.xml#VTD_CORR_UNLINK', descrType: 'insert',
											data: '<root USER_ID="'+userId.xmlEscape()+'" USER_LOGIN="'+userLogin.xmlEscape()+'" PODS_USER="'+userLogin.xmlEscape()+'" >' + sendingData + '</root>' };
										//Ставим фиктивный currentTemplate для обработки результата теми же функциями onResult, onFault что и остальные запросы
										currentTemplate = 'UnlinkReperTemplate';
										//Устанавливаем курсор ожидания
										BlockingUtil.wait();
										App.serverQueryXMLGridNode(Services.processQueryNode, requestParams, onResult, onFault);
									}else if (GridAdmWidget.processStatusForm)
										GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_155);
								},
								endProcess, cancelProcess, true);
						}else {
							App.errorReport(gis_gridwidget_5, gis_gridwidget_140, undefined, {filename:gis_filename_187, functionname:'gis_filename_187_49'});
						}
						break;
					//ГРУППА. Задача "ВТД. Коррекция". вызов задачи 'Добавить репер' Связывание репера с точкой на карте
					case 'LinkReperEvent':
						var buttons = [
							{
								text: gis_core_12, click: function () {
									App.destroyDialog(undefined, this);
									var layerId = curDataAdapter.currentGridDescr.layerId;
									//Вызываем функцию создания объекта на карте(эмулируем)
									if (WidgetMap && WidgetMap.addObjectControl) {
										widgetMoveWindowToPosition('grid');
										var routeId = undefined;
										var firstElement = $(currentGrid).jqxGrid('getrowdata', 0);
										if(firstElement )
											routeId = firstElement.ROUTE_ID;
										var iliInpectionId = MapUtil.getTopFilterByName('ILI_INSP_FILTER');
										if(iliInpectionId)
											iliInpectionId = iliInpectionId.value;
										WidgetMap.addObjectControl.emulateHandleAddOnMapObjectClick({
											routeId: routeId,
											layerName: layerId,
											inspectionId: iliInpectionId,
											callback: function(semId){
												refreshDataAfterProcEnd(layerId, [semId]);
											}
										});
									}
								}
							},
							{
								text: gis_core_6, click: function () {
									App.destroyDialog(undefined, this);
								}
							}
						];
						App.confirmDialog(gis_gridwidget_159, buttons, {title:gis_core_1});
						break;
					
					//ГРУППА.Пересчет отчетов
					case 'gridAdmIliCalc':
						gridPropPanelId = 'divFormPPanel_gridAdmIliCalc';
						gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton:gis_core_12, cancelButton:gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects:[{id: "ADM_ILI_INSP_PROC", label: gis_gridadmwidget_82}],
							handlers:{getFormDataCallback:function getFormDataCallback(dataObject){
									if (dataObject) {
										iliCalcArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridadmwidget_68,iliCalcArray,that,
											function processSingleInspection(inspection) {
												if (inspection && inspection.hasOwnProperty("ID")){
													var guid = GridAdmInternal.generateProcessGUID();
													var processGuid = guid;//'78e29bcf';
													var sendingData = GridAdmInternal.convertSimpleObjectToXml_(dataObject); /*'<input/>';*/
													sendingData = sendingData.replace('/>',' inspection_id="'+inspection.ID+'" process_id="'+processGuid+'" />');
													var currentTemplate = "ILI_INSP_Proc.xml";
													var requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													BlockingUtil.wait();
													currentMessageId = App.serverQueryXMLGridNewNode(Services.uteIliInspCalc, requestParams, GridAdmInternal.onNodeResult, GridAdmInternal.onNodeFault, undefined, processGuid);
													GridAdmInternal.monitorProcess(processGuid, currentTemplate, currentMessageId, onResult, onFault, GridAdmInternal.cancelRequest, true);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridadmwidget_69);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridadmwidget_72, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_80'});
									}
								}}
						});
						break;
					//ГРУППА.1. Группировка дефектов в кластеры
					case 'gridAdmIliCalcCluster':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcCluster";
						gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
						$('#' + gridPropPanelId).remove();
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects: [{id: "ADM_ILI_CLUSTER", label:gis_gridwidget_34 }],
							handlers: {
								getFormDataCallback: function getFormDataCallback(dataObject) {
									if (dataObject) {
										iliCalcClusterArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_35, iliCalcClusterArray, that,
											function processSingleInspectionCluster(inspectionCluster) {
												if (inspectionCluster && inspectionCluster.hasOwnProperty("ID")) {
													sendingData = convertSimpleObjectToXml(dataObject);
													/*'<input/>';*/
													sendingData = sendingData.replace('/>', ' inspection_id="' + inspectionCluster.ID + '"/>');
													currentTemplate = "ILI_Cluster.xml";
													requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													//BlockingUtil.blockApplication();
													currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_31);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridwidget_36, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_26'});
									}
								}
							}
						});
						break;
					//ГРУППА.2. Расчет точечных показателей в соответствии с СТО 112, 173, 292, 401, 595
					case 'gridAdmIliCalcPressure':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcPressure";
						gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects: [{
								id: "ADM_ILI_PRESSURE",
								label: gis_gridwidget_37
							}],
							handlers: {
								getFormDataCallback: function getFormDataCallback(dataObject) {
									if (dataObject) {
										iliCalcPressureArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_38, iliCalcPressureArray, that,
											function processSingleInspectionCluster(inspectionPressure) {
												if (inspectionPressure && inspectionPressure.hasOwnProperty("ID")) {
													_baseOutputData = '<input inspection_id="1300497" pressure="7.36" breaking_point="588" yielding_limit="490" elastic_modulus="206000" ' +
														'safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" ' +
														'safety_factor_of_destination="1.34" route_category="4" thickness="16" calc_sto_2_2_3_112_2007="true" calc_sto_2_2_3_173_2007="true" ' +
														'calc_sto_2_2_3_292_2009="true" calc_sto_2_2_3_401_2009="true" calc_sto_2_2_3_595_2011="true" calc_sto_2_2_3_620_2011="true" calc_sto_ltg="true" />';
													sendingData = convertSimpleObjectToXml($.extend(convertXmlToSimpleObject(_baseOutputData), dataObject));
													sendingData = sendingData.replace(' inspection_id="1300497"', ' inspection_id="' + inspectionPressure.ID + '"');
													currentTemplate = "ILI_Pressure.xml";
													requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													//BlockingUtil.blockApplication();
													currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_31);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridwidget_39, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_27'});
									}
								}
							}
						});
						break;
					//ГРУППА.3. Расчет линейных показателей в соответствии с СТО 095, 292, 401
					case 'gridAdmIliCalcSTO':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcSTO";
						gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects: [{
								id: "ADM_ILI_STO",
								label: gis_gridwidget_40
							}],
							handlers: {
								getFormDataCallback: function getFormDataCallback(dataObject) {
									if (dataObject) {
										iliCalcSTOArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_41, iliCalcSTOArray, that,
											function processSingleInspectionCluster(inspectionSTO) {
												if (inspectionSTO && inspectionSTO.hasOwnProperty("ID")) {
													_baseOutputData = '<input calc_line_events="true" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {INSPECTION_ID}" ' +
														'calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" regular_intervals_distance="100" pressure="7.36" ' +
														'breaking_point="588" safety_factor_of_internal_pressure="1.1" safety_factor_of_working_conditions="0.9" safety_factor_of_material="1" safety_factor_of_destination="1.34" ' +
														'thickness="16" lifetime="25" average_cost_of_responding="150" cost_of_replacing_a_pipe="0.6" cost_of_the_ILI_per_km="0.1" cost_per_hole="0.2" cost_of_repair_per_km="23.8" ' +
														'calc_sto_2_2_3_292_2007="true" calc_sto_2_2_3_401_2003="true" calc_sto_2_2_3_095_2007="true" calc_sto_xxx="true" />';

													sendingData = convertSimpleObjectToXml($.extend(convertXmlToSimpleObject(_baseOutputData), dataObject));
													//sendingData = sendingData.replace('calc_line_events="true"','calc_line_events="True"');
													//sendingData = sendingData.replace('calc_line_events="false"','calc_line_events="False"');
													//Добавляем inspectionSTO.ID также в текст запроса line_events_query
													sendingData = sendingData.replace('{INSPECTION_ID}', inspectionSTO.ID);
													sendingData = sendingData.replace('/>', ' inspection_id="' + inspectionSTO.ID + '"/>');
													currentTemplate = "STO_ILI_INSP_Proc.xml";
													requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													//BlockingUtil.blockApplication();
													currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_31);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridwidget_42, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_28'});
									}
								}
							}
						});
						break;
					//ГРУППА.4. Расчет линейных показателей в соответствии с инструкцией ВНИИГАЗ 2004
					case 'gridAdmIliCalcSTOforEHZ':
						//Добавляем div панели свойств для создания формы ввода
						gridPropPanelId = 'divFormPPanel' + "_gridAdmIliCalcSTOforEHZ";
						gridPropPanelDiv = '<div id="' + gridPropPanelId + '"></div>';
						var widgetElementId = currentGrid.id.replace("jqxgrid",'');
						$('#' + gridPropPanelId).remove();
						$("#" + widgetElementId).append(gridPropPanelDiv);
						//Создаем панель свойств для текущего объекта (с добавлением дефолтных параметров, которых нет в самой форме)
						$('#' + gridPropPanelId).myFormPropertiesPanel({
							buttonsLabels: {saveButton: gis_core_12, cancelButton: gis_core_6},
							zindex: 260, /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
							modal: true,
							opener: "#" + widgetElementId,
							objects: [{
								id: "ADM_ILI_STO_FOR_EHZ",
								label: gis_gridwidget_43
							}],
							handlers: {
								getFormDataCallback: function getFormDataCallback(dataObject) {
									if (dataObject) {
										iliCalcSTOforEHZArray = dataObj;
										GridAdmWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_44, iliCalcSTOforEHZArray, that,
											function processSingleInspectionCluster(inspectionSTOforEHZ) {
												if (inspectionSTOforEHZ && inspectionSTOforEHZ.hasOwnProperty("ID")) {
													_baseOutputData = '<input calc_line_events="true" line_events_query="select event_id from PODS.ILI_INSPECTION_RANGE where ili_inspection_id = {INSPECTION_ID}" ' +
														'calc_construction_intervals="true" construction_element_query="select event_id from pods.valve" calc_regular_intervals="true" ' +
														'regular_intervals_distance="100" install_date="06.11.2002" calc_sto_xxx="true" />';

													sendingData = convertSimpleObjectToXml($.extend(convertXmlToSimpleObject(_baseOutputData), dataObject));
													//sendingData = sendingData.replace('calc_line_events="true"','calc_line_events="True"');
													//sendingData = sendingData.replace('calc_line_events="false"','calc_line_events="False"');
													//Добавляем inspectionSTOforEHZ.ID также в текст запроса line_events_query
													sendingData = sendingData.replace('{INSPECTION_ID}', inspectionSTOforEHZ.ID);
													sendingData = sendingData.replace('/>', ' inspection_id="' + inspectionSTOforEHZ.ID + '"/>');
													currentTemplate = "STO_EHZ_INSP_Proc.xml";
													requestParams = GridAdmWidget.prototype.makeUTEReqParams(currentTemplate, sendingData);
													//Устанавливаем курсор ожидания
													BlockingUtil.wait();
													currentMessageId = App.serverQueryXMLGrid(Services.RunUTETaskService, requestParams, onResult, onFault);
												}
												else if (GridAdmWidget.processStatusForm)
													GridAdmWidget.processStatusForm.processResultString(gis_gridwidget_31);
											},
											endProcess, cancelProcess, true);
									} else {
										App.errorReport(gis_gridwidget_5, gis_gridwidget_45, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_29'});
									}
								}
							}
						});
						break;
					//ГРУППА Отображение дашбордов
					case 'ShowDashboardEvent':
						var curRowData = dataObj[0];
						//Фильтрация грида
						var da = $(currentGrid).jqxGrid('source');
						if(da.currentGridDescr !== undefined){
							//TODO хардод. избавиться
							$('.search-engine-filters__grid').remove();
							if($('#searchEngine_'+currentGrid.id).length > 0){
								$('#searchEngine_'+currentGrid.id).toggle();
							}
							else{
								$('.search-engine-filters__grid').remove();
								var fltrs = GridUtil.formatFilters2SearchFrom(da.currentGridDescr.gridColumns, function(filters){
									var filterView = new SearchEngineGridFiltersForm({
										opener: 'grid',
										openerId: currentGrid.id,
										curDataAdapter: da,
										currentGrid: currentGrid,
										layerName: da.currentGridDescr.layerId,
										settings:{
											noTitle:true,
										},
										config: filters,
										applyCallback: function(filters, boolFilters, dateFilters){
											//применяем фильтр
											var curFilter = GridUtil.reformatFilters(filters, boolFilters, dateFilters);

											da.currentGridDescr.currentFilter = curFilter;
											//that.emulateBottomFilter(currentGrid);
											//TODO выставить фильтры в текущие открытые дашборды
										}
									});
									filterView.build();
								});
							}
						}

						break;
					//ГРУППА. Показать легенду в виде светофора для гридов Задачи "СУ ТС ТПА"
					case 'ShowLegendEvent':
						layerId = curDataAdapter.currentGridDescr.layerId;
						var tableName = (layerId.indexOf('КРАНОВЫЙ_УЗЕЛ') !== -1) ? 'structure' : (layerId.indexOf('КРАН') !== -1) ? 'valve' : 'vent_pipe';
						var userId = Auth.getUserId();
						var userLogin = Auth.getUserName();
						var params = {
							descrId: 'SUTSTPA_SEM.xml#RANK_LEGEND',
							descrType: 'select',
							data: '<root USER_ID="' + userId + '" USER_LOGIN="' + userLogin + '" PODS_USER="' + userLogin + '" >' +
								'<data TABLE_NAME="' + tableName + '"/></root>'
						}
						function result(resultXML) {
							try{
								var er = HTTPServiceUtil.getError(resultXML);
								if (er){
									App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_68'});
									return;
								}
								var data = resultXML.find('data')[0];
								var lowLimit = $(data).attr('PERC_15'),
									highLimit = $(data).attr('PERC_50'),
									elementId = currentGrid.id + '_showLegendModal';
								if(!lowLimit) lowLimit = 'Неизвестно';
								if(!highLimit) highLimit = 'Неизвестно';
								var div = '<div id="' + elementId + '" style="padding: 10px">' +
									'<div class="legend_line">' +
										'<div class="legend_line_color" style="background: rgb(0, 255, 0)"></div>' +
										'<span>- Ранг опасности до ' + lowLimit + '</span>' +
									'</div>' +
									'<div class="legend_line">' +
										'<div class="legend_line_color" style="background: rgb(255, 188, 22);"></div>' +
										'<span>- Ранг опасности от ' + lowLimit + ' до ' + highLimit + '</span>' +
									'</div>' +
									'<div class="legend_line">' +
										'<div class="legend_line_color" style="background: rgb(255, 70, 62);"></div>' +
										'<span>- Ранг опасности от ' + highLimit + '</span>' +
									'</div>' +
									'</div>';
								$('body').append(div);
								dlg = $('#'+elementId);
								dlg.dialog({
									modal: true,
									title: 'Легенда светофора',
									dialogClass: 'gsi-zindex__dialog',
									closeOnEscape: true,
									width: 300,
									height: 138,
									resizable: false,
									close: function () {
										App.destroyDialog(null, dlg);
									}
								});
							}catch (ex) {
								App.errorReport(gis_core_error_2, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_67'});
							}
						}
						function fault(resultXML) {
							var er = HTTPServiceUtil.getError(resultXML);
							if (er) App.errorReport(gis_core_error_2, er, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_66'});
						}
						App.serverQueryNodeWithTries(Services.processQueryNode, params, result, fault);
						break;
					//ГРУППА. показ на карте через открытие отдельного окна браузера/либо через iframe(зависит от настроек конфига задачи)
					case 'ShowMapEvent':
						try {
							//2015_03_18 - Проверяем есть ли слой, и если нет - центровку не выполняем
							layerId = curDataAdapter.currentGridDescr.layerId;
							layerManagerInst = curDataAdapter.currentGridDescr.layerManager;
							curLayerObj = layerManagerInst.getLayerByName(layerId);
							if (curLayerObj==undefined || curLayerObj==null)
								break;
							//Формируем параметры для вызова функции центровки
							objectsStr = eventParamsObj["layerid"] + ":";
							var selectedItemsCount = dataObj.length;
							if(App.syncEnabled && dataObj.length > 150)//количество доступных идентификаторов для хранения в куках
								selectedItemsCount = 150;
							for (i = 0; i < selectedItemsCount; i++) {
								objectsStr += dataObj[i]["ID"];
								//К последнему ID сзади запятую не добавляем
								if (i < dataObj.length - 1) {
									objectsStr += ",";
								}
							}
							params = [{name:"mdl", value:"main_js.html"}, {name: "objects", value: objectsStr}, {name: "select", value: true}, {name: "centering", value: true},{name: "isGroupButton", value: true}];
							if(eventParamsObj && eventParamsObj.task)
								taskName = eventParamsObj.task;
							GridUtil.showOnMap(taskName, params)
						} catch (e) {
							App.errorReport(gis_gridwidget_16, e.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_23'});
						}
						break;
					//ГРУППА. Выполнение произвольных команд с передачей в них выбранных идентификаторов
					case 'ExecuteQueryEvent':
						var datas = dataObj;
						if(!datas && datas.length === 0)
							datas = [{ID:'NULL'}];
						var requestId = eventParamsObj['request'];
						var selectedIds = datas.map(function (item) {
							return item.ID;
						});
						GridUtil.executeQuery(requestId, 'insert', selectedIds, function(){
							layerId = curDataAdapter.currentGridDescr.layerId;
							var selectedObject = layerId + ':' + selectedIds.join();
							App.syncManager.callSync(selectedObject,'grid', undefined, SyncTypes.TYPE_3);
							App.confirmDialog(gis_gridwidget_157, null, {title:gis_core_1});
						});
						break;
					//ГРУППА. Выполнение произвольных запросов с передачей в них выбранных идентификаторов и результат выводить в excel
					case 'ExecuteExcelQueryEvent':
						var datas = dataObj;
						if(!datas && datas.length === 0)
							datas = [{ID:'NULL'}];
						var requestId = eventParamsObj['request'];
						var selectedIds = datas.map(function (item) {
							return item.ID;
						});
						GridUtil.executeExcelQuery(requestId, 'select', selectedIds);
						break;
				}

			}
		}
	} catch (e) {
		App.errorReport(gis_gridwidget_5, e, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_30'});
	}
};

/**
 * Сохранение измененных ячеек грида по клику на групповую кнопку
 * @param currentGrid
 * @param dataAdapter
 * @param syncMap  флаг, нужно ли синхронизировать карту по обновленным объектам(удалять старые с карты и перезапрашивать новые)
 */
GridWidget.prototype.saveUpdatedCellDialog = function(currentGrid, dataAdapter, syncMap) {
	var that = this;
	if(dataAdapter && dataAdapter.currentGridDescr && dataAdapter.currentGridDescr.rows4Update) {
		var jqxGridId = currentGrid.id;
		var rows4UpdateObj = dataAdapter.currentGridDescr.rows4Update;
		var rows4UpdateIds = []; // массив всех идентификаторов на обновление
		var rows4Update = [];
		for(var row in rows4UpdateObj){
			rows4Update.push(rows4UpdateObj[row]);
			rows4UpdateIds.push(rows4UpdateObj[row].ID);
		}
		if(rows4Update.length === 0)
			return;
		delete dataAdapter.currentGridDescr.rows4Update;

		that.selectFullDataBeforeUpdateDB(dataAdapter, rows4Update, function(result){
			var rows4UpdateLength = rows4Update.length;
			rows4Update.forEach(function (it, index) {
				//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
				var itemFromDb = result[it.ID];
				var isLastRow = (rows4UpdateLength - 1) === index;
				if(itemFromDb){
					var extIt = $.extend(itemFromDb,it);
					that.updateCellDB(dataAdapter, extIt, syncMap, jqxGridId, isLastRow, rows4UpdateIds);
				}
			});
			//TODO обновлять грид по окончанию загрузки
			//GridWidget.refreshGrid(jqxGridId);
		});
	}
}


GridWidget.prototype.pasteFromExcelDialog = function(currentGrid, dataAdapter, syncMap) {
	var that = this;
	var divv = '<div id="pasteFromExcelDialog">' +
		'<label style="color: #ffffff">' + gis_gridwidget_98 + '</label>'+
		'<textarea id="pasteFromExcelText" style="width:580px;margin: 1px;color: #005d98;height: 55px;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text"></textarea>' +
		'<div style="margin-top:10px; color: #ffffff">' + gis_gridwidget_99 + '</div>'+
		'<div style="margin-top:2px; color: #ffffff;" >' +
		'   <input type="checkbox" id="confirmPasteFromExcelCheckbox">' +
		'   <label style="color: #ffffff;" for="confirmPasteFromExcelCheckbox">' + gis_gridwidget_105 + '</label>' +
		'</div>' +
		'<div style="margin-top:10px; color: #ffffff">' + gis_gridwidget_99_1 + '</div>'+
		'</div>';
	$('body').append(divv);
	var dlg = $('#pasteFromExcelDialog');
	var bts = [
		{
			text: gis_gridwidget_92,
			click: function(){
				var pastedText =  $('#pasteFromExcelText').val();
				if(pastedText === ''){
					App.confirmDialog(gis_gridwidget_109, null, {title:gis_core_1});
					return;
				}
				if(dataAdapter && dataAdapter.currentGridDescr) {
					dataAdapter.currentGridDescr.pasteFromExcelData = pastedText;
					var checked = $('#confirmPasteFromExcelCheckbox').prop('checked');
					that.pasteCells(currentGrid, dataAdapter, checked, syncMap);
				}
				$('#pasteFromExcelDialog').remove();
			}
		},
		{
			text: gis_gridwidget_93,
			click: function(){
				var pastedText =  $('#pasteFromExcelText').val();
				if(pastedText === ''){
					App.confirmDialog(gis_gridwidget_109, null, {title:gis_core_1});
					return;
				}
				else if(!dataAdapter.currentGridDescr.lastEditedCell){
					App.confirmDialog(gis_gridwidget_107, null, {title: gis_core_1});
					return ;
				}
				var pastedText =  $('#pasteFromExcelText').val();
				that.confirmUpdateFromExcel(currentGrid, dataAdapter, pastedText, syncMap);
				$('#pasteFromExcelDialog').remove();
			}
		},
		{
			text: gis_core_8,
			click: function(){
				delete dataAdapter.currentGridDescr.lastEditedCell;
				$('#pasteFromExcelDialog').remove();
			}
		}];
	dlg.dialog({
		modal: true,
		title: gis_gridwidget_87,
		dialogClass: 'ui-dialog-confirm noCloseButton gsi-zindex__dialog',
		closeOnEscape: true,
		width: 595,
		height: 395,
		resizable: false,
		buttons : bts
	});
};

GridWidget.prototype.confirmUpdateFromExcel = function(currentGrid, dataAdapter, text, syncMap) {
	var that = this;
	var label = gis_gridwidget_101;
	if(dataAdapter && dataAdapter.currentGridDescr.lastEditedCell && dataAdapter.currentGridDescr.lastEditedCell.boundIndex !== undefined && dataAdapter.currentGridDescr.lastEditedCell.boundIndex !== null  && dataAdapter.currentGridDescr.lastEditedCell.dataField){
		var columns = dataAdapter.currentGridDescr.gridColumns;
		label = label.replace('{ROW_NUM}', dataAdapter.currentGridDescr.lastEditedCell.rwn);
		columns.forEach(function(it){
			if(it.datafield === dataAdapter.currentGridDescr.lastEditedCell.dataField)
				label = label.replace('{COL_NAME}', (it.text)?it.text.replace(/\\n/g,' '):'');
		});
		dataAdapter.currentGridDescr.pasteFromExcelData = text;
		that.updateCells(currentGrid, dataAdapter, syncMap);
	}
	else{
		App.confirmDialog(gis_gridwidget_107, null, {title: gis_core_1});
	}
};

/**
 * Эмуляция запроса данных в грид при фильтрации, чтобы не блоркировалось содержимое грида
 * @param currentGrid
 * @param curFilter
 * @param selecting
 * @param centering
 */
GridWidget.prototype.emulateRefreshGrid = function (currentGrid, curFilter, selecting, centering) {
	var dataAdapter = $(currentGrid).jqxGrid('source');
	var refreshGridEvt = new GridEvent(GridEvent.FILTER_GRID);
	refreshGridEvt.gridId = currentGrid.id;
	refreshGridEvt.dispatch();
	/*dataAdapter.currentGridDescr.currentFilter = curFilter;
	//Также сохраняем флаги выделения и центровки на карте
	dataAdapter.currentGridDescr.selecting = selecting;
	dataAdapter.currentGridDescr.centering = centering;*/
};


GridWidget.prototype.emulateBottomFilter = function(currentGrid){
	$(currentGrid).jqxGrid('clearselection');
	var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
	if(gridWidget) {
		gridWidget.modified = true;
	}

	//Перезапрашиваем грид
	try {
		GridWidget.refreshGrid(currentGrid.id, true);
	}
	catch(ex){

	}
}

/* Функции фильтрации */
//Слушатель события закрытия формы фильтра нижнего уровня
GridWidget.prototype.onBottomFilterFormClose = function (evt/*CloseEvent*/) {
	$("body").off(CloseEvent.CLOSE);
	if (evt && evt.eventData) {
		var parentRoughFilter = undefined;
		var selecting = evt.eventData.selecting;
		var centering = evt.eventData.centering;
		//Забираем фильтр
		var curFilter = evt.eventData.filter;
		//Сохраняем его в виджет грида и перезапршиваем грид
		var currentGrid = evt.eventData.currentGrid;
		var dataAdapter = $(currentGrid).jqxGrid('source');
		dataAdapter.currentGridDescr.currentFilter = curFilter;
		//Также сохраняем флаги выделения и центровки на карте
		dataAdapter.currentGridDescr.selecting = selecting;
		dataAdapter.currentGridDescr.centering = centering;
		var showError = true;
		//пытаемся очистить на карте прошлый фильтр слоя
		if(dataAdapter.currentGridDescr!=undefined && dataAdapter.currentGridDescr.layerManager!=undefined){
			var layerId = dataAdapter.currentGridDescr.layerId;
			var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
			var layObj = layerManagerInst.getLayerByName(layerId);
			if(layObj !=undefined && layObj.layer != undefined){
				if(layObj.layer.useServerCache)
					showError = false;
				layObj.layer.showAllObjects();
			}
		}
		//чистка выделения при применении фильтрации
		$(currentGrid).jqxGrid('clearselection');
		var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
		var force = true;
		if(gridWidget) {
			gridWidget.modified = true;
			parentRoughFilter = gridWidget.parentRoughFilter;
			force = false;
		}
		//Перезапрашиваем грид
		try {
			GridWidget.refreshGrid(currentGrid.id, force);
		}
		catch(ex){ }

		if(selecting === undefined && centering === undefined)
			return;
		//В связи с проблемой с доступом к контену грида во время фильтрации, эмулируем запросы на кол-во и содержимое
		//если результаты удачны, то заполняем грид
		//this.emulateRefreshGrid(currentGrid,curFilter,selecting,centering);

		var windowId = "";
		var roughFilter = dataAdapter.currentGridDescr.roughFilter;
		//Текущая сортировка (получаем из массива объектов колонок)
		var gridSortStr = GridWidget.prototype.getSortStringFromArr(dataAdapter.currentGridDescr);
		var topFilter = dataAdapter.currentGridDescr.topFilter;
		var funcName = "filterData";
		var params = [{name: "highlight", value: selecting},
			{name: "zoom", value: centering},
			{name: "requestId", value: dataAdapter.currentGridDescr.dataRequest},
			{name: "layer", value: dataAdapter.currentGridDescr.layerId},
			{name:'showError', value:showError},
			{name:'filterXML', value:GridWidget.prototype.makeFilterXMLForCentering(curFilter, gridSortStr, topFilter, roughFilter, parentRoughFilter)}];
		//Вызываем функцию в текущем окне через ExternalInteraction (там будут обработаны ошибки вызова и выдано сообщение об ошибке)
		ExternalInteraction.callFunction(windowId, funcName, params);
	} else {

	}
};



GridWidget.applyExtBottomFilter = function(filters){

}


//Создание строки фильтра для отправки в запрос
GridWidget.prototype.getBottomFilterString = function (filters/*Array*/, parentRoughFilter/*String*/) {
	var _strFilter = "";
	if (filters && filters.length > 0) {
		var res = [];
		var n;
		for (var j = 0; j < filters.length; j++) {
			var f = filters[j];
			if (f.hasOwnProperty("val")) {
				switch (f.op) {
					case 'in': // из списка
						//TODO хардкод если поле YEAR_INSP, то в нижним фильтре игнорируем
						if(f.fld === 'YEAR_INSP')
							break;
						res.push(f.fld + " IN (" + GridWidget.prototype.getArrayDictFilter(f.val)+")");
						break;
					case '=': // число или строка
						//Даты игнорируем (они добавятся в фильтр верхнего уровня как переменные)
						if (f.hasType == 'date') {
							var startDate = f.startDate.toString();
							var endDate = f.endDate.toString();
							if(!startDate) startDate = '01.01.1900';
							if(!endDate) endDate = '01.01.2121';
							startDate += ' 00:00:00';
							endDate += ' 00:00:00';
							if(f.dateformat !== 'number'){
								//ИМЯ_КОЛОНКИ_ДАТЫ between '2020-01-01 00:00:00'::date and '2121-04-02 00:00:00'::date
								res.push(f.fld + " BETWEEN '" + startDate + "'::date and '" + endDate + "'::date ");
							}
							else{
								//парсим строку в Date и получаем миллисекунды
								var startDateArr = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(startDate);//DD.MM.YYYY
								var endDateArr = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(endDate);//DD.MM.YYYY
								//new Date(year, month, day)
								startDate = new Date(Number(startDateArr[3]), Number(startDateArr[2]), Number(startDateArr[1])).getTime();
								endDate = new Date(Number(endDateArr[3]), Number(endDateArr[2]), Number(endDateArr[1])).getTime();
								res.push(f.fld + " >= " + startDate + " and "+f.fld+" <=" + endDate + " ");
							}
							break;
						}
						if (f.hasType == 'number') {
							if((f.val.toString()).indexOf(";")>0) { //тогда имеет место массив чисел и нужен оператор in
								var arr = f.val.toString().split(";");
								res.push(f.fld + " IN (" + GridWidget.prototype.getArrayFilter(arr)+")");
							}  else {
								n = GridWidget.prototype.getNumber(f.val.toString().replace(',','.'));
								if (!isNaN(n))
									res.push(f.fld + " = " + n.toString());
							}
						}
						break;
					case 'likeA':
						if((f.val.toString()).indexOf(";")>=0) { //тогда имеет место массив строк и нужен оператор in
							var arrStr = f.val.toString().split(";");
							//проверяем, все ли элементы в кавычка, если нет, то ставим
							for (var i = 0; i < arrStr.length; i++) {
								//replace (';;',';XZY;') заменяем
								if(arrStr[i].length == 0)
									arrStr[i] = "XZY";
								if(arrStr[i].indexOf("'")==-1) { //т.е. строки данного элемента ещё не обрамлены в кавычки
									if(arrStr[i].length>0)
										arrStr[i] = "UPPER('"+arrStr[i]+"')";
								}
							}
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY')" + " IN (" + GridWidget.prototype.getArrayFilter(arrStr)+")");
						} else {
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
							else
								res.push("UPPER(" + f.fld + ") LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "')");
						}
						break;
					case 'notLikeA':
						if((f.val.toString()).indexOf(";")>=0) { //тогда имеет место массив строк и нужен оператор in
							var arrStr = f.val.toString().split(";");
							//проверяем, все ли элементы в кавычка, если нет, то ставим
							for (var i = 0; i < arrStr.length; i++) {
								//replace (';;',';XZY;') заменяем
								if(arrStr[i].length == 0)
									arrStr[i] = "XZY";
								if(arrStr[i].indexOf("'")==-1) { //т.е. строки данного элемента ещё не обрамлены в кавычки
									if(arrStr[i].length>0)
										arrStr[i] = "UPPER('"+arrStr[i]+"')";
								}
							}
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY')" + "NOT IN (" + GridWidget.prototype.getArrayFilter(arrStr)+")");
						} else {
							if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
								res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
							else
								res.push("UPPER(" + f.fld + ") NOT LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "')");
						}
						break;
					case 'like%A':
						if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
						else
							res.push("UPPER(" + f.fld + ") LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "')");
						break;
					case 'likeA%':
						if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
						else
							res.push("UPPER(" + f.fld + ") LIKE UPPER('" + GridWidget.prototype.validate(f.val) + "%')");
						break;
					case 'like%A%':
						if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
						else
							res.push("UPPER(" + f.fld + ") LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "%')");
						break;
					case 'notLike%A%':
						if(f.val.length == 0)//чтобы корректно передавались в запрос пустые строки
							res.push("COALESCE(UPPER(" + f.fld + "),'XZY') IN ('XZY')");
						else
							res.push("UPPER(" + f.fld + ") NOT LIKE UPPER('%" + GridWidget.prototype.validate(f.val) + "%')");
						break;
					default: // только числа
						//тут меняем первую запятую и меняем на точку. Если получится число, то отправляем запрос
						n = GridWidget.prototype.getNumber(f.val.toString().replace(',','.'));
						if (!isNaN(n))
							res.push(f.fld + " " + GridWidget.prototype.validate(f.op) + " " + n.toString());
						break;
				}
			}
		}
		if (res.length > 0) {
			if(parentRoughFilter)
				res.push(parentRoughFilter);
			_strFilter = res.join(" AND ");
		}
	}
	else{
		if(parentRoughFilter)
			_strFilter = parentRoughFilter;
	}
	if (_strFilter == "")
		_strFilter = GridWidget.DEFAULT_FILTER;
	_strFilter =  _strFilter.replace(/&amp;#60;/g, '&amp;lt;');
	return _strFilter;//Фиксим баг #1016 - Если задать условие "<" , то ничего не найдется.
};

//Получение значений с кавычками, если строка и без них, если число. Объединяет значения одного массива в строку через ","
GridWidget.prototype.getArrayDictFilter = function (dict/*Array*/) {
	if (dict && (dict.length > 0)) {
		var res  = [];
		for (var i = 0; i < dict.length; i++) {
			var d = dict[i];
			if (d.hasOwnProperty('CODE')) {
				var v = d.CODE;
				if (typeof v == 'string'){
					//экранируем двойные кавычки, чтобы не рушился формат xml
					var vs = "'"+v.toString().replace(/\"/g,'&quot;')+"'";
					vs = vs.replace(/''/g, "'");
					res.push(vs);
				}
				else
					res.push(v.toString());
			}
		}
		return res.join(", ");
	}
	return 'NULL';
};

//Объединение значений в строку
GridWidget.prototype.getArrayFilter = function (dict/*Array*/) {
	if (dict && (dict.length > 0)) {
		var res = [];
		for (var i = 0; i < dict.length; i++) {
			var d = dict[i];
			if(d.length == 0 || d == " ")
				continue;
			res.push(d);
		}
		return res.toString(); //TODO - проверить что объединяет строки !!!
	}
	return 'NULL';
};

//Получение числа из строки с заменой символа разделителя
GridWidget.prototype.getNumber = function (value/*String*/) {
	var n = parseFloat(value);
	if (!isNaN(n))
		return n;
	return parseFloat(value.replace(",", "."));
};

//Получение числа из строки с заменой символа разделителя
GridWidget.prototype.validate = function (val/*String*/) {
	val = val.replace(/&/g, '&amp;');
	val = val.replace(/<=/g, '&amp;lt;=');
	val = val.replace(/</g, '&amp;lt;');
	val = val.replace(/>=/g, '&amp;gt;=');
	val = val.replace(/>/g, '&amp;gt;');
	val = val.replace(/"/g, '&amp;quot;'); //" просто чтобы форматирование нормально показывалось
	return val;
};
/**/

/* Функции групповой операции удаления */
//Форма процесса групповой операции
GridWidget.processStatusForm = null;
//Функция удаления одной записи
GridWidget.prototype.deleteObject = function (deletingObject) {
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID, this.onObjectDeleteResult);
	$("body").on(OperationEvent.OBJECT_DELETED_BY_ID, this.onObjectDeleteFault);
	//Запускаем удаление
	DBUtil.deleteGeometryFromDB(deletingObject.objectId, deletingObject.classId, deletingObject.provider, deletingObject.propertyPanelName);

	//После удаления нужно будет обновить грид, но пока что не делаем этого
};


//Функция удаления одной записи
GridWidget.prototype.deleteObjectWithSyncMap = function (deletingObject) {
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID, this.onObjectDeleteWithSyncMapResult);
	$("body").on(OperationEvent.OBJECT_DELETED_BY_ID, this.onObjectDeleteFault);
	//Запускаем удаление
	DBUtil.deleteGeometryFromDB(deletingObject.objectId, deletingObject.classId, deletingObject.provider, deletingObject.propertyPanelName);

	//После удаления нужно будет обновить грид, но пока что не делаем этого
};


GridWidget.prototype.insertStoILiDataAdvObject = function (insertingObject) {
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_INSERTED, this.onObjectInsertFault);
	//Запускаем удаление
	DBUtil.insertStoIliDataAdvToDB(insertingObject.rowData, insertingObject.dataAdapter, insertingObject.provider);
};

GridWidget.prototype.insertObject = function (insertingObject) {
	//Запускаем удаление
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_INSERTED, this.onObjectInsertFault);
	DBUtil.insertObjectToDB(insertingObject.rowData, insertingObject.dataAdapter, insertingObject.colTypes);
};

//Функция обработки результата удаления записи
GridWidget.prototype.onObjectDeleteResult = function (evt) {
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
	//Проверяем, есть ли карта и пробуем удалять объект с карты
	if (evt.operationData == "") {//нет ошибки
		if(WidgetMap!=undefined && WidgetMap.layerManager!=undefined){
			var layer = WidgetMap.layerManager.getLayerByName(evt.classId);
			if(layer != undefined && layer.layer != undefined){
				layer.layer.deleteObjectById(evt.objectId);
			}
		}
	}
	GridWidget.processStatusForm.processResultString(evt.operationData);
};

//Функция обработки результата удаления записи
GridWidget.prototype.onObjectDeleteWithSyncMapResult = function (evt) {
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};

//Функция обработки ошибки при удалении записи
GridWidget.prototype.onObjectDeleteFault = function (evt) {
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
	$("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};

//Функция обработки ошибки при вставке записи
GridWidget.prototype.onObjectInsertFault = function (evt) {
	$("body").off(OperationEvent.OBJECT_INSERTED);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};
//Функция окончания удаления всех записей
GridWidget.prototype.onAllObjectsDeleted = function () {
	//Пока ничего не делаем
};
//Функция отмены удаления (текущее удаление не отменит, но следующие запускать не будет)
GridWidget.prototype.deleteObjectsCancel = function () {
	//Отменяем удаление текущего запроса (если возможно)
};

/**
 *
 * @param reversedObject
 */
GridWidget.prototype.reverseObject = function (reversedObject) {
	//Добавляем слушатель
	$("body").on(OperationEvent.OBJECT_REVERSED_RESULT_BY_ID, this.onObjectReversedResult);
	$("body").on(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID, this.onObjectReversedFault);
	//Запускаем удаление
	DBUtil.reverseObject(reversedObject.rowData, reversedObject.classId);
};

//Функция обработки результата удаления записи
GridWidget.prototype.onObjectReversedResult = function (evt) {
	$("body").off(OperationEvent.OBJECT_REVERSED_RESULT_BY_ID);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};
//Функция обработки ошибки при удалении записи
GridWidget.prototype.onObjectReversedFault = function (evt) {
	$("body").off(OperationEvent.OBJECT_REVERSED_FAULT_BY_ID);
	$("body").off(OperationEvent.OBJECT_REVERSED_BY_ID);
	GridWidget.processStatusForm.processResultString(evt.operationData);
};


/**
 * Обработка кнопки импорта/экспорта объектов в/из GPX, KML
 * @param filterStr
 * @param currentGridDescr
 * @param currentGridId
 * @constructor
 */
GridWidget.prototype.exportImportObjectsToGpxKml = function (filterStr ,currentGridDescr, currentGridId) {
	//Идентификатор запроса геометрии получаем из LayerManager
	if (!currentGridDescr) return;
	var flagImport = filterStr ? false : true;
	var layerId = currentGridDescr.layerId;
	var layerManagerInst = currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	var dataProvider = curLayerObj.dataProvider;
	var requestParams = {};
	if (filterStr !== undefined)//Получаем параметры запроса
		requestParams = GridWidget.prototype.makeLoadGeoDataReqParams(dataProvider.spatial, filterStr);
	//Создаем форму выбора формата экспорта и передаем в нее набор геометрий для экспорта
	var chooseExportImportForm = new ImportExportGpxKmlForm();
	if (requestParams && requestParams.data)
		chooseExportImportForm.requestParams = requestParams.data;
	chooseExportImportForm.dataRequest = dataProvider.spatial;
	chooseExportImportForm.layerName = layerId;
	chooseExportImportForm.dataProvider = dataProvider;
	chooseExportImportForm.currentGridId = currentGridId;
	chooseExportImportForm.flagImport = flagImport;
	chooseExportImportForm.projection = (curLayerObj.layer)? curLayerObj.layer.projection: null;
	chooseExportImportForm.htmlUrl = 'ui/html/ImportExportGpxKmlForm.html';
	chooseExportImportForm.columns = currentGridDescr.gridColumns.filter(function(column) { return column.filtercomparisiontype });
	chooseExportImportForm.build();
};
/* Функции экспорта в GPX/KML */
GridWidget.prototype.exportObjectsToGPX = function (filterStr, currentGridDescr) {
	//Идентификатор запроса геометрии получаем из LayerManager
	var layerId = currentGridDescr.layerId;
	var layerManagerInst = currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	var dataRequest = curLayerObj.dataProvider.spatial;
	var dataProvider = curLayerObj.dataProvider;
	//Получаем параметры запроса
	var requestParams = GridUtil.makeLoadGeoDataReqParams(dataRequest, filterStr);
	//Создаем форму выбора формата экспорта и передаем в нее набор геометрий для экспорта
	var chooseExportForm = new ExportGpxKmlForm();
	chooseExportForm.exportArray = [];
	chooseExportForm.projection = (curLayerObj.layer)? curLayerObj.layer.projection: null;
	chooseExportForm.dataRequest = dataRequest;
	chooseExportForm.requestParams = requestParams.data;
	chooseExportForm.dataProvider = dataProvider;
	chooseExportForm.layerName = layerId;
	//Собственно создаем форму
	chooseExportForm.build();
};



//Сортировка по свойству объекта (c учетом строкового/числового полей)
GridWidget.prototype.dynamicSort = function (property) {
	return function (obj1,obj2) {
		//Исправление для отсутствующего в данных поля - если поля нет, автоматически считаем это значение меньше
		if (obj1==undefined || obj1==null || !obj1.hasOwnProperty(property)) return -1;
		if (obj2==undefined || obj2==null || !obj2.hasOwnProperty(property)) return 1;
		//Внутренняя функция сортировки учитывает, что значения могут быть числовыми
		var value1 = obj1[property].toLowerCase();
		var value2 = obj2[property].toLowerCase();
		try {
			var tmpvalue1 = parseFloat(value1);
			var tmpvalue2 = parseFloat(value2);
			if (!isNaN(tmpvalue1) && !isNaN(tmpvalue2)) {
				if (tmpvalue1 < tmpvalue2) { return -1; }
				if (tmpvalue1 > tmpvalue2) { return 1; }
			} else {
				if (value1 < value2) { return -1; }
				if (value1 > value2) { return 1; }
			}
		} catch (error) {}
		return 0;
	}
};
//Сортировка сразу по нескольким полям
GridWidget.prototype.dynamicSortMultiple = function (fieldsArr) {
	var props = fieldsArr;
	return function (obj1, obj2) {
		var i = 0, result = 0, numberOfProperties = props.length;
		while(result === 0 && i < numberOfProperties) {
			result = GridWidget.prototype.dynamicSort(props[i])(obj1, obj2);
			i++;
		}
		return result;
	}
};

//Функция формирует строку сортировки из массива
GridWidget.prototype.getSortStringFromArr = function (currentGridDescr) {
	var sortStr = "";
	var sortArr = currentGridDescr.currentSort;
	if (sortArr && sortArr !== undefined && sortArr.length > 0) {
		var tmpSortArr = [];
		var i = 0;
		for (i; i < sortArr.length; i++) {
			var sortinformation = sortArr[i];
			//Теперь если мы добавляем сортировку и этот элемент уже был - меняем его (или убираем если сортировка отменена), иначе просто добавляем
			if (sortinformation.sortdirection.ascending || sortinformation.sortdirection.descending) {
				for (var j = 0; j < currentGridDescr.gridColumns.length; j++) {
					//Ищем среди колонок ту, по которой сортируем и забираем значение из ее свойства sortfield
					//Если такого свойста у колонки нет, сортируем по datafield
					var curGridCol = currentGridDescr.gridColumns[j];
					if (curGridCol.hasOwnProperty('datafield') && curGridCol.datafield == sortinformation.sortcolumn) {
						var tmpSortStr = curGridCol.hasOwnProperty('sortfield') && curGridCol.sortfield != undefined ? curGridCol.sortfield : curGridCol.datafield;
						if (sortinformation.sortdirection.descending)
							tmpSortStr += " DESC";
						tmpSortArr.push(tmpSortStr);
					}
				}
			}
		}
		//Собираем получившийся массив в строку, разделенную запятой
		sortStr = tmpSortArr.join(",");
	}
	else {//иначе проходим по колонкам в gridDescription, ищем соответствующие initialSortField поля сортировки
		if (currentGridDescr.columns != undefined) {
			if (currentGridDescr.initialSortField != null) {
				var i = 0;
				var sortArr = [];
				var isf = currentGridDescr.initialSortField.split(',');

				for (i; i < isf.length; i++) {
					var j = 0;
					var found = false;
					for (j; j < currentGridDescr.columns.length; j++) {
						if (isf[i] == currentGridDescr.columns[j].datafield && currentGridDescr.columns[j].sortfield != undefined && currentGridDescr.columns[j].sortfield != '') {
							sortArr.push(currentGridDescr.columns[j].sortfield);
							found = true;
							break;
						}
					}
					if (!found)
						sortArr.push(isf[i]);
				}
				sortStr = sortArr.join(',');
			}
		}
	}
	//по-умолчанию возвращаем первоначальный порядок сортировки
	if (sortStr == "") sortStr = currentGridDescr.initialSortField;
	return sortStr;
};


GridWidget.prototype.onColorFilterFormClose = function (data) {
	var that = this;
	if(data){
		var currentGrid = data.currentGrid;
		var currentGridDescr = data.currentGridDescr;
		currentGridDescr.colorRowValidations = data.colorRowValidations;
		currentGridDescr.colorValidations = data.colorValidations;
		currentGridDescr.colorRowSelectType = data.checkType;
		currentGridDescr.minCriticalColor = data.minCriticalColor;
		currentGridDescr.maxCriticalColor = data.maxCriticalColor;
		//получаем обновленный список цветов и заново рендерим грид
		$(currentGrid).jqxGrid('render');
		$(currentGrid).jqxGrid('clearselection');
		if(data.selectedIndexes && data.selectedIndexes.length > 0){
			for(var item in data.selectedIndexes)
				$(currentGrid).jqxGrid('selectrow', data.selectedIndexes[item] );
		}
	}
};

//Функция обновления грида
GridWidget.refreshGridAfterDelete = function (gridId) {
	//После удаления обновляем грид
	GridWidget.refreshGrid(gridId);
};

/**
 * Функция обновления грида
 * TODO Вынести в общий класс
 * @param gridId
 * @param force необходима ли полное обновление грида(сброс сортировок, фильтров, страниц)
 * @param refreshGridCallback
 * @param opt_options additional options
 */
GridWidget.refreshGrid = function (gridId, force, refreshGridCallback, opt_options) {
	//prepare options
	var options = opt_options || {};
	var ignoreAllFilter = !!options.ignoreAllFilter;

	var refreshGridEvt = new GridEvent(GridEvent.REFRESH_GRID+"_"+gridId);
	refreshGridEvt.gridId = gridId;
	refreshGridEvt.force = force;
	refreshGridEvt.ignoreAllFilter = ignoreAllFilter;
	refreshGridEvt.refreshGridCallback = refreshGridCallback;
	refreshGridEvt.dispatch();
	//12.10.2021 Vartanian при любом обовление грида, будет востанавливаться грид, если он свернут
	//12.10.2021 Vartanian востановление грида в рамках инц #2536
	widgetMoveWindowToPosition('grid', 'restore');
};

//Функция обновления грида
GridWidget.refreshGridAfterInsert = function (gridId, layerName, syncMap) {
	//После удаления обновляем грид
	GridWidget.refreshGrid(gridId);
	if(syncMap){
		MapUtil.updateLayerData(layerName, [], true);
	}
};

/**
 * Вставка записей из Excel
 * @param currentGrid текущий грид
 * @param curDataAdapter текущий адаптер грида
 * @param isSystemInsert  true - вставка со служебными колонками. false - вставка, как есть, начиная с первой колонки
 */
GridWidget.prototype.pasteCells = function (currentGrid, curDataAdapter, isSystemInsert, syncMap) {
	var that = this;
	try{
		if(currentGrid && curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData){
			var currentGridDescr = curDataAdapter.currentGridDescr;
			var cols = currentGridDescr.gridColumns;
			var colNames = [];
			var colTypes = {};
			var synonyms = {};//массив синонимов колонок в гриде TODO заменить на получение из GridUtils
			cols.forEach(function (it, index) {
				if(it.datafield && !Number.isInteger(it.datafield) && !it.hidden && it.datafield !== 'RWN'){
					colNames.push(it.datafield);
					colTypes[it.datafield] = it.columntype;
				}
				if(it.datafieldsynonym)
					synonyms[it.datafield] = it.datafieldsynonym;
			});
            var layer = curDataAdapter.currentGridDescr.layerManager.getLayerByName(curDataAdapter.currentGridDescr.layerId);
            if (layer && layer.dataProvider && layer.dataProvider.semantic){
				var params = {
					layerName: curDataAdapter.currentGridDescr.layerId,
					jqxGridId: currentGrid.id,
					isSystemInsert: isSystemInsert,
					syncMap: syncMap,
					currentGridDescr: currentGridDescr,
					curDataAdapter: curDataAdapter,
					colNames: colNames,
					colTypes: colTypes,
					synonyms: synonyms,
					that:that,
				}
                GridUtil.getRequestVariables(layer.dataProvider.semantic, 'update', that.prepareToUpdateCells, params);
            }
		}
	}
	catch(ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_60'});
	}
}
/**
 * @param semanticColTypes - массив с объектами типа: {name: "ID", type: "Int64"}
 * @param params - объект с параметрами
 */
GridWidget.prototype.prepareToUpdateCells = function (semanticColTypes, params) {
	var that = params.that;
	try {
		var isSystemInsert = params.isSystemInsert;
		var layerName = params.layerName;
		var jqxGridId = params.jqxGridId;
		var idColumn = 'ID';
		var gridWidget = App.GridManager.getByGridId(jqxGridId.replace('jqxgrid',''));
		if(gridWidget) {
			idColumn = gridWidget.primaryKeyField || 'ID';
		}

		var syncMap = params.syncMap;
		var colNames = params.colNames;
		var colTypes = params.colTypes;
		var synonyms = params.synonyms;
		var currentGridDescr = params.currentGridDescr;
		var curDataAdapter = params.curDataAdapter;
		var rows = GridUtil.convertPlainExcelDataToTable(currentGridDescr.pasteFromExcelData);
		var rows4Insert = [];
		var rows4Update = [];
		var rows4UpdateIds = [];
		var isInsert = true;// если в данных присутствует колонка ID, то будет происзведено обновление вместо вставки
		var buttons = [
			{
				text: gis_core_4, click: function () {
					App.destroyDialog(undefined, this);
					var foreignKeyField = '';
					//var gridWidget = App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''));
					if(gridWidget && gridWidget.foreignKeyField && gridWidget.filters && gridWidget.filters.length) {
						foreignKeyField = gridWidget.foreignKeyField || [];//{PI_CP_ENEBT_ID:111}
						if(foreignKeyField) {
							foreignKeyField.forEach(function(fc){
								var foreignKeyData = {};
								gridWidget.filters.forEach(function(filterItem){
									if(filterItem.name === fc){
										foreignKeyData[fc] = filterItem.value;
										rows4Insert.forEach(function(dataIns){
											dataIns.rowData = $.extend(dataIns.rowData, foreignKeyData);
										})
									}
								})
							})
						}
					}
					GridWidget.processStatusForm = GroupOperationsUtil.createProcessStatusForm(gis_gridwidget_130, (isInsert)?rows4Insert.reverse():rows4Update.reverse(),that,GridWidget.prototype.insertObject,
						function(){
							//записи успешно добавлены
							GridWidget.refreshGridAfterInsert(jqxGridId, layerName, syncMap);
						}, null, true);
				}
			},
			{
				text: gis_core_5, click: function () {
					App.destroyDialog(undefined, this);
				}
			}
		];
		if(isSystemInsert){
			if(rows.length > 0){
				var columns = rows[0];// в служебном режиме 1-я строка - строка с названиями колонок
				if (columns.length > colNames.length){
					var uniqueColumn = columns.filter(function(nameColumn) { return colNames.indexOf(nameColumn) === -1; });
					if (uniqueColumn && uniqueColumn.length){
						uniqueColumn.forEach(function (uniqueCol) {
							semanticColTypes.forEach(function (col) {
								if (col.name === uniqueCol) {
									switch (col.type) {
										case 'Int64':
										case 'Decimal':
											col.type = 'stringnumber';
											break;
										case 'DateTime':
											col.type = 'date';
											break;
										default:
											col.type = 'string';
											break;
									}
									colTypes[col.name] = col.type;
								}
							})
						});
					}
				}
				//если у колонки есть синоним, то заменяем
				rows.forEach(function(row, i){
					if(i !== 0){
						var data = {};
						//имена колонок приводим в upperCase, чтобы совпадали с названиями переменных
						row.forEach(function(val, valIndex){
							var colName;
							if (columns[valIndex])
								colName = columns[valIndex].toUpperCase();
							var columnType = colTypes[colName];
							var preparedVal = GridUtil.prepareValueByDataType2(val, columnType, colName);
							if(preparedVal !== undefined){
								if(synonyms[colName])
									data[synonyms[colName]] = preparedVal;
								else
									data[colName] = preparedVal;// устанавливаем в колонку соответствующее значение. индексы совпадают
							}
						})
						if(data[idColumn]){// если есть в данных ID, то обновление данных
							isInsert = false;
							rows4Update.push({rowData: data, classId:layerName, objectId:data[idColumn],  dataAdapter: curDataAdapter, colTypes: colTypes});
							rows4UpdateIds.push(data);
						}
						else
							rows4Insert.push({rowData: data, classId:layerName, objectId:'',  dataAdapter: curDataAdapter, colTypes: colTypes});
					}
				});
				if(rows4Update.length > 0){
					GridWidget.prototype.selectFullDataBeforeUpdateDB(curDataAdapter, rows4UpdateIds, function(result){
						var rows4UpdateLength = rows4Update.length;
						rows4Update.forEach(function (rowData, index) {
							var it = rowData.rowData;
							if(!it) return;
							//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
							var itemFromDb = result[it[idColumn]];
							var isLastRow = (rows4UpdateLength - 1) === index;
							if(itemFromDb){
								rowData.rowData = $.extend(itemFromDb,it);
							}
						});
						App.confirmDialog(gis_gridwidget_111_1.replace('{ROWS_COUNT}', rows4Update.length), buttons, {title:gis_core_1, html:true});
					});
					return;
				}
			}
		}
		else{
			try{
				rows.forEach(function (row, index) {
					var data = {};
					var valueCounter = 0;
					for(var i = 0; i < colNames.length; i++){
						var colName = colNames[i].toUpperCase();
						var columnType = colTypes[colName];
						if(valueCounter >= row.length ) break;
						var val = row[valueCounter];
						var preparedVal = GridUtil.prepareValueByDataType2(val, columnType, colName);
						if(preparedVal !== undefined)
							data[colName] = preparedVal;
						valueCounter++;
					}
					rows4Insert.push({rowData: data, classId:layerName, objectId:data[idColumn],  dataAdapter: curDataAdapter, colTypes: colTypes});
				});
			}
			catch (ex){
				throw new Error(gis_gridwidget_88);
			}
		}

		if(isInsert)
			App.confirmDialog(gis_gridwidget_111.replace('{ROWS_COUNT}', rows4Insert.length), buttons, {title:gis_core_1, html:true});
		else
			App.confirmDialog(gis_gridwidget_111_1.replace('{ROWS_COUNT}', rows4Update.length), buttons, {title:gis_core_1, html:true});
	}catch (ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_61'});
	}
	finally {
		curDataAdapter.currentGridDescr.pasteFromExcelData = undefined;
	}
}
/**
 * Обновление ячеек грида данными, скопированными из Excel
 * @param currentGrid текущий грид
 * @param curDataAdapter текущий адаптер грида
 */
GridWidget.prototype.updateCells = function (currentGrid, curDataAdapter, syncMap) {
	var that = this;
	try{
		if(currentGrid && curDataAdapter && curDataAdapter.currentGridDescr && curDataAdapter.currentGridDescr.pasteFromExcelData && curDataAdapter.currentGridDescr.lastEditedCell){
			var jqxGridId = currentGrid.id;
			var currentGridDescr = curDataAdapter.currentGridDescr;
			var lastEditedCell = currentGridDescr.lastEditedCell;
			var cols = currentGridDescr.gridColumns;
			var colNames = [];
			var colTypes = {};
			var confirmLabel = gis_gridwidget_101;
			//lastEditedCell = { rwn:rwn, boundIndex: rowBoundIndex, dataField: dataField, event: event} ;
			var dataField = lastEditedCell.dataField;
			var rowBoundIndex = lastEditedCell.boundIndex;
			confirmLabel = confirmLabel.replace('{ROW_NUM}', lastEditedCell.rwn);
			cols.forEach(function (it, index) {
				if(it.datafield && !Number.isInteger(it.datafield) && !it.hidden && it.datafield !== 'RWN'){
					colNames.push(it.datafield);
					colTypes[it.datafield] = it.columntype;
					if(it.datafield === currentGridDescr.lastEditedCell.dataField)
						confirmLabel = confirmLabel.replace('{COL_NAME}', (it.text)?it.text.replace(/\\n/g,' '):'');
				}
			});
			//ищем индекс колонки, начиная с которой пойдет заполнение
			var startIndex = colNames.indexOf(dataField);
			if(startIndex !== -1){
				var rows = GridUtil.convertPlainExcelDataToTable(currentGridDescr.pasteFromExcelData);
				//получаем элементы, которые будут обновляться
				var rows4Update = [];
				var rows4UpdateIds = []; // массив всех идентификаторов на обновление
				rows.forEach(function (row, index) {
					var valueCounter = 0;
					var rowBoundElement = $(currentGrid).jqxGrid('getrowdata', rowBoundIndex);
					var data = (rowBoundElement.ID)?GridUtil.getFullRowDataById(currentGrid, rowBoundElement):data;
					if(data){
						for(var i = startIndex; i < colNames.length; i++){
							var colName = colNames[i];

							//добавляем в значение колонки по очереди каждый элемент вставляемой строки
							if(valueCounter >= row.length ) break;
							var columnType = colTypes[colName];
							var preparedVal = GridUtil.prepareValueByDataType2(row[valueCounter++], columnType, colName);
							if(preparedVal !== undefined){
								data[colName] = preparedVal;
							}
							//data[colName] = row[valueCounter++];
						}
						rows4Update.push(data);
						rows4UpdateIds.push(data.ID);
					}
					rowBoundIndex++;
				});

				var buttons = [
					{
						text: gis_core_4, click: function () {
							App.destroyDialog(undefined, this);
							that.selectFullDataBeforeUpdateDB(curDataAdapter, rows4Update, function(result){
								var rows4UpdateLength = rows4Update.length;
								rows4Update.forEach(function (it, index) {
									//перекрываем свойства объекта из селекта теми, что в гриде установили для обновления
									var itemFromDb = result[it.ID];
									var isLastRow = (rows4UpdateLength - 1) === index;
									if(itemFromDb){
										var extIt = $.extend(itemFromDb,it);
										that.updateCellDB(curDataAdapter, extIt, syncMap, jqxGridId, isLastRow, rows4UpdateIds);
									}
								});

								//that.updateCellDBWithSync(curDataAdapter, rows4Update, jqxGridId, syncMap);
								//TODO добавить счетчик
								//GridWidget.refreshGrid(jqxGridId);
							});
						}
					},
					{
						text: gis_core_5, click: function () {
							App.destroyDialog(undefined, this);
						}
					}
				];

				confirmLabel = confirmLabel.replace('{ROWS_COUNT}', rows4Update.length).replace('{ALL_ROWS_COUNT}', rows.length);
				App.confirmDialog(confirmLabel, buttons, {title:gis_core_1, html:true})
				return;
			}
			throw new Error(gis_gridwidget_88)
		}
	}
	catch(ex){
		App.errorReport(gis_gridwidget_91, ex.message, undefined, {filename:gis_filename_243, functionname:'gis_filename_243_60'});
	}
	finally {
		delete curDataAdapter.currentGridDescr.lastEditedCell;
		curDataAdapter.currentGridDescr.pasteFromExcelData = undefined;
	}
}


/**
 *
 * @param dataAdapter
 * @param data
 * @param syncMap
 * @param jqxGridId  идентификатор грида, который нужно обновить
 * @param isLastRow  если последняя строка - обновляем грид
 * @param rows4UpdateIds весь массив идентификаторов на обновление
 */
GridWidget.prototype.updateCellDB = function(dataAdapter, data, syncMap, jqxGridId, isLastRow, rows4UpdateIds){
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = (!data.ID) ? 'insert' : 'update';
		//добавляем атрибут SYS_OBJ_ID, т.к. update в панелях свойств использует его
		if(descrType === 'update') {
			//для случая ИУС Т добавляем FILTER, для для случая обновления через панель свойств
			data.FILTER = 'ID=' + data.ID;
			data.SYS_OBJ_ID = data.ID;
		}
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(data), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					var title = GridUtil.getDetailDbError(er);
					App.errorReport(title, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_56'
					});
				}
				/*if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, [data.ID], true);
				}*/
			}
			if(isLastRow){
				if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, rows4UpdateIds, true)
				}
				GridWidget.refreshGrid(jqxGridId)
			}

		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				var title = GridUtil.getDetailDbError(er);
				App.errorReport(title, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_57'
				});
			}
			if(isLastRow){
				if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, rows4UpdateIds, true)
				}
				GridWidget.refreshGrid(jqxGridId)
			}
		},4);
	}
}


GridWidget.prototype.updateCellDBWithSync = function(dataAdapter, data, syncMap, jqxGridId, isLastRow){
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = (!data.ID) ? 'insert' : 'update';
		//добавляем атрибут SYS_OBJ_ID, т.к. update в панелях свойств использует его
		if(descrType === 'update') {
			//для случая ИУС Т добавляем FILTER, для для случая обновления через панель свойств
			data.FILTER = 'ID=' + data.ID;
			data.SYS_OBJ_ID = data.ID;
		}
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData(data), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					var title = GridUtil.getDetailDbError(er);
					App.errorReport(title, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_56'
					});
				}
				if(syncMap && MapUtil){
					MapUtil.updateLayerData(layerId, [data.ID], true);
				}
			}
		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				var title = GridUtil.getDetailDbError(er);
				App.errorReport(title, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_57'
				});
			}
		});
	}
}
/**
 * Функция получает полную детализацию данных, которые собираемся редактировать
 * @param dataAdapter
 * @param {Array}  datas
 * @param {function} successCallback
 */
GridWidget.prototype.selectFullDataBeforeUpdateDB = function(dataAdapter, datas, successCallback){
	var layerId = dataAdapter.currentGridDescr.layerId;
	var layerManagerInst = dataAdapter.currentGridDescr.layerManager;
	var curLayerObj = layerManagerInst.getLayerByName(layerId);
	if (curLayerObj) {
		var dataRequest = curLayerObj.dataProvider.semantic;
		var descrType = 'select';
		var filterIds = [];
		datas.forEach(function (it) {
			filterIds.push(it.ID);
		});
		var reqParams = DBUtil.getReqParams(dataRequest, DBUtil.serializeData({FILTER:'ID in ('+filterIds.join()+')'}), descrType);
		BlockingUtil.wait();
		App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
			BlockingUtil.ready();
			if (resultXML) {
				var er = HTTPServiceUtil.getError(resultXML);
				if (er !== "") {
					App.errorReport(gis_gridwidget_90, er, undefined, {
						filename: gis_filename_243,
						functionname: 'gis_filename_243_58'
					});
				}
				else{
					//парсим данные в объект из ключей идентификаторов и отправляем назад в callabck
					var resDatas = {};
					var xmlData = $.parseXML(resultXML);
					//Сохраняем для переиспользования
					$(xmlData).find("data").each(function () {
						var resData = {};
						for (var curAttrInd = 0; curAttrInd < this.attributes.length; curAttrInd++) {
							resData[this.attributes[curAttrInd].name] = this.attributes[curAttrInd].value;
						}
						if(resData.ID === undefined) resData.ID = resData.CODE;
						resDatas[resData.ID] = resData;
					});
					if(successCallback)
						successCallback(resDatas);
				}
			}
		},function (resultXML) {
			BlockingUtil.ready();
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				App.errorReport(gis_gridwidget_90, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_59'
				});
			}
		});
	}
}


GridWidget.prototype.pasteFromExcelStoIliDataAdvDialog = function(currentGrid, dataAdapter, rowData) {
	var that = this;
	var divv = '<div id="pasteFromExcelStoIliDataAdvDialog">' +
		'<label style="color: #ffffff">' + gis_gridwidget_122 + '</label><br/>'+
		'<label style="color: #ffffff">' + gis_gridwidget_123 + '</label>'+
		'<textarea id="pasteFromExcelText" style="width:465px;margin: 1px;color: #005d98;height: 55px;font-size: 11px; font-family: Verdana,Arial,sans-serif;" class="map-link-text"></textarea>' +
		'</div>';
	$('body').append(divv);
	var dlg = $('#pasteFromExcelStoIliDataAdvDialog');
	var bts = [
		{
			text: gis_core_12,
			click: function(){
				var pastedText =  $('#pasteFromExcelText').val();
				if(pastedText === ''){
					App.confirmDialog(gis_gridwidget_126, null, {title:gis_core_1});
					return;
				}
				if(dataAdapter && dataAdapter.currentGridDescr) {
					dataAdapter.currentGridDescr.pasteFromExcelData = pastedText;
					var dataRequest = 'STO_SEM.xml#STO_ILI_DATA_ADV';
					GridUtil.getProvDataXml(dataRequest, function(parametersTypes){
						// parametersTypes - переменная, куда заносим типы колонок из файла запросов для данной команды, далее ищем по ключу
						GridUtil.pasteStoIliDataAdvCells(currentGrid, dataAdapter, rowData, dataRequest, parametersTypes, that, true);
					})
				}
				$('#pasteFromExcelStoIliDataAdvDialog').remove();
			}
		},
		{
			text: gis_core_6,
			click: function(){
				$('#pasteFromExcelStoIliDataAdvDialog').remove();
			}
		}];
	dlg.dialog({
		modal: true,
		title: gis_gridwidget_119,
		dialogClass: 'ui-dialog-confirm noCloseButton gsi-zindex__dialog',
		closeOnEscape: true,
		width: 474,
		height: 250,
		resizable: false,
		buttons : bts
	});
};

GridWidget.linkStoDataAdv = function(iliInspectionId, jqxGridId){
	BlockingUtil.wait();
	var reqParams = DBUtil.getReqParams('STO_SEM.xml#STO_ILI_DATA_ADV_LINK', DBUtil.serializeData({ILI_INSPECTION_ID: iliInspectionId}), 'update');
	App.serverQueryXMLNodeWithTries(Services.processQueryNode, reqParams, function (resultXML) {
		BlockingUtil.ready();
		if (resultXML) {
			var er = HTTPServiceUtil.getError(resultXML);
			if (er !== "") {
				var title = GridUtil.getDetailDbError(er);
				App.errorReport(title, er, undefined, {
					filename: gis_filename_243,
					functionname: 'gis_filename_243_56'
				});
			}
			else { //обновляем грид
				GridWidget.refreshGrid(jqxGridId);
				App.confirmDialog(gis_gridwidget_128);
			}
		}
	},function (resultXML) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXML);
		if (er !== "") {
			var title = GridUtil.getDetailDbError(er);
			App.errorReport(title, er, undefined, {
				filename: gis_filename_243,
				functionname: 'gis_filename_243_57'
			});
		}
	},4);
}


/**
 * Функция обновления содержимого грида по входящему новому фильтру. Т.к. название слоя, отвечающего за грид совпадает,
 * то для исключения избыточных запросов на загрузку описания грида xml, справочников   перезапрашиваем только данные на основе нового фильтра
 * @param filter
 */
GridWidget.prototype.updateGridContent = function(filter, forceTopFilter, forceRefresh, parentRoughFilter, filterMap, parentRoughParams, staticParentRoughFilter){
	this.filter = filter;
	this.modified = false;
	var gridElem = $("#" + this.id);
	//Если грида нет - возможно, окно грида уже закрыли - ничего не делаем
	if (gridElem.length === 0 && !this.dataAdapter)
		return;


	//var dataAdapter = $(gridElem).jqxGrid('source');
	var gridDescription = this.dataAdapter.currentGridDescr;
	/*gridDescription.source = dataAdapter;
	gridElem.jqxGrid(gridDescription);*/

	var curFilter = filter;
	var topFilter = (forceTopFilter !== true) ? gridDescription.topFilter : [];

	var fArr = [];
	//если был верхний фильтр, то параметры заменяем только те, что совпадают по имени
	if(topFilter && topFilter.length > 0){
		topFilter.forEach(function(item){
			var finded = false;
			for(var obj in filter){
				if(item.name === obj){
					fArr.push({name:obj, value:filter[obj]});
					finded = true;
					break;
				}
			}
			if(!finded) {
				fArr.push(item);
			}
		});
	}
	else{
		for(var obj in filter){
			fArr.push({name:obj, value:filter[obj]});
		}
	}
	fArr = GridWidget.removeDuplicateFilterData(fArr);
	this.filters = fArr;

	var gridId = 'jqxgrid'+this.id;
	//Сохраняем его в виджет грида и перезапршиваем грид
	gridDescription.topFilter = fArr;//$.extend( gridDescription.topFilter, filter ); //верхний фильтр
	gridDescription.currentFilter = []; // нижний фильтр
	gridDescription.roughFilter = []; //средний фильтр
	//обнулуляем нижний фильтр
	try{
		$('#'+gridId+'_bottomFilter').remove(); //jqxgridid8254_GRID_bottomFilter
	}
	catch(ex){ }

	//обнуляем сортировку
	gridDescription.currentSort = [];
	//обнуляем закешированные данные
	this.cachedRecords = [];
	this.parentRoughFilter = undefined;
	this.parentRoughParams = undefined;
	this.staticParentRoughFilter = undefined;
	if(parentRoughFilter) this.parentRoughFilter = parentRoughFilter;
	if(parentRoughParams) this.parentRoughParams = parentRoughParams;
	if(staticParentRoughFilter) this.staticParentRoughFilter = staticParentRoughFilter;
	if(filterMap) this.filterMap = filterMap;

	//обнуляем текущее состояние(если скрывали колонки)
	this.currentState = null;
	//Перезапрашиваем грид
	GridWidget.refreshGrid(gridId, forceRefresh === true);//jqxgridid4438_GRID
};

GridWidget.removeDuplicateFilterData = function(filter){
	return filter;
}

/**
 * Функция обновления грида на обснове изменных колонок
 * @param currentGrid
 * @param columns
 */
GridWidget.prototype.updateDataWithColumns = function(currentGrid, columns){
	var gridWidget = App && App.GridManager && App.GridManager.getByGridId(currentGrid.id.replace('jqxgrid',''))//jqxgridid9860_GRID
	var dataArr = gridWidget.cachedRecords;
	var dataAdapter = gridWidget.dataAdapter;
	gridWidget.columns = columns;
	gridWidget.modified = true;

	//сначала фильтруем начальные данные по видимым колонкам
	var hiddenColumns = [];

	columns.forEach(function (column) {
		if (column.hidden)
			hiddenColumns.push(column);
	})
	dataArr = GridUtil.filterDataFromJson(dataArr, hiddenColumns);
	var visibleDataArr = dataArr;
	if (gridWidget.jqxDataAdapterCallback !== undefined) {
		var resultObj = {
			records: visibleDataArr,
			totalrecords: dataAdapter.totalrecords
		};
		//dataAdapter.localdata = visibleDataArr;
		$(currentGrid).jqxGrid({ columns: columns });
		//Добавляем через имеющуюся функцию обратного вызова плагина jqxDataAdapter
		gridWidget.jqxDataAdapterCallback(resultObj);
		$(currentGrid).jqxGrid('render');
	}
	else {
		/*gridSource.localdata = gridData;
		//Обновляем записи в гриде
		$(currentGrid).jqxGrid({ source: gridSource });*/
	}
}



GridWidget.successIliReportCalcCorr = function(){
	//перезагружаем слои из сценариев на карте
	ExternalInteraction.showLayers(App.scenarioManager.openLayers)
	App.confirmDialog(gis_gridwidget_157, null, {title: gis_core_1});
}

GridWidget.prototype.setLayerId = function(layerId) {
	var lId = layerId;
	if(layerId && layerId.indexOf('#') !== -1){
		this.layerId = layerId.split('#')[1];
		this.fullLayerId = layerId.replace('#', '*');
		lId = this.layerId;
	}
	return lId;
}

/*
 * Наследие старой версии
 * 
 * Много разных функций в глобальной области видимости,
 * в основном связанные с взаимодействием между несколькими окнами браузера
 */

//==============================================================================

// Globals
var requiredMajorVersion = 10; // Major version of Flash required
var requiredMinorVersion = 1;  // Minor version of Flash required
var requiredRevision = 0;      // Minor version of Flash required

var arrPage = {};
var arrTemplates = {};

//свойства страницы
var task = "";
var idWnd = "";

//заполнил массив настроек дочерних окон из файла windowTemplates.xml
function loadWindowTemplates(file) {
    $.ajax({
        type: "GET",
        timeout: App.clientRequestTimeout,
        url: file, // путь к файлу, который будем читать
        dataType: "xml", // тип данных, с которыми работаем
        success: function (xml_data) {
            var data = $(xml_data).find('data');
            //цикл по ids
            $(data).each(function()
            {
                var id = $(this).attr('id');
                arrTemplates[id] = $(data).attr('template');
            });
        }
    });
};

function getSessionParams() {
    //return [{"sessionParam1":"value"}];
    return [];
};
function getURL() {
    return document.location.toString().replace(/\?.*/, '');
};

//получает параметры авторизации, пришедшие из флешки, чтобы с ними формировать  урл
function getAutorization(url) {
    var u =  url;
    return u.substring(u.indexOf('#')+1,u.length);
};

function openNewWindow(url, windowTemplate, taskName, params, callback, minimize) {
    var session_params = getSessionParams(); //пустой массив с параметрами сессии
    params = params.concat(session_params);
    // получаем параметры авторизации, если они есть из урл. после "#"
    var authParams = getAutorization(url);

    url = getURL(); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (url.lastIndexOf("#") != -1) {
        url = url.substr(0, url.lastIndexOf("#"));
    }

    //Добавляем полученные параметры в URL
    url += "?task=" + taskName;

    for (var i = 0; i < params.length; i++) {
        url += "&";
        url += params[i]["name"] + "=" + params[i]["value"];
    }
    //генерируем по новому идендификатор, т.к. прошлый вариант с "?" кидал ошибку при открытии окна
    var id = "id" + Math.floor(Math.random() * (10000)) + "_" + taskName;
    var idStr = id.split("_")[0];

    var idWindow;
    try {
        //Открываем на текущей странице браузера, если это грид, который не требует открытия в новом окне
        //добавляем проверку. Если браузер не 8, то имеем возможность работать с многовкладочным гридом
        if (isCanvasSupported() && taskName=='GRID') {
            var gridPopup = new GridWindow();
            //Полученный iframe будем сохранять как окно в общем списке окон
            try{
                if(callback)//прокидываем назад вновь созданный идентификатор грида
                    callback(id);
            }
            catch(ex){ }
            idWindow = gridPopup.build(url+'#'+authParams, id, params, arrTemplates[windowTemplate], minimize);
        }
        else
            idWindow = window.open(url+'#'+authParams, id, arrTemplates[windowTemplate]);
    }
    catch (e) {
        return null;
    }

    try {
        idWindow.task = taskName;
        //А вот id меняем только для окон, для iframe id менять нельзя!
        /*if (idWindow.tagName.toLowerCase() != 'iframe') {
         idWindow.id = idStr;
         } else { //для iframe мы должны вернуть в качестве idStr id фрейма (он генерируется при создании фрейма)
         idStr = idWindow.id;
         }*/
        //Выставил для всех окон id, чтобы корректно работало получение данных для фильтра (при запросе из дочерних окон)
        idWindow.id = idStr;
        arrPage[idStr] = {
            "childWindow": idWindow
        };
    }
    catch (e) {
        return idStr;
    }

    return idStr;
};

function openNewWindowExt(url, windowTemplate, taskName, params, callback) {
    var session_params = getSessionParams(); //пустой массив с параметрами сессии
    params = params.concat(session_params);
    // получаем параметры авторизации, если они есть из урл. после "#"
    var authParams = getAutorization(url);

    url = getURL(); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (url.lastIndexOf("#") != -1) {
        url = url.substr(0, url.lastIndexOf("#"));
    }

    //Добавляем полученные параметры в URL
    url += "?task=" + taskName;

    for (var i = 0; i < params.length; i++) {
        url += "&";
        url += params[i]["name"] + "=" + params[i]["value"];
    }

    var correctW = screen.width;
    var correctH = screen.height;
    correctH -=200;//смещаем чуть ниже
    correctW -= 50;
    var x = 20;
    var y = 80;
    //генерируем по новому идендификатор, т.к. прошлый вариант с "?" кидал ошибку при открытии окна
    var id = "id" + Math.floor(Math.random() * (10000)) + "_" + taskName;
    var idStr = id.split("_")[0];

    var idWindow;
    try {
        //Открываем на текущей странице браузера, если это грид, который не требует открытия в новом окне
        //добавляем проверку. Если браузер не 8, то имеем возможность работать с многовкладочным гридом
        if (isCanvasSupported() && taskName=='GRID') {
            var gridPopup = new GridWindow();
            //Полученный iframe будем сохранять как окно в общем списке окон
            try{
                if(callback)//прокидываем назад вновь созданный идентификатор грида
                    callback(id);
            }
            catch(ex){ }
            idWindow = gridPopup.build(url+'#'+authParams, id, params, arrTemplates[windowTemplate]);
        }
        else
            window.open(url+'#'+authParams, 'EXTRA__' +App.generateUUID(), 'height='+correctH+',width='+correctW+',menubar=no,location=no,directories=no,status=no,resizable=yes,scrollbars=yes,left='+x+',top='+y+'');
            //idWindow = window.open(url+'#'+authParams, id, arrTemplates[windowTemplate]);
    }
    catch (e) {
        return null;
    }

    try {
        idWindow.task = taskName;
        idWindow.id = idStr;
        arrPage[idStr] = {
            "childWindow": idWindow
        };
    }
    catch (e) {
        return idStr;
    }

    return idStr;
};

function getOpener() {
    //Если у окна текущая задача - грид, родителем для iframe-окна будет parent, а opener==undefined
    if (window.opener==undefined || window.opener==null) {
        return window.parent;
    }
    //Для открытых окон возвращаем opener
    return window.opener;
};

function callFunction(windowId, funcName, params) {
    var wnd = getOpener();

    //добавляем id окна, в который opener должен вернуть данные
    if (wnd == "") {
        return -1;
    }
    if (typeof wnd == "string") {
        return wnd;
    }
    if (!wnd) {
        return -1; //окно еще не создавалось
    }
    if (wnd.closed) {
        return -1; //закрыто
    }

    try {
        //так функции вызываются
        //fix
        if(funcName === 'enableLayer' || funcName === 'disableLayer' || funcName === 'updateCacheLayer' ){
            ExternalInteraction.callFunction(windowId, funcName, params);
            return 1;
        }else{
            var fApp = getCurrentFlexApp(wnd,"Client_Main");
            if (fApp != null) {
                fApp[funcName](params);
            }
            wnd.focus();
        }

    }
    catch (e) {
        return 0;
    }

    return 1;
};

function callbackFunction(windowId, funcName, params) {
    var wnd;
    //Добавляем проверку наличия windowId в объекте arrPage - если его нет, значит функцию пробуем вызвать в текущем окне
    var inCurrentWindow = arrPage && arrPage.hasOwnProperty(windowId) ? false : true;
    if(windowId!=='' && windowId!=null && windowId!=undefined && !inCurrentWindow) {
        wnd = arrPage[windowId]["childWindow"]; //получает связанную страницу по id
    }
    else {
        wnd = getOpener();
    }

    //добавляем id окна, в который opener должен вернуть данные
    if (wnd == "") {
        return -1;
    }
    if (typeof wnd == "string") {
        return wnd;
    }

    if (!wnd) {
        return -1; //окно еще не создавалось
    }
    if (wnd.closed)	{
        return -1; //закрыто
    }

    try {
        //Поскольку имена функций вызова и возврата значений могут быть одинаковыми, узнаем что именно нужно делать по содержимому params
        switch (funcName) {
            case 'callbackFilter':
                /*Вызов получения фильтра из грида и возвращение результата с фильтром из карты имеют различия только внутри массива params
                 Если внутри массива единственный элемент и этот элемент - объект {name: 'layer', value: 'PODS_ILI_DATA'} - это вызов из грида
                 Если возвращается объект {name:'filter', value:'LPU_ACCESS_FILTER:13006,13009,13011,13004,13003,13000,13008,13013,13002,13005,13001,13007,0|ILI_DATA_FILTER:130021,130022|OLD_LPU_ACCESS_FILTER:13006,13009,13011,13004,13003,13000,13008,13013,13002,13005,13001,13007,0'}
                 это ответ из карты
                 */
                if (params && params.length > 0) {
                    var firstParam = params[0];
                    //Если пришел результат от флешовой карты - вызываем последнюю сохраненную в App.callbackFilter функцию
                    if (firstParam.hasOwnProperty('name') && firstParam['name']=='filter') {

                        ExternalInteraction.callbackFilter(params);
                        return 1;
                    }
                }
                //Иначе нужно перейти далее к выполнению вызова функции во флеше
                break;
            default:
                break;
        }
        var filter = $('#treeDiv').myCategories('callbackFilter',{params:params});
        // если нет рубрикатора, либо в рубрикаторе нет фильтров, то всегда используем предзагруженный фильтр по ЛПУ
        if (!filter) filter = {
            params: [{
                name: 'filter', value: ''
            }]
        };

        if(filter.params && filter.params.length === 1 && filter.params[0].name === 'filter' && filter.params[0].value === ''){
            //добавляем фильтр по ЛПУ
            /*for(var it in WidgetMap.currentTopFilter){
                if(WidgetMap.currentTopFilter[it].name === 'LPU_ACCESS_FILTER')
                    filter.params[0].value = WidgetMap.currentTopFilter[it].name+':'+WidgetMap.currentTopFilter[it].value;
            }*/
            //добавляем все фильтры верхнего уровня
            var topFilterArr = [];
            for(var it in WidgetMap.currentTopFilter){
                topFilterArr.push(WidgetMap.currentTopFilter[it].name+':'+WidgetMap.currentTopFilter[it].value);
            }
            if(topFilterArr && topFilterArr.length)
            filter.params[0].value = topFilterArr.join('|');
        }
        //добавляем roughFilter в params, если он присутствует
        if(goog.isDef(WidgetMap.currentRoughFilter) && WidgetMap.currentRoughFilter.length > 0){
            var layerName = '';
            if(params && params.length > 0){
                for(var i=0; i < params.length; i++){
                    if(params[i].name === 'layer'){// если нашли в параметрах слой, к которому фильтр относится, то дальше в ищем его в фильтре
                        layerName = params[i].value;
                        break;
                    }
                }
            }
            if(layerName !== ''){
                if(WidgetMap.currentRoughFilter && WidgetMap.currentRoughFilter.length > 0) {
                    if(!WidgetMap.currentRoughFilter[0].layerName){
                        filter.params.push({name:'roughFilter',value:WidgetMap.currentRoughFilter[0].name+':'+WidgetMap.currentRoughFilter[0].value});
                    }
                    else if(WidgetMap.currentRoughFilter[0].layerName === layerName){
                            filter.params.push({name:'roughFilter',value:WidgetMap.currentRoughFilter[0].name+':'+WidgetMap.currentRoughFilter[0].value});
                    }
                }
                ExternalInteraction.callbackFilter(filter.params);
                return 1;
            }
            filter.params.push({name:'roughFilter',value:WidgetMap.currentRoughFilter[0].name+':'+WidgetMap.currentRoughFilter[0].value});
        }
        ExternalInteraction.callbackFilter(filter.params);
        return 1;
    }
    catch (e) {
        return 0;
    }

    return 1;
};

function getCurrentFlexApp(wnd,appName) {
//добавил проверки на то, что окно является фреймом, чтобы иметь возможность достучаться до его контента и получить флешки
    if (navigator.appName.indexOf ("Microsoft") != -1) {
        if(wnd.toString().indexOf('HTMLIFrameElement')!=-1)
        {
            return wnd.contentWindow[appName];
        }
        return wnd.window[appName];
    }
    else {
        if(wnd.toString().indexOf('HTMLIFrameElement')!=-1)
        {
            return wnd.contentDocument[appName];
        }
        return wnd.document[appName];
    }
};

function fillWndProperties() {
    var splittedArr;
    //Если у окна текущая задача - грид, родителем для iframe-окна будет parent, а opener==undefined
    if (window.opener==undefined || window.opener==null) {
        splittedArr = window.name.split("_");
        //Подстрока до первого символа "_" это id окна
        idWnd = splittedArr.shift();
        //Все, что следует после первого символа "_" это название задачи (может содержать символы "_"!)
        task = splittedArr.join("_");
    }
    else
    {
        if (window.name.split("_")[0] == "") {
            idWnd = "id" + Math.floor(Math.random() * (10000));
        }
        else {
            splittedArr = window.name.split("_");
            //Подстрока до первого символа "_" это id окна
            idWnd = splittedArr.shift();
            //Все, что следует после первого символа "_" это название задачи (может содержать символы "_"!)
            task = splittedArr.join("_");
        }
    }
};

// снять этот комментарий в следующем выпуске
$(document).ready(function () {
    // метод, который заполняет id окна и task окна
    fillWndProperties();
    loadWindowTemplates("windowTemplates.xml");
});


//==============================================================================
//Оригинальный заголовок формы, нужен для исправления ошибки IE 6+, при которой title для окна необходимо устанавливать с задержкой, чтобы IE не подставлял в title текущий URL
var originalTitle = document.title;

function getFlexApp(appName) {
    if (navigator.appName.indexOf ("Microsoft") != -1) {
        return window[appName];
    }
    else {
        return document[appName];
    }
};
// Код для исправления ошибки IE 6+, при которой title для окна необходимо устанавливать с задержкой, чтобы IE не подставлял в title текущий URL
function initListeners() {
    var titleEl = document.getElementsByTagName("title")[0];

    if (titleEl && titleEl.addEventListener) {
        titleEl.addEventListener("DOMSubtreeModified", function(evt) {
            var t = evt.target;
            if (t === titleEl || (t.parentNode && t.parentNode === titleEl)) {
                if(document.title !== originalTitle)
                    setTimeout(function () {
                        document.title = originalTitle;
                    }, 1);
            }
        }, false);
    } else {
        document.attachEvent('onpropertychange', function (evt) {
            if (evt.propertyName === 'title' && document.title !== originalTitle) {
                setTimeout(function () {
                    document.title = originalTitle;
                }, 1);
            }
        });
    }
};

initListeners();

function onLogin() {
    var app = getFlexApp("Client_Main");
    if (app != null) {
        try	{
            app.login(loginI.value, passI.value);
        }
        catch (e) {
            setTimeout('onLogin()',5000);
        }
    }
    else {
        setTimeout('onLogin()',5000);
    }
};

/**
 * Открытие карты в iframe
 * @param taskName
 * @param params
 * @param guid
 */
function openMapWithinIframe(taskName, params, guid) {
    guid = guid || '';
    var authStr = Auth.getAuthStr();
    if (authStr === undefined || authStr === null) authStr = "";
    var currentUrl = getURL() + "#" + authStr;
    // получаем параметры авторизации, если они есть из урл. после "#"
    var authParams = getAutorization(currentUrl);
    var url = currentUrl.replace(/\?.*/, ''); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (url.lastIndexOf("#") != -1) {
        url = url.substr(0, url.lastIndexOf("#"));
    }
    //Добавляем полученные параметры в URL
    url += "?task=" + taskName;
    for (var i = 0; i < params.length; i++) {
        url += "&";
        url += params[i]["name"] + "=" + params[i]["value"];
    }
    
    var draftDashboard = App.dashboardManager.getCurrentDashboard();
    var width = 474;
    var height = 360;
    if(WidgetMap && WidgetMap.config && WidgetMap.config.map && WidgetMap.config.map.position){
        var position = getPositionFromConfig(WidgetMap.config.map.position);
        width = position.width;
        height = position.height;
    }
    var dialogId = 'mapWidgetInlineFrameDialog' + guid;
    url += "&dialogId=" + dialogId;
    var siteUrl = url+'#'+authParams;
    var divv = '<div id="' + dialogId +'"><iframe id="mapWidgetInlineFrame"' +
        '    title="' + gis_head55_2 + '"' +
        '    width="100%"' +
        '    height="100%"' +
        '    src="' + siteUrl + '">' +
        '</iframe></div>';

    $('body').append(divv);
    var dlg = $('#'+dialogId);
    dlg.dialog({
        modal: false,
        title: gis_head55_2,
        dialogClass: 'gsi-zindex__map',
        closeOnEscape: false,
        width: width,
        height: height,
        appendTo: '.taskContent',
        close: function(){
            draftDashboard.removeMap(dialogId);
            App.destroyDialog(null, dlg);
        },
        resizable: true,
        buttons : [],
    }).dialogExtend({
        "maximizable" : true,
        "minimizable" : true,
        "minimizeLocation" : "right",
        "icons" : {
            "close" : "ui-icon-gisCloseButton",
            "maximize" : "ui-icon-gisMaximizeButton",
            "minimize" : "ui-icon-gisMinimizeButton",
            "collapse" : "ui-icon-triangle-1-s",
            "restore" : "ui-icon-gisRestoreButton"
        },
    });

    var mapObj = {
        url: url.replace(window.location.origin, ''),
        id: dialogId,
        position: {
            left: 0,
            top: 0,
            width: width + 'px',
            height: height + 'px',
        }
    }
    draftDashboard.addMap(mapObj);

}


function buildMapWithinIframe(config) {
    var guid = config.id;
    var authStr = Auth.getAuthStr();
    if (authStr === undefined || authStr === null) authStr = "";
    var draftDashboard = App.dashboardManager.getCurrentDashboard();
    var position = getPositionFromConfig(config.position);
    var width = position.width;
    var height = position.height;
    var siteUrl = config.url+'#'+authStr;
    var dialogId = 'mapWidgetInlineFrameDialog' + guid;
    var divv = '<div id="' + dialogId +'"><iframe id="mapWidgetInlineFrame"' +
        '    title="' + gis_head55_2 + '"' +
        '    width="100%"' +
        '    height="100%"' +
        '    src="' + siteUrl + '">' +
        '</iframe></div>';

    $('body').append(divv);
    var dlg = $('#'+dialogId);
    dlg.dialog({
        modal: false,
        title: gis_head55_2,
        dialogClass: 'gsi-zindex__map',
        closeOnEscape: false,
        width: width,
        height: height,
        position: [position.left, position.top],
        appendTo: '.taskContent',
        close: function(){
            draftDashboard.removeMap(dialogId);
            App.destroyDialog(null, dlg);
        },
        resizable: true,
        buttons : [],

    }).dialogExtend({
        "maximizable" : true,
        "minimizable" : true,
        "minimizeLocation" : "right",
        "icons" : {
            "close" : "ui-icon-gisCloseButton",
            "maximize" : "ui-icon-gisMaximizeButton",
            "minimize" : "ui-icon-gisMinimizeButton",
            "collapse" : "ui-icon-triangle-1-s",
            "restore" : "ui-icon-gisRestoreButton"
        },
    });
    var mapObj = {
        url: siteUrl.replace(window.location.origin, ''),
        id: dialogId,
        position: position,
    }
    draftDashboard.addMap(mapObj);

}

/**
 * Открытие карты в iframe
 * @param url
 * @param config
 */
function openMapWithinIframeByUrl(url, config) {
    var left = 0, top = 0;
    var width = 474, height = 360;
    var pos = {my: "left top", at: "left top", of: 'body', collision: 'none'};
    var isDashboard = false;
    var closeOnEscape = false, dialogClass = '';
    var resizable = true, draggable = true;
    if(config){
        var position = getPositionFromConfig(config, true);
        width = position.width;
        height = position.height;
        left = position.left;
        top = position.top;
        //pos = {my: "left+" + position.left + " top+" + position.top, at: "left top", of: 'body', collision: 'none'};
        isDashboard = true;
        closeOnEscape = false;
        resizable = false;
        draggable = false;
        dialogClass = 'noCloseButton';
    }
    var siteUrl = url
    var divv = '<div id="mapWidgetInlineFrameDialog"><iframe id="mapWidgetInlineFrame"' +
        '    title="' + gis_head55_2 + '"' +
        '    width="100%"' +
        '    height="100%"' +
        '    src="' + siteUrl + '">' +
        '</iframe></div>';

    $('.taskContent').append(divv);

    var dlg = $('#mapWidgetInlineFrameDialog');
    dlg.dialog({
        modal: false,
        title: gis_head55_2,
        dialogClass: dialogClass,
        closeOnEscape: closeOnEscape,
        width: width,
        height: height,
        position: pos,
        appendTo: '.taskContent',
        close: function(){
            App.destroyDialog(null, dlg);
        },
        resizable: resizable, draggable: draggable,
        buttons : []
    }).dialogExtend({
        "maximizable" : true,
        "minimizable" : true,
        "minimizeLocation" : "right",
        "icons" : {
            "close" : "ui-icon-gisCloseButton",
            "maximize" : "ui-icon-gisMaximizeButton",
            "minimize" : "ui-icon-gisMinimizeButton",
            "collapse" : "ui-icon-triangle-1-s",
            "restore" : "ui-icon-gisRestoreButton"
        },
    });
    if(isDashboard){
        dlg.addClass('hide-dialog');
        setTimeout(function(){
        //    $('html').scrollTop(0);
            pos = {my: "left+" + position.left + " top+" + position.top, at: "left top", of: 'body', collision: 'none'};
            dlg.dialog({ position: pos});
            dlg.removeClass('hide-dialog').addClass('show-dialog');
        }, 4000)

        //$('html').scrollTop(0);
    }
    var mapObj = {
        url: url.replace(window.location.origin, ''),
        id: dialogId,
        position: {
            left: 0,
            top: 0,
            width: width + 'px',
            height: height + 'px',
        }
    }
    draftDashboard.addMap(mapObj);

}

/**
 * Открытие ПКА в iframe
 * @param taskName
 * @param params
 * @param guid
 */
function openCasWithinIframe(taskName, params, guid) {
    guid = guid || '';
    var authStr = Auth.getAuthStr();
    if (authStr === undefined || authStr === null) authStr = "";
    var currentUrl = getURL() + "#" + authStr;
    currentUrl = currentUrl.replace('main_js.html','cas_js.html').replace('main.html','cas_js.html');
    // получаем параметры авторизации, если они есть из урл. после "#"
    var authParams = getAutorization(currentUrl);
    var url = currentUrl.replace(/\?.*/, ''); //получить URL без параметров в строке
    //Обрезаем последний символ '#' и всё после него, он относился к авторизации
    if (url.lastIndexOf("#") != -1) {
        url = url.substr(0, url.lastIndexOf("#"));
    }
    //Добавляем полученные параметры в URL
    url += "?task=" + taskName+'&mdl=cas_js.html';
    var title = (params && params.title) ? params.title : gis_head55_3;
    delete params.title;
    Object.keys(params).forEach(function(key){
        url += '&' + key + '=' + params[key];
    });
    var width = 1032;
    var height = 560;
    if(WidgetMap && WidgetMap.config && WidgetMap.config.cas && WidgetMap.config.cas.position){
        var position = getPositionFromConfig(WidgetMap.config.cas.position);
        width = position.width;
        height = position.height;
    }

    var siteUrl = url+'#'+authParams;
    var dialogId = 'mapWidgetInlineFrameDialog' + guid;
    var divv = '<div id="' + dialogId +'"><iframe id="mapWidgetInlineFrame"' +
        '    width="100%"' +
        '    height="100%"' +
        '    src="' + siteUrl + '">' +
        '</iframe></div>';

    $('.taskContent').append(divv);
    var dlg = $('#'+dialogId);
    dlg.dialog({
        modal: false,
        title: title,
        dialogClass: 'gsi-zindex__map',
        closeOnEscape: false,
        width: width,
        height: height,
        appendTo: ".taskContent",
        resizable: true,
        buttons : [],
        close: function(){
            App.destroyDialog(null, dlg);
        }
    }).dialogExtend({
        "maximizable" : true,
        "minimizable" : true,
        "minimizeLocation" : "right",
        "icons" : {
            "close" : "ui-icon-gisCloseButton",
            "maximize" : "ui-icon-gisMaximizeButton",
            "minimize" : "ui-icon-gisMinimizeButton",
            "collapse" : "ui-icon-triangle-1-s",
            "restore" : "ui-icon-gisRestoreButton"
        },
    });
}
/*
 * Скрипт главной страницы (main.html)
 */
$('.datePicker').datepicker();
//Linux. Счетчик попыток перезапроса данных, если выдается ошибка apache2
App.userTasksLoadErrorCounter = 5;

$(document).ready(function(){
    //проверка версии браузера и перенаправление
    checkBrowserVersion();


    $(document).ready(fixSizes);
    $(window).resize(fixSizes);

    //Получаем и парсим web.config (возвращается ссылка на запрос, по ней можно отменить загрузку)
    App.getClientConfig(function(){
        Auth.Autorization();
    });
});

// Скорректируем размеры
function fixSizes(hasMenus) {
    var h = $(window).height();
    $('.taskContent').height(h);
}

/*
 * Наследие старой версии
 * Загрузка флеш плеера
 */
App.loadFlash = function(swf) {
    // Version check for the Flash Player that has the ability to start Player Product Install (6.0r65)
    var hasProductInstall = DetectFlashVer(6, 0, 65);

    // Version check based upon the values defined in globals
    var hasRequestedVersion = DetectFlashVer(requiredMajorVersion, requiredMinorVersion, requiredRevision);
    var alternateContent =
        '<div class="main">'+
        '<div class="image"><a href="Public/install/install_flash_player.exe" unselectable="on" ><img src="Public/assets/FlashPlayer_Logo.jpg" width="100" height="100" alt="Установить Adobe Flash Player" unselectable="on" title="Установить Adobe Flash Player"/></a></div>' +
        '<div class="text">Для отображения содержимого страницы необходимо установить <a class="orange" href="Public/install/install_flash_player.exe" title="Установить Adobe Flash Player">Adobe Flash Player</a><br/><br/>' +
        'При возникновении проблем с отображением содержимого скачайте <a class="orange" href="Public/install/uninstall_flash_player.exe" title="Программа удаления Adobe Flash Player">программу удаления Adobe Flash Player</a>' +
        ' и выполните установку <a class="orange" href="Public/install/install_flash_player.exe" title="Установить Adobe Flash Player">повторно</a><br /> </div>' +
        '<div class="whitebg">' +
        '	После инсталляции необходимо повторно открыть страницу в новом окне браузера' +
        '</div>'+
        '</div>';

    /* new version to detect if browser is IE
     // ----------------------------------------------------------
     // If you're not in IE (or IE version is less than 5) then:
     // ie === undefined
     // If you're in IE (>=5) then you can determine which version:
     // ie === 7; // IE7
     // Thus, to detect IE:
     // if (ie) {}
     // And to detect the version:
     // ie === 6 // IE6
     // ie > 7 // IE8, IE9, IE10 ...
     // ie < 9 // Anything less than IE9
     // ----------------------------------------------------------  */
    var IE = (function(){
        var undef,rv = -1; // Return value assumes failure.
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf('MSIE ');
        var trident = ua.indexOf('Trident/');

        if (msie > 0) {
            // IE 10 or older => return version number
            rv = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        } else if (trident > 0) {
            // IE 11 (or newer) => return version number
            var rvNum = ua.indexOf('rv:');
            rv = parseInt(ua.substring(rvNum + 3, ua.indexOf('.', rvNum)), 10);
        }

        return ((rv > -1) ? rv : undef);
    }());

    /* old version to detect if browser is IE */
    /*var IE='\v'=='v';*/
    if(IE!==undefined) {
        alternateContent =
            '<div class="main">'+
            '<div class="image"><a href="Public/install/install_flash_player_ax.exe" unselectable="on" ><img src="Public/assets/FlashPlayer_Logo.jpg" width="100" height="100" alt="Установить Adobe Flash Player" unselectable="on" title="Установить Adobe Flash Player"/></a></div>' +
            '<div class="text">Для отображения содержимого страницы необходимо установить <a class="orange" href="Public/install/install_flash_player_ax.exe" title="Установить Adobe Flash Player">Adobe Flash Player</a><br/><br/>' +
            'При возникновении проблем с отображением содержимого скачайте <a class="orange" href="Public/install/uninstall_flash_player.exe" title="Программа удаления Adobe Flash Player">программу удаления Adobe Flash Player</a>' +
            ' и выполните установку <a class="orange" href="Public/install/install_flash_player_ax.exe" title="Установить Adobe Flash Player">повторно</a><br /> </div>' +
            '<div class="whitebg">' +
            '	После инсталляции необходимо повторно открыть страницу в новом окне браузера' +
            '</div>'+
            '</div>';
    }
    if ( hasProductInstall && !hasRequestedVersion ) {
        $('.content').html(alternateContent);
    }
    else if (hasRequestedVersion) {
        if(swf) {
            // if we've detected an acceptable version
            // embed the Flash Content SWF when all tests are passed
            AC_FL_RunContent(
                "src",                  swf,
                "width",                "100%",
                "height",               "100%",
                "align",                "top",
                "id",                   "web5",
                "quality",              "high",
                "bgcolor",              "#ffffff",
                "name",                 "Client_Main",
                "allowScriptAccess",    "sameDomain",
                "type",                 "application/x-shockwave-flash",
                "pluginspage",          "http://www.adobe.com/go/getflashplayer",
                "wmode",                "opaque"
            );
        }
        else {
            //document.write('no swf');
        }
    }
    else {  // flash is too old or we can't detect the plugin    
        $('.content').html(alternateContent);  // insert non-flash content
    }
};
/* загрузка флешки с доп. параметрами*/
App.loadFlashVideoModule = function(swf) {
    // Version check for the Flash Player that has the ability to start Player Product Install (6.0r65)
    var hasProductInstall = DetectFlashVer(6, 0, 65);

    // Version check based upon the values defined in globals
    var hasRequestedVersion = DetectFlashVer(requiredMajorVersion, requiredMinorVersion, requiredRevision);
    var alternateContent =
        '<div class="main" style="background: #EAEAEA;color: black; height: 100%;width: 100%;">'+
        '<div class="image"><a href="Public/install/install_flash_player.exe" unselectable="on" ><img src="Public/assets/FlashPlayer_Logo.jpg" width="100" height="100" alt="Установить Adobe Flash Player" unselectable="on" title="Установить Adobe Flash Player"/></a></div>' +
        '<div class="text">Для отображения содержимого страницы необходимо установить <a class="orange" href="Public/install/install_flash_player.exe" title="Установить Adobe Flash Player">Adobe Flash Player</a><br/><br/>' +
        'При возникновении проблем с отображением содержимого скачайте <a class="orange" href="Public/install/uninstall_flash_player.exe" title="Программа удаления Adobe Flash Player">программу удаления Adobe Flash Player</a>' +
        ' и выполните установку <a class="orange" href="Public/install/install_flash_player.exe" title="Установить Adobe Flash Player">повторно</a><br /> </div>' +
        '<div class="whitebg">' +
        '	После инсталляции необходимо повторно открыть страницу в новом окне браузера' +
        '</div>'+
        '</div>';

    /* new version to detect if browser is IE
     // ----------------------------------------------------------
     // If you're not in IE (or IE version is less than 5) then:
     // ie === undefined
     // If you're in IE (>=5) then you can determine which version:
     // ie === 7; // IE7
     // Thus, to detect IE:
     // if (ie) {}
     // And to detect the version:
     // ie === 6 // IE6
     // ie > 7 // IE8, IE9, IE10 ...
     // ie < 9 // Anything less than IE9
     // ----------------------------------------------------------  */
    var IE = (function(){
        var undef,rv = -1; // Return value assumes failure.
        var ua = window.navigator.userAgent;
        var msie = ua.indexOf('MSIE ');
        var trident = ua.indexOf('Trident/');

        if (msie > 0) {
            // IE 10 or older => return version number
            rv = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        } else if (trident > 0) {
            // IE 11 (or newer) => return version number
            var rvNum = ua.indexOf('rv:');
            rv = parseInt(ua.substring(rvNum + 3, ua.indexOf('.', rvNum)), 10);
        }

        return ((rv > -1) ? rv : undef);
    }());

    /* old version to detect if browser is IE */
    /*var IE='\v'=='v';*/
    if(IE!==undefined) {
        alternateContent =
            '<div class="main"  style="background: #EAEAEA;color: black; height: 100%;width: 100%;">'+
            '<div class="image"><a href="Public/install/install_flash_player_ax.exe" unselectable="on" ><img src="Public/assets/FlashPlayer_Logo.jpg" width="100" height="100" alt="Установить Adobe Flash Player" unselectable="on" title="Установить Adobe Flash Player"/></a></div>' +
            '<div class="text">Для отображения содержимого страницы необходимо установить <a class="orange" href="Public/install/install_flash_player_ax.exe" title="Установить Adobe Flash Player">Adobe Flash Player</a><br/><br/>' +
            'При возникновении проблем с отображением содержимого скачайте <a class="orange" href="Public/install/uninstall_flash_player.exe" title="Программа удаления Adobe Flash Player">программу удаления Adobe Flash Player</a>' +
            ' и выполните установку <a class="orange" href="Public/install/install_flash_player_ax.exe" title="Установить Adobe Flash Player">повторно</a><br /> </div>' +
            '<div class="whitebg">' +
            '	После инсталляции необходимо повторно открыть страницу в новом окне браузера' +
            '</div>'+
            '</div>';
    }
    if ( hasProductInstall && !hasRequestedVersion ) {
        $('#videoPlayerDiv').html(alternateContent);
    }
    else if (hasRequestedVersion) {
        if(swf) {
            if(App && App.config && App.config.APP_60_SERVER)
                swf = swf.replace('./', App.config.APP_60_SERVER);
            // if we've detected an acceptable version
            // embed the Flash Content SWF when all tests are passed
            AC_FL_RunContentModule(
                "parentElementId",      "videoPlayerDiv",
                "src",                  swf,
                "width",                "100%",
                "height",               "100%",
                "align",                "top",
                "id",                   "videoPlayer55",
                "quality",              "high",
                "bgcolor",              "#ffffff",
                "name",                 "videoPlayer55",
                "allowScriptAccess",    "always",//"sameDomain",
                "type",                 "application/x-shockwave-flash",
                "pluginspage",          "http://www.adobe.com/go/getflashplayer",
                "wmode",                "opaque"
            );
        }
        else {
            //document.write('no swf');
        }
    }
    else {  // flash is too old or we can't detect the plugin
        $('#videoPlayerDiv').html(alternateContent);  // insert non-flash content
    }
};

/*Первоначальная загрузка PRELOAD.xml, чтобы не вылетали ошибки при получении геометрии при асинхонных запросах*/
App.Preload = function(widgetElementId, showMap){
    BlockingUtil.wait();
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
	function getReqLPUParams(request, lpuIds) {
		var topFiltersStr = LayerManager.getTopFiltersString(WidgetMap.currentTopFilter);
		return {
			getSchema: false,
			descrId: request,
			toElements: false,
			descrType: 'select',
			data:'<root USER_ID="'+userId.xmlEscape()+
			'" USER_LOGIN="'+userLogin.xmlEscape()+
			'" PODS_USER="'+userLogin.xmlEscape()+
			'" '+ topFiltersStr+''+
			'>'+
			'<data FILTER="'+lpuIds+'"/></root>'
		};
	}
	function faultLPU(resultXml) {
		BlockingUtil.ready();
		App.loadDefaultLpu(widgetElementId, showMap);
	}
	function resultLPU(resultXml) {
		BlockingUtil.ready();
		var er = HTTPServiceUtil.getError(resultXml);
		if(er == ''){
			var layerGeoXml = ($.parseXML(resultXml)).firstChild;
			var datas = layerGeoXml.getElementsByTagName("data");
			var dd = 0;
			var extent = [];
			for (dd; dd < datas.length; dd++) {
				var maxLat = parseFloat(datas[dd].getAttribute('YMAX'));
				var minLat = parseFloat(datas[dd].getAttribute('YMIN'));
				var minLon = parseFloat(datas[dd].getAttribute('XMIN'));
				var maxLon = parseFloat(datas[dd].getAttribute('XMAX'));
				var pnt1= new proj4.toPoint([minLon,minLat]);
				var pnt2= new proj4.toPoint([maxLon,maxLat]);
				var source_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
				var dest_ =  new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
				if(App.projection == GeoUtil.PROJS.Pulkovo42){//преобразуем в wgs84
					var p42WgsPnt = GeoUtil.P42WGS(minLat,minLon);
					pnt1= new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
					p42WgsPnt = GeoUtil.P42WGS(maxLat,maxLon);
					pnt2 = new proj4.toPoint([p42WgsPnt.x, p42WgsPnt.y]);
                }
				proj4.transform(source_, dest_, pnt1);
				proj4.transform(source_, dest_, pnt2);
                if(isNaN(pnt1.x) || isNaN(pnt1.y) || isNaN(pnt2.x) || isNaN(pnt2.y))
                    continue;
				if(extent.length == 0)
				    extent= [pnt1.x, pnt1.y, pnt2.x, pnt2.y];
				else
					extent = ol.extent.extend(extent,[pnt1.x, pnt1.y, pnt2.x, pnt2.y]);
			}
			 // of ol.Extent `[minx, miny, maxx, maxy]`.
			WidgetMap.LPURestrictExtent = extent;
		}
		App.loadDefaultLpu(widgetElementId, showMap);
	}


    function getReqParams(request, fileName) {
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:'<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
            '<data FILE="'+fileName.xmlEscape()+'"/></root>'
        };
    }
    function fault(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== '')
            App.errorReport(gis_body55_3, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_1'});
        App.loadDefaultLpu(widgetElementId, showMap);
    }
    function result(resultXml) {
        var topFilterLoadedCount = 0;
        function getFilterReqParams(request) {
            return {
                getSchema: false,
                descrId: request,
                toElements: false,
                descrType: 'select',
                data:'<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
                '<data/>'+
                '</root>'
            };
        }
        function faultFilter(resultXml) {
            BlockingUtil.ready();
            --topFilterLoadedCount;
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                App.errorReport(gis_body55_4, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_2'});
            }
            if(topFilterLoadedCount == 0){
                App.loadDefaultLpu(widgetElementId, showMap);
            }
        }
        function resultFilter(resultXml) {
            --topFilterLoadedCount;
            BlockingUtil.ready();
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                App.errorReport(gis_body55_4, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_3'});
            }
            else{
                var filtersXml = ($.parseXML(resultXml)).firstChild;
                var datas = filtersXml.getElementsByTagName("data");
                var resArr = [];
                var lpuArr = [];
                var j = 0;
                for (j; j < datas.length; j++) {
                    var curCode = datas[j].getAttribute('CODE');
                    var curDescr =  datas[j].getAttribute('DESCR');
                    var xmin =  datas[j].getAttribute('XMIN');
                    var xmax =  datas[j].getAttribute('XMAX');
                    var ymin =  datas[j].getAttribute('YMIN');
                    var ymax =  datas[j].getAttribute('YMAX');
                    //#1943 upd. Еслди не пришло descr, то заполняем его ''
                    if(curDescr === undefined)curDescr = '';
                    if (!goog.isNull(curCode)) {
                        resArr.push(curCode);
                        var lpu = {CODE:curCode, DESCR:curDescr, XMIN:xmin, XMAX:xmax, YMIN:ymin, YMAX:ymax };
                        WidgetMap.preloadLpuValuesDict[curCode] = lpu;
                        lpuArr.push(lpu);
                    }
                }
                WidgetMap.currentTopFilter.push({name:'LPU_ACCESS_FILTER',value:resArr.join(',')});
                //заносим список доступных пользователю ЛПУ в массив, чтобы далле его считать из фильтра
                WidgetMap.preloadLpuValues = lpuArr;
            }
            if(topFilterLoadedCount == 0){
                //тут добавляем проверку, если LPU_ACCESS_FILTER заполнен, то запрашиваем рамку контура ЛПУ,
                //для дальнейшего использования при отображении трубопроводной сети по контуру ЛПУ #1673
                //
	            if(goog.isDef(WidgetMap.currentTopFilter) &&  WidgetMap.currentTopFilter.length > 0 && goog.isDef(WidgetMap.LPURestrictZoom)){
                    var k=0;
                    for(;k<WidgetMap.currentTopFilter.length;k++){
                        if(goog.isDef(WidgetMap.currentTopFilter[k].name) && WidgetMap.currentTopFilter[k].name == 'LPU_ACCESS_FILTER'){
                            var lpus = WidgetMap.currentTopFilter[k].value;
	                        App.serverQueryXMLNodeWithTries(Services.processQueryNode, getReqLPUParams('SYS_SEM.xml#GET_LPU_BOUNDS', lpus), resultLPU, faultLPU,4);
                            return;
                        }
                    }

                }
                App.loadDefaultLpu(widgetElementId, showMap);
            }
        }
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.errorReport(gis_body55_5, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_4'});
            App.loadDefaultLpu(widgetElementId, showMap);
        }
        else{
            var filtersXml = ($.parseXML(resultXml)).firstChild;
            var datas = filtersXml.getElementsByTagName("data");
            var i = 0;
            topFilterLoadedCount = datas.length;
            for (i; i < datas.length; i++) {
                var provider = datas[i].getAttribute('provider');
                if(!goog.isNull(provider)){
                    BlockingUtil.wait();
                    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getFilterReqParams(provider), resultFilter, faultFilter,4);
                }
            }
        }
    }
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getReqParams('SYS_SEM.xml#GET_XML_FILE', 'PRELOAD.xml'), result, fault);
};

App.loadMap = function(widgetElementId, showMap) {
    //здесь надо разделить карту, рубрикатор, видеоплеер, панель свойств
    var mainDiv =
        '<div id="mainDiv" style="width: 100%; height: 100%;">' +
        '</div>';
    var mapDiv =
        '<div id="map" class="map" tabindex="0">' +
        '</div>'+
        '<div>' +
            '<div id="treeButtonDiv" class="tree-button-div ol-control" ></div>' +
            '<div class="tree-div-rect collapsed" ></div>' +
            '<div id="treeDiv" class="tree-div collapsed" ></div>' +
        '</div>';

    $('#'+widgetElementId).append(mainDiv)
        .on('resize',
        function (event) {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map)){
                WidgetMap.map.updateSize();
            }
        });

    $("#mainDiv").append(mapDiv);
    var isMaximizeed = WidgetMap.getTreeMaximizedFlag();
    //Процентная ширина рубрикатора относительно карты (тег <treePercentWidth>80</treePercentWidth> в задаче)
    var treePercentWidth = WidgetMap.getTreePercentWidth();
    treePercentWidth = treePercentWidth==-1 || !isMaximizeed ? '36%' : treePercentWidth+'%'; //Также учитываем флаг isMaximizeed (чтобы работало как раньше если он false)
    //без таймаута при ресайзе окна обновления размеров карты не применяются
    var curTimeout;
    $(window).on('resize', function(){
        clearTimeout(curTimeout);
        curTimeout = setTimeout(function() {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map))
                WidgetMap.map.updateSize();
        }, 100);
    });
    if(WidgetMap.treeConfig) {
        $('.tree-button-div').click(function () {
            $('.tree-div').toggleClass('collapsed');
            $('.tree-div-rect').toggleClass('collapsed');
            //добавляем сюда скрытие/показ строки поиска, когда спрятали рубрикатор
            if ($('.tree-div').hasClass('collapsed')) {
                $('div.map-search').removeClass('collapsed');
                $('div.search-view').removeClass('collapsed');
                $('div.search-filters').removeClass('collapsed');
                $('div.search-engine-filters').removeClass('collapsed');
            } else {
                $('div.map-search').addClass('collapsed');
                $('div.search-view').addClass('collapsed');
                $('div.search-filters').addClass('collapsed');
                $('div.search-engine-filters').addClass('collapsed');
            }

        });
        //добавляем дерево всегда
        App.addTree();
    }
    var isTreeVisible = !(WidgetMap && WidgetMap.config && WidgetMap.config.tree && WidgetMap.config.tree.visible === false);
    if(!isTreeVisible)
        $('#treeButtonDiv').parent().hide();

    //TODO обработать флаг canRaster, чтобы забрать из rasterlayers растровые трубы
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    var baseLayersUrl = [].concat(mapConfig.rasterlayers);
    var needBg = (WidgetMap && WidgetMap.config && WidgetMap.config.background);
    if(!checkMapExisting() && needBg){
        //нет карты, выставляем задний фон в виде картинки карты трубопроводной сети
        //TODO рефакторить - в отдельную функцию
        $('.map').addClass('no-map');
        $('.taskContent').css('background-color','transparent');
        $('.panels .panel').css('background-color','transparent');
    }
    //загружаем базовые слои
    if(goog.isDefAndNotNull(showMap) && showMap === true && !goog.isDef(WidgetMap.BaseLayersParser)){
        WidgetMap.BaseLayersParser = new BaseLayersParser({urls: baseLayersUrl});
    }
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    var overviewConfig = mapConfig.overview_map;
    if(overviewConfig !== undefined){
        //получаем параметры
        WidgetMap.overviewMapHeight = (overviewConfig.height !== undefined)? parseFloat(overviewConfig.height): 100;
        WidgetMap.overviewMapWidth = (overviewConfig.width !== undefined)?parseFloat(overviewConfig.width): 150;
        var urls = [];
        for(var i in overviewConfig.urls){
            var ovItem = overviewConfig.urls[i];
            urls.push({
                extension: ovItem.extension,
                useInterimTilesOnError: ovItem.useInterimTilesOnError === true,
                interimTilesOnErrorList: ovItem.interimTilesOnErrorList,
                url: ovItem.url
            });
        }
        WidgetMap.BaseLayersParser.parseOverviewLayers(urls);
    }


    if(WidgetMap && WidgetMap.config && WidgetMap.config.maps && WidgetMap.config.maps.length > 0){
        WidgetMap.config.maps.forEach(function(map){
            var currentDashboard = App.dashboardManager.getCurrentDashboard();
            currentDashboard.buildMap(map);
        })
    }
};


//подгружаем список дефолтных лпу, чтобы при запросе данных проходить по ним и запрашивать данные из бд
App.loadDefaultLpu = function (widgetElementId, showMap) {
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    function getFilterReqParams() {
        return {
            getSchema: false,
            descrId: "PODS_SEM_DICT.xml#PODS_SRV_DISTRICT_GCL",
            toElements: false,
            descrType: 'select',
            data: '<root USER_ID="' + userId.xmlEscape() +
                '" USER_LOGIN="' + userLogin.xmlEscape() +
                '" PODS_USER="' + userLogin.xmlEscape() + '" >' +
                '<data />' +
                '</root>'
        };
    }

    function faultFilter(resultXml) {
        App.loadMap(widgetElementId, showMap);
    }

    function resultFilter(resultXml) {
        var er = HTTPServiceUtil.getError(resultXml);
        if (er === '') {
            var filtersXml = ($.parseXML(resultXml)).firstChild;
            var datas = filtersXml.getElementsByTagName("data");
            WidgetMap.defaultLpuIds = [];
            for (var j = 0; j < datas.length; j++) {
                var curCode = datas[j].getAttribute('CODE');
                if (!goog.isNull(curCode)) {
                    WidgetMap.defaultLpuIds.push(""+curCode);
                }
            }
        }
        App.loadMap(widgetElementId, showMap);
    }
    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getFilterReqParams(), resultFilter, faultFilter,4);
};

/*Первоначальная загрузка PRELOAD.xml, чтобы не вылетали ошибки при получении геометрии при асинхонных запросах*/
App.PreloadCAS = function(widgetElementId, showMap){
    BlockingUtil.wait();
    var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
    var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
    function getReqParams(request, fileName) {
        return {
            getSchema: false,
            descrId: request,
            toElements: false,
            descrType: 'select',
            data:'<root USER_ID="'+userId.xmlEscape()+
            '" USER_LOGIN="'+userLogin.xmlEscape()+
            '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
            '<data FILE="'+fileName+'"/></root>'
        };
    }
    function fault(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== '')
            App.errorReport(gis_body55_3, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_1'});
        App.loadCASMap(widgetElementId, showMap);
    }
    function result(resultXml) {
        var topFilterLoadedCount = 0;
        function getFilterReqParams(request) {
            return {
                getSchema: false,
                descrId: request,
                toElements: false,
                descrType: 'select',
                data:'<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
                '<data/>'+
                '</root>'
            };
        }
        function faultFilter(resultXml) {
            BlockingUtil.ready();
            --topFilterLoadedCount;
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                App.errorReport(gis_body55_4, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_2'});
            }
            if(topFilterLoadedCount == 0){
                App.loadCASMap(widgetElementId, showMap);
            }
        }
        function resultFilter(resultXml) {
            --topFilterLoadedCount;
            BlockingUtil.ready();
            var er = HTTPServiceUtil.getError(resultXml);
            if(er !== ''){
                App.errorReport(gis_body55_4, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_3'});
            }
            else{
                var filtersXml = ($.parseXML(resultXml)).firstChild;
                var datas = filtersXml.getElementsByTagName("data");
                var resArr = [];
                var lpuArr = [];
                var j = 0;
                for (j; j < datas.length; j++) {
                    var curCode = datas[j].getAttribute('CODE');
                    var curDescr =  datas[j].getAttribute('DESCR');
                    var xmin =  datas[j].getAttribute('XMIN');
                    var xmax =  datas[j].getAttribute('XMAX');
                    var ymin =  datas[j].getAttribute('YMIN');
                    var ymax =  datas[j].getAttribute('YMAX');
                    //#1943 upd. Еслди не пришло descr, то заполняем его ''
                    if(curDescr === undefined)curDescr = '';
                    if (!goog.isNull(curCode)) {
                        resArr.push(curCode);
                        var lpu = {CODE:curCode, DESCR:curDescr, XMIN:xmin, XMAX:xmax, YMIN:ymin, YMAX:ymax };
                        WidgetMap.preloadLpuValuesDict[curCode] = lpu;
                        lpuArr.push(lpu);
                    }
                }
                WidgetMap.currentTopFilter.push({name:'LPU_ACCESS_FILTER',value:resArr.join(',')});
                //заносим список доступных пользователю ЛПУ в массив, чтобы далле его считать из фильтра
                WidgetMap.preloadLpuValues = lpuArr;
            }
            if(topFilterLoadedCount == 0){
                App.loadCASMap(widgetElementId, showMap);
            }
        }
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.errorReport(gis_body55_5, er, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_4'});
            App.loadCASMap(widgetElementId, showMap);
        }
        else{
            var filtersXml = ($.parseXML(resultXml)).firstChild;
            var datas = filtersXml.getElementsByTagName("data");
            var i = 0;
            topFilterLoadedCount = datas.length;
            for (i; i < datas.length; i++) {
                var provider = datas[i].getAttribute('provider');
                if(!goog.isNull(provider)){
                    BlockingUtil.wait();
                    App.serverQueryXMLNodeWithTries(Services.processQueryNode, getFilterReqParams(provider), resultFilter, faultFilter,4);
                }
            }
        }
    }
    App.serverQueryXmlFileNodeWithTries(Services.processQueryNodeXml, getReqParams('SYS_SEM.xml#GET_XML_FILE', 'PRELOAD.xml'), result, fault);
};

App.loadCASMap = function(widgetElementId) {
    var routeNameDiv = '<div id="casRouteNameDiv" class="casRouteNameDiv"><label id="casRouteName" /></div>';

    var vScrollDiv =
        '<div id="vScrollKm">' +
        '</div>';
    var hScrollDiv =
        '<div style="width: 100%; height: 25px;">' +
            '<div id="hScrollBeginKm"/>' +
            '<div id="hScrollKm"></div>' +
            '<div id="hScrollEndKm"/>' +
        '</div>';
    var mainDiv =
        '<div id="mainDiv" style="width: 98%; height: 100%;">' +
        '</div>';
    var mapDiv =
        '<div id="lmap" class="lmap">' +
        '</div>'+
        '<div id="map" class="map" tabindex="0">' +
        '</div>';

    $('#'+widgetElementId).append(routeNameDiv).append(hScrollDiv).append(mainDiv)
        .on('resize',
        function (event) {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map)){
                WidgetMap.map.updateSize();
                WidgetMap.lmap.updateSize();
            }
        }).append(vScrollDiv);

    $("#mainDiv").append(mapDiv);
    $(mapDiv).width( $(window).width()-430);
    //устанавливаем размеры легенды и отступ карты в зависимости от параметра
    //устанавливаем параметры из конфига
    WidgetMap.CAS_LEGEND_WIDTH = 190;
    WidgetMap.getMapDrawParams();
    $('#lmap').css('width', WidgetMap.CAS_LEGEND_WIDTH+'px');
    //смещаем влево на 4, чтобы визуально вертикальный разделитель легенды и карты выглядел норм
    $('#map').css('margin-left', (WidgetMap.CAS_LEGEND_WIDTH)+'px');
    //без таймаута при ресайзе окна обновления размеров карты не применяются
    var curTimeout;
    $(window).on('resize', function(){
        clearTimeout(curTimeout);
        curTimeout = setTimeout(function() {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map)){
                WidgetMap.map.updateSize();
                WidgetMap.lmap.updateSize();
                WidgetMap.mapSizeChanged();
            }
            var slider = $('#hScrollKm');
            var legendSize = 140;
            if(slider.length>0){
                if(goog.isDef(WidgetMap.map)){
                    var mapWidth = WidgetMap.map.getSize()[0]-80+190-8;
                    slider.jqxScrollBar({width:mapWidth});
                }
            }
        }, 100);
    });
    $('#CAS').css('visibility','hidden');
    if(getParameterByName('func') == 'showCAS'){
        WidgetMap.checkExternalParamsFromURL();
    }
    else if(getParameterByName('lineId')!=''){
        WidgetMap.loadLineData();
    }
    else{
        taskReady('showCAS',true);
        //выдать сообщение, что нет line_ID
        //App.errorReport('Ошибка при получении данных.','Не указан идентификатор трубопровода');
    }

};

App.loadMapTech = function(widgetElementId, showMap) {
    //здесь надо разделить карту, рубрикатор, видеоплеер, панель свойств
    var mainDiv =
        '<div id="mainDiv" style="width: 100%; height: 100%;">' +
        '</div>';
    var mapDiv =
        '<div id="map" class="map" tabindex="0" style="background: white;">' +
        '</div>';
    //Рубрикатор для тех. схемы
	if(WidgetMap.treeConfig){
        mapDiv =
            '<div id="map" class="map" tabindex="0" style="background: white;">' +
            '</div>'+
            '<div>' +
            '<div id="treeButtonDiv" class="tree-button-div ol-control" ></div>' +
            '<div class="tree-div-rect collapsed" ></div>' +
            '<div id="treeDiv" class="tree-div collapsed" ></div>' +
            '</div>';
    }



    $('#'+widgetElementId).append(mainDiv);
    //$('#'+widgetElementId).append(propertyDiv);// insert non-flash con
    $('#'+widgetElementId).on('resize',
        function (event) {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map)){
                WidgetMap.map.updateSize();
            }
        });

    $("#mainDiv").append(mapDiv);


    //без таймаута при ресайзе окна обновления размеров карты не применяются
    var curTimeout;
    $(window).on('resize', function(){
        clearTimeout(curTimeout);
        curTimeout = setTimeout(function() {
            if(goog.isDefAndNotNull(WidgetMap) && goog.isDefAndNotNull(WidgetMap.map))
                WidgetMap.map.updateSize();
        }, 100);
    });
    if(WidgetMap.treeConfig){
        $('.tree-button-div').click(function(){
            $('.tree-div').toggleClass('collapsed');
            $('.tree-div-rect').toggleClass('collapsed');
            //добавляем сюда скрытие/показ строки поиска, когда спрятали рубрикатор
            if($('.tree-div').hasClass('collapsed')){
                $('div.map-search').removeClass('collapsed');
                $('div.search-view').removeClass('collapsed');
                $('div.search-filters').removeClass('collapsed');
            }
            else{
                $('div.map-search').addClass('collapsed');
                $('div.search-view').addClass('collapsed');
                $('div.search-filters').addClass('collapsed');
            }
        });
        //добавляем дерево всегда
        App.addTree();
    }
    var mapConfig = (WidgetMap.config && WidgetMap.config.map) ? WidgetMap.config.map: WidgetMap.config;
    var baseLayersUrl = [].concat(mapConfig.rasterlayers);
    /*if(!baseLayersUrl){
        //нет карты, выставляем задний фон в виде картинки карты трубопроводной сети
        $('.map').addClass('no-map');
        $('.taskContent').css('background-color','transparent');
        $('.panels .panel').css('background-color','transparent');
    }*/
    //загружаем базовые слои
    if(goog.isDefAndNotNull(showMap) && showMap === true && !goog.isDef(WidgetMap.BaseLayersParser)){
        WidgetMap.BaseLayersParser = new BaseLayersParser({urls: baseLayersUrl});
    }
    //TODO добавить preload
    //WidgetMap.preload();
    WidgetMap.init();
};


//Загрузка виджета грида в элемент с переданным ID (widgetElementId) по шаблону грида (gridTemplate)
//typeOfGrid - тип грида (от этого зависит каким классом будем обрабатывать описание грида)
App.loadWidgetGrid = function(widgetElementId, gridTemplate, fullLayerId, gridTitle, gridType, options) {
    var gridWidget;
    //Разделяем загрузку обычных гридов и гридов административных задач
    if (gridType && gridType.toLowerCase()=="gridadmwidget")
        gridWidget = new GridAdmWidget({id:widgetElementId, fullLayerId: fullLayerId});
    else if (gridType && gridType.toLowerCase()=="gridadmfileswidget")
        gridWidget = new GridAdmFilesWidget({id:widgetElementId, fullLayerId: fullLayerId});
    else if (gridType && gridType.toLowerCase()=="gridadmmapswidget")
        gridWidget = new GridAdmMapsWidget({id:widgetElementId, fullLayerId: fullLayerId});
    else{
        var parentGrid, childGrid, parentRoughFilter, parentRoughParams, filterMap, showDashboard, ignoreLabelColumn,
            staticParentRoughFilter, parentGridRowId, parentGridFilter;
        for(var i in options){
            if(options[i].name === "parentGrid"){
                parentGrid = options[i].value;
            }
            if(options[i].name === "parentRoughFilter"){
                parentRoughFilter = options[i].value;
            }
            if(options[i].name === "staticParentRoughFilter"){
                staticParentRoughFilter = options[i].value;
            }
            if(options[i].name === "parentRoughParams"){
                parentRoughParams = options[i].value;
            }
            if(options[i].name === "filterMap"){
                filterMap = options[i].value;
            }
            if(options[i].name === "childGrid"){
                childGrid = options[i].value;
            }
            if(options[i].name === "showDashboard"){
                showDashboard = options[i].value == 'true';
            }
            if(options[i].name === "ignoreLabelColumn"){
                ignoreLabelColumn = options[i].value == 'true';
            }
            if(options[i].name === "parentGridRowId"){
                parentGridRowId = options[i].value;
            }
            if(options[i].name === "parentGridFilter"){
                parentGridFilter = options[i].value;
            }
        }
        var filter = {};
        for(var i in options){
            if(options[i].name === "filter"){
                filter = options[i].value;
                break;
            }
        }
        gridWidget = new GridWidget({
            id: widgetElementId,
            fullLayerId: fullLayerId,
            filter: filter,
            parentGrid: parentGrid,
            childGrid: childGrid,
            parentRoughFilter: parentRoughFilter,
            parentRoughParams: parentRoughParams,
            filterMap: filterMap,
            showDashboard: showDashboard,
            ignoreLabelColumn: ignoreLabelColumn,
            parentGridRowId: parentGridRowId,
            parentGridFilter: parentGridFilter,
            staticParentRoughFilter: staticParentRoughFilter
        });
    }
    if(App && App.GridManager){
        App.GridManager.add(gridWidget);
    }
    //Возвращаем построенный элемент, содержащий виджет грида.
    //Пока что интерфейс загрузки гридов одинаковый, в будущем возможно будет необходимость разделения и здесь
    return gridWidget.build(widgetElementId, gridTemplate, fullLayerId, gridTitle);
};
App.scenarioParams = undefined;

App.addTree = function(){
    if(WidgetMap !== undefined && WidgetMap.getTreeMaximizedFlag()){
        $('.tree-div').removeClass('collapsed');
        $('.tree-div-rect').removeClass('collapsed');
    }

    $('#treeDiv').myCategories({width:'100%',startJson:WidgetMap.treeConfig,
        handlers:{
	        checkHeadRadioHandler:function(params){
                //если ранее не было основной обработки сценариев, то используем старый механизм
                //TODO нужно что-то делать со сценариями, чтобы исключить зависимость от рубрикатора
                if(!App.scenarioParams )
                    ExternalInteraction.treeCallFunction(params, 'loadScenario');
                if(App.scenarioParams && App.scenarioParams.mainScenario === true){
                    params.vars = App.scenarioParams.vars;
                    ExternalInteraction.treeCallFunction(params, 'loadScenario');
                }

            },
            errorHandler:function(params){
	            App.errorReport(gis_categories_6, params.text, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_10'});},
            checkHandler:function(params){ExternalInteraction.treeCallFunction(params,'enableLayer');},
            uncheckHandler:function(params){ExternalInteraction.treeCallFunction(params,'disableLayer');},
            setLayerVisibility:function(params){
                return ExternalInteraction.getLayersVisibility(params);
            },
            contextMenuHandler:
                function(params){ExternalInteraction.treeCallFunction(params,'clickButton');}
        }});
};

App.loadVideoPlayer = function(widgetElementId, docId, videoUrl, videoName, lineId) {
  try {
    //здесь надо разделить карту, рубрикатор, видеоплеер, панель свойств
    //TODO почистить код
    var closeEvt = new VideoPlayerEvent(VideoPlayerEvent.CLOSE);
    var COOKIE_VIDEO_PANEL_WIDTH = 'gis_web55_video_panel_width';
    var COOKIE_VIDEO_PANEL_HEIGHT = 'gis_web55_video_panel_height';
    var COOKIE_VIDEO_PANEL_X = 'gis_web55_video_panel_x';
    var COOKIE_VIDEO_PANEL_Y = 'gis_web55_video_panel_y';


    closeEvt.dispatch();
    if($('#videoWindow').length == 0){
        var videoDiv = '<div id="videoWindow" style="height: auto;">' +
            '<div>Видеоплеер</div><div id="videoPlayerDiv" style="width: 100%; height: 100%;"></div>'+
            '</div>';
        $('body').prepend(videoDiv);
        var videoConfig = WidgetMap.videoConfig;
        var vHeight = '280';
        var vWidth = '440';
        var vX = '5';
        var vY = '460';
        var currResize = [440,280];
        try{
            vHeight = videoConfig.height;
            vWidth = videoConfig.width;
            vX = videoConfig.x;
            vY = videoConfig.y;
        }
        catch(e){
            try{ console.log(e.stack) } catch(err) {};
        }
        //забираем/сохраняем в куки
        App.hasCookie(COOKIE_VIDEO_PANEL_HEIGHT)?vHeight = App.getCookie(COOKIE_VIDEO_PANEL_HEIGHT):App.setCookie(COOKIE_VIDEO_PANEL_HEIGHT,vHeight);
        App.hasCookie(COOKIE_VIDEO_PANEL_WIDTH)?vWidth = App.getCookie(COOKIE_VIDEO_PANEL_WIDTH):App.setCookie(COOKIE_VIDEO_PANEL_WIDTH,vWidth);
        App.hasCookie(COOKIE_VIDEO_PANEL_X)?vX = App.getCookie(COOKIE_VIDEO_PANEL_X):App.setCookie(COOKIE_VIDEO_PANEL_X,vX);
        App.hasCookie(COOKIE_VIDEO_PANEL_Y)?vY = App.getCookie(COOKIE_VIDEO_PANEL_Y):App.setCookie(COOKIE_VIDEO_PANEL_Y,vY);

        var vPosition = '{x:'+vX+', y:'+vY+'}';

        //если в куках было значение "на весь экран"
        var needCollapse = false;
        if(parseFloat(vHeight)>3000 && parseFloat(vWidth)>3000){
            vHeight = '280';
            vWidth = '440';
            needCollapse = true;
            vPosition =  '{x:0, y:0}';
        } else if (parseFloat(vHeight)<50 || parseFloat(vWidth)<50){
            //Обрабатываем ситуацию, когда во флеш-версии были записаны куки со свернутого окна видеоплеера - тогда нужно показывать его в обычном дефолтном положении
            vHeight = '280';
            vWidth = '440';
            vX = '5';
            vY = '460';
        }
        //Создаем окно видеоплеера
        $('#videoWindow').jqxVideoWindow({title:'', height: vHeight, width: vWidth, position: vPosition, showCollapseButton: true, theme:'gis-blue'});

        $('#videoWindow').on('resized', function (event) {
            //если не раскыли на весь экран, а просто за края раздвигали(collapsed == true - значит на весь экран, т.к. функционал кнопки сворачивания исправлялся))
            if(event.args !== undefined && $('#videoWindow').jqxVideoWindow("collapsed") == false){
                App.setCookie(COOKIE_VIDEO_PANEL_HEIGHT,event.args.height);
                App.setCookie(COOKIE_VIDEO_PANEL_WIDTH,event.args.width);
                currResize = [event.args.width,event.args.height];
            }
        });
        $('#videoWindow').on('collapse', function (event) {
            //если не раскыли на весь экран, а просто за края раздвигали(collapsed == true - значит на весь экран, т.к. функционал кнопки сворачивания исправлялся))
                App.setCookie(COOKIE_VIDEO_PANEL_HEIGHT,10000);
                App.setCookie(COOKIE_VIDEO_PANEL_WIDTH,10000);
        });
        $('#videoWindow').on('expand', function (event) {
            App.setCookie(COOKIE_VIDEO_PANEL_HEIGHT,currResize[1]);
            App.setCookie(COOKIE_VIDEO_PANEL_WIDTH,currResize[0]);
        });
        $('#videoWindow').on('moved', function (event) {
            //если не раскыли на весь экран, а просто двигали(collapsed == true - значит на весь экран, т.к. функционал кнопки сворачивания исправлялся))
            if(event.args !== undefined && $('#videoWindow').jqxVideoWindow("collapsed") == false){
                App.setCookie(COOKIE_VIDEO_PANEL_X,event.args.x);
                App.setCookie(COOKIE_VIDEO_PANEL_Y,event.args.y);
            }
        });
        $('#videoWindow').on('close', function (event) {
            try {
                //в таком виде флешки из памяти убираются при закрытии
                $('#videoPlayer55').remove();
                $('#videoWindow').jqxVideoWindow('destroy');
                //$('#videoWindow').remove();
                var closeEvt = new VideoPlayerEvent(VideoPlayerEvent.CLOSE);
                closeEvt.dispatch();
            }
            catch (e) {
                App.errorReport(gis_videoplayerwindow_2, e, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_7'});
            }
        });
        if(needCollapse == true){
            $('#videoWindow').jqxVideoWindow('move',0,0);
            $('#videoWindow').jqxVideoWindow('collapse');
        }
        else
            $('#videoWindow').jqxVideoWindow('move',vX,vY);

    }

    App.loadFlashVideoModule("./Public/SWF/VideoPlayer_55.swf");


    //Функция перезапуска воспроизведения - флешка грузится не сразу, так что делаем отложенный запуск
    function startVideo() {
        var wnd = getOpener();
        var fApp = getCurrentFlexApp(wnd,"videoPlayer55");
        if (fApp != null) {
            try	{
                fApp['showVideo'](docId, videoUrl, lineId);
                if(WidgetMap.startVideoAutoFocusFlag !== undefined)
                    widgetVideoSetAutoFocus(WidgetMap.startVideoAutoFocusFlag,true);
            }
            catch (e) {
                setTimeout(startVideo,5000);
            }
        }
        else {
            setTimeout(startVideo,5000);
        }
    }
    //Запускаем воспроизведение
    startVideo();
  } catch (videoErr) {
      App.errorReport(gis_body55_1, gis_body55_2 + videoErr.message, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_8'});
  }
};


/**
 * Получение информации о пользователе
 * @param panelId
 * @param showMap
 * @constructor
 */
App.PreloadUser = function(panelId, showMap){
    var that = this;
    function getCurrentUserDataParams( ) {
        var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
        var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
        return {
            getSchema: false,
            descrId: "ADM_SEM.xml#WEB50_B_USER_PRIVATE",
            toElements: false,
            descrType: 'select',
            data:  '<root USER_ID="'+userId.xmlEscape()+
                '" USER_LOGIN="'+userLogin.xmlEscape()+
                '" PODS_USER="'+userLogin.xmlEscape()+
                '">'+
                '<data FILTER="'+' d.USER_ID='+userId+'" />'+
                '</root>'
        };
    }

    function getCurrentUserDataResult(resultXml) {
        BlockingUtil.ready();
        var er = HTTPServiceUtil.getError(resultXml);
        if(er !== ''){
            App.loadPanelMap(panelId, showMap);
            return;
        }
        var resultXml = ($.parseXML(resultXml)).firstChild;
        var datas = resultXml.getElementsByTagName("data");
        if(datas.length>0){
            var data = datas[0];
            var themeAttr = goog.isNull(data.getAttribute("THEME"))?'':data.getAttribute("THEME")+'';
            //получаем флаги на режим открытия карты и показ обзорной карты
            if(themeAttr !== ''){
                try{
                    var theme = JSON.parse(themeAttr.replace(/&quot;/g,'"'));
                    var mode = MapUtil.getAvailableMapMode(theme.MAP_MODE);
                    if(WidgetMap !== undefined){
                        MapUtil.applyThemeParams({
                            mapMode: mode,
                            showOverviewMap: theme.SHOW_OVERVIEW_MAP === true,
                            showTree: theme.SHOW_TREE === true,
                            sendCadastreEmail: theme.SEND_CADASTRE_EMAIL === true,
                            showCenterMap: theme.SHOW_CENTER_MAP === true,
                            coordMode: theme.COORD_MODE,
                            useSynchronization: theme.USE_SYNCHRONIZATION === true,
                        },true);
                    }
                }
                catch(e){

                }
            }
            App.loadPanelMap(panelId, showMap);
        }

    }
    function getCurrentUserDataFault(resultXml) {
        App.loadPanelMap(panelId, showMap);
    }
    App.serverQueryXML2Node(Services.processQueryNode, getCurrentUserDataParams(), getCurrentUserDataResult, getCurrentUserDataFault);
};

App.cookieMessageShowed = false;
App.loadPanelMap = function(panelId, showMap){
    //проверяем, что включены куки
    var areCookiesEnabled = App.areCookiesEnabled();//если включены куки
    if(!areCookiesEnabled){
        if(!App.cookieMessageShowed)
            App.showCookieMessage(gis_core_15);
        App.cookieMessageShowed = true;
    }
    switch(panelId){
        case 'adm_lib_doc' :
        case 'MAPSERVICE' :
            App.Preload(panelId,true);
            break;
        case 'MAPSERVICE_ADM_TREE' :
            App.loadMap(panelId,true); //Исправление по адм. задачам - показываем карту
            break;
        case 'MAPTECHSERVICE' :
            App.loadMapTech(panelId, showMap);
            break;
        case 'CAS' :
            App.PreloadCAS(panelId,true);
            break;
    }

    App.UNIQUE_ID = App.generateUUID();
    //включаем режим синхронизации
    if (App.syncManager)
        App.syncManager.turnOn();
    App.addFastAccessButtons(panelId);
}


App.addFastAccessButtons = function(panelId){
    if(WidgetMap && WidgetMap.config && WidgetMap.config && WidgetMap.config.grid && WidgetMap.config.grid.fast_buttons && WidgetMap.config.grid.fast_buttons.length > 0 ){
        var faDiv = '<div class="map-fast-task-access_grid ol-unselectable ol-control">' +
           '</div>';
        if(panelId)
            $('#'+panelId).append(faDiv);
        var singleTab = (WidgetMap.config.grid.singleTab) ? WidgetMap.config.grid.singleTab : false;
        WidgetMap.config.grid.fast_buttons.forEach(function(gConfig, i){
            var title = (gConfig.title) ? gConfig.title : '';
            //создаем кнопку ниже версии
            var gLink = '<a class="map-fast-task-access-link_grid" id="faGrid_'+i+'" title="' + title + '" >' + title + '</a>' ;
            $('.map-fast-task-access_grid').append(gLink);
            $('#faGrid_'+i).click(function(event){
                event.preventDefault();
                try{
                    var template = (gConfig.layer) ? gConfig.layer.split('#')[1] : '';
                    ExternalInteraction.openGrid({
                        data: {
                            //ILI_INSP_FILTER:dataObj[0].ID,
                            //ILI_LBL:dataObj[0].ILI_LBL//проброс в запрос на получение заголовка грида
                        },
                        gridId: template + "_LIST",
                        label: title,
                        fullLayerId: gConfig.layer,
                        reload: true,
                        singleTab: singleTab,
                    });
                }
                catch(ex){
                    App.errorReport(gis_app_55_31, ex.message, undefined, {filename:gis_filename_584, functionname:'gis_filename_584_9'});
                }
            })
        });
        //корректировка положения кнопок, чтобы были по центру окна браузера
        var margin = '-'+((WidgetMap.config.grid.fast_buttons.length - 1)*100)+'px';
        $('.map-fast-task-access_grid').css('margin-left', margin);
    }
}
function CloseEvent(eventType) {
    // Apply the super constructor to get properly wire
    // core event properties.
    jQuery.Event.call(this, eventType);
    // Store the custom attributes. We can store any custom
    // attribute we want so long as we don't override core
    // jQuery Event properties.
    this._eventType = eventType;

    this.detail = 0; //По-умолчанию событие закрытия с отменой
    this.eventData = null; //По-умолчанию дополнительных данных нет
    this.parent = null; //По-умолчанию дополнительных данных нет

    //Функция отправки самого события
    this.dispatch = function dispatch() {
        $("body").trigger(this);
    };
};

// Extend the core jQuery event object.
CloseEvent.prototype = new $.Event("");

CloseEvent.CLOSE = "CloseEvent.close";
function GridEvent(eventType) {
    // Apply the super constructor to get properly wire
    // core event properties.
    jQuery.Event.call(this, eventType);
    // Store the custom attributes. We can store any custom
    // attribute we want so long as we don't override core
    // jQuery Event properties.
    this._eventType = eventType;

    this.detail = 0; //По-умолчанию событие закрытия с отменой
    this.eventData = null; //По-умолчанию дополнительных данных нет
    this.gridId = null; //По-умолчанию нет id конкретного грида
    this.force = false;
    this.refreshGridCallback = undefined;

    //Функция отправки самого события
    this.dispatch = function dispatch() {
        $("body").trigger(this);
    };
};

// Extend the core jQuery event object.
GridEvent.prototype = new $.Event("");

GridEvent.REFRESH_GRID = "GridEvent.refreshGrid";
GridEvent.FILTER_GRID = "GridEvent.filterGrid";
function OperationEvent(eventType) {
    // Apply the super constructor to get properly wire
    // core event properties.
    $.Event.call(this, eventType);
    // Store the custom attributes. We can store any custom
    // attribute we want so long as we don't override core
    // jQuery Event properties.
    this._eventType = eventType;

    //переменные события
    this.objectId = "";
    this.classId = "";
    //Часть данных для операции - DATA_PART_ALL (все), DATA_PART_SEM (семантика), DATA_PART_GEO (геометрия)
    this.dataPart = OperationEvent.DATA_PART_ALL;
    //объект с данными, с которым выполнялись операции
    this.rowData = undefined;
    //Признак, успешно ли было удаление (по-умолчанию - успешно)
    this.operationSuccess = true;
    //Дополнительные данные (это может быть результат или сообщение об ошибке)
    this.operationData = null;
    //Переменные нужны если команду вызываем для выбора и центровки на объекте
    this.withSelecting = true;
    this.withCentering = false;
    this.withEditing = false;
    this.editingMode = 0;

    //Переменная нужна для определения заполнять и показывать панель свойств если она закрыта или нет
    //Переменная введена специально для центровки из грида
    this.showFormIfClosed = true;

    //Функция отправки самого события
    this.dispatch = function dispatch() {
        $("body").trigger(this);
    };
};

// Extend the core jQuery event object.
OperationEvent.prototype = new $.Event("");

OperationEvent.SELECT_OBJECT_BY_ID = "OperationEvent.selectObjectById";

OperationEvent.INSERT_OBJECT_BY_ID = "OperationEvent.insertObjectById";
OperationEvent.UPDATE_OBJECT_BY_ID = "OperationEvent.updateObjectById";
OperationEvent.DELETE_OBJECT_BY_ID = "OperationEvent.deleteObjectById";
OperationEvent.SAVE_ALL_CHANGES_IN_OBJECTS = "OperationEvent.saveAllChangesInObjects";
OperationEvent.DONT_SAVE_CHANGES_IN_OBJECTS = "OperationEvent.dontSaveChangesInObjects";

//Константы событий завершения операций
OperationEvent.OBJECT_SELECTED_BY_ID = "OperationEvent.objectSelectedById";
OperationEvent.OBJECT_INSERTED_BY_ID = "OperationEvent.objectInsertedById";
OperationEvent.OBJECT_UPDATED_BY_ID = "OperationEvent.objectUpdatedById";
OperationEvent.OBJECT_DELETED_BY_ID = "OperationEvent.objectDeletedById";
OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID = "OperationEvent.objectDeletedByIdFromGrid";
OperationEvent.OBJECT_INSERTED = "OperationEvent.objectInserted";

//Константы, показывающие к какой части данных относится событие
OperationEvent.DATA_PART_SEM = "OperationEvent.semantic";
OperationEvent.DATA_PART_GEO = "OperationEvent.geometry";
OperationEvent.DATA_PART_ALL = "OperationEvent.all";

//Константы событий реверса отчета ВТД
OperationEvent.OBJECT_REVERSED_RESULT_BY_ID = "OperationEvent.objectReversedResultById";
OperationEvent.OBJECT_REVERSED_FAULT_BY_ID = "OperationEvent.objectReversedFaultById";
OperationEvent.OBJECT_REVERSED_BY_ID = "OperationEvent.objectReversedById";
function VideoPlayerEvent(eventType) {
    // Apply the super constructor to get properly wire
    // core event properties.
    jQuery.Event.call(this, eventType);
    // Store the custom attributes. We can store any custom
    // attribute we want so long as we don't override core
    // jQuery Event properties.
    this._eventType = eventType;

    this.detail = 0; //По-умолчанию событие закрытия с отменой
    this.eventData = null; //По-умолчанию дополнительных данных нет

    //Функция отправки самого события
    this.dispatch = function dispatch() {
        $("body").trigger(this);
    };
};

// Extend the core jQuery event object.
VideoPlayerEvent.prototype = new $.Event("");

VideoPlayerEvent.CLOSE = "VideoPlayerEvent.close";
VideoPlayerEvent.PAUSE = "VideoPlayerEvent.pause";
VideoPlayerEvent.PLAY = "VideoPlayerEvent.play";
(function( $ ){
    var methods = {
        init : function( options ) {
            return this.each(function (){
                var handlers = {};
                if(options.handlers !== undefined)$.extend(handlers,options.handlers);
                var scenarioVars = {};
                if(options.scenarioVars !== undefined)$.extend(scenarioVars,options.scenarioVars);
                var el = $(this);
                el.data('handlers', handlers);
                el.data('scenarioVars',scenarioVars);
                el.data('needApply', false);
                el.data('infinite', !!options.infinite);//флаг, является ли фильтр с большим количеством данных, чтобы далее использовать заполнение через спец кнопку
                el.data('opener', options.opener);
                el.data('requestId', options.requestId);
                el.data('fromTree', options.fromTree === true);
	            el.data('loading',true);
                el.data('hideButtons', options.hideButtons);
                //объект со значениями, которые необходимо выбрать в списках
                var selectedItems = {};
                if(options.selectedItems !== undefined)$.extend(selectedItems,options.selectedItems);
                el.data('selectedItems',selectedItems);
                //доп. параметры, которые передаются в запрос в <data>
                if(options.addParams !== undefined)
                    el.data('addParams',options.addParams);
		        el.data('showLoader',options.showLoader === true);

                if(options.addText !== undefined)el.data('addtext','<div class="divTextFilter">'+options.addText+'</div>');
                else el.data('addtext','');
                if(options.dataSource !== undefined){
                    var getUserTasksParams = {
                        descrId: 'SYS_SEM.xml#GET_XML_FILE',
                        descrType: 'select',
                        data:'<root ><data FILE="../../Public/Modules/Form/'+options.dataSource+'.mxml"/></root>'
                    };
                    methods.serverQueryXmlFileNode(Services.processQueryNodeXml, getUserTasksParams,
                        methods.parseTopFilter,{el:el,divFilters:el});
                }
                if(options.dataXML !== undefined) {
                    var xmlData = $.parseXML(options.dataXML);
                    $(xmlData).children().each(function(){methods.parseTopFilter($(this),{el:el,divFilters:el});});
                }
            });
        },
        serverQueryXmlFileNode:function(url,params,callbackResult,thisObject) {
            if(thisObject.divFilters === undefined)
                methods.callbackError({text:gis_filters_1});
            App.serverQueryXmlFileNodeWithTries(url, params, function(data){
                var er = HTTPServiceUtil.getError(data);
                if (er !== ''){
                    if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
                        methods.callbackError({
                            text: gis_core_error_1 + '. ' + params.data + '.filter_serverQueryXmlFileNode success error. ' + data + '. ',
                            divFilters: thisObject.divFilters
                        });
                    return;
                }
                try{
                        var xmlData = $.parseXML(data);
                        $(xmlData).children().each(function(){callbackResult($(this),thisObject);});
                    }catch(ex){
                        methods.callbackError({text:gis_core_error_1 + '. ' + params.data + '. filter_serverQueryXmlFileNode. success. '+ex.message,divFilters:thisObject.divFilters});}
                }, function(data){
                        methods.callbackError({
                            text: gis_core_error_1 + '. ' + params.data + '.filter_serverQueryXmlFileNode. ' + data + '. ',
                            divFilters: thisObject.divFilters
                        });
                    },undefined);
                },
        serverQueryXML1:function(url,params,callbackResult,thisObject) {
             url = App.formatNodeServiceUrl(url);
            if(thisObject.divFilters === undefined)
                methods.callbackError({text:gis_filters_1});
            BlockingUtil.wait();
            App.serverQueryXmlFileNodeWithTries(url, params, function(data){
                BlockingUtil.ready();
                var er = HTTPServiceUtil.getError(data);
                if (er !== ''){
                    if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
                        methods.callbackError({
                            text: gis_core_error_1 + '. ' + params.data + '.filter_serverQueryXML1 success error. ' + data + '. ',
                            divFilters: thisObject.divFilters
                        });
                    return;
                }
                try{
                    //var layerGeoXml = ($.parseXML(data)).firstChild;
                    //var datas = layerGeoXml.getElementsByTagName("root");
                    var datas = $($.parseXML(data)).find("root");
                    callbackResult($(datas),thisObject);
                }
                catch(ex){
                    if(ex.message.indexOf('Invalid jQuery Selector') === -1){//если не ошибка поиска селектора(закрыли панель раньше прихода данных)
                        if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
                            methods.callbackError({text:gis_core_error_1+ '. request:' + params.data + '.filter_serverQueryXML1. success. catch:' + ex.message+'; response:'+data, divFilters:thisObject.divFilters});
                    }
                }
            }, function(data){
                BlockingUtil.ready();
                if(params.descrId !== 'none')//случай, если не фейковый запрос фильтра fake_filter. Используется в гридах, где нет справочных колонок
                    methods.callbackError({
                        text: gis_core_error_1 + '. ' + params.data + '.filter_serverQueryXML1. fail' + data + '. ',
                        divFilters: thisObject.divFilters
                    });
            }, undefined);
        },
        callbackError: function(params){
            var el = params.divFilters.data('handlers');
            var loading = params.divFilters.data('loading');
            if(loading !== undefined)
	            params.divFilters.data('loading', false);
	        if(params.parentParams !== undefined && params.parentParams.showLoader === true)
		        BlockingUtil.ready();
            if(el && el.errorHandler !== undefined)
                el.errorHandler(params);
            else{
                App.errorReport(gis_core_error_1, params.text, undefined, {filename:gis_filename_569, functionname:'gis_filename_569_1'});
            }
            /*else
                alert(params.text);*/
        },
        parseTopFilter: function(xmlElement,divObject){
            switch(xmlElement[0].tagName){
                case 'mx:VBox':xmlElement.children().each(function(){methods.parseTopFilter($(this),divObject.el);});break;
                case 'components:FilterPopUpButton':
                    var addTitle = '(0)',
                        checkDefault = false,
                        isDropDown = true,
                        maxCnt = '-1',
                        minCnt = 1,
                        dataProvider = '',
                        idElement = 'w'+methods.getUniqueId()+'_'+xmlElement.attr('id'),
                        addText = divObject.data('addtext');
                    if(xmlElement.attr('maxCnt') !== undefined)maxCnt=xmlElement.attr('maxCnt');
                    if(xmlElement.attr('minCnt') !== undefined)minCnt=xmlElement.attr('minCnt');
                    if(xmlElement.attr('isDropDown') !== undefined)isDropDown = xmlElement.attr('isDropDown') == 'true';
                    if(xmlElement.attr('dataProvider') !== undefined)dataProvider = xmlElement.attr('dataProvider');
                    if((xmlElement.attr('selectAllElements') === undefined)||(xmlElement.attr('selectAllElements') == 'true')){
                        addTitle = gis_filters_3;
                        checkDefault = true;
                    }
                    else{
                        if(maxCnt != '-1')addTitle = gis_filters_4+maxCnt+')';
                    }
                    if((divObject.data('fromTree') || divObject.data('infinite')) && dataProvider){
                        FilterSourceDataManager[dataProvider] = {
                            selectAllElements: checkDefault
                        };
                    }
                    if((addText == '')&&(maxCnt != '-1')){
                        if(isDropDown == false)
                            addText = '<div class="divTextMiddleFilter" style="display:inline;position:absolute">Убедитесь, что количество выбранных элементов не превышает '+maxCnt+'</div>';
                        else
                            addText = '<div class="divTextFilter" style="display:inline;">Убедитесь, что количество выбранных элементов не превышает '+maxCnt+'</div>';
                    }
	                var datapreopen = '';
                    if(divObject.data('handlers')!==undefined && divObject.data('handlers').checkHeadRadioHandler !==undefined){
                        var vars = {};
                        vars.maxCnt = maxCnt;
                        vars.dataProvider = dataProvider;
                        vars.title = xmlElement.attr('title');
                        vars.variableName = xmlElement.attr('id');
                        if(divObject.data('scenarioVars') !== undefined)$.extend(vars,divObject.data('scenarioVars'));
                        var result = {vars:vars};
                        //костыль. чтобы не вызывался сценарий повторно при след парсинге
                        if(divObject.data('isHeadRadio') != true)
                            divObject.data('handlers').checkHeadRadioHandler(result);
                        divObject.data('isHeadRadio',true);
	                    datapreopen = 'data-preopen="'+divObject.data('preopen')+'"';
                    }
                    var filterDiv = '';
                    var isInfinite = divObject.data('infinite');
                    var fromTreeClass = (divObject.data('fromTree'))?'treeFilter':'';
                    var hideButtons = divObject.data('hideButtons');
                    var hideCancel = 'inline-block', hideApply = 'inline-block';
                    if (hideButtons) {
                        if (hideButtons.indexOf('cancel') !== -1)
                            hideCancel = 'none';
                        else if (hideButtons.indexOf('apply') !== -1)
                            hideApply = 'none';
                    }
                    var lightWeightButton = '';

                    if(!isDropDown) {
                        filterDiv = $('<div id="'+idElement+'" class="divFilter '+xmlElement.attr('id')+'" '+datapreopen+' data-filterid="'+ xmlElement.attr('id')+'" data-title="'+ xmlElement.attr('title')+'" data-dataprovider="'+dataProvider+'" data-getdata=true data-maxcnt='+maxCnt+' data-mincnt='+minCnt+' data-isdropdown='+isDropDown+'>\
                           <div>'+xmlElement.attr('title')+addTitle+'</div>\
                           <div>\
                            <div class="divFilterContent">\
                             <input type="text" id="'+idElement+'_input" data-lastvalue="" class="iFilterSearch"/>\
                             <div id="'+idElement+'_listCheckBoxes" data-checkdefault='+checkDefault+' class="divListCheckBoxes"></div>\
                             <div style="height: 35px;">\
                              <div class="divCheckAllMiddle">\
                               <div id="'+idElement+'_checkAll" class="myCheckBox" data-recalc=1 style="display:inline;"> </div>\
                              </div>\
                              <div class="myCheckBoxMiddle" style="display:inline">Выбрать все</div>\
                              <input type="button" value="Применить" id="'+idElement+'_apply" class="myButton filterButton" style="display: '+hideApply+';"/>\
                              <input type="button" value="Отмена" id="'+idElement+'_cancel" class="myButton filterButton" style="display: '+hideCancel+';"/>'+addText+'\
                             </div>\
                            </div>\
                           </div>\
                          </div>');
                    }
                    else {
                        filterDiv = $('<div id="'+idElement+'" class="divFilter '+xmlElement.attr('id')+'" '+datapreopen+' data-filterid="'+ xmlElement.attr('id')+'" data-title="'+ xmlElement.attr('title')+'" data-dataprovider="'+dataProvider+'" data-getdata=true data-maxcnt='+maxCnt+' data-mincnt='+minCnt+' data-isdropdown='+isDropDown+'>\
                           <div>'+xmlElement.attr('title')+addTitle+'</div>\
                           <div>\
                            <div class="divFilterContent '+fromTreeClass+'">\
                             <input type="text" id="'+idElement+'_input" data-lastvalue="" class="iFilterSearch"/>\
                             <div id="'+idElement+'_listCheckBoxes" data-checkdefault='+checkDefault+' class="divListCheckBoxes"></div>\
                             <div>\
                              <div class="divCheckAll">\
                               <div id="'+idElement+'_checkAll" class="myCheckBox" data-recalc=1>Выбрать все</div>\
                              </div>\
                              <input type="button" value="Применить" id="'+idElement+'_apply" class="myButton filterButton"/>\
                              <input type="button" value="Отмена" id="'+idElement+'_cancel" class="myButton filterButton"/>\
                             </div>'+addText+'\
                            </div>\
                           </div>\
                          </div>');
                    }
                    divObject.append(filterDiv);
                    if(isInfinite){
                        lightWeightButton = '<div style="padding-bottom: 3px;">' +
                                '<div  id="'+idElement+'_lightweightcombo" class="divFilter__fake jqx-widget-header">' +
                                xmlElement.attr('title') + addTitle +
                                '</div>' +
                                '<div id="'+idElement+'_lightweight" class="divFilter__fake-button" ></div>' +
                            '</div>';
                        divObject.append(lightWeightButton);
                    }
                    $('#'+idElement+'_apply').jqxButton({disabled:true}).on('click',function(){
                        var successApply = true;
                        if(filterDiv.data('isdropdown')){
                            //устанавливаем флаг, что именно после этой кнопки надо применять фильтр
                            filterDiv.parent().data('needApply',true);
                            filterDiv.jqxExpander('collapse');
                        }
                        else{
                            //если средний фильтр, то перед выполнением функции applyHandler сначала применяем его, чтобы корректно getSelectedItems вызывался
                            successApply = methods.applyFilter({idFilter:idElement,filterDiv:filterDiv});
                        }
                        if(successApply !== false){
                            var handlers = filterDiv.parent().data('handlers');
                            if(handlers.applyHandler !== undefined)handlers.applyHandler(filterDiv.parent());
                        }
                    });
                    $('#'+idElement+'_cancel').jqxButton({disabled:false}).on('click',function(){
                        methods.cancelEditFilter({idFilter:idElement,filterDiv:filterDiv});
                        if(filterDiv.data('isdropdown')){
                            filterDiv.parent().data('needApply',true);
                            filterDiv.jqxExpander('collapse');
                        }
                        var handlers = filterDiv.parent().data('handlers');
                        if(handlers.cancelHandler !== undefined)
                            handlers.cancelHandler(filterDiv.parent());
                    });
                    $('#'+idElement+'_checkAll').jqxCheckBox({rtl:true,checked:checkDefault,disabled:true,theme:''})
                        .on('checked',function(event){
                            methods.filterCheckAll({event:event,idElement:idElement,checkBoxAll:$(this)});
                        })
                        .on('unchecked',function(event){
                            methods.filterCheckAll({event:event,idElement:idElement,checkBoxAll:$(this)});
                        });
                    $('#'+idElement+'_input').jqxInput({placeHolder: gis_filters_5,width: '100%',disabled:true,theme:'myCommon'})
                        .keyup(function(event){
                            //16-shift, 17-ctrl, 8-backspace, 46-del
                            if((event.keyCode!=16 && event.keyCode!=17 && event.keyCode!=18))
                                methods.inputSearchCheckBoxes({input:$(this),idFilter:idElement});
                    });
                    var addParams = filterDiv.parent().data('addParams');
                    var showLoader = filterDiv.parent().data('showLoader');
                    methods.loadFilterContent({showLoader:showLoader, filterDiv:filterDiv,xmlElement:xmlElement,addParams:addParams});

                    var expParams = {width: '100%',expanded: !isDropDown,theme:'myCommon'};

                    if(isInfinite){
                        $.extend(expParams,{disabled:true,width:'95%', showArrow:false})
                        $('#'+idElement+'_lightweight').on('click',function() {
                            FilterUtil.showLightWeightFilter({
                                filterId: idElement,
                                requestId: filterDiv.parent().data('requestId'),
                            });
                        });
                        $('#'+idElement+'_lightweightcombo').on('click',function() {
                            FilterUtil.showLightWeightFilter({
                                filterId: idElement,
                                requestId: filterDiv.parent().data('requestId'),
                            });
                        });
                        //filterDiv.css('display','inline-block');
                        filterDiv.css('display','none');
                    }
                    if(!isDropDown)$.extend(expParams,{expandAnimationDuration:0,collapseAnimationDuration:0, showArrow:false});
                    filterDiv.jqxExpander(expParams).on('expanding',function(){
                        //раскрывая один фильтр, прячем остальные
                        $('.divFilter').each(
                            function(){
                                var el = $(this);
                                if(el.jqxExpander('expanded'))
                                    el.jqxExpander('collapse');
                            });
                        //Вызываем callback при сворачивании/разворачивании списка
                        var handlers = filterDiv.parent().data('handlers');
                        if(handlers.dropDownOpenCallback != undefined)
                            handlers.dropDownOpenCallback({filterDiv:filterDiv, expanded:true});

                    }).on('collapsed',function(){
                        if(!filterDiv.data('isdropdown'))filterDiv.jqxExpander('expand');
                        else {
                            if(filterDiv.parent().data('needApply') == true)
                                methods.applyFilter({idFilter:idElement,filterDiv:filterDiv});
                            else
                                methods.cancelEditFilter({idFilter:idElement,filterDiv:filterDiv});
                            filterDiv.parent().data('needApply',false);
                            //Вызываем callback при сворачивании/разворачивании списка
                            var handlers = filterDiv.parent().data('handlers');
                            if(handlers.dropDownOpenCallback != undefined)
                                handlers.dropDownOpenCallback({filterDiv:filterDiv, expanded:false});
                        }
                    });
                    //if(!isDropDown)$('#'+idElement+' .jqx-expander-header').addClass('noVisible');
                    break;
            }
        },
        filterCheckAll:function(params){
            if(params.checkBoxAll.data('skip') == true){
                params.checkBoxAll.data('skip',false);
                return;
            }

            //TODO пописать удаление из checked в эдит боксе
            var list = $('#'+params.idElement+'_listCheckBoxes');
            $('#'+params.idElement+'_input').data('lastchecked',list.data('lastchecked').slice());
            if(params.checkBoxAll.data('recalc') == 1){
                var funcName = 'clearSelection';
                var allitems = list.data('currentCodes');//забираем текущие коды
                var lastchecked =  $('#'+params.idElement+'_input').data('lastchecked');
                if(params.event.type =='checked'){
                    lastchecked = allitems;
                    funcName = 'checkAll';
                }
                else{
                    lastchecked = [];
                    funcName = 'uncheckAll';
                }
                $('#'+params.idElement+'_input').data('lastchecked',lastchecked);
                //сначала отписываемся, чтобы установить все, а затем опять подписываемся на события
                if(list.length != 0){
                    list.data('isSingle',false);
                    list.data('recalc',0).data('applyfilter',false).jqxListBox(funcName);
                    list.data('isSingle',true);
                }
                methods.recalcFilterView({idFilter:params.idElement,recalcAll:false,fromSelectAll:true});
            }
            else
                params.checkBoxAll.data('recalc',1);

        },
        parseTopFilterContent: function(xmlElement,params){
        	//устанавливаем флаг, что загрузка данных завершгена
	        var filterDiv = params.divObject.parent().data('loading');
	        if(filterDiv !== undefined)
		        params.divObject.parent().data('loading',false);
            var isInfinite = params.divObject.parent().data('infinite');
            if(isInfinite){
                var handlers = params.divObject.parent().data('handlers');
                var requestId = params.divObject.parent().data('requestId');
                if(handlers.infiniteCallback != undefined)
                    handlers.infiniteCallback(xmlElement, requestId);
                return;
            }
            switch(xmlElement[0].tagName){
                case 'root':
                    var childrenLen = xmlElement.children().length;
                    var idFilter = params.divObject.attr('id');
                    var resArr = [];
                    if(childrenLen != 0){//TODO добавить проверку на существование $('#'+idFilter+'_listCheckBoxes'), когдп пришел результат(например, закрыли форму)
                        var divListCheckBoxes = $('#'+idFilter+'_listCheckBoxes'),
                            maxCnt = params.divObject.data('maxcnt'),
                            checked = divListCheckBoxes.data('checkdefault');
                        divListCheckBoxes.addClass('divListCheckBoxes');
                        var resStrArr = [];//массив из строковых кодов
                        var filters = params.divObject.data('slicefilters');

                        if(filters !== undefined && filters !== ''){
                            var ids = filters.split(',');
                            xmlElement.children().each(function(index){
                                //Проверяем есть ли в полученном объекте и CODE и DESCR - и только если есть оба поля, добавляем в список (аналогично флешовому QueryDataProvider)
                                var curCode = $(this).attr('CODE');
                                var curDescr = $(this).attr('DESCR');
                                //#1943 upd. Еслди не пришло descr, то заполняем его ''
	                            if(curDescr === undefined)curDescr = '';
                                if (curCode !== undefined && curDescr !== undefined) {
                                    var j = 0;
                                    for(; j<=ids.length-1; j++){
                                        if(ids[j] === curCode){
                                            resArr.push({CODE:curCode,DESCR:curDescr});
                                            resStrArr.push(curCode);
                                            break;
                                        }
                                    }
                                }
                            });
                        }
                        else{
                            xmlElement.children().each(function(index){
                                //Проверяем есть ли в полученном объекте и CODE и DESCR - и только если есть оба поля, добавляем в список (аналогично флешовому QueryDataProvider)
                                var curCode = $(this).attr('CODE');
                                var curDescr = $(this).attr('DESCR');
	                            //#1943 upd. Еслди не пришло descr, то заполняем его ''
	                            if(curDescr === undefined)curDescr = '';
                                if (curCode !== undefined && curDescr !== undefined) {
                                    resArr.push({CODE:curCode,DESCR:curDescr});
                                    if(maxCnt == -1)
                                        resStrArr.push(curCode);
                                }
                            });
                        }

                        divListCheckBoxes.jqxListBox({ source: resArr,checkboxes: true, itemHeight:21,
                            displayMember: "DESCR", valueMember: "CODE",width:'100%',height:'100%',
                            theme:'filter',
                            renderer: function (index, label, value) {
                                var table = '<div class="spFilterIndex">['+(index+1)+']</div><span class="spDescr">'+label+'</span></div>';
                                return table;
                            }
                        });
                        divListCheckBoxes.data('allCodes',resStrArr.slice()).data('currentCodes',resStrArr.slice());
                        $('#'+idFilter+'_input').data('lastchecked',resStrArr.slice());//сохраняем все текущие коды
                        divListCheckBoxes.data('lastchecked',resStrArr.slice());
                        if(checked){
                            divListCheckBoxes.data('applyfilter',true);
                            divListCheckBoxes.jqxListBox('checkAll');
                        }
                        else{
                            $('#'+idFilter+'_input').data('lastchecked',[]);//сохраняем все текущие коды
                            divListCheckBoxes.data('lastchecked',[]);
                        }
                        divListCheckBoxes.data('items',resArr);
                        divListCheckBoxes.data('checkedItems',divListCheckBoxes.jqxListBox('getCheckedItems'));
                        divListCheckBoxes.data('isSingle',true);
                        divListCheckBoxes.on('checkChange', function (event) {
                            if(divListCheckBoxes.data('isSingle') == true){
                                //$('#'+idFilter+'_input').data('lastchecked',divListCheckBoxes.jqxListBox('getCheckedItems'));
                                if(event.args != undefined && event.args){
                                    var lastchecked = $('#'+idFilter+'_input').data('lastchecked');
                                    if(event.args.checked == true){
                                        var index = lastchecked.indexOf(event.args.value);
                                        if(index==-1)
                                            lastchecked.push(event.args.value);
                                    }
                                    else{
                                        var index = lastchecked.indexOf(event.args.value);
                                        if(index!=-1)
                                            lastchecked.splice(index, 1);
                                    }
                                    $('#'+idFilter+'_input').data('lastchecked',lastchecked);
                                }
                                methods.recalcFilterView({idFilter:idFilter,recalcAll:false});
                                //если выбрали все, выставляем чекбокс
                                if(divListCheckBoxes.jqxListBox('getCheckedItems').length ==  divListCheckBoxes.data('items').length) {
                                    $('#' + idFilter + '_checkAll').data('skip', true);
                                    $('#' + idFilter + '_checkAll').jqxCheckBox('check');
                                }
                                else{
                                    //и снимаем checked
                                    $('#'+idFilter+'_checkAll').data('skip',true);
                                    $('#'+idFilter+'_checkAll').jqxCheckBox('uncheck');
                                }
                                divListCheckBoxes.data('applyfilter',false);
                            }
                        });
                        //var filters = params.divObject.data('slicefilters');
                        //if(filters != undefined)
                        //    methods.setTopFilterSlice({objIds:filters,id: idFilter});
                        filters = params.divObject.data('filters');
                        if(filters !== undefined)
                            methods.setTopFilterValues({objIds:filters,id: idFilter});
                        if((maxCnt != -1)&&(checked == true)&&(maxCnt < childrenLen)){
                            var textTitle = params.divObject.jqxExpander('getHeaderContent').split('(');
                            params.divObject.jqxExpander('setHeaderContent',textTitle[0]+'('+childrenLen+gis_filters_6+maxCnt+')');
                            params.divObject.addClass('divBadFilter');
                        }
                    }

                    //вызов колбек функц
                    var selectedItems = params.divObject.parent().data('selectedItems');
                    //забираем название поля
                    var dataField = idFilter.substr(idFilter.indexOf('_')+1);
                    if(selectedItems != undefined && selectedItems[dataField] != undefined && selectedItems[dataField].lastSelected != undefined){
                        var filterArr = [];
                        for(var i=0; i<selectedItems[dataField].lastSelected.length;i++){
                            filterArr.push(selectedItems[dataField].lastSelected[i].CODE);
                        }
                        var filterStr = filterArr.join(',');
                        methods.setTopFilterValues({objIds:filterStr,id: idFilter});
                    }
                    params.divObject.data('getdata',false);
                    if(resArr.length > 0){
                        $('#'+idFilter+'_apply').jqxButton({disabled:false});
                        $('#'+idFilter+'_checkAll').jqxCheckBox({disabled:false,theme:'myCommon'});
                    }
                    $('#'+idFilter+'_cancel').jqxButton({disabled:false});
                    $('#'+idFilter+'_input').jqxInput({disabled:false,theme:'myCommon'});
                    break;
            }
        },
        parseLpuFilterContent: function(params){
            //устанавливаем флаг, что загрузка данных завершгена
            var filterDiv = params.divObject.parent().data('loading');
            if(filterDiv !== undefined)
                params.divObject.parent().data('loading',false);
            var idFilter = params.divObject.attr('id');
            var divListCheckBoxes = $('#'+idFilter+'_listCheckBoxes'),
                checked = divListCheckBoxes.data('checkdefault');
            divListCheckBoxes.addClass('divListCheckBoxes');
            var resArr = [];
            var resStrArr = [];//массив из строковых кодов

            params.lpuValues.forEach(function(item){
                resArr.push(item);
                resStrArr.push(item.CODE);
            });
            params.divObject.data('codetype',undefined);
            divListCheckBoxes.jqxListBox({ source: resArr,checkboxes: true, itemHeight:21,
                displayMember: "DESCR", valueMember: "CODE",width:'100%',height:'100%',
                theme:'filter',
                renderer: function (index, label, value) {
                    var table = '<div class="spFilterIndex">['+(index+1)+']</div><span class="spDescr">'+label+'</span></div>';
                    return table;
                }
            });
            divListCheckBoxes.data('allCodes',resStrArr.slice()).data('currentCodes',resStrArr.slice());
            $('#'+idFilter+'_input').data('lastchecked',resStrArr.slice());//сохраняем все текущие коды
            divListCheckBoxes.data('lastchecked',resStrArr.slice());
            if(checked){
                divListCheckBoxes.data('applyfilter',true);
                divListCheckBoxes.jqxListBox('checkAll');
            }
            divListCheckBoxes.data('items',resArr);
            divListCheckBoxes.data('checkedItems',divListCheckBoxes.jqxListBox('getCheckedItems'));
            divListCheckBoxes.data('isSingle',true);
            divListCheckBoxes.on('checkChange', function (event) {
                if(divListCheckBoxes.data('isSingle') == true){
                    //$('#'+idFilter+'_input').data('lastchecked',divListCheckBoxes.jqxListBox('getCheckedItems'));
                    if(event.args != undefined && event.args){
                        var lastchecked = $('#'+idFilter+'_input').data('lastchecked');
                        if(event.args.checked == true){
                            var index = lastchecked.indexOf(event.args.value);
                            if(index==-1)
                                lastchecked.push(event.args.value);

                        }
                        else{
                            var index = lastchecked.indexOf(event.args.value);
                            if(index!=-1)
                                lastchecked.splice(index, 1);
                        }
                        $('#'+idFilter+'_input').data('lastchecked',lastchecked);
                    }

                    methods.recalcFilterView({idFilter:idFilter,recalcAll:false});
                    //если выбрали все, выставляем чекбокс
                    if(divListCheckBoxes.jqxListBox('getCheckedItems').length ==  divListCheckBoxes.data('items').length) {
                        $('#' + idFilter + '_checkAll').data('skip', true);
                        $('#' + idFilter + '_checkAll').jqxCheckBox('check');
                    }
                    else{
                        //и снимаем checked
                        $('#'+idFilter+'_checkAll').data('skip',true);
                        $('#'+idFilter+'_checkAll').jqxCheckBox('uncheck');
                    }
                    divListCheckBoxes.data('applyfilter',false);
                }
            });

            //вызов колбек функц
            var selectedItems = params.divObject.parent().data('selectedItems');
            //забираем название поля
            var dataField = idFilter.substr(idFilter.indexOf('_')+1);
            if(selectedItems != undefined && selectedItems[dataField] != undefined && selectedItems[dataField].lastSelected != undefined){
                var filterArr = [];
                for(var i=0; i<selectedItems[dataField].lastSelected.length;i++){
                    filterArr.push(selectedItems[dataField].lastSelected[i].CODE);
                }
                var filterStr = filterArr.join(',');
                methods.setTopFilterValues({objIds:filterStr,id: idFilter});
            }
            params.divObject.data('getdata',false);
            $('#'+idFilter+'_apply').jqxButton({disabled:false});
            $('#'+idFilter+'_cancel').jqxButton({disabled:false});
            $('#'+idFilter+'_checkAll').jqxCheckBox({disabled:false,theme:'myCommon'});
            $('#'+idFilter+'_input').jqxInput({disabled:false,theme:'myCommon'});
        },
        loadFilterContent:function(params){
            //грузим контент фильтра
            var userId = AbstractFormDialog.sendUser ? '' + Auth.getUserId() : '-1';
            var userLogin = AbstractFormDialog.sendUser ? '' + Auth.getUserName() : 'guest';
            var dataStr = '<data/>';
            if(params.addParams!== undefined)
                dataStr = params.addParams;
            //ХАРДКОД. Если фильтр ЛПУ, то забираем его из того, что пришло после PRELOAD.xml
            if(WidgetMap && WidgetMap.preloadLpuValues !== undefined && params.xmlElement.attr('id') === 'LPU_ACCESS_FILTER'){
                methods.parseLpuFilterContent({
                    lpuValues: WidgetMap.preloadLpuValues,
                    divObject: params.filterDiv,
                    divFilters: $('#' + params.filterDiv.attr('id').split('_')[0] + '_tree')
                })
            }
            else{
                //upd.16.04.21 принято решениие для ЭХЗ убрать лоадер. Если будет неудобно - вернуть
                /*if(params.showLoader === true)
                    BlockingUtil.wait();*/
                //TDDO хардкод. Убрать! для задачи су тс тпа нужно подгружать справочники через запрос process-xml
                var serviceName = Services.processQueryNode;
                methods.serverQueryXML1(serviceName,
                    {showLoader:params.showLoader,
                        descrId:params.xmlElement.attr('dataProvider'),
                        descrType:'select',
                        getSchema:true,
                        toElements:false,
                        data:'<root USER_ID="'+userId.xmlEscape()+
                            '" USER_LOGIN="'+userLogin.xmlEscape()+
                            '" PODS_USER="'+userLogin.xmlEscape()+'" >'+
                            dataStr +
                            '</root>'},
                    methods.parseTopFilterContent,{divObject: params.filterDiv,
                        divFilters: $('#'+params.filterDiv.attr('id').split('_')[0]+'_tree')});

            }
        },
        inputSearchCheckBoxes:function(params){
            var value = params.input.val().toLowerCase(),
                oldvalue = params.input.data('lastvalue'),
                listBox = $('#'+params.idFilter+'_listCheckBoxes'),
                lstCheckBoxes = listBox.jqxListBox('getItems'),
                newChecked = listBox.jqxListBox('getCheckedItems');

            var items = listBox.data('items');
            var lstChecked = [];
            if(items.length != newChecked.length){
                lstChecked = newChecked;
            }
            else{
                params.input.data('lastchecked',[]);
            }
            if(oldvalue == value && value == ''){
                return;
            }
            var lastchecked = params.input.data('lastchecked');
            params.input.data('lastvalue',value);
            var newArr = [];

            //listBox.jqxListBox('findItems','АГРС')
            if(value != ''){
                listBox.jqxListBox('clear');
                var currCodes = [];
                for(var i in items){
                    if(items[i].DESCR.toLowerCase().indexOf(value) != -1){
                        newArr.push(items[i]);
                        currCodes.push(items[i].CODE);
                    }
                }

                listBox.jqxListBox({source:newArr});
                listBox.data('currentCodes',currCodes);
                if(lastchecked.length>0){//если были выбраны с прошлого поиска, то их применяем
                    for(var a = 0; a <= newArr.length-1; a++ ){
                        for(var i=0; i <= lastchecked.length-1; i++){
                            if(lastchecked[i] == newArr[a].CODE)
                                listBox.jqxListBox('checkIndex', a );
                        }
                    }
                }
                methods.recalcFilterView({idFilter:params.idFilter,recalcAll:false, fromSearch:true});
            }
            else{
                listBox.jqxListBox({source:items});
                listBox.data('currentCodes',listBox.data('allCodes'));
                if(lstChecked.length>0){
                    for(var a = 0; a <= items.length-1; a++ ){
                        for(var i=0; i <= lastchecked.length-1; i++){
                            if(lastchecked[i] == items[a].CODE)
                                listBox.jqxListBox('checkIndex', a );
                        }
                    }
                }
                else{
                    methods.recalcFilterView({idFilter:params.idFilter,recalcAll:false, fromSearch:true});
                    if(lstChecked.length == 0)
                        methods.cancelEditFilter(params);
                }
            }
            if(listBox.data('currentCodes').length ==  listBox.data('allCodes').length)
                $('#'+params.idFilter+'_checkAll').jqxCheckBox('enable');
            else{
                $('#'+params.idFilter+'_checkAll').jqxCheckBox('disable');
                //и снимаем checked
                $('#'+params.idFilter+'_checkAll').data('skip',true);
                $('#'+params.idFilter+'_checkAll').jqxCheckBox('uncheck');
            }
        },
        cancelEditFilter:function(params){
            var list = $('#'+params.idFilter+'_listCheckBoxes');
            list.data('recalc',0);
            var checkedItems = list.data('lastchecked');
            var items = list.data('items');
            //раздизейбливаем чекбокс "выбрать все"
            $('#'+params.idFilter+'_checkAll').jqxCheckBox('enable');
            list.data('applyfilter',true);
            if(items && items.length < 500)
                list.jqxListBox({source:items});
            list.data('isSingle',false);
            var currentCodes = [];
            var ii=0;
            //если изначально список пустой
            if(items != undefined){
                for(; ii<=items.length-1; ii++){
                    currentCodes.push(items[ii].CODE);
                }
                if(items.length < 500){
                    for(var a = 0; a<=checkedItems.length-1; a++ ){
                        for(var i=0; i<=items.length-1; i++){
                            if(items[i].CODE == checkedItems[a])
                                list.jqxListBox('checkIndex', i );
                        }
                    }
                }

            }
            list.data('currentCodes',currentCodes);
            list.data('isSingle',true);
            $('#'+params.idFilter+'_input').val('');
            methods.recalcFilterView({idFilter:params.idFilter,recalcAll:false,fromCancel:true});
            if((list.data('lastchecked') != undefined && list.data('lastchecked').length ==  list.data('allCodes').length) && list.data('lastchecked').length!=0)
                $('#'+params.idFilter+'_checkAll').data('recalc',0).jqxCheckBox('check');
            else
                $('#'+params.idFilter+'_checkAll').data('recalc',0).jqxCheckBox('uncheck');
        },
        applyFilter:function(params){
            if($('#'+params.idFilter+'_apply').jqxButton('disabled')) return ;
            if($('#'+params.idFilter).hasClass('divBadFilter')){
                methods.cancelEditFilter(params);
                methods.recalcFilterView({idFilter:params.idFilter,recalcAll:true});
                return ;
            }
            var list = $('#'+params.idFilter+'_listCheckBoxes');
            var items = list.data('items');
            //раздизейбливаем чекбокс "выбрать все"
            $('#'+params.idFilter+'_checkAll').jqxCheckBox('enable');
            var checkedItems = $('#'+params.idFilter+'_input').data('lastchecked');//list.data('lastchecked');//list.jqxListBox('getCheckedItems');

            list.data('checkedItems',checkedItems).data('applyfilter',true);
            if(items && items.length < 500)
                list.jqxListBox({source:items});
            list.data('isSingle',false);
            var currentCodes = [];
            var ii=0;
            if(items != undefined){
	            for(; ii<=items.length-1; ii++){
		            currentCodes.push(items[ii].CODE);
	            }
                var lastchecked = [];
                if(items.length < 500) {
                    for (var a = 0; a <= checkedItems.length - 1; a++) {
                        for (var i = 0; i <= items.length - 1; i++) {
                            if (items[i].CODE == checkedItems[a]) {
                                list.jqxListBox('checkIndex', i);
                                lastchecked.push(items[i].CODE);
                            }
                        }
                    }
                }
                else
                    lastchecked = checkedItems;
			}
            if(lastchecked != undefined){
	            $('#'+params.idFilter+'_input').data('lastchecked',lastchecked.slice());
	            list.data('lastchecked',lastchecked.slice());
            }

            //('#'+params.idFilter+'_checkAll').data('recalc',1);
            //возвращаем после применения все элементы, как текущие коды
            list.data('currentCodes',currentCodes);
            $('#'+params.idFilter+'_input').val('');
            list.data('isSingle',true);
            if(checkedItems.length === 0 ) return false;
        },
        recalcFilterView:function(params){
            var divFilter = $('#'+params.idFilter),
                title = divFilter.jqxExpander('getHeaderContent').split('('),
                listBox = $('#'+params.idFilter+'_listCheckBoxes'),
                input = $('#'+params.idFilter+'_input').data('lastchecked'),
                cntChecked = (listBox.jqxListBox('getCheckedItems') != undefined)?listBox.jqxListBox('getCheckedItems').length:0,
                listCheckBoxes = listBox.jqxListBox('getItems'),
                listLastChecked = listBox.data('lastchecked'),
                allCodes = (listBox.data('allCodes') != undefined)?listBox.data('allCodes'):[],
                fromSearch = params.fromSearch,//если пришел запрас на пересчет из поля текстового
                fromCancel = params.fromCancel,
                fromSelectAll = params.fromSelectAll,//от кнопки "отмена"
                maxCnt = divFilter.data('maxcnt'),
                minCnt = divFilter.data('mincnt'),
                addTitle = '';
            if(fromCancel == true && listLastChecked!=undefined)
                cntChecked = listLastChecked.length;
            else if(fromSelectAll == true){
                cntChecked = cntChecked;
            }
            else{
                //если в списке все записи
                if(listBox.data('items') != undefined && listCheckBoxes.length != listBox.data('items').length)
                    cntChecked = input.length;
            }

            //if(fromSearch == true && input != undefined){

            //}
            if(params.addCheck != undefined)cntChecked=cntChecked+params.addCheck;
            if((cntChecked < minCnt)&(params.recalcAll == true)){
                cntChecked = listCheckBoxes.length;
                if(listCheckBoxes.length != 0)listCheckBoxes/*.data('recalc',0)*/.data('applyfilter',true);//.jqxCheckBox('check');
            }
            if(cntChecked == allCodes.length){
                addTitle = gis_filters_3;
                if(maxCnt != 1 && maxCnt != -1)addTitle='('+cntChecked+gis_filters_6+maxCnt+')';
                //$('#'+params.idFilter+'_checkAll').data('recalc',0);//.jqxCheckBox('check');
            }
            else{
                if(maxCnt != 1 && maxCnt != -1)addTitle='('+cntChecked+gis_filters_6+maxCnt+')';
                else addTitle = '('+cntChecked+')';
                //$('#'+params.idFilter+'_checkAll').data('recalc',0);//.jqxCheckBox('uncheck');
            }
            if(((maxCnt != -1)&&((cntChecked>maxCnt)||(cntChecked<minCnt)))){
                divFilter.addClass('divBadFilter');
                addTitle='('+cntChecked+gis_filters_6+maxCnt+')';
                $('#'+params.idFilter+'_apply').jqxButton({disabled: true});
                //if(!divFilter.data('isdropdown'))$('#'+params.idFilter+' .jqx-expander-header').removeClass('noVisible');
            }
            else if(((maxCnt == -1)&&((cntChecked>maxCnt)&&(cntChecked<minCnt)))){  //if(((maxCnt != -1)&(cntChecked>maxCnt))||(cntChecked<minCnt))
                divFilter.addClass('divBadFilter');
                $('#'+params.idFilter+'_apply').jqxButton({disabled: true});
            }
            else{
                //if(!divFilter.data('isdropdown'))$('#'+params.idFilter+' .jqx-expander-header').addClass('noVisible');
                divFilter.removeClass('divBadFilter');
                $('#'+params.idFilter+'_apply').jqxButton({disabled: false});
            }
            divFilter.jqxExpander('setHeaderContent',title[0]+addTitle);
        },
        recalcFilterHeader:function(params){
            var divFilter = $('#'+params.idFilter),
                title = divFilter.jqxExpander('getHeaderContent').split('('),
                maxCnt = divFilter.data('maxcnt'),
                addTitle = '',
                badFilter = false;
            if(params.cntChecked == params.cntAll)addTitle = gis_filters_3;
            else addTitle = '('+params.cntChecked+')';
            if((maxCnt != -1)&(params.cntChecked>maxCnt)){
                badFilter = true;
                divFilter.addClass('divBadFilter');
                addTitle='('+params.cntChecked+gis_filters_6+maxCnt+')';
                params.cntChecked = 0;
            }
            else divFilter.removeClass('divBadFilter');
            divFilter.jqxExpander('setHeaderContent',title[0]+addTitle);
            $('#'+params.idFilter+'_apply').jqxButton({disabled: (params.cntChecked == 0)||badFilter});
        },
        getUniqueId : function(){return 'xxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);return v.toString(16);});},
        callbackFilter:function(params){
            var value = '',
                id = $('#'+this.attr('id')+' .divTab.activeTab').attr('id').split('_')[0];
            $('#'+id+'_filters .divFilter').each(function(){value = value+methods.getFilterValues(this)+'|';});
            if(value != '')value = value.substr(0,value.length-1);
            return {windowId:params.windowId,params:[{name:'filter',value:value}]};
        },
        getFilterDataProviderString:function(){
            var value = '';
            if(this.data('dataprovider')!=undefined && this.data('dataprovider')!='')
                value = this.data('dataprovider');
            return value;
        },
        getFilterValues:function(){
            var value = '';
            $('#'+this.id+' .divFilter').each(function(){value = value+$(this).myFilters('getFilterValuesString')+'|';});
            if(value != '')value = value.substr(0,value.length-1);
            return value;
        },
        getFiltersCount:function(){
            var value = '';
            $('#'+this.id+' .divFilter').each(function(){value = value+$(this).myFilters('getFilterValuesString')+'|';});
            if(value != '')value = value.substr(0,value.length-1);
            return value;
        },
        getFilterValuesString: function(){
            var idFilter = this.attr('id').split('_'),
                value = '';
            idFilter.shift();
            if($('#'+this.attr('id')+'_listCheckBoxes').data('applyfilter') == true){
                var items = $('#'+this.attr('id')+'_listCheckBoxes').jqxListBox('getCheckedItems');
                for(var a in items){
                    value=value+items[a].value+',';
                }
            }
            if(value != '')value = value.substr(0,value.length-1);
            return idFilter.join('_')+':'+value;
        },
        getFilterValuesArray: function(){
            var value = [];
            $('#'+this.attr('id')+' .divFilter').each(function(){
                var idFilter = this.id.split('_'),
                    values = [];
                idFilter.shift();
                var items = $('#'+this.id+'_listCheckBoxes').jqxListBox('getCheckedItems');
                var isCodeStringType = ($(this).data('codetype') !== undefined && $(this).data('codetype') === 'xs:string');
                for(var a in items){
                    values.push({code:(isCodeStringType)?"'"+items[a].value+"'":items[a].value,descr:items[a].label});
                }
                value.push({idFilter:idFilter.join('_'),values:values});
            });
            return value;
        },
        updateTopFilter:function(params){
            if(this.data('getdata') == true)
                this.data('filters',params.obj_ids);
            else
                methods.setTopFilterValues({objIds:params.obj_ids,id: this.attr('id')});
        },
        setTopFilterValues: function(params){
            var ids = params.objIds.split(','),
                list = $('#'+params.id+'_listCheckBoxes'),
                items = list.jqxListBox('getItems');
            list.data('recalc',0);
            if(ids.length>0){
                list.data('isSingle',false);
                list.jqxListBox('uncheckAll');
                list.data('isSingle',true);
                for(var a = 0; a <= items.length-1; a++ ){
                    for(var i=0; i <= ids.length-1; i++){
                        if(ids[i] == items[a].value)
                            list.jqxListBox('checkIndex', a );
                    }
                }
                var checkedItems = list.jqxListBox('getCheckedItems');
                list.data('checkedItems',checkedItems).data('lastchecked',ids);
                $('#'+params.id+'_input').data('lastchecked',ids);
            }
            list.data('applyfilter',true);
            methods.recalcFilterView({idFilter:params.id,recalcAll:false});
        },
        sliceListFilter:function(params){
            if(this.data('getdata') == true)
                this.data('slicefilters',params.obj_ids);
            else
                methods.setTopFilterSlice({objIds:params.obj_ids,id: this.attr('id')});
        },
        setTopFilterSlice: function(params){
            var ids = params.objIds.split(','),
                list = $('#'+params.id+'_listCheckBoxes'),
                items = list.jqxListBox('getItems');
            list.data('recalc',0);
            for(var a = 0; a <= items.length-1; a++ ){
                for(var i=0; i <= ids.length-1; i++){
                    if(ids[i] == items[a].value)
                        list.jqxListBox('checkIndex', i );
                }
            }
            list.data('isSingle',false);
            list.jqxListBox('checkAll');
            list.data('isSingle',true);
            list.data('applyfilter',true);
            methods.recalcFilterView({idFilter:params.id,recalcAll:false});
        }
    };

    $.fn.myFilters = function( method ){
        if(methods[method]) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.fn.myFilters' );
        }
    };
})(jQuery);
//Переменная хранит url для открытия файлов (вида 'http://sitename/')
var pPanelOpenDocPath = window.location.protocol+'//'+window.location.hostname+window.location.pathname.substr(0,window.location.pathname.lastIndexOf('/')+1);

//Глобальный объект, в котором хранятся объекты инициализации предыдущих панелей свойств (для перехода от предыдущего к следующему и перехода по белой стрелочке к связанному объекту)
var pPanelSelectedObjectsHistory = {lastSelectedIndex:-1, historyArray:[]};

(function( $ ){
    var methods = {
        init: function( options ) {
            return this.each(function ()
            {
                if(options.handlers == undefined) $.extend(options,{handlers:{}});
                if(options.tabIndex == undefined) $.extend(options,{tabIndex:0,lastTabIndex:0});
                //Параметром регулируем, скрывать или нет системную информацию (CONFIG.SHOW_SYSTEM_INFO или флаг Show_System_Info, пришедший из задачи)
                if(options.showSystemInfo == undefined)$.extend(options,{showSystemInfo:false});
                //Параметром регулируем, редактировать или нет системную информацию (нужно если мы под администратором)
                if(options.editSystemInfo == undefined)$.extend(options,{editSystemInfo:false});
                //Параметром регулируем, редактировать или нет системную информацию (нужно если мы под администратором)
                if(options.closeAfterSave == undefined)$.extend(options,{closeAfterSave:false});
                if(options.skipValidation == undefined)$.extend(options,{skipValidation:false});
                if(options.position !== undefined)$.extend(options,{position:options.position});
                $.extend(options,{openerType:(options.openerType !== undefined)?options.openerType:getMapType()});
                $.extend(options,{withCtrl:(options.withCtrl !== undefined && options.withCtrl === true)});
                //Сохраняем текущий элемент, генерим локальный id панели свойств, сохраняем опции
                var el = $(this),
                    localId = methods.getUniqueId();
                options.localId = localId;
                el.data('options',options);
                var ppanelWindowContent = '<div class="ui-widget-header ui-corner-all ui-helper-clearfix" style="height:25px; border-top-color: currentColor; border-right-color: currentColor; border-bottom-color: currentColor; border-left-color: currentColor; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-top-style: none; border-right-style: none; border-bottom-style: none; border-left-style: none; white-space: normal; background-image: none; background-color: transparent;">\
	            <div id="divCoordPanel'+ localId +'" class="divCoordPanel"></div>\
                <div class="ui-dialog-titlebar-buttonpane" style="height: 18px; top: 14px; right: 6px; margin-top: -10px; position: absolute;">\
                    <button id="pPanelTitleCloseBtn_'+localId+'" class="ui-button ui-widget ui-state-default ui-corner-all ui-button-icon-only ui-dialog-titlebar-close" role="button" aria-disabled="false" title="Закрыть" style="position: relative; float: right; top: auto; right: auto; margin: 0px;">\
                        <span class="ui-button-icon-primary ui-icon ui-icon-gisCloseButton"></span>\
                        <span class="ui-button-text">Закрыть</span>\
                    </button>\
                    <a id="pPanelTitleMinimizeBtn_'+localId+'" class="ui-corner-all ui-state-default" href="#" title="Свернуть" role="button" style="width:19px; height:18px; padding:0px; display: block;">\
                        <span class="ui-icon ui-icon-gisMinimizeButton">Свернуть</span>\
                    </a>\
                    <a id="pPanelTitleMaximizeBtn_'+localId+'" class="ui-corner-all ui-state-default" href="#" title="Развернуть" role="button" style="width:19px; height:18px; padding:0px; display: block;">\
                        <span class="ui-icon ui-icon-gisMaximizeButton">Свернуть</span>\
                    </a>\
                    <a id="pPanelTitleRestoreBtn_'+localId+'" class="ui-corner-all ui-state-default" href="#" title="Восстановить" role="button" style="width:19px; height:18px; padding:0px; display: none;">\
                        <span class="ui-icon ui-icon-gisRestoreButton">Восстановить</span>\
                    </a>\
                </div>\
              </div>\
              <div class="ui-widget-content ui-dialog-normal" id="pPanelContent_'+localId+'" style="width: auto; min-height: 0px; max-height: none; height: calc(100% - 25px); background-color: #4C93C2; border-color: #005e9a; background-image: none;">\
                <div style="height:100%">\
                  <div id="divContent_'+localId+'" class="divContent" style="height:100%">\
                        <div class="pPanelTitleContent">\
                        <input type="button" value="<<" id="btnPrevObject_'+localId+'" class="myButton btnTopNavigate" style="padding: 2px;" />\
                        <input type="button" value=">>" id="btnNextObject_'+localId+'" class="myButton btnTopNavigate" style="padding: 2px;" />\
                        <span id="spNameObject_'+localId+'"></span>\
                        <span id="spSizeObject_'+localId+'"></span>\
                    </div>\
                   <div id="divLeftPanel_'+localId+'" class="divLeftPanel">\
                   </div>\
                  <div class="divBottomPanel pPanelTableCell">\
                  </div>\
                 </div>\
              </div>';
                /*<a class="ui-dialog-titlebar-restore ui-corner-all ui-state-default" href="#" role="button" style="display: none; right: 1.4em;"><span class="ui-icon ui-icon-gisRestoreButton">restore</span></a>*/
                el.append(ppanelWindowContent);
                //Дефолтные размеры панели свойств
                var panelWidth = 800;
                var panelHeight = 255+25;//+25 - высота блока с координатами
                if(options.coords){
                    if(WidgetMap.DEFAULT_PROJECTION !== GeoUtil.PROJS['EPSG:5807']){
                        var dest_ = new proj4.Proj(GeoUtil.PROJS.WGS84);
                        var source_ = new proj4.Proj(WidgetMap.DEFAULT_PROJECTION);
                        var point = new proj4.toPoint([options.coords[0], options.coords[1]] );
                        proj4.transform(source_, dest_, point);
                        var coord_x = point.x.toPrecision(12);
                        var coord_y = point.y.toPrecision(12);
                        var x_dec = GeoUtil.convertDecimalIntoDegree(coord_x);
                        var y_dec = GeoUtil.convertDecimalIntoDegree(coord_y);
                        //десятичные градусы
                        //var html = gis_mapcenterpointcontrol_3++gis_mapcenterpointcontrol_4+;
                        $('#divCoordPanel'+ localId).text(gis_core_10 + y_dec + '(' + coord_y + '); ' + gis_core_11 + x_dec + '(' + coord_x + ')');
                    }
                }
                if(options.error){
                    $('#btnNextObject_' + localId).addClass('divError').attr('title',gis_mapinfocontrol_1+':'+options.error);
                }

                if (options.hasOwnProperty('panelSize')) {
                    panelWidth = options.panelSize.propPanelWidth;
                    panelHeight = options.panelSize.propPanelHeight;
                } else {
                    $.extend(options,{panelSize: {propPanelWidth:panelWidth, propPanelHeight:panelHeight-5}});
                }
                var prevPanelTopPosition = 200;
                if((panelHeight+5) < 280)//280 дефолтная высота панели свойств
                    prevPanelTopPosition = 30;
                //Отступ слева (350px по дефолту). Высчитываем исходя из размеров родителя
                var panelLeftPosition = options.opener!=undefined>0 && $(options.opener).outerWidth()>panelWidth ? ($(options.opener).outerWidth()-panelWidth)/2 : 50;
                var pPanelMinimizedHeight = 25;

                if(options.position && options.position.length == 2 && !isNaN(options.position[0]) && !isNaN(options.position[1])){
                    panelLeftPosition = options.position[0];
                    prevPanelTopPosition = options.position[1];
                }
                panelWidth = options.opener!=undefined>0 && $(options.opener).outerWidth()<panelWidth ? $(options.opener).outerWidth() -100 : panelWidth;
                el.css({left:panelLeftPosition+'px', top:prevPanelTopPosition+'px', width:panelWidth+'px', height:panelHeight, display:'block', position:'absolute'});
                if (options.zindex!=undefined) {
                    if(options.zindex === 50)
                        el.css({'z-index':150}); /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
                    else
                        el.css({'z-index':options.zindex}); /*Нужно, чтобы панель свойств в гриде не залезала под заголовки столбцов*/
                }
                el.addClass('ui-dialog ui-widget ui-widget-content ui-corner-all ui-front pPanelDialog ui-resizable ui-draggable');
                //Создаем не плавающее окно, а плавающую панель
                el.resizable({minHeight:200, minWidth:600,containment: "parent", alsoResize: '#pPanelContent_'+localId,
                    resize: function( event, ui ) {
                        var tabs = $('#divTabs_'+localId);
                        var divContentHeight = $('#divContent_'+localId).innerHeight();
                        //upd. 05.02.20 по совещанию принято решение просто кнопки не показывать при изменении высоты панели. Если нужно - то расширят панель
                        $('#divLeftPanel_'+localId).css('height',divContentHeight-30);
                        //выставляем высоту для
                        if(tabs.length != 0)tabs.jqxTabs({height: divContentHeight>30 ? divContentHeight-30 : 1}); //-5 отступ, чтобы лучше выглядело при изменении размеров панели свойств
                    }}).draggable({containment: "parent", cancel: '#pPanelContent_'+localId, drag: function(event, ui) {
                        if(options.opener === 'body'){
                            var pos = ui.position;
                            //если панель открыти из карты, то глобально выставляем последнее положение панели
                            if(options.handlers.dragPanelCallback != undefined){
                                options.handlers.dragPanelCallback([pos.left, pos.top]);
                            }
                        }
                    }});
                var overlayDiv = undefined;
                if (options.zindex!=undefined && options.modal!=undefined && options.modal==true) {
                    /* Добавляем к родителю оверлей, закрывающий все под нашей панелью */
                    overlayDiv = $('<div class="applicationBlockOverlay" style="z-index:'+(options.zindex-1).toString()+'"></div>');
                    options.overlayDiv = overlayDiv;
                    el.after(overlayDiv);
                }
                //Создаем действия для кнопки "закрыть"
                $('#pPanelTitleCloseBtn_'+localId).jqxButton().on('click',function(evt) {
                    if (evt) evt.stopImmediatePropagation();
                    if(options.handlers.closeCallback != undefined)
                        options.handlers.closeCallback();
                    //пробуем удалять модальность
                    if(overlayDiv!=undefined)
                        $('.applicationBlockOverlay').remove();
                    methods.destroyPanel(pPanelParams); //el.remove();
                });
                //Создаем действия для кнопки "свернуть"
                $('#pPanelTitleMinimizeBtn_'+localId).jqxButton().on('click',function(evt) {
                    if (evt) evt.stopImmediatePropagation();
                    $('#pPanelTitleMinimizeBtn_'+localId).css('display','none');
                    $('#pPanelContent_'+localId).css('display','none');
                    el.css({height:pPanelMinimizedHeight+'px'});
                    prevPanelTopPosition = parseFloat(el.css('top').replace('px',''));
                    el.css({top:($(options.opener).outerHeight()-pPanelMinimizedHeight)+'px'});
                    $('#pPanelTitleRestoreBtn_'+localId).css('display','block');
                });
                //Создаем действия для кнопки "развернуть на весь экран"
                //Vartanian Добавлена кнопка развернуть, в рамках замечания 150 от 09.12.2021
                //TDOD временно убираем функционал - не корректно работает при открытии вкладок в панели свойств
                $('#pPanelTitleMaximizeBtn_'+localId).jqxButton().on('click',function(evt) {
                    if (evt) evt.stopImmediatePropagation();
                    el.css({height:'70%'});
                    $('#divTabs_'+localId, el).css({height: '94%'});
                    $('.jqx-tabs-content.jqx-tabs-content-myCommon', el).css({height: '100%'});
                });
                //Создаем действия для кнопки "восстановить"
                $('#pPanelTitleRestoreBtn_'+localId).jqxButton().on('click',function(evt) {
                    if (evt) evt.stopImmediatePropagation();
                    $('#pPanelTitleRestoreBtn_'+localId).css('display','none');
                    el.css({height:'auto', top:prevPanelTopPosition+'px'});
                    $('#pPanelContent_'+localId).css('display','block');
                    $('#pPanelTitleMinimizeBtn_'+localId).css('display','block');
                });

                //Выбираем текущим первый объект в списке
                $.extend(options,{curObject:0});
                //Создаем кнопки перехода между объектами, а если объект один - прячем их
                $('#btnPrevObject_'+localId).jqxButton({disabled:true, width:30}).on('click',function(){methods.prevObject({checkSave:true,divProperties:el,localId:localId,options:options});});
                $('#btnNextObject_'+localId).jqxButton({disabled:options.objects.length<=1, width:30}).on('click',function(){methods.nextObject({checkSave:true,divProperties:el,localId:localId,options:options});});
                if(options.objects.length==1) {
                    $('#btnPrevObject_'+localId).addClass('noVisible');
                    $('#btnNextObject_'+localId).addClass('noVisible');
                }
                /*el.dialogExtend({
                    "maximizable" : true,
                    "minimizable" : true,
                    "dblclick" : "maximize",
                    "titlebar" : "transparent",
                    "minimizeLocation" : "right",
                    "icons" : {
                        "close" : "ui-icon-gisCloseButton",
                        "maximize" : "ui-icon-gisMaximizeButton",
                        "minimize" : "ui-icon-gisMinimizeButton",
                        "collapse" : "ui-icon-triangle-1-s",
                        "restore" : "ui-icon-gisRestoreButton"
                    },
                });*/
                //Запускаем получение формы для первого объекта
                var pPanelParams = {divProperties:el,localId:localId,options:options};
                if(options.objects.length!=0)methods.showPanelObject(pPanelParams);
                else{
                    methods.createLeftButton({
                        params: {localId: localId},
                        iconUrl: '',
                        tooltip: gis_ppanel_61,
                        clickEvent:'FindRouteEvent',
                        coords: options.coords
                    });

                }
            });
        },
        destroyPanel:function(params) {
            if (params.options!=undefined && params.options.overlayDiv!=undefined) params.options.overlayDiv.remove();
            //Полностью удаляем слушатели и компоненты
            if (params && params.hasOwnProperty('divProperties') && params.hasOwnProperty('localId')) {
                var localId = params.localId;
                $('#pPanelTitleCloseBtn_' + localId).off();
                $('#pPanelTitleMinimizeBtn_' + localId).off();
                $('#pPanelTitleRestoreBtn_' + localId).off();
                $('#btnLeftPDocs_' + localId).off();
                $('#btnLeftPSave_' + localId).off();
                $('#btnLeftPUndo_' + localId).off();
                $('#btnLeftPDelete_' + localId).off();
                $('#btnLeftPExportNAV_' + localId).off();
                $('#btnLeftPShowOnMap_' + localId).off();
                $('#btnLeftPExcel_' + localId).off();
                $('#btnLeftPBack_' + localId).off();
                $('#btnLeftPForward_' + localId).off();
                $('#btnPrevObject_' + localId).off();
                $('#btnNextObject_' + localId).off();

                try {
                    var listForms = $('#divContent_'+localId+' .frmPanelTab');
                    for (var i = 0; i<listForms.length; i++) {
                        var frmId = 'frm_'+localId+'_'+i;
                        $(listForms[i]).jqxValidator('hide');
                        $('#'+frmId+' .formControl').each(function(){
                            var el = $(this);
                            switch(el.data('typecontrol')) {
                                case 'input': el.off(); el.jqxInput().off(); el.jqxInput('destroy');break;
                                case 'numberinput': el.off(); el.jqxNumberInput().off(); el.jqxNumberInput('destroy');break;
                                case 'checkbox': el.off(); el.jqxCheckBox().off(); el.jqxCheckBox('destroy'); break;
                                case 'combobox': el.off(); el.jqxComboBox().off(); el.jqxComboBox('destroy'); break;
                                case 'date': el.off(); break;
                                case 'file': break;
                                case 'inputfile': break;
                            }
                        });
                    }
                    //Также чистим компонент jqxTabs
                    var tabs = $('#divTabs_'+localId);
                    if(tabs.length != 0) {
                        tabs.off();
                        tabs.jqxTabs.off();
                        tabs.jqxTabs('destroy');
                    }
                } catch (err) {
                    //Ничего не делаем
                }
            }
            params.divProperties.remove(); //Удаляет основной элемент и все его дочерние улементы из DOM, а также чистит слушатели на компонентах внутри
            params.divProperties = null; //На всякий случай убираем из объекта ссылку на divProperties
            //Под конец в IE вызываем сборщик мусора
            if (typeof(CollectGarbage) == "function") CollectGarbage();
            //Под конец в Chrome вызываем сборщик мусора
            if (typeof(gc) == "function") gc();
        },
        successCallback:function(data, url, params,callbackResult,thisObject, isMainSelect){
            try {
                //var dataString = $(data).children('string').text();
                if(thisObject && thisObject.syncMap && MapUtil){
                    if(thisObject.options && thisObject.options.objects && thisObject.options.objects.length > 0){
                        var obj = thisObject.options.objects[thisObject.options.curObject];
                        if(obj && obj.id && obj.id.indexOf(':') !== -1){
                            var layerName = obj.id.split(':')[0];
                            var ids = obj.id.split(':')[1];
                            MapUtil.updateLayerData(layerName, [ids], true);
                        }
                    }
                }
                var dataString = data;
                var er = HTTPServiceUtil.getError(dataString);
                var el = thisObject.divProperties.data('options');
                var selectedObjectStr = thisObject.options.objects[thisObject.options.curObject];
                var selectedObject = {layerId: selectedObjectStr.id.split(':')[0], id: selectedObjectStr.id.split(':')[1]};
                if (er != "") {
                    var errTitle = gis_ppanel_24+gis_ppanel_25;
                    if (params.descrType=='insert' || params.descrType=='update') errTitle = gis_ppanel_26+gis_ppanel_25;
                    App.errorReport(errTitle, er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_8'});
                    if (methods && methods.callbackError!=undefined) methods.callbackError({text:er,divProperties:thisObject.divProperties,url:url,params:params});
                    if (params && params.descrType=='insert' && thisObject && thisObject.indexForm==0 && thisObject.saveMethod=='saveTabForm' && thisObject.hasOwnProperty('divProperties')) {
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:false, requestParams:params, requestUrl:url, retObj: selectedObject,});
                        methods.destroyPanel(thisObject);
                    }//закрываем форму
                    else if (thisObject && thisObject.options!=undefined && thisObject.options.closeAfterSave==true) {
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:false, requestParams:params, requestUrl:url, retObj: selectedObject,});
                        methods.destroyPanel(thisObject);
                    }
                    else{
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:false, requestParams:params, requestUrl:url, retObj: selectedObject,});
                    }
                    return;
                }

                if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.successCallback != undefined)
                    el.handlers.successCallback({url:url,params:params,data:data});
                //thisObject.options.handlers.successCallback({url:url,params:params,data:data});
                //!!!! ВАЖНО! Если пришел флаг создания новой записи, значит  установка всем контролам editable и enabled в true
                //пока это будет флаг label=""  из  thisObject.options.object[0].label или нет идентификатора объекта в thisObject.options.object[0].id
                var xmlData = null;
                try{
                    xmlData = $.parseXML(dataString);
                }
                catch(ex){
                    // BlockingUtil.ready();
                    // App.errorReport(gis_ppanel_65, gis_core_error_3+ex.message, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_21'});
                    // return;
                    xmlData = null;
                }
                var isGetSheetId = false;
                //TODO хардкод. Избавиться!
                isGetSheetId = params && (params.descrId === "STO_SEM.xml#PODS_STO_SHEET_REPAIR_LIST" || params.descrId === "STO_SEM.xml#PODS_STO_SHEET_EXCAVATE_LIST" || params.descrId === "STO_SEM.xml#GET_REPAIR_SHEET_ID_BY_ILI_DATA_ID" || params.descrId === "STO_SEM.xml#GET_EXCAVATE_SHEET_ID_BY_ILI_DATA_ID");
                //TODO хак, если нет панели свойств, но node возвращает пустую запись. Функция общая для получения и данных, и описания панели
                if(dataString && dataString.indexOf('<root/></string>') !== -1 && !(params && params.descrType === 'update') && !isGetSheetId){
                    xmlData = null;
                    if (isMainSelect) {
                        App.errorReport(gis_gridwidget_1, gis_ppanel_66, function () {
                            try {
                                var gridPropPanelId = thisObject.divProperties.attr('id');
                                $('#' + gridPropPanelId).remove();
                            } catch (ex) {
                            }
                        }, {filename: gis_filename_568, functionname: 'gis_filename_568_19'});

                        return;
                    }
                }

                /*if (xmlData!=undefined && xmlData!=null) {
                var inputXml = xmlData.firstChild;
                var items = inputXml.getElementsByTagName('data');
                if(items.length === 0)
                    xmlData = null;
            }*/
                //Обрабатываем случай, когда форма не найдена или ошибка при получении
                if (xmlData!=undefined && xmlData!=null) {
                    //!!!!обрабатываем случай для экспорта пикетажа трубопровода
                    var inputXml = xmlData.firstChild;
                    var items = inputXml.getElementsByTagName('data');
                    var isRouteToExport = false;
                    var retObj = {};
                    //если пришли данные, то добавляем их в объект
                    //TODO сделать для всех объектов
                    for (var i = 0; i < items.length; i++) {
                        var curItem = items[i];
                        var attrNameNodeMap = curItem.attributes;
                        for (var j = 0; j < attrNameNodeMap.length; j++) {
                            var node = attrNameNodeMap[j];
                            retObj[node.nodeName.toUpperCase()] = node.nodeValue;
                            if(node.nodeName.toUpperCase() == 'LINE_ID')
                                isRouteToExport = true;
                        }
                    }
                    if (!selectedObject.id)
                        selectedObject.id = retObj.ID;
                    if(isRouteToExport && thisObject &&  thisObject.options && thisObject.options.objects && !thisObject.options.objects[thisObject.options.curObject]['curRowData']){
                        thisObject.options.objects[thisObject.options.curObject]['curRowData'] = retObj;
                    }
                    $(xmlData).children().each(function(){callbackResult($(this),thisObject, isMainSelect);});
                    if (params && params.descrType=='insert' && thisObject && thisObject.indexForm==0 && thisObject.saveMethod=='saveTabForm' && thisObject.hasOwnProperty('divProperties'))
                    {
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:true,result:xmlData,savingData:params.data, requestParams:params, requestUrl:url, retObj: selectedObject,});
                        methods.destroyPanel(thisObject);
                    }//закрываем форму
                    else if (params && params.descrType=='update' && thisObject && thisObject.options!=undefined)
                    {
                        if(thisObject.options!=undefined && thisObject.options.handlers!=undefined && thisObject.options.handlers.semanticCallback != undefined)
                            el.handlers.semanticCallback({success:true,result:xmlData,savingData:params.data, requestParams:params, requestUrl:url, retObj: selectedObject,});
                        if(thisObject.options.closeAfterSave==true){
                            methods.destroyPanel(thisObject);
                        }
                    }
                }
                else {
                    //Снимаем курсор ожидания
                    BlockingUtil.ready();
                    //BlockingUtil.unblockApplication();
                    //иначе в случае, если есть запрос на заполнение вкладки, запросим данные и выведем в виде грида свойство-значение
                    var source = {localdata: [],
                        datatype: "array",
                        datafields: [ {name:'CODE', type:'string'}, {name:'DESCR', type:'string'} ]
                    };
                    var dataGridParams = {width:'99%',
                        height:'99%',
                        pageable: false,
                        columnsresize: true,
                        showemptyrow:false,
                        altrows:true,
                        selectionmode: 'singlerow',
                        columns: [
                            {text:gis_ppanel_39, datafield:"CODE", width:'40%'},
                            {text:gis_ppanel_40, datafield:"DESCR", width:'60%',
                                cellsrenderer: function (row, column, value) {
                                    return "<div style='margin:4px;' title='"+value+"'>" + value + "</div>";
                                }}],
                        theme:'myCommon',
                        sortable:false,
                        columnsmenu: false,
                        editable:false,
                        source:source};
                    //Сохраняем описание грида
                    params.source = source;
                    var idTable = 'divTable_'+methods.getUniqueId();
                    var element = $('<div id="'+idTable+'" class="vBox" data-selectscript="'+params.selectScript+'"></div>');
                    thisObject.tabs.jqxTabs('setContentAt', thisObject.selectedIndex, '<div id="divTabContent_'+thisObject.localId+'_'+thisObject.selectedIndex+'" class="pPanelTabContent"></div>');
                    $.extend(thisObject,{div:methods.getDivContent(thisObject),parentClass:'',rules:[],tableReadOnly:true});
                    methods.appendFormElement({params:thisObject,element:element,xmlElement:thisObject.divProperties});

                    if(params.selectScript === "undefined" || params.selectScript === undefined){
                        params.source.localdata = thisObject.options.objects[thisObject.options.curObject].attrs;
                    }

                    element.jqxGrid(dataGridParams);
                    //Делаем запрос
                    var prm = thisObject.options.objects[thisObject.options.curObject].id.split(':'),
                        db= prm[0].split('_'),
                        db_schema = db[0],
                        db_table_id = db.slice(1).join('_');
                    //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                    if (thisObject.hasOwnProperty('curSchema') && thisObject.hasOwnProperty('curTable')) {
                        db_schema = thisObject.curSchema;
                        db_table_id = thisObject.curTable;
                    }
                    if(params.selectScript != "undefined" && params.selectScript !== undefined)
                        methods.serverQueryStringNode(Services.processQueryNode,
                            {descrId:params.selectScript,
                                descrType:'select',
                                data:'<root><data FILTER="ID='+prm[1]+'" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+'" DB_SCHEMA_ID="'+db_schema+
                                    '" DB_TABLE_ID="'+db_table_id+'" SYS_CLASS_ID="'+prm[0]+'" SYS_OBJ_ID="'+prm[1]+'"/></root>'},
                            function setTableData(data,params){
                                try {
                                    var retArr = [];
                                    var resultXml = data;
                                    if (resultXml) {
                                        var er = HTTPServiceUtil.getError(resultXml);
                                        if (er != "") {
                                            App.errorReport(gis_gridwidget_1, gis_ppanel_14 + er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_9'});
                                            return false;
                                        } else {
                                            //Получаем xml с данными в виде структуры (берем корневой элемент, т.е. root)
                                            var inputXml = ($.parseXML(resultXml)).firstChild;
                                            var items = inputXml.getElementsByTagName('data');
                                            //Теоретически на запрос приходит только 1 строка <data />, но мы в гриде будем выводить ВСЕ, если их несколько
                                            for (var i = 0; i < items.length; i++) {
                                                var curItem = items[i];
                                                var attrNameNodeMap = curItem.attributes;
                                                //добавляем в виде объекта со свойствами CODE (имя атрибута) и DESCR (значение атрибута)
                                                for (var j = 0; j < attrNameNodeMap.length; j++) {
                                                    var node = attrNameNodeMap[j];
                                                    var addItem = {CODE:node.nodeName.toUpperCase(), DESCR:node.nodeValue };
                                                    retArr.push(addItem);
                                                }
                                            }
                                        }
                                    }
                                    //Подставляем данные в грид
                                    params.source.localdata = retArr;
                                    var dataAdapter = new $.jqx.dataAdapter(params.source);
                                    $('#'+params.idTable).jqxGrid({source:dataAdapter});
                                    //Сразу после обновления блокируем кнопки в гридах комментариев и прикрепленных документов
                                    methods.setCommentDocGridBtnDisabled(params, true);
                                } catch (err) {
                                    //Ничего не делаем, возможно панель закрыта
                                }
                            },
                            $.extend({divProperties:thisObject.divProperties, source:params.source, idTable:idTable, localId:thisObject.localId})
                        );
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        } ,
        serverQueryNode:function(url,params,callbackResult,thisObject, isMainSelect, handleEmptyFileError) {
            url = App.formatNodeServiceUrl(url);
            if(thisObject.divProperties == undefined)
                App.confirmDialog(gis_ppanel_38);
            App.serverQueryNodeWithTries2(url,params,function(data){
                    if(data){
                        var er = HTTPServiceUtil.getError(data);
                        //TODO нужен рефакторинг, перенести блок с ошибкой в одно место
                        if (er !== ''){
                            try {
                                methods.callbackError({text:gis_ppanel_41+'. '+data,divProperties:thisObject.divProperties,url:url,params:params});
                                if (params && params.descrType=='insert' && thisObject && thisObject.indexForm==0 && thisObject.saveMethod=='saveTabForm' && thisObject.hasOwnProperty('divProperties'))
                                    methods.destroyPanel(thisObject);//закрываем форму
                                else if (params && params.descrType=='update' && thisObject && thisObject.options!=undefined && thisObject.options.closeAfterSave==true)
                                    methods.destroyPanel(thisObject);
                            } catch (err) {
                                //Ничего не делаем, возможно панель закрыта
                            }
                            return;
                        }
                        methods.successCallback(data, url, params,callbackResult,thisObject, isMainSelect);
                    }
                },
                function(data){
                    try {
                        if (data.indexOf(gis_app_55_4) !== -1){
                            App.errorReport(gis_app_55_3, gis_app_55_30, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_24'});
                        }
                        methods.callbackError({text:gis_ppanel_41+'. '+data,divProperties:thisObject.divProperties,url:url,params:params});
                        if (params && params.descrType=='insert' && thisObject && thisObject.indexForm==0 && thisObject.saveMethod=='saveTabForm' && thisObject.hasOwnProperty('divProperties'))
                            methods.destroyPanel(thisObject);//закрываем форму
                        else if (params && params.descrType=='update' && thisObject && thisObject.options!=undefined && thisObject.options.closeAfterSave==true)
                            methods.destroyPanel(thisObject);
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                },4,handleEmptyFileError);
        },
        serverQueryString:function(url,params,callbackResult,thisObject) {
            if(thisObject.divProperties == undefined)App.confirmDialog(gis_ppanel_38);
            App.serverQueryStringWithTries(url, params, function(data){
                    try {
                        var dataString = $(data).children('string').text();
                        var er = HTTPServiceUtil.getError(dataString);
                        if (er != "") {
                            var errTitle = gis_ppanel_24+gis_ppanel_25;
                            if (params.descrType=='insert' || params.descrType=='update') errTitle = gis_ppanel_26+gis_ppanel_25;
                            App.errorReport(errTitle, er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_10'});
                            methods.callbackError({text:er,divProperties:thisObject.divProperties,url:url,params:params});
                            return;
                        }
                        var el = thisObject.divProperties.data('options');
                        if(el.handlers != undefined && el.handlers.successCallback != undefined) el.handlers.successCallback({url:url,params:params,data:data});
                        callbackResult(dataString,thisObject);
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                },
                function(data){
                    try {
                        methods.callbackError({text:gis_ppanel_41+'. '+data,divProperties:thisObject.divProperties,url:url,params:params});
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                });
        },
        serverQueryStringNode:function(url,params,callbackResult,thisObject) {
            if(thisObject.divProperties == undefined)App.confirmDialog(gis_ppanel_38);
            App.serverQueryStringNodeWithTries(url,params, function(data){
                    try {
                        var dataString = data;
                        var er = HTTPServiceUtil.getError(dataString);
                        if (er != "") {
                            var errTitle = gis_ppanel_24+gis_ppanel_25;
                            if (params.descrType=='insert' || params.descrType=='update') errTitle = gis_ppanel_26+gis_ppanel_25;
                            App.errorReport(errTitle, er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_10'});
                            methods.callbackError({text:er,divProperties:thisObject.divProperties,url:url,params:params});
                            return;
                        }
                        var el = thisObject.divProperties.data('options');
                        if(el.handlers != undefined && el.handlers.successCallback != undefined) el.handlers.successCallback({url:url,params:params,data:data});
                        callbackResult(dataString,thisObject);
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                },
                function(data){
                    try {
                        methods.callbackError({text:gis_ppanel_41+'. '+data,divProperties:thisObject.divProperties,url:url,params:params});
                    } catch (err) {
                        //Ничего не делаем, возможно панель закрыта
                    }
                });
        },
        callbackError: function(params){
            try {
                var el = params.divProperties.data('options');
                if(el.handlers != undefined && el.handlers.errorHandler != undefined)
                    el.handlers.errorHandler(params);
                else
                    App.errorReport(gis_core_error_1 + '. ' + gis_ppanel_25, params.text, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_22'});
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        getUniqueId : function(){return 'xxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);return v.toString(16);});
        },
        openObjectInNewPanel : function(params){
            try {
                /* params = {divProperties:params.divProperties, localId:params.localId, options:{objects:[params.options.objects[params.options.curObject]], curObject:0, handlers:params.options.handlers, opener:params.options.opener}} */
                //Заново создаем панель
                if (params!=undefined && params.hasOwnProperty('divProperties') && params.hasOwnProperty('options')) {
                    //Создаем панель свойств для текущего объекта
                    var gridPropPanelId = params.divProperties.attr('id');
                    $('#' + gridPropPanelId).remove();
                    var gridPropPanelDiv = '<div id="'+gridPropPanelId+'"></div>';
                    $(params.options.opener).append(gridPropPanelDiv);
                    $('#' + gridPropPanelId).myPropertiesPanel(params.options);
                } else {
                    App.errorReport(gis_ppanel_42,gis_ppanel_43, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_11'});
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        checkPrevNextHistoryBtnEnabled : function(params){
            try {
                //Переключение доступности кнопок вперед/назад истории панелей свойств
                var backDisabled = pPanelSelectedObjectsHistory.lastSelectedIndex <= 0;
                $('#btnLeftPBack'+params.localId).jqxButton({disabled:backDisabled});
                var forwardDisabled = pPanelSelectedObjectsHistory.lastSelectedIndex + 1 >= pPanelSelectedObjectsHistory.historyArray.length;
                $('#btnLeftPForward'+params.localId).jqxButton({disabled:forwardDisabled});
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        prevObject:function (params){
            try {
                //if((params.checkSave == true)&&(!methods.checkSave($.extend(params,{callBack:methods.prevObject}))))return;
                //устанавливаем в false флаг withCtrl, если начинаем переключаться между объектами
                params.options.withCtrl = false;
                params.options.curObject--;
                if(params.options.curObject == 0)$(this).jqxButton({disabled:true});
                //upd.03.11.21 обнуляем сохраненные размеры формы, чтобы не было сбоя при переключении между объектами.
                // высота будет подстраиваться под текущий размер формы
                if(params.options.panelSize)
                    params.options.panelSize.propPanelHeight = undefined
                methods.showPanelObject(params);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        nextObject:function (params){
            try {
                //if((params.checkSave == true)&&(!methods.checkSave($.extend(params,{callBack:methods.nextObject}))))return;
                //устанавливаем в false флаг withCtrl, если начинаем переключаться между объектами
                params.options.withCtrl = false;
                params.options.curObject++;
                //upd.03.11.21 обнуляем сохраненные размеры формы, чтобы не было сбоя при переключении между объектами.
                // высота будет подстраиваться под текущий размер формы
                if(params.options.panelSize)
                    params.options.panelSize.propPanelHeight = undefined
                methods.showPanelObject(params);

            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        showPanelObject:function(params){
            $('#divLeftPanel_'+params.localId).empty();
            try {
                $('#btnPrevObject_'+params.localId).jqxButton({disabled:(params.options.curObject==0)});
                $('#btnNextObject_'+params.localId).jqxButton({disabled:(params.options.curObject==(params.options.objects.length-1))});
                if(params.options.objects.length==1) {
                    $('#btnPrevObject_'+params.localId).addClass('noVisible');
                    $('#btnNextObject_'+params.localId).addClass('noVisible');
                }
                //Не пишем 1 из 1, когда создаем новый объект, но пишем, если получили информацию именно из 1 объекта
                var objectInArrText = params.options.creatingNewObject==true ? '' : (params.options.curObject+1)+gis_ppanel_44+params.options.objects.length;
                var objectLabel = params.options.objects[params.options.curObject].label==undefined ? '' : params.options.objects[params.options.curObject].label;
                $('#spNameObject_'+params.localId).text(objectInArrText+' '+objectLabel);
                //Вызываем callback-функцию центровки если она есть
                if(params.options.handlers.changePanelObjectCallback != undefined) {
                    params.options.handlers.changePanelObjectCallback(params.options.objects[params.options.curObject], params.options.withCtrl);
                }
                if(params.options.handlers.calculateObjectSizeCallback != undefined) {
                    //передаем в коллбек селектор поля, куда надо посчитать длину или площадь объекта выбранного
                    params.options.handlers.calculateObjectSizeCallback({selector:'#spSizeObject_'+params.localId , object:params.options.objects[params.options.curObject]});
                }
                //Устанавливаем признак создания нового объекта, чтобы каждый раз не проверять в каком режиме панель свойств (insert/update)
                $.extend(params.options, {creatingNewObject: (params.options.objects.length==1 && params.options.objects[0].id.indexOf(':')==-1)});
                var curSelectedObjectId = params.options.objects[params.options.curObject].id;
                var curSelectedObjectIdSplitArr = curSelectedObjectId.split(':');
                params.curSchema = curSelectedObjectIdSplitArr[0].substring(0, curSelectedObjectIdSplitArr[0].indexOf('_'));
                params.curTable = curSelectedObjectIdSplitArr[0].substring(curSelectedObjectIdSplitArr[0].indexOf('_')+1);
                //Сохраняем текущий объект в стеке выбранных однажды объектов, если он не только что из стека или если не создаем новый
                if (!pPanelSelectedObjectsHistory.hasOwnProperty(curSelectedObjectId)) {
                    if (curSelectedObjectId.indexOf(':') > 0) {
                        var curSelectedObject = {
                            divProperties:params.divProperties,
                            localId:params.localId,
                            options:{objects:[params.options.objects[params.options.curObject]], curObject:0, handlers:params.options.handlers, opener:params.options.opener}
                        };
                        pPanelSelectedObjectsHistory.historyArray.push(curSelectedObject);
                        pPanelSelectedObjectsHistory[curSelectedObjectId] = curSelectedObjectId; //для быстрой проверки наличия такого объекта в истории добавляем ключ
                        //Увеличиваем индекс последнего выбранного элемента
                        pPanelSelectedObjectsHistory.lastSelectedIndex++;
                        methods.checkPrevNextHistoryBtnEnabled(params);
                    }
                } else {
                    //Пересчитываем и блокируем кнопки перехода к предыдущему/следующему объекту из истории
                    methods.checkPrevNextHistoryBtnEnabled(params);
                }
                //получаем имя класса из *Layers.xml <dataProvider> type="propertiesPanel" source="ALL_PROP_LIST.xml#PODS_S..." />
                var className = params.options.objects[params.options.curObject].id.split(':')[0];
                if (WidgetMap!=undefined && WidgetMap.layerManager!=undefined) {
                    var curLayer = WidgetMap.layerManager.getLayerObjByName(className);
                    if(curLayer !== undefined && curLayer.layer !== undefined && curLayer.layer.dataProvider !== undefined &&
                        curLayer.layer.dataProvider.propertiesPanel !== undefined && curLayer.layer.dataProvider.propertiesPanel != ''){
                        var splitted  = curLayer.layer.dataProvider.propertiesPanel.split('#');
                        className = splitted[splitted.length-1];
                    }
                }
                //Запрашиваем форму
                methods.serverQueryNode(Services.processQueryNodeXml,
                    {descrId:'SYS_PROP.xml#PROP_LIST',
                        descrType:'select',
                        data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="'+className+'"/></root>'},methods.parseTabsPanel,$.extend(params,{loadObject:params.options.curObject,callBack:function(){/*App.confirmDialog('Сохранено!');*/}}),undefined,false);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseTabsPanel:function(xmlElement,params){
            try {
                switch(xmlElement[0].tagName)
                {
                    case 'result':
                    case 'root':
                        if(params.loadObject != params.options.curObject)return;
                        if (xmlElement.children().length>0) {
                            xmlElement.children().each(function(){methods.parseTabsPanel($(this),params);});
                        } else {
                            App.errorReport(gis_ppanel_45,gis_ppanel_46, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_12'});
                        }
                        break;
                    case 'data':
                        var tabs = $('#divTabs_'+params.localId);
                        if(tabs.length != 0)tabs.jqxTabs('destroy');
                        $('#divContent_'+params.localId).append('<div id="divTabs_'+params.localId+'" class="divTabs"><ul id="ulTabs_'+params.localId+'"></ul></div>');
                        tabs = $('#divTabs_'+params.localId);
                        tabs.data('activePage',0);
                        $.extend(params,{tabs:tabs});
                        xmlElement.children().each(function(){methods.parseTabsPanel($(this),params);});
                        var addDocsIndex = -1,
                            commentsIndex = -1;
                        $('#ulTabs_'+params.localId).children().each(function(){
                            var el = $(this);
                            if(el.html() ==gis_ppanel_47) {
                                el.attr('data-source','SYS_DOCUMENT_LIST');
                                addDocsIndex = 0;
                            }
                            if(el.html() ==gis_ppanel_48) {
                                el.attr('data-source','SYS_COMMENT_LIST');
                                commentsIndex = 0;
                                //#1260 - Пытаемся получить реальные schema и table из слоя в layerManager
                                if (WidgetMap!=undefined && WidgetMap.layerManager!=undefined) {
                                    var curSelectedObjectId = params.options.objects[params.options.curObject].id;
                                    if (curSelectedObjectId.indexOf(':') > 0) {
                                        var prm = curSelectedObjectId.split(':');
                                        var curLayer = WidgetMap.layerManager.getLayerByName(prm[0]);
                                        if (curLayer && curLayer.dataProvider && curLayer.dataProvider.spatial!=undefined && curLayer.dataProvider.spatial!='') {
                                            //Получаем и обрабатываем xml с запросом геометрии
                                            var splittedArr = curLayer.dataProvider.spatial.split("#");
                                            var sendingData = '<data file="'+splittedArr[0]+'" dataId="'+splittedArr[1]+'"/>';
                                            //Получаем параметры для запроса и исправляем их на нужные нам
                                            var userId = Auth.getUserId();
                                            var userLogin = Auth.getUserName();
                                            var requestParams = { descrType: 'select', descrId: 'SYS_SEM.xml#GET_DATA_XML',
                                                data: '<root USER_ID="'+userId+'" USER_LOGIN="'+userLogin+'" PODS_USER="'+userLogin+'" >' + sendingData + '</root>' };
                                            methods.serverQueryNode(Services.processQueryNodeXml,
                                                requestParams, function onGetSpatialResult(resultXML){
                                                    try {
                                                        if (resultXML) {
                                                            var er = HTTPServiceUtil.getError(resultXML);
                                                            if (er!='') {
                                                                //Ничего не делаем - будем получать все по схеме и таблице, полученной из класса объекта
                                                            } else {
                                                                var schemaStartInd = resultXML.indexOf('schema="') + 8;
                                                                var schemaEndInd = resultXML.indexOf('"',schemaStartInd);
                                                                params.curSchema = resultXML.substring(schemaStartInd, schemaEndInd);
                                                                var tableStartInd = resultXML.indexOf('table="') + 7;
                                                                var tableEndInd = resultXML.indexOf('"',tableStartInd);
                                                                params.curTable = resultXML.substring(tableStartInd, tableEndInd);
                                                            }
                                                        }
                                                    } catch (err) {
                                                        //Ничего не делаем - будем получать все по схеме и таблице, полученной из класса объекта
                                                    }
                                                }, function onGetSpatialFault(resultXML){
                                                    //Ничего не делаем - будем получать все по схеме и таблице, полученной из класса объекта
                                                });
                                        }
                                    }
                                }
                            }
                        });
                        /*if(commentsIndex == -1)
                {
                 $(tabs.children()[0]).append('<li data-source="SYS_COMMENT_LIST">Комментарии</li>');
                 tabs.append('<div></div>');
                }*/
                        /* Прикрепленные документы теперь показываются по нажатию на кнопку, поэтому не добавляем их если вкладки нет в ALL_PROP_LIST */
                        /*if(addDocsIndex == -1 && params.options.creatingNewObject==false) {
                 $(tabs.children()[0]).append('<li data-source="SYS_DOCUMENT_LIST">Прикрепленные документы</li>');
                 tabs.append('<div></div>');
              }*/
                        var activePage = tabs.data('activePage');
                        //var tabsHeight = params.options.panelSize.propPanelHeight - 110;
                        var tabsHeight = $('#divContent_'+params.localId).outerHeight() - 30;
                        /*if(params.options.panelSize.propPanelHeight){
                            tabsHeight = params.options.panelSize.propPanelHeight - 110;
                        }*/
                        tabs.jqxTabs({theme:'myCommon', height:tabsHeight}).on('selected',function(event){
                            //Сразу после выбора другой вкладки блокируем кнопки в гридах комментариев и прикрепленных документов
                            methods.setCommentDocGridBtnDisabled(params, true);
                            if($(event.target).jqxTabs('getContentAt',event.args.item).html() != '')return;
                            var idRequest = $($('#ulTabs_'+params.localId).children()[event.args.item]).data('source');
                            var formDataProvider = $($('#ulTabs_'+params.localId).children()[event.args.item]).data('datarequest');
                            var fileName = '../../Public/Modules/Form/'+idRequest+'.mxml';
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {
                                    descrId: 'SYS_SEM.xml#GET_XML_FILE',
                                    descrType: 'select',
                                    data: '<root ><data FILE="' + fileName + '"/></root>'
                                },
                                methods.parseForm,$.extend(params,{selectedIndex:event.args.item,idRequest:idRequest,saveMethod:'getTabForm'}), undefined, false);
                        }).jqxTabs('select',activePage);
                        tabs.on('selecting',function(event){
                            var frmSelIndex = $(event.target).jqxTabs('selectedItem');
                            var frm = $('#frm_'+params.localId+'_'+frmSelIndex);
                            if(frm.length != 0) {
                                //Ставим фокус на первый компонент во вкладке
                                var formFirstTabIndex = (frmSelIndex + 1)*100 + 1;
                                $('#'+frm.attr('id')+' [tabindex="'+formFirstTabIndex+'"]').focus();
                            }
                            //Убираем выделение в гридах прикрепленных документов и комментариев перед переключением на вкладку
                            $("div[id^='divAddDocsContent_"+params.localId+"']").each(function(){
                                $($(this).children()[0]).jqxGrid('clearselection');
                            });
                            $("div[id^='divCommentContent_"+params.localId+"']").each(function(){
                                $($(this).children()[0]).jqxGrid('clearselection');
                            });
                        });
                        if(activePage == 0) {
                            var idRequest = $($('#ulTabs_'+params.localId).children()[0]).data('source');
                            var formDataProvider = $($('#ulTabs_'+params.localId).children()[0]).data('datarequest');
                            //Устанавливаем курсор ожидания
                            BlockingUtil.wait();
                            var fileName = '../../Public/Modules/Form/'+idRequest+'.mxml';
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {
                                    descrId: 'SYS_SEM.xml#GET_XML_FILE',
                                    descrType: 'select',
                                    data: '<root ><data FILE="' + fileName + '"/></root>',
                                    id:idRequest,
                                    selectScript:formDataProvider
                                },
                                methods.parseForm,$.extend(params,{selectedIndex:0,idRequest:idRequest,saveMethod:'getTabForm'}),undefined, false);
                        }
                        break;
                    case 'panel':
                        //Если  params.options.objects[params.options.curObject].id только указано название слоя, то форма добавления
                        //и необхъодимо пармить только вкладку паспорт
                        var isCreateNewObject = false;
                        if(params.options.objects[params.options.curObject].id.split(':').length == 1)
                            isCreateNewObject = true;
                        var isDefault = false;
                        if((xmlElement.attr('default') != undefined)&&(xmlElement.attr('default') == 'true')){
                            params.tabs.data('activePage',$(params.tabs.children()[0]).children().length);
                            isDefault = true;
                        }
                        //Проверяем вкладки из списка не реализованных, и если они там присутствуют - не добавляем
                        var sourceAttr = xmlElement.attr('source');
                        var requestAttr = xmlElement.attr('dataRequest');
                        if(isCreateNewObject){
                            if(isDefault){
                                $(params.tabs.children()[0]).append('<li data-source="'+sourceAttr+'" data-datarequest="'+requestAttr+'">'+xmlElement.attr('descr')+'</li>');
                                params.tabs.append('<div></div>');
                            }
                        }
                        else{
                            if (sourceAttr!='PODS_EVENT_GROUP_LIST' && sourceAttr!='PODS_OFFLINE_GROUP_LIST' && sourceAttr!='INTEGRATION') {
                                $(params.tabs.children()[0]).append('<li data-source="'+sourceAttr+'" data-datarequest="'+requestAttr+'">'+xmlElement.attr('descr')+'</li>');
                                params.tabs.append('<div></div>');
                            }
                        }
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseForm:function(xmlElement,params){
            try {
                var element,idElement;
                var visible = xmlElement.attr('visible'), addVisibleClass = '';
                //Если из задачи пришел options.showSystemInfo==true, показываем такие поля независимо от значения конфига (мы под админом), иначе - в зависимости от конфига
                if (params.options.showSystemInfo==false) {
                    var confShowFlag = 'SHOW_SYSTEM_INFO'; //Также прячем по значению конфига
                    if (visible!=undefined && visible=='{CONFIG.'+confShowFlag+'}' && App.config && (!App.config.hasOwnProperty(confShowFlag) || App.config[confShowFlag]==false)) visible='false';
                }
                //Если в форме напрямую указано visible="false", полюбому скрываем даже для админов (скрытое поле для отправки в запрос)
                if((visible != undefined)&&(visible == 'false')) addVisibleClass = 'noVisible';
                //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
                var valueFromConfig = null;
                if (xmlElement.attr('text')!=undefined && xmlElement.attr('text').toUpperCase().indexOf('{CONFIG.')==0 && App.config) {
                    var configProp = xmlElement.attr('text').toUpperCase().substring(8,xmlElement.attr('text').length-1);
                    if (App.config.hasOwnProperty(configProp)) {
                        valueFromConfig = App.config[configProp];
                    }
                }
                //Обрабатываем высоту и ширину, если они указаны (в пикселях или процентах)
                var curElementHeight = xmlElement.attr('height')!=undefined && xmlElement.attr('height').indexOf('%')==-1 ? xmlElement.attr('height')+'px' : xmlElement.attr('height');
                var curElementWidth = xmlElement.attr('width')!=undefined && xmlElement.attr('width').indexOf('%')==-1 ? xmlElement.attr('width')+'px' : xmlElement.attr('width');
                //Обрабатываем соответственно названию тега текущего элемента
                var needResize = true;
                if(params.selectedIndex !== 0){
                    needResize = false;
                }
                switch(xmlElement[0].tagName) {
                    case 'DATA_EDIT_FORM':
                        //Снимаем курсор ожидания
                        BlockingUtil.ready();
                        //BlockingUtil.unblockApplication();
                        if(typeof(params.selectedIndex) =='number') {
                            if(params.loadObject != params.options.curObject)return;
                            params.tabs.jqxTabs('setContentAt', params.selectedIndex, '<form id="frm_'+params.localId+'_'+params.selectedIndex+'" class="frmPanelTab" data-waitload="0"><div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTabContent"></div></form>');
                            //После парсинга элементов формы устанавливаем высоту
                            var tabsHeight = $('#divContent_'+params.localId).outerHeight() - 30;
                            if(params.options.panelSize.propPanelHeight)
                                tabsHeight = params.options.panelSize.propPanelHeight - 50;
                            //params.tabs.jqxTabs({height: tabsHeight - 20/*60*/}); /*$('#divContent_'+params.localId).outerHeight()*/
                            if(needResize)
                                params.tabs.jqxTabs({height:tabsHeight}); /**/
                            //var outerWidth = $('#divContent_'+params.localId).outerWidth()
                            //Обрабатываем атрибуты тега DATA_EDIT_FORM
                            var curDivTabContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
                            if (xmlElement.attr('width')!=undefined) methods.setStyleElement({xmlElement:xmlElement[0],element:curDivTabContent});
                            if (xmlElement.attr('title')!=undefined) curDivTabContent.data('title',xmlElement.attr('title'));
                            if (xmlElement.attr('ext_data_id')!=undefined) curDivTabContent.data('ext_data_id',xmlElement.attr('ext_data_id'));
                            if (xmlElement.attr('excelTemplate')!=undefined) curDivTabContent.data('excelTemplate',xmlElement.attr('excelTemplate'));
                            //основной идентификатор, который будет использоваться из объекта вкладки на заполнение. по умолчанию ID
                            (xmlElement.attr('initialId')!=undefined)?curDivTabContent.data('initialId',xmlElement.attr('initialId')):curDivTabContent.data('initialId','ID');
                            //сценарий, содержит связывающее событие с кнопкой
                            (xmlElement.attr('scenario')!=undefined)?curDivTabContent.data('scenario',xmlElement.attr('scenario')):curDivTabContent.data('scenario',undefined);
                        }
                        //Если нет label у панели свойств, берем его из описания формы паспорта. Не пишем 1 из 1, когда создаем новый объект, но пишем, если получили информацию именно из 1 объекта
                        if (params.selectedIndex==0) {
                            var objectInArrText = params.options.creatingNewObject==true ? '' : (params.options.curObject+1)+gis_ppanel_44+params.options.objects.length;
                            var objectLabel = params.options.objects[params.options.curObject].label==undefined ? '' : params.options.objects[params.options.curObject].label;
                            if (objectLabel=='' && xmlElement.attr('title')!=undefined) objectLabel = xmlElement.attr('title');
                            $('#spNameObject_'+params.localId).text(objectInArrText+' '+objectLabel);
                        }
                        if(params.unlockCombo != undefined)
                            params.divProperties.data('unlockCombo',params.unlockCombo);
                        else params.divProperties.data('unlockCombo',0);
                        $.extend(params,{div:methods.getDivContent(params),parentClass:'',rules:[],tableReadOnly:xmlElement.attr('readOnly')=='true'});
                        //Устанавливаем начальный tabIndex для формы как params.selectedIndex*100 (лимит по 100 контролов в каждой вкладке)
                        params.options.tabIndex = (params.selectedIndex + 1)*100;
                        params.options.lastTabIndex = params.options.tabIndex+1; //Запоминаем первый в текущей форме, к нему будем прибавлять новые индексы на каждый контрол
                        //Парсим остальные элементы формы
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        //Ставим валидатор для текущей формы
                        try{
                            $('#frm_'+params.localId+'_'+params.selectedIndex).jqxValidator({
                                rules:params.rules,
                                animation:'none',
                                onError: function (errorArr) {
                                    var fullErrorText = '';
                                    var errObj = {};
                                    for (var j=0; j<errorArr.length; j++) {
                                        var elemId = undefined;
                                        if(errorArr[j][0].attributes['id'])
                                            elemId = errorArr[j][0].attributes['id'].value;
                                        else{
                                            elemId = errorArr[j].selector.split(' ')[0].replace('#','');
                                        }
                                        if (!errObj.hasOwnProperty(elemId)) {
                                            //Изгаляемся, чтобы получить сообщение об ошибке для контрола выбора файла - в нем нет .data('validateErrorText')
                                            var curErrText = $(errorArr[j][0]).data('validateErrorText');
                                            if (curErrText==undefined) {
                                                for (var k=0; k<params.rules.length; k++) {
                                                    if (params.rules[k].input=='#'+elemId) {
                                                        curErrText = params.rules[k].message;
                                                        break;
                                                    }
                                                }
                                            }
                                            if (curErrText!=undefined) {
                                                fullErrorText += curErrText + '<br/>';
                                                errObj[elemId] = elemId;
                                                //$(errorArr[j][0]).addClass('jqx-validator-error-element'); //Добавляем класс валидированного элемента
                                            }
                                        }
                                    }
                                    var alertForm = new AlertForm();
                                    alertForm.build('pPanel_'+params.localId+'_AlertForm', fullErrorText, gis_ppanel_27, AlertForm.OK);
                                }
                            }).data('dataProvider',params.dataProvider);
                        }
                        catch(ex)
                        {
                        }
                        //Если не insert - выполняем запрос на получение данных текущего объекта
                        if(typeof(params.selectedIndex) =='number') {
                            var prm = params.options.objects[params.options.curObject].id.split(':'),
                                db= prm[0].split('_'),
                                db_schema = db[0],
                                db_table_id = db.slice(1).join('_');
                            methods.setAttrsValues(params);
                            if(prm.length > 1 && prm[1] != undefined) {
                                $('#frm_'+params.localId+'_'+params.selectedIndex).data('scriptType','SELECT');
                                var initialId='ID';
                                var idField = prm[0];
                                var idValue = prm[1];
                                var iliDataId = '';
                                var iliTypeField = idField === 'PODS_ILI_CLUSTER'?'ILI_CLUSTER_ID':'ILI_DATA_ID';
                                try{
                                    if(params &&  params.options && params.options.objects){
                                        initialId = params.div.data('initialId');
                                        if( params.options.objects[params.options.curObject]['curRowData']){
                                            if(params.options.objects[params.options.curObject]['curRowData'][initialId])
                                                idValue = params.options.objects[params.options.curObject]['curRowData'][initialId];
                                            iliDataId = params.options.objects[params.options.curObject]['curRowData'][iliTypeField];
                                            if(iliDataId === undefined) iliDataId = '';
                                        }
                                    }
                                }
                                catch(ex){}
                                //доп. проверка, если не нашло LIST_ID, то устанавливаем в NULL
                                if(!idValue) idValue = 'NULL';
                                if(iliDataId === '' )  iliDataId = prm[1];
                                //случай если открываем из кнопки грида у ведомости шурфовок, то извне приходит ili_cluster_id, если работаем с кластером
                                if(params && params.options && params.options.data && params.options.data.ILI_CLUSTER_ID)
                                    iliTypeField = 'ILI_CLUSTER_ID';
                                //iliDataId = params.options.data.ILI_CLUSTER_ID

                                if(initialId === 'LIST_ID'/*&& idValue === 'NULL'*/){
                                    //получаем sheetId, если не нашли, то пустая форма.
                                    //если нашли, то просто за
                                    methods.getSheetId(prm[1],params.idRequest,function(sheetId, stoEventId, type){
                                        if(sheetId === undefined)
                                            sheetId = 'NULL';
                                        methods.serverQueryNode(Services.processQueryNode,
                                            {descrId:params.dataProvider+'#'+$($('#ulTabs_'+params.localId).children()[params.selectedIndex]).data('source'),
                                                descrType:'select',
                                                data: '<root USER_ID="' + Auth.getUserId() + '" USER_LOGIN="' + Auth.getUserName() + '" PODS_USER="' + Auth.getUserName() + '">' +
                                                    '<data FILTER="SHEET_ID=' + sheetId +' AND ' + iliTypeField + '='+iliDataId+
                                                    '" SYS_FULL_ID="' + idField + '/' + idValue +
                                                    '" DB_SCHEMA_ID="' + db_schema +
                                                    '" DB_TABLE_ID="' + db_table_id +
                                                    '" SYS_CLASS_ID="' + idField +
                                                    '" SYS_OBJ_ID="' + idValue + '"/></root>'
                                            }, methods.parseTabValues, params, true);
                                    },params);
                                }
                                else
                                    methods.serverQueryNode(Services.processQueryNode,
                                        {descrId:params.dataProvider+'#'+$($('#ulTabs_'+params.localId).children()[params.selectedIndex]).data('source'),
                                            descrType:'select',
                                            data: '<root USER_ID="' + Auth.getUserId() + '" USER_LOGIN="' + Auth.getUserName() + '" PODS_USER="' + Auth.getUserName() + '">' +
                                                '<data FILTER="ID=' + idValue +
                                                '" SYS_FULL_ID="' + idField + '/' + idValue +
                                                '" DB_SCHEMA_ID="' + db_schema +
                                                '" DB_TABLE_ID="' + db_table_id +
                                                '" SYS_CLASS_ID="' + idField +
                                                '" SYS_OBJ_ID="' + idValue + '"/></root>'
                                        }, methods.parseTabValues, params, true);
                            } else {
                                $('#frm_'+params.localId+'_'+params.selectedIndex).data('scriptType','INSERT');
                                //И только в самом конце, после свойств объекта запрашиваем данные комбобоксов
                                $('#divTabContent_'+params.localId+'_'+params.selectedIndex).find('[data-typecontrol="combobox"]').each(function (){
                                    var element = $(this);
                                    if(element.attr('dataProvider') != undefined) {
                                        var comboDataProvider = new QueryDataProvider({
                                            requestSource: element.attr('dataProvider'),
                                            dataField: element.jqxComboBox('valueMember'),
                                            labelField: element.jqxComboBox('displayMember'),
                                            resultHandler: function(){
                                                methods.setComboBoxDataProvider(this,{comboBox:element,divProperties:params.divProperties,localId:params.localId, options: params.options});
                                            }
                                        });
                                    }
                                });
                                params.divProperties.data('unlockCombo',1);
                                methods.unlockFormControls(params);
                                $('#frm_'+params.localId+'_'+params.selectedIndex+' [tabindex="'+params.options.lastTabIndex+'"]').focus();
                            }
                        } else {
                            //Получаем списки для всплывающих popup создания новых документов (только при вставке нового)
                            if (params.hasOwnProperty('action') && params.action=='insert') {
                                $('#divTabContent_' + params.localId + '_' + params.selectedIndex).find('[data-typecontrol="combobox"]').each(function () {
                                    var element = $(this);
                                    if(element.attr('dataProvider') != undefined) {
                                        var comboDataProvider = new QueryDataProvider({
                                            requestSource: element.attr('dataProvider'),
                                            dataField: element.jqxComboBox('valueMember'),
                                            labelField: element.jqxComboBox('displayMember'),
                                            resultHandler: function(){
                                                methods.setComboBoxDataProvider(this,{comboBox:element,divProperties:params.divProperties,localId:params.localId, options: params.options});
                                            }
                                        });
                                    }
                                });
                            }
                        }
                        methods.checkLeftButtons(params);
                        break;
                    case 'DATA_GRID_FORM':
                        //Снимаем курсор ожидания
                        BlockingUtil.ready();
                        //BlockingUtil.unblockApplication();
                        if(typeof(params.selectedIndex) =='number')
                        {
                            if(params.loadObject != params.options.curObject)return;
                            params.tabs.jqxTabs('setContentAt', params.selectedIndex, '<div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTabContent"></div>');
                        }
                        $.extend(params,{div:methods.getDivContent(params),
                            parentClass:'',
                            rules:[],
                            tableReadOnly:xmlElement.attr('readOnly')=='false'});
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        methods.setAttrsValues(params);
                        methods.checkLeftButtons(params);
                        break;
                    case 'DataGridWithScript':
                        $.extend(params,{dataGrid:{width:'100%',
                                height:'100%',
                                pageable: false,
                                columnsresize: true,
                                showemptyrow:false,
                                altrows:true,
                                selectionmode: 'singlerow',
                                columns: [],
                                theme:'myCommon',
                                sortable:true,
                                columnsmenu: false,
                                editable:params.tableReadOnly},
                            selectScript:'',
                            source:{datatype: 'xml',
                                datafields: [],
                                root: 'root',
                                record: 'data',
                                localdata:''}});
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        var idTable = 'divTable_'+methods.getUniqueId();
                        element = $('<div id="'+idTable+'" class="vBox" data-selectscript="'+params.selectScript+'"></div>');
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        element.jqxGrid(params.dataGrid);
                        var onGridChangeSelect = function onGridChangeSelect(event) {
                            try {
                                var btnDisabled = !event || event.type!='rowselect';
                                methods.setCommentDocGridBtnDisabled(params, btnDisabled);
                            } catch (e) {}
                        };
                        //Привязываемся к событиям смены выделения в гриде, чтобы блокировать/разблокировать кнопки
                        element.on('rowselect', onGridChangeSelect);
                        //Для грида комментариев добавляем слушатель события двойного клика
                        var curElementId = element.parent()!=undefined && element.parent().length>0 ? element.parent().attr('id') : '';
                        if (curElementId=='divCommentContent_'+params.localId+'_'+params.selectedIndex) {
                            element.on('rowdoubleclick', function commentGridDblClick(event) {
                                var divContent = element.parent();
                                $('#btnEditComment_'+curElementId.replace('divCommentContent_','')).jqxButton().click();
                            });
                        }
                        //Для грида прикрепленных документов добавляем слушатель события двойного клика
                        if (curElementId=='divAddDocsContent_'+params.localId+'_'+params.selectedIndex) {
                            element.on('rowdoubleclick', function docGridDblClick(event) {
                                var divContent = element.parent();
                                $('#btnOpenDoc_'+curElementId.replace('divAddDocsContent_','')).jqxButton().click();
                            });
                        }
                        //
                        params.div.data('selectscript',params.selectScript);
                        var prm = params.options.objects[params.options.curObject].id.split(':'),
                            db= prm[0].split('_'),
                            db_schema = db[0],
                            db_table_id = db.slice(1).join('_');
                        //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                        if (params.hasOwnProperty('curSchema') && params.hasOwnProperty('curTable')) {
                            db_schema = params.curSchema;
                            db_table_id = params.curTable;
                        }
                        methods.serverQueryStringNode(Services.processQueryNode,
                            {descrId:params.selectScript,
                                descrType:'select',
                                getSchema:false,
                                toElements:false,
                                data:'<root><data FILTER="ID='+prm[1]+
                                    '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                    '" ID="'+prm[1]+
                                    '" DB_SCHEMA_ID="'+db_schema+
                                    '" DB_TABLE_ID="'+db_table_id+
                                    '" SYS_CLASS_ID="'+prm[0]+
                                    '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.setTableData,
                            $.extend({divProperties:params.divProperties,
                                source:params.source,
                                idTable:idTable,
                                localId:params.localId}));
                        break;
                    case 'columns':
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        var no = params.dataGrid.columns.length - params.source.datafields.length,
                            col = Math.floor((100-5*no)/(xmlElement.children().length-no));
                        $(params.dataGrid.columns).each(function(){
                            if(this.width=='0%')this.width =col+'%';
                        });
                        break;
                    case 'mx:DataGridColumn':
                        var fieldName = xmlElement.attr('dataField');
                        if(fieldName != undefined){
                            var colWidth = '0%';
                            var defaultRenderer = function(row, columnfield, value, defaulthtml, columnproperties){
                                var noPaddingsHtml = $(defaulthtml);
                                //если поле с координатами тип отображения градусы, то конвертируем
                                if(WidgetMap && WidgetMap.COORD_FIELDS && WidgetMap.coordMode === WidgetMap.COORD_MODES.GRAD && WidgetMap.COORD_FIELDS.indexOf(columnfield) !== -1){
                                    var gradCoord = GeoUtil.convertDecimalIntoDegree(value);
                                    return defaulthtml.replace('>'+value+'<','>'+gradCoord+'<' )
                                }
                            }
                            var linkRenderer = function(row, columnfield, value, defaulthtml, columnproperties){
                                //Public/Data/LIB/
                                var newVal = (App.config && App.config.LIB_PATH) ? App.config && App.config.LIB_PATH + value : value;
                                var link = '<a class="" href="'+newVal+'" target="_blank" title="Ссылка" ' +
                                    ' style="width:19px; height:18px; padding:0px; display: block;" >Скачать файл</a>'
                                return (value)?defaulthtml.replace('>'+value+'<','>'+link+'<' ):defaulthtml.replace('>'+value+'<','><' );
                            }

                            var cellRenderer = defaultRenderer;
                            if(xmlElement.attr('itemRenderer') === 'view.controls.renderer.GridLinkItemRenderer'){
                                cellRenderer = linkRenderer;
                            }

                            if(xmlElement.attr('width')){
                                colWidth = Number(xmlElement.attr('width'));
                            }
                            params.dataGrid.columns.push({text: xmlElement.attr('headerText'),datafield: fieldName,width:colWidth,
                                cellsrenderer: cellRenderer
                            });
                            params.source.datafields.push({name: fieldName, map: '['+fieldName+']'});
                        }
                        else
                            params.dataGrid.columns.push({text: xmlElement.attr('headerText'),datafield: "", columntype: 'number',width:'5%'});
                        break;
                    case 'selectScript':params.selectScript=xmlElement.text();break;
                    case 'dataProvider':
                        $.extend(params,{dataProvider:xmlElement.text()});
                        break;
                    case 'mx:VBox':
                        element = $('<div class="vBox '+addVisibleClass+'"></div>');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined && curElementWidth!='50%') element.css('width',curElementWidth); // curElementWidth!='50%' - чтобы растровые бланки не сжимались внутри ячейки
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var oldValues = {div:params.div,oldParentClass:params.parentClass};
                        params.div = element;
                        params.parentClass = '';
                        xmlElement.children().each(function(){methods.parseForm($(this),params)});
                        params.parentClass = oldValues.oldParentClass;
                        params.div = oldValues.div;
                        break;
                    case 'mx:HBox':
                        element = $('<div class="pPanelTable '+addVisibleClass+'"><div class="pPanelTableRow"></div></div>');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined && curElementWidth!='50%') element.css('width',curElementWidth); // curElementWidth!='50%' - чтобы растровые бланки не сжимались внутри ячейки
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var oldValues = {div:params.div,oldParentClass:params.parentClass};
                        params.div = $(element.children()[0]);
                        params.parentClass = 'pPanelTableCell';
                        xmlElement.children().each(function(){methods.parseForm($(this),params)});
                        params.parentClass = oldValues.oldParentClass;
                        params.div = oldValues.div;
                        break;
                    case 'mx:HRule':
                        element = $('<hr/>');
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        break;
                    case 'mx:TextInput':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        var fieldName = idElement.substring(0, idElement.indexOf('_'+params.localId));
                        params.options.tabIndex++;
                        var inputType = xmlElement.attr('displayAsPassword')!=undefined && xmlElement.attr('displayAsPassword')=='true' ? 'password' : 'text';
                        element = $('<input id="'+idElement+'" type="'+inputType+'" data-fieldname="' + fieldName + '" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
                        if (curElementHeight!=undefined) {
                            //Обрабатываем случай, если высота > 30, то считаем что нам нужен textArea для отображения в нескольких строках
                            if (parseFloat(xmlElement.attr('height'))>30) element = $('<textArea id="'+idElement+'" type="text" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
                            element.css('height',curElementHeight);
                        }
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        element.jqxInput({disabled:true,theme:'myCommon'}).on('keyup contextmenu input',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        if(defaultSelectedValue){
                            element.data('selectedvalue', defaultSelectedValue);
                            var data = (params.options && params.options.data)? params.options.data: null;
                            if(data && data[defaultSelectedValue])
                                methods.setControlValue(element, {value: data[defaultSelectedValue] });
                        }
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
                        if (valueFromConfig!=null) element.val(valueFromConfig);
                        if(params.idRequest == 'COSMETIC_OBJECT'){
                            var labelVal = params.options.objects[params.options.curObject][xmlElement.attr('id')];
                            element.val(labelVal)
                        }
                        break;
                    case 'mx:Text':
                        var id = '',text = '&nbsp;';
                        if(xmlElement.attr('text') != undefined)text = xmlElement.attr('text');
                        if(xmlElement.attr('id') != undefined)id = ' id="'+methods.getIdControl({xmlElement:xmlElement,params:params})+'"';
                        methods.appendFormElement({params:params,element:$('<span'+id+' data-typecontrol="label" class="'+addVisibleClass+'">'+text+'</span>'),xmlElement:xmlElement[0]});
                        break;
                    case 'mx:ComboBox':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        params.options.tabIndex++;
                        params.enabledCombo = xmlElement.attr('enabledCombo');
                        element = $('<div id="'+idElement+'" class="noListValues formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-typecontrol="combobox" data-loadvalue=false tabindex="'+params.options.tabIndex+'"></div>');
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var curComboHeight = curElementHeight!=undefined ? parseFloat(xmlElement.attr('height'))-2 : 16;
                        var curComboWidth = curElementWidth!=undefined ? parseFloat(xmlElement.attr('width')) : '100%';
                        var placeHolder = xmlElement.attr('hint')!=undefined ? xmlElement.attr('hint') : '';
                        var valueMember = xmlElement.attr('valueMember')!=undefined ? xmlElement.attr('valueMember') : 'CODE';
                        var displayMember = xmlElement.attr('displayMember')!=undefined ? xmlElement.attr('displayMember') : 'DESCR';
                        var defaultSelectedIndex = xmlElement.attr('selectedIndex')!=undefined ? parseFloat(xmlElement.attr('selectedIndex')) : -1;
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        element.jqxComboBox({valueMember:valueMember,displayMember:displayMember,width:curComboWidth, autoComplete: true, disabled:true, height:curComboHeight,dropDownHeight:130,dropDownWidth:curComboWidth, placeHolder:placeHolder, searchMode: 'containsignorecase',theme:'myCommon'}).on('change',function(){
                            if ($(this).hasClass('noListValues') == false && params.tableReadOnly == false)
                                methods.markChange($.extend(params,{control:$(this)}));
                        });
                        element.attr('defaultSelectedIndex',defaultSelectedIndex);
                        if(defaultSelectedValue)
                            element.data('selectedvalue', defaultSelectedValue)
                        if(xmlElement.attr('dataProvider') != undefined)
                            element.attr('dataProvider',xmlElement.attr('dataProvider'));
                        xmlElement.children().each(function(){methods.parseForm($(this),{options:params.options, comboBox:element});});
                        //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
                        if (valueFromConfig!=null) element.val(valueFromConfig);
                        break;
                    case 'mx:dataProvider':
                        var selectedIndex = -1;
                        var comboDataProv = [];
                        xmlElement.children().each(function(){
                            var curObj = { DESCR: $(this).attr('DESCR'), CODE: $(this).attr('CODE')};
                            comboDataProv.push(curObj);
                        });
                        var disabledCombo = params.comboBox.hasClass('noEditable');
                        var autoDropDownHeight = comboDataProv.length<=5 ? true : false; //При наличии в списках 5 и менее элементов нужно dropdown сжимать по их количеству
                        //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
                        if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1) selectedIndex = 0;
                        params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo,selectedIndex:selectedIndex,autoDropDownHeight:autoDropDownHeight, searchMode: 'containsignorecase', autoComplete: true });
                        params.comboBox.removeClass('noListValues');
                        break;
                    case 'mx:Button':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        element = $('<button id="'+idElement+'"></button>');
                        //По атрибуту styleName разделяем обычные кнопки и кнопки-иконки
                        var title = (xmlElement.attr('toolTip'))? xmlElement.attr('toolTip'): "";
                        if(xmlElement.attr('styleName') != undefined)
                            element = $('<div id="'+idElement+'" class="divIconButton '+xmlElement.attr('styleName')+'Icon '+addVisibleClass+'"></div>');
                        else {
                            var btnLabel = xmlElement.attr('label') != undefined ? xmlElement.attr('label') : '';
                            element = $('<button id="'+idElement+'" class="myButton '+addVisibleClass+'">'+btnLabel+'</button>');
                        }
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        element.attr('title', title);
                        element.attr('selectedField',xmlElement.attr('selectedField')!=undefined ? xmlElement.attr('selectedField') : '');
                        element.attr('btnStyleName',xmlElement.attr('styleName')!=undefined ? xmlElement.attr('styleName') : '');
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        element.jqxButton({theme:'myCommon', disabled: methods.checkEditable(xmlElement,params)=='noEditable'});
                        element.on('click', {elemId:idElement}, function goToLinkedObject(evt) {
                            evt.preventDefault();
                            var clickBtn = $('#'+evt.data.elemId);
                            var selectedField = clickBtn.attr('selectedField');
                            if (selectedField!='') {
                                //Получаем связанный с кнопкой объект
                                var idStr = clickBtn.attr('id');
                                var linkObj;
                                //Не привязываем кнопку к списку, если мы создаем новую запись.
                                if (idStr.substr(0,7)=="BUTTON_" && !params.options.creatingNewObject)
                                    linkObj = $('#'+idStr.substring(7));
                                else if (idStr.substr(0,9)=="BTN_LIST_")
                                    linkObj = $('#'+idStr.substring(9));
                                else if (idStr.substr(0,9)=="BTN_FILE_" && !params.options.creatingNewObject) //Кнопка перехода к файлу активна только если не создаем запись и есть имя файла
                                    linkObj = $('#'+idStr.substring(9));
                                //очищаем btn.data, чтобы если значения в поле нет, не осуществлять переход
                                var btnData = null;
                                var typeControl = '';
                                if (linkObj.length > 0) {
                                    typeControl = linkObj.data('typecontrol');
                                    if (typeControl=='combobox' && linkObj.jqxComboBox('getSelectedItem')!=null)
                                        btnData = selectedField+"/"+linkObj.jqxComboBox('val');
                                    else if (typeControl=='input' && linkObj.val()!='')
                                        btnData = selectedField+"/"+linkObj.val();
                                    else if (typeControl=='numberinput' && linkObj.val()!='')
                                        btnData = selectedField+"/"+linkObj.val();
                                    //если переходим к файлу, в btnData устанавливаем путь к файлу
                                    else if (typeControl=='inputfile' && linkObj.attr('value')!='') {
                                        if (App.config.DATA_PATH === undefined){
                                            App.errorReport(gis_core_17, 'DATA_PATH' + gis_core_18, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_22'});
                                            return;
                                        }
                                        btnData = App.config['DATA_PATH'] + linkObj.data('uploadpath') + linkObj.attr('value');
                                        btnData = btnData.replace(/\\/g,"/");
                                    }
                                }
                                //По нажатию на кнопку может осуществляться: переход к значению из comboBox,
                                //редактирование справочника либо открытие файла
                                //Не переходим по кнопке к файлу, если мы создаем новую запись.
                                if (clickBtn.attr('id').substr(0,9)=="BTN_FILE_" && (typeControl=='inputfile' || typeControl=='input' || typeControl=='numberinput') && !params.options.creatingNewObject && btnData) {
                                    var addIdStr = '_'+params.localId+'_'+params.selectedIndex;
                                    //Для открытия 3D-сцены или IMG-карты проверяем тип прикрепленного документа
                                    var docTypeId = $('#DOC_TYPE_ID'+addIdStr).length>0 ? $('#DOC_TYPE_ID'+addIdStr).val() : '';
                                    if (docTypeId!='' && ($('#DOC_VERSION_ID'+addIdStr).length>0 || $('#DOC_ID'+addIdStr).length>0) && (docTypeId=="37" || docTypeId=="38" || docTypeId=="41")) {
                                        var docObj = {};
                                        docObj.DOC_ID = $('#DOC_VERSION_ID'+addIdStr).length>0 ? $('#DOC_VERSION_ID'+addIdStr).val() : $('#DOC_ID'+addIdStr).val();
                                        docObj.FILE_NAME = linkObj.val(); /*(linkObj is FileInput) ? (linkObj as FileInput).fileLoading.text : (linkObj as TextInput).text;*/
                                        switch (docTypeId) {
                                            case "37":	//3Dсцена
                                                ExportUtil.exportToWRL(docObj.DOC_ID, docObj.FILE_NAME);
                                                break;
                                            case "38":	//IMG-карта
                                                ExportUtil.exportToIMG(docObj.DOC_ID, docObj.FILE_NAME);
                                                break;
                                            case "41":	//Видеофайл
                                                var rowDataObj = {};
                                                rowDataObj.ID = docObj.DOC_ID;
                                                rowDataObj.FILE_NAME = docObj.FILE_NAME;
                                                showVideo(docObj.DOC_ID, docObj.FILE_NAME, $('#NAME'+addIdStr).length>0 ? $('#NAME'+addIdStr).val() : gis_ppanel_49);
                                                //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                                widgetMoveWindowToPosition('grid');
                                                break;
                                        }
                                    } else {
                                        //Если документ не является ни 3D-сценой, ни IMG-картой, ни видеофайлом - открываем его
                                        var fileName = linkObj.attr('value');
                                        HTTPServiceUtil.openFile(btnData, {specificPdfFileName: fileName, parentDir: pPanelOpenDocPath});
                                    }
                                } else if (clickBtn.attr('btnStyleName')=="refList" && typeControl=='combobox') {
                                    //В selectedField "ИМЯ_ФАЙЛА#ИДЕНТИФИКАТОР_ИСТОЧНИКА".
                                    //Точно разделить значение схемы и таблицы невозможно, поэтому считаем что в названии схемы нет символа "_"
                                    var dirForm = new DirectoryEditForm({requestSQL:selectedField,
                                        source:linkObj[0].getAttribute('dataProvider').split('#')[0],
                                        requestSource:linkObj[0].getAttribute('dataProvider')
                                    });
                                    dirForm.build();
                                    /*showDirectoryEditForm(btn.selectedField, (linkObj as ComboBox).id);*/
                                } else if (clickBtn.attr('btnStyleName')=="refObject" && !params.options.creatingNewObject && btnData) {
                                    //Затираем callback-функцию changePanelObjectCallback, чтобы при открытии панели с карты и переходе на объекты без слоя не кидалось сообщение об ошибке
                                    if (params.options.handlers && params.options.handlers.changePanelObjectCallback!=undefined)
                                        params.options.handlers.changePanelObjectCallback = undefined;
                                    //переходим по кнопке к объекту
                                    var linkedObjParams = {
                                        divProperties:params.divProperties,
                                        localId:params.localId,
                                        options:{objects:[{id:btnData.replace('/',':')}], curObject:0, handlers:params.options.handlers, opener:params.options.opener}
                                    };
                                    methods.openObjectInNewPanel(linkedObjParams);
                                }
                            }
                        });
                        break;
                    case 'mx:CheckBox':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        params.options.tabIndex++;
                        //тип чекбокса: принимает значения либо 0|1(случай sqlite) либо Y|N
                        var checkboxValueType = xmlElement.attr('type')=="number"?"number":'boolean';
                        element = $('<div id="'+idElement+'" data-typecontrol="checkbox" data-typevalue="'+checkboxValueType+'" class="formControl myCheckBox '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'"></div>');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var isChecked = xmlElement.attr('selected')=="true" ? true : false;
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        if(defaultSelectedValue)
                            element.data('selectedvalue', defaultSelectedValue)
                        element.jqxCheckBox({disabled:true,checked:isChecked,theme:'myCommon'}).on('change',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        break;
                    case 'mx:RadioButton':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        params.options.tabIndex++;
                        element = $('<div id="'+idElement+'" data-typecontrol="radio" class="formControl myRadio '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'"></div>');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        var isChecked = xmlElement.attr('selected')=="true" ? true : false;
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        if(defaultSelectedValue)
                            element.data('selectedvalue', defaultSelectedValue)
                        element.jqxCheckBox({disabled:true,checked:isChecked,theme:'myCommon'}).on('change',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        $("#admRoutesIntervalDividingForm_useIntervalsButton").jqxRadioButton({checked: true, width:120, height:25, groupName:'useRegularIntervalsGroup'}).on('change', function (event) {
                            var checked = event.args.checked;
                            regularIntervalsDistanceInput.jqxInput({disabled: !checked});
                        });
                        $("#admRoutesIntervalDividingForm_dontUseIntervalsButton").jqxRadioButton({width:120, height:25, groupName:'useRegularIntervalsGroup'}).on('change', function (event) {
                            var checked = event.args.checked;
                            //Блокируем поле PODS_FEATURE_TABLE
                            $("div[ data-dataprovider='"+GridAdmRoutesIntervalDividingForm.PODS_FEATURE_TABLE_REQUEST+"']", dlg).each( function (){
                                $(this).jqxExpander({disabled: !checked});
                            });
                        });
                        break;
                    case 'mx:DateField':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        params.div.addClass('mxForm');
                        // Считываем общие аттрибуты
                        var cssWidth;
                        var width = xmlElement.attr('width');
                        if(/^(\d+)%$/) { // А вдруг указаны проценты
                            cssWidth = width;
                        }
                        else if(width > 0) {
                            cssWidth = width + 'px';
                        }
                        var percentWidth = xmlElement.attr('percentWidth');
                        if(percentWidth > 0) {
                            cssWidth = percentWidth*1 + '%';
                        }
                        var cssHeight = xmlElement.attr('height');
                        if(cssHeight) { cssHeight += 'px'; }
                        var formatString = (xmlElement.attr("formatString"))? xmlElement.attr("formatString"): 'dd:mm:yyyy';
                        var element = $('<div id="'+idElement+'" data-typecontrol="date" data-format=' + formatString + ' class="control formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false >' +
                            '<input type="text" class="date" maxlength="12" /></div>');

                        //Добавляем в форму
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});

                        var inp = $('input', element);
                        inp.change(function() {
                            methods.markChange($.extend(params,{control:$(this).parent()}));
                        });
                        if(addVisibleClass=='noEditable') element.attr('readonly', 'readonly').addClass('readOnly');
                        if(cssWidth) { element.css('width', cssWidth); }
                        if(cssHeight) { inp.css({'height':cssHeight, 'line-height':cssHeight}); }
                        // Для полей типа даты, которые доступны к редактированию устанавливаем datepicker
                        $('input.date', element).not('.readOnly').datepicker();
                        var defaultSelectedValue = xmlElement.attr('selectedValue')!=undefined ? xmlElement.attr('selectedValue') : '';
                        if(defaultSelectedValue){
                            element.data('selectedvalue', defaultSelectedValue);
                            var data = (params.options && params.options.data)? params.options.data: null;
                            if(data && data[defaultSelectedValue])
                                methods.setControlValue(element, {value: data[defaultSelectedValue] });
                        }

                        params.options.tabIndex++;
                        inp.attr('tabindex', params.options.tabIndex);
                        break;
                    case 'controls:NumberInput':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        var fieldName = idElement.substring(0, idElement.indexOf('_'+params.localId));
                        params.options.tabIndex++;
                        element = $('<input id="'+idElement+'" type="text" data-fieldname="' + fieldName + '" data-typecontrol="input" class="formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
                        //element = $('<div id="'+idElement+'" data-typecontrol="numberinput" class="formControl '+methods.checkEditable(xmlElement,params)+' '+addVisibleClass+'" data-loadvalue=false tabindex="'+params.options.tabIndex+'" />');
                        if (curElementHeight!=undefined) element.css('height',curElementHeight);
                        if (curElementWidth!=undefined) element.css('width',curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        if(defaultSelectedValue)
                            element.data('selectedvalue', defaultSelectedValue);
                        element.jqxInput({disabled:true,theme:'myCommon'}).on('keyup contextmenu input',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        //Если в поле есть свойство text="{CONFIG.<значение ключа>}" - устанавливаем сразу как дефолтное
                        if (valueFromConfig!=null) element.val(valueFromConfig);
                        //если поле с координатами тип отображения градусы, то конвертируем
                        if(WidgetMap && WidgetMap.COORD_FIELDS && WidgetMap.coordMode === WidgetMap.COORD_MODES.GRAD && WidgetMap.COORD_FIELDS.indexOf(fieldName) !== -1){
                            break;
                        }
                        //element.jqxNumberInput({decimalDigits: 2, inputMode: 'simple', groupSeparator: "", disabled:true,theme:'myCommon'}).on('keyup',function(){methods.markChange($.extend(params,{control:$(this)}));});
                        //element.jqxNumberInput.val(null);
                        params.rules.push({
                            input: '#'+idElement,
                            message: gis_ppanel_50,
                            action: 'none',
                            rule: function(){var val = $('#'+idElement).val();
                                if(val != '')return /^[+-]?\d*(\.\d+)?$/.test(val);
                                else return true;},
                            hintRender:function(message, input){
                                if (input.length > 0) $(input[0]).data('validateErrorText',message);
                            }
                        });
                        break;
                    case 'validatorsArray':
                        xmlElement.children().each(function(){methods.parseForm($(this),params);});
                        break;
                    case 'controls:DefaultEmailValidator':
                        idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
                        if($('#'+idElement).length == 0)return;
                        params.rules.push({
                            input: '#'+idElement,
                            message: gis_ppanel_51,
                            action: 'none',
                            rule: 'email',
                            hintRender:function(message, input){
                                if (input.length > 0) $(input[0]).data('validateErrorText',message);
                            }
                        });
                        break;
                    case 'controls:DefaultDateValidator':
                    case 'controls:DefaultStringValidator':
                    case 'controls:DefaultNumberValidator':
                        idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
                        if($('#'+idElement).length == 0)return;
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        break;
                    case 'controls:DefaultComboBoxValidator':
                    case 'controls:ComboBoxValidator':
                        idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
                        if($('#'+idElement).length == 0)return;
                        if(xmlElement.attr('required') == 'true'){
                            xmlElement.attr('required','false');
                            xmlElement.attr('requiredcombo','true');
                        }
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        break;
                    case 'controls:FieldComparisonValidator':
                        idElement = xmlElement.attr('source').substr(1, xmlElement.attr('source').length-2)+'_'+params.localId+'_'+params.selectedIndex;
                        if($('#'+idElement).length == 0)return;
                        methods.setValidateElement({params:params,idElement:idElement,xmlElement:xmlElement[0]});
                        break;
                    case 'controls:FileInput':
                        idElement = methods.getIdControl({xmlElement:xmlElement,params:params});
                        var accept = '';
                        if(xmlElement.attr('fileFilterExtension') != undefined)accept = ' accept="'+xmlElement.attr('fileFilterExtension').replace(/\*/g,'')+'"';
                        element = $('<input id="'+idElement+'" type="hidden" value="" data-typecontrol="inputfile" class="formControl" data-loadvalue=true data-uploadpath="'+xmlElement.attr('uploadPath')+'"/>\
                           <div id="divFI_'+idElement+'" class="divFileInput">\
                            <input class="divFileInputName noVisible" />\
                            <input id="iFIText_'+idElement+'" class="divFileInputNameText" />\
                            <form method="POST" id="fr_'+idElement+'" action="" data-action="./api/files/upload?path='+
                            xmlElement.attr('uploadPath')+'" enctype="multipart/form-data" class="frmInputFile" target="ifr_'+idElement+'">\
                             <input id="iFI_'+idElement+'" type="file" data-typecontrol="file" data-filename="" class="iFileInput" name="fileinput" '+accept+'/>\
                            </form>\
                            <iframe id="ifr_'+idElement+'" name="ifr_'+idElement+'" class="noVisible ifDocForm" data-checkload=false></iframe>\
                           </div>');
                        if (!isNaN(curElementHeight)) element.height(curElementHeight);
                        if (!isNaN(curElementWidth)) element.width(curElementWidth);
                        methods.appendFormElement({params:params,element:element,xmlElement:xmlElement[0]});
                        $('#ifr_'+idElement).load(function(){methods.uploadComplete($.extend(params,{iframe:this,indexForm:params.selectedIndex,saveMethod:'saveTabForm'}));});
                        $('#iFI_'+idElement).change(methods.setInputFileName);
                        $('#iFIText_'+idElement).change(methods.setInputFileNameText);
                        $('#'+idElement).change(function(){
                            if($(this).data('needSetFileInput') == false){//если редактировали руками название файла
                                if($('#divFI_'+idElement).hasClass('waitLoad')){
                                    $('#divFI_'+idElement).removeClass('waitLoad');
                                    var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                                    frm.data('waitload',Number(frm.data('waitload'))-1);
                                }
                            }
                            else{
                                $('#divFI_'+idElement+' .divFileInputName').val($(this).val());
                                if($('#divFI_'+idElement+' .divFileInputNameText').val() != $(this).val())
                                    $('#divFI_'+idElement+' .divFileInputNameText').val($(this).val());
                                if(!$('#divFI_'+idElement).hasClass('waitLoad'))
                                {
                                    $('#divFI_'+idElement).addClass('waitLoad');
                                    var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                                    frm.data('waitload',Number(frm.data('waitload'))+1);
                                }
                            }
                            $(this).data('needSetFileInput',true);
                            methods.markChange(params);
                        });
                        break;
                    case 'panel:buttons':
                        //params.div = element;
                        //params.parentClass = '';
                        xmlElement.children().each(function(){methods.parseForm($(this),params)});
                        break;
                    case 'picPutton:PanelButton':
                        if (params.options.objects[params.options.curObject].flag === 'import') return;
                        var iconUrl = xmlElement.attr('source');
                        var tooltip = xmlElement.attr('tooltip');
                        var clickEvent = xmlElement.attr('clickEvent');
                        var syncMap = xmlElement.attr('syncMap') === 'true';
                        if(params.selectedIndex === 0) {// если вкладка не 0-я, значит вообще не добавляем кнопки.
                            methods.createLeftButton({
                                params: params,
                                iconUrl: iconUrl,
                                tooltip: tooltip,
                                clickEvent: clickEvent,
                                syncMap: syncMap,
                            });
                        }
                        break;

                    default:
                        //console.log('Unknown tag!!!!!  ',xmlElement[0].tagName);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
                //console.err(err);
            }
        },
        //проверка, установлены ли боковые кнопки, описанные в панели свойств или нет. Если нет, то добавляем все по умолчанию
        checkLeftButtons:function(params){
            var children = $('#divLeftPanel_'+params.localId).children();
            if(children.length == 0 && params.selectedIndex == 0 && !params.options.objects[params.options.curObject].flag){
                var background = '';
                methods.createLeftButton({params:params, clickEvent:'DocsEvent',iconUrl:'',tooltip: gis_ppanel_1});
                methods.createLeftButton({params:params, clickEvent:'SaveEvent',iconUrl:'',tooltip: gis_ppanel_2});
                methods.createLeftButton({params:params, clickEvent:'UndoEvent',iconUrl:'',tooltip: gis_ppanel_3});
                methods.createLeftButton({params:params, clickEvent:'DeleteEvent',iconUrl:'',tooltip: gis_ppanel_12});
                methods.createLeftButton({params:params, clickEvent:'ExportGpxEvent',iconUrl:'',tooltip: gis_ppanel_15});
                methods.createLeftButton({params:params, clickEvent:'ShowOnMapEvent',iconUrl:'',tooltip: gis_ppanel_17});
                methods.createLeftButton({params:params, clickEvent:'FindRouteEvent',iconUrl:'',tooltip: gis_ppanel_61});
                methods.createLeftButton({params:params, clickEvent:'BufferCustomEvent',iconUrl:'',tooltip: gis_bufferzonechoosercontrol_3});
                methods.createLeftButton({params:params, clickEvent:'ExportToExcelEvent',iconUrl:'',tooltip: gis_ppanel_18});
                methods.createLeftButton({params:params, clickEvent:'BackEvent',iconUrl:'',tooltip: gis_ppanel_22});
                methods.createLeftButton({params:params, clickEvent:'ForwardEvent',iconUrl:'',tooltip: gis_ppanel_23});
            }else if(params.options.objects[params.options.curObject].flag){
                var background = '';
                methods.createLeftButton({params:params, clickEvent:'ApplyEvent',iconUrl:'',tooltip: gis_core_7});
                methods.createLeftButton({params:params, clickEvent:'CancelEvent',iconUrl:'',tooltip: gis_core_8});
            }
        },
        createLeftButton:function(options){
            var params = options.params;
            //забираем из конфига запрещенные кнопки. Если из грида открыли, передаём options для получения запрещенных кнопок для панели свойств, открыитой из грида
            var denyButtons = (getDenyPropButtonsByTask) ? getDenyPropButtonsByTask((params && params.options && params.options.openerType) ? params.options.openerType : MAP_TYPE.MAP) : [];
            var buttonName = options.clickEvent.replace('Event','');
            if(denyButtons.indexOf(buttonName) !== -1)
                return;
            var iconUrl = options.iconUrl;
            var background = 'background:url(\''+iconUrl+'\') no-repeat center;';
            //if(iconUrl === undefined || iconUrl === '')
            background = '';
            var tooltip = options.tooltip
            var clickEvent = options.clickEvent;
            var syncMap = options.syncMap;
            var buttonTemplate = '';
            var localId = params.localId;
            var options = params.options;
            /*if(options)
          options.syncMap = syncMap;*/
            var el = params.divProperties;
            var pPanelParams = {divProperties:params.divProperties,localId:localId,options:options, dataProvider:params.dataProvider};
            switch(clickEvent){
                case 'DocsEvent':
                    if($('#btnLeftPDocs_'+params.localId).length > 0)
                        $('#btnLeftPDocs_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPDocs_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'" class="btnLeftPanelIcon btnLeftPanelDocs"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPDocs_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                        if (curSelectedObjectId.indexOf(':')>0) {
                            //Переходим по ссылке на прикрепленные документы текущего объекта
                            var curDocLink = './docList.html?objId=' + curSelectedObjectId;
                        var curRowData = options.objects[options.curObject].curRowData;
                        if(curRowData && curRowData.LG_ATTACH){//хардкод для варианта внешнего источника
                            try{
                                curDocLink = './docList.html?objId=' + curRowData.LG_ATTACH.replace(new RegExp('"','g'),'&quot;');
                            }
                            catch(ex){ }
                        }
                            //Для трубопроводов пытаемся получить также LINE_ID для воспроизведения видеозаписей
                            if (curSelectedObjectId.indexOf('PODS_ROUTE')>=0) {
                                var routeData = methods.serializeForm('frm_'+pPanelParams.localId+'_0');
                                var lineIdInd = routeData.indexOf('LINE_ID="');
                                if (lineIdInd >= 0) {
                                    //Добавляем в ссылку lineId, чтобы было откуда для PODS_ROUTE его брать в окне прикрепленных документов
                                    var lineId = routeData.substring(lineIdInd+9,routeData.indexOf('"',lineIdInd+9));
                                    curDocLink += '&lineId=' + lineId;
                                }
                            }
                            //Открываем ссылку с хешем авторизации
                            var docWnd = window.open(curDocLink + Auth.hash, '_blank');
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'SaveEvent':
                    if($('#btnLeftPSave_'+params.localId).length > 0)
                        $('#btnLeftPSave_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPSave_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelSave"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPSave_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        methods.checkSave({divProperties:el,localId:localId,options:options,callBack:function(){}}, syncMap);
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    //СИНХРОНИЗАЦИЯ. Используются коллбеки в semanticCallback
                    break;
                case 'ApplyEvent':
                    if($('#btnLeftPApply_'+params.localId).length > 0)
                        $('#btnLeftPApply_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPApply_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelApply"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPApply_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        methods.checkSave({divProperties:el,localId:localId,options:options,callBack:function(){}}, syncMap);
                    }).attr('title',tooltip);
                    break;
                case 'CancelEvent':
                    if($('#btnLeftPCancel_'+params.localId).length > 0)
                        $('#btnLeftPCancel_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPCancel_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelCancel"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPCancel_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        methods.destroyPanel(pPanelParams);
                    }).attr('title',tooltip);
                    break;
                case 'UndoEvent':
                    if($('#btnLeftPUndo_'+params.localId).length > 0)
                        $('#btnLeftPUndo_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPUndo_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelUndo"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPUndo_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        methods.showPanelObject({checkSave:false,divProperties:el,localId:localId,options:options});
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    //СИНХРОНИЗАЦИЯ #J5 TYPE_NO ничего не происходит
                    break;
                case 'DeleteEvent':
                    if($('#btnLeftPDelete_'+params.localId).length > 0)
                        $('#btnLeftPDelete_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPDelete_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelDelete"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPDelete_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                            if(options.handlers.deleteCallback != undefined)
                                options.handlers.deleteCallback(methods.getAllFormsObjects(localId));
                            else if (curSelectedObjectId.indexOf(':')>0) {
                                var splittedIdArr = curSelectedObjectId.split(':');
                                //Пытаемся получить нужные для удаления данные (в том числе через layerManager)
                                try {
                                    var layerId = splittedIdArr[0];
                                    var layerManagerInst = WidgetMap!=undefined ? WidgetMap.layerManager : undefined;
                                    //Если нет LayerManager - так и пишем
                                    var curLayerObj = layerManagerInst!==undefined && layerManagerInst.getLayerByName !== undefined ? layerManagerInst.getLayerByName(layerId) : undefined;
                                    var dataRequest = '';
                                    if (curLayerObj==undefined || curLayerObj==null || !curLayerObj.hasOwnProperty('dataProvider') || curLayerObj.dataProvider.semantic=='') {
                                        //Форма может удалить с помощью семантики, если у нее есть dataProvider
                                        if (pPanelParams.dataProvider!=undefined && pPanelParams.dataProvider) {
                                            dataRequest = pPanelParams.dataProvider+'#'+$($('#ulTabs_'+pPanelParams.localId).children()[0]).data('source');
                                        } else {
                                            //Если слоя нет - делаем как во флеше (там ничего не происходило, даже запрос не отправлялся, здесь Володя сказал должна быть форма с сообщением)
                                            alertForm = new AlertForm();
                                            alertForm.build("pPanelDeleteNoLayerAlertForm",gis_ppanel_4,gis_ppanel_5,AlertForm.OK);
                                            return;
                                        }
                                    } else {
                                        //удаление ТОЛЬКО СЕМАНТИКИ (исправить provider на dataRequest = "", чтобы прошел полный алгоритм удаления сначала геометрии затем семантики)
                                        dataRequest = curLayerObj.dataProvider.semantic;
                                    }
                                    //выставил PropertyPanelName="" как для случая групповой операции удаления было сделано
                                    var deletingObject = {classId:layerId, objectId:splittedIdArr[1], provider:dataRequest, propertyPanelName:""};
                                    var alertForm = new AlertForm();
                                    //Меняем кнопки на "Да" и "Нет"
                                    alertForm.alertOkButtonText = gis_ppanel_6;
                                    alertForm.alertCancelButtonText = gis_ppanel_7;
                                    alertForm.width = 330;
                                    alertForm.build("pPanelDeleteConfirmationForm",gis_ppanel_8,gis_ppanel_9);
                                    //Добавляем слушатель закрытия формы
                                    //CloseEvent
                                    $("body").on(CloseEvent.CLOSE, function onDeleteConfirmationFormClose(evt) {
                                        $("body").off(CloseEvent.CLOSE);
                                        if (evt && evt.detail==1) {
                                            if(options.handlers.deleteCASCallback != undefined){
                                                options.handlers.deleteCASCallback(methods.getAllFormsObjects(localId));
                                                return false;
                                            }
                                            DBUtil.deleteGeometryFromDB(deletingObject.objectId, deletingObject.classId, deletingObject.provider, deletingObject.propertyPanelName);
                                            //Функция обработки результата удаления записи
                                            var onObjectDeleteResult = function onObjectDeleteResult(evt) {
                                                $("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
                                                $("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
                                                if (evt.operationData!="") {
                                                    App.errorReport(gis_ppanel_10, evt.operationData, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_1'});
                                                }
                                                else{
                                                    if(MapUtil && syncMap)
                                                        MapUtil.updateLayerData(deletingObject.classId, [deletingObject.objectId], false);
                                                    //если есть колбек после удачного удаления, то
                                                    if(options.handlers.successDeleteCallback != undefined){
                                                        options.handlers.successDeleteCallback({id:deletingObject.objectId,layerName: deletingObject.classId});
                                                    }
                                                }
                                            };
                                            //Функция обработки ошибки при удалении записи
                                            var onObjectDeleteFault = function onObjectDeleteFault(evt) {
                                                $("body").off(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID);
                                                $("body").off(OperationEvent.OBJECT_DELETED_BY_ID);
                                                if (evt.operationData!="") App.errorReport(gis_ppanel_10, evt.operationData, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_2'});
                                            };
                                            //Добавляем слушатель
                                            $("body").on(OperationEvent.OBJECT_DELETED_BY_ID_FROM_GRID, onObjectDeleteResult);
                                            $("body").on(OperationEvent.OBJECT_DELETED_BY_ID, onObjectDeleteFault);
                                        }
                                    });
                                } catch (e) {
                                    App.errorReport(gis_ppanel_11, e.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_3'});
                                }
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'ExportGpxEvent':
                    if($('#btnLeftPExportNAV_'+params.localId).length > 0)
                        $('#btnLeftPExportNAV_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPExportNAV_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelExNAV"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPExportNAV_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                            if(options.handlers.exportToGpxKmlCallback != undefined)
                                options.handlers.exportToGpxKmlCallback(methods.getAllFormsObjects(localId));
                            else if (curSelectedObjectId.indexOf(':')>0) {
                                var splittedIdArr = curSelectedObjectId.split(':');
                                try {
                                    //Пытаемся получить нужные для экспорта данные (в том числе через layerManager)
                                    var filterStr = "ID = " + splittedIdArr[1];
                                    var layerManagerInst = WidgetMap.layerManager;
                                    var curLayerObj = layerManagerInst.getLayerByName(splittedIdArr[0]);
                                    //Если слоя нет - делаем как во флеше (там ничего не происходило)
                                    if (curLayerObj==undefined || curLayerObj==null) return;
                                    var currentGridDescr = {layerId:splittedIdArr[0], layerManager: layerManagerInst}; //фиктивный объект, сформирован так же, как currentGridDescr в гриде для использования той же функции
                                    GridWidget.prototype.exportObjectsToGPX(filterStr, currentGridDescr);
                                } catch (e) {
                                    App.errorReport(gis_ppanel_10, evt.operationData,undefined, {filename:gis_filename_568, functionname:'gis_filename_568_4'});
                                }
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'ShowOnMapEvent':
                    if($('#btnLeftPShowOnMap_'+params.localId).length > 0)
                        $('#btnLeftPShowOnMap_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPShowOnMap_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelShowOnMap"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPShowOnMap_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            var curObjData = methods.getAllFormsObjects(localId);
                            var opener = options && options.openerType;
                            var sender = (opener === 'grid') ? 'grid_ppanel' : 'ppanel';
                            var selectedObject = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                            var unique = options.objects[options.curObject].uniqueLayerName || undefined;
                            if (options.handlers.centeringCallback != undefined) {
                                //TODO рефакторинг, решить куда вынести синхронизацию: в centeringCallback или оставить здесь
                                widgetMoveWindowToPosition('grid');
                                if (selectedObject) {
                                    //СИНХРОНИЗАЦИЯ #L5
                                    //СИНХРОНИЗАЦИЯ #L6
                                    //СИНХРОНИЗАЦИЯ #L7
                                    //СИНХРОНИЗАЦИЯ #L8
                                    App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                                }
                                options.handlers.centeringCallback(curObjData, options, selectedObject);
                            }
                            else {
                                try {
                                    if (selectedObject) {
                                        var funcName = "showObjects";
                                        var params = [{name:"objects", value:selectedObject}, {name:"select", value:true}, {name:"centering", value:true}, {name:"gridCenteringResultFunction", value:App.errorReport}];
                                        if(!App.syncEnabled){
                                            ExternalInteraction.callFunction("", funcName, params);
                                            //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                            widgetMoveWindowToPosition('grid');
                                        }
                                        else{
                                            //upd. 21.04.21 принято решение, если текущая вкладка, то центровка на карте по-старому без синхронизации
                                            //ExternalInteraction.callFunction("", funcName, params);
                                            //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                            widgetMoveWindowToPosition('grid');
                                            if (selectedObject) {
                                                //СИНХРОНИЗАЦИЯ #L5
                                                //СИНХРОНИЗАЦИЯ #L6
                                                //СИНХРОНИЗАЦИЯ #L7
                                                //СИНХРОНИЗАЦИЯ #L8
                                                App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                                            }
                                        }
                                        //проверка
                                    }
                                } catch (e) {
                                    App.errorReport(gis_ppanel_16, e.message, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_5'});
                                }
                            }
                            var isMapAsIframe = (WidgetMap && WidgetMap.config && WidgetMap.config.map && WidgetMap.config.map.type === 'widget');
                            //TODO хадкод показа на карте объектов су тс тпа для презентации
                            if(isMapAsIframe){
                                var select = true;
                                var centering = true;
                                params = [{name:"mdl", value:"main_js.html"}, {name: "objects", value: selectedObject}, {name: "select", value: select}, {name: "centering", value: centering},{name: "isGroupButton", value: true}];
                                var taskName = (WidgetMap && WidgetMap.config && WidgetMap.config.map && WidgetMap.config.map.task)?WidgetMap.config.map.task:'sutstpa_map';
                                GridUtil.showOnMap(taskName, params);
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',gis_ppanel_17);//.jqxTooltip({content:gis_ppanel_17});
                    break;
                case 'ShowOnMapPipePartEvent':
                    if($('#btnLeftPShowOnMap_'+params.localId).length > 0)
                        $('#btnLeftPShowOnMap_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPShowOnMap_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelShowOnMap"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPShowOnMap_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            var curObjData = methods.getAllFormsObjects(localId);
                            widgetMoveWindowToPosition('grid');
                            if (selectedObject) {
                                //СИНХРОНИЗАЦИЯ #L5
                                //СИНХРОНИЗАЦИЯ #L6
                                //СИНХРОНИЗАЦИЯ #L7
                                //СИНХРОНИЗАЦИЯ #L8
                                App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                            }
                            if (options.handlers.centeringCallback != undefined)
                                options.handlers.centeringCallback(curObjData, options);
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',gis_ppanel_17);//.jqxTooltip({content:gis_ppanel_17});
                    break;
                case 'FindRouteEvent':
                    if($('#btnLeftFindRoute_'+params.localId).length > 0)
                        $('#btnLeftFindRoute_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftFindRoute_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon map-find-route-button"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftFindRoute_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            $('body').append('<div id="findRouteModal" class="findRouteModal">Выберите направление маршрута</div>');
                            var dlg = $('#findRouteModal');
                            var buttons = {};
                            buttons[0] = {
                                text: 'От точки',
                                click: function(){
                                    $('#findRouteModal').remove();
                                    WidgetMap.findRoute.handleFindRouteClick_(true);
                                    var event = {
                                        coordinate: [options.coords[0], options.coords[1]]
                                    };
                                    WidgetMap.findRoute.mapClickHandler_(event);
                                }
                            };
                            buttons[1] = {
                                text: 'До точки',
                                click: function(){
                                    $('#findRouteModal').remove();
                                    WidgetMap.findRoute.handleFindRouteClick_(false);
                                    var event = {
                                        coordinate: [options.coords[0], options.coords[1]]
                                    };
                                    WidgetMap.findRoute.mapClickHandler_(event);
                                }
                            };

                            dlg.dialog({
                                modal : true,
                                title : 'Построение маршрута',
                                width : 300,
                                height: 120,
                                dialogClass: 'gsi-zindex__dialog',
                                buttons: buttons
                            });

                            //WidgetMap.findRoute.handleFindRouteClick_(false);
                            //var event = {
                            //    coordinate: [options.coords[0], options.coords[1]]
                            //};
                            //WidgetMap.findRoute.mapClickHandler_(event);
                            widgetMoveWindowToPosition('grid');
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'BufferCustomEvent':
                    if($('#btnLeftBufferCustom_'+params.localId).length > 0)
                        $('#btnLeftBufferCustom_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftBufferCustom_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon map-buffer-custom"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftBufferCustom_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            if(WidgetMap.bufferZoneControl){
                                //upd. 18.06.20 если не успели подгрузиться данные(растр), выдать сообщение, чтобы подождать
                                if (WidgetMap.mapSelectionLayer.getSource().getFeatures().length == 0){
                                    App.confirmDialog(gis_ppanel_62, null, {
                                        title: gis_bufferzonechoosercontrol_7,
                                        width: 300,
                                        dialogClass: 'noCloseButton'
                                    });
                                    return;
                                }
                                WidgetMap.bufferZoneControl.selectedIds = params.options.objects;
                                WidgetMap.bufferZoneControl.handleBufferClick_('custom',params.options.withCtrl);
                            }

                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'ExportToExcelEvent':
                    if($('#btnLeftPExcel_'+params.localId).length > 0)
                        $('#btnLeftPExcel_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPExcel_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelExcel"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    //проверяем, что слой PODS_ROUTE, значит вместо обычного экспорта - экспорт пикетажа
                    //все трубы будут экспортировать пикетаж из панели свойств
                    if(true || goog.isDef(options.objects[0].id) && options.objects[0].id.indexOf('PODS_ROUTE:')!=-1){
                        $('#btnLeftPExcel_'+params.localId).jqxButton({ theme:'myCommon'}).on('click',function(){
                            if(goog.isDef(options.objects[0].id) && options.objects[0].id.indexOf('PODS_ROUTE:')!=-1){
                                try {
                                    var rId = undefined;
                                    var lId = undefined;
                                    if(goog.isDef(options.objects[0].curRowData["ID"]))
                                        rId = options.objects[0].curRowData["ID"];
                                    if(goog.isDef(options.objects[0].curRowData["LINE_ID"]))
                                        lId = options.objects[0].curRowData["LINE_ID"];
                                    var extDataId = 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE';


                                    function build() {
                                        //Создаем диалоговую форму
                                        dlg.dialog({
                                            modal: true,
                                            title: gis_ppanel_18,
                                            dialogClass: 'noCloseButton gsi-zindex__dialog',
                                            closeOnEscape: true,
                                            width: 300,
                                            height: 180
                                        });

                                        //Кнопки Ок и отмены
                                        $("input[name='export']", dlg).click(function () {
                                            if($('input[id="radioPicketingByRoute"]', dlg).is(':checked'))
                                                ExportUtil.exportAdmPicketingToExcel([{ROUTE_ID: rId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_ROUTE');
                                            else
                                                ExportUtil.exportAdmPicketingToExcel([{LINE_ID: lId}], 'server_export', 'PODS_EXPORT.xml#PODS_ADM_PICKETING_BY_LINE');
                                            $('#exportPicketingToExcelForm').remove();
                                        });
                                        $("input[name='cancel']", dlg).click(function () {
                                            $('#exportPicketingToExcelForm').remove();
                                        });
                                    }
                                    var elementId = 'exportPicketingToExcelForm';
                                    $('#'+elementId).remove();
                                    $('body').append('<div id="'+elementId+'"></div>');
                                    var dlg = $('#'+elementId);
                                    dlg.load('ui/html/ExportPicketingToExcelForm.html', build);
                                } catch (err) {
                                    //Ничего не делаем, возможно панель закрыта
                                }
                            }
                            else{
                                try {
                                    var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                                    if(options.handlers.exportToExcelCallback != undefined)
                                        options.handlers.exportToExcelCallback(methods.getAllFormsObjects(localId));
                                    else if (curSelectedObjectId.indexOf(':')>0) {
                                        var splittedIdArr = curSelectedObjectId.split(':');
                                        try {
                                            var curDivTabContent = $('#divTabContent_'+localId+'_0'); //Всегда берем параметры экспорта (excelTemplate и ext_data_id) из первой вкладки
                                            //Пытаемся получить нужные для экспорта данные
                                            var fileName = App.generateUUID() + ".xls";
                                            //Если вызов экспорта одиночной записи - при отсутствии templatename подставляем template='export'
                                            var excelTemplate = curDivTabContent.length>0 && curDivTabContent.data('excelTemplate')!=undefined ? curDivTabContent.data('excelTemplate') : splittedIdArr[0];
                                            var extDataId = curDivTabContent.length>0 && curDivTabContent.data('ext_data_id')!=undefined ? curDivTabContent.data('ext_data_id') : '';
                                            //if(extDataId == 'disabled') return;
                                            //Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде datafield:value
                                            var newDataObj = methods.getCurrentFormObject('frm_'+localId+'_0');
                                            if (extDataId=='') {
                                                ExportUtil.exportToExcel([newDataObj], fileName, excelTemplate, 'export');
                                            } else {
                                                ExportUtil.exportToExcel([newDataObj], fileName, excelTemplate, extDataId);
                                            }
                                        } catch (e) {
                                            App.errorReport(gis_ppanel_19, gis_ppanel_14 + e.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_6'});
                                        }
                                    }
                                } catch (err) {
                                    //Ничего не делаем, возможно панель закрыта
                                }
                            }

                        }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    }
                    else{
                        $('#btnLeftPExcel_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                            try {
                                var curSelectedObjectId = options.objects[options.curObject].id; //id обязательно должен быть в нижнем регистре, т.к. там 2 свойства - id и ID
                                if(options.handlers.exportToExcelCallback != undefined)
                                    options.handlers.exportToExcelCallback(methods.getAllFormsObjects(localId));
                                else if (curSelectedObjectId.indexOf(':')>0) {
                                    var splittedIdArr = curSelectedObjectId.split(':');
                                    try {
                                        var curDivTabContent = $('#divTabContent_'+localId+'_0'); //Всегда берем параметры экспорта (excelTemplate и ext_data_id) из первой вкладки
                                        //Пытаемся получить нужные для экспорта данные
                                        var fileName = App.generateUUID() + ".xls";
                                        //Если вызов экспорта одиночной записи - при отсутствии templatename подставляем template='export'
                                        var excelTemplate = curDivTabContent.length>0 && curDivTabContent.data('excelTemplate')!=undefined ? curDivTabContent.data('excelTemplate') : splittedIdArr[0];
                                        var extDataId = curDivTabContent.length>0 && curDivTabContent.data('ext_data_id')!=undefined ? curDivTabContent.data('ext_data_id') : '';
                                        //Если у нас осуществляется просто экспорт (без ext_data_id) формируем объект данных в виде datafield:value
                                        var newDataObj = methods.getCurrentFormObject('frm_'+localId+'_0');
                                        if (extDataId=='') {
                                            ExportUtil.exportToExcel([newDataObj], fileName, excelTemplate, 'export');
                                        } else {
                                            ExportUtil.exportToExcel([newDataObj], fileName, excelTemplate, extDataId);
                                        }
                                    } catch (e) {
                                        App.errorReport(gis_ppanel_19, gis_ppanel_14 + e.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_7'});
                                    }
                                }
                            } catch (err) {
                                //Ничего не делаем, возможно панель закрыта
                            }
                        }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    }

                    break;
                case 'BackEvent':
                    if($('#btnLeftPBack_'+params.localId).length > 0)
                        $('#btnLeftPBack_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPBack_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelBack"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPBack_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            if(options.handlers.previousCallback != undefined)options.handlers.previousCallback();
                            if (pPanelSelectedObjectsHistory.lastSelectedIndex > 0 && pPanelSelectedObjectsHistory.historyArray.length > 0) {
                                var curSelectedObject = pPanelSelectedObjectsHistory.historyArray[pPanelSelectedObjectsHistory.lastSelectedIndex - 1];
                                curSelectedObject.options.coords = options.coords;
                                curSelectedObject.options.opener = options.opener; //обязательно меняем opener, чтобы панель переоткрылась в текущем родителе
                                curSelectedObject.divProperties = el; //обязательно меняем divProperties, чтобы панель переоткрылась в текущем родителе
                                //Уменьшаем индекс последнего выбранного элемента
                                pPanelSelectedObjectsHistory.lastSelectedIndex--;
                                //Открываем панель свойств для выбранного элемента
                                methods.openObjectInNewPanel(curSelectedObject);

                                var selectedObject = options.objects[options.curObject].id;
                                var unique = options.objects[options.curObject].uniqueLayerName || undefined;
                                if (selectedObject) {
                                    //СИНХРОНИЗАЦИЯ #O6
                                    App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                                }
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
                case 'ForwardEvent':
                    if($('#btnLeftPForward_'+params.localId).length > 0)
                        $('#btnLeftPForward_'+params.localId).remove();
                    buttonTemplate = '<div id="btnLeftPForward_'+params.localId+'" class="btnLeftPanel"><div style="'+background+'"  class="btnLeftPanelIcon btnLeftPanelForward"></div></div>';
                    $('#divLeftPanel_'+params.localId).append(buttonTemplate);
                    $('#btnLeftPForward_'+params.localId).jqxButton({theme:'myCommon'}).on('click',function(){
                        try {
                            if(options.handlers.nextCallback != undefined)options.handlers.nextCallback();
                            if (pPanelSelectedObjectsHistory.lastSelectedIndex >= 0 && pPanelSelectedObjectsHistory.historyArray.length > 0 && pPanelSelectedObjectsHistory.lastSelectedIndex + 1 < pPanelSelectedObjectsHistory.historyArray.length) {
                                var curSelectedObject = pPanelSelectedObjectsHistory.historyArray[pPanelSelectedObjectsHistory.lastSelectedIndex + 1];
                                curSelectedObject.options.coords = options.coords;
                                curSelectedObject.options.opener = options.opener; //обязательно меняем opener, чтобы панель переоткрылась в текущем родителе
                                curSelectedObject.divProperties = el; //обязательно меняем divProperties, чтобы панель переоткрылась в текущем родителе
                                //Уменьшаем индекс последнего выбранного элемента
                                pPanelSelectedObjectsHistory.lastSelectedIndex++;
                                //Открываем панель свойств для выбранного элемента
                                methods.openObjectInNewPanel(curSelectedObject);
                                var selectedObject = options.objects[options.curObject].id;
                                var unique = options.objects[options.curObject].uniqueLayerName || undefined;
                                if (selectedObject) {
                                    //СИНХРОНИЗАЦИЯ #P6
                                    App.syncManager.callSync(selectedObject, 'ppanel', unique, SyncTypes.TYPE_2);
                                }
                            }
                        } catch (err) {
                            //Ничего не делаем, возможно панель закрыта
                        }
                    }).attr('title',tooltip);//.jqxTooltip({content:tooltip});
                    break;
            }
        },
        setCommentDocGridBtnDisabled:function(params, btnDisabled){
            try {
                //Для комментариев
                $("button[id^='btnDeleteComment_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
                $("button[id^='btnEditComment_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
                //Для документов
                $("button[id^='btnOpenDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
                $("button[id^='btnDeleteDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
                $("button[id^='btnEditDoc_"+params.localId+"_']").each(function(){$(this).jqxButton({disabled: btnDisabled});});
            } catch(e) {}
        },
        checkEditable:function(xmlElement, params){
            //установка всем контролам editable и enabled в true при создании объекта
            var isNewObject = (params!=undefined && params.options != undefined && params.options.objects != undefined &&
                params.options.objects.length > 0 && params.options.objects[0].id != undefined &&
                params.options.objects[0].id.indexOf(':') == -1)?true:false;
            var addClass = '',
                editable = xmlElement.attr('editable'),
                enabled = true; /*xmlElement.attr('enabled');*/
            if(isNewObject)editable = 'true';
            if((editable!=undefined && editable=='false') || (enabled!=undefined && enabled=='false'))addClass = 'noEditable';
            if (params.options.editSystemInfo==true) addClass=''; //Админ может редактировать любые поля
            if(params.tableReadOnly)//если сама форма readOnly
                addClass = 'noEditable';
            if(params.enabledCombo === 'false')//если сама форма readOnly
                addClass = 'noEditable';
            return addClass;
        },
        getIdControl:function(params){
            return params.xmlElement.attr('id')+'_'+params.params.localId+'_'+params.params.selectedIndex;
        },
        appendFormElement:function(params){
            try {
                if(params.params.parentClass == 'pPanelTableCell')
                    params.params.div.append(methods.tabelCellElement({element:params.element,xmlElement:params.xmlElement}))
                        .append('<div class="pPanelTableCell pPanelTableCellRight">&nbsp;</div>');
                else {
                    methods.setStyleElement({xmlElement:params.xmlElement,element:params.element});
                    params.params.div.append(params.element);
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
                //console.err(err);
            }
        },
        tabelCellElement: function(params){
            try {
                var tableCell = $('<div class="pPanelTableCell"></div>');
                methods.setStyleElement({xmlElement:params.xmlElement,element:tableCell});
                tableCell.append(params.element);
                return tableCell;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setValidateElement:function(params){
            try {
                $.each(params.xmlElement.attributes,function(){
                    var value = this.value;
                    switch(this.name) {
                        case 'maxChars':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: gis_ppanel_52,
                                action: 'none',
                                rule: 'maxLength=' + this.value,
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'minLength':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('tooShortError'),
                                action: 'none',
                                rule: 'minLength='+this.value,
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'requiredFieldError':
                            /*case 'required':*/
                            if(params.xmlElement.getAttribute('required')!='false'){
                                var controlType = $('#'+params.idElement).data('typecontrol');
                                //Для контрола ввода файла отдельное правило - проверяем текст внутреннего div'а
                                if (controlType=='inputfile') {
                                    params.params.rules.push({
                                        input: '#'+params.idElement,
                                        message: params.xmlElement.getAttribute('requiredFieldError'),
                                        action: 'none',
                                        rule: function(){
                                            try {
                                                var curFileNameText = $('#'+params.idElement).parent().find('.divFileInputNameText').val();
                                                return curFileNameText!='';
                                            } catch (e) {
                                                return false;
                                            }
                                        }
                                    });
                                } else
                                if (controlType=='date') {
                                    /* отдельно проверяем поля даты, т.к. в них контрол input завернут в div */
                                    params.params.rules.push({
                                        input: '#'+params.idElement,
                                        message: params.xmlElement.getAttribute('requiredFieldError'),
                                        action: 'none',
                                        rule: function(){
                                            try {
                                                var control = $('#'+params.idElement);
                                                var inputControlValue = $('input.date', control).val();
                                                return inputControlValue!=null && inputControlValue!='';
                                            } catch (e) {
                                                return false;
                                            }
                                        }
                                    });
                                } else {
                                    params.params.rules.push({
                                        input: '#'+params.idElement,
                                        message: params.xmlElement.getAttribute('requiredFieldError'),
                                        action: 'none',
                                        rule: 'required',
                                        hintRender:function(message, input){
                                            if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                        }
                                    });
                                }
                            }
                            break;
                        case 'requiredcombo':
                            params.params.rules.push({
                                input: '#'+params.idElement+' input',
                                message: params.xmlElement.getAttribute('notDefaultError'),
                                action: 'none',
                                rule: function(){
                                    var index = $('#'+params.idElement).jqxComboBox('getSelectedIndex');
                                    if(index !== -1){
                                        var item = $('#'+params.idElement).jqxComboBox('getSelectedItem');
                                        if(item !== undefined && item.originalItem !== undefined){
                                            if(item.originalItem.CODE === '0' || item.originalItem.CODE === 'UNKNOWN'){
                                                index = -1;
                                            }
                                        }
                                    }
                                    return index != -1;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'comparisonError':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('comparisonError'),
                                action: 'none',
                                rule: function(){
                                    try {
                                        var destinationId = params.xmlElement.getAttribute('destination');
                                        destinationId = destinationId.substring(1, destinationId.length-1)+'_'+params.params.localId+'_'+params.params.selectedIndex;
                                        return $('#'+params.idElement).val()==$('#'+destinationId).val();
                                    } catch (err) {}
                                    return false;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'allowNegative':
                            if(this.value == 'false')
                                params.params.rules.push({
                                    input: '#'+params.idElement,
                                    message: params.xmlElement.getAttribute('negativeError'),
                                    action: 'none',
                                    rule: function(){
                                        var val = $('#'+params.idElement).val();
                                        if(val != '')return /^[+]?\d*(\.\d+)?$/.test(val);
                                        else return true;
                                    },
                                    hintRender:function(message, input){
                                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                    }
                                });
                            break;
                        case 'precision':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('precisionError'),
                                action: 'none',
                                rule: function(){
                                    var val = $('#'+params.idElement).val().toString().split('.');
                                    if(val.length >1)return val[1].length <= value;
                                    else return true;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'maxValue':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('exceedsMaxError'),
                                action: 'none',
                                rule: function(){
                                    var val = $('#'+params.idElement).val();
                                    if(val.length >1)return parseFloat(val) <= parseFloat(value);
                                    else return true;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'minValue':
                            params.params.rules.push({
                                input: '#'+params.idElement,
                                message: params.xmlElement.getAttribute('lowerThanMinError'),
                                action: 'none',
                                rule: function(){
                                    var val = $('#'+params.idElement).val();
                                    if(val.length >1)return parseFloat(val) >= parseFloat(value);
                                    else return true;
                                },
                                hintRender:function(message, input){
                                    if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                }
                            });
                            break;
                        case 'notAllowedValues':
                            if($('#'+params.idElement).data('typecontrol') == 'combobox')
                                params.params.rules.push({
                                    input: '#'+params.idElement+' input',
                                    message: params.xmlElement.getAttribute('notAllowedError'),
                                    action: 'none',
                                    rule: function(){
                                        var val = $('#'+params.idElement).val(),
                                            values = value.split(',');
                                        for(var i = 0;i<values.length;i++)
                                            if(values[i]== val)return false;
                                        return true;
                                    },
                                    hintRender:function(message, input){
                                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                    }
                                });
                            else
                                params.params.rules.push({
                                    input: '#'+params.idElement,
                                    message: params.xmlElement.getAttribute('notAllowedError'),
                                    action: 'none',
                                    rule: function(){
                                        var val = $('#'+params.idElement).val(),
                                            values = value.split(',');
                                        for(var i = 0;i<values.length;i++)
                                            if(values[i]== val)return false;
                                        return true;
                                    },
                                    hintRender:function(message, input){
                                        if (input.length > 0) $(input[0]).data('validateErrorText',message);
                                    }
                                });
                            break;
                        case 'defaultValue':
                        case 'text':
                            var control = $('#'+params.idElement);
                            switch(control.data('typecontrol')) {
                                case 'input':if(control.data('loadvalue') == false)control.val(value);break;
                                case 'numberinput':if(control.data('loadvalue') == false)control.val(value);break;
                                case 'checkbox':if((control.data('loadvalue') == false)&&(this.value == 'Y'))control.jqxCheckBox('check');break;
                                case 'date':
                                    if(control.data('loadvalue') == false) {
                                        var input = $('input.date', control);
                                        var date;
                                        if(value == 'new Date()') {
                                            value = new Date();
                                            value = value.format('dd.mm.yyyy');
                                            input.val(value);
                                        } else {
                                            input.val(value);
                                        }
                                    }
                                    break;
                                case 'combobox':
                                    if(control.data('loadvalue') == false)
                                        control.data('value',value);
                                    else control.jqxComboBox('val',value);
                                    break;
                            }
                            break;
                    }
                });
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setStyleElement:function(params){
            try {
                $.each(params.xmlElement.attributes,function(){
                    switch(this.name)
                    {
                        case 'width':params.element.css('width',this.value+'px');break;
                        case 'percentWidth':if(this.value != '100')params.element.css('width',this.value+'%');break;
                        case 'textAlign':params.element.addClass(this.value+'TextAlign');break;
                    }
                });
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setComboBoxDataProvider:function(comboDataProv, params){
            if(params.comboBox==undefined || $('#'+params.comboBox.attr('id')).length == 0)return;
            var data = (params.options && params.options.data)? params.options.data: null;
            var selectedIndex = -1;
            var selectedValue = params.comboBox.data('selectedvalue') || null;
            var disabledCombo = params.comboBox.hasClass('noEditable');
            var comboDataValue = params.comboBox!=undefined && params.comboBox.data('value');
            //var comboId = params.comboBox.attr('id').substring(0, params.comboBox.attr('id').indexOf('_'+params.localId));
            //пробуем найти из data
            if(!comboDataValue && selectedValue){
                if (data && data[selectedValue])
                    comboDataValue = data[selectedValue];
            }
            var comboDataValueField = params.comboBox.jqxComboBox('valueMember');
            for (var i=0; i<comboDataProv.length; i++) {
                var curObj = comboDataProv[i];
                //Сразу ищем элемент, данные уже есть
                var val = curObj[comboDataValueField];
                if (comboDataValue!=undefined && val==comboDataValue) selectedIndex = i;
            }
            //проверяем, если есть атрибут defaultSelectedIndex и не выбран уже selectedIndex, то выбираем его
            var defaultSelectedIndex = params.comboBox.attr('defaultselectedindex')? parseInt(params.comboBox.attr('defaultselectedindex')):-1;
            if(selectedIndex == -1 && defaultSelectedIndex < comboDataProv.length){
                selectedIndex = defaultSelectedIndex;
            }
            if(defaultSelectedIndex !== -1)
                params.readonly = true;

            params.comboBox.removeClass('noListValues');
            var autoDropDownHeight = comboDataProv.length<=5 ? true : false; //При наличии в списках 5 и менее элементов нужно dropdown сжимать по их количеству
            //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
            if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1 && params.comboBox.jqxComboBox('placeHolder')=='') selectedIndex = 0;
            if(params.comboBox.data('value') != undefined) {
                params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo,selectedIndex:selectedIndex,autoDropDownHeight:autoDropDownHeight, autoComplete: true});
                params.comboBox.data('loadvalue',true);
            } else {
                if(defaultSelectedIndex === -1)
                    disabledCombo = params.divProperties.data('unlockCombo')!=1;
                params.comboBox.jqxComboBox({source:comboDataProv,disabled:disabledCombo,selectedIndex:selectedIndex,autoDropDownHeight:autoDropDownHeight, autoComplete: true});
                params.comboBox.data('loadvalue',true);
            }
            if(!params.readonly)
                params.comboBox.jqxComboBox({disabled:false});
        },
        parseTabValues:function(xmlElement,params, isMainSelect){
            try {
                switch(xmlElement[0].tagName) {
                    case 'string':
                        xmlElement.children().each(function(){methods.parseTabValues($(this),params);});
                        break;
                    case 'result':
                    case 'root':
                        if(params.loadObject != params.options.curObject)return;
                        //если ничего не нашло и запрос - основной по заполнению вкладки, то выставляем флаг для вкладки insert
                        if(xmlElement.children().length == 0 && isMainSelect === true){
                            if(params && params.options)
                                params.options.requestType = 'insert';
                        }
                        //TODO хардкод. т.к. в панели запрос на сохранение не совпадает со вкладкой паспорт
                        if(xmlElement.children().length == 0 && params && params.options && params.idRequest === 'PODS_STO_ILI_INSPECTION_SHEET'){
                            params.options.requestType = 'insert';
                        }
                        xmlElement.children().each(function(){methods.parseTabValues($(this),params);});
                        methods.unlockFormControls(params);
                        //Меняем тип скрипта - если уже запросили данные, будет UPDATE
                        $('#frm_'+params.localId+'_'+params.selectedIndex).data('scriptType','UPDATE');
                        //Ставим фокус на первое поле
                        var formFirstTabIndex = (params.selectedIndex + 1)*100 + 1;
                        $('#frm_'+params.localId+'_'+params.selectedIndex+' [tabindex="'+formFirstTabIndex+'"]').focus();
                        //И только в самом конце, после свойств объекта запрашиваем данные комбобоксов
                        $('#divTabContent_'+params.localId+'_'+params.selectedIndex).find('[data-typecontrol="combobox"]').each(function (){
                            var element = $(this);
                            if(element.attr('dataProvider') != undefined) {
                                var comboDataProvider = new QueryDataProvider({
                                    requestSource: element.attr('dataProvider'),
                                    dataField: element.jqxComboBox('valueMember'),
                                    labelField: element.jqxComboBox('displayMember'),
                                    resultHandler: function(){
                                        methods.setComboBoxDataProvider(this,{readonly:params.tableReadOnly == true,comboBox:element,divProperties:params.divProperties,localId:params.localId, options: params.options});
                                    }
                                });
                            }
                        });
                        break;
                    case 'data':
                        $.each(xmlElement[0].attributes,function(){
                            var control = $('#'+this.name+'_'+params.localId+'_'+params.selectedIndex);
                            if(control.length != 0) {
                                if(control.hasClass('noListValues')) {
                                    control.data('value', this.value);
                                    control.data('orig-value', this.value);
                                }
                                else methods.setControlValue(control,this);
                            } else
                                $('#frm_'+params.localId+'_'+params.selectedIndex).append(
                                    '<input id="'+this.name+'_'+params.localId+'_'+params.selectedIndex+'" type="hidden" value="'+this.value.xmlEscape()+'" data-typecontrol="input" class="formControl" data-loadvalue=true />');
                        });
                        //!!закомментировал это место, потому что для объектов типа cosmetic, уходило в цикл бесконечный всё
                        /*if(xmlElement[0].attributes.length == 1)
            {
             params.options.objects[params.options.curObject].id=params.options.objects[params.options.curObject].id+':'+xmlElement[0].attributes[0].value;
             methods.showPanelObject(params);
            }*/
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setControlValue:function(control,data){
            try {
                var dataValue = data.value.replace(new RegExp("&quot;","g"),'"'); //Заменяем кавычки
                switch(control.data('typecontrol')) {
                    case 'label': control.html(dataValue); break;
                    case 'input':
                        if(WidgetMap && WidgetMap.COORD_FIELDS && WidgetMap.coordMode === WidgetMap.COORD_MODES.GRAD && WidgetMap.COORD_FIELDS.indexOf(control.data('fieldname')) !== -1){
                            var gradCoord = GeoUtil.convertDecimalIntoDegree(dataValue);
                            control.val(gradCoord);
                        }
                        else
                            control.val(dataValue);
                        control.data('loadvalue',true);
                        break;
                    case 'numberinput': control.val(dataValue); control.data('loadvalue',true); break;
                    case 'checkbox':
                        if (dataValue == 'Y' || dataValue == '1') {
                            control.jqxCheckBox('check');
                            control.data('loadvalue', true);
                        }
                        break;
                    case 'combobox':
                        //Если у нас уже есть провайдер комбобокса (например dataProvider задан прямо в форме) - устанавливаем значение
                        var comboDataProv = control.jqxComboBox('source');
                        if (comboDataProv && comboDataProv.length > 0) {
                            var selectedIndex = -1;
                            var comboValueMember = control.jqxComboBox('valueMember');
                            for (var i = 0; i < comboDataProv.length; i++) {
                                if (comboDataProv[i][comboValueMember]==dataValue) {
                                    selectedIndex = i;
                                    break;
                                }
                            }
                            //Выбираем в качестве значения по-умолчанию первое в списке, если список не пустой (как правило это значение "Не определено" или "Не выбрано", т.е. дефолтное)
                            if (comboDataProv && comboDataProv.length>0 && selectedIndex==-1 && control.jqxComboBox('placeHolder')=='') selectedIndex = 0;
                            //Если не нашли такого значения в провайдере - ставим selectedIndex==-1, т.е. ничего не выбрано
                            control.jqxComboBox({selectedIndex: selectedIndex});
                        } else {
                            //иначе данные для комбобоксов получаем после данных формы, поэтому включаем в атрибут value пришедшее из запроса значение (оно будет искаться после запроса комбобокса там)
                            control.data('value',dataValue);
                        }
                        control.data('loadvalue',true);
                        break;
                    case 'date':
                        dataValue =  dataValue.split('+')[0];
                        var input = $('input.date', control);
                        var formatString = (control.data('format'))? control.data('format').toLowerCase(): 'dd.mm.yyyy';
                        var date;
                        if(dataValue.indexOf('T')!=-1){
                            dataValue = dataValue.substring(0,dataValue.indexOf('T'));
                            date = new Date(dataValue);
                        }
                        else{
                            //пробуем распарсить
                          var dateArr = /^(\d{1,2})\.(\d{1,2})\.(\d{4})/.exec(dataValue);//DD.MM.YYYY
                          if(dateArr !== null)
                                    date = new Date(dateArr[3], dateArr[2]-1,dateArr[1])
                          else{
                              //upd. 03.11.21 проверка случая в задаче су тс тпа, когда из sqlite проходит значение даты вместо NULL значение 0
                              if(dataValue !== '0'){
                                  date = new Date(Number(dataValue));
                              }
                              else {
                                  date = null;
                              }
                              //доп. устанавливаем свойство у контрола, что дата пришла в миллисекундах
                              input.data('type','bigint');
                          }
                      }
                      if(date)
                        date = date.format(formatString);
                        input.val(date);
                        control.data('lodateadvalue',true);
                        break;
                    case 'inputfile':
                        control.val(dataValue);
                        $('#divFI_'+control.attr('id')+' .divFileInputNameText').val(dataValue);
                        control.data('loadvalue',true);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        checkSave: function(params, syncMap){
            try {
                //убираем из выборки флаг frmChanged
                var frmChanged = '.frmChanged';
                var listForms = $('#divContent_'+params.localId+' .frmPanelTab'+frmChanged);
                if(params.options.target == 'moveGeometry' || params.options.target == 'editGeometry'){
                    params.options.target = undefined;
                    frmChanged = '';
                    var passportItem = $('#divContent_'+params.localId+' .frmPanelTab').first();
                    //оставляем 1-й форму в любом случае паспорт, для сохранения семантики и далее геометрии.
                    //и к паспорту добавляем остальные, которые реально редактировались
                    if(passportItem.length !== 0){
                        listForms = $.merge(listForms, passportItem);
                    }
                }

                var count = listForms.length;
                if (count != 0) {// Убрал проверку на колво измененных элементов, чтобы сохранялось, как во флеше, если ничего не менялось
                    for (var i = 0;i<count;i++) {
                        var fullErrorText = '';
                        var curForm = $(listForms[i]);
                        var labelElements = curForm.find('.pPanelTableRow div.rightTextAlign:first-child span[data-typecontrol="label"]');
                        //Получаем комбобоксы и проверяем, выбрано ли в них значение, иначе в БД может передаваться подстрока из поля поиска в списке.
                        curForm.find('[data-typecontrol="combobox"]').each(function(){
                            var selectedIndex = $(this).jqxComboBox('getSelectedIndex');
                            if (selectedIndex==-1) {
                                var labelText = '';
                                for (var j=0; j<labelElements.length; j++) {
                                    var curLabelElem = $(labelElements[j]);
                                    var findComboInLabels = curLabelElem.parent().parent().find('[id="'+this.id+'"]');
                                    if (findComboInLabels.length>0) {
                                        labelText = "'"+curLabelElem.text() + "' ";
                                        break;
                                    }
                                }
                                fullErrorText += gis_ppanel_53+labelText+gis_ppanel_54 + '<br/>';
                            }
                        });
                        if (fullErrorText!='') {
                            var alertForm = new AlertForm();
                            alertForm.build('pPanel_'+params.localId+'_AlertForm', fullErrorText+gis_ppanel_55 , gis_ppanel_27, AlertForm.OK);
                            return true;
                        }
                        //Получаем все поля дат и проверяем их валидность - иначе в БД будет передаваться некорректная строка, что удалит имеющуюся дату
                        //Корректными считаем только даты в формате dd.mm.yyyy или yyyy, даты вида 1.1.2012 считаем некорректными
                        fullErrorText = '';
                        curForm.find('[data-typecontrol="date"]').each(function(){
                            var input = $('input.date', $(this));
                            var value = input.val();
                            //Если ввели только год
                            if (value.length==4 && value.indexOf('.')==-1) value = '01.01.'+value;
                            //Затем проверяем, что формат даты правильный (точки и цифры на своих местах)
                            if (!(value.length==0 || (value.length==10 && value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/)))) {
                                fullErrorText = gis_ppanel_56;
                            }
                        });
                        if (fullErrorText!='') {
                            var alertForm = new AlertForm();
                            alertForm.build('pPanel_'+params.localId+'_AlertForm', fullErrorText+gis_ppanel_57, gis_ppanel_27, AlertForm.OK);
                            return true;
                        }
                        if(!params.options.skipValidation ){
                            //Затем запускаем валидатор
                            try{
                                if (curForm.jqxValidator('validate')==false) {
                                    $('#divTabs_'+params.localId).jqxTabs('select',i);
                                    curForm.jqxValidator('hide'); //Сразу прячем (при этом они останутся в DOM и мы сможем получить их текст)*/
                                    return true;
                                }
                            }
                            catch(e){
                                //console.log('d');
                            }
                        }
                    }
                    //Показываем подтверждение сохранения
                    var alertForm = new AlertForm();
                    //Меняем текст кнопок на "Да" и "Нет"
                    alertForm.alertOkButtonText = gis_ppanel_6;
                    alertForm.alertCancelButtonText = gis_ppanel_7;
                    alertForm.width = 330;
                    if (params.options.objects[params.options.curObject].flag === 'import')
                        alertForm.build("pPanel_"+params.localId+"_AlertForm",gis_ppanel_67,gis_alertform_1);
                    else
                        alertForm.build("pPanel_"+params.localId+"_AlertForm",gis_ppanel_28,gis_ppanel_29);
                    //Добавляем слушатель закрытия формы
                    $("body").on(CloseEvent.CLOSE, function pPanelConfirmSaveDialog(evt/*CloseEvent*/) {
                        $("body").off(CloseEvent.CLOSE);
                        var indexForm = 0;
                        var shurfArray = [];
                        for (var j=0; j<count; j++) {
                            //прохой фикс, но в связи с отказов в дальшейшем от панелей
                            //индекс формы забираем из id frm_123dc34_4
                            try{
                                indexForm = parseInt(listForms[j].id.replace('frm_','').split('_')[1]);
                            }
                            catch(ex){}
                            var reqId = $($('#ulTabs_'+params.localId).children()[indexForm]).data('source');
                            //TODO переработать. Если встрачаем вкладку excavate или repair, то сохраняем по другой схеме
                            //заношу в общий массив панели шурфовок, который надо сохранять через ведомсоти
                            if(reqId === "PODS_STO_SHEET_REPAIR_LIST" || reqId === "PODS_STO_SHEET_EXCAVATE_LIST"){
                                shurfArray.push($.extend(params,{indexForm:indexForm,saveMethod:'saveTabForm', syncMap:syncMap}));
                                methods.saveShurfTabForm(shurfArray);

                            }
                            else
                            if (evt && evt.detail==1){
                                if (params.options.objects[params.options.curObject].flag === 'import'){
                                    var serializedForm = methods.serializeForm('frm_'+params.localId+'_'+indexForm, true);
                                    if(params.options.handlers.applyCallback)
                                        params.options.handlers.applyCallback(serializedForm)
                                    methods.destroyPanel(params);
                                    /*var frm = $('#frm_'+params.localId+'_'+indexForm),
                                        prm = params.options.objects[params.options.curObject].id.split(':'),
                                        db= prm[0].split('_'),
                                        db_schema = db[0],
                                        db_table_id = db.slice(1).join('_'),
                                        descrType = 'insert';
                                    var dataProvider = frm.data('dataProvider')+'#'+reqId;
                                    return params.options.handlers.applyCallback({
                                        requestParams: {
                                            descrId:dataProvider,
                                            descrType:descrType,
                                            data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">' +
                                                '<data FILTER="ID='+prm[1]+
                                                '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                                '" DB_SCHEMA_ID="'+db_schema+
                                                '" DB_TABLE_ID="'+db_table_id+
                                                '" SYS_CLASS_ID="'+prm[0]+
                                                '" SYS_OBJ_ID="'+prm[1]+'" '
                                        },
                                        thisObject: $.extend(params,{loadObject:params.options.curObject}),
                                        layerName: reqId,
                                        attrObj: serializedForm
                                    });*/
                                }
                                else
                                    methods.saveFormNew($.extend(params,{indexForm:indexForm,saveMethod:'saveTabForm', syncMap:syncMap}));
                            }
                            $(listForms[j]).removeClass('frmChanged');
                        }
                        if(shurfArray.length > 0){
                            methods.saveShurfTabForm(shurfArray);
                        }
                        params.checkSave = false;
                    });
                    return false;
                }
                return true;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        getAllFormsObjects:function(localId){ //Получение массива объектов со всех вкладок
            try {
                var resultArray = [];
                var listForms = $('#divContent_'+localId+' .frmPanelTab');
                for(var i = 0; i<listForms.length; i++) {
                    var curObject = methods.getCurrentFormObject('frm_'+localId+'_'+i);
                    if (curObject) resultArray.push(curObject);
                }
                return resultArray;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        getCurrentFormObject:function(frmId){ //Получение объекта со свойствами из одной вкладки
            try {
                var dataObj = {};
                $('#'+frmId+' .formControl').each(function(){
                    var el = $(this),
                        value = '',
                        id = this.id.split('_');
                    id.splice(id.length-2,2);
                    switch(el.data('typecontrol'))
                    {
                        case 'input':value=el.val();break;
                        case 'numberinput':value=el.val();break;
               case 'checkbox':
                   var yVal = 'Y', nVal = 'N';
                   if(el.data('typevalue') === 'number'){
                       yVal = '1';
                       nVal = '0';
                   }
                   if(el.jqxCheckBox('checked'))value=yVal;else value=nVal;
                   break;
               case 'combobox':
                   if(el.jqxComboBox('selectedIndex') == -1){
                            if(el.data('loadvalue')== true)value='NULL';
                            else id = undefined;
                        }
                        else value=el.jqxComboBox('val');
                            break;
                        case 'date':
                            var input = $('input.date', el);
                            var value = input.val();
                            if(value == null || value=='') id = undefined;
                            else {
                                //Если ввели только год
                                if (value.length==4 && value.indexOf('.')==-1) value = '01.01.'+value;
                                //Затем проверяем, что формат даты правильный (точки и цифры на своих местах)
                                if (value.length!=10 || !value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/)) {
                                    id = undefined;
                                }
                                /*else value = value.getDate()+'.'+(value.getMonth()+1)+'.'+value.getFullYear();*/
                            }
                            break;
                        case 'file':value=el.data('filename');
                            break;
                        case 'inputfile':value=el.prop('value');//Это для получения значения из контрола выбора файла
                            break;
                    }
                    if(id != undefined)
                        dataObj[id.join('_')] = value;
                });
                return dataObj;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        serializeForm: function (frmId, toObject) {
            try {
                var serializedData = toObject ? {} : '';
                var scriptType = $('#' + frmId).data('scriptType');
                $('#' + frmId + ' .formControl').each(function () {
                    var el = $(this),
                        value = '',
                        id = this.id.split('_');
                    id.splice(id.length - 2, 2);
                    switch (el.data('typecontrol')) {
                        case 'input':
                            value = el.val();
                            if (el.attr('type') == 'password') value = CryptoJS.MD5(value).toString();
                            break;
                        case 'numberinput':
                            value = el.val();
                            break;
                        case 'checkbox':
                            var yVal = 'Y', nVal = 'N';
                            if (el.data('typevalue') === 'number') {
                                yVal = '1';
                                nVal = '0';
                            }
                            if (el.jqxCheckBox('checked')) value = yVal; else value = nVal;
                            break;
                        case 'combobox':
                            if (el.jqxComboBox('selectedIndex') == -1) {
                                if (el.data('loadvalue') == true) value = 'NULL';
                                else id = undefined;
                            } else {
                                //TODO добавить проверку на el.data('orig-value')
                                value = el.jqxComboBox('val');
                            }
                            break;
                        case 'date':
                            var input = $('input.date', el);
                            var value = input.val();
                            var isBigint = input.data('type') === 'bigint';
                            if (value == null || value == '') id = undefined;
                            else {
                                //Если ввели только год
                                if (value.length == 4 && value.indexOf('.') == -1) value = '01.01.' + value;
                                //Затем проверяем, что формат даты правильный (точки и цифры на своих местах)
                                if (value.length != 10 || !value.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})$/)) {
                                    id = undefined;
                                }

                                if (isBigint) {
                                    value = input.datepicker('getDate').getTime();
                                }
                            }
                            break;
                        case 'file':
                            value = el.data('filename');
                            break;
                        case 'inputfile':
                            value = el.prop('value');//Это для получения значения из контрола выбора файла
                            break;
                    }
                    value = methods.convertToString(value, scriptType);
                    if (id != undefined && value != "NULL") {
                        if (toObject)
                            serializedData[id.join('_')] = value;
                        else
                            serializedData += ' ' + id.join('_') + '="' + value + '"';
                    }
                });
                return serializedData;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        convertToString:function(val, scriptType){
            if(val==null)
                return "NULL";
            var res = val.toString().xmlEscape(); //Заменяем кавычки
            //Изменил условие возврата NULL - мы можем сохранять пустые поля если скрипт - UPDATE
            if (scriptType=="UPDATE") {
                if(res==gis_ppanel_30)
                    return "NULL";
            } else {
                if(res.length==0 || res==gis_ppanel_30)
                    return "NULL";
            }
            return res;
        },
        saveFormNew:function(params){
            try {
                var waitload = $('#frm_'+params.localId+'_'+params.indexForm).data('waitload');
                if(waitload != 0)
                {
                    $('#frm_'+params.localId+'_'+params.indexForm+' .divFileInput.waitLoad').each(function(){
                        var fileName = $('#'+this.id+' .divFileInputName').val();
                        if($('#'+this.id+' .divFileInputNameText').val()!='');
                        fileName = $('#'+this.id+' .divFileInputNameText').val();
                        var allID = this.id.replace('divFI','');
                        var form = $('#fr'+allID);
                        $('#ifr'+allID).data('checkload',true);
                        if(params.options.handlers.setDataLoadingCallback != undefined)params.options.handlers.setDataLoadingCallback(true);
                        form.attr('action',form.data('action')+'&fileNameGUID='+encodeURI(fileName)).submit();
                    });
                }
                else methods[params.saveMethod](params);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        saveTabForm:function(params){
            try {
                var frm = $('#frm_'+params.localId+'_'+params.indexForm),
                    prm = params.options.objects[params.options.curObject].id.split(':'),
                    db= prm[0].split('_'),
                    db_schema = db[0],
                    db_table_id = db.slice(1).join('_'),
                    descrType = 'update';
                var reqId = $($('#ulTabs_'+params.localId).children()[params.indexForm]).data('source');
                if(params.options.requestType === 'insert' && reqId === 'PODS_STO_ILI_INSPECTION_SHEET'){
                    descrType = params.options.requestType;
                    params.options.requestType = undefined;
                }

                if(prm[1] == undefined) {
                    descrType='insert';
                    prm[1] = '';
                }
                //попытка получения атрибута initialId, чтобы узнать, нужно создавать новую запись или обновлять
                var initialId = undefined;
                try{
                    initialId = $('#divTabContent_'+params.localId+'_'+params.indexForm).data('initialId');
                }
                catch(ex){

                }
                var serializedForm = methods.serializeForm('frm_'+params.localId+'_'+params.indexForm);
                if(serializedForm){
                    if(serializedForm.indexOf(' '+initialId+'="undefined"') !== -1 || serializedForm.indexOf(' '+initialId+'=""') !== -1) {
                        descrType = 'insert';
                        if(initialId === 'ADV_ID'){
                            serializedForm = serializedForm.replace(' '+initialId+'=""', ' '+initialId+'="" ILI_DATA_ID="' + prm[1] + '"');
                        }
                    }
                    else {
                        if(prm[1] !== '')
                            descrType = 'update';
                    }
                }
                //Проходимся по options.data(задача шурфовок) и заменяем параметры в сериализованнй форме
                if(params.options.data)
                    for(var item in params.options.data){
                        //если нашли такой атрибут, то его затираем тем, что пришел в форму изначально
                        if(serializedForm.indexOf(' '+item+'="') !== -1 && params.options.data[item]){
                            serializedForm = serializedForm.replace(' '+item+'="',' '+item+'_old="');
                        }
                        //не нашли, то добавляем как новый атрибут
                        if(params.options.data[item])
                            serializedForm += ' '+item+'="'+params.options.data[item]+'" ';
                    }
                var dataProvider = frm.data('dataProvider')+'#'+reqId;//'STO_SEM.xml';
                if(params.options.handlers.saveCallback){
                    params.options.handlers.saveCallback(serializedForm, dataProvider);
                    return;
                }

                //TODO переработать. Если встрачаем вкладку excavate или repair, то сохраняем по другой схеме
                if(reqId === "PODS_STO_SHEET_REPAIR_LIST" || reqId === "PODS_STO_SHEET_EXCAVATE_LIST"){
                    //methods.saveShurfTabForm(params);
                    return;
                }
                methods.serverQueryNode(Services.processQueryNode,
                    {descrId:dataProvider,
                        descrType:descrType,
                        data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">' +
                            '<data FILTER="ID='+prm[1]+
                            '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                            '" DB_SCHEMA_ID="'+db_schema+
                            '" DB_TABLE_ID="'+db_table_id+
                            '" SYS_CLASS_ID="'+prm[0]+
                            '" SYS_OBJ_ID="'+prm[1]+'" '+serializedForm+' /></root>'},methods.parseTabValues,$.extend(params,{loadObject:params.options.curObject}));
                params.callBack(params);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },//сохранение вкладок по шурфовкам
        saveShurfTabForm:function(shurfArray){
            if(shurfArray.length > 0){
                //забираем форму из массива и проводим по ней все действия. Когда с ней всё сделали, работаем со второй
                var params = shurfArray[0];
                shurfArray.shift();
                try {
                    var frm = $('#frm_'+params.localId+'_'+params.indexForm),
                        prm = params.options.objects[params.options.curObject].id.split(':'),
                        descrType = 'update';
                    if(prm[1] == undefined) {
                        descrType='insert';
                        prm[1] = '';
                    }
                    var serializedForm = methods.serializeForm('frm_'+params.localId+'_'+params.indexForm);

                    var hasSheetId = false
                    //Проходимся по options.data(задача шурфовок) и заменяем параметры в сериализованнй форме
                    if(params.options.data)
                        for(var item in params.options.data){
                            if(item === 'SHEET_ID')
                                hasSheetId = true;
                            //если нашли такой атрибут, то его затираем тем, что пришел в форму изначально
                            if(serializedForm.indexOf(' '+item+'="') != -1){
                                serializedForm = serializedForm.replace(' '+item+'="',' '+item+'_old="');
                            }
                            //не нашли, то добавляем как новый атрибут
                            serializedForm += ' '+item+'="'+params.options.data[item]+'" ';
                        }
                    if(serializedForm.indexOf(' LIST_ID="') != -1)
                        descrType = 'update';
                    else
                        descrType = 'insert';
                    //если нет list_id и есть sheet_id, то insert иначе update
                    var reqId = $($('#ulTabs_'+params.localId).children()[params.indexForm]).data('source');
                    var dataProvider = 'STO_SEM.xml';
                    //TODO переработать. Если встрачаем вкладку excavate или repair, то сохраняем по другой схеме
                    if(reqId === "PODS_STO_SHEET_REPAIR_LIST" || reqId === "PODS_STO_SHEET_EXCAVATE_LIST"){
                        //получаем id дефекта и ищем его sheetId в зависимости от выбранной вкладки
                        //если нет weld_number, то предлагаем его ввести, инача обычное сохранение
                        var iliDataId = prm[1];
                        var iliType = prm[0] === 'PODS_ILI_CLUSTER'?'ILI_CLUSTER_ID':'ILI_DATA_ID';
                        if(serializedForm.indexOf(' '+iliType+'="undefined" ') !== -1){
                            //получаем из prm
                            serializedForm = serializedForm.replace(' '+iliType+'="undefined" ',' '+iliType+'="'+iliDataId+'" ');
                        }
                        if(serializedForm.indexOf(' WELD_NUMBER=') === -1 && hasSheetId){
                            if(params.options.handlers.saveCallback){
                                params.options.handlers.saveCallback(serializedForm);
                                return;
                            }
                        }
                        if(serializedForm.indexOf(' '+iliType+'=""') !== -1 ){
                            serializedForm = serializedForm.replace(' '+iliType+'=""', ' '+iliType+'="'+iliDataId+'"');
                        }

                        var dObj = $.extend(params,{loadObject:params.options.curObject});
                        methods.getSheetId(iliDataId,reqId, function(sheetId, stoEventId, type){
                            if(!sheetId || sheetId === ''){//если не нашли sheetId, то предлагаем сохранить ведомость и после этого сохраняем
                                methods.saveSheet(iliDataId, type, function(sheetId, stoEventId, type){
                                    methods.saveList(sheetId,type, serializedForm,dataProvider+'#'+reqId,descrType,dObj, function(listId){
                                        methods.saveShurfTabForm(shurfArray);//повторяем сохранение след. вкладки
                                    })
                                },dObj);
                            }
                            else
                                methods.saveList(sheetId,type, serializedForm,dataProvider+'#'+reqId,descrType,dObj, function(listId){
                                    methods.saveShurfTabForm(shurfArray);//повторяем сохранение след. вкладки
                                });
                        },dObj);
                    }
                } catch (err) {
                    //Ничего не делаем, возможно панель закрыта
                }
            }
        },//вставка/обновление сведений о шурфовках/ремеонте
        saveList:function(sheetId, type, serializedForm, request,descrType, divObject, callback){
            var listId = 'NULL';
            //ищем LIST_ID
            if(serializedForm.indexOf(' LIST_ID="') != -1){
                var sub = serializedForm.substr(serializedForm.indexOf(' LIST_ID="')+10);
                if(sub !== '')
                    listId = sub.substr(0,sub.indexOf('"'));
            }
            if(serializedForm.indexOf(' SHEET_ID="') != -1){
                serializedForm = serializedForm.replace(' SHEET_ID="',' SHEET_ID_old="');
            }
            serializedForm += '  SHEET_ID="'+sheetId+'"';
            methods.serverQueryNode(Services.processQueryNode,
                {descrId:request, descrType:descrType, getSchema:false, toElements:false,
                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'">' +
                        '<data FILTER="ID='+listId+'" '+
                        serializedForm+' /></root>'},methods.parseTabValues,divObject);
            if(callback)
                callback();
        },
        //сохранение ведомости
        saveSheet:function(iliDataId, type, callback, divObject){
            //сначала получаем идентификатор обследования и межкранового участка
            methods.serverQueryNode(Services.processQueryNode,
                {descrId:'STO_SEM.xml#GET_INSP_EVENT_ID_BY_ILI_DATA_ID', descrType:'select', getSchema:false, toElements:false,
                    data:'<root><data ILI_DATA_ID="'+iliDataId+'" ILI_CLUSTER_ID="'+iliDataId+'"/></root>'},function(resultXml){
                    var er = HTTPServiceUtil.getError(resultXml);
                    if (er != "") {
                        App.errorReport(gis_core_error_1, gis_ppanel_14 + er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_18'});
                        if(callback)
                            callback();
                        return false;
                    } else {
                        var datas = $(resultXml).find('data');
                        if(datas.length > 0){
                            var inspectionId = datas[0].getAttribute('ILI_INSPECTION_ID');
                            var stoEventId = datas[0].getAttribute('STO_ILI_INSP_EVENT_ID');
                            var gridSheetForm = new GridSTOSheetForm({
                                iliDataId:inspectionId,
                                data:{ILI_INSPECTION_ID:inspectionId,STO_ILI_INSP_EVENT_ID:stoEventId},
                                sheetType:type,
                                applyCallback:function(sheetId){
                                    if(callback)
                                        callback(sheetId,stoEventId,type);
                                }
                            });
                            gridSheetForm.buildNewSheet_();
                        }
                        else
                            App.errorReport(gis_ppanel_63, gis_ppanel_64, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_20'});
                    }
                },divObject);
        },
        //получение ведомости по ili_data_id
        getSheetId:function(iliDataId, type, callback, divObject){
            var request = 'GET_EXCAVATE_SHEET_ID_BY_ILI_DATA_ID';
            if(type === "PODS_STO_SHEET_REPAIR_LIST"){
                request = 'GET_REPAIR_SHEET_ID_BY_ILI_DATA_ID';
                type = 'repair';
            }
            else{
                type = 'excavate'
            }
            methods.serverQueryNode(Services.processQueryNode,
                {descrId:'STO_SEM.xml#'+request, descrType:'select', getSchema:false, toElements:false,
                    data:'<root><data ILI_DATA_ID="'+iliDataId+'"  ILI_CLUSTER_ID="'+iliDataId+'" /></root>'},function(resultXml){
                    var er = HTTPServiceUtil.getError(resultXml);
                    var semId = undefined;
                    var stoEventId = undefined;
                    if (er != "") {
                        App.errorReport(gis_core_error_1, gis_ppanel_14 + er, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_17'});
                        return false;
                    } else {
                        var datas = $(resultXml).find('data');
                        if(datas.length > 0){
                            //забираем первый sheetId, как в гриде
                            //semId = datas[0].getAttribute('SHEET_ID');
                            //var stoEventId = datas[0].getAttribute('STO_ILI_INSP_EVENT_ID');
                            semId = datas[datas.length-1].getAttribute('SHEET_ID');
                            stoEventId = datas[datas.length-1].getAttribute('STO_ILI_INSP_EVENT_ID');
                        }
                        if(callback)
                            callback(semId,stoEventId, type);
                    }
                },divObject);
        },
        setTableData:function(data,params){
            try {
                //data = data.replace(/<root/g,"&lt;root").replace(/root>/g,"root&gt;").replace(/<data/g,"&lt;data").replace(/data>/g,"data&gt;");
                var localData = App.convertDataXmlToArray(data, true);
                params.source.localdata = localData;
                var dataAdapter = new $.jqx.dataAdapter(params.source);
                $('#'+params.idTable).jqxGrid({source:dataAdapter});
                //Сразу после обновления блокируем кнопки в гридах комментариев и прикрепленных документов
                methods.setCommentDocGridBtnDisabled(params, true);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        markChange:function(params){
            try {
                if(params.control.data('loadvalue') == true || params.options.creatingNewObject==true) {
                    var selectedIndex = $('#divTabs_'+params.localId).jqxTabs('selectedItem');
                    //var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                    var frm = $('#frm_'+params.localId+'_'+selectedIndex);
                    if(frm.length != 0) {
                        frm.addClass('frmChanged');
                    }
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        unlockFormControls:function(params){
            try {
                $('#divTabContent_'+params.localId+'_'+params.selectedIndex+' .formControl').each(function(){
                    var el = $(this);
                    if(!el.hasClass('noEditable')) {
                        switch(el.data('typecontrol')) {
                            case 'input':
                                var isShurf = (params.idRequest === "PODS_STO_SHEET_EXCAVATE" || params.idRequest === "PODS_STO_SHEET_REPAIR" || params.idRequest === "PODS_STO_SHEET_MTR");
                                if( isShurf && (el.attr('id').indexOf('INSP_DESCRIPTION_'+params.localId+'_') != -1 || el.attr('id').indexOf('INSP_ROUTE_DESCRIPTION_'+params.localId+'_') != -1)){

                                }
                                else
                                    el.jqxInput({disabled:false}); el.data('loadvalue',true);
                                break;
                            case 'numberinput':el.jqxNumberInput({disabled:false}); el.data('loadvalue',true); break;//разблокируем и помечаем как контрол с загруженными данными
                            case 'checkbox':el.jqxCheckBox({disabled:false}); el.data('loadvalue',true); break; //разблокируем и помечаем как контрол с загруженными данными
                            case 'date':
                                el.data('loadvalue',true);
                                break; //разблокируем и помечаем как контрол с загруженными данными
                            case 'combobox':
                                if(!el.hasClass('noListValues')) {
                                    //комбобокс разблокируем и помечаем как контрол с загруженными данными только если в него загружены значения (нет класса noListValues)
                                    //el.data('loadvalue',true);
                                    //el.jqxComboBox({disabled:false});
                                }
                                break;
                        }
                    }
                });
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        getDivContent:function(params){
            try {
                var divContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
                switch(params.idRequest)
                {
                    case 'SYS_COMMENT_LIST':
                        divContent.css('overflow','hidden'); //Добавляем, чтобы скроллов не было видно
                        divContent.append('<div class="pPanelTable width100" style="height: 100%;">\
                                  <div class="pPanelTableRow" style="height: 100%">\
                                   <div id="divCommentContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTableCell" style="height: 100%"></div>\
                                   <div class="pPanelTableCell leftPanelAddDocs" style="height: 100%;">\
                                    <button id="btnNewComment_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Добавить</button>\
                                    <button id="btnDeleteComment_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton " >Удалить</button>\
                                    <button id="btnEditComment_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Редактировать</button>\
                                   </div>\
                                  </div>\
                                 </div>');
                        divContent = $('#divCommentContent_'+params.localId+'_'+params.selectedIndex);
                        $('#btnNewComment_'+params.localId+'_'+params.selectedIndex).jqxButton().on('click',function(){
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {descrId:'SYS_PROP.xml#PROP_LIST',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="PODS_COMMENTS"/></root>'},methods.parseCommentFormDescribe,$.extend(params,{divContent:divContent,action:'insert',idRequest:'CommentForm',idComment:''}));
                        });
                        $('#btnEditComment_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' div[data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {descrId:'SYS_PROP.xml#PROP_LIST',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="PODS_COMMENTS"/></root>'},methods.parseCommentFormDescribe,$.extend(params,{divContent:divContent,action:'update',idRequest:'CommentForm',idComment:$(grid.jqxGrid('source').recordids[selRecord]).attr('COMMENTS_ID')}));
                            //Очищаем выделение в гриде
                            grid.jqxGrid('clearselection');
                        });
                        $('#btnDeleteComment_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' [data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            var alertForm = new AlertForm();
                            alertForm.alertOkButtonText = gis_ppanel_6;
                            alertForm.alertCancelButtonText = gis_ppanel_7;
                            alertForm.build("btnDeleteCommentAlertForm",gis_ppanel_31,gis_ppanel_32);
                            //Добавляем слушатель закрытия формы
                            $("body").on(CloseEvent.CLOSE, function btnDeleteCommentAlertFormClose(evt/*CloseEvent*/) {
                                $("body").off(CloseEvent.CLOSE);
                                if (evt && evt.detail==1) {
                                    var prm = params.options.objects[params.options.curObject].id.split(':'),
                                        db= prm[0].split('_'),
                                        db_schema = db[0],
                                        db_table_id = db.slice(1).join('_');
                                    //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                                    if (params.hasOwnProperty('curSchema') && params.hasOwnProperty('curTable')) {
                                        db_schema = params.curSchema;
                                        db_table_id = params.curTable;
                                    }
                                    methods.serverQueryNode(Services.processQueryNode,
                                        {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENT_LIST',
                                            descrType:'delete',
                                            getSchema:false,
                                            toElements:false,
                                            data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+prm[1]+
                                                '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                                '" DB_SCHEMA_ID="'+db_schema+
                                                '" DB_TABLE_ID="'+db_table_id+
                                                '" SYS_CLASS_ID="'+prm[0]+
                                                '" SYS_OBJ_ID="'+prm[1]+
                                                '" COMMENTS_ID="'+$(grid.jqxGrid('source').recordids[selRecord]).attr('COMMENTS_ID')+'"/></root>'},methods.refreshCommentTable,$.extend(params,{divContent:divContent}));
                                    //Очищаем выделение в гриде
                                    grid.jqxGrid('clearselection');
                                }
                            });
                        });
                        break;
                    case 'SYS_DOCUMENT_LIST':
                        divContent.css('overflow','hidden'); //Добавляем, чтобы скроллов не было видно
                        divContent.append('<div class="pPanelTable width100" style="height: 100%;">\
                                  <div class="pPanelTableRow" style="height: 100%;">\
                                   <div id="divAddDocsContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTableCell" style="height: 100%;">\
                                   </div>\
                                   <div class="pPanelTableCell leftPanelAddDocs" style="height: 100%;">\
                                    <button id="btnOpenDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Открыть</button>\
                                    <button id="btnLoadNewDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Загрузить новый</button>\
                                    <button id="btnDeleteDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Удалить</button>\
                                    <button id="btnEditDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Редактировать</button>\
                                   </div>\
                                  </div>\
                                 </div>');
                        /* Убираем эту кнопку, будет реализовано по-другому: <button id="btnNewDoc_'+params.localId+'_'+params.selectedIndex+'" class="myButton rightPanelButton ">Добавить</button>\ */
                        divContent = $('#divAddDocsContent_'+params.localId+'_'+params.selectedIndex);
                        $('#btnOpenDoc_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' div[data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            var curDocGridSelectedItem = $(grid.jqxGrid('source').recordids[selRecord]);
                            var idDoc = curDocGridSelectedItem.attr('DOC_ID'),
                                prm = params.options.objects[params.options.curObject].id.split(':'),
                                db= prm[0].split('_'),
                                db_schema = db[0],
                                db_table_id = db.slice(1).join('_');
                            methods.serverQueryNode(Services.processQueryNode,
                                {descrId:'SYS_SEM.xml#DOCUMENT_OPEN',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" DOC_ID="'+idDoc+
                                        '" FILTER="ID='+prm[1]+
                                        '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                        '" DB_SCHEMA_ID="'+db_schema+
                                        '" DB_TABLE_ID="'+db_table_id+
                                        '" SYS_CLASS_ID="'+prm[0]+
                                        '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.loadDoc, $.extend(params, {curDocGridSelectedItem:curDocGridSelectedItem}));
                            //Очищаем выделение в гриде
                            grid.jqxGrid('clearselection');
                        });
                        $('#btnLoadNewDoc_'+params.localId+'_'+params.selectedIndex).jqxButton().on('click',function(){
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {descrId:'SYS_PROP.xml#PROP_LIST',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="WEB50_LIB_DOC"/></root>'},methods.parseFormDescribe,$.extend(params,{divContent:divContent,action:'insert',idRequest:'DocForm'}));
                        });
                        $('#btnDeleteDoc_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' [data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            var alertForm = new AlertForm();
                            alertForm.alertOkButtonText = gis_ppanel_6;
                            alertForm.alertCancelButtonText = gis_ppanel_7;
                            alertForm.build("btnDeleteDocAlertForm",gis_ppanel_31,gis_ppanel_32);
                            //Добавляем слушатель закрытия формы
                            $("body").on(CloseEvent.CLOSE, function btnDeleteDocAlertFormClose(evt/*CloseEvent*/) {
                                $("body").off(CloseEvent.CLOSE);
                                if (evt && evt.detail == 1) {
                                    var prm = params.options.objects[params.options.curObject].id.split(':'),
                                        db= prm[0].split('_'),
                                        db_schema = db[0],
                                        db_table_id = db.slice(1).join('_');
                                    methods.serverQueryNode(Services.processQueryNode,
                                        {descrId:'SYS_SEM.xml#DOCUMENT_LIST',
                                            descrType:'delete',
                                            getSchema:false,
                                            toElements:false,
                                            data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+prm[1]+
                                                '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                                '" DB_SCHEMA_ID="'+db_schema+
                                                '" DB_TABLE_ID="'+db_table_id+
                                                '" SYS_CLASS_ID="'+prm[0]+
                                                '" SYS_OBJ_ID="'+prm[1]+
                                                '" GATE_ID="'+$(grid.jqxGrid('source').recordids[selRecord]).attr('GATE_ID')+'"/></root>'},methods.deleteDocFile,$.extend(params,{divContent:divContent}));
                                    //Очищаем выделение в гриде
                                    grid.jqxGrid('clearselection');
                                }
                            });
                        });
                        $('#btnEditDoc_'+params.localId+'_'+params.selectedIndex).jqxButton({disabled:true}).on('click',function(){
                            var grid = $('#'+divContent.attr('id')+' [data-selectscript="'+divContent.data('selectscript')+'"]'),
                                selRecord = grid.jqxGrid('getselectedrowindex');
                            if(selRecord == -1) {
                                App.confirmDialog(gis_ppanel_58);
                                return;
                            }
                            methods.serverQueryNode(Services.processQueryNodeXml,
                                {descrId:'SYS_PROP.xml#PROP_LIST',
                                    descrType:'select',
                                    getSchema:false,
                                    toElements:false,
                                    data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CLASS_NAME="WEB50_LIB_DOC"/></root>'},methods.parseFormDescribe,$.extend(params,{divContent:divContent,action:'update',idRequest:'DocForm',idFile:$(grid.jqxGrid('source').recordids[selRecord]).attr('DOC_ID')}));
                            //Очищаем выделение в гриде
                            grid.jqxGrid('clearselection');
                        });
                        break;
                    case 'DocForm':
                        $('.pPanelModalForm').remove();
                        var docEditFormTitle = params.action=='insert' ? gis_ppanel_59 : '';
                        $('body').append('<div id="divDocForm_'+params.localId+'" class="pPanelModalForm jqx-tabs-content-myCommon">\
                                   <div>\
                                    <form id="frm_'+params.localId+'_'+params.selectedIndex+'" class="frmPanelTab" data-waitload="0">\
                                     <div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'" class="pPanelTabContent"></div>\
                                    </form>\
                                    <div class="divBottomWindow">\
                                     <button id="btnSaveDocForm_'+params.localId+'" class="btnForm myButton">Сохранить</button>\
                                     <button id="btnCancelDocForm_'+params.localId+'" class="btnForm myButton">Отмена</button>\
                                    </div>\
                                   </div>\
                                  </div>');
                        divContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
                        var dlg = $('#divDocForm_'+params.localId).dialog({
                            dialogClass: "jqx-tabs-content-myCommon",
                            title: docEditFormTitle,
                            closeOnEscape: true,
                            width: 340,
                            height: 200,
                            resizable: false,
                            modal: true
                        });
                        $('#btnCancelDocForm_'+params.localId).jqxButton().on('click',function(){dlg.dialog('destroy').remove();});
                        $('#btnSaveDocForm_'+params.localId).jqxButton().on('click',function(){
                            //Проверяем, что поле выбранного файла не пустое
                            var docFileInput = $('#FILE_NAME_'+params.localId+'_'+params.selectedIndex);
                            if (docFileInput.length > 0  && docFileInput.attr('value')!=undefined && docFileInput.attr('value')!='') {
                                $('#btnSaveDocForm_'+params.localId).jqxButton({disabled:true});
                                methods.saveFormNew($.extend(params,{indexForm:params.selectedIndex,callBack:function(){
                                    }}));
                            } else {
                                App.errorReport(gis_ppanel_33+gis_ppanel_25, gis_ppanel_14 + gis_ppanel_34, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_13'});
                            }
                        });
                        break;
                    case 'CommentForm':
                        $('.pPanelModalForm').remove();
                        var commentEditFormTitle = params.action=='insert' ? gis_ppanel_60 : '';
                        $('body').append('<div id="divCommentForm_'+params.localId+'" class="pPanelModalForm jqx-tabs-content-myCommon">\
                                   <div>\
                                    <form id="frm_'+params.localId+'_'+params.selectedIndex+'" class="frmPanelTab" data-waitload="0">\
                                     <div id="divTabContent_'+params.localId+'_'+params.selectedIndex+'"></div>\
                                    </form>\
                                    <div class="divBottomWindow">\
                                     <button id="btnSaveCommentForm_'+params.localId+'" class="btnForm myButton">Сохранить</button>\
                                     <button id="btnCancelCommentForm_'+params.localId+'" class="btnForm myButton">Отмена</button>\
                                    </div>\
                                   </div>\
                                  </div>');
                        divContent = $('#divTabContent_'+params.localId+'_'+params.selectedIndex);
                        var dlg = $('#divCommentForm_'+params.localId).dialog({
                            dialogClass: "jqx-tabs-content-myCommon",
                            title: commentEditFormTitle,
                            closeOnEscape: true,
                            width: 380,
                            height: 150,
                            resizable: false,
                            modal: true
                        });
                        $('#btnCancelCommentForm_'+params.localId).jqxButton().on('click',function(){dlg.dialog('destroy').remove();});
                        $('#btnSaveCommentForm_'+params.localId).jqxButton().on('click',function(){
                            $('#btnSaveCommentForm_'+params.localId).jqxButton({disabled:true});
                            methods.saveFormNew($.extend(params,{indexForm:params.selectedIndex,callBack:function(){
                                } }));});
                        break;
                }
                return divContent;
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setInputFileName:function(){
            try {
                var fileName = $(this).val().split('\\');
                var changedElement = $('#'+this.id.replace('iFI_',''));
                if(fileName.length != 1)fileName = fileName[fileName.length-1].split('.');
                else fileName = fileName[0].split('.');
                fileName[fileName.length-2] = fileName[fileName.length-2]+'-'+methods.getUniqueId();
                fileName = fileName.join('.');
                $(this).data('filename',fileName);
                changedElement.val(fileName);
                changedElement.trigger('change');
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setInputFileNameText:function(){
            try {
                var changedElement = $('#'+this.id.replace('iFIText_',''));
                var fileName = $(this).val();
                if(fileName.indexOf('.pdf#')==-1){
                    var fInput = $('#'+this.id.replace('iFIText_','iFI_')).val();
                    // если после выбора файла вписывали руками путь, то сохраняем этот без разбития пути
                    if(fileName==fInput){
                        fileName = $(this).val().split('\\');
                        if(fileName.length != 1)fileName = fileName[fileName.length-1].split('.');
                        else fileName = fileName[0].split('.');
                        fileName[fileName.length-2] = fileName[fileName.length-2]+'-'+methods.getUniqueId();
                        fileName = fileName.join('.');
                    }
                }
                $(this).data('filename',fileName);
                changedElement.data('needSetFileInput',false);
                changedElement.val(fileName);
                changedElement.trigger('change');
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        saveComment:function(params){
            try {
                var dataFromForm = methods.serializeForm('frm_'+params.localId+'_extForm');
                //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                if (params.hasOwnProperty('curSchema') && params.hasOwnProperty('curTable')) {
                    var tableIdStartIndex = dataFromForm.indexOf('TABLE_ID="') + 10;
                    var tableIdEndIndex = dataFromForm.indexOf('"',tableIdStartIndex);
                    dataFromForm = dataFromForm.replace(dataFromForm.substring(tableIdStartIndex,tableIdEndIndex), params.curTable);
                }
                switch(params.action) {
                    case 'insert':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENTS',
                                descrType:params.action,
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'" ><data SYS_FULL_ID="" SYS_CLASS_ID="PODS_COMMENTS" SYS_OBJ_ID="" DB_SCHEMA_ID="PODS" DB_TABLE_ID="COMMENTS" CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" '+dataFromForm+'/></root>'},
                            methods.refreshCommentTable,params);
                        break;
                    case 'update':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENTS',
                                descrType:params.action,
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'" ><data SYS_FULL_ID="PODS_COMMENTS/'+params.idComment+'" SYS_CLASS_ID="PODS_COMMENTS" SYS_OBJ_ID="'+params.idComment+'" DB_SCHEMA_ID="PODS" DB_TABLE_ID="COMMENTS" CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" '+dataFromForm+'/></root>'},
                            methods.refreshCommentTable,params);
                        break;
                }
                params.callBack(params);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        saveDocFile:function(params){
            try {
                switch(params.action) {
                    case 'insert':
                        var prm = params.options.objects[params.options.curObject].id.split(':'),
                            db= prm[0].split('_'),
                            db_schema = db[0],
                            db_table_id = db.slice(1).join('_');
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'SYS_SEM.xml#WEB50_LIB_DOC',
                                descrType:'insert',
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+prm[1]+
                                    '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                    '" DB_SCHEMA_ID="'+db_schema+
                                    '" DB_TABLE_ID="'+db_table_id+
                                    '" SYS_CLASS_ID="'+prm[0]+
                                    '" SYS_OBJ_ID="'+prm[1]+'" '+methods.serializeForm('frm_'+params.localId+'_extForm')+'/></root>'},methods.parseAddDoc,params);
                        break;
                    case 'update':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'SYS_SEM.xml#WEB50_LIB_DOC',
                                descrType:'update',
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+params.idFile+
                                    '" SYS_FULL_ID="WEB50_LIB_DOC/'+params.idFile+
                                    '" DB_SCHEMA_ID="WEB50" DB_TABLE_ID="LIB_DOC" SYS_CLASS_ID="WEB50_LIB_DOC'+
                                    '" SYS_OBJ_ID="'+params.idFile+'" '+methods.serializeForm('frm_'+params.localId+'_extForm')+'/></root>'},methods.refreshDocTable,params);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        uploadComplete:function(params){
            try {
                if($(params.iframe).data('checkload') == true) {
                    $(params.iframe).data('checkload',false);
                    var frm = $('#frm_'+params.localId+'_'+params.selectedIndex);
                    frm.data('waitload',Number(frm.data('waitload'))-1);
                    $('#divFI'+params.iframe.id.replace('ifr','')).removeClass('waitLoad');
                    if(params.options.handlers.setDataLoadingCallback != undefined)params.options.handlers.setDataLoadingCallback(false);
                    if(Number(frm.data('waitload')) == 0) methods[params.saveMethod](params);
                }
            } catch (e) {
                App.errorReport(gis_ppanel_35, gis_ppanel_14 + e.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_14'});
            }
        },
        parseAddDoc:function(xmlElement,params) {
            try {
                switch(xmlElement[0].tagName) {
                    case 'root':xmlElement.children().each(function(){methods.parseAddDoc($(this),params);});break;
                    case 'data':
                        switch(params.action)
                        {
                            case 'insert':
                                var prm = params.options.objects[params.options.curObject].id.split(':'),
                                    db= prm[0].split('_'),
                                    db_schema = db[0],
                                    db_table_id = db.slice(1).join('_');
                                methods.serverQueryNode(Services.processQueryNode,
                                    {descrId:'SYS_SEM.xml#DOCUMENT_LIST',
                                        descrType:'insert',
                                        getSchema:false,
                                        toElements:false,
                                        data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+prm[1]+
                                            '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                                            '" DB_SCHEMA_ID="'+db_schema+
                                            '" DB_TABLE_ID="'+db_table_id+
                                            '" SYS_CLASS_ID="'+prm[0]+
                                            '" SYS_OBJ_ID="'+prm[1]+
                                            '" LEFT_OBJ_ID="WEB50_LIB_DOC/'+xmlElement.attr('ID')+
                                            '" RIGHT_OBJ_ID="'+prm[0]+'/'+prm[1]+'"/></root>'},methods.refreshDocTable,params);
                                break;
                            case 'update':
                                methods.refreshDocTable(xmlElement, params);
                                break;
                        }
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        refreshDocTable:function(xmlElement,params){
            try {
                var curDocGrid = $('#'+params.divContent.attr('id')+ ' div[data-selectscript="SYS_SEM.xml#DOCUMENT_LIST"]');
                var curDocGridSource = curDocGrid.jqxGrid('source')._source;
                var prm = params.options.objects[params.options.curObject].id.split(':'),
                    db= prm[0].split('_'),
                    db_schema = db[0],
                    db_table_id = db.slice(1).join('_'),
                    idTable = curDocGrid.attr('id');
                methods.serverQueryStringNode(Services.processQueryNode,
                    {descrId:'SYS_SEM.xml#DOCUMENT_LIST',
                        descrType:'select',
                        getSchema:false,
                        toElements:false,
                        data:'<root><data FILTER="ID='+prm[1]+
                            '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                            '" DB_SCHEMA_ID="'+db_schema+
                            '" DB_TABLE_ID="'+db_table_id+
                            '" SYS_CLASS_ID="'+prm[0]+
                            '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.setTableData,
                    $.extend({divProperties:params.divProperties,
                        source:curDocGridSource,
                        idTable:idTable}));
                var form = $('#divDocForm_'+params.localId);
                if(form != undefined && form.length > 0) {
                    form.dialog('destroy').remove();
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        refreshCommentTable:function(xmlElement,params){
            try {
                var curCommentsGrid = $('#'+params.divContent.attr('id')+ ' div[data-selectscript="GAZPROM_SYS_SEM.xml#PODS_COMMENT_LIST"]');
                var curCommentsGridSource = curCommentsGrid.jqxGrid('source')._source;
                var prm = params.options.objects[params.options.curObject].id.split(':'),
                    db= prm[0].split('_'),
                    db_schema = db[0],
                    db_table_id = db.slice(1).join('_'),
                    idTable = curCommentsGrid.attr('id');
                //#1260 - подставляем реальные schema и table из описания запроса геометрии слоя в layerManager (если удалось получить)
                if (params.hasOwnProperty('curSchema') && params.hasOwnProperty('curTable')) {
                    db_schema = params.curSchema;
                    db_table_id = params.curTable;
                }
                methods.serverQueryStringNode(Services.processQueryNode,
                    {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENT_LIST',
                        descrType:'select',
                        getSchema:false,
                        toElements:false,
                        data:'<root><data FILTER="ID='+prm[1]+
                            '" SYS_FULL_ID="'+prm[0]+'/'+prm[1]+
                            '" DB_SCHEMA_ID="'+db_schema+
                            '" DB_TABLE_ID="'+db_table_id+
                            '" SYS_CLASS_ID="'+prm[0]+
                            '" SYS_OBJ_ID="'+prm[1]+'"/></root>'},methods.setTableData,
                    $.extend({divProperties:params.divProperties,
                        source:curCommentsGridSource,
                        idTable:idTable}));
                var form = $('#divCommentForm_'+params.localId);
                if(form != undefined && form.length > 0) {
                    form.dialog('destroy').remove();
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        loadDoc:function(xmlElement,params){
            try {
                switch(xmlElement[0].tagName) {
                    case 'root':xmlElement.children().each(function(){methods.loadDoc($(this),params);});break;
                    case 'data':
                        if (xmlElement.attr('FILE_NAME')!=undefined && xmlElement.attr('PATH')!=undefined) {
                            try {
                                if (params && params.curDocGridSelectedItem!=undefined && params.curDocGridSelectedItem!=null
                                    && params.curDocGridSelectedItem.attr('DOC_ID')!=null && params.curDocGridSelectedItem.attr('DOC_TYPE_ID')!=null) {
                                    //Для открытия 3D-сцены или IMG-карты проверяем тип прикрепленного документа
                                    var docId = params.curDocGridSelectedItem.attr('DOC_ID')!='' ? params.curDocGridSelectedItem.attr('DOC_ID') : '';
                                    var docTypeId = params.curDocGridSelectedItem.attr('DOC_TYPE_ID')!='' ? params.curDocGridSelectedItem.attr('DOC_TYPE_ID') : '';
                                    if (docTypeId!='' && (docTypeId=="37" || docTypeId=="38" || docTypeId=="41")) {
                                        var docObj = {};
                                        docObj.DOC_ID = docId;
                                        docObj.FILE_NAME = xmlElement.attr('FILE_NAME');
                                        /*(linkObj is FileInput) ? (linkObj as FileInput).fileLoading.text : (linkObj as TextInput).text;*/
                                        switch (docTypeId) {
                                            case "37":	//3Dсцена
                                                ExportUtil.exportToWRL(docObj.DOC_ID, docObj.FILE_NAME);
                                                break;
                                            case "38":	//IMG-карта
                                                ExportUtil.exportToIMG(docObj.DOC_ID, docObj.FILE_NAME);
                                                break;
                                            case "41":	//Видеофайл
                                                var rowDataObj = {};
                                                rowDataObj.ID = docObj.DOC_ID;
                                                rowDataObj.FILE_NAME = docObj.FILE_NAME;
                                                //Для трубопроводов пытаемся получить также LINE_ID для воспроизведения
                                                if (params.curTable=='ROUTE') {
                                                    var routeData = methods.serializeForm('frm_'+params.localId+'_0');
                                                    var lineIdInd = routeData.indexOf('LINE_ID="');
                                                    if (lineIdInd >= 0) {
                                                        showVideo(docObj.DOC_ID, docObj.FILE_NAME, gis_ppanel_49, routeData.substring(lineIdInd+9,routeData.indexOf('"',lineIdInd+9)));
                                                    } else {
                                                        showVideo(docObj.DOC_ID, docObj.FILE_NAME, gis_ppanel_49);
                                                    }
                                                } else {
                                                    showVideo(docObj.DOC_ID, docObj.FILE_NAME, gis_ppanel_49);
                                                }
                                                //Вызываем внешнюю функцию, которая переместит окно грида в нужное положение
                                                widgetMoveWindowToPosition('grid');
                                                break;
                                        }
                                    } else {
                                        //Если документ не является ни 3D-сценой, ни IMG-картой, ни видеофайлом - открываем его
                                        window.open(pPanelOpenDocPath + xmlElement.attr('PATH') + xmlElement.attr('FILE_NAME'), '_blank');
                                    }
                                } else {
                                    window.open(pPanelOpenDocPath + xmlElement.attr('PATH') + xmlElement.attr('FILE_NAME'), '_blank');
                                }
                            } catch (e) {
                                App.errorReport(gis_ppanel_24+gis_ppanel_25, gis_ppanel_14 + e.message.toString(), undefined, {filename:gis_filename_568, functionname:'gis_filename_568_15'});
                            }
                        } else
                            App.errorReport(gis_ppanel_24+gis_ppanel_25, gis_ppanel_14 + gis_ppanel_36, undefined, {filename:gis_filename_568, functionname:'gis_filename_568_16'});
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseCommentFormDescribe:function(xmlElement,params){
            try {
                switch(xmlElement[0].tagName) {
                    case 'root':xmlElement.children().each(function(){methods.parseCommentFormDescribe($(this),params);});break;
                    case 'data':
                        var fileName = '../../Public/Modules/Form/'+xmlElement.attr('id')+'.mxml';
                        methods.serverQueryNode(Services.processQueryNodeXml,
                            {
                                descrId: 'SYS_SEM.xml#GET_XML_FILE',
                                descrType: 'select',
                                data: '<root ><data FILE="' + fileName + '"/></root>'
                            },
                            methods.parseCommentForm,$.extend(params,{selectedIndex:'extForm',saveMethod:'saveComment'}));
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseCommentForm:function(xmlElement,params){
            try {
                methods.parseForm(xmlElement,params);
                switch(params.action) {
                    case 'insert':
                        var prm = params.options.objects[params.options.curObject].id.split(':'),
                            db= prm[0].split('_'),
                            db_table_id = db.slice(1).join('_'),
                            inputOI = $('#OBJECT_ID_'+params.localId+'_'+params.selectedIndex),
                            inputTI = $('#TABLE_ID_'+params.localId+'_'+params.selectedIndex);
                        if(inputOI.length == 0)
                            $('#frm_'+params.localId+'_'+params.selectedIndex).append(
                                '<input id="OBJECT_ID_'+params.localId+'_'+params.selectedIndex+'" type="hidden" value="'+prm[1]+'" data-typecontrol="input" class="formControl" data-loadvalue=true />');
                        else inputOI.val(prm[1]);
                        if(inputTI.length == 0)
                            $('#frm_'+params.localId+'_'+params.selectedIndex).append(
                                '<input id="TABLE_ID_'+params.localId+'_'+params.selectedIndex+'" type="hidden" value="'+db_table_id+'" data-typecontrol="input" class="formControl" data-loadvalue=true />');
                        else inputTI.val(db_table_id);
                        params.divProperties.data('unlockCombo',1);
                        methods.unlockFormControls(params);
                        break;
                    case 'update':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'GAZPROM_SYS_SEM.xml#PODS_COMMENTS',
                                descrType:'select',
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+params.idComment+
                                    '" SYS_FULL_ID="PODS_COMMENTS/'+params.idComment+
                                    '" DB_SCHEMA_ID="PODS" DB_TABLE_ID="COMMENTS" SYS_CLASS_ID="PODS_COMMNETS" SYS_OBJ_ID="'+params.idComment+'"/></root>'},methods.parseTabValues,params);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseFormDescribe:function(xmlElement,params){
            try {
                switch(xmlElement[0].tagName) {
                    case 'root':xmlElement.children().each(function(){methods.parseFormDescribe($(this),params);});break;
                    case 'data':
                        var fileName = '../../Public/Modules/Form/'+xmlElement.attr('id')+'.mxml';
                        methods.serverQueryNode(Services.processQueryNodeXml,
                            {
                                descrId: 'SYS_SEM.xml#GET_XML_FILE',
                                descrType: 'select',
                                data: '<root ><data FILE="' + fileName + '"/></root>'
                            },
                            methods.parseDocForm,$.extend(params,{selectedIndex:'extForm',saveMethod:'saveDocFile'}));

                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        parseDocForm:function(xmlElement,params){
            try {
                methods.parseForm(xmlElement,params);
                switch(params.action) {
                    case 'insert':params.divProperties.data('unlockCombo',1);
                        methods.unlockFormControls(params);
                        break;
                    case 'update':
                        methods.serverQueryNode(Services.processQueryNode,
                            {descrId:'SYS_SEM.xml#WEB50_LIB_DOC',
                                descrType:'select',
                                getSchema:false,
                                toElements:false,
                                data:'<root USER_ID="'+Auth.getUserId()+'" USER_LOGIN="'+Auth.getUserName()+'" PODS_USER="'+Auth.getUserName()+'"><data CURRENT_USER_LOGIN="'+Auth.getUserName()+'" CURRENT_USER_ID="'+Auth.getUserId()+'" FILTER="ID='+params.idFile+
                                    '" SYS_FULL_ID="WEB50_LIB_DOC/'+params.idFile+
                                    '" DB_SCHEMA_ID="WEB50" DB_TABLE_ID="LIB_DOC" SYS_CLASS_ID="WEB50_LIB_DOC'+
                                    '" SYS_OBJ_ID="'+params.idFile+'"/></root>'},methods.parseTabValues,params);
                        break;
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        deleteDocFile:function(xmlElement,params){
            try {
                methods.refreshDocTable(xmlElement,params);
                var alertForm = new AlertForm();
                alertForm.build("pPanelDeleteDocAlertForm",gis_ppanel_37,"",AlertForm.OK);
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        setAttrsValues:function(params){
            try {
                if(params.options.objects[params.options.curObject].attrs != undefined)
                {
                    $(params.options.objects[params.options.curObject].attrs).each(function(){
                        var control = $('#'+this.name+'_'+params.localId+'_'+params.selectedIndex);
                        if(control.length != 0)
                            methods.setControlValue(control,this);
                    });
                }
            } catch (err) {
                //Ничего не делаем, возможно панель закрыта
            }
        },
        //сворачиваем панель
        minimizePanel:function(params){
            //получаем localId и по нему
            var options = $(this).data('options');
            if(options!=undefined && options.localId != undefined && options.localId!=''){
                var localId = options.localId;
                $('#pPanelTitleMinimizeBtn_'+localId).jqxButton().trigger('click');
            }

        },
        updateOptions:function(params){
            var options = $(this).data('options');
            $.extend(options,params);
        }
    };

    $.fn.myPropertiesPanel = function( method ){

        if(methods[method]) {
            return methods[ method ].apply( this, Array.prototype.slice.call( arguments, 1 ));
        } else if ( typeof method === 'object' || ! method ) {
            return methods.init.apply( this, arguments );
        } else {
            $.error( 'Method ' +  method + ' does not exist on jQuery.fn.myPropertiesPanel' );
        }
    };
})(jQuery);
/*
 * Глобальные функции для вызова из внешних приложений
 * */

//Эта функция используется как для выполнения операции, так и для возврата значения
//При возврате значения функция вызывается с единственным аргументом со значением true/false
//Поэтому если первый аргумент - true/false, а второй - undefined, значит вызываем внешнюю функцию-результат
function findExternalObject(systemId, objectId, needBind, lineId, beginKm, endKm) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_1, "Data Access", LogUtil.Severity_INFO, gis_externalfunctionsapi_2 + systemId + ", objectId=" + objectId);
		if (systemId != undefined && objectId == undefined) {
			if (window != undefined && window.external != undefined) window.external.findExternalObject(systemId);
			else
				LogUtil.sendLog("window==undefined || window.external==undefined");
		} else {
			var app = getFlexApp("Client_Main");
			if (app != null)
				app.findExternalObject(systemId, objectId);
			else {
				return WidgetMap.findExternalObject(systemId, objectId, needBind, lineId, beginKm, endKm);
			}
		}
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию findExternalObject. error: "+ e.message + ". Вызов функции findExternalObject с параметрами: systemId="+systemId+", objectId="+objectId);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_3 + e.message);
		} catch (err) {
		}
	}
}

//Эта функция используется как для выполнения операции, так и для возврата значения
//При возврате значения функция вызывается с единственным аргументом со значением true/false
//Поэтому если первый аргумент - true/false, а второй - undefined, значит вызываем внешнюю функцию-результат
function findExternalPipeKm(systemId, objectId, km) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_4 + systemId + ", objectId=" + objectId + ", km=" + km);
		if (systemId != undefined && objectId == undefined) {
			if (window != undefined && window.external != undefined) window.external.findExternalPipeKm(systemId);
			else
				LogUtil.sendLog("window==undefined || window.external==undefined");
		} else {
			var app = getFlexApp("Client_Main");
			if (app != null)
				app.findExternalPipeKm(systemId, objectId, km);
			else {
				return WidgetMap.findExternalPipeKm(systemId, objectId, km);
			}
		}
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию findExternalPipeKm. error: "+ e.message + ". Вызов функции findExternalPipeKm с параметрами: systemId="+systemId+", objectId="+objectId+", km="+km);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_5 + e.message);
		} catch (err) {
		}
	}
}

//Эта функция используется как для выполнения операции, так и для возврата значения
//При возврате значения функция вызывается с единственным аргументом со значением true/false
//Поэтому если первый аргумент - true/false, а второй - undefined, значит вызываем внешнюю функцию-результат
function findExternalPipePart(systemId, objectId, km, endKm) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_6 + systemId + ", objectId=" + objectId + ", km=" + km + ", endKm=" + endKm);
		if (systemId != undefined && objectId == undefined) {
			if (window != undefined && window.external != undefined) window.external.findExternalPipePart(systemId);
			else
				LogUtil.sendLog("window==undefined || window.external==undefined");
		} else {
			var app = getFlexApp("Client_Main");
			if (app != null)
				app.findExternalPipePart(systemId, objectId, km, endKm);
			else {
				return WidgetMap.findExternalPipeKm(systemId, objectId, km, endKm);
			}
		}
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию findExternalPipePart. error: "+ e.message + ". Вызов функции findExternalPipePart с параметрами: systemId="+systemId+", objectId="+objectId+", km="+km+", endKm="+endKm);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_7 + e.message);
		} catch (err) {
		}
	}
}

function getMapWidth() {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_8);
		var app = getFlexApp("Client_Main");
		if (app != null)
			return app.getMapWidth();
		else {
			return WidgetMap.getMapWidth();
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_9 + e.message);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_9 + e.message);
		} catch (err) {
		}
	}
}
function getMapCenter() {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_10);
		var app = getFlexApp("Client_Main");
		if (app != null)
			return app.getMapCenter();
		else {
			return WidgetMap.getMapCenter();
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_11 + e.message);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_11 + e.message);
		} catch (err) {
		}
	}
}

function getPosition() {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_12);
		var app = getFlexApp("Client_Main");
		if (app != null)
			return app.getPosition();
		else {
			return WidgetMap.getPosition();
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_13 + e.message);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_13 + e.message);
		} catch (err) {
		}
	}
}

//Эта функция используется как для выполнения операции, так и для возврата значения
//При возврате значения функция вызывается с единственным аргументом со значением true/false
//Поэтому если первый аргумент - true/false, а второй - undefined, значит вызываем внешнюю функцию-результат
function refreshLayer(layerName, params) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_14 + layerName + ", params=" + params);
		if (layerName != undefined && params == undefined) {
			if (window != undefined && window.external != undefined) window.external.refreshLayer(layerName);
			else
				LogUtil.sendLog("window==undefined || window.external==undefined");
		} else {
			var app = getFlexApp("Client_Main");
			if (app != null) {
				app.refreshLayer(layerName, params);
			} else {
				return WidgetMap.refreshLayer(layerName, params);
			}
		}
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию refreshLayer. error: "+ e.message + ". Вызов функции refreshLayer с параметрами: layerName="+layerName+", params="+params);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_15 + e.message);
		} catch (err) {
		}
	}
}

function clearLayer(layerName) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_16 + layerName);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.clearLayer(layerName);
		else {
			return WidgetMap.clearLayer(layerName);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_17 + e.message + gis_externalfunctionsapi_18 + layerName);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_17 + e.message);
		} catch (err) {
		}
	}
}

function refreshModel(modelName, params) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_19 + modelName + ", params=" + params);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.refreshModel(modelName, params);
		else {
			return WidgetMap.refreshModel(modelName, params);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_20, gis_externalfunctionsapi_20 + e.message + gis_externalfunctionsapi_21 + modelName + ", params=" + params, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_5'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_20 + e.message);
		} catch (err) {
		}
	}
}

function clearModel(modelName) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_22 + modelName);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.clearModel(modelName);
		else {
			return WidgetMap.clearModel(modelName);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_26, gis_externalfunctionsapi_26 + e.message + gis_externalfunctionsapi_27 + modelName + ", params=" + params, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_7'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_23 + e.message);
		} catch (err) {
		}
	}
}

function refreshMap(modelName, params) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_25 + modelName + ", params=" + params);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.refreshMap(modelName, params);
		else {
			return WidgetMap.refreshMap(modelName, params);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_26 + e.message + gis_externalfunctionsapi_27 + modelName + ", params=" + params);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_26 + e.message);
		} catch (err) {
		}
	}
}

function clearMap(modelName) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_28 + modelName);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.clearMap(modelName);
		else {
			return WidgetMap.clearMap(modelName);
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_29 + e.message + gis_externalfunctionsapi_30 + modelName);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_29 + e.message);
		} catch (err) {
		}
	}
}

function showCAS(type, systemId, objectId, objectName, kmBegin, kmEnd) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_31 + type + ", systemId=" + systemId + ", objectId=" + objectId + ", objectName=" + objectName + ", kmBegin=" + kmBegin + ", kmEnd=" + kmEnd);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.showCAS(type, systemId, objectId, objectName, kmBegin, kmEnd);
		else
			return WidgetMap.showCAS(type, systemId, objectId, objectName, kmBegin, kmEnd);
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_32 + e.message + gis_externalfunctionsapi_33 + type + ", systemId=" + systemId + ", objectId=" + objectId + ", objectName=" + objectName + ", kmBegin=" + kmBegin + ", kmEnd=" + kmEnd);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_32 + e.message);
		} catch (err) {
		}
	}
}

function exportIMG(systemId, objectId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_34 + systemId + ", objectId=" + objectId);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.exportIMG(systemId, objectId);
		else
			LogUtil.sendLog("app == null");
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_35, gis_externalfunctionsapi_35 + e.message + gis_externalfunctionsapi_36 + systemId + ", objectId=" + objectId, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_10'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_35 + e.message);
		} catch (err) {
		}
	}
}

function openVRML(systemId, objectId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_37 + systemId + ", objectId=" + objectId);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.openVRML(systemId, objectId);
		else
			LogUtil.sendLog("app == null");
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_38, gis_externalfunctionsapi_38 + e.message + gis_externalfunctionsapi_39 + systemId + ", objectId=" + objectId, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_11'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_38 + e.message);
		} catch (err) {
		}
	}
}

function exportGPX(systemId, objectId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_40 + systemId + ", objectId=" + objectId);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.exportGPX(systemId, objectId);
		else
			LogUtil.sendLog("app == null");
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_41, gis_externalfunctionsapi_41 + e.message + gis_externalfunctionsapi_42 + systemId + ", objectId=" + objectId, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_12'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_41 + e.message);
		} catch (err) {
		}
	}
}

function exportExcel(systemId, objectId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_43 + systemId + ", objectId=" + objectId);
		var app = getFlexApp("Client_Main");
		if (app != null)
			app.exportExcel(systemId, objectId);
		else
			LogUtil.sendLog("app == null");
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_44, gis_externalfunctionsapi_44 + e.message + gis_externalfunctionsapi_45 + systemId + ", objectId=" + objectId, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_13'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_44 + e.message);
		} catch (err) {
		}
	}
}

/* Функция запуска воспроизведения видео по docId и videoUrl */
function showVideo(docId, videoUrl, videoName, lineId) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		if(videoUrl != "" && videoUrl.indexOf("'") != -1){
			videoUrl = videoUrl.replace("'","");//удаляем одинарные кавычки, чтобы корректно флешка читала mp4
			videoUrl = videoUrl.replace("'","");
		}

		LogUtil.sendLog(gis_externalfunctionsapi_46 + docId + ", videoUrl=" + videoUrl + ", videoName=" + videoName + ", lineId=" + lineId);

		//Вместо вызова флеша открываем js-окно, в которое будет загружаться виджет видеоплеера
		if (typeof VideoPlayerWindow != 'undefined') {
			var videoPlayerWnd = new VideoPlayerWindow();
			videoPlayerWnd.build('currentVideoPlayer', docId, videoUrl, videoName, lineId);
		} else {
			/* версия с флеш-картой запускала видео так */
			var app = getFlexApp("Client_Main");
			//Параметры для вызова
			var videoParams = [{name: "docId", value: docId}, {name: "videoUrl", value: videoUrl}, {
				name: "lineId",
				value: lineId
			}];
			if (app != null && app['showVideo'] != undefined) {
				app['showVideo'](videoParams);
			} else {
				//Если вызвали функцию со страницы, открытой из грида - перенаправляем вызов в окно карты (видеоплеер находится в нем)
				callFunction('', 'showVideo', videoParams);
			}
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_47 + e.message + gis_externalfunctionsapi_48 + docId + ", videoUrl=" + videoUrl + ", videoName=" + videoName);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_47 + e.message);
		} catch (err) {
		}
	}
}

/* Функция приема из виджета видеоплеера параметра перемещения карты за вертолетиком, если он выходит за рамку карты (true/false) */
function widgetVideoSetAutoFocus(autoFocus, toFlash) {
	try {
		WidgetMap.startVideoAutoFocusFlag = autoFocus;
		if (toFlash !== undefined) {
			var app = getFlexApp("videoPlayer55");
			if (app != null)
				app.widgetVideoSetAutoFocus(autoFocus);
			WidgetMap.isVideoAutoFocus = autoFocus;
			return;
		}
		WidgetMap.isVideoAutoFocus = autoFocus;
		if (autoFocus == true)
			WidgetMap.forceAutoFocus = true;
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию widgetVideoSetAutoFocus");
	}
}

/* Функция приема из виджета видеоплеера трека видеозаписи (приходит в формате xml-строки с геометрией) */
function widgetVideoSetTrack(xmlGeoResult) {
	try {
		var geoRes = xmlGeoResult;
		WidgetMap.showVideo(geoRes);
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_49 + e.message + gis_externalfunctionsapi_50 + xmlGeoResult);
	}
}

/* Функция приема из виджета видеоплеера текущей точки видеозаписи (приходит в формате xml-строки с геометрией) */
function widgetVideoShowOnMap(xmlGeoResult) {
	try {
		var geoRes = xmlGeoResult;
		WidgetMap.videoShowOnMap(geoRes);
	}
	catch (e) {
	}
}

/* Функция установки в виджет видеоплеера текущего времени видеозаписи (целое значение от 0 до длины видео, берется из переданного в функцию widgetVideoSetTrack) */
function widgetVideoSetPlayheadTime(timeValue) {
	try {
		var wnd = getOpener();
		var fApp = getCurrentFlexApp(wnd, "videoPlayer55");
		if (fApp != null) {
			try {
				fApp['widgetVideoSetPlayheadTime'](timeValue);
				//Если вызов прошел - возвращаем true
				return true;
			}
			catch (e) {
				return false;
			}
		} else {
			return false;
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_51 + e.message + gis_externalfunctionsapi_52 + timeValue);
		return false;
	}
}

/* Функция перемотки виджета видеоплеера ко времени точки, ближайшей к переданным координатам (координаты передаются в Пулково-42) */
function widgetVideoMovePlayheadToCoords(pointLon, pointLat) {
	try {
		var wnd = getOpener();
		var fApp = getCurrentFlexApp(wnd, "videoPlayer55");
		if (fApp != null) {
			try {
				fApp['widgetVideoMovePlayheadToCoords'](pointLon, pointLat);
				//Если вызов прошел - возвращаем true
				return true;
			}
			catch (e) {
				return false;
			}
		} else {
			return false;
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_53, gis_externalfunctionsapi_53 + e.message + gis_externalfunctionsapi_54 + pointLon + ", pointLat=" + pointLat, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_17'});
		return false;
	}
}

/* Функция для изменения позиции окна (окна грида, видеоплеера - по специальным идентификаторам)
 * popupWindowId - идентификатор окна либо константа из следующего списка: ['grid','videoplayer']
 * flag - флаг, указывающий что делать с окном. Обрабатываются параметры из следующего списка: ['move','collapse','minimize','maximize','restore','close'].
 * По-умолчанию 'move', т.е. окно будет уменьшено и перемещено так, чтобы верх окна по высоте начинался с 2/3 экрана.
 * */
function widgetMoveWindowToPosition(popupWindowId, flag) {
	try {
		if (!flag || flag == undefined) flag = 'move';
		//Для грида всегда используется контейнер с классом gridTabContent - по нему и находим плавающее окно с гридом
		if (popupWindowId != undefined && popupWindowId && popupWindowId == 'grid') {
			var curGridTabNav = $('.gridTabContent');
			if (curGridTabNav && curGridTabNav.length > 0) {
				switch (flag) {
					case 'move':
						//ТУТ ПРОИСХОДИТ СВОРАЧИВАНИЕ ГРИДА ДО МИНИМАЛЬНЫХ РАЗМЕРОВ
						//upd. 08.04.21 если нет карты, то грид не сворачиваем
						if(!checkMapExisting())
							break;
						var curPos = curGridTabNav.dialog("widget").position();
						var newHeight = $(window).height() / 3;
						curGridTabNav.dialog('option', {"height": newHeight, "position": [curPos.left, newHeight * 2]});
						/*Вызываем события resize как при изменении размеров мышкой*/
						curGridTabNav.trigger("resize");
						curGridTabNav.dialog('option', 'resize').apply(curGridTabNav, [null, null]);
						break;
					case 'collapse':
						curGridTabNav.dialogExtend("collapse");
						break;
					case 'minimize':
						curGridTabNav.dialogExtend("minimize");
						break;
					case 'maximize':
						curGridTabNav.dialogExtend("maximize");
						break;
					case 'restore':
						curGridTabNav.dialogExtend("restore");
						break;
					case 'restore_default':
						curGridTabNav.trigger("resize");
						curGridTabNav.dialog('option', 'resize').apply(curGridTabNav, ['restore_default', null]);
						break;
					case 'close':
						curGridTabNav.dialog("destroy");
						//Возможно нужно тут удалять curGridTabNav, хотя при build нового окна он все равно удалится
						break;
					default:
						break;
				}
			} else {
				//Это на случай, если текущий код находится на странице iframe и нужно вызвать функцию родительского окна
				if (parent && parent.hasOwnProperty('widgetMoveWindowToPosition') && parent.widgetMoveWindowToPosition !== widgetMoveWindowToPosition && parent.$('.gridTabContent').length > 0) {
					parent.widgetMoveWindowToPosition(popupWindowId, flag);
				}
			}
		} else if (popupWindowId != undefined && popupWindowId && popupWindowId == 'videoplayer') {
			//Для видеоплеера еще не создан никакой класс или div с плавающим окном
		}
	}
	catch (e) {
		App.errorReport(gis_externalfunctionsapi_55, gis_externalfunctionsapi_55 + e.message + gis_externalfunctionsapi_56 + popupWindowId + ", flag=" + flag, undefined, {filename:gis_filename_536, functionname:'gis_filename_536_18'});
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_55 + e.message);
		} catch (err) {
		}
	}
}

/* Это функция обратного вызова */
function taskReady(taskName, success) {
	try {
		//ловим вызов, смотрим, нит ли в url параметров func.
		//если есть, то вызываем функции
		var func = Auth.getParameterByName('func');
		if (func != '') {
			var systemId = Auth.getParameterByName('systemId');
			switch (func) {
				case 'exportGPX':
					exportGPX(systemId, Auth.getParameterByName('objectId'));
					break;
				case 'exportExcel':
					exportExcel(systemId, Auth.getParameterByName('objectId'));
					break;
				case 'exportIMG':
					exportIMG(systemId, Auth.getParameterByName('objectId'));
					break;
				case 'openVRML':
					openVRML(systemId, Auth.getParameterByName('objectId'));
					break;
				case 'showCAS':
					showCAS(Auth.getParameterByName('type'), systemId, Auth.getParameterByName('objectId'), Auth.getParameterByName('objectName'), Auth.getParameterByName('beginKm'), Auth.getParameterByName('endKm'));
					break;
			}
			LogUtil.sendLog(gis_externalfunctionsapi_57 + taskName + ", success=" + success);
			return;
		}

		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_57 + taskName + ", success=" + success);
		if (window != undefined && window.external != undefined) window.external.taskReady(taskName, success);
		else
			LogUtil.sendLog("window==undefined || window.external==undefined");
	}
	catch (e) {
		//App.errorReport("Не удалось вызвать внешнюю функцию taskReady. error: "+ e.message + ". Вызов функции taskReady с параметрами: taskName="+taskName+", success="+success);
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_58 + e.message);
		} catch (err) {
		}
	}
}

/* Это функция обратного вызова с информацией из панели свойств */
function onObjectsInfo(objectsList) {
	try {
		//Отправляем в лог данные с описанием вызова и параметров функции
		LogUtil.sendLog(gis_externalfunctionsapi_59 + objectsList.toString());
		if (window != undefined && window.external != undefined) window.external.onObjectsInfo(objectsList);
		else
			LogUtil.sendLog("window==undefined || window.external==undefined");
	}
	catch (e) {
		try {
			LogUtil.sendLog(gis_externalfunctionsapi_60 + e.message);
		} catch (err) {
		}
	}
}

