<root version="postgres 7.7.7.5">
	<data id="CONV_BINARY" comment="CONV_BINARY" schema="UTE" table="CONV_BINARY">
		<update>
			<dbCommand>
				<query>
					{INSERT_SQL}
				</query>
			</dbCommand>
		</update>
	</data>
	<data id="SELECT_PROJ_GEO_MBR" comment="SELECT_PROJ_GEO" schema="UTE" table="SELECT_PROJ_GEO">
		<select>
			<dbQuery>
				<query>
					SELECT {ID_FIELD} "ID", {BLOB_FIELD} "WKB_GEOMETRY", null "XMIN", null "YMIN", null "XMAX", null "YMAX" FROM {TABLE_NAME}
				</query>
			</dbQuery>
		</select>
	</data>
	<data id="UPDATE_PROJ_GEO_MBR" comment="UPDATE_PROJ_GEO" schema="UTE" table="UPDATE_PROJ_GEO">
		<update>
			<dbCommand>
				<query>
					UPDATE {TABLE_NAME} SET  {BLOB_FIELD}=:WKB_GEOMETRY, "XMIN"=:XMIN, "YMIN"=:YMIN, "XMAX"=:XMAX, "YMAX"=:YMAX WHERE {ID_FIELD} = :ID
				</query>
			</dbCommand>
		</update>
	</data>
	<data id="SELECT_PROJ_XY_GEO" comment="SELECT_PROJ_XY_GEO" schema="UTE" table="SELECT_PROJ_XY_GEO">
		<select>
			<dbQuery>
				<query>
					{SELECT_SQL}
				</query>
			</dbQuery>
		</select>
	</data>
	<data id="UPDATE_PROJ_XY_GEO" comment="UPDATE_PROJ_XY_GEO" schema="UTE" table="UPDATE_PROJ_XY_GEO">
		<update>
			<dbCommand>
				<query>
					{UPDATE_SQL}
				</query>
			</dbCommand>
		</update>
	</data>
	<data id="SELECT_PROJ_GEO" comment="SELECT_PROJ_GEO" schema="UTE" table="SELECT_PROJ_GEO">
		<select>
			<dbQuery>
				<query>
					SELECT {ID_FIELD} "ID", {BLOB_FIELD} "WKB_GEOMETRY" FROM {TABLE_NAME}
				</query>
			</dbQuery>
		</select>
	</data>
	<data id="UPDATE_PROJ_GEO" comment="UPDATE_PROJ_GEO" schema="UTE" table="UPDATE_PROJ_GEO">
		<update>
			<dbCommand>
				<query>
					UPDATE {TABLE_NAME} SET {BLOB_FIELD}=:WKB_GEOMETRY WHERE {ID_FIELD} = :ID
				</query>
			</dbCommand>
		</update>
	</data>
	<data id="CONV_LIB_DOC_VERSION_BINARY" comment="CONV_LIB_DOC_VERSION_BINARY" schema="UTE" table="CONV_LIB_DOC_VERSION_BINARY">
		<update>
			<dbCommand>
				<query>
					INSERT INTO web50.lib_doc_version(doc_id, doc_version_id, next_doc_version_id,mime_type_id,storage_id,name,descr,version_number,ctime,cuser_id,mtime, muser_id, file_name, body)
					values(:DOC_ID,:DOC_VERSION_ID,:NEXT_DOC_VERSION_ID,:MIME_TYPE_ID,:STORAGE_ID,:NAME,:DESCR,:VERSION_NUMBER,:CTIME,:CUSER_ID,:MTIME,:MUSER_ID,:FILE_NAME,:BODY)
				</query>
			</dbCommand>
		</update>
	</data>
<data id="CONV_MDR_BINARY" comment="CONV_MDR_BINARY" schema="UTE" table="CONV_MDR_BINARY">
		<update>
			<dbCommand>
				<query>
					INSERT INTO web50.kadastr_pods_mdr(obj_type, description, station_begin,station_end,mdr_id,wkb_geometry)
					values(:OBJ_TYPE,:DESCRIPTION,:STATION_BEGIN,:STATION_END,:MDR_ID,:WKB_GEOMETRY)
				</query>
			</dbCommand>
		</update>
	</data>
<data id="CONV_SRV_DISTRICT_G_BINARY" comment="CONV_SRV_DISTRICT_G_BINARY" schema="UTE" table="CONV_SRV_DISTRICT_G_BINARY">
		<update>
			<dbCommand>
				<query>
					INSERT INTO pods.srv_district_g(gid,wkb_geometry,"XMIN","XMAX","YMIN","YMAX",style) values(:GID,:WKB_GEOMETRY,:XMIN,:XMAX,:YMIN,:YMAX,:STYLE)
				</query>
			</dbCommand>
		</update>
	</data>	

<data id="ILI_INTEGR_2_1" comment="Получение списка отчетов ВТД, перенесенных ранее через интеграцию (чтоб не перенести еще раз)" schema="UTE" table="ILI_INTEGR_2_1">
	<select>
		<dbQuery>		
			<query>
select string_agg(''''||g.obj_id||'''', ',') from gis_integration50.gate  g where     g.system_id = 'INFOTEH'
                           and g.table_name = 'ILI_INSPECTION'
                           and g.system_pair_id = '102'
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_INTEGR_2_2" comment="Заполнение таблицы gate для связи отчета ВТД между нашей БД и Инфотехом" schema="UTE" table="ILI_INTEGR_2_2">
<insert>
		<dbCommand>
		<var name="db_command_err.CMD.ILI_INSPECTION_ID"/>
		<var name="EXTERNAL_P_OBJ_ID"/>
			<query>
DO $$
begin
      INSERT INTO gis_integration50.gate (owner,table_name,key_fields,key_values,system_pair_id,system_id,system_descr,obj_id,obj_descr,is_univ,sql_query)
				VALUES('PODS', 'ILI_INSPECTION', 'ILI_INSPECTION_ID'
				, '{db_command_err.CMD.ILI_INSPECTION_ID}'
				, '102'
				, 'INFOTEH'
				, '2 Тип интеграции: Перенос ВТД из ССД ИНФОТЕХ в PODS'
				, '{EXTERNAL_P_OBJ_ID}'
				, ''
				, 'FALSE'
				,null);

INSERT INTO gis_integration50.gate (owner,table_name,key_fields,key_values,system_pair_id,system_id,system_descr,obj_id,obj_descr,is_univ,sql_query)
VALUES (  'CALC', 'STO_EHZ_INSP_Proc.xml', 'ILI_INSPECTION_ID', '{db_command_err.CMD.ILI_INSPECTION_ID}', 102, 'INFOTEH', '2 Тип интеграции: Расчет показателей ЭХЗ', '{EXTERNAL_P_OBJ_ID}', null, 'FALSE', null);


INSERT INTO gis_integration50.gate (owner,table_name,key_fields,key_values,system_pair_id,system_id,system_descr,obj_id,obj_descr,is_univ,sql_query)
VALUES (  'CALC', 'STO_ILI_INSP_Proc.xml', 'ILI_INSPECTION_ID', '{db_command_err.CMD.ILI_INSPECTION_ID}', 102, 'INFOTEH', '2 Тип интеграции: Расчет лин. показателей', '{EXTERNAL_P_OBJ_ID}', null, 'FALSE', null);


INSERT INTO gis_integration50.gate (owner,table_name,key_fields,key_values,system_pair_id,system_id,system_descr,obj_id,obj_descr,is_univ,sql_query)
VALUES (  'CALC', 'ILI_Cluster.xml', 'ILI_INSPECTION_ID', '{db_command_err.CMD.ILI_INSPECTION_ID}', 102, 'INFOTEH', '2 Тип интеграции: Расчет групп дефектов', '{EXTERNAL_P_OBJ_ID}', null, 'FALSE', null);


INSERT INTO gis_integration50.gate (owner,table_name,key_fields,key_values,system_pair_id,system_id,system_descr,obj_id,obj_descr,is_univ,sql_query)
VALUES (  'CALC', 'ILI_Pressure.xml', 'ILI_INSPECTION_ID', '{db_command_err.CMD.ILI_INSPECTION_ID}', 102, 'INFOTEH', '2 Тип интеграции: Расчет точ. показателей', '{EXTERNAL_P_OBJ_ID}', null, 'FALSE', null);

END$$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="ILI_INTEGR_2_3" comment="Поиск связи между отчетом ВТД и трубопроводов" schema="UTE" table="ILI_INTEGR_2_3">
<select>		
	<dbQuery>
		<var name="PIPE"/>
		<var name="KM_START"/>
		<var name="KM_END"/>
			<query>
		  WITH routes AS (SELECT r.route_id, l.description descr, MIN(s.station_begin) km_start, MAX(s.station_end) km_end
                                FROM pods.route r
                                     JOIN pods.series s
                                       ON s.route_id = r.route_id
                                     JOIN pods.line l
                                       ON r.line_id = l.line_id  
                               WHERE                 r.current_indicator_lf like 'Y' and 
				r.type_cl IN ('ROUTE_TYPE_01','ROUTE_TYPE_04','ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12')
                               GROUP BY r.route_id, l.description),
                   inspections AS (SELECT '{PIPE}' descr
                                         ,{KM_START} km_start
                                         ,{KM_END} km_end)
              SELECT MIN(route_id) route_id
                     FROM routes r
                          JOIN inspections i
                               ON REPLACE(REPLACE(REPLACE(REPLACE (REPLACE (REPLACE (REPLACE (LOWER (LTRIM (RTRIM (i.descr::text)))
                                          ,'iv','4'), 'iii','3'),'ii','2'),'i','1'),'-',''),'-',''),' ','')
                                  = REPLACE(REPLACE(REPLACE(REPLACE (REPLACE (REPLACE (REPLACE (LOWER (LTRIM (RTRIM (r.descr)))
                                            ,'iv','4'), 'iii','3'),'ii','2'),'i','1'),'-',''),'-',''),' ','')
                               /*AND (ABS (i.km_start - r.km_start) &lt; 2 OR ABS (i.km_end - r.km_end) &lt; 2)
                               AND ABS (r.km_end - r.km_start) > 2*/
 			       AND i.km_start::numeric BETWEEN r.km_start-2 AND r.km_end
                               AND i.km_end::numeric   BETWEEN r.km_start AND r.km_end+2 
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_INTEGR_2_7" comment="Установка связи с трубопроводом и создание записи отчета" schema="UTE" table="ILI_INTEGR_2_7">
	<update>
		<dbCommand>
		<var name="DATE"/>	
		<var name="MODEL"/>
		<var name="FORMAT"/>
		<var name="COMPANY"/>
		<var name="config.main.PODS_USER"/>
		<var name="PIPE"/>
		<var name="KM_START"/>
		<var name="KM_END"/>
		<var name="call_complex_method.FIRST_WELD_NUMBER"/>
		<var name="ILI_INSPECTION_ID" type="Decimal" default="SELECT max(ili_inspection_id) id FROM PODS.ILI_INSPECTION"/>				
			<query>
DO $$
			DECLARE
			returnId NUMERIC default -50;
			returnInspectionId NUMERIC;
			comp_id varchar(10) default 'UNKNOWN';
			v_routeID NUMERIC default null;
			comp_cnt NUMERIC;
			BEGIN 


  if (select count(*) from pods.ili_tool_vendor_cl where description like '{COMPANY}')>0 then  
    select code into comp_id  from pods.ili_tool_vendor_cl where description like '{COMPANY}';
  end if;


 WITH routes AS (SELECT r.route_id, l.description descr, MIN(s.station_begin) km_start, MAX(s.station_end) km_end
                                FROM pods.route r
                                     JOIN pods.series s
                                       ON s.route_id = r.route_id
                                     JOIN pods.line l
                                       ON r.line_id = l.line_id  
                               WHERE  r.current_indicator_lf like 'Y' and 
		r.type_cl IN ('ROUTE_TYPE_01','ROUTE_TYPE_04','ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12')
                               GROUP BY r.route_id, l.description),
                   inspections AS (SELECT '{PIPE}' descr
                                         ,{KM_START} km_start
                                         ,{KM_END} km_end)
              SELECT MIN(route_id) route_id into v_routeID 
                     FROM routes r
                          JOIN inspections i
                               ON REPLACE(REPLACE(REPLACE(REPLACE (REPLACE (REPLACE (REPLACE (LOWER (LTRIM (RTRIM (i.descr::text)))
                                          ,'iv','4'), 'iii','3'),'ii','2'),'i','1'),'-',''),'-',''),' ','')
                                  = REPLACE(REPLACE(REPLACE(REPLACE (REPLACE (REPLACE (REPLACE (LOWER (LTRIM (RTRIM (r.descr)))
                                            ,'iv','4'), 'iii','3'),'ii','2'),'i','1'),'-',''),'-',''),' ','')
                               
 			       AND i.km_start::numeric BETWEEN r.km_start AND r.km_end
                               AND i.km_end::numeric BETWEEN r.km_start AND r.km_end;

 			INSERT INTO PODS.ILI_INSPECTION(BEGIN_DATE, END_DATE, START_ODOMETER, END_ODOMETER, TOOL_TYPE_CL, MODEL, SENSOR_GCL,
 			SENSOR_SPACING_MIN, SENSOR_SPACING_MAX, MIN_TEMP, MAX_TEMP, AVG_TEMP, MIN_VELOCITY, MAX_VELOCITY, AVG_VELOCITY, SAMPLING_FREQUENCY, 
 			RESOLUTION, RATED_MAX_VELOCITY, RATED_MAX_WT, CLUSTER_RULE_CL, SOURCE_GCL, COMMENTS, TOOL_VENDOR_CL) VALUES
 			(TO_DATE(substring('{DATE}',1,10),'DD.MM.YYYY'), TO_DATE(substring('{DATE}',1,10),'DD.MM.YYYY'), 
 			null, null, 'UNKNOWN', '{MODEL}', 'UNKNOWN', null,
 			null, null, null, null, null, null, null, 
 			null, null, null, null, 'UNKNOWN', 'UNKNOWN', 'INFOTEH',
 			comp_id) RETURNING ili_inspection_id INTO returnInspectionId; 
 
IF v_routeID  IS NOT NULL THEN
 			INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL) 
 			VALUES ('ILI_INSP_RNG',
 			(SELECT MIN(station_id) FROM pods.station_point sp 
 			WHERE sp.route_id = v_routeID AND sp.measure = (SELECT MIN(spp.measure) FROM pods.station_point spp WHERE spp.route_id = v_routeID )),
 			(SELECT MAX(station_id) FROM pods.station_point sp 
 			WHERE sp.route_id = v_routeID   AND sp.measure = (SELECT MAX(spp.measure) FROM pods.station_point spp WHERE spp.route_id = v_routeID )),
 			'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN') RETURNING EVENT_ID INTO returnId;
 			END IF;


INSERT INTO PODS.ILI_INSPECTION_RANGE(EVENT_ID,sequence,ascending,ILI_INSPECTION_ID,DESCRIPTION,COMMENTS,WELD_INCREMENT,SOURCE_GCL,START_ODOMETER, END_ODOMETER, LAUNCHER_EVENT_ID, RECEIVER_EVENT_ID, WELD_START_NUMBER) 
 			VALUES(returnId,1,1,returnInspectionId,substring('{PIPE}',1,50),'{KM_START}-{KM_END}',null,'UNKNOWN',null, null,
 			(SELECT MIN(lr.event_id) FROM pods.launcher_receiver lr
 			JOIN pods.event_range e ON e.event_id = lr.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			WHERE sp.route_id = v_routeID AND lr.type_cl = 'LAUNCH_R_TYPE_06'),
 			(SELECT MAX(lr.event_id) from pods.launcher_receiver lr
 			JOIN pods.event_range e ON e.event_id = lr.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			WHERE sp.route_id = v_routeID AND lr.type_cl = 'LAUNCH_R_TYPE_07'),
 			'{call_complex_method.FIRST_WELD_NUMBER}');
			END$$;
			</query>
		</dbCommand>
	</update>
</data>

	<data id="ILI_INTEGR_2_7_2" comment="Установка связи с трубопроводом и создание записи отчета" schema="UTE" table="ILI_INTEGR_2_7">
		<update>
			<dbCommand>
				<var name="DATE"/>
				<var name="MODEL"/>
				<var name="FORMAT"/>
				<var name="COMPANY"/>
				<var name="config.main.PODS_USER"/>
				<var name="PIPE"/>
				<var name="KM_START"/>
				<var name="KM_END"/>
				<var name="call_complex_method_err.FIRST_WELD_NUMBER"/>
				<var name="ILI_INSPECTION_ID" type="Decimal" default="SELECT max(ili_inspection_id) id FROM PODS.ILI_INSPECTION"/>
				<query>
					DO $$
					DECLARE
					returnId NUMERIC default -50;
					returnInspectionId NUMERIC;
					comp_id varchar(10) default 'UNKNOWN';
					v_routeID NUMERIC default null;
					comp_cnt NUMERIC;
					BEGIN

					if (select count(*) from pods.ili_tool_vendor_cl where description like '{COMPANY}')>0 then
					select code into comp_id  from pods.ili_tool_vendor_cl where description like '{COMPANY}';
					end if;


					WITH routes AS (SELECT r.route_id, l.description descr, MIN(s.station_begin) km_start, MAX(s.station_end) km_end
					FROM pods.route r
					JOIN pods.series s
					ON s.route_id = r.route_id
					JOIN pods.line l
					ON r.line_id = l.line_id
					WHERE r.current_indicator_lf like 'Y' and r.type_cl IN ('ROUTE_TYPE_01','ROUTE_TYPE_04','ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12')
					GROUP BY r.route_id, l.description),
					inspections AS (SELECT '{PIPE}' descr
					,{KM_START} km_start
					,{KM_END} km_end)
					SELECT MIN(route_id) route_id into v_routeID
					FROM routes r
					JOIN inspections i
					ON REPLACE(REPLACE(REPLACE(REPLACE (REPLACE (REPLACE (REPLACE (LOWER (LTRIM (RTRIM (i.descr::text)))
					,'iv','4'), 'iii','3'),'ii','2'),'i','1'),'-',''),'-',''),' ','')
					= REPLACE(REPLACE(REPLACE(REPLACE (REPLACE (REPLACE (REPLACE (LOWER (LTRIM (RTRIM (r.descr)))
					,'iv','4'), 'iii','3'),'ii','2'),'i','1'),'-',''),'-',''),' ','')

					AND i.km_start::numeric BETWEEN r.km_start AND r.km_end
					AND i.km_end::numeric BETWEEN r.km_start AND r.km_end;

					INSERT INTO PODS.ILI_INSPECTION(BEGIN_DATE, END_DATE, START_ODOMETER, END_ODOMETER, TOOL_TYPE_CL, MODEL, SENSOR_GCL,
					SENSOR_SPACING_MIN, SENSOR_SPACING_MAX, MIN_TEMP, MAX_TEMP, AVG_TEMP, MIN_VELOCITY, MAX_VELOCITY, AVG_VELOCITY, SAMPLING_FREQUENCY,
					RESOLUTION, RATED_MAX_VELOCITY, RATED_MAX_WT, CLUSTER_RULE_CL, SOURCE_GCL, COMMENTS, TOOL_VENDOR_CL) VALUES
					(TO_DATE(substring('{DATE}',1,10),'DD.MM.YYYY'), TO_DATE(substring('{DATE}',1,10),'DD.MM.YYYY'),
					null, null, 'UNKNOWN', '{MODEL}', 'UNKNOWN', null,
					null, null, null, null, null, null, null,
					null, null, null, null, 'UNKNOWN', 'UNKNOWN', 'INFOTEH',
					comp_id) RETURNING ili_inspection_id INTO returnInspectionId;

					IF v_routeID  IS NOT NULL THEN
					INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL)
					VALUES ('ILI_INSP_RNG',
					(SELECT MIN(station_id) FROM pods.station_point sp
					WHERE sp.route_id = v_routeID AND sp.measure = (SELECT MIN(spp.measure) FROM pods.station_point spp WHERE spp.route_id = v_routeID )),
					(SELECT MAX(station_id) FROM pods.station_point sp
					WHERE sp.route_id = v_routeID   AND sp.measure = (SELECT MAX(spp.measure) FROM pods.station_point spp WHERE spp.route_id = v_routeID )),
					'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN') RETURNING EVENT_ID INTO returnId;
					END IF;


					INSERT INTO PODS.ILI_INSPECTION_RANGE(EVENT_ID,sequence,ascending,ILI_INSPECTION_ID,DESCRIPTION,COMMENTS,WELD_INCREMENT,SOURCE_GCL,START_ODOMETER, END_ODOMETER, LAUNCHER_EVENT_ID, RECEIVER_EVENT_ID, WELD_START_NUMBER)
					VALUES(returnId,1,1,returnInspectionId,substring('{PIPE}',1,50),'{KM_START}-{KM_END}',null,'UNKNOWN',null, null,
					(SELECT MIN(lr.event_id) FROM pods.launcher_receiver lr
					JOIN pods.event_range e ON e.event_id = lr.event_id
					JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
					WHERE sp.route_id = v_routeID AND lr.type_cl = 'LAUNCH_R_TYPE_06'),
					(SELECT MAX(lr.event_id) from pods.launcher_receiver lr
					JOIN pods.event_range e ON e.event_id = lr.event_id
					JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
					WHERE sp.route_id = v_routeID AND lr.type_cl = 'LAUNCH_R_TYPE_07'),
					'{call_complex_method_err.FIRST_WELD_NUMBER}');
					END$$;
				</query>
			</dbCommand>
		</update>
	</data>


	<data id="ILI_INTEGR_2_4" comment="Заполнение связи между отчетом ВТД и участком газопровода (сокращенный вариант - в исходном скрипте 3 варианта связи, оставлен 1)" schema="UTE" table="ILI_INTEGR_2_4">
	<update>
		<dbCommand>
		<var name="v_inspection_id"/>
		<var name="v_route_id"/>	 
			<query>
	
DO $$
	DECLARE
     v_station_begin NUMERIC;
     v_station_end   NUMERIC;
     v_r_event_id    NUMERIC;
     v_r_route_id    NUMERIC;
     v_r_series_id   NUMERIC;
     v_retcode       Integer DEFAULT 1;
			Begin
if {v_route_id} is not null then
	SELECT coalesce(MIN(sp1.station_id),0)
              ,coalesce(MAX(sp2.station_id),0)
          INTO v_station_begin, v_station_end
          FROM pods.route r
               JOIN pods.station_point sp1
                 ON sp1.route_id = r.route_id
               JOIN pods.station_point sp2
                 ON sp2.route_id = r.route_id
         WHERE r.route_id = {v_route_id}
           AND NOT EXISTS (SELECT 1
                             FROM pods.station_point sp
                            WHERE sp.route_id = {v_route_id}
                              AND sp.measure &lt; sp1.measure)
           AND NOT EXISTS (SELECT 1
                             FROM pods.station_point sp
                            WHERE sp.route_id = {v_route_id}
                              AND sp.measure &gt; sp2.measure)
         GROUP BY r.route_id;

       INSERT INTO pods.event_range (feature_id,station_id_begin,station_id_end,pods_user
                                    ,create_date,effective_from_date,current_indicator_lf)
              VALUES ('ILI_INSP_RNG', v_station_begin, v_station_end, 'ADMIN', current_timestamp, current_timestamp, 'Y')
              RETURNING event_id into v_r_event_id;

       UPDATE pods.ili_inspection_range
          SET event_id = v_r_event_id
       WHERE ili_inspection_id = {v_inspection_id};
end if;
			END $$;
			</query>
		</dbCommand>
	</update>
</data>


<data id="ILI_INTEGR_2_5" comment="Различные постобработки которые выполняются после переноса отчета" schema="UTE" table="ILI_INTEGR_2_5">
	<update>
		<dbCommand>
		<var name="db_command_err.CMD.ILI_INSPECTION_ID"/>
			<query>
	DO $$
	
		DECLARE
     v_station_begin NUMERIC;
     v_station_end   NUMERIC;
     v_r_event_id    NUMERIC;
     v_r_route_id    NUMERIC;
     v_r_series_id   NUMERIC;
     v_retcode       NUMERIC DEFAULT 1;
     v_ili_inspection_range_id NUMERIC;
    v_launcher_event_id NUMERIC DEFAULT NULL;
    v_receiver_event_id NUMERIC DEFAULT NULL;
			Begin

	   UPDATE pods.ili_data dst
             SET anomaly_extension_cl = coalesce((SELECT a.code
                                           FROM pods.anomaly_extension_cl a
                                                JOIN pods.ili_anomaly_type_cl b
                                                  ON a.code = b.index_description
                                          WHERE b.code = dst.anomaly_type_cl),'ANOMALY_EXT_004')
                    WHERE dst.ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID};
/*перенесено сюда из старого инсертаиз БД Инфотеха*/


	   UPDATE pods.ili_data dst
 set anomaly_type_cl  = (SELECT coalesce(MIN (CODE),0)
                  FROM pods.ili_anomaly_type_cl t
                 WHERE UPPER (t.description || ',' || t.anomaly_references) 
                       LIKE '%'||REGEXP_REPLACE (UPPER (TRIM (dst.feature_description)),'\(.*\)|[*.?]|\s+','%')|| '%')
            WHERE dst.EVENT_ID IS NULL
              AND dst.ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID};

/*Далее то, что и раньше было в скрипте интеграции в постобработке*/

               
                update pods.ili_data d set 
                us_weld_distance=d.absolute_odometer-d.us_weld_odometer
                ,ds_weld_distance=d.ds_weld_odometer -  d.absolute_odometer
                where EXISTS (select 1 from pods.ili_data ddd
                 JOIN pods.ili_data ww 
                 ON ww.ili_inspection_id = ddd.ili_inspection_id
                 AND ddd.absolute_odometer&gt;=ww.absolute_odometer 
                             AND ww.absolute_odometer&gt;=ddd.absolute_odometer-100
                 WHERE ww.ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID}
                 AND ww.anomaly_type_cl = 5001
                 AND ddd.ili_data_id = d.ili_data_id);
 
              
               
      /* PIPE_LENGTH!!!!!!!*/

        INSERT INTO pods.ili_pipe_length(ili_inspection_id, weld_number, sequence_number, start_odometer
                                     ,end_odometer, measured_wall_thickness, nominal_wall_thickness
                                     ,source_gcl,description)
               (SELECT ili_inspection_id
                           ,weld_number
                           ,ROW_NUMBER () OVER (PARTITION BY ili_inspection_id ORDER BY absolute_odometer) sequence_number
                           ,absolute_odometer start_odometer
                           ,LEAD (absolute_odometer) OVER (PARTITION BY ili_inspection_id ORDER BY absolute_odometer) end_odometer
                           ,measured_wall_thickness
                           ,nominal_wall_thickness
                           ,source_gcl
                           ,comments
                      FROM pods.ili_data d
                     WHERE anomaly_type_cl = '5001'
                       AND ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID});
                       
        insert  INTO pods.comments (table_id,comment_by,id,comments,source_gcl,current_indicator_lf)
SELECT DISTINCT 'PIPE_SYSTEM_CL' table_id,'IS_DIRTY' comment_by,psb.pipe_system_id id,'1' , 'INFOTEH' source_gcl,'Y' current_indicator_lf
                       FROM pods.ili_inspection_range ir
                            JOIN pods.event_range er
                              ON ir.event_id = er.event_id
                            JOIN pods.station_point sp
                              ON sp.station_id = er.station_id_begin
                            JOIN pods.series s
                              ON s.series = sp.series
                            JOIN pods.pipe_system_boundary psb
                              ON psb.line_id = s.line_id
                              AND psb.km_end &gt;=s.station_begin
                              AND psb.km_begin &lt;=s.station_end                
                      WHERE ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID};


       /*Установка камер приема-запуска:*/
    SELECT MIN(ili_inspection_range_id)
      INTO v_ili_inspection_range_id
      FROM pods.ili_inspection_range
     WHERE ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID}
       AND event_id != -50;
      
    SELECT MIN(LR.EVENT_ID)
      INTO v_launcher_event_id
      FROM PODS.ILI_INSPECTION_RANGE IR 
           JOIN PODS.EVENT_RANGE ER
             ON IR.EVENT_ID = ER.EVENT_ID
           JOIN PODS.STATION_POINT SPB
             ON ER.STATION_ID_BEGIN = SPB.STATION_ID
           JOIN PODS.STATION_POINT SPL
             ON SPB.ROUTE_ID = SPL.ROUTE_ID
           JOIN PODS.EVENT_RANGE ERL
             ON ERL.STATION_ID_BEGIN = SPL.STATION_ID
           JOIN PODS.LAUNCHER_RECEIVER LR
             ON ERL.EVENT_ID = LR.EVENT_ID 
     WHERE ERL.FEATURE_ID = 'LAUNC_REC'
       AND LR.TYPE_CL = 'LAUNCH_R_TYPE_06'  /* Запуск */
       AND SPB.STATION = SPL.STATION
       AND IR.ILI_INSPECTION_RANGE_ID = v_ili_inspection_range_id; 


    SELECT MIN(LR.EVENT_ID)
      INTO v_receiver_event_id
      FROM PODS.ILI_INSPECTION_RANGE IR 
           JOIN PODS.EVENT_RANGE ER
             ON IR.EVENT_ID = ER.EVENT_ID
           JOIN PODS.STATION_POINT SPB
             ON ER.STATION_ID_BEGIN = SPB.STATION_ID
           JOIN PODS.STATION_POINT SPL
             ON SPB.ROUTE_ID = SPL.ROUTE_ID
           JOIN PODS.EVENT_RANGE ERL
             ON ERL.STATION_ID_BEGIN = SPL.STATION_ID
           JOIN PODS.LAUNCHER_RECEIVER LR
             ON ERL.EVENT_ID = LR.EVENT_ID 
     WHERE ERL.FEATURE_ID = 'LAUNC_REC'
       AND LR.TYPE_CL = 'LAUNCH_R_TYPE_07' /* Прием */
       AND SPB.STATION = SPL.STATION
       AND IR.ILI_INSPECTION_RANGE_ID = v_ili_inspection_range_id;
       
    UPDATE PODS.ILI_INSPECTION_RANGE
       SET LAUNCHER_EVENT_ID = v_launcher_event_id
          ,RECEIVER_EVENT_ID = v_receiver_event_id
     WHERE ILI_INSPECTION_RANGE_ID = v_ili_inspection_range_id;

END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="ILI_INTEGR_2_6" comment="вставка дефектов, особенностей, труб в таблицу ili_data" schema="UTE" table="ILI_INTEGR_2_6">
	<insert>
		<dbCommand>
		<var name="SOURCE_GCL"/>
		<var name="DATE"/>		
		<var name="X" type="Decimal"/>	
		<var name="Y" type="Decimal"/>		
		<var name="ILI_INSPECTION_ID" type="Decimal"/>
		<var name="SRV_DISTRICT_GCL" type="Decimal"/>	
		<var name="Z" type="Decimal"/>		
		<var name="WELD_NUMBER" type="String"/>	
		<var name="ABSOLUTE_ODOMETER" type="Decimal"/>	
		<var name="AVERAGE_DEPTH" type="String"/>		
		<var name="LENGTH" type="String"/>
		<var name="WIDTH" type="String"/>	
		<var name="BPR_PIG" type="String"/>		
		<var name="ORIENTATION_DEG" type="String"/>	
		<var name="SOURCE" type="String"/>	
		<var name="ANOMALY_TYPE_CL" type="String"/>		
		<var name="FEATURE_DESCRIPTION" type="String"/>
		<var name="DESCRIPTION" type="String"/>	
		<var name="MILEPOST" type="String"/>		
		<var name="NOMINAL_WALL_THICKNESS" type="String"/>	
		<var name="DL_TUBE" type="Decimal"/>	
		<var name="COMMENTS" type="String"/>
		<var name="REMARK" type="String"/>
		<var name="KBD" type="Decimal"/>
		<var name="ORIENTATION_MIN" type="Decimal"/>
		<var name="ORIENTATION_MAX" type="Decimal"/>	
			<query>
			INSERT INTO 
 			PODS.ILI_DATA(ILI_INSPECTION_ID,WELD_NUMBER,US_WELD_NUMBER,ABSOLUTE_ODOMETER,AVERAGE_DEPTH,LENGTH,WIDTH,BPR_PIG,INTERNAL_EXTERNAL_CL,SOURCE_GCL,DATE_COLLECTED,ORIENTATION_DEG,ANOMALY_TYPE_CL,ANOMALY_EXTENSION_CL,MEASURED_WALL_THICKNESS,FEATURE_DESCRIPTION,DESCRIPTION,MILEPOST,NOMINAL_WALL_THICKNESS,DS_WELD_DISTANCE,COORDINATE_ID,COMMENTS) 
 			VALUES({ILI_INSPECTION_ID},'{WELD_NUMBER}','{WELD_NUMBER}',{ABSOLUTE_ODOMETER},'{AVERAGE_DEPTH}','{LENGTH}','{WIDTH}','{KBD}','UNKNOWN','INFOTEH',TO_DATE(substring('{DATE}',1,10),'DD.MM.YYYY'),ROUND('{ORIENTATION_DEG}')
 			,CASE WHEN '{ANOMALY_TYPE_CL}'='5001'
 			THEN 5001
 			ELSE (SELECT MIN(CODE) 
 			FROM pods.ili_anomaly_type_cl t
 			WHERE UPPER (t.description || ',' || t.anomaly_references) LIKE '%'||REGEXP_REPLACE (UPPER (TRIM ('{ANOMALY_TYPE_CL}')),'\(.*\)|[*.?]|\s+','%')|| '%')
 			END 
 			,'UNKNOWN',NULL,replace('{FEATURE_DESCRIPTION}','''',''),replace('{DESCRIPTION}','''',''),'{MILEPOST}','{NOMINAL_WALL_THICKNESS}',null,null,replace('{COMMENTS}','''',''))
			</query>
		</dbCommand>
	</insert>
</data> 

<data id="ILI_INTEGR_2_10" comment="Получение идентификатора трубопровода" schema="UTE" table="ILI_INTEGR_2_10">
	<select>
		<dbQuery>
			<var name="EXTERNAL_P_OBJ_ID"/>
			<query>
				SELECT spb.ROUTE_ID
				FROM pods.ili_inspection_range i
				JOIN pods.event_range er ON er.event_id = i.event_id
				JOIN pods.station_point spb ON er.station_id_begin = spb.station_id WHERE ILI_INSPECTION_ID::text =
				(select g.key_values from gis_integration50.gate g where g.system_pair_id='102' and g.table_name like 'ILI_INSPECTION' and g.obj_id='{EXTERNAL_P_OBJ_ID}' limit 1)
			</query>
		</dbQuery>
	</select>
</data>
<data id="ILI_INTEGR_2_11" comment="Получение идентификатора отчета ВТД" schema="UTE" table="ILI_INTEGR_2_11">
	<select>
		<dbQuery>
			<var name="EXTERNAL_P_OBJ_ID"/>
			<query>
				select max(g.key_values::numeric) from gis_integration50.gate g where g.system_pair_id='102' and g.table_name like 'ILI_INSPECTION' and g.obj_id='{EXTERNAL_P_OBJ_ID}'
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_INTEGR_2_12" comment="Получение идентификаторов отчетов ВТД для запуска групповых расчетов ('STO_EHZ_INSP_Proc.xml' - расчет показателей ЭХЗ, 'STO_ILI_INSP_Proc.xml' - расчет лин. показатей, 'ILI_Cluster.xml' - группировка в кластеры, 'ILI_Pressure.xml' - расчет точ. показателей, должен передаваться в параметр CALC_TYPE" schema="UTE" table="ILI_INTEGR_2_11">
	<select>
		<dbQuery>
			<var name="CALC_TYPE"/>
			<query>
				select g.key_values::numeric ILI_INSPECTION_ID from gis_integration50.gate g where g.owner='CALC' and g.table_name like '{CALC_TYPE}'
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_INTEGR_2_13" comment="Удаление из списка подлежащих расчету отчетов ВТД, которые бцли успешно обработаны. ('STO_EHZ_INSP_Proc.xml' - расчет показателей ЭХЗ, 'STO_ILI_INSP_Proc.xml' - расчет лин. показатей, 'ILI_Cluster.xml' - группировка в кластеры, 'ILI_Pressure.xml' - расчет точ. показателей, должен передаваться в параметр CALC_TYPE" schema="UTE" table="ILI_INTEGR_2_11">
	<update>
		<dbCommand>
			<var name="CALC_TYPE"/>
			<var name="INSPECTION_ID"/>
			<query>
				delete from gis_integration50.gate g where g.owner='CALC' and g.table_name like '{CALC_TYPE}' and g.key_values like '{INSPECTION_ID}'
			</query>
		</dbCommand>
	</update>
</data>


<data id="CALC_CALC_CIS" comment="ВАЖНО!!! Отчет ЭХЗ должен быть разбит строго по роутам. Привязка идет по лин.дистанции в метрах, значения берутся из поля Description. CALC_CALC_CIS - новая версия связывания отчета ЭХЗ по интенсивам- сразу идет расчет координат, но ветка логики для случая когда координаты перданы в отчете пока закомментирована, т.к. предполагает привязку трассовых объектов" schema="UTE" table="CALC_CALC_CP">
<update>
		<dbCommand>
		<var name="ROUTE_ID"/>
		<var name="REPORT_ID"/>	 
			<query>
do $$
DECLARE
  id integer;
  loc_id integer;
  sp_id integer;
  c_id integer;
  min_measure integer;
  min_station_id integer;
  min_line_id integer;
  min_series integer;
  min_route_id integer;
  min_series_id integer;
  min_description  integer;
  max_measure integer;
  max_station_id  integer;
  max_description  integer;
  cur_measure integer;
  cur_route_id integer;
  cur_line_id integer;
  cur_series integer;
  cur_series_id integer;
  prev_x_coord integer;
  prev_y_coord integer;
  prev_z_coord integer;
  prev_srv_district_gcl integer;
  prev_depth_of_cover integer;
  prev_measure integer;
  prev_station_id integer;
  prev_station integer;
  next_x_coord integer;
  next_y_coord integer;
  next_z_coord integer;
  next_srv_district_gcl integer;
  next_depth_of_cover integer;
  next_measure integer;
  next_station_id integer;
  next_station integer;
  cur_x_coord integer;
  cur_y_coord integer;
  cur_station integer;
  cur_z_coord integer;
  cur_depth_of_cover integer;
  max_cnt integer;
  min_cnt integer;
  srv_id integer;
  i record;
  r record;
  BEGIN

/* привязка замеров при условии наличия в них координат - не сделано, координаты необходимо вставлять в какую-либо колонку через копипасту и оттуда разбирать на вставку сюда
  for i in (select null DEPTH,!!!rc.dd_grad SRV_DISTRICT_GCL,c."COORD_B" coord_b, c."COORD_L" coord_l,этих данных в типовой таблице pi_cis_reading нет!!!rc.event_id
  from pods.pi_cis_reading rc where c."PI_CP_EVENT_ID"=192977679)
    loop

  SELECT MAX(c.coordinate_id),MAX(c.location_id)
  INTO c_id,loc_id
  FROM pods.coordinate c
  WHERE abs(c.X_COORD-i.coord_b)&lt;0.000001 and abs(c.Y_COORD-i.coord_l)&lt;0.000001;

  IF c_id IS NULL THEN
   INSERT INTO pods.location(DEPTH_OF_COVER, SRV_DISTRICT_GCL)
   VALUES (null, i.SRV_DISTRICT_GCL::numeric)
   RETURNING LOCATION_ID INTO loc_id;

   INSERT INTO pods.coordinate(COORDINATE_SOURCE_ID, LOCATION_ID, X_COORD, Y_COORD, Z_COORD,
   TYPE_CL, HORIZ_INDICATOR_LF, VERT_INDICATOR_LF, CURRENT_INDICATOR_LF,
   EFFECTIVE_FROM_DATE, ACCURACY_CL, VALIDITY_TOLERANCE, CREATE_DATE, PODS_USER)
   VALUES (9, loc_id, i.coord_b, i.coord_l, null, 'ASG', 'Y', 'Y', 'N', current_timestamp, 'MEDIUM', 0, current_timestamp, 'ADMIN')
   RETURNING COORDINATE_ID INTO c_id;
  END IF;

  INSERT INTO pods.station_point(LINE_ID,ROUTE_ID,SERIES_ID,SERIES,LOCATION_ID,STATION,MEASURE,TYPE_CL)
  VALUES(0,0,0,0,loc_id,-1,0,'ST_POINT_TYPE_04')
  RETURNING STATION_ID INTO sp_id;

            update pods.event_range set STATION_ID_BEGIN=sp_id,STATION_ID_END=sp_id where event_id=i.event_id;

  END loop;
*/
/*Здесь выполняется привязка для замеров, у которых не было координат. Обязательное условие - должны быть как минимум пары замеров с координатами для замеров бе зкоординат расположенных между ними
 *  ВАЖНО!! необходимо через азадчу привязки трассовых обхектов привязать замеры с координатами к трубопроводу перед этим запуском!!!*/

  for i in (select rr.description,rr.pi_cp_event_id,e.station_id_begin from pods.pi_cis_reading rr,pods.event_Range e where rr.pi_cp_event_id=192977679
  and e.event_id=rr.event_id and e.station_id_begin=0
  order by rr.description::numeric)
  loop
            BEGIN
             select ss.measure,ss.station_id,ss.line_id,ss.series,ss.route_id,ss.series_id,rr.description*1000
             into min_measure,min_station_id,min_line_id,min_series,min_route_id,min_series_id,min_description from pods.station_point ss,pods.event_Range ee,pods.pi_cis_reading rr where
             ss.route_id=(select max(s.route_id) from pods.station_point s,pods.event_Range e,pods.pi_cis_reading r where r.pi_cp_event_id=i.pi_cp_event_id and to_number(r.description*1000)&lt;to_number(i.description)
             and e.event_id=r.event_id and s.station_id=e.station_id_begin and e.station_id_begin&gt;0)
             and ss.measure=(select max(s.measure) from pods.station_point s,pods.event_Range e,pods.pi_cis_reading r where r.pi_cp_event_id=i.pi_cp_event_id and to_number(r.description*1000)&lt;to_number(i.description)
             and e.event_id=r.event_id and s.station_id=e.station_id_begin and e.station_id_begin&gt;0)
             and ss.station_id=ee.station_id_begin and ee.event_id=rr.event_id and ss.route_id&gt;0;

             select ss.measure,ss.station_id,rr.description*1000
             into max_measure,max_station_id,max_description from pods.station_point ss,pods.event_Range ee,pods.pi_cis_reading rr where
             ss.route_id=(select min(s.route_id) from pods.station_point s,pods.event_Range e,pods.pi_cis_reading r where r.pi_cp_event_id=i.pi_cp_event_id and to_number(r.description*1000)&gt;to_number(i.description)
             and e.event_id=r.event_id and s.station_id=e.station_id_begin and e.station_id_begin&gt;0 and s.measure&gt;0)
             and ss.measure=(select min(s.measure) from pods.station_point s,pods.event_Range e,pods.pi_cis_reading r where r.pi_cp_event_id=i.pi_cp_event_id and to_number(r.description*1000)&gt;to_number(i.description)
             and e.event_id=r.event_id and s.station_id=e.station_id_begin and e.station_id_begin&gt;0 and s.measure&gt;0)
             and ss.station_id=ee.station_id_begin and ee.event_id=rr.event_id  and ss.route_id&gt;0;


             cur_series:=min_series;

             cur_measure:=round(min_measure+(i.description-min_description)*(max_measure-min_measure)/(to_number(max_description)-to_number(min_description)),2);
             cur_route_id:=min_route_id;
             cur_line_id:=min_line_id;

             cur_series_id:=min_series_id;

               select c.x_coord,c.y_coord,c.z_coord,l.srv_district_gcl,l.depth_of_cover,ss.measure,ss.station_id,ss.station
               into prev_x_coord,prev_y_coord,prev_z_coord,prev_srv_district_gcl,prev_depth_of_cover,prev_measure,prev_station_id,prev_station from pods.station_point ss,pods.coordinate c,pods.location l
                where ss.route_id=cur_route_id
               and ss.measure=(select max(s.measure) from pods.station_point s where s.measure&lt;=cur_measure and s.route_id=ss.route_id)
               and ss.location_id=c.location_id limit 1;


             select c.x_coord,c.y_coord,c.z_coord,l.srv_district_gcl,l.depth_of_cover,ss.measure,ss.station_id,ss.station
             into next_x_coord,next_y_coord,next_z_coord,next_srv_district_gcl,next_depth_of_cover,next_measure,next_station_id,next_station from pods.station_point ss,pods.coordinate c,pods.location l
              where
             ss.route_id=cur_route_id
             and ss.measure=(select min(s.measure) from pods.station_point s where s.measure&gt;cur_measure  and s.route_id=ss.route_id and s.measure&gt;0)
             and ss.location_id=c.location_id  limit 1;


             cur_x_coord:=round(prev_x_coord+(next_x_coord-prev_x_coord)*(cur_measure-prev_measure)/(next_measure-prev_measure),7);
             cur_y_coord:=round(prev_y_coord+(next_y_coord-prev_y_coord)*(cur_measure-prev_measure)/(next_measure-prev_measure),7);
             cur_station:=round(prev_station+(next_station-prev_station)*(cur_measure-prev_measure)/(next_measure-prev_measure),2);
             cur_z_coord:=round(prev_z_coord+(next_z_coord-prev_z_coord)*(cur_measure-prev_measure)/(next_measure-prev_measure),2);
             cur_depth_of_cover:=round(prev_depth_of_cover+(next_depth_of_cover-prev_depth_of_cover)*(cur_measure-prev_measure)/(next_measure-prev_measure),2);

              INSERT INTO pods.location(DEPTH_OF_COVER, SRV_DISTRICT_GCL)
               VALUES (cur_depth_of_cover, prev_srv_district_gcl)
               RETURNING LOCATION_ID INTO loc_id;

               INSERT INTO pods.coordinate(COORDINATE_SOURCE_ID, LOCATION_ID, X_COORD, Y_COORD, Z_COORD,
               TYPE_CL, HORIZ_INDICATOR_LF, VERT_INDICATOR_LF, CURRENT_INDICATOR_LF,
               EFFECTIVE_FROM_DATE, ACCURACY_CL, VALIDITY_TOLERANCE, CREATE_DATE, PODS_USER)
               VALUES (9, loc_id, cur_x_coord, cur_y_coord, cur_z_coord, 'ASG', 'Y', 'Y', 'Y', current_timestamp, 'MEDIUM', 0, current_timestamp, 'ADMIN')
               RETURNING COORDINATE_ID INTO c_id;

               INSERT INTO pods.station_point(LINE_ID,ROUTE_ID,SERIES_ID,SERIES,LOCATION_ID,STATION,MEASURE,TYPE_CL)
               VALUES(cur_line_id,cur_route_id,cur_series_id,cur_series,loc_id,cur_station,cur_measure,'ST_POINT_TYPE_04')
                RETURNING STATION_ID INTO sp_id;

            update pods.event_range set STATION_ID_BEGIN=sp_id,STATION_ID_END=sp_id where event_id=i.event_id;

    EXCEPTION WHEN OTHERS
    THEN RAISE EXCEPTION ' произошла ошибка: % код %',SQLERRM, SQLSTATE ;
       END;
   END loop;
 END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_CALC_CP" comment="CALC_CALC_CP - новая версия связывания отчета ЭХЗ и КИПов - фактически сразу и связывание и расчет координат" schema="UTE" table="CALC_CALC_CP">
<update>
		<dbCommand>
		<var name="ROUTE_ID"/>
		<var name="REPORT_ID"/>	 
		<var name="LINE_ID"/>
		<var name="STATION_BEGIN"/>
		<var name="STATION_END"/>
			<query>
DO $$
   
DECLARE
            i record;
			ir record;
            c_max_delta CONSTANT NUMERIC DEFAULT 0.35;
            v_start_id   NUMERIC;
            v_end_id     NUMERIC;
            v_start_x    NUMERIC;
            v_start_y    NUMERIC;
            v_end_x      NUMERIC;
            v_end_y      NUMERIC;
            v_delta      NUMERIC;
            v_station_id NUMERIC;

            BEGIN

			if {ROUTE_ID} is null then 
			 for ir IN
			  (select r.route_id from pods.route r,pods.series s  where s.route_id=r.route_id and r.line_id={LINE_ID} and r.type_cl in ('ROUTE_TYPE_04','ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12')
				and ((s.station_begin&gt;={STATION_BEGIN} and  {STATION_END}&lt;=s.station_end ) or (s.station_begin&lt;={STATION_BEGIN} and {STATION_END}&lt;=s.station_end ) or (s.station_begin&gt;={STATION_BEGIN} and {STATION_END}&gt;=s.station_end )))
			  loop
			   FOR i IN
                (select ABS(coalesce(comments::numeric,0)) km,r.event_id from pods.pi_cp_reading r where r.pi_cp_event_id = {REPORT_ID})
                 loop
                  select spp.station_id,ABS(spp.station - i.km)
                   into v_station_id,v_delta  from pods.station_point spp
                  where spp.route_id=ir.route_id and ABS(spp.station - i.km)  = (select min(ABS(sp.station - i.km)) from pods.station_point sp where sp.route_id=ir.route_id);
          
                 if v_station_id is not null and v_delta&lt;c_max_delta  then
                  update pods.event_Range set station_id_begin=v_station_id,station_id_end=v_station_id where event_id=i.event_id;
                end if;
               END loop;
			 end loop;
			else 
			  UPDATE PODS.EVENT_RANGE E
				SET STATION_ID_BEGIN =
				(SELECT STATION_ID
					FROM PODS.STATION_POINT S
					WHERE     S.ROUTE_ID = {ROUTE_ID}
						AND S.MEASURE = (SELECT MIN (MEASURE)
                                      FROM PODS.STATION_POINT SP
                                     WHERE SP.ROUTE_ID = {ROUTE_ID})
                   limit 1),
				STATION_ID_END =
				(SELECT STATION_ID
					FROM PODS.STATION_POINT S
					WHERE     S.ROUTE_ID = {ROUTE_ID}
                   AND S.MEASURE = (SELECT MAX (MEASURE)
                                      FROM PODS.STATION_POINT SP
                                     WHERE SP.ROUTE_ID = {ROUTE_ID})
                   limit 1)
					WHERE E.EVENT_ID ={REPORT_ID};

				FOR i IN
				(select ABS(coalesce(substring(comments, 1, strpos(comments, ';')-1)::numeric,0)) km,r.event_id from
				pods.pi_cp_reading r where r.pi_cp_event_id = {REPORT_ID})
				loop
					select spp.station_id,ABS(spp.station - i.km)
					into v_station_id,v_delta  from pods.station_point spp
					where spp.route_id={ROUTE_ID} and ABS(spp.station - i.km)  =
                        (select min(ABS(sp.station - i.km)) from pods.station_point sp where sp.route_id={ROUTE_ID});
          
					if v_station_id is not null and v_delta&lt;c_max_delta  then
						update pods.event_Range set station_id_begin=v_station_id,station_id_end=v_station_id where event_id=i.event_id;
					end if;
				END loop;
			end if;
    EXCEPTION WHEN OTHERS
    THEN RAISE EXCEPTION ' произошла ошибка: % код %',SQLERRM, SQLSTATE ;
               
    END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_CALC_CP_1" comment="CALC_CALC_CP_1" schema="UTE" table="CALC_CALC_CP">
	<select>
		<dbQuery>
		<var name="P_REPORT_ID"/>
			<query>
			
			select coalesce(MIN(line_id),-1) "LINE_ID"
			from pods.line l
			join pods.pi_cp_inspection i ON TRIM(UPPER(REPLACE(REPLACE(REPLACE(l.description,'III','3'),'II','2'),'I','1'))) 
			like TRIM(UPPER(REPLACE(REPLACE(REPLACE(REGEXP_REPLACE(i.description,',\s\d\sполугодие.*$',''),'III','3'),'II','2'),'I','1')))
			WHERE i.event_id = {P_REPORT_ID}
			</query>
		</dbQuery>
	</select>
</data>

<data id="CALC_CALC_CP_2" comment="CALC_CALC_CP_2" schema="UTE" table="CALC_CALC_CP">
	<update>
		<dbCommand>
		<var name="db_scalar_reader.LINE_ID"/>
		<var name="P_REPORT_ID"/>	 
			<query>

	DO $$
	
	
	DECLARE
	r record;
	c_radius CONSTANT NUMERIC DEFAULT 0.25;
	v_ref_test_lead_event_id NUMERIC;
	v_station_id NUMERIC;
	v_distance NUMERIC;
	v_measure NUMERIC;
	v_sequence NUMERIC;
	
	v_first_station_id NUMERIC;
	v_last_station_id NUMERIC;
	
	c_test_lead CURSOR (cp_km NUMERIC,cp_line_id NUMERIC, cp_radius NUMERIC, cp_report_id NUMERIC )
	for SELECT er.event_id ref_test_lead_event_id,sp.station_id,abs( sp.station- cp_km) distance,sp.measure,r.sequence
	FROM pods.event_range er
	JOIN pods.station_point sp
	ON er.station_id_begin = sp.station_id
	JOIN pods.series s
	ON sp.series_id = s.series_id 
	JOIN pods.route r
	ON s.route_id = r.route_id 
	WHERE er.feature_id = 'TEST_LEAD'
	AND r.line_id = cp_line_id
	AND sp.station BETWEEN cp_km - cp_radius AND cp_km + cp_radius
	ORDER BY abs(sp.station -cp_km ),sp.measure;
	
	c_valve CURSOR (cp_km NUMERIC,cp_line_id NUMERIC, cp_radius NUMERIC, cp_report_id NUMERIC )
	for SELECT sp.station_id,abs( sp.station- cp_km) distance,sp.measure,r.sequence
	FROM pods.event_range er
	JOIN pods.station_point sp
	ON er.station_id_begin = sp.station_id
	JOIN pods.series s
	ON sp.series_id = s.series_id 
	JOIN pods.route r
	ON s.route_id = r.route_id 
	WHERE er.feature_id = 'VALVE'
	AND r.line_id = cp_line_id
	AND sp.station BETWEEN cp_km - cp_radius AND cp_km + cp_radius
	ORDER BY abs(sp .station -cp_km ),sp.measure;
	
	c_other_sp CURSOR (cp_km NUMERIC,cp_line_id NUMERIC, cp_radius NUMERIC, cp_report_id NUMERIC )
	for SELECT sp.station_id,abs( sp.station- cp_km) distance,sp.measure,r.sequence
	FROM pods.station_point sp
	JOIN pods.series s
	ON sp.series_id = s.series_id 
	JOIN pods.route r
	ON s.route_id = r.route_id 
	WHERE r.line_id = cp_line_id
	AND sp.station BETWEEN cp_km - cp_radius AND cp_km + cp_radius
	ORDER BY abs(sp .station -cp_km ),sp.measure;
	
	
	
	BEGIN
	
	create or replace function pg_temp.is_downstream_measures (p_station_id NUMERIC, p_report_id NUMERIC) RETURNS BOOLEAN as '
	DECLARE
	v_measures_downstream INTEGER; 
	v_result BOOLEAN DEFAULT FALSE;
	BEGIN
	
	WITH af 
	AS (SELECT rr.sequence * 1e8 + sp.measure artifical_measure,station_id
	FROM pods.pi_cp_Reading crc
	JOIN pods.event_range erc
	ON crc.event_id = erc.event_id 
	JOIN pods.station_point sp
	ON erc.station_id_Begin = sp.station_id
	JOIN pods.series s
	ON s.series_id = sp.series_id
	JOIN pods.route rr
	ON s.route_id = rr.route_id 
	WHERE crc.pi_cp_event_id = p_report_id)
	SELECT count(*)
	INTO v_measures_downstream
	FROM af 
	WHERE af.artifical_measure &gt;= (SELECT af1.artifical_measure
	FROM af af1
	WHERE af1.station_id = p_station_id); 
	
	IF v_measures_downstream &gt;0
	THEN
	v_result := TRUE;
	END IF;
	
	RETURN v_result; 
	
	END ' language plpgsql;
	
	IF {db_scalar_reader.LINE_ID} = -1
	THEN
	/* Не привязано. Выходим*/ 
	RETURN;
	END IF;
	
	/* По-новому рисую изученость.Полностью line*/
	select station_id INTO v_first_station_id from (
	SELECT sp.station_id, ROW_NUMBER() OVER( ORDER BY rr.sequence,sp.measure ) rn
	FROM pods.line l
	JOIN pods.route rr
	ON l.line_id = rr.line_id
	AND l.type_cl = CASE rr.type_cl
	WHEN 'ROUTE_TYPE_10' THEN 'LINE_TYPE_01'
	WHEN 'ROUTE_TYPE_11' THEN 'LINE_TYPE_02'
	WHEN 'ROUTE_TYPE_12' THEN 'LINE_TYPE_03'
	WHEN 'ROUTE_TYPE_04' THEN 'LINE_TYPE_04'
	END
	JOIN pods.series s
	ON rr.route_id = s.route_id 
	JOIN pods.station_point sp
	ON sp.series_id = s.series_id 
	WHERE l.line_id = {db_scalar_reader.LINE_ID} 
	AND sp.type_Cl in ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03')) tr where rn=1;
	
	select station_id into v_last_station_id from (
	SELECT sp.station_id, ROW_NUMBER() OVER( ORDER BY rr.sequence*100000+sp.measure desc) rn
	FROM pods.line l
	JOIN pods.route rr
	ON l.line_id = rr.line_id
	AND l.type_cl = CASE rr.type_cl
	WHEN 'ROUTE_TYPE_10' THEN 'LINE_TYPE_01'
	WHEN 'ROUTE_TYPE_11' THEN 'LINE_TYPE_02'
	WHEN 'ROUTE_TYPE_12' THEN 'LINE_TYPE_03'
	WHEN 'ROUTE_TYPE_04' THEN 'LINE_TYPE_04'
	END
	JOIN pods.series s
	ON rr.route_id = s.route_id 
	JOIN pods.station_point sp
	ON sp.series_id = s.series_id 
	WHERE l.line_id = {db_scalar_reader.LINE_ID}  
	AND sp.type_Cl in ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03')) tr where rn=1;
	
	
	
	FOR r IN SELECT event_id ,substr(comments ,1,strpos( comments, ';')-1 ) km
	,comments
	,trim(substr(comments ,strpos( comments, ';')+1)) control_type
	FROM PODS .PI_CP_READING
	WHERE pi_cp_event_id = {P_REPORT_ID}
	ORDER BY (substr(comments ,1,strpos( comments, ';')-1 ))::numeric
	LOOP
	BEGIN
	v_ref_test_lead_event_id := NULL;
	v_station_id := NULL;
	IF r.control_type IN ('КИП с ЭНЭС' ,'КИП со СМЭС' ,'КИП' ,'КИП, БСЗ' ,'КИП,БСЗ(труба+патрон)' ,'КИП с ЭНЕС (ВЭИ)'
	,'КИП - ГАЗ' ,'КИП с БПИ' ,'КИП с ЭНЕС,БДРМ' ,'КИК' ,'КИП - обсадная колонна' ,'КИП-АЗ'
	,'КУ(крановый узел)' ,'КП (ковер)' ,'КУЖ83' ,'КДП , БСЗ' ,'БДР-М1' ,'БДРМ 25-2-21-У1' ,'БДР-М'
	,'КПТМ' ,'КИП со СМЭС, БДРМ' ,'КДП' ,'Вход ГРС' ,'Нестандартный')
	THEN 
	OPEN c_test_lead (r .km ,{db_scalar_reader.LINE_ID} ,c_radius,{P_REPORT_ID} );
	FETCH c_test_lead INTO v_ref_test_lead_event_id,v_station_id, v_distance,v_measure,v_sequence;
	
	LOOP
	IF is_downstream_measures (v_station_id, {P_REPORT_ID})
	THEN 
	/* Уже на этой точке или далее висит измерение
	беру следующую */ 
	FETCH c_test_lead INTO v_ref_test_lead_event_id,v_station_id, v_distance,v_measure,v_sequence;
	/* Есть риск, что точек больше нет, нужно сбрасывать в NULL и выходить */
	IF c_test_lead%NOTFOUND
	THEN
	v_ref_test_lead_event_id := NULL;
	v_station_id := NULL;
	EXIT;
	END IF;
	ELSE
	EXIT;
	END IF; 
	END LOOP;
	
	CLOSE c_test_lead ;
	
	IF v_ref_test_lead_event_id IS NOT NULL
	THEN 
	UPDATE pods.pi_cp_reading
	SET ref_test_lead_event_id = v_ref_test_lead_event_id
	WHERE event_id = r .event_id;
	END IF; 
	
	ELSIF r.control_type = 'КУ(крановый узел)'
	THEN 
	OPEN c_valve (r .km ,{db_scalar_reader.LINE_ID} ,c_radius,{P_REPORT_ID} );
	FETCH c_valve INTO v_station_id, v_distance,v_measure,v_sequence;
	
	LOOP
	IF is_downstream_measures (v_station_id, {P_REPORT_ID})
	THEN 
	/* Уже на этой точке или далее висит измерение
	беру следующую */ 
	FETCH c_valve INTO v_station_id, v_distance,v_measure,v_sequence; 
	/* Есть риск, что точек больше нет, нужно сбрасывать в NULL и выходить */
	IF c_valve%NOTFOUND
	THEN
	v_station_id := NULL;
	EXIT;
	END IF;
	ELSE
	RAISE INFO 'v_station_id: %',v_station_id ; 
        EXIT;
	END IF; 
	END LOOP; 
	
	CLOSE c_valve ;
	END IF; 
	
	IF v_station_id IS NULL
	THEN
	/* Не нашли ни КИП, ни крана */
	OPEN c_other_sp (r .km ,{db_scalar_reader.LINE_ID} ,c_radius,{P_REPORT_ID} );
	FETCH c_other_sp INTO v_station_id, v_distance,v_measure,v_sequence;
	
	LOOP
	
	IF is_downstream_measures (v_station_id, {P_REPORT_ID})
	THEN 
	/* Уже на этой точке или далее висит измерение
	беру следующую */ 
	FETCH c_other_sp INTO v_station_id, v_distance,v_measure,v_sequence;
	/* Есть риск, что точек больше нет, нужно сбрасывать в NULL и выходить */
	IF c_other_sp%NOTFOUND
	THEN
	v_station_id := NULL;
	EXIT;
	END IF;
	ELSE
	RAISE INFO 'v_station_id: %',v_station_id ; 
	EXIT;
	END IF; 
	END LOOP; 
	
	CLOSE c_other_sp ;
	
	END IF;
	
	IF v_station_id IS NOT NULL
	THEN
	/* Прицепляю измерение на точки найденного объекта, КИП или КРАН */
	UPDATE pods.event_range
	SET station_id_begin = v_station_id
	,station_id_end = v_station_id
	,effective_from_date = current_timestamp
	,pods_user = USER
	WHERE event_id = r .event_id ;
		RAISE INFO 'UPDATE pods.event_range' ; 
	END IF; 
	
	EXCEPTION
	WHEN OTHERS THEN
	RAISE NOTICE 'При обработке измерения event_id=:%  произошла ошибка: %',r.event_id||''||SQLERRM, SQLSTATE;
	END;
	END LOOP;
	
	END $$;
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_CALC_CP_3" comment="CALC_CALC_CP_3" schema="UTE" table="CALC_CALC_CP">
	<insert>
		<dbCommand>
		<var name="src_id" type="String"/>
		<var name="fract" type="Decimal"/>	
		<var name="s_id" type="Decimal"/>	
		<var name="e_id" type="Decimal"/>		
		<var name="id" type="Decimal"/>	
		<var name="dist" type="Decimal"/>		 
			<query>
			DO $$
			DECLARE
 			km NUMERIC(10,2);
 			lc NUMERIC(10,2);
 			BEGIN
 			DELETE FROM WEB50.PS_INDEX_OBJ WHERE KEY_VALUES = '{src_id}';
 
 			SELECT sp1.measure+{fract}*(sp2.measure-sp1.measure),sp1.station+{fract}*(sp2.station-sp1.station) INTO lc,km
 			FROM pods.station_point sp1, pods.station_point sp2
 			WHERE sp1.station_id = {s_id} AND sp2.station_id = {e_id};

 			INSERT INTO WEB50.PS_INDEX_OBJ(TEMPLATE_ID, PIPE_SYSTEM_ID, STATE_ID, KEY_FIELDS, KEY_VALUES, KM_START, KM_END, LINE_COORD_START, LINE_COORD_END, DISTANCE, GID, CUSER_ID) 
 			VALUES(1, {id}, 0, 'EVENT_ID', '{src_id}', km, km, lc, lc, {dist}, NULL, 0);
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_CALC_CP_4" comment="CALC_CALC_CP_4" schema="UTE" table="CALC_CALC_CP">
	<update>
		<dbCommand>
		<var name="P_REPORT_ID"/>	 
			<query>
 			DELETE FROM pods.comments c WHERE c.table_id = 'PI_CP_INSPECTION' AND c.comment_by = 'IS_DIRTY' AND c.comments = '1' AND c.id::integer = {P_REPORT_ID}
			</query>
		</dbCommand>
	</update>
</data> 
 
<data id="CALC_CALC_DEF_1" comment="CALC_CALC_DEF_1" schema="UTE" table="CALC_CALC_DEF">
	<select>
		<dbQuery>
		<var name="P_REPORT_ID"/>
			<query>
 			SELECT ILI_DATA_ID "ILI_DATA_ID", ABSOLUTE_ODOMETER "ABSOLUTE_ODOMETER", CALIBRATED_MEASURE "MEASURE", CONTROL_POINT_LF "CONTROL_POINT_LF", CERTAINTY_INTERVAL "ACCURACY", EVENT_ID "EVENT_ID"
 			FROM pods.ili_data d 
 			WHERE d.ili_inspection_id = {P_REPORT_ID}
 			AND absolute_odometer IS NOT NULL
 			order by absolute_odometer
			</query>
		</dbQuery>
	</select>
</data>

<data id="CALC_CALC_DEF_2" comment="CALC_CALC_DEF_2" schema="UTE" table="CALC_CALC_DEF">
	<select>
		<dbQuery>
		<var name="P_ROUTE_ID"/>
			<query>
			SELECT SP.MEASURE "MEASURE", SP.STATION "STATION", SP.LINE_ID "LINE_ID", SP.ROUTE_ID "ROUTE_ID", SP.SERIES_ID "SERIES_ID", SP.SERIES "SERIES", SP.STATION_ID "STATION_ID",
 			L.DEPTH_OF_COVER "DEPTH", L.SRV_DISTRICT_GCL "SRV_DISTRICT_GCL", C.COORDINATE_ID "COORDINATE_ID", C.LOCATION_ID "LOCATION_ID", C.X_COORD "X", C.Y_COORD "Y", C.Z_COORD "Z"
			from pods.station_point sp
			JOIN pods.location l ON l.location_id = sp.location_id
			JOIN pods.coordinate c ON c.location_id = l.location_id
			where sp.route_id = {P_ROUTE_ID} AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03','ST_POINT_TYPE_04')
			order by measure
			</query>
		</dbQuery>
	</select>
</data>

<data id="CALC_CALC_DEF_3" comment="CALC_CALC_DEF_3" schema="UTE" table="CALC_CALC_DEF">
	<insert>
		<dbCommand>
		<var name="config.main.COORD_TOLERANCE"/>
		<var name="config.main.LINK_RADIUS"/>
		<var name="config.main.PODS_USER"/>
		<var name="NEAREST_DIST" type="Decimal"/>
		<var name="COORDINATE_ID" type="Decimal"/>	
		<var name="LOCATION_ID" type="Decimal"/>	
		<var name="DEPTH" type="Decimal"/>		
		<var name="SRV_DISTRICT_GCL" type="Decimal"/>	
		<var name="dist" type="Decimal"/>	
		<var name="X" type="Decimal"/>
		<var name="Y" type="Decimal"/>	
		<var name="Z" type="Decimal"/>	
		<var name="STATION_ID" type="Decimal"/>		
		<var name="LINE_ID" type="Decimal"/>	
		<var name="ROUTE_ID" type="Decimal"/>	
		<var name="SERIES_ID" type="Decimal"/>
		<var name="SERIES" type="Decimal"/>	
		<var name="STATION" type="Decimal"/>	
		<var name="MEASURE" type="Decimal"/>
		<var name="ACCURACY" type="Decimal"/>	
		<var name="ILI_DATA_ID" type="Decimal"/>			
			<query>
			DO $$
			
			DECLARE
 			sp_id NUMERIC(16,0);
 			loc_id NUMERIC(16,0);
 			c_id NUMERIC(16,0);
 			e_id NUMERIC(16,0);
 			BEGIN
 			IF {NEAREST_DIST}&lt;{config.main.COORD_TOLERANCE} 
			THEN
 			   c_id := {COORDINATE_ID};
 			   loc_id := {LOCATION_ID};
			   sp_id := {STATION_ID};
 			ELSE
    			     INSERT INTO pods.location(DEPTH_OF_COVER, SRV_DISTRICT_GCL) 
 			     VALUES ({DEPTH}, {SRV_DISTRICT_GCL}) 
 			     RETURNING LOCATION_ID INTO loc_id;

   			     INSERT INTO pods.coordinate(COORDINATE_SOURCE_ID, LOCATION_ID, X_COORD, Y_COORD, Z_COORD, 
 			     TYPE_CL, HORIZ_INDICATOR_LF, VERT_INDICATOR_LF, CURRENT_INDICATOR_LF, 
 			     EFFECTIVE_FROM_DATE, ACCURACY_CL, VALIDITY_TOLERANCE, CREATE_DATE, PODS_USER) 
 			     VALUES (9, loc_id, {X}, {Y}, {Z}, 'ASG', 'Y', 'Y', 'Y', current_timestamp, 'MEDIUM', {ACCURACY}, current_timestamp, '{config.main.PODS_USER}')
 			     RETURNING COORDINATE_ID INTO c_id;
			END IF;

 			IF sp_id is null  THEN
 			  INSERT INTO pods.station_point(LINE_ID,ROUTE_ID,SERIES_ID,SERIES,LOCATION_ID,STATION,MEASURE,TYPE_CL) 
 			  VALUES({LINE_ID},{ROUTE_ID},{SERIES_ID},{SERIES},loc_id,{STATION},{MEASURE},'ST_POINT_TYPE_04') 
 			  RETURNING STATION_ID INTO sp_id;
                        end if;

 			INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,VALIDITY_TOLERANCE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL) 
 			VALUES ('ILI_DATA', sp_id, sp_id, '{config.main.PODS_USER}', current_timestamp, {ACCURACY}, current_timestamp, 'Y', 'UNKNOWN') 
 			RETURNING EVENT_ID INTO e_id;
 
 			UPDATE pods.ili_data 
 			SET coordinate_id = c_id, event_id = e_id, CALIBRATED_MEASURE = {MEASURE}
 			WHERE ili_data_id = {ILI_DATA_ID};
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>
 
<data id="CALC_CALC_DEF_4" comment="CALC_CALC_DEF_4" schema="UTE" table="CALC_CALC_DEF">
	<insert>
		<dbCommand>		
		<var name="src_id" type="String"/>
		<var name="fract" type="Decimal"/>	
		<var name="s_id" type="Decimal"/>	
		<var name="e_id" type="Decimal"/>		
		<var name="id" type="Decimal"/>	
		<var name="dist" type="Decimal"/>	
			<query>
			DO $$
			DECLARE
 			km NUMERIC(10,2);
 			lc NUMERIC(10,2);
 			BEGIN
 			DELETE FROM WEB50.PS_INDEX_OBJ WHERE KEY_VALUES = '{src_id}';
 
 			SELECT sp1.measure+{fract}*(sp2.measure-sp1.measure),sp1.station+{fract}*(sp2.station-sp1.station)
 			INTO lc,km
 			FROM pods.station_point sp1, pods.station_point sp2
 			WHERE sp1.station_id = {s_id} AND sp2.station_id = {e_id};

 			INSERT INTO WEB50.PS_INDEX_OBJ(TEMPLATE_ID, PIPE_SYSTEM_ID, STATE_ID, KEY_FIELDS, KEY_VALUES, KM_START, KM_END, LINE_COORD_START, LINE_COORD_END, DISTANCE, GID, CUSER_ID) 
 			VALUES(1, {id}, 0, 'ILI_DATA_ID', '{src_id}', km, km, lc, lc, {dist}, NULL, 0);
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>
 
<data id="CALC_CALC_DEF_5" comment="CALC_CALC_DEF_5" schema="UTE" table="CALC_CALC_DEF">
	<select>
		<dbQuery>
		<var name="P_REPORT_ID"/>
			<query>
			SELECT p.ILI_PIPE_LENGTH_ID "ILI_PIPE_LENGTH_ID", p.WELD_NUMBER "WELD_NUMBER", p.EVENT_ID "EVENT_ID", e1.VALIDITY_TOLERANCE "VALIDITY_TOLERANCE",
 			d1.COORDINATE_ID "COORDINATE_ID", e1.STATION_ID_BEGIN "STATION_ID", d1.DS_WELD_DISTANCE "ODOM_LENGTH", sp2.MEASURE-sp1.MEASURE "LENGTH",
 			d2.COORDINATE_ID "NEXT_COORDINATE_ID", e2.STATION_ID_BEGIN "NEXT_STATION_ID"
			from pods.ili_pipe_length p
			join pods.ili_data d1 on p.ili_inspection_id = d1.ili_inspection_id and p.weld_number = d1.weld_number and d1.anomaly_type_cl = 5001
			join pods.event_range e1 on e1.event_id = d1.event_id
			join pods.station_point sp1 ON sp1.station_id = e1.station_id_begin
			join pods.ili_data d2 on p.ili_inspection_id = d2.ili_inspection_id and p.weld_number = d2.us_weld_number and d2.anomaly_type_cl = 5001
			join pods.event_range e2 on e2.event_id = d2.event_id
			join pods.station_point sp2 ON sp2.station_id = e2.station_id_begin
			where p.ili_inspection_id = {P_REPORT_ID}
			order by d1.absolute_odometer
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_CALC_DEF_6" comment="CALC_CALC_DEF_6" schema="UTE" table="CALC_CALC_DEF">
	<insert>
		<dbCommand>		
		<var name="config.main.PODS_USER"/>		
		<var name="LENGTH" type="Decimal"/>
		<var name="ODOM_LENGTH" type="Decimal"/>	
		<var name="STATION_ID" type="Decimal"/>	
		<var name="NEXT_STATION_ID" type="Decimal"/>		
		<var name="VALIDITY_TOLERANCE" type="Decimal"/>	
		<var name="EVENT_ID" type="Decimal" default="SELECT max(EVENT_ID) id FROM PODS.EVENT_RANGE" />	
			<query>
			INSERT INTO pods.event_range(FEATURE_ID,LENGTH,SLACK_LENGTH,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,VALIDITY_TOLERANCE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL) 
 			VALUES ('ILI_PIPE_LENGTH', {LENGTH}, {ODOM_LENGTH}, {STATION_ID}, {NEXT_STATION_ID}, '{config.main.PODS_USER}', current_timestamp, {VALIDITY_TOLERANCE}, current_timestamp, 'Y', 'UNKNOWN')
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_CALC_DEF_7" comment="CALC_CALC_DEF_7" schema="UTE" table="CALC_CALC_DEF">
	<insert>
		<dbCommand>	
		<var name="EVENT_ID" type="Decimal"/>
		<var name="COORDINATE_ID" type="Decimal"/>	
		<var name="NEXT_COORDINATE_ID" type="Decimal"/>	
		<var name="ILI_PIPE_LENGTH_ID" type="Decimal"/>
			<query>
 			UPDATE pods.ili_pipe_length 
 			SET EVENT_ID = {EVENT_ID}, START_COORDINATE_ID = {COORDINATE_ID}, END_COORDINATE_ID = {NEXT_COORDINATE_ID}
 			WHERE ILI_PIPE_LENGTH_ID = {ILI_PIPE_LENGTH_ID}
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_CALC_DEF_8" comment="CALC_CALC_DEF_8" schema="UTE" table="CALC_CALC_DEF">
	<update>
		<dbCommand>
		<var name="P_REPORT_ID"/>	 
			<query>
			UPDATE pods.event_range set CURRENT_INDICATOR_LF = 'N', EFFECTIVE_TO_DATE = current_timestamp
 			WHERE event_id IN (SELECT event_id FROM pods.ili_data where ili_inspection_id = {P_REPORT_ID} and control_point_lf = 'N')
			</query>
		</dbCommand>
	</update>
</data> 

<data id="CALC_CALC_DEF_9" comment="CALC_CALC_DEF_9" schema="UTE" table="CALC_CALC_DEF">
	<update>
		<dbCommand>
		<var name="P_REPORT_ID"/>	 
			<query>
			UPDATE pods.event_range set CURRENT_INDICATOR_LF = 'N', EFFECTIVE_TO_DATE = current_timestamp
 			WHERE event_id IN (SELECT event_id FROM pods.ili_pipe_length where ili_inspection_id = {P_REPORT_ID})
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_CALC_DEF_10" comment="CALC_CALC_DEF_10" schema="UTE" table="CALC_CALC_DEF">
	<update>
		<dbCommand>
		<var name="P_REPORT_ID"/>	 
			<query>
			UPDATE pods.ili_data set event_id = null,coordinate_id = null, ref_event_id = null, ref_event_guid = null, control_point_lf = 'N', calibrated_measure = null, certainty_interval = null
 			WHERE event_id IN (SELECT e.event_id FROM pods.ili_data dd JOIN pods.event_range e ON e.event_id = dd.event_id where dd.ili_inspection_id = {P_REPORT_ID} and e.current_indicator_lf = 'N' and control_point_lf = 'N')
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_CALC_DEF_11" comment="CALC_CALC_DEF_11" schema="UTE" table="CALC_CALC_DEF">
	<update>
		<dbCommand>
		<var name="P_REPORT_ID"/>	 
			<query>
			UPDATE pods.ili_pipe_length set event_id = null
 			WHERE event_id IN (SELECT e.event_id FROM pods.ili_pipe_length pll JOIN pods.event_range e ON e.event_id = pll.event_id where pll.ili_inspection_id = {P_REPORT_ID} and e.current_indicator_lf = 'N')
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_CALC_DEF_12" comment="CALC_CALC_DEF_12" schema="UTE" table="CALC_CALC_DEF">
	<update>
		<dbCommand>
		<var name="call_complex_method.STATION_RANGE"/>	 
		<var name="P_REPORT_ID"/>		
			<query>
			UPDATE pods.event_range SET {call_complex_method.STATION_RANGE} WHERE event_id IN (SELECT event_id FROM pods.ili_inspection_range r WHERE r.ili_inspection_id = {P_REPORT_ID})
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_CALC_DEF_13" comment="CALC_CALC_DEF_13" schema="UTE" table="CALC_CALC_DEF">
	<update>
		<dbCommand> 
		<var name="P_REPORT_ID"/>		
			<query>
			DELETE FROM pods.comments WHERE table_id = 'ILI_INSPECTION' AND comment_by = 'IS_DIRTY' AND comments = '1' AND id::integer = {P_REPORT_ID}
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_CALC_HODO_1" comment="CALC_CALC_HODO_1" schema="UTE" table="CALC_CALC_HODO">
	<select>
		<dbQuery>
		<var name="P_ROUTE_ID"/>
			<query>
			SELECT count(*) "COUNT"
			FROM pods.pipe_length pl
			JOIN pods.event_range e ON e.event_id = pl.event_id
			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
			WHERE sp.route_id = {P_ROUTE_ID}
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="CALC_CALC_HODO_2" comment="CALC_CALC_HODO_2" schema="UTE" table="CALC_CALC_HODO">
	<select>
		<dbQuery>
		<var name="P_REPORT_ID"/>
		<var name="P_ROUTE_ID"/>		
			<query>
			WITH a AS 
			(SELECT sp.measure absolute_odometer, e.length, 
 			row_number() OVER(ORDER BY sp.measure) rnum 
 			FROM pods.ili_pipe_length pl
 			JOIN pods.event_range e ON e.event_id = pl.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			WHERE ili_inspection_id = {P_REPORT_ID}),
			k as
			(SELECT a.absolute_odometer absolute_odometer1, aa.absolute_odometer absolute_odometer2, 
 			a.length length1, aa.length length2, (aa.length - a.length) / (aa.length + a.length) coeff, 
 			row_number() OVER(ORDER BY a.absolute_odometer) rnum
 			FROM a JOIN a aa ON aa.rnum = a.rnum + 1 
 			WHERE a.length&gt;0 AND Abs((aa.length - a.length) / (aa.length + a.length)) &gt; 0.2),
			kk as
			(select k1.absolute_odometer1 absolute_odometer, k1.length1 length, 
 			k1.coeff coeff1, k2.coeff coeff2, k2.absolute_odometer1-k1.absolute_odometer1 delta 
 			from k k1 JOIN k k2 ON k1.rnum = k2.rnum-1),
			t as
			(SELECT k2.route_id, round(k2.absolute_odometer-k1.absolute_odometer,-1) dist, count(*) cnt
 			from kk k1 JOIN web50.hodo_key k2 ON k1.coeff1 between k2.coeff1-0.01 and k2.coeff1+0.01
 			AND k1.coeff2 between k2.coeff2-0.01 and k2.coeff2+0.01
 			and k1.length between k2.length-0.2 and k2.length+0.2
 			and abs(k1.delta-k2.delta)/(k1.delta+k2.delta)&lt;0.01
 			and k2.route_id = {P_ROUTE_ID}
 			group by k2.route_id, round(k2.absolute_odometer-k1.absolute_odometer,-1)
 			having count(*)&gt;2)
			select route_id "ROUTE_ID", sum(cnt) "CNT", min(dist) "MN", max(dist) "MX"
			from t
			group by "ROUTE_ID"
			having sum(cnt)&gt;3
			order by "CNT" desc 
			</query>
		</dbQuery>
	</select>
</data>

 <data id="CALC_CALC_HODO_3" comment="CALC_CALC_HODO_3" schema="UTE" table="CALC_CALC_HODO">
	<update>
		<dbCommand> 
		<var name="config.main.PODS_USER"/>	
		<var name="P_REPORT_ID"/>		
			<query>
			DO $$
			BEGIN

 			INSERT INTO pods.event_range(ORIGINAL_EVENT_ID,FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,LENGTH,PODS_USER,CREATE_DATE,VALIDITY_TOLERANCE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL)
 			SELECT e.EVENT_ID,'PIPE_LENGTH', e.STATION_ID_BEGIN,e.STATION_ID_END,e.LENGTH,'{config.main.PODS_USER}',current_timestamp,e.VALIDITY_TOLERANCE,current_timestamp,e.CURRENT_INDICATOR_LF,e.POSITIONING_TYPE_CL
 			FROM pods.event_range e
 			JOIN pods.ili_pipe_length pl on pl.event_id = e.event_id
 			WHERE pl.ili_inspection_id = {P_REPORT_ID};

 			UPDATE pods.ili_pipe_length pl
 			SET ref_event_id = (SELECT MIN (re.event_id)
 			FROM pods.event_range re
 			WHERE re.original_event_id = pl.event_id),
 			comments = 'EQ'
 			WHERE pl.ili_inspection_id = {P_REPORT_ID};
 
 			UPDATE pods.event_range SET original_event_id = null 
 			WHERE event_id IN 
 			(SELECT pl.ref_event_id 
 			FROM pods.ili_pipe_length pl 
 			WHERE pl.ili_inspection_id = {P_REPORT_ID});
 
 			INSERT INTO pods.pipe_length(EVENT_ID, LENGTH_IDENTIFIER, DESCRIPTION, SOURCE_GCL, END_TREATMENT_CL, COMMENTS)
 			SELECT pl.ref_event_id, pl.weld_number, pl.description, pl.source_gcl, 'UNKNOWN','ВТД:'||t.description||'('||i.begin_date||')'
 			FROM pods.ili_pipe_length pl
 			JOIN pods.ili_inspection i ON i.ili_inspection_id = pl.ili_inspection_id
 			JOIN pods.ili_tool_vendor_cl t ON t.code = i.tool_vendor_cl
 			WHERE i.ili_inspection_id = {P_REPORT_ID} AND pl.event_id IS NOT NULL;

			END $$;
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_CALC_HODO_4" comment="CALC_CALC_HODO_4" schema="UTE" table="CALC_CALC_HODO">
	<update>
		<dbCommand> 
		<var name="P_REPORT_ID"/>		
			<query>
			INSERT INTO web50.hodo_key(route_id, absolute_odometer, length, coeff1, coeff2, delta)
			WITH a AS 
			(SELECT sp.route_id, sp.measure absolute_odometer, e.length, row_number() OVER(ORDER BY sp.measure) rnum 
 			FROM pods.ili_pipe_length pl
 			JOIN pods.event_range e ON e.event_id = pl.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			WHERE e.length &gt; 0 and pl.ili_inspection_id = {P_REPORT_ID}),
			k as
			(SELECT a.route_id, a.absolute_odometer absolute_odometer1, aa.absolute_odometer absolute_odometer2, 
 			a.length length1, aa.length length2, (aa.length - a.length) / (aa.length + a.length) coeff, 
 			row_number() OVER(ORDER BY a.absolute_odometer) rnum
 			FROM a JOIN a aa ON aa.rnum = a.rnum + 1 
 			WHERE Abs((aa.length - a.length) / (aa.length + a.length)) &gt; 0.2)
			SELECT k1.route_id, k1.absolute_odometer1 absolute_odometer, k1.length1 length, 
 			k1.coeff coeff1, k2.coeff coeff2, k2.absolute_odometer1-k1.absolute_odometer1 delta 
 			FROM k k1 JOIN k k2 ON k1.rnum = k2.rnum-1
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_CALC_HODO_5" comment="CALC_CALC_HODO_5" schema="UTE" table="CALC_CALC_HODO">
	<select>
		<dbQuery>
		<var name="P_REPORT_ID"/>
			<query>
			SELECT pl.ili_inspection_id "ILI_INSPECTION_ID", pl.ili_pipe_length_id "WELD_NUMBER", sp.measure "ABSOLUTE_ODOMETER", e.length "LENGTH" 
 			FROM pods.ili_pipe_length pl
 			JOIN pods.event_range e ON e.event_id = pl.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			WHERE ili_inspection_id = {P_REPORT_ID} AND e.length IS NOT NULL ORDER BY sp.measure
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="CALC_CALC_HODO_6" comment="CALC_CALC_HODO_6" schema="UTE" table="CALC_CALC_HODO">
	<select>
		<dbQuery>
		<var name="ds_table.CMP.Rows.0.ROUTE_ID"/>
			<query>
			SELECT sp.route_id "ILI_INSPECTION_ID", e.event_id "WELD_NUMBER", sp.measure "ABSOLUTE_ODOMETER", e.length "LENGTH"
 			FROM pods.pipe_length pl
 			JOIN pods.event_range e ON e.event_id = pl.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			WHERE sp.route_id = {ds_table.CMP.Rows.0.ROUTE_ID} AND e.length IS NOT NULL ORDER BY sp.measure
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="CALC_CALC_HODO_7" comment="CALC_CALC_HODO_7" schema="UTE" table="CALC_CALC_HODO">
	<select>
		<dbQuery>
		<var name="P_REPORT_ID"/>		
		<var name="ds_table.CMP.Rows.0.route_id"/>		
		<var name="ds_table.CMP.Rows.0.mn"/>		
		<var name="ds_table.CMP.Rows.0.mx"/>
			<query>
			WITH a AS 
			(SELECT pl.ili_inspection_id, sp.measure, e.length, row_number() OVER(ORDER BY sp.measure) rnum
 			FROM pods.ili_pipe_length pl
 			JOIN pods.event_range e ON e.event_id = pl.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			WHERE e.length &gt; 0 and pl.ili_inspection_id = {P_REPORT_ID}),
			aa AS 
			(SELECT pl.ili_inspection_id, sp.measure, e.length, row_number() OVER(ORDER BY sp.measure) rnum
 			FROM pods.ili_pipe_length pl
 			JOIN pods.event_range e ON e.event_id = pl.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			WHERE e.length &gt; 0 and pl.ili_inspection_id = {P_REPORT_ID}),
			k as
			(SELECT a.ili_inspection_id, a.,measure absolute_odometer1, aa.measure absolute_odometer2, 
 			a.length length1, aa.length length2, (aa.length - a.length) / (aa.length + a.length) coeff, 
 			row_number() OVER(PARTITION BY a.ili_inspection_id ORDER BY a.measure) rnum
 			FROM a JOIN a aa ON a.ili_inspection_id = aa.ili_inspection_id AND aa.rnum = a.rnum + 1 
 			WHERE Abs((aa.length - a.length) / (aa.length + a.length)) &gt; 0.2),
			kk as
			(select k1.ili_inspection_id, k1.absolute_odometer1 absolute_odometer, k1.length1 length, 
 			k1.coeff coeff1, k2.coeff coeff2, k2.absolute_odometer1-k1.absolute_odometer1 delta 
 			from k k1 JOIN k k2 ON k1.ili_inspection_id = k2.ili_inspection_id and k1.rnum = k2.rnum-1)
			SELECT k1.absolute_odometer "ABSOLUTE_ODOMETER1", k2.absolute_odometer "ABSOLUTE_ODOMETER2"
			from kk k1 JOIN web50.hodo_key k2 ON k1.coeff1 between k2.coeff1-0.01 and k2.coeff1+0.01
 			AND k1.coeff2 between k2.coeff1-0.01 and k2.coeff2+0.01
 			and k1.length between k2.length-0.2 and k2.length+0.2
 			and abs(k1.delta-k2.delta)/(k1.delta+k2.delta)&lt;0.01
			where k2.route_id = {ds_table.CMP.Rows.0.route_id} and ROUND(k2.absolute_odometer-k1.absolute_odometer, -1) between {ds_table.CMP.Rows.0.mn} and {ds_table.CMP.Rows.0.mx} 
			order by k1.absolute_odometer
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="CALC_CALC_HODO_8" comment="CALC_CALC_HODO_8" schema="UTE" table="CALC_CALC_HODO">
	<insert>
		<dbCommand>	
		<var name="g_weld_number" type="Decimal"/>
		<var name="acc" type="String"/>	
		<var name="weld_number" type="Decimal"/>	
			<query>
			UPDATE pods.ili_pipe_length set ref_event_id = {g_weld_number}, comments = '{acc}'
 			WHERE ili_pipe_length_id = {weld_number} 
			</query>
		</dbCommand>
	</insert>
</data>
 
<data id="CALC_CALC_HODO_9" comment="CALC_CALC_HODO_9" schema="UTE" table="CALC_CALC_HODO">
	<update>
		<dbCommand> 
		<var name="P_REPORT_ID"/>		
			<query>
                UPDATE pods.ili_pipe_length d SET ref_event_id = (WITH t AS
	 			(SELECT pl.ILI_PIPE_LENGTH_ID, pl.start_odometer, pl.end_odometer, pl.ref_event_id, e.length
	 			FROM pods.ili_pipe_length pl
	 			LEFT JOIN pods.event_range e ON e.event_id = pl.ref_event_id
	 			WHERE pl.ili_inspection_id = {P_REPORT_ID})
				SELECT t2.ref_event_id/*, 'MISS|'||TRIM((t1.start_odometer-t2.start_odometer,'9990.99')::text) comments*/
	 			FROM t t1 JOIN t t2
	 			ON t2.start_odometer &lt;t1.start_odometer AND t2.ref_event_id IS NOT NULL and t1.ili_pipe_length_id = d.ili_pipe_length_id
	 			AND NOT EXISTS (SELECT 1 FROM t t3
	 			WHERE t3.ref_event_id IS NOT NULL
	 			AND t3.start_odometer &gt; t2.start_odometer
	 			AND t3.start_odometer &lt; t1.start_odometer)
	 			JOIN pods.event_range e ON e.event_id = t2.ref_event_id AND e.length*1.5 &gt; t1.end_odometer - t2.start_odometer
	 			WHERE t1.ref_event_id IS NULL)
                where 
                ili_pipe_length_id in (WITH t AS
	 			(SELECT pl.ILI_PIPE_LENGTH_ID, pl.start_odometer, pl.end_odometer, pl.ref_event_id, e.length
	 			FROM pods.ili_pipe_length pl
	 			LEFT JOIN pods.event_range e ON e.event_id = pl.ref_event_id
	 			WHERE pl.ili_inspection_id = {P_REPORT_ID})
				SELECT t1.ili_pipe_length_id
	 			FROM t t1 JOIN t t2
	 			ON t2.start_odometer &lt;t1.start_odometer AND t2.ref_event_id IS NOT NULL and t1.ili_pipe_length_id = d.ili_pipe_length_id
	 			AND NOT EXISTS (SELECT 1 FROM t t3
	 			WHERE t3.ref_event_id IS NOT NULL
	 			AND t3.start_odometer &gt; t2.start_odometer
	 			AND t3.start_odometer &lt; t1.start_odometer)
	 			JOIN pods.event_range e ON e.event_id = t2.ref_event_id AND e.length*1.5 &gt; t1.end_odometer - t2.start_odometer
	 			WHERE t1.ref_event_id IS NULL)
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_CALC_KM_1" comment="CALC_CALC_KM_1" schema="UTE" table="CALC_CALC_KM">
	<select>
		<dbQuery>
		<var name="ROUTE_ID"/>
			<query>
			select a.STATION_ID "STATION_ID", a.STATION "STATION", a.MEASURE "MEASURE", a.TYPE_CL "TYPE_CL"
			from
			(select sp.STATION_ID, sp.STATION, sp.MEASURE, sp.TYPE_CL
			from pods.station_point sp
			where route_id = {ROUTE_ID} AND sp.TYPE_CL IN ('ST_POINT_TYPE_02','ST_POINT_TYPE_03','ST_POINT_TYPE_04','ST_POINT_TYPE_05')
			union all
			select 0,s.station_begin, MIN(sp.measure), 'ST_POINT_TYPE_03'
			from pods.series s
			join pods.station_point sp on sp.series_id = s.series_id
			where s.route_id = {ROUTE_ID}
			group by s.station_begin
			union all
			select 1e25,s.station_end, MAX(sp.measure), 'ST_POINT_TYPE_03'
			from pods.series s
			join pods.station_point sp on sp.series_id = s.series_id
			where s.route_id = {ROUTE_ID}
			group by s.station_end) a
			order by a.measure, STATION_ID
			</query>
		</dbQuery>
	</select>
</data> 
 
<data id="CALC_CALC_KM_2" comment="CALC_CALC_KM_2" schema="UTE" table="CALC_CALC_KM">
	<insert>
		<dbCommand>	
		<var name="STATION" type="Decimal"/>
		<var name="STATION_ID" type="Decimal"/>	
			<query>
			UPDATE PODS.STATION_POINT
			SET STATION = {STATION}
			WHERE STATION_ID = {STATION_ID}
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_CALC_KM_ALL_1" comment="CALC_CALC_KM_ALL_1" schema="UTE" table="CALC_CALC_KM_ALL">
	<select>
		<dbQuery>
		<var name="ROUTE_ID"/>
			<query>
			select a.STATION_ID "STATION_ID", a.STATION "STATION", a.MEASURE "MEASURE", a.TYPE_CL "TYPE_CL"
			from
			(select sp.STATION_ID, sp.STATION, sp.MEASURE, sp.TYPE_CL 
			from pods.station_point sp
			where route_id = {ROUTE_ID} AND sp.TYPE_CL IN ('ST_POINT_TYPE_02','ST_POINT_TYPE_03','ST_POINT_TYPE_04','ST_POINT_TYPE_05')
			union all
			select 0,s.station_begin, MIN(sp.measure), 'ST_POINT_TYPE_03'
			from pods.series s
			join pods.station_point sp on sp.series_id = s.series_id
			where s.route_id = {ROUTE_ID}
			group by s.station_begin
			union all
			select 1e25,s.station_end, MAX(sp.measure), 'ST_POINT_TYPE_03'
			from pods.series s
			join pods.station_point sp on sp.series_id = s.series_id
			where s.route_id = {ROUTE_ID}
			group by s.station_end) a
			order by a.measure, STATION_ID
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_CALC_KM_ALL_2" comment="CALC_CALC_KM_ALL_2" schema="UTE" table="CALC_CALC_KM_ALL">
	<insert>
		<dbCommand>	
		<var name="STATION" type="Decimal"/>
		<var name="STATION_ID" type="Decimal"/>	
			<query>
			UPDATE PODS.STATION_POINT
			SET STATION = {STATION}
			WHERE STATION_ID = {STATION_ID}
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_CALC_LRS_1" comment="CALC_CALC_LRS_1" schema="UTE" table="CALC_CALC_LRS">
	<select>
		<dbQuery>
		<var name="ROUTE_ID"/>
			<query>
			SELECT sp.STATION_ID "STATION_ID", sp.MEASURE "MEASURE", sp.TYPE_CL "TYPE_CL", c.X_COORD "X", c.Y_COORD "Y", c.Z_COORD + l.DEPTH_OF_COVER "Z"
			FROM pods.station_point sp
			JOIN pods.location l ON l.location_id = sp.location_id
			JOIN pods.coordinate c ON c.location_id = sp.location_id
			WHERE sp.route_id = {ROUTE_ID} AND sp.TYPE_CL IN ('ST_POINT_TYPE_02','ST_POINT_TYPE_03','ST_POINT_TYPE_04','ST_POINT_TYPE_05')
			ORDER BY sp.measure, sp.station_id
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="CALC_CALC_LRS_2" comment="CALC_CALC_LRS_2" schema="UTE" table="CALC_CALC_LRS">
	<insert>
		<dbCommand>	
		<var name="MEASURE" type="Decimal"/>
		<var name="STATION_ID" type="Decimal"/>	
			<query>
			UPDATE PODS.STATION_POINT
			SET MEASURE = {MEASURE}
			WHERE STATION_ID = {STATION_ID}
			</query>
		</dbCommand>
	</insert>
</data>
 
<data id="CALC_CALC_LRS_ALL_1" comment="CALC_CALC_LRS_ALL_1" schema="UTE" table="CALC_CALC_LRS_ALL">
	<select>
		<dbQuery>
		<var name="ROUTE_ID"/>
			<query>
			SELECT sp.STATION_ID "STATION_ID", sp.MEASURE "MEASURE", c.X_COORD "X", c.Y_COORD "Y", c.Z_COORD + l.DEPTH_OF_COVER "Z"
			FROM pods.station_point sp
			JOIN pods.location l ON l.location_id = sp.location_id
			JOIN pods.coordinate c ON c.location_id = sp.location_id
			WHERE sp.route_id = {ROUTE_ID} AND sp.TYPE_CL IN ('ST_POINT_TYPE_02','ST_POINT_TYPE_03','ST_POINT_TYPE_04','ST_POINT_TYPE_05')
			ORDER BY sp.measure, sp.station_id
			</query>
		</dbQuery>
	</select>
</data>

<data id="CALC_CALC_LRS_ALL_2" comment="CALC_CALC_LRS_ALL_2" schema="UTE" table="CALC_CALC_LRS_ALL">
	<insert>
		<dbCommand>	
		<var name="MEASURE" type="Decimal"/>
		<var name="STATION_ID" type="Decimal"/>	
			<query>
			UPDATE PODS.STATION_POINT
			SET MEASURE = {MEASURE}
			WHERE STATION_ID = {STATION_ID}
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_CALC_PS_1" comment="CALC_CALC_PS_1" schema="UTE" table="CALC_CALC_PS">
	<update>
		<dbCommand> 
		<var name="P_PIPE_SYSTEM_ID"/>
		<var name="P_TEMPLATE_ID"/>		
			<query>
			update web50.PS_INDEX_OBJ SET GID = NULL where pipe_system_id = {P_PIPE_SYSTEM_ID} and template_id={P_TEMPLATE_ID}
			</query>
		</dbCommand>
	</update>
 </data> 
 
<data id="CALC_CALC_PS_2" comment="CALC_CALC_PS_2" schema="UTE" table="CALC_CALC_PS">
	<update>
		<dbCommand> 
		<var name="P_PIPE_SYSTEM_ID"/>
		<var name="P_TEMPLATE_ID"/>		
			<query>
			delete from web50.PS_INDEX_OBJ_G where exists(select 0 from web50.PS_INDEX_OBJ o WHERE pipe_system_id = {P_PIPE_SYSTEM_ID} AND template_id={P_TEMPLATE_ID} AND o.index_obj_id = web50.PS_INDEX_OBJ_G.gid)
			</query>
		</dbCommand>
	</update>
</data> 

<data id="CALC_CALC_PS_3" comment="CALC_CALC_PS_3" schema="UTE" table="CALC_CALC_PS">
	<update>
		<dbCommand> 
		<var name="P_PIPE_SYSTEM_ID"/>
		<var name="P_TEMPLATE_ID"/>		
			<query>
			delete from web50.PS_INDEX_OBJ where pipe_system_id = {P_PIPE_SYSTEM_ID} and template_id={P_TEMPLATE_ID}
			</query>
		</dbCommand>
	</update>
</data> 
 
<data id="CALC_CALC_PS_4" comment="CALC_CALC_PS_4" schema="UTE" table="CALC_CALC_PS">
	<select>
		<dbQuery>
		<var name="call_method.RES_QUERY"/>
			<query>
			{call_method.RES_QUERY}
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_CALC_PS_5" comment="CALC_CALC_PS_5" schema="UTE" table="CALC_CALC_PS">
	<select>
		<dbQuery>
		<var name="P_PIPE_SYSTEM_ID"/>
			<query>
			WITH 
 			ps_info AS (SELECT PIPE_SYSTEM_ID
 			,MIN(KM_BEGIN) KM_BEGIN
 			,MAX(KM_END) KM_END
 			FROM PODS.PIPE_SYSTEM_BOUNDARY 
 			WHERE PIPE_SYSTEM_ID = {P_PIPE_SYSTEM_ID}
 			AND TITLE_EVENT_INDICATOR_LF = 'Y'
 			GROUP BY PIPE_SYSTEM_ID),
 			my_routes AS (SELECT psb.PIPE_SYSTEM_ID
 			,r.LINE_ID
 			,r.ROUTE_ID
 			,r.SEQUENCE
 			,CASE r.TYPE_CL
 			WHEN 'ROUTE_TYPE_10' THEN 'G0000001'
 			WHEN 'ROUTE_TYPE_11' THEN 'G0000002'
 			WHEN 'ROUTE_TYPE_12' THEN 'G0000002'
 			WHEN 'ROUTE_TYPE_04' THEN 'G0000003'
 			END OBJ_CLS_GROUP_ID 
 			,s.STATION_BEGIN KM_START
 			,s.STATION_END KM_END
 			,CASE WHEN SIGN(S.STATION_END-S.STATION_BEGIN) = 0 THEN 1
 			ELSE SIGN(S.STATION_END-S.STATION_BEGIN)
 			END M_SIGN 
 			FROM ps_info ps
 			JOIN PODS.PIPE_SYSTEM_BOUNDARY psb 
 			ON ps.PIPE_SYSTEM_ID = psb.PIPE_SYSTEM_ID 
 			JOIN PODS.ROUTE r
 			ON r.LINE_ID = psb.LINE_ID 
 			JOIN PODS.SERIES s
 			ON r.ROUTE_ID = s.ROUTE_ID 
 			WHERE psb.TITLE_EVENT_INDICATOR_LF = 'Y' 
 			AND r.TYPE_CL IN ('ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12','ROUTE_TYPE_04')
 			AND r.CURRENT_INDICATOR_LF = 'Y'
 			AND ((SELECT MAX(MEASURE)-MIN(MEASURE) PIPE_LENGTH
 			FROM PODS.SERIES s
 			JOIN PODS.STATION_POINT sp
 			ON sp.SERIES_ID = s.SERIES_ID
 			WHERE s.ROUTE_ID = r.ROUTE_ID
 			AND s.CURRENT_INDICATOR_LF = 'Y') &gt; 900
 			OR r.TYPE_CL != 'ROUTE_TYPE_04'))
 			SELECT ps_info.PIPE_SYSTEM_ID "PIPE_SYSTEM_ID"
 			,mr.LINE_ID "LINE_ID"
 			,sp.SERIES_ID "SERIES_ID"
 			,sp.STATION "STATION"
 			,sp.MEASURE "MEASURE"
 			,c.X_COORD "X_COORD"
 			,c.Y_COORD "Y_COORD"
 			,sp.STATION_ID "STATION_ID"
 			FROM my_routes mr
 			JOIN PODS.SERIES s
 			ON s.ROUTE_ID = mr.ROUTE_ID
 			JOIN PODS.STATION_POINT sp
 			ON sp.SERIES_ID = s.SERIES_ID 
 			JOIN PODS.COORDINATE c
 			ON c.LOCATION_ID = sp.LOCATION_ID 
 			JOIN ps_info
 			ON ps_info.PIPE_SYSTEM_ID = mr.PIPE_SYSTEM_ID
 			WHERE s.CURRENT_INDICATOR_LF = 'Y'
 			AND c.CURRENT_INDICATOR_LF = 'Y'
 			AND s.station_begin &lt;= ps_info.KM_END
 			AND s.station_end &gt;= ps_info.KM_BEGIN
 			AND sp.station &lt;= ps_info.KM_END
 			AND sp.station &gt;= ps_info.KM_BEGIN
 			AND sp.type_cl IN ('ST_POINT_TYPE_02', 'ST_POINT_TYPE_03')
 			AND ((OBJ_CLS_GROUP_ID = 'G0000003' 
 			AND NOT EXISTS (SELECT 'x' 
 			FROM my_routes 
 			WHERE OBJ_CLS_GROUP_ID in ('G0000001','G0000002')))
 			OR (OBJ_CLS_GROUP_ID = 'G0000002' 
 			AND NOT EXISTS (SELECT 'x' 
 			FROM my_routes 
 			WHERE OBJ_CLS_GROUP_ID = 'G0000001'))
 			OR OBJ_CLS_GROUP_ID = 'G0000001') 
 			ORDER BY mr.LINE_ID, mr.SEQUENCE, s.SERIES_ID, sp.MEASURE*mr.m_sign
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_CALC_PS_6" comment="CALC_CALC_PS_6" schema="UTE" table="CALC_CALC_PS">
	<select>
		<dbQuery>
		<var name="P_PIPE_SYSTEM_ID"/>
			<query>
			WITH 
 			ps_info AS (SELECT PIPE_SYSTEM_ID
 			,MIN(KM_BEGIN) KM_BEGIN
 			,MAX(KM_END) KM_END
 			FROM PODS.PIPE_SYSTEM_BOUNDARY 
 			WHERE PIPE_SYSTEM_ID = {P_PIPE_SYSTEM_ID}
 			AND TITLE_EVENT_INDICATOR_LF = 'Y'
 			GROUP BY PIPE_SYSTEM_ID),
 			my_routes AS (SELECT psb.PIPE_SYSTEM_ID
 			,r.LINE_ID
 			,r.ROUTE_ID
 			,r.SEQUENCE
 			,CASE r.TYPE_CL
 			WHEN 'ROUTE_TYPE_10' THEN 'G0000001'
 			WHEN 'ROUTE_TYPE_11' THEN 'G0000002'
 			WHEN 'ROUTE_TYPE_12' THEN 'G0000002'
 			WHEN 'ROUTE_TYPE_04' THEN 'G0000003'
 			END OBJ_CLS_GROUP_ID 
 			,s.STATION_BEGIN KM_START
 			,s.STATION_END KM_END
 			,CASE WHEN SIGN(S.STATION_END-S.STATION_BEGIN) = 0 THEN 1
 			ELSE SIGN(S.STATION_END-S.STATION_BEGIN)
 			END M_SIGN 
 			FROM ps_info ps
 			JOIN PODS.PIPE_SYSTEM_BOUNDARY psb 
 			ON ps.PIPE_SYSTEM_ID = psb.PIPE_SYSTEM_ID 
 			JOIN PODS.ROUTE r
 			ON r.LINE_ID = psb.LINE_ID 
 			JOIN PODS.SERIES s
 			ON r.ROUTE_ID = s.ROUTE_ID 
 			WHERE psb.TITLE_EVENT_INDICATOR_LF = 'Y' 
 			AND r.TYPE_CL IN ('ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12','ROUTE_TYPE_04')
 			AND r.CURRENT_INDICATOR_LF = 'Y'
 			AND ((SELECT MAX(MEASURE)-MIN(MEASURE) PIPE_LENGTH
 			FROM PODS.SERIES s
 			JOIN PODS.STATION_POINT sp
 			ON sp.SERIES_ID = s.SERIES_ID
 			WHERE s.ROUTE_ID = r.ROUTE_ID
 			AND s.CURRENT_INDICATOR_LF = 'Y') &gt; 900
 			OR r.TYPE_CL != 'ROUTE_TYPE_04'))
 			SELECT MIN(c.X_COORD) "X_MIN", MAX(c.X_COORD) "X_MAX", MIN(c.Y_COORD) "Y_MIN", MAX(c.Y_COORD) "Y_MAX"
 			FROM my_routes mr
 			JOIN PODS.SERIES s
 			ON s.ROUTE_ID = mr.ROUTE_ID
 			JOIN PODS.STATION_POINT sp
 			ON sp.SERIES_ID = s.SERIES_ID 
 			JOIN PODS.COORDINATE c
 			ON c.LOCATION_ID = sp.LOCATION_ID 
 			JOIN ps_info
 			ON ps_info.PIPE_SYSTEM_ID = mr.PIPE_SYSTEM_ID
 			WHERE s.CURRENT_INDICATOR_LF = 'Y'
 			AND c.CURRENT_INDICATOR_LF = 'Y'
 			AND s.station_begin &lt;= ps_info.KM_END
 			AND s.station_end &gt;= ps_info.KM_BEGIN
 			AND sp.station &lt;= ps_info.KM_END
 			AND sp.station &gt;= ps_info.KM_BEGIN
 			AND sp.type_cl IN ('ST_POINT_TYPE_02', 'ST_POINT_TYPE_03')
 			AND ((OBJ_CLS_GROUP_ID = 'G0000003' 
 			AND NOT EXISTS (SELECT 'x' 
 			FROM my_routes 
 			WHERE OBJ_CLS_GROUP_ID in ('G0000001','G0000002')))
 			OR (OBJ_CLS_GROUP_ID = 'G0000002' 
 			AND NOT EXISTS (SELECT 'x' 
 			FROM my_routes 
 			WHERE OBJ_CLS_GROUP_ID = 'G0000001'))
 			OR OBJ_CLS_GROUP_ID = 'G0000001') 
 			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_CALC_PS_7" comment="CALC_CALC_PS_7" schema="UTE" table="CALC_CALC_PS">
	<insert>
		<dbCommand>	
		<var name="P_TEMPLATE_ID"/>
		<var name="P_PIPE_SYSTEM_ID"/>
		<var name="P_GID_FIELD"/>		
		<var name="KEY_VALUES" type="String"/>
		<var name="KM_START" type="Decimal"/>
		<var name="KM_END" type="Decimal"/>
		<var name="LINE_COORD_START" type="Decimal"/>
		<var name="LINE_COORD_END" type="Decimal"/>
		<var name="DISTANCE" type="Decimal"/>
		<var name="GID" type="Decimal" default="SELECT max(INDEX_OBJ_ID) id FROM WEB50.PS_INDEX_OBJ" />	
			<query>
			insert into WEB50.PS_INDEX_OBJ(TEMPLATE_ID, PIPE_SYSTEM_ID, STATE_ID, KEY_FIELDS, KEY_VALUES, KM_START, KM_END, LINE_COORD_START, LINE_COORD_END, DISTANCE, GID, CUSER_ID) 
 			VALUES({P_TEMPLATE_ID}, {P_PIPE_SYSTEM_ID}, 0, '{P_GID_FIELD}', {KEY_VALUES}, {KM_START}, {KM_END}, {LINE_COORD_START}, {LINE_COORD_END}, {DISTANCE}, NULL, 0) 
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_CALC_PS_8" comment="CALC_CALC_PS_8" schema="UTE" table="CALC_CALC_PS">
	<insert>
		<dbCommand>
		<param name="GID" type="Decimal"/>
		<param name="XMIN" type="Decimal"/>
		<param name="YMIN" type="Decimal"/>
		<param name="XMAX" type="Decimal"/>
		<param name="YMAX" type="Decimal"/>
			<query>
				insert into WEB50.PS_INDEX_OBJ_G(GID, "XMIN", "YMIN", "XMAX", "YMAX", WKB_GEOMETRY) VALUES(:GID, :XMIN, :YMIN, :XMAX, :YMAX, :WKB_GEOMETRY)
			</query>
		</dbCommand>
	</insert>
</data> 
 
<data id="CALC_CALC_PS_9" comment="CALC_CALC_PS_9" schema="UTE" table="CALC_CALC_PS">
	<insert>
		<dbCommand>
		<var name="GID" type="Decimal"/>
			<query>
			update WEB50.PS_INDEX_OBJ SET GID = {GID} WHERE INDEX_OBJ_ID = {GID}
			</query>
		</dbCommand>
	</insert>
 </data>

<data id="CALC_CALC_PS_10" comment="CALC_CALC_PS_10" schema="UTE" table="CALC_CALC_PS">
	<insert>
		<dbCommand>
		<var name="P_TEMPLATE_ID"/>
		<var name="P_PIPE_SYSTEM_ID"/>
		<var name="P_GID_FIELD"/>
			<query>
			insert into WEB50.PS_INDEX_OBJ(TEMPLATE_ID, PIPE_SYSTEM_ID, STATE_ID, KEY_FIELDS, KEY_VALUES, KM_START, KM_END, LINE_COORD_START, LINE_COORD_END, DISTANCE, GID, CUSER_ID) 
 			VALUES({P_TEMPLATE_ID}, {P_PIPE_SYSTEM_ID}, 0, '{P_GID_FIELD}', @KEY_VALUES, @KM_START, @KM_END, @LINE_COORD_START, @LINE_COORD_END, @DISTANCE, NULL, 0) SET @R_GID=SCOPE_IDENTITY()
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_CALC_PS_11" comment="CALC_CALC_PS_11" schema="UTE" table="CALC_CALC_PS">
	<insert>
		<dbCommand>
			<query>
			insert into WEB50.PS_INDEX_OBJ_G(GID, "XMIN", "YMIN", "XMAX", "YMAX", WKB_GEOMETRY) VALUES(@GID, @XMIN, @YMIN, @XMAX, @YMAX, @WKB_GEOMETRY)
			</query>
		</dbCommand>
	</insert>
 </data>
 
<data id="CALC_CALC_PS_12" comment="CALC_CALC_PS_12" schema="UTE" table="CALC_CALC_PS">
	<insert>
		<dbCommand>
			<query>
			update WEB50.PS_INDEX_OBJ SET GID = @GID WHERE INDEX_OBJ_ID = @GID
			</query>
		</dbCommand>
	</insert>
 </data> 

<data id="CALC_CALC_PS_13" comment="CALC_CALC_PS_13" schema="UTE" table="CALC_CALC_PS">
	<update>
		<dbCommand> 
		<var name="P_PIPE_SYSTEM_ID"/>
			<query>
			DELETE FROM pods.comments c WHERE c.table_id = 'PIPE_SYSTEM_CL' AND c.comment_by = 'IS_DIRTY' AND c.comments = '1' AND c.id::integer = {P_PIPE_SYSTEM_ID}
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_EHZ_INSP_CALC_STO_1" comment="CALC_EHZ_INSP_CALC_STO_1" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			WITH report 
			AS (SELECT i.*,r.event_id range_event_id, r.event_id event_id, s.route_id,
			s.station_begin station_beg, s.station_end station_end,
			c.description company_name,l.line_id,
 			CASE
 			WHEN l.line_id = 0
 			THEN 'Отчет не рассчитан. '
 			ELSE rtc.description
 			END route_type,
 			CASE
 			WHEN l.line_id = 0
 			THEN r.description
 			ELSE l.description
 			END line_name,
 			(SELECT count(*)
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) WELDS_COUNT,
 			(SELECT ABS(MAX(F.ABSOLUTE_ODOMETER)-MIN(F.ABSOLUTE_ODOMETER))/1000 
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) INSP_LENGTH 
 			FROM pods.ili_inspection i 
 			JOIN pods.ili_inspection_range r
 			ON r.ili_inspection_id = i.ili_inspection_id 
 			AND i.ili_inspection_id = {INSPECTION_ID}
 			JOIN pods.event_range e 
 			ON e.event_id = r.event_id
 			JOIN pods.station_point sp
 			ON sp.station_id = e.station_id_begin
 			JOIN pods.series s 
 			ON s.series_id = sp.series_id
 			JOIN pods.route rt 
 			ON sp.route_id = rt.route_id
 			JOIN pods.line l 
 			ON sp.line_id = l.line_id
 			JOIN pods.route_type_cl rtc 
 			ON rt.type_cl = rtc.code
 			JOIN pods.ili_tool_vendor_cl c
 			ON c.code = i.tool_vendor_cl
 			), 
			diameter 
 			AS (SELECT coalesce(min(p.nominal_diameter_gcl),'1420') nominal_diameter_gcl,coalesce(min(p.date_begin_exploitation),to_date('01011955','DDMMYYYY')) INSTALL_DATE
 			from pods.sto_pipe_segment_params p
			join report r on
 			 p.route_id=r.line_id and r.station_beg&lt;=p.station_begin and r.station_end&gt;=p.station_end)
 			SELECT ar.CALC_ID "CALC_ID"
 			,ar.EVENT_ID "EVENT_ID"
 			,report.RANGE_EVENT_ID "RANGE_EVENT_ID"
 			,report.BEGIN_DATE "BEGIN_DATE"
 			,ar.TYPE_CL "TYPE_CL"
 			,ar.ILI_INSPECTION_ID "ILI_INSPECTION_ID"
 			,ar.BEGIN_EVENT_ID "BEGIN_EVENT_ID"
 			,ar.END_EVENT_ID "END_EVENT_ID"
 			,er.STATION_ID_BEGIN "STATION_ID_BEGIN"
 			,er.STATION_ID_END "STATION_ID_END"
 			,ar.BEGIN_ODOMETER "BEGIN_ODOMETER"
 			,ar.END_ODOMETER "END_ODOMETER"
			 ,spb.measure "MEASURE_BEGIN"
 			,spe.measure "MEASURE_END"
 			,ar.DANGER_DEG "DANGER_DEG"
 			,ar.DANGER_DEG_SEGMENT_TYPE "DANGER_DEG_SEGMENT_TYPE"
 			,ar.DEFEAT_ZONE "DEFEAT_ZONE"
 			,ar.INTEGR_DEG_RATE "INTEGR_DEG_RATE"
 			,ar.UNEVENNESS_COEF "UNEVENNESS_COEF"
 			,ar.SEGMENT_INTENSIVE_DEG_RATE "SEGMENT_INTENSIVE_DEG_RATE"
 			,ar.SEGMENT_INTENSIVITY "SEGMENT_INTENSIVITY"
 			,ar.SEGMENT_CATEGORY "SEGMENT_CATEGORY"
 			,ar.CORR_AVER_DEPTH "CORR_AVER_DEPTH"
 			,ar.CORR_AVER_SPEED "CORR_AVER_SPEED"
 			,ar.CORR_CRITICAL_DEPTH "CORR_CRITICAL_DEPTH"
 			,ar.CORR_TIME_TO_CRITICAL_DEPTH "CORR_TIME_TO_CRITICAL_DEPTH"
 			,ar.PRIORITY_RATE "PRIORITY_RATE"
 			,ar.IS_DEFEAT_DANGER "IS_DEFEAT_DANGER"
 			,ar.RING_BREAK_POINT "RING_BREAK_POINT"
 			,ar.TIME_TO_DANGER "TIME_TO_DANGER"
 			,ar.DEPTH_TO_DANGER "DEPTH_TO_DANGER"
 			,ar.LENGTH_TO_DANGER "LENGTH_TO_DANGER"
 			,ar.WIDTH_TO_DANGER "WIDTH_TO_DANGER"
 			,ar.SQUARE_TO_DANGER "SQUARE_TO_DANGER "
 			,diameter.nominal_diameter_gcl "NOMINAL_DIAMETER_GCL"
 			,er.length "SECTOR_LENGTH"
 			,diameter.INSTALL_DATE "INSTALL_DATE"
 			FROM pods.sto_ehz_calc ar
 			JOIN pods.event_range er
 			ON er.event_id = ar.event_id
 			JOIN pods.station_point spb
 			ON spb.station_id = er.station_id_begin
 			JOIN pods.station_point spe
 			ON spe.station_id = er.station_id_end
 			JOIN report
 			ON ar.ili_inspection_id = report.ili_inspection_id
 			CROSS JOIN diameter
 			WHERE ar.ili_inspection_id = {INSPECTION_ID}
			</query>
		</dbQuery>
	</select>
</data>

<data id="CALC_EHZ_INSP_CALC_STO_2" comment="CALC_EHZ_INSP_CALC_STO_2" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<insert>
		<dbCommand>
		<var name="CALC_ID" type="Decimal"/>
		<var name="DANGER_DEG" type="String"/>
		<var name="DANGER_DEG_SEGMENT_TYPE" type="String"/>
		<var name="DEFEAT_ZONE" type="Decimal"/>
		<var name="INTEGR_DEG_RATE" type="Decimal"/>
		<var name="UNEVENNESS_COEF" type="Decimal"/>
		<var name="SEGMENT_INTENSIVE_DEG_RATE" type="Decimal"/>
		<var name="SEGMENT_INTENSIVITY" type="String"/>
		<var name="SEGMENT_CATEGORY" type="String"/>	
		<var name="CORR_AVER_DEPTH" type="Decimal"/>
		<var name="CORR_AVER_SPEED" type="Decimal"/>
		<var name="CORR_CRITICAL_DEPTH" type="Decimal"/>
		<var name="CORR_TIME_TO_CRITICAL_DEPTH" type="Decimal"/>
		<var name="PRIORITY_RATE" type="Decimal"/>
		<var name="IS_DEFEAT_DANGER" type="Decimal"/>
		<var name="RING_BREAK_POINT" type="Decimal"/>
		<var name="TIME_TO_DANGER" type="Decimal"/>
		<var name="DEPTH_TO_DANGER" type="Decimal"/>
		<var name="LENGTH_TO_DANGER" type="Decimal"/>
		<var name="WIDTH_TO_DANGER" type="Decimal"/>
		<var name="SQUARE_TO_DANGER" type="Decimal"/>
		<var name="BEGIN_ODOMETER" type="Decimal"/>
		<var name="END_ODOMETER" type="Decimal"/>
		<var name="EVENT_ID" type="Decimal"/>
		<var name="TYPE_CL" type="String"/>
		<var name="ILI_INSPECTION_ID" type="Decimal"/>
		<var name="BEGIN_EVENT_ID" type="Decimal"/>	
		<var name="END_EVENT_ID" type="Decimal"/>		
			<query>
			DO $$
			DECLARE
 			v_dummy VARCHAR(512); 
 			v_event_id NUMERIC;
 			v_calc_id NUMERIC;
 			BEGIN
 			IF {CALC_ID} IS NOT NULL
 			THEN 
 			/* Если calc_id уже заполнен, значит мы просто сохраняем результаты расчета, без создания новых объектов*/ 
 			UPDATE pods.sto_ehz_calc 
 			SET DANGER_DEG = '{DANGER_DEG}' 
 			,DANGER_DEG_SEGMENT_TYPE = '{DANGER_DEG_SEGMENT_TYPE}'
 			,DEFEAT_ZONE = {DEFEAT_ZONE}
 			,INTEGR_DEG_RATE = {INTEGR_DEG_RATE}
 			,UNEVENNESS_COEF = {UNEVENNESS_COEF}
 			,SEGMENT_INTENSIVE_DEG_RATE = {SEGMENT_INTENSIVE_DEG_RATE}
 			,SEGMENT_INTENSIVITY = '{SEGMENT_INTENSIVITY}'
 			,SEGMENT_CATEGORY = '{SEGMENT_CATEGORY}'
 			,CORR_AVER_DEPTH = {CORR_AVER_DEPTH}
 			,CORR_AVER_SPEED = {CORR_AVER_SPEED}
 			,CORR_CRITICAL_DEPTH = {CORR_CRITICAL_DEPTH}
 			,CORR_TIME_TO_CRITICAL_DEPTH = {CORR_TIME_TO_CRITICAL_DEPTH}
 			,PRIORITY_RATE = {PRIORITY_RATE}
 			,IS_DEFEAT_DANGER = {IS_DEFEAT_DANGER}
 			,RING_BREAK_POINT = {RING_BREAK_POINT}
 			,TIME_TO_DANGER = {TIME_TO_DANGER}
 			,DEPTH_TO_DANGER = {DEPTH_TO_DANGER}
 			,LENGTH_TO_DANGER = {LENGTH_TO_DANGER}
 			,WIDTH_TO_DANGER = {WIDTH_TO_DANGER}
 			,SQUARE_TO_DANGER = {SQUARE_TO_DANGER}
 			,BEGIN_ODOMETER = {BEGIN_ODOMETER}
 			,END_ODOMETER = {END_ODOMETER}
 			WHERE calc_id = {CALC_ID};
 			ELSE 
 			/* Добавляю запись в расчетную таблицу */ 
 			INSERT INTO pods.sto_ehz_calc
 			(EVENT_ID,TYPE_CL,ILI_INSPECTION_ID,BEGIN_EVENT_ID,END_EVENT_ID,DANGER_DEG,DANGER_DEG_SEGMENT_TYPE,DEFEAT_ZONE,INTEGR_DEG_RATE,UNEVENNESS_COEF 
 			,SEGMENT_INTENSIVE_DEG_RATE,SEGMENT_INTENSIVITY,SEGMENT_CATEGORY,CORR_AVER_DEPTH,CORR_AVER_SPEED,CORR_CRITICAL_DEPTH,CORR_TIME_TO_CRITICAL_DEPTH 
 			,PRIORITY_RATE,IS_DEFEAT_DANGER,RING_BREAK_POINT,TIME_TO_DANGER,DEPTH_TO_DANGER,LENGTH_TO_DANGER,WIDTH_TO_DANGER,SQUARE_TO_DANGER,BEGIN_ODOMETER,END_ODOMETER)
 			VALUES 
 			({EVENT_ID},'{TYPE_CL}',{ILI_INSPECTION_ID},{BEGIN_EVENT_ID},{END_EVENT_ID},'{DANGER_DEG}','{DANGER_DEG_SEGMENT_TYPE}',{DEFEAT_ZONE},{INTEGR_DEG_RATE},{UNEVENNESS_COEF}
 			,{SEGMENT_INTENSIVE_DEG_RATE},'{SEGMENT_INTENSIVITY}','{SEGMENT_CATEGORY}',{CORR_AVER_DEPTH},{CORR_AVER_SPEED},{CORR_CRITICAL_DEPTH},{CORR_TIME_TO_CRITICAL_DEPTH}
 			,{PRIORITY_RATE},{IS_DEFEAT_DANGER},{RING_BREAK_POINT},{TIME_TO_DANGER},{DEPTH_TO_DANGER},{LENGTH_TO_DANGER},{WIDTH_TO_DANGER},{SQUARE_TO_DANGER},{BEGIN_ODOMETER},{END_ODOMETER})
 			RETURNING CALC_ID INTO v_calc_id;
 			
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_EHZ_INSP_CALC_STO_3" comment="CALC_EHZ_INSP_CALC_STO_3" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			WITH report 
			 AS (SELECT i.*, r.event_id event_id, s.route_id,
 			s.station_begin station_beg, s.station_end station_end,
 			c.description company_name,
 			CASE
 			WHEN l.line_id = 0
 			THEN 'Отчет не рассчитан. '
 			ELSE rtc.description
 			END route_type,
 			CASE
 			WHEN l.line_id = 0
 			THEN r.description
 			ELSE l.description
 			END line_name,
 			(SELECT count(*)
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) WELDS_COUNT,
 			(SELECT ABS(MAX(F.ABSOLUTE_ODOMETER)-MIN(F.ABSOLUTE_ODOMETER))/1000 
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) INSP_LENGTH 
 			FROM pods.ili_inspection i JOIN pods.ili_inspection_range r
 			ON r.ili_inspection_id = i.ili_inspection_id and i.ili_inspection_id={INSPECTION_ID}
 			JOIN pods.event_range e ON e.event_id = r.event_id
 			JOIN pods.station_point sp
 			ON sp.station_id = e.station_id_begin
 			JOIN pods.series s ON s.series_id = sp.series_id
 			JOIN pods.route rt ON sp.route_id = rt.route_id
 			JOIN pods.line l ON sp.line_id = l.line_id
 			JOIN pods.route_type_cl rtc ON rt.type_cl = rtc.code
 			JOIN pods.ili_tool_vendor_cl c
 			ON c.code = i.tool_vendor_cl
 			), 
			diameter 
 			AS (SELECT coalesce(MIN(ps.nominal_diameter_gcl),'1420') nominal_diameter_gcl
 			FROM pods.station_point spe 
 			JOIN pods.event_range eps
 			ON spe.station_id = eps.station_id_begin AND eps.FEATURE_ID = 'PIPE_SEGMENT'
 			JOIN pods.pipe_segment ps 
 			ON eps.event_id = ps.event_id 
 			JOIN report
 			ON report.route_id = spe.route_id),
			defect_pipe_length 
 			AS (SELECT dd.ili_data_id,coalesce(MIN(ABS(pl.end_odometer-pl.start_odometer)),'10') defect_pipe_length
 			FROM pods.ili_data dd
 			JOIN pods.ili_pipe_length pl
 			ON pl.ili_inspection_id = dd.ili_inspection_id
 			AND pl.weld_number = dd.weld_number
 			WHERE dd.ili_inspection_id = {INSPECTION_ID} 
 			GROUP BY dd.ili_data_id), 
			left_marker 
 			AS (SELECT ili_data_id,marker_distance_left,coalesce(marker_name_left,'НЕИЗВЕСТНО') marker_name_left
 			FROM (SELECT dd.ili_data_id
 			,ROW_NUMBER() OVER (PARTITION BY dd.ili_data_id ORDER BY ft.absolute_odometer DESC) rwn
 			,ft.absolute_odometer marker_distance_left
 			,ft.feature_description marker_name_left
 			FROM pods.ili_data dd 
 			JOIN pods.ili_data ft
 			ON ft.ili_inspection_id =dd.ili_inspection_id
 			AND ft.absolute_odometer &lt;dd.absolute_odometer
 			WHERE ft.anomaly_type_cl IN ( SELECT code
 			FROM pods.ili_anomaly_type_cl
 			WHERE category_cl = 2)
 			AND dd.ili_inspection_id = {INSPECTION_ID}) x01
			WHERE rwn = 1), 
			right_marker
 			AS (SELECT ili_data_id,marker_distance_right,coalesce(marker_name_right,'НЕИЗВЕСТНО') marker_name_right
 			FROM (SELECT dd.ili_data_id ,ROW_NUMBER() OVER (PARTITION BY dd.ili_data_id ORDER BY ft.absolute_odometer ASC) rwn
 			,ft.absolute_odometer marker_distance_right
 			,ft.feature_description marker_name_right
 			FROM pods.ili_data dd 
 			JOIN pods.ili_data ft
 			ON ft.ili_inspection_id =dd.ili_inspection_id
 			AND ft.absolute_odometer &gt;dd.absolute_odometer
 			WHERE ft.anomaly_type_cl IN ( SELECT code FROM pods.ili_anomaly_type_cl
 			WHERE category_cl = 2)
 			AND dd.ili_inspection_id = {INSPECTION_ID}) x02
			WHERE rwn = 1)
 			SELECT ID "ID",
 			orientation_deg "ORIENTATION_DEG",
 			nominal_wall_thickness "NOMINAL_WALL_THICKNESS",
 			weld_number "WELD_NUMBER",
 			station "STATION",
 			calibrated_measure "CALIBRATED_MEASURE",
 			ili_data_id "ILI_DATA_ID",
 			LENGTH "LENGTH",
 			average_depth "AVERAGE_DEPTH",
 			width "WIDTH",
 			absolute_odometer "ABSOLUTE_ODOMETER",
 			anomaly_type_cl "ANOMALY_TYPE_CL",
 			anomaly_extension_cl "ANOMALY_EXTENSION_CL",
 			feature_description "FEATURE_DESCRIPTION",
 			type_description "TYPE_DESCRIPTION",
 			description "DESCRIPTION",
 			line_name "LINE_NAME",
 			begin_date "BEGIN_DATE",
 			company_name "COMPANY_NAME",
 			nominal_diameter_gcl "NOMINAL_DIAMETER_GCL",
 			marker_distance_left "MARKER_DISTANCE_LEFT",
 			marker_name_left "MARKER_NAME_LEFT",
 			marker_distance_right "MARKER_DISTANCE_RIGHT",
 			marker_name_right "MARKER_NAME_RIGHT",
 			defect_pipe_length "DEFECT_PIPE_LENGTH",
 			anomaly_group "ANOMALY_GROUP",
 			US_WELD_DISTANCE "US_WELD_DISTANCE",
 			DS_WELD_DISTANCE "DS_WELD_DISTANCE",
 			ILI_INSPECTION_ID "ILI_INSPECTION_ID",
 			WELDS_COUNT "WELDS_COUNT",
 			INSP_LENGTH "INSP_LENGTH"
 			,MEASURE "MEASURE" 
 			FROM (SELECT def.ili_data_id ID,
 			coalesce(def.orientation_deg/360*12,0) orientation_deg /*ориентация дефекта в градусах */,
 			coalesce(def.nominal_wall_thickness, '16' ) nominal_wall_thickness /*толщина стенки */,
 			coalesce(def.weld_number, 'НЕИЗВЕСТНО') weld_number /*номер трубы */,
 			coalesce(def.station, -999) station /*километр */,
 			coalesce(def.calibrated_measure,-999) calibrated_measure /*линейная дистация геодезическая */,
 			def.ili_data_id ili_data_id /*идентификатор дефекта*/,
 			coalesce(def.LENGTH, 0) LENGTH /*длина дефекта*/,
 			coalesce(def.average_depth, '5' ) average_depth /*средняя глубина поражения*/,
 			coalesce(def.width, 0) width /*ширина*/,
 			coalesce(def.absolute_odometer,-999) absolute_odometer /*линейная дистация геодезическая*/,
 			coalesce(def.anomaly_type_cl,0) anomaly_type_cl /*прикрутить справочник */,
 			coalesce(def.anomaly_extension_cl,'UNKNOWN') anomaly_extension_cl,
 			coalesce(def.feature_description,'НЕИЗВЕСТНО') feature_description /* описание дефекта */,
 			coalesce(def_description, 'НЕИЗВЕСТНО') type_description /*тип дефекта */,
 			coalesce(def.description, ' ') description /* описание */,
 			CASE WHEN report.line_name IS NOT NULL
 			THEN coalesce(report.route_type, '')|| ' '|| coalesce(report.line_name, '')|| ' '|| coalesce(report.station_beg::text, '')|| ' - '|| coalesce(report.station_end::text, '')|| ' км '
 			ELSE 'НЕИЗВЕСТНО' 
 			END line_name,
 			coalesce((report.begin_date)::text, 'НЕИЗВЕСТНО') begin_date /*дата проведения */,
 			coalesce(report.company_name, 'НЕИЗВЕСТНО') company_name,
 			coalesce(diameter.nominal_diameter_gcl ,1420) nominal_diameter_gcl,
 			coalesce(ABS( absolute_odometer - lm.marker_distance_left),-999) marker_distance_left /*Дистанция до маркера слева */,
 			lm.marker_name_left /* Имя маркера слева*/ ,
 			coalesce(ABS( absolute_odometer - rm.marker_distance_right),-999) marker_distance_right /* дистанция до маркера справа */ ,
 			rm.marker_name_right /*имя маркера справа*/,
 			dpl.defect_pipe_length defect_pipe_length,
 			anomaly_group anomaly_group,
 			coalesce(US_WELD_DISTANCE,0) US_WELD_DISTANCE,
 			coalesce(DS_WELD_DISTANCE,0) DS_WELD_DISTANCE,
 			coalesce(def.ili_inspection_id,0) ILI_INSPECTION_ID,
 			coalesce(report.WELDS_COUNT,10000) WELDS_COUNT,
 			coalesce(report.INSP_LENGTH,100) INSP_LENGTH
 			,MEASURE
 			FROM 
 			(SELECT d.orientation_deg
 			,d.nominal_wall_thickness
 			,d.weld_number
 			,d.calibrated_measure
 			,d.ili_data_id
 			,d.LENGTH
 			,d.average_depth
 			,d.width
 			,d.absolute_odometer
 			,d.anomaly_type_cl
 			,d.anomaly_extension_cl
 			,d.feature_description
 			,d.description
 			,d.ili_inspection_id
 			,d.ds_weld_distance
 			,d.us_weld_distance
 			,sp.station
 			,sp.measure,
 			ia.description anomaly_type,
 			ia.description def_description,
 			CASE
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_003' THEN '1'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_004' AND IA.CODE = 121 THEN '1'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_001' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_002' AND IA.CODE !=144 THEN '4'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_005' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_007' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_009' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_006' THEN '3'
 			WHEN IA.CODE !=144 THEN '4'
 			ELSE '-1'
 			END ANOMALY_GROUP
 			FROM pods.ili_data d
 			JOIN pods.ili_anomaly_type_cl ia
 			ON d.anomaly_type_cl = ia.code AND ia.category_cl = 1
 			LEFT JOIN pods.event_range e
 			ON d.event_id = e.event_id
 			LEFT JOIN pods.station_point sp
 			ON e.station_id_begin = sp.station_id
 			WHERE d.ili_inspection_id = {INSPECTION_ID}
 			AND D.ANOMALY_EXTENSION_CL IN ('ANOMALY_EXT_001','ANOMALY_EXT_005')) def
 			JOIN report
 			ON def.ili_inspection_id = report.ili_inspection_id
 			LEFT JOIN defect_pipe_length dpl
 			ON dpl.ili_data_id = def.ili_data_id
 			LEFT OUTER JOIN left_marker lm
 			ON lm.ili_data_id = def.ili_data_id
 			LEFT OUTER JOIN right_marker rm
 			ON rm.ili_data_id = def.ili_data_id
 			CROSS JOIN diameter
 			) d
 			ORDER BY absolute_odometer
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_EHZ_INSP_CALC_STO_4" comment="CALC_EHZ_INSP_CALC_STO_4" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			WITH station_on_inspection 
 			AS (SELECT spc.station_id,spc.measure
 			FROM pods.ili_inspection_range ir
 			JOIN pods.event_range eri
 			ON eri.event_id = ir.event_id
 			JOIN pods.station_point spi
 			ON eri.station_id_begin = spi.station_id
 			JOIN pods.series si
 			ON si.series_id = spi.series_id
 			JOIN pods.series sc
 			ON sc.route_id = si.route_id
 			JOIN pods.station_point spc
 			ON spc.series_id = si.series_id 
 			WHERE ir.ili_inspection_id = {INSPECTION_ID})
 			SELECT erc.event_id "EVENT_ID"
 			,erc.feature_id "TYPE"
 			,spb.measure "MEASURE_BEGIN"
 			,spe.measure "MEASURE_END"
 			FROM pods.event_range erc
 			JOIN station_on_inspection spb
 			ON erc.station_id_begin = spb.station_id 
 			JOIN station_on_inspection spe
 			ON erc.station_id_end = spe.station_id 
 			WHERE erc.feature_id IN ('WATERWAY','ROAD','RAILROAD')
			</query>
		</dbQuery>
	</select>
</data> 
 
<data id="CALC_EHZ_INSP_CALC_STO_5" comment="CALC_EHZ_INSP_CALC_STO_5" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			SELECT spb.measure "MEASURE",d.weld_number "WELD_NUMBER"
 			FROM pods.ili_data d
 			JOIN pods.event_range er
 			ON er.event_id = d.event_id
 			JOIN pods.station_point spb
 			ON spb.station_id = er.station_id_begin
 			WHERE er.current_indicator_lf = 'Y'
 			AND anomaly_type_cl = 5001
 			AND d.ili_inspection_id = {INSPECTION_ID}
 			ORDER BY spb.measure
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_EHZ_INSP_CALC_STO_6" comment="CALC_EHZ_INSP_CALC_STO_6" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<update>
		<dbCommand> 
		<var name="CALC_CONSTRUCTION_INTERVALS"/>
		<var name="INSPECTION_ID"/>
		<var name="CALC_REGULAR_INTERVALS"/>
		<var name="CALC_LINE_EVENTS"/>		
			<query>
			DO $$
			DECLARE
			 BEGIN
 			IF '{CALC_CONSTRUCTION_INTERVALS}'='true'
 			THEN
 			UPDATE pods.event_range er
 			SET current_indicator_lf = 'N'
 			WHERE feature_id = 'INTERVAL_PER_OBJ'
 			AND current_indicator_lf = 'Y'
 			AND EXISTS (SELECT 1
 			FROM pods.sto_ehz_calc ic
 			WHERE ic.event_id = er.event_id
 			AND ic.ili_inspection_id = {INSPECTION_ID});
 
 			END IF;

 			IF '{CALC_REGULAR_INTERVALS}'='true'
 			THEN
 			UPDATE pods.event_range er
 			SET current_indicator_lf = 'N'
 			WHERE feature_id = 'INTERVAL_REGULAR'
 			AND current_indicator_lf = 'Y'
 			AND EXISTS (SELECT 1
 			FROM pods.sto_ehz_calc ic
 			WHERE ic.event_id = er.event_id
 			AND ic.ili_inspection_id = {INSPECTION_ID});
 			END IF;

 			IF '{CALC_LINE_EVENTS}' = 'true'
 			THEN
 			UPDATE pods.event_range er
 			SET current_indicator_lf = 'N'
 			WHERE feature_id = 'INTERVAL_LAN_REC'
 			AND current_indicator_lf = 'Y'
 			AND EXISTS (SELECT 1
 			FROM pods.sto_ehz_calc ic
 			WHERE ic.event_id = er.event_id
 			AND ic.ili_inspection_id = {INSPECTION_ID}); 
 			END IF; 
 
 			DELETE 
 			FROM pods.sto_ehz_calc
 			WHERE ili_inspection_id = {INSPECTION_ID};
 
 			END $$;
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_EHZ_INSP_CALC_STO_7" comment="CALC_EHZ_INSP_CALC_STO_7" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
		<var name="LINE_EVENTS_QUERY"/>
		<var name="config.main.PODS_USER"/>
			<query>
	DO $$ 
	
	DECLARE
	i RECORD;
	v_event_id NUMERIC;
	v_report_measure_begin NUMERIC(10,2);
	v_report_measure_end NUMERIC(10,2);
	v_begin_odometer NUMERIC(10,2);
	v_end_odometer NUMERIC(10,2);
	v_odometer1 NUMERIC(10,2);
	v_odometer2 NUMERIC(10,2);
	v_measure1 NUMERIC(10,2);
	v_measure2 NUMERIC(10,2); 
	v_route_id NUMERIC; 
	
	BEGIN
	
	SELECT s.route_id,spb.measure,spe.measure
	INTO v_route_id,v_report_measure_begin,v_report_measure_end
	FROM pods.series s
	JOIN pods.station_point spb
	ON s.series_id = spb.series_id
	JOIN pods.event_range er
	ON er.station_id_begin = spb.station_id
	JOIN pods.station_point spe
	ON er.station_id_end = spe.station_id
	JOIN pods.ili_inspection_range ir
	ON ir.event_id = er.event_id
	
	WHERE ir.ili_inspection_id = {INSPECTION_ID}; 
	
	IF v_route_id IS NULL
	OR v_route_id = 0
	THEN
	RETURN;
	END IF; 
	
	FOR i IN (SELECT er.*,spb.measure measure_begin,spe.measure measure_end
	FROM pods.event_range er
	JOIN pods.station_point spb
	ON er.station_id_begin = spb.station_id
	JOIN pods.station_point spe
	ON er.station_id_end = spe.station_id
	
	WHERE event_id in ({LINE_EVENTS_QUERY}))
	LOOP 
	
	/* в свете последних решений необходимо обрезать по размерам отчета */
	
	/* BEGIN ODOMETER*/ 
	/* Получена точка на трубе, создана или найдена, не важно, необходимо получить значение одометра в этом месте*/
	BEGIN
	SELECT absolute_odometer,measure
	INTO v_odometer1,v_measure1 
	FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure DESC,d.absolute_odometer ASC) RWN /* mssql compatibility*/
	,d.absolute_odometer
	,sp1.measure
	FROM pods.station_point sp1
	JOIN pods.station_point spb
	USING (series_id)
	JOIN pods.event_range er
	ON sp1.station_id = er.station_id_begin
	JOIN pods.ili_data d
	USING (event_id)
	WHERE spb.station_id = i.station_id_begin
	AND sp1.measure&lt;=spb.measure
	AND er.current_indicator_lf = 'Y'
	AND d.ili_inspection_id = {INSPECTION_ID}) d
	WHERE rwn = 1;
	EXCEPTION WHEN NO_DATA_FOUND
	THEN /* не нашлось ничего вокруг, попробую экстраполировать */
	v_odometer1 := -1e6;
	v_measure1 := -1e6; 
	END; 
	
	BEGIN 
	SELECT absolute_odometer,measure
	INTO v_odometer2,v_measure2 
	FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure ASC,d.absolute_odometer DESC) RWN /* mssql compatibility*/
	,d.absolute_odometer
	,sp1.measure
	FROM pods.station_point sp1
	JOIN pods.station_point spb
	USING (series_id)
	JOIN pods.event_range er
	ON sp1.station_id = er.station_id_begin
	JOIN pods.ili_data d
	USING (event_id)
	WHERE spb.station_id = i.station_id_begin
	AND sp1.measure&gt;=spb.measure
	AND er.current_indicator_lf = 'Y'
	AND d.ili_inspection_id = {INSPECTION_ID}) d
	WHERE rwn = 1;
	EXCEPTION WHEN NO_DATA_FOUND
	THEN /* не нашлось ничего вокруг, попробую экстраполировать */
	v_odometer2 := 1e6;
	v_measure2 := 1e6; 
	END; 
	
	IF v_measure2 != v_measure1
	THEN 
	v_begin_odometer := v_odometer1+(i.measure_begin-v_measure1)*(v_odometer2-v_odometer1)/(v_measure2-v_measure1);
	ELSE
	v_begin_odometer := v_odometer1;
	END IF; 
	
	/* END ODOMETER*/ 
	/* Получена точка на трубе, создана или найдена, не важно, необходимо получить значение одометра в этом месте*/
	BEGIN
	SELECT absolute_odometer,measure
	INTO v_odometer1,v_measure1 
	FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure DESC,d.absolute_odometer ASC) RWN /* mssql compatibility*/
	,d.absolute_odometer
	,sp1.measure
	FROM pods.station_point sp1
	JOIN pods.station_point spb
	USING (series_id)
	JOIN pods.event_range er
	ON sp1.station_id = er.station_id_begin
	JOIN pods.ili_data d
	USING (event_id)
	WHERE spb.station_id = i.station_id_end
	AND sp1.measure&lt;=spb.measure
	AND er.current_indicator_lf = 'Y'
	AND d.ili_inspection_id = {INSPECTION_ID}) d
	WHERE rwn = 1;
	EXCEPTION WHEN NO_DATA_FOUND
	THEN /* не нашлось ничего вокруг, попробую экстраполировать */
	v_odometer1 := -1e6;
	v_measure1 := -1e6; 
	END; 
	
	BEGIN 
	SELECT absolute_odometer,measure
	INTO v_odometer2,v_measure2 
	FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure ASC,d.absolute_odometer DESC) RWN /* mssql compatibility*/
	,d.absolute_odometer
	,sp1.measure
	FROM pods.station_point sp1
	JOIN pods.station_point spb
	USING (series_id)
	JOIN pods.event_range er
	ON sp1.station_id = er.station_id_begin
	JOIN pods.ili_data d
	USING (event_id)
	WHERE spb.station_id = i.station_id_end
	AND sp1.measure&gt;=spb.measure
	AND er.current_indicator_lf = 'Y'
	AND d.ili_inspection_id = {INSPECTION_ID}) d
	WHERE rwn = 1;
	EXCEPTION WHEN NO_DATA_FOUND
	THEN /* не нашлось ничего вокруг, попробую экстраполировать */
	v_odometer2 := 1e6;
	v_measure2 := 1e6; 
	END; 
	
	IF v_measure2 != v_measure1
	THEN 
	v_end_odometer := v_odometer1+(i.measure_end-v_measure1)*(v_odometer2-v_odometer1)/(v_measure2-v_measure1);
	ELSE
	v_end_odometer := v_odometer1;
	END IF; 
	
	INSERT INTO pods.event_range(feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf,positioning_type_cl,length) 
	VALUES ('INTERVAL_LAN_REC',i.station_id_begin,i.station_id_end,'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN',/*i.length*/ ABS(i.measure_end-i.measure_begin))
	RETURNING event_id INTO v_event_id;
	
	INSERT INTO pods.sto_ehz_calc (EVENT_ID,ILI_INSPECTION_ID,TYPE_CL,BEGIN_ODOMETER,END_ODOMETER)
	VALUES (v_event_id,{INSPECTION_ID},'Оценка состояния по линейному event-объекту',v_begin_odometer,v_end_odometer);
	
	END LOOP;
	END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_EHZ_INSP_CALC_STO_8" comment="CALC_EHZ_INSP_CALC_STO_8" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
		<var name="CONSTRUCTION_ELEMENT_QUERY"/>
		<var name="config.main.PODS_USER"/>
			<query>
	DO $$
	
	DECLARE
	i RECORD;
	v_station_id_begin NUMERIC;
	v_station_id_end NUMERIC;
	v_station_measure_begin NUMERIC(10,2);
	v_station_measure_end NUMERIC(10,2);
	v_route_id NUMERIC;
	v_event_like_this Integer;
	v_event_id NUMERIC;
	v_report_measure_begin NUMERIC(10,2);
	v_report_measure_end NUMERIC(10,2);
	v_begin_odometer NUMERIC(10,2);
	v_end_odometer NUMERIC(10,2);
	v_odometer1 NUMERIC(10,2);
	v_odometer2 NUMERIC(10,2);
	v_measure1 NUMERIC(10,2);
	v_measure2 NUMERIC(10,2);
		
	BEGIN
	
	SELECT s.route_id,spb.measure,spe.measure
	INTO v_route_id,v_report_measure_begin,v_report_measure_end
	FROM pods.series s
	JOIN pods.station_point spb
	ON s.series_id = spb.series_id
	JOIN pods.event_range er
	ON er.station_id_begin = spb.station_id
	JOIN pods.station_point spe
	ON er.station_id_end = spe.station_id
	JOIN pods.ili_inspection_range ir
	ON ir.event_id = er.event_id
	
	WHERE ir.ili_inspection_id = {INSPECTION_ID}; 
	
	
	IF v_route_id IS NULL
	OR v_route_id = 0
	THEN
	RETURN;
	END IF;
	
	FOR i IN (WITH my_construction_elements
	AS (SELECT station_id_begin
	FROM pods.event_range er
	WHERE er.event_id in ({CONSTRUCTION_ELEMENT_QUERY})
	AND er.current_indicator_lf = 'Y'),
	structural_elements
	AS (SELECT sp.station_id,sp.measure
	FROM pods.station_point sp
	JOIN pods.series s
	ON s.series_id = sp.series_id
	WHERE s.route_id = v_route_id
	AND sp.measure BETWEEN v_report_measure_begin AND v_report_measure_end
	AND EXISTS (SELECT 1
	FROM my_construction_elements me
	WHERE me.station_id_begin = sp.station_id)
	UNION ALL
	SELECT DISTINCT FIRST_VALUE(spx.station_id) OVER (PARTITION BY er.event_id ORDER BY ABS(spx.measure - (spb.measure + (spe.measure - spb.measure)/2 ))) station_id
	,FIRST_VALUE(spx.measure) OVER (PARTITION BY er.event_id ORDER BY ABS(spx.measure - (spb.measure + (spe.measure - spb.measure)/2 ))) measure
	FROM pods.event_range er
	JOIN pods.station_point spb
	ON spb.station_id = er.station_id_begin
	JOIN pods.series s
	ON s.series_id = spb.series_id
	JOIN pods.station_point spe
	ON spe.station_id = er.station_id_end
	JOIN pods.station_point spX
	ON s.series_id = spX.series_id
	AND spX.measure BETWEEN spb.measure AND spe.measure
	WHERE er.event_id in ({CONSTRUCTION_ELEMENT_QUERY})
	AND ( (spb.measure BETWEEN v_report_measure_begin AND v_report_measure_end)
	OR (spe.measure BETWEEN v_report_measure_begin AND v_report_measure_end))
	AND er.current_indicator_lf = 'Y'
	AND s.route_id = v_route_id
	AND er.station_id_begin != er.station_id_end),
	limits_station
	AS (
	SELECT MIN(measure) first_measure
	,MAX(measure) last_measure
	,(select station_id from pods.station_point ss where ss.route_id= v_route_id and ss.measure=(select min(measure) from pods.station_point sss where sss.route_id= v_route_id) limit 1) first_station_id
	,(select station_id from pods.station_point ss where ss.route_id= v_route_id and ss.measure=(select max(measure) from pods.station_point sss where sss.route_id= v_route_id) limit 1) last_station_id
	FROM pods.station_point sp
	JOIN pods.series s
	ON s.series_id = sp.series_id
	WHERE s.route_id = v_route_id
	AND sp.measure BETWEEN v_report_measure_begin AND v_report_measure_end),
	combained_junctions
	AS (SELECT first_station_id station_id,first_measure measure
	FROM limits_station ls1
	WHERE NOT EXISTS (SELECT 1 FROM structural_elements se WHERE ls1.first_measure = se.measure)
	UNION ALL
	SELECT station_id,measure
	FROM structural_elements
	UNION ALL
	SELECT last_station_id station_id,last_measure
	FROM limits_station ls2
	WHERE NOT EXISTS (SELECT 1 FROM structural_elements se WHERE ls2.last_measure = se.measure))
	SELECT station_id,measure
	FROM combained_junctions
	ORDER BY measure)
	LOOP
	v_station_id_end := i.station_id;
	v_station_measure_end := i.measure;
	/* Получена точка на трубе, создана или найдена, не важно, необходимо получить значение одометра в этом месте*/
	BEGIN
	SELECT absolute_odometer,measure
	INTO v_odometer1,v_measure1 
	FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure DESC,d.absolute_odometer ASC) RWN /* mssql compatibility*/
	,d.absolute_odometer
	,sp1.measure
	FROM pods.station_point sp1
	JOIN pods.station_point spb
	USING (series_id)
	JOIN pods.event_range er
	ON sp1.station_id = er.station_id_begin
	JOIN pods.ili_data d
	USING (event_id)
	WHERE spb.station_id = v_station_id_end
	AND sp1.measure&lt;=spb.measure
	AND er.current_indicator_lf = 'Y'
	AND d.ili_inspection_id = {INSPECTION_ID}) d
	WHERE rwn = 1;
	EXCEPTION WHEN NO_DATA_FOUND
	THEN /* не нашлось ничего вокруг, попробую экстраполировать */
	v_odometer1 := -1e6;
	v_measure1 := -1e6; 
	END; 
	
	BEGIN 
	SELECT absolute_odometer,measure
	INTO v_odometer2,v_measure2 
	FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure ASC,d.absolute_odometer DESC) RWN /* mssql compatibility*/
	,d.absolute_odometer
	,sp1.measure
	FROM pods.station_point sp1
	JOIN pods.station_point spb
	USING (series_id)
	JOIN pods.event_range er
	ON sp1.station_id = er.station_id_begin
	JOIN pods.ili_data d
	USING (event_id)
	WHERE spb.station_id = v_station_id_end
	AND sp1.measure&gt;=spb.measure
	AND er.current_indicator_lf = 'Y'
	AND d.ili_inspection_id = {INSPECTION_ID}) d
	WHERE rwn = 1;
	EXCEPTION WHEN NO_DATA_FOUND
	THEN /* не нашлось ничего вокруг, попробую экстраполировать */
	v_odometer2 := 1e6;
	v_measure2 := 1e6; 
	END; 
	
	IF v_measure2 != v_measure1
	THEN 
	v_end_odometer := v_odometer1+(i.measure-v_measure1)*(v_odometer2-v_odometer1)/(v_measure2-v_measure1);
	ELSE
	v_end_odometer := v_odometer1;
	END IF; 
	
	/* Если первый проход то пропускаем итерацию цикла */
	IF v_station_id_end IS NOT NULL
	AND v_station_id_begin IS NOT NULL
	THEN 
	
	SELECT count(*)
	INTO v_event_like_this
	FROM pods.event_range er
	WHERE feature_id = 'INTERVAL_PER_OBJ'
	AND current_indicator_lf = 'Y'
	AND station_id_begin = v_station_id_begin
	AND station_id_end = v_station_id_end
	AND EXISTS (SELECT 1
	FROM pods.sto_ehz_calc ic
	WHERE ic.event_id = er.event_id
	AND ic.ili_inspection_id = {INSPECTION_ID});
	
	IF v_event_like_this = 0
	THEN 
	
	INSERT INTO pods.event_range(feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf,positioning_type_cl,length) 
	VALUES ('INTERVAL_PER_OBJ',v_station_id_begin,v_station_id_end,'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN',ABS(v_station_measure_end-v_station_measure_begin))
	RETURNING event_id INTO v_event_id;
	
	INSERT INTO pods.sto_ehz_calc (EVENT_ID,ILI_INSPECTION_ID,TYPE_CL,BEGIN_ODOMETER,END_ODOMETER)
	VALUES (v_event_id,{INSPECTION_ID},'Оценка состояния по межконструкционным участкам',v_begin_odometer,v_end_odometer);
	
	END IF; 
	END IF;
	v_station_id_begin := v_station_id_end;
	v_station_measure_begin := v_station_measure_end;
	v_begin_odometer := v_end_odometer;
	
	END LOOP; 
	EXCEPTION WHEN OTHERS 
	 THEN RAISE EXCEPTION ' произошла ошибка: % код %',SQLERRM, SQLSTATE ; 
	END $$;
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_EHZ_INSP_CALC_STO_9" comment="CALC_EHZ_INSP_CALC_STO_9" schema="UTE" table="CALC_EHZ_INSP_CALC_STO">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
		<var name="REGULAR_INTERVALS_DISTANCE"/>
		<var name="config.main.PODS_USER"/>
			<query>
	DO $$
	
	DECLARE
	i RECORD;
	v_station_id_begin NUMERIC;
	v_station_id_end NUMERIC;
	v_location_id NUMERIC;
	v_srv_district_gcl NUMERIC;
	v_depth_of_cover NUMERIC;
	v_X NUMERIC;
	v_Y NUMERIC;
	v_Z NUMERIC;
	
	v_depth_of_cover1 NUMERIC;
	v_X1 NUMERIC;
	v_Y1 NUMERIC;
	v_Z1 NUMERIC;
	v_measure1 NUMERIC(10,2);
	v_station_id1 NUMERIC;

	v_depth_of_cover2 NUMERIC;
	v_X2 NUMERIC;
	v_Y2 NUMERIC;
	v_Z2 NUMERIC;
	v_measure2 NUMERIC(10,2);
	v_station_id2 NUMERIC;

	v_route_id NUMERIC;
	v_event_like_this Integer;
	v_event_id NUMERIC;
	v_report_measure_begin NUMERIC(10,2);
	v_report_measure_end NUMERIC(10,2);
	v_begin_odometer NUMERIC(10,2);
	v_end_odometer NUMERIC(10,2);
	v_odometer1 NUMERIC(10,2);
	v_odometer2 NUMERIC(10,2);
	BEGIN

	SELECT s.route_id,spb.measure,spe.measure
	INTO v_route_id,v_report_measure_begin,v_report_measure_end
	FROM pods.series s
	JOIN pods.station_point spb
	ON s.series_id = spb.series_id
	JOIN pods.event_range er
	ON er.station_id_begin = spb.station_id
	JOIN pods.station_point spe
	ON er.station_id_end = spe.station_id
	JOIN pods.ili_inspection_range ir
	ON ir.event_id = er.event_id
	WHERE ir.ili_inspection_id = {INSPECTION_ID}; 

	IF v_route_id IS NULL
	OR v_route_id = 0
	THEN
	RETURN;
	END IF; 

	FOR i IN ( WITH row_generator
	AS (SELECT v_report_measure_begin +(series.a-1) * {REGULAR_INTERVALS_DISTANCE} measure FROM generate_series(1, (v_report_measure_end-v_report_measure_begin)/{REGULAR_INTERVALS_DISTANCE} + 1) as series(a)),
	base_sp
	AS (SELECT measure
	,station_id
	,LEAD(measure) OVER(ORDER BY measure) n_measure
	,LEAD(station_id) OVER (ORDER BY measure) n_station_id
	,sp.series
	,sp.station
	,sp.series_id
	,r.route_id
	,r.line_id
	FROM pods.station_point sp
	JOIN pods.series s
	ON s.series_id = sp.series_id
	JOIN pods.route r
	ON r.route_id = s.route_id
	JOIN pods.coordinate c
	ON c.location_id = sp.location_id
	WHERE r.route_id = v_route_id
	AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03'))
	(SELECT sp.line_id, sp.route_id, sp.series_id, sp.series, sp.station, s.measure
	FROM row_generator s
	JOIN base_sp sp
	ON s.measure&gt;=sp.measure
	AND s.measure&lt;sp.n_measure
	UNION ALL
	SELECT s.line_id, s.route_id, s.series_id, MAX(sp.series) series, MAX(sp.station) station, MAX(sp.measure) measure
	FROM pods.series s
	JOIN pods.station_point sp
	ON sp.series_id = s.series_id
	JOIN PODS.coordinate c
	ON c.location_id = sp.location_id
	WHERE s.route_id = v_route_id
	AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03')
	AND sp.measure BETWEEN v_report_measure_begin AND v_report_measure_end
	GROUP BY s.line_id, s.route_id, s.series_id, sp.series)
	ORDER BY MEASURE)
	LOOP

	v_station_id_begin := v_station_id_end;
	v_begin_odometer := v_end_odometer;

	SELECT count(*)
	INTO v_event_like_this
	FROM pods.event_range er
	JOIN pods.station_point spe
	ON er.station_id_end = spe.station_id
	JOIN pods.series s
	ON s.series_id = spe.series_id
	WHERE feature_id = 'INTERVAL_REGULAR'
	AND er.CURRENT_INDICATOR_LF = 'Y'
	AND spe.measure = i.measure
	AND spe.type_cl = 'ST_POINT_TYPE_04'
	AND length = {REGULAR_INTERVALS_DISTANCE}
	AND s.route_id = v_route_id
	AND EXISTS (SELECT 1
	FROM pods.sto_ehz_calc ic
	WHERE ic.event_id = er.event_id
	AND ic.ili_inspection_id = {INSPECTION_ID});

	IF v_event_like_this = 0
	THEN 

	/* необходимо интерполировать значения с соседних пикетов*/

                SELECT l.srv_district_gcl
 			,l.depth_of_cover
 			,c.x_coord
 			,c.y_coord
 			,c.z_coord
 			,sp.measure
			,sp.station_id
 			INTO v_srv_district_gcl
 			,v_depth_of_cover1 
 			,v_X1 
 			,v_Y1 
 			,v_Z1 
 			,v_measure1
			,v_station_id1			 
 			FROM pods.station_point sp
 			JOIN pods.location l
 			ON l.location_id = sp.location_id
 			JOIN pods.coordinate c 
 			ON c.location_id = sp.location_id 
 			WHERE sp.route_id=i.route_id
                         and sp.measure = (SELECT max(sp2.measure) 
                        FROM pods.station_point sp2
                        WHERE sp2.route_id=v_route_id 
                        AND sp2.measure &lt;=i.measure)
                        limit 1;
 
 			SELECT l.depth_of_cover
 			,c.x_coord
 			,c.y_coord
 			,c.z_coord
 			,sp.measure
			,sp.station_id
 			INTO v_depth_of_cover2 
 			,v_X2 
 			,v_Y2 
 			,v_Z2 
 			,v_measure2 
			,v_station_id2
 			FROM pods.station_point sp
 			JOIN pods.location l
 			ON l.location_id = sp.location_id
 			JOIN pods.coordinate c 
 			ON c.location_id = sp.location_id 
 			WHERE sp.route_id=i.route_id
                         and sp.measure = (SELECT min(sp2.measure) 
                        FROM pods.station_point sp2
                        WHERE sp2.route_id=v_route_id 
                        AND sp2.measure &gt;=i.measure)
                        limit 1; 
      
                  IF abs(v_measure2 - v_measure1)>{REGULAR_INTERVALS_DISTANCE}*0.1
                  THEN 
                  v_depth_of_cover := v_depth_of_cover1+(i.measure-v_measure1)*(v_depth_of_cover2-v_depth_of_cover1)/(v_measure2-v_measure1);
                  v_X := v_X1+(i.measure-v_measure1)*(v_X2-v_X1)/(v_measure2-v_measure1); 
                  v_Y := v_Y1+(i.measure-v_measure1)*(v_Y2-v_Y1)/(v_measure2-v_measure1); 
                  v_Z := v_Z1+(i.measure-v_measure1)*(v_Z2-v_Z1)/(v_measure2-v_measure1);
                  INSERT INTO pods.location (srv_district_gcl,depth_of_cover) VALUES (v_srv_district_gcl,v_depth_of_cover)
                  RETURNING location_id INTO v_location_id;
      
                  INSERT INTO pods.station_point (line_id,route_id,series_id,series,location_id,station,measure,type_cl)
                  VALUES (i.line_id,i.route_id,i.series_id,i.series,v_location_id,i.station,i.measure,'ST_POINT_TYPE_04')
                  RETURNING station_id INTO v_station_id_end; 
      
                  INSERT INTO pods.coordinate(coordinate_source_id, location_id, x_coord, y_coord, z_coord
                  ,type_cl, horiz_indicator_lf, vert_indicator_lf, current_indicator_lf
                  ,effective_from_date, accuracy_cl, create_date, pods_user)
                  VALUES (9,v_location_id,v_X,v_Y,v_Z,'ASG','Y', 'Y', 'Y',current_timestamp, 'MEDIUM', current_timestamp, '{config.main.PODS_USER}');
                  ELSE
                  v_station_id_end:=v_station_id1;
                  END IF; 

	ELSE
	SELECT MIN(spe.station_id)
	INTO v_station_id_end
	FROM pods.event_range er
	JOIN pods.station_point spe
	ON er.station_id_end = spe.station_id
	JOIN pods.series s
	ON s.series_id = spe.series_id
	WHERE feature_id = 'INTERVAL_REGULAR'
	AND er.CURRENT_INDICATOR_LF = 'Y'
	AND spe.measure = i.measure
	AND spe.type_cl = 'ST_POINT_TYPE_04'
	AND length = {REGULAR_INTERVALS_DISTANCE}
	AND s.route_id = v_route_id
	AND EXISTS (SELECT 1
	FROM pods.sto_ehz_calc ic
	WHERE ic.event_id = er.event_id
	AND ic.ili_inspection_id = {INSPECTION_ID});

	END IF;
	/* Получена точка на трубе, создана или найдена, не важно, необходимо получить значение одометра в этом месте*/
	BEGIN
	SELECT absolute_odometer,measure
	INTO v_odometer1,v_measure1 
	FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure DESC,d.absolute_odometer ASC) RWN /* mssql compatibility*/
	,d.absolute_odometer
	,sp1.measure
	FROM pods.station_point sp1
	JOIN pods.station_point spb
	USING (series_id)
	JOIN pods.event_range er
	ON sp1.station_id = er.station_id_begin
	JOIN pods.ili_data d
	USING (event_id)
	WHERE spb.station_id = v_station_id_end
	AND sp1.measure&lt;=spb.measure
	AND er.current_indicator_lf = 'Y'
	AND d.ili_inspection_id = {INSPECTION_ID}) d
	WHERE rwn = 1;
	EXCEPTION WHEN NO_DATA_FOUND
	THEN /* не нашлось ничего вокруг, попробую экстраполировать */
	v_odometer1 := -1e6;
	v_measure1 := -1e6; 
	END; 

	BEGIN 
	SELECT absolute_odometer,measure
	INTO v_odometer2,v_measure2 
	FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure ASC,d.absolute_odometer DESC) RWN /* mssql compatibility*/
	,d.absolute_odometer
	,sp1.measure
	FROM pods.station_point sp1
	JOIN pods.station_point spb
	USING (series_id)
	JOIN pods.event_range er
	ON sp1.station_id = er.station_id_begin
	JOIN pods.ili_data d
	USING (event_id)
	WHERE spb.station_id = v_station_id_end
	AND sp1.measure&gt;=spb.measure
	AND er.current_indicator_lf = 'Y'
	AND d.ili_inspection_id = {INSPECTION_ID}) d
	WHERE rwn = 1;
	EXCEPTION WHEN NO_DATA_FOUND
	THEN /* не нашлось ничего вокруг, попробую экстраполировать */
	v_odometer2 := 1e6;
	v_measure2 := 1e6; 
	END; 

	IF v_measure2 != v_measure1
	THEN 
	v_end_odometer := v_odometer1+(i.measure-v_measure1)*(v_odometer2-v_odometer1)/(v_measure2-v_measure1);
	ELSE
	v_end_odometer := v_odometer1;
	END IF; 

	/* Если первый проход то пропускаем итерацию цикла */
	IF v_station_id_begin IS NOT NULL
	THEN
	INSERT INTO pods.event_range(feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf,positioning_type_cl,length)
	VALUES ('INTERVAL_REGULAR',v_station_id_begin,v_station_id_end,'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN',{REGULAR_INTERVALS_DISTANCE})
	RETURNING event_id INTO v_event_id;

	INSERT INTO pods.sto_ehz_calc (EVENT_ID,ILI_INSPECTION_ID,TYPE_CL,BEGIN_ODOMETER,END_ODOMETER)
	VALUES (v_event_id,{INSPECTION_ID},'Оценка состояния по регулярным участкам ({REGULAR_INTERVALS_DISTANCE}m)',v_begin_odometer,v_end_odometer);

	END IF;

	END LOOP;
	EXCEPTION WHEN OTHERS
	THEN RAISE EXCEPTION ' произошла ошибка: % код %',SQLERRM, SQLSTATE ; 
	END $$;
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_ILI_CALC_CLUSTER_1" comment="CALC_ILI_CALC_CLUSTER_1" schema="UTE" table="CALC_ILI_CALC_CLUSTER">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			SELECT CASE d.anomaly_extension_cl
 			WHEN 'ANOMALY_EXT_001' THEN 'Группа поверхностных дефектов'
 			WHEN 'ANOMALY_EXT_005' THEN 'Группа поверхностных дефектов'
 			WHEN 'ANOMALY_EXT_009' THEN 'Группа поверхностных дефектов'
 			/*WHEN 'ANOMALY_EXT_002' THEN 'Ремонтное место'*/
 			WHEN 'ANOMALY_EXT_003' THEN 'Ремонтное место'
 			END "CLUSTER_TYPE"
 			,coalesce(d.length,0) "LENGTH"
 			,coalesce(d.width,0) "WIDTH"
 			,coalesce(d.nominal_wall_thickness,0) "NOMINAL_WALL_THICKNESS"
 			,d.absolute_odometer "ABSOLUTE_ODOMETER"
 			,d.weld_number "WELD_NUMBER"
 			,d.ili_data_id "ILI_DATA_ID"
 			,CASE WHEN d.orientation_deg IS NULL
 			THEN 6*30
 			ELSE d.orientation_deg 
 			END "ORIENTATION_DEG"
 			,0 proceed 
 			FROM pods.ili_data d
 			JOIN pods.ili_anomaly_type_cl ia
 			ON d.anomaly_type_cl = ia.code 
 			WHERE d.anomaly_extension_cl IN ('ANOMALY_EXT_001','ANOMALY_EXT_005','ANOMALY_EXT_009',/*'ANOMALY_EXT_002',*/'ANOMALY_EXT_003')
 			AND ia.category_cl = 1
 			AND d.ili_inspection_id = {INSPECTION_ID} ORDER BY d.absolute_odometer
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_ILI_CALC_CLUSTER_2" comment="CALC_ILI_CALC_CLUSTER_2" schema="UTE" table="CALC_ILI_CALC_CLUSTER">
	<insert>
		<dbCommand>
		<var name="EFFECTIVE_LENGTH" type="Decimal"/>	
		<var name="EFFECTIVE_WIDTH" type="Decimal"/>			
		<var name="EFFECTIVE_AREA" type="Decimal"/>	
		<var name="CLUSTER_TYPE" type="String"/>	
		<var name="ILI_INSPECTION_ID" type="Decimal"/>
		<var name="ANOMALY_COUNT" type="Decimal"/>
		<var name="ILI_CLUSTER_ID" type="Decimal" default="SELECT max(ILI_CLUSTER_ID) id FROM pods.ili_cluster" />			
			<query>
			DO $$
			DECLARE
 			v_ili_cluster_id NUMERIC;
 
			BEGIN
 
 			INSERT INTO pods.ili_cluster (effective_length,effective_width,effective_area,description,event_id,ili_inspection_id,comments)
 			VALUES (CASE WHEN {EFFECTIVE_LENGTH} > 9999
 			THEN 9999
 			ELSE {EFFECTIVE_LENGTH}
 			END 
 			,{EFFECTIVE_WIDTH},{EFFECTIVE_AREA},'{CLUSTER_TYPE}',-110,{ILI_INSPECTION_ID},'calc anomaly count: '||{ANOMALY_COUNT})
 			RETURNING ili_cluster_id INTO v_ili_cluster_id ; 
 
 			INSERT INTO pods.sto_ili_cluster_calc (ILI_INSPECTION_ID,ILI_CLUSTER_ID,CLUSTER_COMMENT) 
 			VALUES ({ILI_INSPECTION_ID},v_ili_cluster_id
 			,CASE '{CLUSTER_TYPE}'
 			WHEN 'Группа поверхностных дефектов' THEN 'п. 8, СТО Газпром 2-2.2-595-2011 '
 			WHEN 'Ремонтное место' THEN 'п. 7.4, СТО Газпром 2-2.2-595-2011 '
 			END);
 
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>
 
<data id="CALC_ILI_CALC_CLUSTER_3" comment="CALC_ILI_CALC_CLUSTER_3" schema="UTE" table="CALC_ILI_CALC_CLUSTER">
	<insert>
		<dbCommand>
		<var name="ILI_CLUSTER_ID" type="Decimal"/>	
		<var name="ILI_DATA_ID" type="Decimal"/>			
			<query>
			DO $$
			
			BEGIN
 			UPDATE pods.ili_data 
 			SET ili_cluster_id = {ILI_CLUSTER_ID}
 			WHERE ili_data_id = {ILI_DATA_ID};
 
 			UPDATE pods.sto_ili_data_calc 
 			SET ili_cluster_id = {ILI_CLUSTER_ID}
 			WHERE ili_data_id = {ILI_DATA_ID};
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>
 
<data id="CALC_ILI_CALC_CLUSTER_4" comment="CALC_ILI_CALC_CLUSTER_4" schema="UTE" table="CALC_ILI_CALC_CLUSTER">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
			<query>
	DO $$

	BEGIN

	insert into pods.sto_ili_data_calc(ILI_INSPECTION_ID,ILI_DATA_ID) SELECT def.ILI_INSPECTION_ID,def.ILI_DATA_ID 

	FROM PODS.ILI_DATA def
	JOIN PODS.ILI_ANOMALY_TYPE_CL ia 
	ON def.anomaly_type_cl=ia.code 
	WHERE def.ILI_INSPECTION_ID = {INSPECTION_ID}
	AND ia.category_cl=1
	ON CONFLICT (ILI_DATA_ID) DO UPDATE SET
	ILI_CLUSTER_ID = NULL 


	,CLUSTER_COMMENT = NULL 
	,R_595_2011_REPAIR_METHOD = NULL 
	,R_595_2011_DEPTH_ABRASION = NULL 
	,R_595_2011_SQUARE_ABRASION = NULL 
	,R_595_2011_LENGTH_PIPE_REPAIR = NULL 
	,R_595_2011_COMMENT = NULL 
	,STO_112_2007_ASSURANCE_FACTOR = NULL 
	,STO_112_2007_DESTRUCT_PRESSURE = NULL
	,STO_112_2007_ALLOW_PRESSURE = NULL 
	,STO_112_2007_PERFORMANCE_EVAL = NULL 
	,STO_173_2007_CRITICAL_PRESSURE = NULL
	,STO_173_2007_DANGER_DEGREE = NULL 
	,STO_173_2007_SAFE_PRESSURE = NULL 
	,STO_292_2007_DANGER_RANK = NULL 
	,STO_401_2009_FAIL_PROBABILITY = NULL; 

	END $$;
 
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_ILI_CALC_CLUSTER_5" comment="CALC_ILI_CALC_CLUSTER_5" schema="UTE" table="CALC_ILI_CALC_CLUSTER">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
			<query>
	DO $$
	DECLARE
	BEGIN 

	update pods.ili_cluster d set 
	description = (SELECT CASE COUNT(*) WHEN 0 THEN 'Группа поверхностных дефектов без КРН'
	ELSE 'Группа поверхностных дефектов с КРН'
	END
	FROM pods.ili_data d,pods.ili_cluster icc
	WHERE d.ili_cluster_id =icc.ili_cluster_id and icc.description like 'Группа поверхностных дефектов%' 
	AND icc.ili_inspection_Id = {INSPECTION_ID}
	AND d.anomaly_extension_cl = 'ANOMALY_EXT_005') 
	where d.ili_cluster_id in (SELECT ic.ili_cluster_id FROM pods.ili_cluster ic
	WHERE description like 'Группа поверхностных дефектов%' 
	AND ili_inspection_Id = {INSPECTION_ID});

	update PODS.ILI_CLUSTER d set
	AVG_DEPTH = (SELECT
	AVG(dd.average_depth) avg_depth
	FROM pods.ili_data dd
	WHERE dd.ili_inspection_id = {INSPECTION_ID}
	AND dd.ili_cluster_id=d.ili_cluster_id
	GROUP BY dd.ili_cluster_id)
	,avg_length = (SELECT 
	CASE WHEN AVG(dd.length) > 9999
	THEN 9999
	ELSE AVG(dd.length)
	END 
	FROM pods.ili_data dd
	WHERE dd.ili_inspection_id = {INSPECTION_ID}
	AND dd.ili_cluster_id=d.ili_cluster_id
	GROUP BY dd.ili_cluster_id)
	,avg_orientation = (SELECT 
	ROUND(AVG (dd.orientation_deg),1) avg_orientation
	FROM pods.ili_data dd
	WHERE dd.ili_inspection_id = {INSPECTION_ID}
	AND dd.ili_cluster_id =d.ili_cluster_id
	GROUP BY dd.ili_cluster_id)
	,avg_width = (SELECT 
	CASE WHEN AVG(dd.width) > 9999.99
	THEN 9999.99
	ELSE AVG(dd.width)
	END 
	FROM pods.ili_data dd
	WHERE dd.ili_inspection_id = {INSPECTION_ID}
	AND dd.ili_cluster_id =d.ili_cluster_id
	GROUP BY dd.ili_cluster_id)
	,anomaly_count = (SELECT COUNT(*) 
	FROM pods.ili_data dd
	WHERE dd.ili_inspection_id = {INSPECTION_ID}
	AND dd.ili_cluster_id =d.ili_cluster_id
	GROUP BY dd.ili_cluster_id) 
	where 
	d.ili_cluster_id in (select dd.ili_cluster_id from pods.ili_data dd where dd.ili_inspection_id = {INSPECTION_ID});


	update pods.event_range dd SET
	validity_tolerance =(select 
	AVG(erD.validity_tolerance) validity_tolerance
	FROM pods.ili_data d
	JOIN pods.ili_cluster c
	ON d.ili_cluster_id = c.ili_cluster_id
	JOIN pods.event_range erC
	ON erC.event_id = c.event_id 
	JOIN pods.event_range erD
	ON erD.event_id = d.event_id 
	WHERE d.ili_inspection_id = {INSPECTION_ID}
	AND d.ili_cluster_id is not null and erC.event_id = dd.event_id
	GROUP BY erC.event_id)
	where exists (select 1 from pods.ili_data d
	JOIN pods.ili_cluster c
	ON d.ili_cluster_id = c.ili_cluster_id
	JOIN pods.event_range erC
	ON erC.event_id = c.event_id 
	JOIN pods.event_range erD
	ON erD.event_id = d.event_id 
	WHERE d.ili_inspection_id = {INSPECTION_ID}
	AND d.ili_cluster_id is not null and erC.event_id = dd.event_id); 

	END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_ILI_CALC_CLUSTER_6" comment="CALC_ILI_CALC_CLUSTER_6" schema="UTE" table="CALC_ILI_CALC_CLUSTER">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
			<query>
						DO $$
	BEGIN 
	UPDATE pods.ili_data 
	SET ili_Cluster_id = NULL
	WHERE ili_inspection_id = {INSPECTION_ID};
	update pods.sto_ili_data_calc d
	SET ILI_CLUSTER_ID = NULL 
	,CLUSTER_COMMENT = NULL 
	,R_595_2011_REPAIR_METHOD = NULL 
	,R_595_2011_DEPTH_ABRASION = NULL 
	,R_595_2011_SQUARE_ABRASION = NULL 
	,R_595_2011_LENGTH_PIPE_REPAIR = NULL 
	,R_595_2011_COMMENT = NULL 
	,STO_112_2007_ASSURANCE_FACTOR = NULL 
	,STO_112_2007_DESTRUCT_PRESSURE = NULL
	,STO_112_2007_ALLOW_PRESSURE = NULL 
	,STO_112_2007_PERFORMANCE_EVAL = NULL 
	,STO_173_2007_CRITICAL_PRESSURE = NULL
	,STO_173_2007_DANGER_DEGREE = NULL 
	,STO_173_2007_SAFE_PRESSURE = NULL 
	,STO_292_2007_DANGER_RANK = NULL 
	,STO_401_2009_FAIL_PROBABILITY = NULL
	where ili_data_id in 
	(SELECT def.ILI_DATA_ID 
	FROM PODS.ILI_DATA def
	JOIN PODS.ILI_ANOMALY_TYPE_CL ia 
	ON def.anomaly_type_cl=ia.code 
	WHERE def.ILI_INSPECTION_ID = {INSPECTION_ID}
	AND ia.category_cl=1) ; 

	UPDATE pods.event_range 
	SET station_id_Begin =0
	,station_id_end =0
	,current_indicator_lf = 'N' 
	WHERE feature_id = 'ILI_CLUSTER'
	AND event_id IN (SELECT event_id
	FROM pods.ili_cluster
	WHERE ili_inspection_id = {INSPECTION_ID}); 

	DELETE 
	FROM pods.sto_ili_cluster_calc
	WHERE ili_inspection_id = {INSPECTION_ID};

	DELETE 
	FROM pods.sto_ili_cluster_calc_adv
	WHERE ili_inspection_id = {INSPECTION_ID};

	DELETE 
	FROM pods.ili_cluster
	WHERE ili_inspection_id = {INSPECTION_ID};
	END $$;
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="CALC_ILI_CALC_PRESSURE_1" comment="CALC_ILI_CALC_PRESSURE_1" schema="UTE" table="CALC_ILI_CALC_PRESSURE">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			WITH 
			report 
 			AS (SELECT i.*, r.event_id event_id, s.route_id,
 			s.station_begin station_beg, s.station_end station_end,
 			c.description company_name,
 			CASE
 			WHEN l.line_id = 0
 			THEN 'Отчет не рассчитан. '
 			ELSE rtc.description
 			END route_type,
 			CASE
 			WHEN l.line_id = 0
 			THEN r.description
 			ELSE l.description
 			END line_name,
 			(SELECT count(*)
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) WELDS_COUNT,
 			(SELECT ABS(MAX(F.ABSOLUTE_ODOMETER)-MIN(F.ABSOLUTE_ODOMETER))/1000 
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) INSP_LENGTH 
 			FROM pods.ili_inspection i JOIN pods.ili_inspection_range r
 			ON r.ili_inspection_id = i.ili_inspection_id and i.ili_inspection_id={INSPECTION_ID}
 			JOIN pods.event_range e ON e.event_id = r.event_id
 			JOIN pods.station_point sp
 			ON sp.station_id = e.station_id_begin
 			JOIN pods.series s ON s.series_id = sp.series_id
 			JOIN pods.route rt ON sp.route_id = rt.route_id
 			JOIN pods.line l ON sp.line_id = l.line_id
 			JOIN pods.route_type_cl rtc ON rt.type_cl = rtc.code
 			JOIN pods.ili_tool_vendor_cl c
 			ON c.code = i.tool_vendor_cl
 			), 
			diameter 
 			AS (SELECT NULLIF(MIN(ps.nominal_diameter_gcl),0) nominal_diameter_gcl
 			FROM pods.station_point spe 
 			JOIN pods.event_range eps
 			ON spe.station_id = eps.station_id_begin AND eps.FEATURE_ID = 'PIPE_SEGMENT'
 			JOIN pods.pipe_segment ps 
 			ON eps.event_id = ps.event_id 
 			JOIN report
 			ON report.route_id = spe.route_id),
			defect_pipe_length 
 			AS (SELECT dd.ili_data_id,coalesce(MIN(ABS(pl.end_odometer-pl.start_odometer)),'10') defect_pipe_length
 			FROM pods.ili_data dd
 			JOIN pods.ili_pipe_length pl
 			ON pl.ili_inspection_id = dd.ili_inspection_id
 			AND pl."weld_number" = dd."weld_number"
 			WHERE dd.ili_inspection_id = {INSPECTION_ID} 
 			GROUP BY dd.ili_data_id), 
			left_marker 
 			AS (SELECT ili_data_id,marker_distance_left,coalesce(marker_name_left,'НЕИЗВЕСТНО') marker_name_left
 			FROM (SELECT dd.ili_data_id
 			,ROW_NUMBER() OVER (PARTITION BY dd.ili_data_id ORDER BY ft.absolute_odometer DESC) rwn
 			,ft.absolute_odometer marker_distance_left
 			,ft.feature_description marker_name_left
 			FROM pods.ili_data dd 
 			JOIN pods.ili_data ft
 			ON ft.ili_inspection_id =dd.ili_inspection_id
 			AND ft.absolute_odometer &lt; dd.absolute_odometer
 			WHERE ft.anomaly_type_cl IN ( SELECT code
 			FROM pods.ili_anomaly_type_cl
 			WHERE category_cl = 2)
 			AND dd.ili_inspection_id = {INSPECTION_ID}) x01
			WHERE rwn = 1), 
			right_marker
 			AS (SELECT ili_data_id,marker_distance_right,coalesce(marker_name_right,'НЕИЗВЕСТНО') marker_name_right
 			FROM (SELECT dd.ili_data_id ,ROW_NUMBER() OVER (PARTITION BY dd.ili_data_id ORDER BY ft.absolute_odometer ASC) rwn
 			,ft.absolute_odometer marker_distance_right
 			,ft.feature_description marker_name_right
 			FROM pods.ili_data dd 
 			JOIN pods.ili_data ft
 			ON ft.ili_inspection_id =dd.ili_inspection_id
 			AND ft.absolute_odometer &gt; dd.absolute_odometer
 			WHERE ft.anomaly_type_cl IN ( SELECT code FROM pods.ili_anomaly_type_cl
 			WHERE category_cl = 2)
 			AND dd.ili_inspection_id = {INSPECTION_ID}) x02
			WHERE rwn = 1)
 			SELECT 
			sorter "SORTER",
			ID "ID",
 			orientation_deg "ORIENTATION_DEG",
 			nominal_wall_thickness "NOMINAL_WALL_THICKNESS",
 			weld_number "WELD_NUMBER",
 			station "STATION",
 			calibrated_measure "CALIBRATED_MEASURE",
 			ili_data_id "ILI_DATA_ID",
 			LENGTH "LENGTH",
 			average_depth "AVERAGE_DEPTH",
 			width "WIDTH",
 			absolute_odometer "ABSOLUTE_ODOMETER",
 			anomaly_type_cl "ANOMALY_TYPE_CL",
 			anomaly_extension_cl "ANOMALY_EXTENSION_CL",
 			feature_description "FEATURE_DESCRIPTION",
 			type_description "TYPE_DESCRIPTION",
 			description "DESCRIPTION",
 			line_name "LINE_NAME",
 			begin_date "BEGIN_DATE",
 			company_name "COMPANY_NAME",
 			x_coord "X_COORD",
 			y_coord "Y_COORD",
 			z_coord "Z_COORD",
 			depth_of_cover "DEPTH_OF_COVER",
 			nominal_diameter_gcl "NOMINAL_DIAMETER_GCL",
 			marker_distance_left "MARKER_DISTANCE_LEFT",
 			marker_name_left "MARKER_NAME_LEFT",
 			marker_distance_right "MARKER_DISTANCE_RIGHT",
 			marker_name_right "MARKER_NAME_RIGHT",
 			defect_pipe_length "DEFECT_PIPE_LENGTH",
 			anomaly_group "ANOMALY_GROUP",
 			US_WELD_DISTANCE "US_WELD_DISTANCE",
 			DS_WELD_DISTANCE "DS_WELD_DISTANCE",
 			IS_CLUSTER "IS_CLUSTER",
 			ILI_CLUSTER_ID "ILI_CLUSTER_ID", 
 			ILI_INSPECTION_ID "ILI_INSPECTION_ID",
 			WELDS_COUNT "WELDS_COUNT",
 			INSP_LENGTH "INSP_LENGTH"
 			,cluster_comment "CLUSTER_COMMENT"
			,R_595_2011_COMMENT "R_595_2011_COMMENT"
 			,R_595_2011_DEPTH_ABRASION "R_595_2011_DEPTH_ABRASION"
 			,R_595_2011_LENGTH_PIPE_REPAIR "R_595_2011_LENGTH_PIPE_REPAIR"
 			,R_595_2011_REPAIR_METHOD "R_595_2011_REPAIR_METHOD"
 			,R_595_2011_SQUARE_ABRASION "R_595_2011_SQUARE_ABRASION"
 			,STO_112_2007_ALLOW_PRESSURE "STO_112_2007_ALLOW_PRESSURE"
 			,STO_112_2007_ASSURANCE_FACTOR "STO_112_2007_ASSURANCE_FACTOR"
 			,STO_112_2007_DESTRUCT_PRESSURE "STO_112_2007_DESTRUCT_PRESSURE"
 			,STO_112_2007_PERFORMANCE_EVAL "STO_112_2007_PERFORMANCE_EVAL"
 			,STO_173_2007_CRITICAL_PRESSURE "STO_173_2007_CRITICAL_PRESSURE"
 			,STO_173_2007_DANGER_DEGREE "STO_173_2007_DANGER_DEGREE"
 			,STO_173_2007_SAFE_PRESSURE "STO_173_2007_SAFE_PRESSURE"
 			,STO_292_2007_DANGER_RANK "STO_292_2007_DANGER_RANK"
 			,STO_401_2009_FAIL_PROBABILITY "STO_401_2009_FAIL_PROBABILITY"
 			,R_620_2011_DATE_TEST "R_620_2011_DATE_TEST"
 			,R_620_2011_DATE_REPAIR "R_620_2011_DATE_REPAIR"
 			,STO_112_2007_WORK_PRESS_KOEF "STO_112_2007_WORK_PRESS_KOEF"
 			,STO_112_2007_COMPRESS_STRENGTH "STO_112_2007_COMPRESS_STRENGTH"
 			,STO_112_2007_LENGTH_KOEF "STO_112_2007_LENGTH_KOEF"
 			,LTG_THICKNESS_MEASURED "LTG_THICKNESS_MEASURED"
 			,LTG_CORROSION_SPEED "LTG_CORROSION_SPEED"
 			,LTG_TIME_FROM_LAST_REPAIR "LTG_TIME_FROM_LAST_REPAIR"
 			,LTG_THICKNESS_TO_DESTROY "LTG_THICKNESS_TO_DESTROY"
 			,LTG_RESIDUAL_LIFE "LTG_RESIDUAL_LIFE"
 			,LTG_MIN_THICKNESS_ALLOW "LTG_MIN_THICKNESS_ALLOW"
 			,LTG_ACTUAL_RES_THICKNESS "LTG_ACTUAL_RES_THICKNESS"
 			,LTG_PROBAB_CORROSION_SPEED "LTG_PROBAB_CORROSION_SPEED"
 			,LTG_DEPTH_TO_DESTROY "LTG_DEPTH_TO_DESTROY"
 			,LTG_TIME_TO_DESTROY "LTG_TIME_TO_DESTROY"
 			,LTG_REPAIR_METHOD "LTG_REPAIR_METHOD"
 			,PIPE_PARAMS "PIPE_PARAMS"
 			,PAR_NOMINAL_DIAMETER_GCL "PAR_NOMINAL_DIAMETER_GCL"
 			,PAR_NOMINAL_WALL_THICKNESS_GCL "PAR_NOMINAL_WALL_THICKNESS_GCL"
 			,PAR_WORK_PRESSURE "PAR_WORK_PRESSURE"
 			,PAR_DOT_CLASS_RATING_GCL "PAR_DOT_CLASS_RATING_GCL"
 			,PAR_DATE_BEGIN_EXP "PAR_DATE_BEGIN_EXP"
 			,PAR_DATE_LAST_ILI "PAR_DATE_LAST_ILI"
			,PAR_YYIELDING_LIMIT_MIN "PAR_YYIELDING_LIMIT_MIN"
			,PAR_SAFETY_FACTOR "PAR_SAFETY_FACTOR"
			,PAR_IMPACT_TOUGHNESS "PAR_IMPACT_TOUGHNESS"
			,PAR_BREAK_POINT_MIN "PAR_BREAK_POINT_MIN"
 			FROM (SELECT sorter,CASE IS_CLUSTER
 			WHEN 0 THEN def.ili_cluster_id 
 			ELSE def.ili_data_id 
 			END ID,
 			coalesce(def.orientation_deg/360*12,0) orientation_deg /*ориентация дефекта в градусах */,
 			coalesce(def.nominal_wall_thickness, '16' ) nominal_wall_thickness /*толщина стенки */,
 			coalesce(def.weld_number, 'НЕИЗВЕСТНО') weld_number /*номер трубы */,
 			coalesce(def.station, -999) station /*километр */,
 			coalesce(def.calibrated_measure,-999) calibrated_measure /*линейная дистация геодезическая */,
 			def.ili_data_id ili_data_id /*идентификатор дефекта*/,
 			coalesce(def.LENGTH, 0) LENGTH /*длина дефекта*/,
 			coalesce(def.average_depth, '5' ) average_depth /*средняя глубина поражения*/,
 			coalesce(def.width, 0) width /*ширина*/,
 			coalesce(def.absolute_odometer,-999) absolute_odometer /*линейная дистация геодезическая*/,
 			coalesce(def.anomaly_type_cl,0) anomaly_type_cl /*прикрутить справочник */,
 			coalesce(def.anomaly_extension_cl,'UNKNOWN') anomaly_extension_cl,
 			coalesce(def.feature_description,'НЕИЗВЕСТНО') feature_description /* описание дефекта */,
 			coalesce(def_description, 'НЕИЗВЕСТНО') type_description /*тип дефекта */,
 			coalesce(def.description, ' ') description /* описание */,
 			CASE WHEN report.line_name IS NOT NULL
 			THEN coalesce(report.route_type, '')|| ' '|| coalesce(report.line_name, '')|| ' '|| coalesce(report.station_beg::text, '')|| ' - '|| coalesce(report.station_end::text, '')|| ' км 

			'
 			ELSE 'НЕИЗВЕСТНО' 
 			END line_name,
 			report.begin_date begin_date /*дата проведения */,
 			coalesce(report.company_name, 'НЕИЗВЕСТНО') company_name,
 			coalesce(def.x_coord,-999) x_coord, /*долгота */
 			coalesce(def.y_coord,-999) y_coord, /*широта */
 			coalesce(def.z_coord,-999) z_coord, /*абс. высота */
 			coalesce(def.depth_of_cover,-999) depth_of_cover /* глубина заложения */,
 			coalesce(diameter.nominal_diameter_gcl ,1420) nominal_diameter_gcl,
 			coalesce(ABS( absolute_odometer - lm.marker_distance_left),-999) marker_distance_left /*Дистанция до маркера слева */,
 			lm.marker_name_left /* Имя маркера слева*/ ,
 			coalesce(ABS( absolute_odometer - rm.marker_distance_right),-999) marker_distance_right /* дистанция до маркера справа */ ,
 			rm.marker_name_right /*имя маркера справа*/,
 			coalesce(dpl.defect_pipe_length,10) defect_pipe_length,
 			anomaly_group anomaly_group,
 			coalesce(US_WELD_DISTANCE,0) US_WELD_DISTANCE,
 			coalesce(DS_WELD_DISTANCE,0) DS_WELD_DISTANCE,
 			IS_CLUSTER,
 			ILI_CLUSTER_ID, 
 			coalesce(def.ili_inspection_id,0) ILI_INSPECTION_ID,
 			coalesce(report.WELDS_COUNT,10000) WELDS_COUNT,
 			coalesce(report.INSP_LENGTH,100) INSP_LENGTH
 			,cluster_comment cluster_comment
 			,r_595_2011_comment r_595_2011_comment
 			,r_595_2011_depth_abrasion r_595_2011_depth_abrasion
 			,r_595_2011_length_pipe_repair r_595_2011_length_pipe_repair
 			,r_595_2011_repair_method r_595_2011_repair_method
 			,r_595_2011_square_abrasion r_595_2011_square_abrasion
 			,sto_112_2007_allow_pressure sto_112_2007_allow_pressure
 			,sto_112_2007_assurance_factor sto_112_2007_assurance_factor
 			,sto_112_2007_destruct_pressure sto_112_2007_destruct_pressure
 			,sto_112_2007_performance_eval sto_112_2007_performance_eval
 			,sto_173_2007_critical_pressure sto_173_2007_critical_pressure
 			,sto_173_2007_danger_degree sto_173_2007_danger_degree
 			,sto_173_2007_safe_pressure sto_173_2007_safe_pressure
 			,sto_292_2007_danger_rank sto_292_2007_danger_rank
 			,sto_401_2009_fail_probability sto_401_2009_fail_probability
 			,R_620_2011_DATE_TEST R_620_2011_DATE_TEST
 			,R_620_2011_DATE_REPAIR R_620_2011_DATE_REPAIR
 			,STO_112_2007_WORK_PRESS_KOEF STO_112_2007_WORK_PRESS_KOEF 
 			,STO_112_2007_COMPRESS_STRENGTH STO_112_2007_COMPRESS_STRENGTH
 			,STO_112_2007_LENGTH_KOEF STO_112_2007_LENGTH_KOEF 
 			,LTG_THICKNESS_MEASURED LTG_THICKNESS_MEASURED
 			,LTG_CORROSION_SPEED LTG_CORROSION_SPEED
 			,LTG_TIME_FROM_LAST_REPAIR LTG_TIME_FROM_LAST_REPAIR 
 			,LTG_THICKNESS_TO_DESTROY LTG_THICKNESS_TO_DESTROY
 			,LTG_RESIDUAL_LIFE LTG_RESIDUAL_LIFE
 			,LTG_MIN_THICKNESS_ALLOW LTG_MIN_THICKNESS_ALLOW
 			,LTG_ACTUAL_RES_THICKNESS LTG_ACTUAL_RES_THICKNESS
 			,LTG_PROBAB_CORROSION_SPEED LTG_PROBAB_CORROSION_SPEED
 			,LTG_DEPTH_TO_DESTROY LTG_DEPTH_TO_DESTROY
 			,LTG_TIME_TO_DESTROY LTG_TIME_TO_DESTROY
 			,LTG_REPAIR_METHOD LTG_REPAIR_METHOD
 			,PIPE_PARAMS
 			,coalesce(PAR.NOMINAL_DIAMETER_GCL,-1) PAR_NOMINAL_DIAMETER_GCL
 			,coalesce(PAR.NOMINAL_WALL_THICKNESS_GCL,-1) PAR_NOMINAL_WALL_THICKNESS_GCL
 			,coalesce(PAR.WORK_PRESSURE,-1) PAR_WORK_PRESSURE
 			,coalesce(PAR.dot_class_rating_cl,'DOT_CLASS_004') PAR_DOT_CLASS_RATING_GCL
 			,PAR.date_begin_exploitation PAR_DATE_BEGIN_EXP
 			,PAR.DATE_LAST_ILI PAR_DATE_LAST_ILI
				,coalesce(PAR.YYIELDING_LIMIT_MIN,-1) PAR_YYIELDING_LIMIT_MIN
				,coalesce(PAR.SAFETY_FACTOR,-1) PAR_SAFETY_FACTOR
				,coalesce(PAR.IMPACT_TOUGHNESS,-1) PAR_IMPACT_TOUGHNESS
				,coalesce(PAR.BREAK_POINT_MIN,-1) PAR_BREAK_POINT_MIN
 			FROM (SELECT d.orientation_deg
 			,d.nominal_wall_thickness
 			,d.weld_number
 			,d.calibrated_measure
 			,d.ili_data_id
 			,d.LENGTH
 			,d.average_depth
 			,d.width
 			,d.absolute_odometer
 			,d.anomaly_type_cl
 			,d.anomaly_extension_cl
 			,d.feature_description
 			,d.description
 			,d.ili_inspection_id
 			,CASE WHEN d.ili_cluster_id IS NOT NULL
 			THEN 1
 			ELSE -1
 			END is_cluster
 			,d.ili_cluster_id
 			,d.ds_weld_distance
 			,d.us_weld_distance
 			,sp.station,sp.route_id sp_route_id,sp.measure sp_measure,
 			ia.description anomaly_type,
 			ia.description def_description,
 			c.x_coord, c.y_coord, c.z_coord, l.depth_of_cover,
 			CASE
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_003' THEN '1'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_004' AND IA.CODE = 121 THEN '1'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_001' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_002' AND IA.CODE !=144 THEN '4'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_005' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_007' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_009' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_006' THEN '3'
 			WHEN IA.CODE !=144 THEN '4'
 			ELSE '-1'
 			END ANOMALY_GROUP,
 			1 COI_COUNT,
 			99 sorter
 			,ad.cluster_comment
 			,ad.r_595_2011_comment
 			,ad.r_595_2011_depth_abrasion
 			,ad.r_595_2011_length_pipe_repair
 			,ad.r_595_2011_repair_method
 			,ad.r_595_2011_square_abrasion
 			,ad.sto_112_2007_allow_pressure
 			,ad.sto_112_2007_assurance_factor
 			,ad.sto_112_2007_destruct_pressure
 			,ad.sto_112_2007_performance_eval
 			,ad.sto_173_2007_critical_pressure
 			,ad.sto_173_2007_danger_degree
 			,ad.sto_173_2007_safe_pressure
 			,ad.sto_292_2007_danger_rank
 			,ad.sto_401_2009_fail_probability
 			,adv.R_620_2011_DATE_TEST
 			,adv.R_620_2011_DATE_REPAIR
 			,adv.STO_112_2007_WORK_PRESS_KOEF 
 			,adv.STO_112_2007_COMPRESS_STRENGTH
 			,adv.STO_112_2007_LENGTH_KOEF 
 			,adv.LTG_THICKNESS_MEASURED
 			,adv.LTG_CORROSION_SPEED
 			,adv.LTG_TIME_FROM_LAST_REPAIR 
 			,adv.LTG_THICKNESS_TO_DESTROY
 			,adv.LTG_RESIDUAL_LIFE
 			,adv.LTG_MIN_THICKNESS_ALLOW
 			,adv.LTG_ACTUAL_RES_THICKNESS
 			,adv.LTG_PROBAB_CORROSION_SPEED
 			,adv.LTG_DEPTH_TO_DESTROY
 			,adv.LTG_TIME_TO_DESTROY
 			,adv.LTG_REPAIR_METHOD
 			,adv.PIPE_PARAMS
 			,sp.measure
 			FROM pods.ili_data d
 			JOIN pods.ili_anomaly_type_cl ia
 			ON d.anomaly_type_cl = ia.code AND ia.category_cl = 1
 			LEFT JOIN pods.event_range e
 			ON d.event_id = e.event_id
 			LEFT JOIN pods.station_point sp
 			ON e.station_id_begin = sp.station_id
 			LEFT JOIN pods.coordinate c
 			ON c.coordinate_id = d.coordinate_id
 			LEFT JOIN pods.LOCATION l
 			ON c.location_id = l.location_id
 			LEFT OUTER JOIN pods.sto_ili_data_calc ad
 			ON ad.ili_data_id = d.ili_data_id 
 			LEFT OUTER JOIN pods.sto_ili_data_calc_adv adv
 			ON adv.ili_data_id = d.ili_data_id 
 			WHERE d.ili_inspection_id = {INSPECTION_ID}
 			UNION ALL
 			/*Пошли кластера*/
 			SELECT ic.avg_orientation::numeric orientation_deg
 			,d.nominal_wall_thickness
 			,d.weld_number
 			,d.calibrated_measure
 			,d.ili_data_id
 			,ic.EFFECTIVE_LENGTH LENGTH
 			,(SELECT MAX(average_depth)
 			FROM pods.ili_data idd
 			WHERE idd.ili_cluster_id = ic.ili_cluster_id) average_depth
 			,ic.EFFECTIVE_WIDTH width
 			,d.absolute_odometer
 			,9 anomaly_type_cl
 			,CASE ic.description
 			WHEN 'Ремонтное место' THEN 'ANOMALY_EXT_003'
 			WHEN 'Группа поверхностных дефектов с КРН' THEN 'ANOMALY_EXT_005'
 			ELSE 'ANOMALY_EXT_001'
 			END anomaly_extension_cl
 			,ic.description feature_description
 			,ic.description
 			,d.ili_inspection_id
 			,0 is_cluster
 			,d.ili_cluster_id
 			,d.ds_weld_distance
 			,d.us_weld_distance
 			,sp.station,sp.route_id sp_route_id,sp.measure sp_measure,
 			ia.description anomaly_type,
 			ia.description def_description,
 			c.x_coord, c.y_coord, c.z_coord, l.depth_of_cover,
 			CASE ic.description
 			WHEN 'Ремонтное место' THEN '1'
 			WHEN 'Группа поверхностных дефектов с КРН' THEN '2'
 			WHEN 'Группа поверхностных дефектов без КРН' THEN '2'
 			ELSE '-1'
 			END anomaly_group,
 			ic.anomaly_count COI_COUNT,
 			0 sorter
 			,ca.cluster_comment
 			,ca.r_595_2011_comment
 			,ca.r_595_2011_depth_abrasion
 			,ca.r_595_2011_length_pipe_repair
 			,ca.r_595_2011_repair_method
 			,ca.r_595_2011_square_abrasion
 			,ca.sto_112_2007_allow_pressure
 			,ca.sto_112_2007_assurance_factor
 			,ca.sto_112_2007_destruct_pressure
 			,ca.sto_112_2007_performance_eval
 			,ca.sto_173_2007_critical_pressure
 			,ca.sto_173_2007_danger_degree
 			,ca.sto_173_2007_safe_pressure
 			,ca.sto_292_2007_danger_rank
 			,ca.sto_401_2009_fail_probability
 			,cav.R_620_2011_DATE_TEST
 			,cav.R_620_2011_DATE_REPAIR
 			,cav.STO_112_2007_WORK_PRESS_KOEF 
 			,cav.STO_112_2007_COMPRESS_STRENGTH
 			,cav.STO_112_2007_LENGTH_KOEF 
 			,cav.LTG_THICKNESS_MEASURED
 			,cav.LTG_CORROSION_SPEED
 			,cav.LTG_TIME_FROM_LAST_REPAIR 
 			,cav.LTG_THICKNESS_TO_DESTROY
 			,cav.LTG_RESIDUAL_LIFE
 			,cav.LTG_MIN_THICKNESS_ALLOW
 			,cav.LTG_ACTUAL_RES_THICKNESS
 			,cav.LTG_PROBAB_CORROSION_SPEED
 			,cav.LTG_DEPTH_TO_DESTROY
 			,cav.LTG_TIME_TO_DESTROY
 			,cav.LTG_REPAIR_METHOD
 			,cav.PIPE_PARAMS
 			,sp.measure

 			FROM pods.ili_data d
 			JOIN pods.ili_anomaly_type_cl ia
 			ON d.anomaly_type_cl = ia.code AND ia.category_cl = 1
 			JOIN (SELECT DISTINCT ic.ili_cluster_id
 			,first_value (id.ili_data_id) OVER (PARTITION BY ic.ili_cluster_id ORDER BY id.absolute_odometer ASC ) ili_data_id
 			,ic.EFFECTIVE_LENGTH
 			,ic.avg_depth
 			,ic.EFFECTIVE_WIDTH
 			,ic.avg_orientation
 			,ic.anomaly_count
 			,ic.description
 			FROM pods.ili_cluster ic
 			JOIN pods.ili_data id
 			ON ic.ili_cluster_id = id.ili_cluster_id
 			AND ic.ili_inspection_id = id.ili_inspection_id
 			WHERE id.ili_inspection_id = {INSPECTION_ID}) ic
 			ON ic.ili_cluster_id = d.ili_cluster_id
 			AND ic.ili_data_id = d.ili_data_id
 			LEFT JOIN pods.event_range e
 			ON d.event_id = e.event_id
 			LEFT JOIN pods.station_point sp
 			ON e.station_id_begin = sp.station_id
 			LEFT JOIN pods.coordinate c
 			ON c.coordinate_id = d.coordinate_id
 			LEFT JOIN pods.LOCATION l
 			ON c.location_id = l.location_id
 			LEFT OUTER JOIN pods.sto_ili_cluster_calc ca
 			ON ca.ili_cluster_id = ic.ili_cluster_id
 			LEFT OUTER JOIN pods.sto_ili_cluster_calc_adv cav
 			ON cav.ili_cluster_id = ic.ili_cluster_id
 			WHERE d.ili_cluster_id IS NOT NULL
 			AND d.ili_inspection_id = {INSPECTION_ID} ) def
 			JOIN report
 			ON def.ili_inspection_id = report.ili_inspection_id
 			LEFT JOIN defect_pipe_length dpl
 			ON dpl.ili_data_id = def.ili_data_id
 			LEFT OUTER JOIN left_marker lm
 			ON lm.ili_data_id = def.ili_data_id
 			LEFT OUTER JOIN right_marker rm
 			ON rm.ili_data_id = def.ili_data_id
 			LEFT outer join pods.sto_temp_pipe_params_to_calc par
 			on def.measure between par.mes_start and par.mes_end
 			CROSS JOIN diameter
 			) d
 			ORDER BY absolute_odometer,sorter
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_ILI_CALC_PRESSURE_2" comment="CALC_ILI_CALC_PRESSURE_2" schema="UTE" table="CALC_ILI_CALC_PRESSURE">
	<insert>
		<dbCommand>
		<var name="IS_CLUSTER" type="Decimal"/>	
		<var name="ID" type="Decimal"/>
		<var name="ILI_INSPECTION_ID" type="Decimal"/>	
		<var name="ILI_DATA_ID" type="Decimal"/>
		<var name="ILI_CLUSTER_ID" type="Decimal"/>		
		<var name="CLUSTER_COMMENT" type="String"/>	
		<var name="R_620_2011_DATE_TEST" type="Decimal"/>
		<var name="R_620_2011_DATE_REPAIR" type="Decimal"/>	
		<var name="STO_112_2007_WORK_PRESS_KOEF" type="Decimal"/>	
		<var name="STO_112_2007_COMPRESS_STRENGTH" type="Decimal"/>	
		<var name="STO_112_2007_LENGTH_KOEF" type="Decimal"/>
		<var name="LTG_THICKNESS_MEASURED" type="Decimal"/>	
		<var name="LTG_CORROSION_SPEED" type="Decimal"/>		
		<var name="LTG_TIME_FROM_LAST_REPAIR" type="Decimal"/>	
		<var name="LTG_THICKNESS_TO_DESTROY" type="Decimal"/>
		<var name="LTG_RESIDUAL_LIFE" type="Decimal"/>	
		<var name="LTG_MIN_THICKNESS_ALLOW" type="Decimal"/>
		<var name="LTG_ACTUAL_RES_THICKNESS" type="Decimal"/>	
		<var name="LTG_PROBAB_CORROSION_SPEED" type="Decimal"/>
		<var name="LTG_DEPTH_TO_DESTROY" type="Decimal"/>	
		<var name="LTG_TIME_TO_DESTROY" type="Decimal"/>		
		<var name="LTG_REPAIR_METHOD" type="Decimal"/>	
		<var name="PIPE_PARAMS" type="String"/>
		<var name="BPR_VARIANCE" type="Decimal"/>	
		<var name="BPR_CALCULATED" type="Decimal"/>
		<var name="RPR_CALCULATED" type="Decimal"/>	
		<var name="RPR_VARIANCE" type="Decimal"/>			
		<var name="R_595_2011_REPAIR_METHOD" type="String"/>	
		<var name="R_595_2011_DEPTH_ABRASION" type="Decimal"/>
		<var name="R_595_2011_SQUARE_ABRASION" type="Decimal"/>	
		<var name="R_595_2011_LENGTH_PIPE_REPAIR" type="Decimal"/>		
		<var name="R_595_2011_COMMENT" type="String"/>	
		<var name="STO_112_2007_ASSURANCE_FACTOR" type="Decimal"/>
		<var name="STO_112_2007_DESTRUCT_PRESSURE" type="Decimal"/>	
		<var name="STO_112_2007_ALLOW_PRESSURE" type="Decimal"/>		
		<var name="STO_112_2007_PERFORMANCE_EVAL" type="String"/>	
		<var name="STO_173_2007_CRITICAL_PRESSURE" type="Decimal"/>		
		<var name="STO_173_2007_DANGER_DEGREE" type="String"/>	
		<var name="STO_173_2007_SAFE_PRESSURE" type="Decimal"/>
		<var name="STO_292_2007_DANGER_RANK" type="Decimal"/>	
		<var name="STO_401_2009_FAIL_PROBABILITY" type="Decimal"/>	
			<query>
			DO $$
			
			DECLARE
 			v_dummy VARCHAR(512); 
			
 			BEGIN
 
 			/* Поскольку и одиночные дефекты и кластеру идут в одном наборе, то их следует обрабатывать 
 			по-отдельности
 			Признак: IS_CLUSTER=[-1;1;0]
 			*/ 

 			/*вставлено в связи с расширением расчетов 14.01.2016*/
		 			IF {IS_CLUSTER} != 0
 			THEN 
 
			INSERT INTO PODS.STO_ILI_DATA_CALC_ADV(ili_data_id,ili_inspection_id, R_620_2011_DATE_TEST,R_620_2011_DATE_REPAIR,STO_112_2007_WORK_PRESS_KOEF,STO_112_2007_COMPRESS_STRENGTH,STO_112_2007_LENGTH_KOEF,LTG_THICKNESS_MEASURED,LTG_CORROSION_SPEED,LTG_TIME_FROM_LAST_REPAIR,LTG_THICKNESS_TO_DESTROY,LTG_RESIDUAL_LIFE,LTG_MIN_THICKNESS_ALLOW,LTG_ACTUAL_RES_THICKNESS,LTG_PROBAB_CORROSION_SPEED,LTG_DEPTH_TO_DESTROY,LTG_TIME_TO_DESTROY,LTG_REPAIR_METHOD,PIPE_PARAMS)
	 			VALUES (
	 			{ILI_DATA_ID},{ILI_INSPECTION_ID}, {R_620_2011_DATE_TEST}, {R_620_2011_DATE_REPAIR}, {STO_112_2007_WORK_PRESS_KOEF}, {STO_112_2007_COMPRESS_STRENGTH}, {STO_112_2007_LENGTH_KOEF}, {LTG_THICKNESS_MEASURED}, {LTG_CORROSION_SPEED}, {LTG_TIME_FROM_LAST_REPAIR}, {LTG_THICKNESS_TO_DESTROY}, {LTG_RESIDUAL_LIFE}, {LTG_MIN_THICKNESS_ALLOW}, {LTG_ACTUAL_RES_THICKNESS}, {LTG_PROBAB_CORROSION_SPEED}, {LTG_DEPTH_TO_DESTROY}, {LTG_TIME_TO_DESTROY},'{LTG_REPAIR_METHOD}','{PIPE_PARAMS}')
			
			ON CONFLICT (ILI_DATA_ID) DO UPDATE SET
	 			R_620_2011_DATE_TEST = {R_620_2011_DATE_TEST},
	 			R_620_2011_DATE_REPAIR = {R_620_2011_DATE_REPAIR},
							STO_112_2007_WORK_PRESS_KOEF = {STO_112_2007_WORK_PRESS_KOEF},
							STO_112_2007_COMPRESS_STRENGTH = {STO_112_2007_COMPRESS_STRENGTH},
							STO_112_2007_LENGTH_KOEF = {STO_112_2007_LENGTH_KOEF},
							LTG_THICKNESS_MEASURED = {LTG_THICKNESS_MEASURED},
							LTG_CORROSION_SPEED = {LTG_CORROSION_SPEED},
							LTG_TIME_FROM_LAST_REPAIR = {LTG_TIME_FROM_LAST_REPAIR},
							LTG_THICKNESS_TO_DESTROY = {LTG_THICKNESS_TO_DESTROY},
							LTG_RESIDUAL_LIFE = {LTG_RESIDUAL_LIFE},
							LTG_MIN_THICKNESS_ALLOW = {LTG_MIN_THICKNESS_ALLOW},
							LTG_ACTUAL_RES_THICKNESS = {LTG_ACTUAL_RES_THICKNESS},
							LTG_PROBAB_CORROSION_SPEED = {LTG_PROBAB_CORROSION_SPEED},
							LTG_DEPTH_TO_DESTROY = {LTG_DEPTH_TO_DESTROY},
				 			LTG_TIME_TO_DESTROY = {LTG_TIME_TO_DESTROY},
							LTG_REPAIR_METHOD = '{LTG_REPAIR_METHOD}', 
	 			PIPE_PARAMS = '{PIPE_PARAMS}';
 			ELSE 
  

 			INSERT INTO PODS.STO_ILI_CLUSTER_CALC_ADV (
 			ili_cluster_id,ili_inspection_id, R_620_2011_DATE_TEST,R_620_2011_DATE_REPAIR,STO_112_2007_WORK_PRESS_KOEF,STO_112_2007_COMPRESS_STRENGTH,STO_112_2007_LENGTH_KOEF,LTG_THICKNESS_MEASURED,LTG_CORROSION_SPEED,LTG_TIME_FROM_LAST_REPAIR,LTG_THICKNESS_TO_DESTROY,LTG_RESIDUAL_LIFE,LTG_MIN_THICKNESS_ALLOW,LTG_ACTUAL_RES_THICKNESS,LTG_PROBAB_CORROSION_SPEED,LTG_DEPTH_TO_DESTROY,LTG_TIME_TO_DESTROY,LTG_REPAIR_METHOD,PIPE_PARAMS)
 			VALUES (
 			{ILI_CLUSTER_ID},{ILI_INSPECTION_ID}, {R_620_2011_DATE_TEST}, {R_620_2011_DATE_REPAIR}, {STO_112_2007_WORK_PRESS_KOEF}, {STO_112_2007_COMPRESS_STRENGTH}, {STO_112_2007_LENGTH_KOEF}, {LTG_THICKNESS_MEASURED}, {LTG_CORROSION_SPEED}, {LTG_TIME_FROM_LAST_REPAIR}, {LTG_THICKNESS_TO_DESTROY}, {LTG_RESIDUAL_LIFE}, {LTG_MIN_THICKNESS_ALLOW}, {LTG_ACTUAL_RES_THICKNESS}, {LTG_PROBAB_CORROSION_SPEED}, {LTG_DEPTH_TO_DESTROY}, {LTG_TIME_TO_DESTROY},'{LTG_REPAIR_METHOD}','{PIPE_PARAMS}')
			ON CONFLICT (ILI_CLUSTER_ID) DO UPDATE SET 
 			R_620_2011_DATE_TEST = {R_620_2011_DATE_TEST},
 			R_620_2011_DATE_REPAIR = {R_620_2011_DATE_REPAIR},
						STO_112_2007_WORK_PRESS_KOEF = {STO_112_2007_WORK_PRESS_KOEF},
						STO_112_2007_COMPRESS_STRENGTH = {STO_112_2007_COMPRESS_STRENGTH},
						STO_112_2007_LENGTH_KOEF = {STO_112_2007_LENGTH_KOEF},
						LTG_THICKNESS_MEASURED = {LTG_THICKNESS_MEASURED},
						LTG_CORROSION_SPEED = {LTG_CORROSION_SPEED},
						LTG_TIME_FROM_LAST_REPAIR = {LTG_TIME_FROM_LAST_REPAIR},
						LTG_THICKNESS_TO_DESTROY = {LTG_THICKNESS_TO_DESTROY},
						LTG_RESIDUAL_LIFE = {LTG_RESIDUAL_LIFE},
						LTG_MIN_THICKNESS_ALLOW = {LTG_MIN_THICKNESS_ALLOW},
						LTG_ACTUAL_RES_THICKNESS = {LTG_ACTUAL_RES_THICKNESS},
						LTG_PROBAB_CORROSION_SPEED = {LTG_PROBAB_CORROSION_SPEED},
						LTG_DEPTH_TO_DESTROY = {LTG_DEPTH_TO_DESTROY},
			 			LTG_TIME_TO_DESTROY = {LTG_TIME_TO_DESTROY},
						LTG_REPAIR_METHOD = '{LTG_REPAIR_METHOD}',
 			PIPE_PARAMS = '{PIPE_PARAMS}'; 
 			END IF; 
 			/*Новый блок закончился*/
 			IF {IS_CLUSTER} != 0
 			THEN 
 			UPDATE pods.ili_data 
 			SET BPR_VARIANCE = {BPR_VARIANCE}
 			,RPR_CALCULATED = {RPR_CALCULATED}
 			,BPR_CALCULATED = {BPR_CALCULATED}
 			,RPR_VARIANCE = {RPR_VARIANCE}
 			WHERE ili_data_id = {ID};
 
			INSERT INTO PODS.STO_ILI_DATA_CALC (
			ILI_DATA_ID,ILI_INSPECTION_ID, R_595_2011_REPAIR_METHOD, 
 			R_595_2011_DEPTH_ABRASION, R_595_2011_SQUARE_ABRASION, R_595_2011_LENGTH_PIPE_REPAIR, R_595_2011_COMMENT, STO_112_2007_ASSURANCE_FACTOR, 
 			STO_112_2007_DESTRUCT_PRESSURE, STO_112_2007_ALLOW_PRESSURE, STO_112_2007_PERFORMANCE_EVAL, STO_173_2007_CRITICAL_PRESSURE, STO_173_2007_DANGER_DEGREE, 
 			STO_173_2007_SAFE_PRESSURE, STO_292_2007_DANGER_RANK, STO_401_2009_FAIL_PROBABILITY)
			VALUES (
 			{ILI_DATA_ID},{ILI_INSPECTION_ID}, '{R_595_2011_REPAIR_METHOD}', 
 			{R_595_2011_DEPTH_ABRASION}, {R_595_2011_SQUARE_ABRASION}, {R_595_2011_LENGTH_PIPE_REPAIR}, '{R_595_2011_COMMENT}', {STO_112_2007_ASSURANCE_FACTOR}, 
 			{STO_112_2007_DESTRUCT_PRESSURE}, {STO_112_2007_ALLOW_PRESSURE}, '{STO_112_2007_PERFORMANCE_EVAL}', {STO_173_2007_CRITICAL_PRESSURE}, '{STO_173_2007_DANGER_DEGREE}', 
 			{STO_173_2007_SAFE_PRESSURE}, {STO_292_2007_DANGER_RANK}, {STO_401_2009_FAIL_PROBABILITY})
 			ON CONFLICT (ILI_DATA_ID) DO UPDATE SET 
 			R_595_2011_REPAIR_METHOD = '{R_595_2011_REPAIR_METHOD}',
 			R_595_2011_DEPTH_ABRASION = {R_595_2011_DEPTH_ABRASION},
 			R_595_2011_SQUARE_ABRASION = {R_595_2011_SQUARE_ABRASION},
 			R_595_2011_LENGTH_PIPE_REPAIR = {R_595_2011_LENGTH_PIPE_REPAIR},
 			R_595_2011_COMMENT = '{R_595_2011_COMMENT}',
 			STO_112_2007_ASSURANCE_FACTOR = {STO_112_2007_ASSURANCE_FACTOR},
 			STO_112_2007_DESTRUCT_PRESSURE = {STO_112_2007_DESTRUCT_PRESSURE},
 			STO_112_2007_ALLOW_PRESSURE = {STO_112_2007_ALLOW_PRESSURE},
 			STO_112_2007_PERFORMANCE_EVAL = '{STO_112_2007_PERFORMANCE_EVAL}',
 			STO_173_2007_CRITICAL_PRESSURE = {STO_173_2007_CRITICAL_PRESSURE},
 			STO_173_2007_DANGER_DEGREE = '{STO_173_2007_DANGER_DEGREE}',
 			STO_173_2007_SAFE_PRESSURE = {STO_173_2007_SAFE_PRESSURE},
 			STO_292_2007_DANGER_RANK = {STO_292_2007_DANGER_RANK},
 			STO_401_2009_FAIL_PROBABILITY = {STO_401_2009_FAIL_PROBABILITY}; 
 			ELSE /* ТЕПЕРЬ КЛАСТЕРЫ*/
 			UPDATE PODS.ILI_CLUSTER 
 			SET AVG_BPR_VARIANCE = {BPR_VARIANCE}
 			,AVG_RPR_CALCULATED = {RPR_CALCULATED}
 			,AVG_BPR_CALCULATED = {BPR_CALCULATED} 
 			,AVG_RPR_VARIANCE = {RPR_VARIANCE} 
 			WHERE ILI_CLUSTER_ID = {ID};
 

 			INSERT INTO PODS.STO_ILI_CLUSTER_CALC (
 			ILI_CLUSTER_ID,ILI_INSPECTION_ID, R_595_2011_REPAIR_METHOD, 
 			R_595_2011_DEPTH_ABRASION, R_595_2011_SQUARE_ABRASION, R_595_2011_LENGTH_PIPE_REPAIR, R_595_2011_COMMENT, STO_112_2007_ASSURANCE_FACTOR, 
 			STO_112_2007_DESTRUCT_PRESSURE, STO_112_2007_ALLOW_PRESSURE, STO_112_2007_PERFORMANCE_EVAL, STO_173_2007_CRITICAL_PRESSURE, STO_173_2007_DANGER_DEGREE, 
 			STO_173_2007_SAFE_PRESSURE, STO_292_2007_DANGER_RANK, STO_401_2009_FAIL_PROBABILITY)
 			VALUES (
 			{ILI_CLUSTER_ID},{ILI_INSPECTION_ID}, '{R_595_2011_REPAIR_METHOD}', 
 			{R_595_2011_DEPTH_ABRASION}, {R_595_2011_SQUARE_ABRASION}, {R_595_2011_LENGTH_PIPE_REPAIR}, '{R_595_2011_COMMENT}', {STO_112_2007_ASSURANCE_FACTOR}, 
 			{STO_112_2007_DESTRUCT_PRESSURE}, {STO_112_2007_ALLOW_PRESSURE}, '{STO_112_2007_PERFORMANCE_EVAL}', {STO_173_2007_CRITICAL_PRESSURE}, '{STO_173_2007_DANGER_DEGREE}', 
 			{STO_173_2007_SAFE_PRESSURE}, {STO_292_2007_DANGER_RANK}, {STO_401_2009_FAIL_PROBABILITY})
 			
			ON CONFLICT (ILI_CLUSTER_ID) DO UPDATE SET 
 			R_595_2011_REPAIR_METHOD = '{R_595_2011_REPAIR_METHOD}',
 			R_595_2011_DEPTH_ABRASION = {R_595_2011_DEPTH_ABRASION},
 			R_595_2011_SQUARE_ABRASION = {R_595_2011_SQUARE_ABRASION},
 			R_595_2011_LENGTH_PIPE_REPAIR = {R_595_2011_LENGTH_PIPE_REPAIR},
 			R_595_2011_COMMENT = '{R_595_2011_COMMENT}',
 			STO_112_2007_ASSURANCE_FACTOR = {STO_112_2007_ASSURANCE_FACTOR},
 			STO_112_2007_DESTRUCT_PRESSURE = {STO_112_2007_DESTRUCT_PRESSURE},
 			STO_112_2007_ALLOW_PRESSURE = {STO_112_2007_ALLOW_PRESSURE},
 			STO_112_2007_PERFORMANCE_EVAL = '{STO_112_2007_PERFORMANCE_EVAL}',
 			STO_173_2007_CRITICAL_PRESSURE = {STO_173_2007_CRITICAL_PRESSURE},
 			STO_173_2007_DANGER_DEGREE = '{STO_173_2007_DANGER_DEGREE}',
 			STO_173_2007_SAFE_PRESSURE = {STO_173_2007_SAFE_PRESSURE},
 			STO_292_2007_DANGER_RANK = {STO_292_2007_DANGER_RANK},
 			STO_401_2009_FAIL_PROBABILITY = {STO_401_2009_FAIL_PROBABILITY}; 
 			END IF; 
 			END $$;

			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_ILI_CALC_PRESSURE_3" comment="CALC_ILI_CALC_PRESSURE_3" schema="UTE" table="CALC_ILI_CALC_PRESSURE">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
			<query>
	DO $$

	DECLARE
	c_radius CONSTANT NUMERIC DEFAULT 0.25;
	begin
	execute 'truncate table pods.sto_temp_pipe_params_to_calc';
	insert into pods.sto_temp_pipe_params_to_calc SELECT par.nominal_diameter_gcl,par.nominal_wall_thickness_gcl,par.dot_class_rating_cl,par.work_pressure,par.date_begin_exploitation,par.date_last_ili,statbpar.measure mes_start,statendpar.measure mes_end,
	(select min(a.break_point_min) 
	from pods.sto_131_pipe_params_cl a 
	where par.nominal_diameter_gcl=a.nominal_diameter_gcl 
	and par.work_pressure BETWEEN a.work_pressure_min and a.work_pressure_max 
	and par.nominal_wall_thickness_gcl between a.nominal_wall_thick_min and a.nominal_wall_thick_max
	and par.pipe_segment_material_cl=a.pipe_segment_material_gcl 
	and par.pipe_segment_manufacturer_cl=a.pipe_segment_manufacturer_cl),
	(select min(a.YYIELDING_LIMIT_MIN) 
	from pods.sto_131_pipe_params_cl a 
	where par.nominal_diameter_gcl=a.nominal_diameter_gcl 
	and par.work_pressure BETWEEN a.work_pressure_min and a.work_pressure_max 
	and par.nominal_wall_thickness_gcl between a.nominal_wall_thick_min and a.nominal_wall_thick_max
	and par.pipe_segment_material_cl=a.pipe_segment_material_gcl 
	and par.pipe_segment_manufacturer_cl=a.pipe_segment_manufacturer_cl),
	(select min(a.SAFETY_FACTOR) 
	from pods.sto_131_pipe_params_cl a 
	where par.nominal_diameter_gcl=a.nominal_diameter_gcl 
	and par.work_pressure BETWEEN a.work_pressure_min and a.work_pressure_max 
	and par.nominal_wall_thickness_gcl between a.nominal_wall_thick_min and a.nominal_wall_thick_max
	and par.pipe_segment_material_cl=a.pipe_segment_material_gcl 
	and par.pipe_segment_manufacturer_cl=a.pipe_segment_manufacturer_cl),
	(select min(a.IMPACT_TOUGHNESS) 
	from pods.sto_131_pipe_params_cl a 
	where par.nominal_diameter_gcl=a.nominal_diameter_gcl 
	and par.work_pressure BETWEEN a.work_pressure_min and a.work_pressure_max 
	and par.nominal_wall_thickness_gcl between a.nominal_wall_thick_min and a.nominal_wall_thick_max
	and par.pipe_segment_material_cl=a.pipe_segment_material_gcl 
	and par.pipe_segment_manufacturer_cl=a.pipe_segment_manufacturer_cl)
	FROM pods.sto_pipe_segment_params par,
	pods.station_point statbpar,
	pods.station_point statendpar

	WHERE par.station_begin = statbpar.station_id
	AND par.station_end = statendpar.station_id
	AND statbpar.route_id = (select sp.route_id from pods.ili_inspection_range r join 
	pods.event_range e ON e.event_id = r.event_id and r.ili_inspection_id={INSPECTION_ID}
	JOIN pods.station_point sp ON e.station_id_begin = sp.station_id);


	update pods.sto_temp_pipe_params_to_calc set date_last_ili =(SELECT MAX (i.begin_date) insp_prev
	FROM pods.station_point sp,
	pods.event_range ee,
	pods.ili_inspection_range ir,
	pods.ili_inspection i
	WHERE sp.route_id =
	(SELECT s.route_id
	FROM pods.event_Range e,
	pods.station_point s,
	pods.ili_inspection_range r
	WHERE r.ili_inspection_id = {INSPECTION_ID}
	AND e.event_id = r.event_id
	AND s.station_id = e.station_id_begin)
	AND sp.station_id = ee.station_id_begin
	AND ir.event_id = ee.event_id
	AND ir.ili_inspection_id = i.ili_inspection_id
	AND EXTRACT(YEAR FROM i.begin_date)::text &lt; (SELECT EXTRACT(YEAR FROM ii.begin_date)::text
	FROM pods.ili_inspection ii
	WHERE ii.ili_inspection_id = {INSPECTION_ID}));

	end $$;
			</query>
		</dbCommand>
	</update>
</data> 
 
<data id="CALC_ILI_GEOLIZE_CLUSTER_1" comment="CALC_ILI_GEOLIZE_CLUSTER_1" schema="UTE" table="CALC_ILI_GEOLIZE_CLUSTER">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
		<var name="config.main.PODS_USER"/>				
			<query>
	DO $$

	DECLARE
	i RECORD;
	e_id NUMERIC;
	BEGIN
	FOR i IN (SELECT d.ili_cluster_id
	,FIRST_VALUE(sp.station_id) OVER (PARTITION BY d.ili_cluster_id ORDER BY D.ABSOLUTE_ODOMETER ASC) spb_id
	,FIRST_VALUE(sp.station_id) OVER (PARTITION BY d.ili_cluster_id ORDER BY D.ABSOLUTE_ODOMETER DESC) spe_id
	,ABS(FIRST_VALUE(sp.measure) OVER (PARTITION BY d.ili_cluster_id ORDER BY D.ABSOLUTE_ODOMETER ASC)
	- FIRST_VALUE(sp.measure) OVER (PARTITION BY d.ili_cluster_id ORDER BY D.ABSOLUTE_ODOMETER DESC)) event_length
	FROM pods.ili_data d
	JOIN pods.event_range er
	ON d.event_id = er.event_id
	JOIN pods.station_point sp
	ON sp.station_id = er.station_id_begin
	JOIN pods.ili_cluster ic
	ON d.ili_cluster_id = ic.ili_cluster_id

	WHERE ic.ili_inspection_id = {INSPECTION_ID}
	AND ic.event_id &lt; 0)
	LOOP
	INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,VALIDITY_TOLERANCE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL,LENGTH) 
	VALUES ('ILI_CLUSTER', i.spb_id, i.spe_id, '{config.main.PODS_USER}', current_timestamp, 0, current_timestamp, 'Y', 'UNKNOWN',i.event_length) 
	RETURNING EVENT_ID INTO e_id;
	UPDATE pods.ili_cluster
	SET event_id = e_id
	WHERE ili_cluster_id = i.ili_cluster_id;

	END LOOP;
	END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_ILI_INSP_CALC_STO_1" comment="CALC_ILI_INSP_CALC_STO_1" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
			<query>
			DO $$
			
			DECLARE
 			c_radius NUMERIC DEFAULT 0.25;
			begin
			execute 'truncate table pods.sto_temp_pipe_params_to_calc';
 			insert into pods.sto_temp_pipe_params_to_calc SELECT par.nominal_diameter_gcl,par.nominal_wall_thickness_gcl,par.dot_class_rating_cl,par.work_pressure,par.date_begin_exploitation,par.date_last_ili,statbpar.measure mes_start,statendpar.measure mes_end,
 			(select min(a.break_point_min) 
 			from pods.sto_131_pipe_params_cl a 
 			where par.nominal_diameter_gcl=a.nominal_diameter_gcl 
 			and par.work_pressure BETWEEN a.work_pressure_min and a.work_pressure_max 
 			and par.nominal_wall_thickness_gcl between a.nominal_wall_thick_min and a.nominal_wall_thick_max
 			and par.pipe_segment_material_cl=a.pipe_segment_material_gcl 
 			and par.pipe_segment_manufacturer_cl=a.pipe_segment_manufacturer_cl),
 			(select min(a.YYIELDING_LIMIT_MIN) 
 			from pods.sto_131_pipe_params_cl a 
 			where par.nominal_diameter_gcl=a.nominal_diameter_gcl 
 			and par.work_pressure BETWEEN a.work_pressure_min and a.work_pressure_max 
 			and par.nominal_wall_thickness_gcl between a.nominal_wall_thick_min and a.nominal_wall_thick_max
 			and par.pipe_segment_material_cl=a.pipe_segment_material_gcl 
 			and par.pipe_segment_manufacturer_cl=a.pipe_segment_manufacturer_cl),
 			(select min(a.SAFETY_FACTOR) 
 			from pods.sto_131_pipe_params_cl a 
 			where par.nominal_diameter_gcl=a.nominal_diameter_gcl 
 			and par.work_pressure BETWEEN a.work_pressure_min and a.work_pressure_max 
 			and par.nominal_wall_thickness_gcl between a.nominal_wall_thick_min and a.nominal_wall_thick_max
 			and par.pipe_segment_material_cl=a.pipe_segment_material_gcl 
 			and par.pipe_segment_manufacturer_cl=a.pipe_segment_manufacturer_cl),
 			(select min(a.IMPACT_TOUGHNESS) 
 			from pods.sto_131_pipe_params_cl a 
 			where par.nominal_diameter_gcl=a.nominal_diameter_gcl 
 			and par.work_pressure BETWEEN a.work_pressure_min and a.work_pressure_max 
 			and par.nominal_wall_thickness_gcl between a.nominal_wall_thick_min and a.nominal_wall_thick_max
 			and par.pipe_segment_material_cl=a.pipe_segment_material_gcl 
 			and par.pipe_segment_manufacturer_cl=a.pipe_segment_manufacturer_cl)
 			FROM pods.sto_pipe_segment_params par,
 			pods.station_point statbpar,
 			pods.station_point statendpar

			WHERE par.station_begin = statbpar.station_id
 			AND par.station_end = statendpar.station_id
 			AND statbpar.route_id = (select sp.route_id from pods.ili_inspection_range r join 
 			pods.event_range e ON e.event_id = r.event_id and r.ili_inspection_id={INSPECTION_ID}
 			JOIN pods.station_point sp ON e.station_id_begin = sp.station_id);
 
 			update pods.sto_temp_pipe_params_to_calc set date_last_ili =(SELECT MAX (i.begin_date) insp_prev
 			FROM pods.station_point sp,
 			pods.event_range ee,
 			pods.ili_inspection_range ir,
 			pods.ili_inspection i
 			WHERE sp.route_id =
 			(SELECT s.route_id
 			FROM pods.event_Range e,
 			pods.station_point s,
 			pods.ili_inspection_range r
 			WHERE r.ili_inspection_id = {INSPECTION_ID}
 			AND e.event_id = r.event_id
 			AND s.station_id = e.station_id_begin)
 			AND sp.station_id = ee.station_id_begin
 			AND ir.event_id = ee.event_id
 			AND ir.ili_inspection_id = i.ili_inspection_id
 			AND EXTRACT(YEAR FROM i.begin_date)::text &lt; (SELECT EXTRACT(YEAR FROM ii.begin_date)::text
 			FROM pods.ili_inspection ii
 			WHERE ii.ili_inspection_id = {INSPECTION_ID}));
			end $$;
			</query>
		</dbCommand>
	</update>
</data> 
 
<data id="CALC_ILI_INSP_CALC_STO_2" comment="CALC_ILI_INSP_CALC_STO_2" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			WITH report 
 			AS (SELECT i.*,r.event_id range_event_id, r.event_id event_id, s.route_id,
 			s.station_begin station_beg, s.station_end station_end,
 			c.description company_name,l.line_id,
 			CASE
 			WHEN l.line_id = 0
 			THEN 'Отчет не рассчитан. '
 			ELSE rtc.description
 			END route_type,
 			CASE
 			WHEN l.line_id = 0
 			THEN r.description
 			ELSE l.description
 			END line_name,
 			(SELECT count(*)
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) WELDS_COUNT,
 			(SELECT ABS(MAX(F.ABSOLUTE_ODOMETER)-MIN(F.ABSOLUTE_ODOMETER))/1000 
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) INSP_LENGTH 
 			FROM pods.ili_inspection i 
 			JOIN pods.ili_inspection_range r
 			ON r.ili_inspection_id = i.ili_inspection_id 
 			AND i.ili_inspection_id = {INSPECTION_ID}
 			JOIN pods.event_range e 
 			ON e.event_id = r.event_id
 			JOIN pods.station_point sp
 			ON sp.station_id = e.station_id_begin
 			JOIN pods.series s 
 			ON s.series_id = sp.series_id
 			JOIN pods.route rt 
 			ON sp.route_id = rt.route_id
 			JOIN pods.line l 
 			ON sp.line_id = l.line_id
 			JOIN pods.route_type_cl rtc 
 			ON rt.type_cl = rtc.code
 			JOIN pods.ili_tool_vendor_cl c
 			ON c.code = i.tool_vendor_cl
 			), 
			diameter 
 			AS (SELECT coalesce(min(p.nominal_diameter_gcl),'1420') nominal_diameter_gcl,coalesce(min(p.date_begin_exploitation),to_date('01011955','DDMMYYYY')) INSTALL_DATE
 			from pods.sto_pipe_segment_params p
			join report r on
 			 p.route_id=r.line_id and r.station_beg&lt;=p.station_begin and r.station_end&gt;=p.station_end)
 			SELECT ar.CALC_ID "CALC_ID"
 			,ar.EVENT_ID "EVENT_ID"
 			,report.RANGE_EVENT_ID "RANGE_EVENT_ID"
 			,report.BEGIN_DATE "BEGIN_DATE"
 			,ar.TYPE_CL "TYPE_CL"
 			,ar.ILI_INSPECTION_ID "ILI_INSPECTION_ID"
 			,ar.BEGIN_EVENT_ID "BEGIN_EVENT_ID"
 			,ar.END_EVENT_ID "END_EVENT_ID"
 			,er.STATION_ID_BEGIN "STATION_ID_BEGIN"
 			,er.STATION_ID_END "STATION_ID_END"
 			,ar.BEGIN_ODOMETER "BEGIN_ODOMETER"
 			,ar.END_ODOMETER "END_ODOMETER"
 			,ar.STO_292_2007_DAMAGE_MECHANICAL "STO_292_2007_DAMAGE_MECHANICAL"
 			,ar.STO_292_2007_VALUE_WELD "STO_292_2007_VALUE_WELD"
 			,ar.STO_292_2007_DAMAGE_CRACK "STO_292_2007_DAMAGE_CRACK"
 			,ar.STO_292_2007_DAMAGE_CORROSION "STO_292_2007_DAMAGE_CORROSION"
 			,ar.STO_292_2007_DAMAGE_DENT "STO_292_2007_DAMAGE_DENT"
 			,ar.STO_292_2007_VALUE_PIPE "STO_292_2007_VALUE_PIPE"
 			,ar.STO_292_2007_DAMAGE_DUTY_VAR "STO_292_2007_DAMAGE_DUTY_VAR"
 			,ar.STO_292_2007_BAD_PIPE_COUNT "STO_292_2007_BAD_PIPE_COUNT"
 			,ar.STO_292_2007_VALUE_CONDITION "STO_292_2007_VALUE_CONDITION"
 			,ar.STO_401_2003_OP_REP_PIPE_COUNT "STO_401_2003_OP_REP_PIPE_COUNT"
 			,ar.STO_401_2003_TIME_LIMIT_EXPL "STO_401_2003_TIME_LIMIT_EXPL"
 			,ar.STO_401_2003_MEAN_TIME_FAIL "STO_401_2003_MEAN_TIME_FAIL"
 			,ar.STO_401_2003_POSSIBLE_FALUTS "STO_401_2003_POSSIBLE_FALUTS"
 			,ar.STO_401_2003_PIPE_Q_RANK_G_04 "STO_401_2003_PIPE_Q_RANK_G_04"
 			,ar.STO_401_2003_FAILURE_PROBABLY "STO_401_2003_FAILURE_PROBABLY"
 			,ar.STO_401_2003_MIN_UNIT_COST_YKM "STO_401_2003_MIN_UNIT_COST_YKM"
 			,ar.STO_401_2003_OPTIM_TIM_BFR_ILI "STO_401_2003_OPTIM_TIM_BFR_ILI"
 			,ar.PRIORITY_COND "PRIORITY_COND"
 			,ar.PRIORITY_TIME_EXP "PRIORITY_TIME_EXP"
 			,ar.PRIORITY_PROBAB "PRIORITY_PROBAB"
 			,ar.PRIORITY_TIME_FAI "PRIORITY_TIME_FAI"
 			,ar.PRIORITY_SUMMARY "PRIORITY_SUMMARY"
 			,ar.STO_095_2007_NEXT_INSP_SCC "STO_095_2007_NEXT_INSP_SCC"
 			,ar.STO_095_2007_NEXT_INSP "STO_095_2007_NEXT_INSP"
 			,ar.STO_095_2007_NEXT_COMP_INSP "STO_095_2007_NEXT_COMP_INSP"
 			,ar.STO_095_2007_DISTR_DEPTH_SCC "STO_095_2007_DISTR_DEPTH_SCC"
 			,ar.STO_095_2007_DISTR_DEPTH_COR "STO_095_2007_DISTR_DEPTH_COR"
 			,ar.STO_095_2007_PROJECTED_SCC "STO_095_2007_PROJECTED_SCC"
 			,ar.STO_095_2007_PROJECTED_COR "STO_095_2007_PROJECTED_COR"
 			,ar.STO_095_2007_NEXT_ILI_INSP "STO_095_2007_NEXT_ILI_INSP"
 			,diameter.nominal_diameter_gcl "NOMINAL_DIAMETER_GCL"
 			,er.length "SECTOR_LENGTH"
 			,spb.measure "MEASURE_BEGIN"
 			,spe.measure "MEASURE_END"
 			,diameter.INSTALL_DATE "INSTALL_DATE"
 			FROM pods.sto_ili_inspection_calc ar
 			JOIN pods.event_range er
 			ON er.event_id = ar.event_id
 			JOIN pods.station_point spb
 			ON spb.station_id = er.station_id_begin
 			JOIN pods.station_point spe
 			ON spe.station_id = er.station_id_end
 			JOIN report
 			ON ar.ili_inspection_id = report.ili_inspection_id
 			CROSS JOIN diameter
 			WHERE ar.ili_inspection_id = {INSPECTION_ID}
			</query>
		</dbQuery>
	</select>
</data> 
 
<data id="CALC_ILI_INSP_CALC_STO_3" comment="CALC_ILI_INSP_CALC_STO_3" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<insert>
		<dbCommand>
		<var name="CALC_ID" type="Decimal"/>
		<var name="STO_292_2007_DAMAGE_MECHANICAL" type="Decimal"/>
		<var name="STO_292_2007_VALUE_WELD" type="Decimal"/>
		<var name="STO_292_2007_DAMAGE_CRACK" type="Decimal"/>
		<var name="STO_292_2007_DAMAGE_CORROSION" type="Decimal"/>
		<var name="STO_292_2007_DAMAGE_DENT" type="Decimal"/>
		<var name="STO_292_2007_VALUE_PIPE" type="Decimal"/>
		<var name="STO_292_2007_DAMAGE_DUTY_VAR" type="Decimal"/>	
		<var name="STO_292_2007_BAD_PIPE_COUNT" type="Decimal"/>
		<var name="STO_292_2007_VALUE_CONDITION" type="Decimal"/>
		<var name="STO_401_2003_OP_REP_PIPE_COUNT" type="Decimal"/>
		<var name="STO_401_2003_TIME_LIMIT_EXPL" type="Decimal"/>
		<var name="STO_401_2003_MEAN_TIME_FAIL" type="Decimal"/>
		<var name="STO_401_2003_POSSIBLE_FALUTS" type="Decimal"/>
		<var name="STO_401_2003_PIPE_Q_RANK_G_04" type="Decimal"/>
		<var name="STO_401_2003_FAILURE_PROBABLY" type="Decimal"/>	
		<var name="STO_401_2003_MIN_UNIT_COST_YKM" type="Decimal"/>
		<var name="STO_401_2003_OPTIM_TIM_BFR_ILI" type="Decimal"/>
		<var name="PRIORITY_COND" type="Decimal"/>
		<var name="PRIORITY_TIME_EXP" type="Decimal"/>
		<var name="PRIORITY_PROBAB" type="Decimal"/>
		<var name="PRIORITY_TIME_FAI" type="Decimal"/>
		<var name="PRIORITY_SUMMARY" type="Decimal"/>
		<var name="STO_095_2007_NEXT_INSP_SCC" type="Decimal"/>	
		<var name="STO_095_2007_NEXT_INSP" type="Decimal"/>
		<var name="STO_095_2007_NEXT_COMP_INSP" type="Decimal"/>
		<var name="STO_095_2007_DISTR_DEPTH_SCC" type="Decimal"/>
		<var name="STO_095_2007_DISTR_DEPTH_COR" type="Decimal"/>
		<var name="STO_095_2007_PROJECTED_SCC" type="Decimal"/>
		<var name="STO_095_2007_PROJECTED_COR" type="Decimal"/>
		<var name="STO_095_2007_NEXT_ILI_INSP" type="Decimal"/>
		<var name="EVENT_ID" type="Decimal"/>
		<var name="TYPE_CL" type="String"/>
		<var name="ILI_INSPECTION_ID" type="Decimal"/>
		<var name="BEGIN_EVENT_ID" type="Decimal"/>
		<var name="END_EVENT_ID" type="Decimal"/>
		<var name="BEGIN_ODOMETER" type="Decimal"/>
		<var name="END_ODOMETER" type="Decimal"/>						
			<query>
			DO $$
			
			DECLARE
 			v_dummy VARCHAR(512); 
 			v_event_id NUMERIC;
 			v_calc_id NUMERIC;
 			BEGIN
 
 			IF {CALC_ID} IS NOT NULL
 			THEN 
 			/* Если calc_id уже заполнен, значит мы просто сохраняем результаты расчета, без создания новых объектов*/ 
 			UPDATE pods.sto_ili_inspection_calc 
 			SET STO_292_2007_DAMAGE_MECHANICAL={STO_292_2007_DAMAGE_MECHANICAL}
 			,STO_292_2007_VALUE_WELD={STO_292_2007_VALUE_WELD}
 			,STO_292_2007_DAMAGE_CRACK={STO_292_2007_DAMAGE_CRACK}
 			,STO_292_2007_DAMAGE_CORROSION={STO_292_2007_DAMAGE_CORROSION}
 			,STO_292_2007_DAMAGE_DENT={STO_292_2007_DAMAGE_DENT}
 			,STO_292_2007_VALUE_PIPE={STO_292_2007_VALUE_PIPE}
 			,STO_292_2007_DAMAGE_DUTY_VAR={STO_292_2007_DAMAGE_DUTY_VAR}
 			,STO_292_2007_BAD_PIPE_COUNT={STO_292_2007_BAD_PIPE_COUNT}
 			,STO_292_2007_VALUE_CONDITION={STO_292_2007_VALUE_CONDITION}
 			,STO_401_2003_OP_REP_PIPE_COUNT={STO_401_2003_OP_REP_PIPE_COUNT}
 			,STO_401_2003_TIME_LIMIT_EXPL={STO_401_2003_TIME_LIMIT_EXPL}
 			,STO_401_2003_MEAN_TIME_FAIL={STO_401_2003_MEAN_TIME_FAIL}
 			,STO_401_2003_POSSIBLE_FALUTS={STO_401_2003_POSSIBLE_FALUTS}
 			,STO_401_2003_PIPE_Q_RANK_G_04={STO_401_2003_PIPE_Q_RANK_G_04}
 			,STO_401_2003_FAILURE_PROBABLY ={STO_401_2003_FAILURE_PROBABLY}
 			,STO_401_2003_MIN_UNIT_COST_YKM ={STO_401_2003_MIN_UNIT_COST_YKM}
 			,STO_401_2003_OPTIM_TIM_BFR_ILI ={STO_401_2003_OPTIM_TIM_BFR_ILI}
 			,PRIORITY_COND={PRIORITY_COND}
 			,PRIORITY_TIME_EXP={PRIORITY_TIME_EXP}
 			,PRIORITY_PROBAB={PRIORITY_PROBAB}
 			,PRIORITY_TIME_FAI={PRIORITY_TIME_FAI}
 			,PRIORITY_SUMMARY={PRIORITY_SUMMARY}
 			,STO_095_2007_NEXT_INSP_SCC={STO_095_2007_NEXT_INSP_SCC}
 			,STO_095_2007_NEXT_INSP={STO_095_2007_NEXT_INSP}
 			,STO_095_2007_NEXT_COMP_INSP={STO_095_2007_NEXT_COMP_INSP}
 			,STO_095_2007_DISTR_DEPTH_SCC ={STO_095_2007_DISTR_DEPTH_SCC}
 			,STO_095_2007_DISTR_DEPTH_COR ={STO_095_2007_DISTR_DEPTH_COR}
 			,STO_095_2007_PROJECTED_SCC ={STO_095_2007_PROJECTED_SCC}
 			,STO_095_2007_PROJECTED_COR ={STO_095_2007_PROJECTED_COR}
 			,STO_095_2007_NEXT_ILI_INSP ={STO_095_2007_NEXT_ILI_INSP}
 			WHERE calc_id = {CALC_ID};
 			ELSE 
 			/* Добавляю запись в расчетную таблицу */ 
 			INSERT INTO pods.sto_ili_inspection_calc
 			(EVENT_ID,TYPE_CL,ILI_INSPECTION_ID,BEGIN_EVENT_ID,END_EVENT_ID,STO_292_2007_DAMAGE_MECHANICAL,STO_292_2007_VALUE_WELD
 			,STO_292_2007_DAMAGE_CRACK,STO_292_2007_DAMAGE_CORROSION,STO_292_2007_DAMAGE_DENT,STO_292_2007_VALUE_PIPE,STO_292_2007_DAMAGE_DUTY_VAR
 			,STO_292_2007_BAD_PIPE_COUNT,STO_292_2007_VALUE_CONDITION,STO_401_2003_OP_REP_PIPE_COUNT,STO_401_2003_TIME_LIMIT_EXPL
 			,STO_401_2003_MEAN_TIME_FAIL,PRIORITY_COND,PRIORITY_TIME_EXP,PRIORITY_PROBAB,PRIORITY_TIME_FAI,PRIORITY_SUMMARY
 			,STO_095_2007_NEXT_INSP_SCC,STO_095_2007_NEXT_INSP,BEGIN_ODOMETER,END_ODOMETER
 			,STO_095_2007_DISTR_DEPTH_SCC,STO_095_2007_DISTR_DEPTH_COR,STO_095_2007_PROJECTED_SCC,STO_095_2007_PROJECTED_COR,STO_095_2007_NEXT_ILI_INSP
 			,STO_401_2003_POSSIBLE_FALUTS,STO_401_2003_PIPE_Q_RANK_G_04
 			,STO_401_2003_FAILURE_PROBABLY,STO_401_2003_MIN_UNIT_COST_YKM,STO_401_2003_OPTIM_TIM_BFR_ILI)
 			VALUES 
 			({EVENT_ID},'{TYPE_CL}',{ILI_INSPECTION_ID},{BEGIN_EVENT_ID},{END_EVENT_ID},{STO_292_2007_DAMAGE_MECHANICAL},{STO_292_2007_VALUE_WELD}
 			,{STO_292_2007_DAMAGE_CRACK},{STO_292_2007_DAMAGE_CORROSION},{STO_292_2007_DAMAGE_DENT},{STO_292_2007_VALUE_PIPE},{STO_292_2007_DAMAGE_DUTY_VAR}
 			,{STO_292_2007_BAD_PIPE_COUNT},{STO_292_2007_VALUE_CONDITION},{STO_401_2003_OP_REP_PIPE_COUNT},{STO_401_2003_TIME_LIMIT_EXPL}
 			,{STO_401_2003_MEAN_TIME_FAIL},{PRIORITY_COND},{PRIORITY_TIME_EXP},{PRIORITY_PROBAB},{PRIORITY_TIME_FAI},{PRIORITY_SUMMARY}
 			,{STO_095_2007_NEXT_INSP_SCC},{STO_095_2007_NEXT_INSP},{BEGIN_ODOMETER},{END_ODOMETER}
 			,{STO_095_2007_DISTR_DEPTH_SCC},{STO_095_2007_DISTR_DEPTH_COR},{STO_095_2007_PROJECTED_SCC},{STO_095_2007_PROJECTED_COR},{STO_095_2007_NEXT_ILI_INSP}
 			,{STO_401_2003_POSSIBLE_FALUTS},{STO_401_2003_PIPE_Q_RANK_G_04}
 			,{STO_401_2003_FAILURE_PROBABLY},{STO_401_2003_MIN_UNIT_COST_YKM},{STO_401_2003_OPTIM_TIM_BFR_ILI})
 			RETURNING CALC_ID INTO v_calc_id;

 
 			END IF;
 			END $$; 
			</query>
		</dbCommand>
	</insert>
</data>

<data id="CALC_ILI_INSP_CALC_STO_4" comment="CALC_ILI_INSP_CALC_STO_4" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			SELECT spb.measure "MEASURE",d.weld_number "WELD_NUMBER"
 			FROM pods.ili_data d
 			JOIN pods.event_range er
 			ON er.event_id = d.event_id
 			JOIN pods.station_point spb
 			ON spb.station_id = er.station_id_begin
 			WHERE er.current_indicator_lf = 'Y'
 			AND anomaly_type_cl = 5001
 			AND d.ili_inspection_id = {INSPECTION_ID}
 			ORDER BY spb.measure
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_ILI_INSP_CALC_STO_5" comment="CALC_ILI_INSP_CALC_STO_5" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>
			<query>
			WITH report 
 			AS (SELECT i.*, r.event_id event_id, s.route_id,
 			s.station_begin station_beg, s.station_end station_end,
 			c.description company_name,
 			CASE
 			WHEN l.line_id = 0
 			THEN 'Отчет не рассчитан. '
 			ELSE rtc.description
 			END route_type,
 			CASE
 			WHEN l.line_id = 0
 			THEN r.description
 			ELSE l.description
 			END line_name,
 			(SELECT count(*)
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) WELDS_COUNT,
 			(SELECT ABS(MAX(F.ABSOLUTE_ODOMETER)-MIN(F.ABSOLUTE_ODOMETER))/1000 
 			FROM pods.ili_data f
 			WHERE f.ili_inspection_id = {INSPECTION_ID}
 			AND f.anomaly_type_cl = 5001) INSP_LENGTH 
 			FROM pods.ili_inspection i JOIN pods.ili_inspection_range r
 			ON r.ili_inspection_id = i.ili_inspection_id and i.ili_inspection_id={INSPECTION_ID}
 			JOIN pods.event_range e ON e.event_id = r.event_id
 			JOIN pods.station_point sp
 			ON sp.station_id = e.station_id_begin
 			JOIN pods.series s ON s.series_id = sp.series_id
 			JOIN pods.route rt ON sp.route_id = rt.route_id
 			JOIN pods.line l ON sp.line_id = l.line_id
 			JOIN pods.route_type_cl rtc ON rt.type_cl = rtc.code
 			JOIN pods.ili_tool_vendor_cl c
 			ON c.code = i.tool_vendor_cl
 			), 
			diameter 
 			AS (SELECT coalesce(MIN(ps.nominal_diameter_gcl),'1420') nominal_diameter_gcl
 			FROM pods.station_point spe 
 			JOIN pods.event_range eps
 			ON spe.station_id = eps.station_id_begin AND eps.FEATURE_ID = 'PIPE_SEGMENT'
 			JOIN pods.pipe_segment ps 
 			ON eps.event_id = ps.event_id 
 			JOIN report
 			ON report.route_id = spe.route_id),
			defect_pipe_length 
 			AS (SELECT dd.ili_data_id,coalesce(MIN(ABS(pl.end_odometer-pl.start_odometer)),'10') defect_pipe_length
 			FROM pods.ili_data dd
 			JOIN pods.ili_pipe_length pl
 			ON pl.ili_inspection_id = dd.ili_inspection_id
 			AND pl."weld_number" = dd."weld_number"
 			WHERE dd.ili_inspection_id = {INSPECTION_ID} 
 			GROUP BY dd.ili_data_id), 
			left_marker 
 			AS (SELECT ili_data_id,marker_distance_left,coalesce(marker_name_left,'НЕИЗВЕСТНО') marker_name_left
 			FROM (SELECT dd.ili_data_id
 			,ROW_NUMBER() OVER (PARTITION BY dd.ili_data_id ORDER BY ft.absolute_odometer DESC) rwn
 			,ft.absolute_odometer marker_distance_left
 			,ft.feature_description marker_name_left
 			FROM pods.ili_data dd 
 			JOIN pods.ili_data ft
 			ON ft.ili_inspection_id =dd.ili_inspection_id
 			AND ft.absolute_odometer &lt;dd.absolute_odometer
 			WHERE ft.anomaly_type_cl IN ( SELECT code
 			FROM pods.ili_anomaly_type_cl
 			WHERE category_cl = 2)
 			AND dd.ili_inspection_id = {INSPECTION_ID}) x01
			WHERE rwn = 1), 
			right_marker
 			AS (SELECT ili_data_id,marker_distance_right,coalesce(marker_name_right,'НЕИЗВЕСТНО') marker_name_right
 			FROM (SELECT dd.ili_data_id ,ROW_NUMBER() OVER (PARTITION BY dd.ili_data_id ORDER BY ft.absolute_odometer ASC) rwn
 			,ft.absolute_odometer marker_distance_right
 			,ft.feature_description marker_name_right
 			FROM pods.ili_data dd 
 			JOIN pods.ili_data ft
 			ON ft.ili_inspection_id =dd.ili_inspection_id
 			AND ft.absolute_odometer &gt;dd.absolute_odometer
 			WHERE ft.anomaly_type_cl IN ( SELECT code FROM pods.ili_anomaly_type_cl
 			WHERE category_cl = 2)
 			AND dd.ili_inspection_id = {INSPECTION_ID}) x02
			WHERE rwn = 1)
 			SELECT 

                        sorter "SORTER",
			ID "ID",
 			orientation_deg "ORIENTATION_DEG",
 			nominal_wall_thickness "NOMINAL_WALL_THICKNESS",
 			weld_number "WELD_NUMBER",
 			station "STATION",
 			calibrated_measure "CALIBRATED_MEASURE",
 			ili_data_id "ILI_DATA_ID",
 			LENGTH "LENGTH",
 			average_depth "AVERAGE_DEPTH",
 			width "WIDTH",
 			absolute_odometer "ABSOLUTE_ODOMETER",
 			anomaly_type_cl "ANOMALY_TYPE_CL",
 			anomaly_extension_cl "ANOMALY_EXTENSION_CL",
 			feature_description "FEATURE_DESCRIPTION",
 			type_description "TYPE_DESCRIPTION",
 			description "DESCRIPTION",
 			line_name "LINE_NAME",
 			begin_date "BEGIN_DATE",
 			company_name "COMPANY_NAME",
 			x_coord "X_COORD",
 			y_coord "Y_COORD",
 			z_coord "Z_COORD",
 			depth_of_cover "DEPTH_OF_COVER",
 			nominal_diameter_gcl "NOMINAL_DIAMETER_GCL",
 			marker_distance_left"MARKER_DISTANCE_LEFT",
 			marker_name_left "MARKER_NAME_LEFT",
 			marker_distance_right "MARKER_DISTANCE_RIGHT",
 			marker_name_right "MARKER_NAME_RIGHT",
 			defect_pipe_length "DEFECT_PIPE_LENGTH",
 			anomaly_group "ANOMAY_GROUP",
 			US_WELD_DISTANCE "US_WELD_DISTANCE",
 			DS_WELD_DISTANCE "DS_WELD_DISTANCE",
 			IS_CLUSTER "IS_CLUSTER",
 			ILI_CLUSTER_ID "ILI_CLUSTER_ID", 
 			ILI_INSPECTION_ID "ILI_INSPECTION_ID",
 			WELDS_COUNT "WELDS_COUNT",
 			INSP_LENGTH "INSP_LENGTH"
 			,cluster_comment "CLUSTER_COMMENT"
 			,r_595_2011_comment "R_595_2011_COMMENT"
 			,r_595_2011_depth_abrasion "R_595_2011_DEPTH_ABRASION"
 			,r_595_2011_length_pipe_repair "R_595_2011_LENGTH_PIPE_REPAIR"
 			,r_595_2011_repair_method "R_595_2011_REPAIR_METHOD"
 			,r_595_2011_square_abrasion "R_595_2011_SQUARE_ABRASION"
 			,sto_112_2007_allow_pressure "STO_112_2011_ALLOW_PRESSURE"
 			,sto_112_2007_assurance_factor "STO_112_2011_ASSURANCE_FACTOR"
 			,sto_112_2007_destruct_pressure "STO_112_2011_DESTRUCT_PRESSURE"
 			,sto_112_2007_performance_eval "STO_112_2011_PERFORMANCE_EVAL"
 			,sto_173_2007_critical_pressure "STO_173_2007_CRITICAL_PRESSURE"
 			,sto_173_2007_danger_degree "STO_173_2007_DANGER_DEGREE"
 			,sto_173_2007_safe_pressure "STO_173_2007_SAFE_PRESSURE"
 			,sto_292_2007_danger_rank "STO_292_2007_DANGER_RANK"
 			,round(sto_401_2009_fail_probability,3) "STO_401_2009_FAIL_PROBABILITY"
 			,MEASURE "MEASURE"
 			,PAR_NOMINAL_DIAMETER_GCL "PAR_NOMINAL_DIAMETER_GCL"
 			,PAR_NOMINAL_WALL_THICKNESS_GCL "PAR_NOMINAL_WALL_THICKNESS_GCL"
 			,PAR_WORK_PRESSURE "PAR_WORK_PRESSURE"
 			,PAR_DOT_CLASS_RATING_GCL "PAR_DOT_CLASS_RATING_GCL"
 			,PAR_DATE_BEGIN_EXP "PAR_DATE_BEGIN_EXP"
 			,PAR_DATE_LAST_ILI "PAR_DATE_LAST_ILI"
			,PAR_YYIELDING_LIMIT_MIN "PAR_YYIELDING_LIMIT_MIN"
			,PAR_SAFETY_FACTOR "PAR_SAFETY_FACTOR"
			,PAR_IMPACT_TOUGHNESS "PAR_IMPACT_TOUGHNESS"
			,PAR_BREAK_POINT_MIN "cPAR_BREAK_POINT_MIN"
 			FROM (SELECT sorter,CASE IS_CLUSTER
 			WHEN 0 THEN def.ili_cluster_id 
 			ELSE def.ili_data_id 
 			END ID,
 			coalesce(def.orientation_deg/360*12,0) orientation_deg /*ориентация дефекта в градусах */,
 			coalesce(def.nominal_wall_thickness, '16' ) nominal_wall_thickness /*толщина стенки */,
 			coalesce(def.weld_number, 'НЕИЗВЕСТНО') weld_number /*номер трубы */,
 			coalesce(def.station, -999) station /*километр */,
 			coalesce(def.calibrated_measure,-999) calibrated_measure /*линейная дистация геодезическая */,
 			def.ili_data_id ili_data_id /*идентификатор дефекта*/,
 			coalesce(def.LENGTH, 0) LENGTH /*длина дефекта*/,
 			coalesce(def.average_depth, '5' ) average_depth /*средняя глубина поражения*/,
 			coalesce(def.width, 0) width /*ширина*/,
 			coalesce(def.absolute_odometer,-999) absolute_odometer /*линейная дистация геодезическая*/,
 			coalesce(def.anomaly_type_cl,0) anomaly_type_cl /*прикрутить справочник */,
 			coalesce(def.anomaly_extension_cl,'UNKNOWN') anomaly_extension_cl,
 			coalesce(def.feature_description,'НЕИЗВЕСТНО') feature_description /* описание дефекта */,
 			coalesce(def_description, 'НЕИЗВЕСТНО') type_description /*тип дефекта */,
 			coalesce(def.description, ' ') description /* описание */,
 			CASE WHEN report.line_name IS NOT NULL
 			THEN coalesce(report.route_type, '')|| ' '|| coalesce(report.line_name, '')|| ' '|| coalesce(report.station_beg::text, '')|| ' - '|| coalesce(report.station_end::text, '')|| ' км '
 			ELSE 'НЕИЗВЕСТНО' 
 			END line_name,
 			coalesce((report.begin_date)::text, 'НЕИЗВЕСТНО') begin_date /*дата проведения */,
 			coalesce(report.company_name, 'НЕИЗВЕСТНО') company_name,
 			coalesce(def.x_coord,-999) x_coord, /*долгота */
 			coalesce(def.y_coord,-999) y_coord, /*широта */
 			coalesce(def.z_coord,-999) z_coord, /*абс. высота */
 			coalesce(def.depth_of_cover,-999) depth_of_cover /* глубина заложения */,
 			coalesce(diameter.nominal_diameter_gcl ,1420) nominal_diameter_gcl,
 			coalesce(ABS( absolute_odometer - lm.marker_distance_left),-999) marker_distance_left /*Дистанция до маркера слева */,
 			lm.marker_name_left /* Имя маркера слева*/ ,
 			coalesce(ABS( absolute_odometer - rm.marker_distance_right),-999) marker_distance_right /* дистанция до маркера справа */ ,
 			rm.marker_name_right /*имя маркера справа*/,
 			dpl.defect_pipe_length defect_pipe_length,
 			anomaly_group anomaly_group,
 			coalesce(US_WELD_DISTANCE,0) US_WELD_DISTANCE,
 			coalesce(DS_WELD_DISTANCE,0) DS_WELD_DISTANCE,
 			IS_CLUSTER,
 			ILI_CLUSTER_ID, 
 			coalesce(def.ili_inspection_id,0) ILI_INSPECTION_ID,
 			coalesce(report.WELDS_COUNT,10000) WELDS_COUNT,
 			coalesce(report.INSP_LENGTH,100) INSP_LENGTH
 			,cluster_comment cluster_comment
 			,r_595_2011_comment r_595_2011_comment
 			,r_595_2011_depth_abrasion r_595_2011_depth_abrasion
 			,r_595_2011_length_pipe_repair r_595_2011_length_pipe_repair
 			,r_595_2011_repair_method r_595_2011_repair_method
 			,r_595_2011_square_abrasion r_595_2011_square_abrasion
 			,sto_112_2007_allow_pressure sto_112_2007_allow_pressure
 			,sto_112_2007_assurance_factor sto_112_2007_assurance_factor
 			,sto_112_2007_destruct_pressure sto_112_2007_destruct_pressure
 			,sto_112_2007_performance_eval sto_112_2007_performance_eval
 			,sto_173_2007_critical_pressure sto_173_2007_critical_pressure
 			,sto_173_2007_danger_degree sto_173_2007_danger_degree
 			,sto_173_2007_safe_pressure sto_173_2007_safe_pressure
 			,sto_292_2007_danger_rank sto_292_2007_danger_rank
 			,sto_401_2009_fail_probability sto_401_2009_fail_probability
 			,MEASURE
 			,coalesce(PAR.NOMINAL_DIAMETER_GCL,-1) PAR_NOMINAL_DIAMETER_GCL
 			,coalesce(PAR.NOMINAL_WALL_THICKNESS_GCL,-1) PAR_NOMINAL_WALL_THICKNESS_GCL
 			,coalesce(PAR.WORK_PRESSURE,-1) PAR_WORK_PRESSURE
 			,coalesce(PAR.dot_class_rating_cl,'DOT_CLASS_004') PAR_DOT_CLASS_RATING_GCL
 			,PAR.date_begin_exploitation PAR_DATE_BEGIN_EXP
 			,PAR.DATE_LAST_ILI PAR_DATE_LAST_ILI
				,coalesce(PAR.YYIELDING_LIMIT_MIN,-1) PAR_YYIELDING_LIMIT_MIN
				,coalesce(PAR.SAFETY_FACTOR,-1) PAR_SAFETY_FACTOR
				,coalesce(PAR.IMPACT_TOUGHNESS,-1) PAR_IMPACT_TOUGHNESS
				,coalesce(PAR.BREAK_POINT_MIN,-1) PAR_BREAK_POINT_MIN
 			FROM (SELECT d.orientation_deg
 			,d.nominal_wall_thickness
 			,d.weld_number
 			,d.calibrated_measure
 			,d.ili_data_id
 			,d.LENGTH
 			,d.average_depth
 			,d.width
 			,d.absolute_odometer
 			,d.anomaly_type_cl
 			,d.anomaly_extension_cl
 			,d.feature_description
 			,d.description
 			,d.ili_inspection_id
 			,CASE WHEN d.ili_cluster_id IS NOT NULL
 			THEN 1
 			ELSE -1
 			END is_cluster
 			,d.ili_cluster_id
 			,d.ds_weld_distance
 			,d.us_weld_distance
 			,sp.station
 			,sp.measure,
 			ia.description anomaly_type,
 			ia.description def_description,
 			c.x_coord, c.y_coord, c.z_coord, l.depth_of_cover,
 			CASE
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_003' THEN '1'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_004' AND IA.CODE = 121 THEN '1'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_001' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_002' AND IA.CODE !=144 THEN '4'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_005' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_007' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_009' THEN '2'
 			WHEN D.ANOMALY_EXTENSION_CL = 'ANOMALY_EXT_006' THEN '3'
 			WHEN IA.CODE !=144 THEN '4'
 			ELSE '-1'
 			END ANOMALY_GROUP,
 			1 COI_COUNT,
 			99 sorter
 			,ad.cluster_comment
 			,ad.r_595_2011_comment
 			,ad.r_595_2011_depth_abrasion
 			,ad.r_595_2011_length_pipe_repair
 			,ad.r_595_2011_repair_method
 			,ad.r_595_2011_square_abrasion
 			,ad.sto_112_2007_allow_pressure
 			,ad.sto_112_2007_assurance_factor
 			,ad.sto_112_2007_destruct_pressure
 			,ad.sto_112_2007_performance_eval
 			,ad.sto_173_2007_critical_pressure
 			,ad.sto_173_2007_danger_degree
 			,ad.sto_173_2007_safe_pressure
 			,ad.sto_292_2007_danger_rank
 			,ad.sto_401_2009_fail_probability
 			FROM pods.ili_data d
 			JOIN pods.ili_anomaly_type_cl ia
 			ON d.anomaly_type_cl = ia.code AND ia.category_cl = 1
 			LEFT JOIN pods.event_range e
 			ON d.event_id = e.event_id
 			LEFT JOIN pods.station_point sp
 			ON e.station_id_begin = sp.station_id
 			LEFT JOIN pods.coordinate c
 			ON c.coordinate_id = d.coordinate_id
 			LEFT JOIN pods.LOCATION l
 			ON c.location_id = l.location_id
 			LEFT OUTER JOIN pods.sto_ili_data_calc ad
 			ON ad.ili_data_id = d.ili_data_id 
 			WHERE d.ili_inspection_id = {INSPECTION_ID}
 			UNION ALL
 			/*Пошли кластера*/
 			SELECT ic.avg_orientation::numeric orientation_deg
 			,d.nominal_wall_thickness
 			,d.weld_number
 			,d.calibrated_measure
 			,d.ili_data_id
 			,ic.EFFECTIVE_LENGTH LENGTH
 			,(SELECT MAX(average_depth)
 			FROM pods.ili_data idd
 			WHERE idd.ili_cluster_id = ic.ili_cluster_id) average_depth
 			,ic.EFFECTIVE_WIDTH width
 			,d.absolute_odometer
 			,9 anomaly_type_cl
 			,CASE ic.description
 			WHEN 'Ремонтное место' THEN 'ANOMALY_EXT_003'
 			WHEN 'Группа поверхностных дефектов с КРН' THEN 'ANOMALY_EXT_005'
 			ELSE 'ANOMALY_EXT_001'
 			END anomaly_extension_cl
 			,ic.description feature_description
 			,ic.description
 			,d.ili_inspection_id
 			,0 is_cluster
 			,d.ili_cluster_id
 			,d.ds_weld_distance
 			,d.us_weld_distance
 			,sp.station
 			,sp.measure,
 			ia.description anomaly_type,
 			ia.description def_description,
 			c.x_coord, c.y_coord, c.z_coord, l.depth_of_cover,
 			CASE ic.description
 			WHEN 'Ремонтное место' THEN '1'
 			WHEN 'Группа поверхностных дефектов' THEN '2'
 			END anomaly_group,
 			ic.anomaly_count COI_COUNT,
 			0 sorter
 			,ca.cluster_comment
 			,ca.r_595_2011_comment
 			,ca.r_595_2011_depth_abrasion
 			,ca.r_595_2011_length_pipe_repair
 			,ca.r_595_2011_repair_method
 			,ca.r_595_2011_square_abrasion
 			,ca.sto_112_2007_allow_pressure
 			,ca.sto_112_2007_assurance_factor
 			,ca.sto_112_2007_destruct_pressure
 			,ca.sto_112_2007_performance_eval
 			,ca.sto_173_2007_critical_pressure
 			,ca.sto_173_2007_danger_degree
 			,ca.sto_173_2007_safe_pressure
 			,ca.sto_292_2007_danger_rank
 			,ca.sto_401_2009_fail_probability
 			FROM pods.ili_data d
 			JOIN pods.ili_anomaly_type_cl ia
 			ON d.anomaly_type_cl = ia.code AND ia.category_cl = 1
 			JOIN (SELECT DISTINCT ic.ili_cluster_id
 			,first_value (id.ili_data_id) OVER (PARTITION BY ic.ili_cluster_id ORDER BY id.absolute_odometer ASC ) ili_data_id
 			,ic.EFFECTIVE_LENGTH
 			,ic.avg_depth
 			,ic.EFFECTIVE_WIDTH
 			,ic.avg_orientation
 			,ic.anomaly_count
 			,ic.description
			 FROM pods.ili_cluster ic
 			JOIN pods.ili_data id
 			ON ic.ili_cluster_id = id.ili_cluster_id
 			AND ic.ili_inspection_id = id.ili_inspection_id
 			WHERE id.ili_inspection_id = {INSPECTION_ID}) ic
 			ON ic.ili_cluster_id = d.ili_cluster_id
 			AND ic.ili_data_id = d.ili_data_id
 			LEFT JOIN pods.event_range e
 			ON d.event_id = e.event_id
 			LEFT JOIN pods.station_point sp
 			ON e.station_id_begin = sp.station_id
 			LEFT JOIN pods.coordinate c
 			ON c.coordinate_id = d.coordinate_id
 			LEFT JOIN pods.LOCATION l
 			ON c.location_id = l.location_id
 			LEFT OUTER JOIN pods.sto_ili_cluster_calc ca
 			ON ca.ili_cluster_id = ic.ili_cluster_id
 			WHERE d.ili_cluster_id IS NOT NULL
 			AND d.ili_inspection_id = {INSPECTION_ID} ) def
 			JOIN report
 			ON def.ili_inspection_id = report.ili_inspection_id
 			LEFT JOIN defect_pipe_length dpl
 			ON dpl.ili_data_id = def.ili_data_id
 			LEFT OUTER JOIN left_marker lm
 			ON lm.ili_data_id = def.ili_data_id
 			LEFT OUTER JOIN right_marker rm
 			ON rm.ili_data_id = def.ili_data_id
	 			LEFT outer join pods.sto_temp_pipe_params_to_calc par
 			on def.measure between par.mes_start and par.mes_end
 			CROSS JOIN diameter
 			) r
 			ORDER BY "ABSOLUTE_ODOMETER","SORTER"
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_ILI_INSP_CALC_STO_6" comment="CALC_ILI_INSP_CALC_STO_6" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
			<query>
			DO $$
			
			DECLARE
 			BEGIN
 			IF '{CALC_CONSTRUCTION_INTERVALS}'='true'
 			THEN
 			UPDATE pods.event_range er
 			SET current_indicator_lf = 'N'
 			WHERE feature_id = 'INTERVAL_PER_OBJ'
 			AND current_indicator_lf = 'Y'
 			AND EXISTS (SELECT 1
 			FROM pods.sto_ili_inspection_calc ic
 			WHERE ic.event_id = er.event_id
 			AND ic.ili_inspection_id = {INSPECTION_ID});
 
 			END IF;

 			IF '{CALC_REGULAR_INTERVALS}'='true'
 			THEN
 			UPDATE pods.event_range er
 			SET current_indicator_lf = 'N'
 			WHERE feature_id = 'INTERVAL_REGULAR'
 			AND current_indicator_lf = 'Y'
 			AND EXISTS (SELECT 1
 			FROM pods.sto_ili_inspection_calc ic
 			WHERE ic.event_id = er.event_id
 			AND ic.ili_inspection_id = {INSPECTION_ID});
 			END IF;

			 IF '{CALC_LINE_EVENTS}' = 'true'
 			THEN
 			UPDATE pods.event_range er
 			SET current_indicator_lf = 'N'
 			WHERE feature_id = 'INTERVAL_LAN_REC'
 			AND current_indicator_lf = 'Y'
 			AND EXISTS (SELECT 1
 			FROM pods.sto_ili_inspection_calc ic
 			WHERE ic.event_id = er.event_id
 			AND ic.ili_inspection_id = {INSPECTION_ID}); 
 			END IF; 
 
 			DELETE 
 			FROM pods.sto_ili_inspection_calc
 			WHERE ili_inspection_id = {INSPECTION_ID};
 
			 END $$; 
			</query>
		</dbCommand>
	</update>
</data> 

<data id="CALC_ILI_INSP_CALC_STO_7" comment="CALC_ILI_INSP_CALC_STO_7" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
		<var name="LINE_EVENTS_QUERY"/>
		<var name="config.main.PODS_USER"/>		
			<query>
			DO $$
                DECLARE
                i RECORD;
                 v_event_id NUMERIC;
                 v_report_measure_begin NUMERIC(10,2);
                 v_report_measure_end NUMERIC(10,2);
                 v_begin_odometer NUMERIC(10,2);
                 v_end_odometer NUMERIC(10,2);
                 v_odometer1 NUMERIC(10,2);
                 v_odometer2 NUMERIC(10,2);
                 v_measure1 NUMERIC(10,2);
                 v_measure2 NUMERIC(10,2); 
                 v_route_id NUMERIC;
     
                 BEGIN
     
                 SELECT s.route_id,spb.measure,spe.measure
                 INTO v_route_id,v_report_measure_begin,v_report_measure_end
                 FROM pods.series s
                 JOIN pods.station_point spb
                 ON s.series_id = spb.series_id
                 JOIN pods.event_range er
                 ON er.station_id_begin = spb.station_id
                 JOIN pods.station_point spe
                 ON er.station_id_end = spe.station_id
                 JOIN pods.ili_inspection_range ir
                 ON ir.event_id = er.event_id
                 WHERE ir.ili_inspection_id = {INSPECTION_ID}; 
    
                 IF v_route_id IS NULL
                 OR v_route_id = 0
                 THEN
                 RETURN;
                 END IF; 
     
                 FOR i IN (SELECT er.*,spb.measure measure_begin,spe.measure measure_end
                 FROM pods.event_range er
                 JOIN pods.station_point spb
                 ON er.station_id_begin = spb.station_id
                 JOIN pods.station_point spe
                 ON er.station_id_end = spe.station_id
                 WHERE event_id in ({LINE_EVENTS_QUERY}))
                 LOOP 
    
                 /* в свете последних решений необходимо обрезать по размерам отчета */
     
                 /* BEGIN ODOMETER*/ 
                 /* Получена точка на трубе, создана или найдена, не важно, необходимо получить значение одометра в этом месте*/
                 BEGIN
                 SELECT absolute_odometer,measure
                 INTO v_odometer1,v_measure1 
                 FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure DESC,d.absolute_odometer ASC) RWN /* mssql compatibility*/
                 ,d.absolute_odometer
                 ,sp1.measure
                 FROM pods.station_point sp1
                 JOIN pods.station_point spb
                 USING (series_id)
                 JOIN pods.event_range er
                 ON sp1.station_id = er.station_id_begin
                 JOIN pods.ili_data d
                 USING (event_id)
                 WHERE spb.station_id = i.station_id_begin
                 AND sp1.measure&lt;=spb.measure
                 AND er.current_indicator_lf = 'Y'
                 AND d.ili_inspection_id = {INSPECTION_ID}) d
                 WHERE rwn = 1;
                 EXCEPTION WHEN NO_DATA_FOUND
                 THEN /* не нашлось ничего вокруг, попробую экстраполировать */
                 v_odometer1 := -1e6;
                 v_measure1 := -1e6; 
                 END; 
    
                 BEGIN 
                 SELECT absolute_odometer,measure
                 INTO v_odometer2,v_measure2 
                 FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure ASC,d.absolute_odometer DESC) RWN /* mssql compatibility*/
                 ,d.absolute_odometer
                 ,sp1.measure
                 FROM pods.station_point sp1
                 JOIN pods.station_point spb
                 USING (series_id)
                 JOIN pods.event_range er
                 ON sp1.station_id = er.station_id_begin
                 JOIN pods.ili_data d
                 USING (event_id)
                 WHERE spb.station_id = i.station_id_begin
                 AND sp1.measure&gt;=spb.measure
                 AND er.current_indicator_lf = 'Y'
                 AND d.ili_inspection_id = {INSPECTION_ID}) d
                 WHERE rwn = 1;
                 EXCEPTION WHEN NO_DATA_FOUND
                 THEN /* не нашлось ничего вокруг, попробую экстраполировать */
                 v_odometer2 := 1e6;
                 v_measure2 := 1e6; 
                 END; 
     
                 IF v_measure2 != v_measure1
                 THEN 
                 v_begin_odometer := v_odometer1+(i.measure_begin-v_measure1)*(v_odometer2-v_odometer1)/(v_measure2-v_measure1);
                 ELSE
                 v_begin_odometer := v_odometer1;
                 END IF;  
     
                 /* END ODOMETER*/ 
                 /* Получена точка на трубе, создана или найдена, не важно, необходимо получить значение одометра в этом месте*/
                 BEGIN
                 SELECT absolute_odometer,measure
                 INTO v_odometer1,v_measure1 
                 FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure DESC,d.absolute_odometer ASC) RWN /* mssql compatibility*/
                 ,d.absolute_odometer
                 ,sp1.measure
                 FROM pods.station_point sp1
                 JOIN pods.station_point spb
                 USING (series_id)
                 JOIN pods.event_range er
                 ON sp1.station_id = er.station_id_begin
                 JOIN pods.ili_data d
                 USING (event_id)
                 WHERE spb.station_id = i.station_id_end
                 AND sp1.measure&lt;=spb.measure
                 AND er.current_indicator_lf = 'Y'
                 AND d.ili_inspection_id = {INSPECTION_ID}) d
                 WHERE rwn = 1;
                 EXCEPTION WHEN NO_DATA_FOUND
                 THEN /* не нашлось ничего вокруг, попробую экстраполировать */
                 v_odometer1 := -1e6;
                 v_measure1 := -1e6; 
                 END; 
    
                 BEGIN 
                 SELECT absolute_odometer,measure
                 INTO v_odometer2,v_measure2 
                 FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure ASC,d.absolute_odometer DESC) RWN /* mssql compatibility*/
                 ,d.absolute_odometer
                 ,sp1.measure
                 FROM pods.station_point sp1
                 JOIN pods.station_point spb
                 USING (series_id)
                 JOIN pods.event_range er
                 ON sp1.station_id = er.station_id_begin
                 JOIN pods.ili_data d
                 USING (event_id)
                 WHERE spb.station_id = i.station_id_end
                 AND sp1.measure&gt;=spb.measure
                 AND er.current_indicator_lf = 'Y'
                 AND d.ili_inspection_id = {INSPECTION_ID}) d
                 WHERE rwn = 1;
                 EXCEPTION WHEN NO_DATA_FOUND
                 THEN /* не нашлось ничего вокруг, попробую экстраполировать */
                 v_odometer2 := 1e6;
                 v_measure2 := 1e6; 
                 END; 
     
                 IF v_measure2 != v_measure1
                 THEN 
                 v_end_odometer := v_odometer1+(i.measure_end-v_measure1)*(v_odometer2-v_odometer1)/(v_measure2-v_measure1);
                 ELSE            
                 v_end_odometer := v_odometer1;
                 END IF; 
     
                 INSERT INTO pods.event_range(feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf,positioning_type_cl,length) 
                 VALUES ('INTERVAL_LAN_REC',i.station_id_begin,i.station_id_end,'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN',/*i.length*/ ABS(i.measure_end-i.measure_begin))
                 RETURNING event_id INTO v_event_id;
     
                 INSERT INTO pods.sto_ili_inspection_calc (EVENT_ID,ILI_INSPECTION_ID,TYPE_CL,BEGIN_ODOMETER,END_ODOMETER)
                 VALUES (v_event_id,{INSPECTION_ID},'Оценка состояния по линейному event-объекту',v_begin_odometer,v_end_odometer);
     
                 END LOOP;
                 END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_ILI_INSP_CALC_STO_8" comment="CALC_ILI_INSP_CALC_STO_8" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
		<var name="CONSTRUCTION_ELEMENT_QUERY"/>
		<var name="config.main.PODS_USER"/>		
			<query>
			DO $$
                
                DECLARE
                i RECORD;
                 v_station_id_begin NUMERIC;
                 v_station_id_end NUMERIC;
                 v_station_measure_begin NUMERIC(10,2);
                 v_station_measure_end NUMERIC(10,2);
                 v_route_id NUMERIC;
                 v_event_like_this Integer;
                 v_event_id NUMERIC;
                 v_report_measure_begin NUMERIC(10,2);
                 v_report_measure_end NUMERIC(10,2);
                 v_begin_odometer NUMERIC(10,2);
                 v_end_odometer NUMERIC(10,2);
                 v_odometer1 NUMERIC(10,2);
                 v_odometer2 NUMERIC(10,2);
                 v_measure1 NUMERIC(10,2);
                 v_measure2 NUMERIC(10,2);
     
                BEGIN
     
                 SELECT s.route_id,spb.measure,spe.measure
                 INTO v_route_id,v_report_measure_begin,v_report_measure_end
                 FROM pods.series s
                 JOIN pods.station_point spb
                 ON s.series_id = spb.series_id
                 JOIN pods.event_range er
                 ON er.station_id_begin = spb.station_id
                 JOIN pods.station_point spe
                 ON er.station_id_end = spe.station_id
                 JOIN pods.ili_inspection_range ir
                 ON ir.event_id = er.event_id
                 WHERE ir.ili_inspection_id = {INSPECTION_ID}; 
    
                 IF v_route_id IS NULL
                 OR v_route_id = 0
                 THEN
                 RETURN;
                 END IF;
    
                 FOR i IN (WITH my_construction_elements
                 AS (SELECT station_id_begin
                 FROM pods.event_range er
                 WHERE er.event_id in ({CONSTRUCTION_ELEMENT_QUERY})
                 AND er.current_indicator_lf = 'Y'),
                 structural_elements
                 AS (SELECT sp.station_id,sp.measure
                 FROM pods.station_point sp
                 JOIN pods.series s
                 ON s.series_id = sp.series_id
                 WHERE s.route_id = v_route_id
                 AND sp.measure BETWEEN v_report_measure_begin AND v_report_measure_end
                 AND EXISTS (SELECT 1
                 FROM my_construction_elements me
                 WHERE me.station_id_begin = sp.station_id)
                 UNION ALL
                 SELECT DISTINCT FIRST_VALUE(spx.station_id) OVER (PARTITION BY er.event_id ORDER BY ABS(spx.measure - (spb.measure + (spe.measure - spb.measure)/2 ))) station_id
                 ,FIRST_VALUE(spx.measure) OVER (PARTITION BY er.event_id ORDER BY ABS(spx.measure - (spb.measure + (spe.measure - spb.measure)/2 ))) measure
                 FROM pods.event_range er
                 JOIN pods.station_point spb
                 ON spb.station_id = er.station_id_begin
                 JOIN pods.series s
                 ON s.series_id = spb.series_id
                 JOIN pods.station_point spe
                 ON spe.station_id = er.station_id_end
                 JOIN pods.station_point spX
                 ON s.series_id = spX.series_id
                 AND spX.measure BETWEEN spb.measure AND spe.measure
                 WHERE er.event_id in ({CONSTRUCTION_ELEMENT_QUERY})
                 AND ( (spb.measure BETWEEN v_report_measure_begin AND v_report_measure_end)
                 OR (spe.measure BETWEEN v_report_measure_begin AND v_report_measure_end))
                 AND er.current_indicator_lf = 'Y'
                 AND s.route_id = v_route_id
                 AND er.station_id_begin != er.station_id_end),
                 limits_station
                 AS (
			SELECT MIN(measure)  first_measure
                 ,MAX(measure)  last_measure
                 ,(select station_id from pods.station_point ss where ss.route_id= v_route_id  and ss.measure=(select min(measure) from pods.station_point sss where sss.route_id= v_route_id) limit 1) first_station_id
                ,(select station_id from pods.station_point ss where ss.route_id= v_route_id  and ss.measure=(select max(measure) from pods.station_point sss where sss.route_id= v_route_id) limit 1)  last_station_id
                 FROM pods.station_point sp
                 JOIN pods.series s
                 ON s.series_id = sp.series_id
                 WHERE s.route_id = v_route_id
                 AND sp.measure BETWEEN v_report_measure_begin AND v_report_measure_end),
                 combained_junctions
                 AS (SELECT first_station_id station_id,first_measure measure
                 FROM limits_station ls1
                 WHERE NOT EXISTS (SELECT 1 FROM structural_elements se WHERE ls1.first_measure = se.measure)
                 UNION ALL
                 SELECT station_id,measure
                 FROM structural_elements
                 UNION ALL
                 SELECT last_station_id station_id,last_measure
                 FROM limits_station ls2
                 WHERE NOT EXISTS (SELECT 1 FROM structural_elements se WHERE ls2.last_measure = se.measure))
                 SELECT station_id,measure
                 FROM combained_junctions
                 ORDER BY measure)
                 LOOP
                 v_station_id_end := i.station_id;
                 v_station_measure_end := i.measure;
                 /* Получена точка на трубе, создана или найдена, не важно, необходимо получить значение одометра в этом месте*/
                 BEGIN
                 SELECT absolute_odometer,measure
                 INTO v_odometer1,v_measure1 
                 FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure DESC,d.absolute_odometer ASC) RWN /* mssql compatibility*/
                 ,d.absolute_odometer
                 ,sp1.measure
                 FROM pods.station_point sp1
                 JOIN pods.station_point spb
                 USING (series_id)
                 JOIN pods.event_range er
                 ON sp1.station_id = er.station_id_begin
                 JOIN pods.ili_data d
                 USING (event_id)
                 WHERE spb.station_id = v_station_id_end
                 AND sp1.measure&lt;=spb.measure
                 AND er.current_indicator_lf = 'Y'
                 AND d.ili_inspection_id = {INSPECTION_ID}) d
                 WHERE rwn = 1;
                 EXCEPTION WHEN NO_DATA_FOUND
                 THEN /* не нашлось ничего вокруг, попробую экстраполировать */
                 v_odometer1 := -1e6;
                 v_measure1 := -1e6; 
                 END; 
    
                 BEGIN 
                 SELECT absolute_odometer,measure
                 INTO v_odometer2,v_measure2 
                 FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure ASC,d.absolute_odometer DESC) RWN /* mssql compatibility*/
                 ,d.absolute_odometer
                 ,sp1.measure
                 FROM pods.station_point sp1
                 JOIN pods.station_point spb
                 USING (series_id)
                 JOIN pods.event_range er
                 ON sp1.station_id = er.station_id_begin
                 JOIN pods.ili_data d
                 USING (event_id)
                 WHERE spb.station_id = v_station_id_end
                 AND sp1.measure&gt;=spb.measure
                 AND er.current_indicator_lf = 'Y'
                 AND d.ili_inspection_id = {INSPECTION_ID}) d
                 WHERE rwn = 1;
                 EXCEPTION WHEN NO_DATA_FOUND
                 THEN /* не нашлось ничего вокруг, попробую экстраполировать */
                 v_odometer2 := 1e6;
                 v_measure2 := 1e6; 
                 END; 
     
                 IF v_measure2 != v_measure1
                 THEN 
                 v_end_odometer := v_odometer1+(i.measure-v_measure1)*(v_odometer2-v_odometer1)/(v_measure2-v_measure1);
                 ELSE
                 v_end_odometer := v_odometer1;
                 END IF; 
     
                 /* Если первый проход то пропускаем итерацию цикла */
                 IF v_station_id_end IS NOT NULL
                 AND v_station_id_begin IS NOT NULL
                 THEN 
    
                 SELECT count(*)
                 INTO v_event_like_this
                 FROM pods.event_range er
                 WHERE feature_id = 'INTERVAL_PER_OBJ'
                 AND current_indicator_lf = 'Y'
                 AND station_id_begin = v_station_id_begin
                 AND station_id_end = v_station_id_end
                 AND EXISTS (SELECT 1
                 FROM pods.sto_ili_inspection_calc ic
                 WHERE ic.event_id = er.event_id
                 AND ic.ili_inspection_id = {INSPECTION_ID});
     
                 IF v_event_like_this = 0
                 THEN 
     
                 INSERT INTO pods.event_range(feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf,positioning_type_cl,length) 
                 VALUES ('INTERVAL_PER_OBJ',v_station_id_begin,v_station_id_end,'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN',ABS(v_station_measure_end-v_station_measure_begin))
                 RETURNING event_id INTO v_event_id;
     
                 INSERT INTO pods.sto_ili_inspection_calc (EVENT_ID,ILI_INSPECTION_ID,TYPE_CL,BEGIN_ODOMETER,END_ODOMETER)
                 VALUES (v_event_id,{INSPECTION_ID},'Оценка состояния по межконструкционным участкам',v_begin_odometer,v_end_odometer);
     
                 END IF; 
                 END IF;
                 v_station_id_begin := v_station_id_end;
                 v_station_measure_begin := v_station_measure_end;
                 v_begin_odometer := v_end_odometer;
     
                 END LOOP; 
                EXCEPTION WHEN OTHERS 
	 THEN RAISE EXCEPTION ' произошла ошибка: % код %',SQLERRM, SQLSTATE ; 
                END; $$
			</query>
		</dbCommand>
	</update>
</data> 

<data id="CALC_ILI_INSP_CALC_STO_9" comment="CALC_ILI_INSP_CALC_STO_9" schema="UTE" table="CALC_ILI_INSP_CALC_STO">
	<update>
		<dbCommand>
		<var name="INSPECTION_ID"/>
		<var name="REGULAR_INTERVALS_DISTANCE"/>
		<var name="config.main.PODS_USER"/>		
			<query>
	DO $$
                
                DECLARE
                i RECORD;
                 v_station_id_begin NUMERIC;
                 v_station_id_end NUMERIC;
                 v_location_id NUMERIC;
                 v_srv_district_gcl NUMERIC;
                 v_depth_of_cover NUMERIC;
                 v_X NUMERIC;
                 v_Y NUMERIC;
                 v_Z NUMERIC;
    
                 v_depth_of_cover1 NUMERIC;
                 v_X1 NUMERIC;
                 v_Y1 NUMERIC;
                 v_Z1 NUMERIC;
                 v_measure1 NUMERIC(10,2);
		 v_station_id1 NUMERIC;
    
                 v_depth_of_cover2 NUMERIC;
                 v_X2 NUMERIC;
                 v_Y2 NUMERIC;
                 v_Z2 NUMERIC;
                 v_measure2 NUMERIC(10,2);
		 v_station_id2 NUMERIC;

                 v_route_id NUMERIC;
                 v_event_like_this Integer;
                 v_event_id NUMERIC;
                 v_report_measure_begin NUMERIC(10,2);
                 v_report_measure_end NUMERIC(10,2);
                 v_begin_odometer NUMERIC(10,2);
                 v_end_odometer NUMERIC(10,2);
                 v_odometer1 NUMERIC(10,2);
                 v_odometer2 NUMERIC(10,2);
                BEGIN
     
                 SELECT s.route_id,spb.measure,spe.measure
                 INTO v_route_id,v_report_measure_begin,v_report_measure_end
                 FROM pods.series s
                 JOIN pods.station_point spb
                 ON s.series_id = spb.series_id
                 JOIN pods.event_range er
                 ON er.station_id_begin = spb.station_id
                 JOIN pods.station_point spe
                 ON er.station_id_end = spe.station_id
                 JOIN pods.ili_inspection_range ir
                 ON ir.event_id = er.event_id
                 WHERE ir.ili_inspection_id = {INSPECTION_ID}; 
    
                 IF v_route_id IS NULL
                 OR v_route_id = 0
                 THEN
                 RETURN;
                 END IF; 
     
                 FOR i IN ( WITH row_generator

                 AS (SELECT v_report_measure_begin +(series.a-1) * {REGULAR_INTERVALS_DISTANCE} measure FROM generate_series(1, (v_report_measure_end-v_report_measure_begin)/{REGULAR_INTERVALS_DISTANCE} + 1) as series(a)),
                 base_sp
                 AS (SELECT measure
                 ,station_id
                 ,LEAD(measure) OVER(ORDER BY measure) n_measure
                 ,LEAD(station_id) OVER (ORDER BY measure) n_station_id
                 ,sp.series
                 ,sp.station
                 ,sp.series_id
                 ,r.route_id
                 ,r.line_id
                 FROM pods.station_point sp
                 JOIN pods.series s
                 ON s.series_id = sp.series_id
                 JOIN pods.route r
                 ON r.route_id = s.route_id
                 JOIN pods.coordinate c
                 ON c.location_id = sp.location_id
                 WHERE r.route_id = v_route_id
                 AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03'))
                 (SELECT sp.line_id, sp.route_id, sp.series_id, sp.series, sp.station, s.measure
                 FROM row_generator s
                 JOIN base_sp sp
                 ON s.measure&gt;=sp.measure
                 AND s.measure&lt;sp.n_measure
                 UNION ALL
                 SELECT s.line_id, s.route_id, s.series_id, MAX(sp.series) series, MAX(sp.station) station, MAX(sp.measure) measure
                 FROM pods.series s
                 JOIN pods.station_point sp
                 ON sp.series_id = s.series_id
                 JOIN PODS.coordinate c
                 ON c.location_id = sp.location_id
                 WHERE s.route_id = v_route_id
                 AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03')
                 AND sp.measure BETWEEN v_report_measure_begin AND v_report_measure_end
                 GROUP BY s.line_id, s.route_id, s.series_id, sp.series)
                 ORDER BY MEASURE)
                 LOOP
     
                 v_station_id_begin := v_station_id_end;
                 v_begin_odometer := v_end_odometer;
     
                 SELECT count(*)
                 INTO v_event_like_this
                 FROM pods.event_range er
                 JOIN pods.station_point spe
                 ON er.station_id_end = spe.station_id
                 JOIN pods.series s
                 ON s.series_id = spe.series_id
                 WHERE feature_id = 'INTERVAL_REGULAR'
                 AND er.CURRENT_INDICATOR_LF = 'Y'
                 AND spe.measure = i.measure
                 AND spe.type_cl = 'ST_POINT_TYPE_04'
                 AND length = {REGULAR_INTERVALS_DISTANCE}
                 AND s.route_id = v_route_id
                 AND EXISTS (SELECT 1
                 FROM pods.sto_ili_inspection_calc ic
                 WHERE ic.event_id = er.event_id
                 AND ic.ili_inspection_id = {INSPECTION_ID});
     
                  IF v_event_like_this = 0
                 THEN 
     
                 /* необходимо интерполировать значения с соседних пикетов*/
                 
                     
                 SELECT l.srv_district_gcl
 			,l.depth_of_cover
 			,c.x_coord
 			,c.y_coord
 			,c.z_coord
 			,sp.measure
			,sp.station_id
 			INTO v_srv_district_gcl
 			,v_depth_of_cover1 
 			,v_X1 
 			,v_Y1 
 			,v_Z1 
 			,v_measure1
			,v_station_id1			 
 			FROM pods.station_point sp
 			JOIN pods.location l
 			ON l.location_id = sp.location_id
 			JOIN pods.coordinate c 
 			ON c.location_id = sp.location_id 
 			WHERE sp.route_id=i.route_id
                         and sp.measure = (SELECT max(sp2.measure) 
                        FROM pods.station_point sp2
                        WHERE sp2.route_id=v_route_id 
                        AND sp2.measure &lt;=i.measure)
                        limit 1;
 
 			SELECT l.depth_of_cover
 			,c.x_coord
 			,c.y_coord
 			,c.z_coord
 			,sp.measure
			,sp.station_id
 			INTO v_depth_of_cover2 
 			,v_X2 
 			,v_Y2 
 			,v_Z2 
 			,v_measure2 
			,v_station_id2
 			FROM pods.station_point sp
 			JOIN pods.location l
 			ON l.location_id = sp.location_id
 			JOIN pods.coordinate c 
 			ON c.location_id = sp.location_id 
 			WHERE sp.route_id=i.route_id
                         and sp.measure = (SELECT min(sp2.measure) 
                        FROM pods.station_point sp2
                        WHERE sp2.route_id=v_route_id 
                        AND sp2.measure &gt;=i.measure)
                        limit 1; 
      
                  IF abs(v_measure2 - v_measure1)>{REGULAR_INTERVALS_DISTANCE}*0.1
                  THEN 
                  v_depth_of_cover := v_depth_of_cover1+(i.measure-v_measure1)*(v_depth_of_cover2-v_depth_of_cover1)/(v_measure2-v_measure1);
                  v_X := v_X1+(i.measure-v_measure1)*(v_X2-v_X1)/(v_measure2-v_measure1); 
                  v_Y := v_Y1+(i.measure-v_measure1)*(v_Y2-v_Y1)/(v_measure2-v_measure1); 
                  v_Z := v_Z1+(i.measure-v_measure1)*(v_Z2-v_Z1)/(v_measure2-v_measure1);
                  INSERT INTO pods.location (srv_district_gcl,depth_of_cover) VALUES (v_srv_district_gcl,v_depth_of_cover)
                  RETURNING location_id INTO v_location_id;
      
                  INSERT INTO pods.station_point (line_id,route_id,series_id,series,location_id,station,measure,type_cl)
                  VALUES (i.line_id,i.route_id,i.series_id,i.series,v_location_id,i.station,i.measure,'ST_POINT_TYPE_04')
                  RETURNING station_id INTO v_station_id_end; 
      
                  INSERT INTO pods.coordinate(coordinate_source_id, location_id, x_coord, y_coord, z_coord
                  ,type_cl, horiz_indicator_lf, vert_indicator_lf, current_indicator_lf
                  ,effective_from_date, accuracy_cl, create_date, pods_user)
                  VALUES (9,v_location_id,v_X,v_Y,v_Z,'ASG','Y', 'Y', 'Y',current_timestamp, 'MEDIUM', current_timestamp, '{config.main.PODS_USER}');
                  ELSE
                  v_station_id_end:=v_station_id1;
                  END IF; 
     
                 ELSE
                 SELECT MIN(spe.station_id)
                 INTO v_station_id_end
                 FROM pods.event_range er
                 JOIN pods.station_point spe
                 ON er.station_id_end = spe.station_id
                 JOIN pods.series s
                 ON s.series_id = spe.series_id
                 WHERE feature_id = 'INTERVAL_REGULAR'
                 AND er.CURRENT_INDICATOR_LF = 'Y'
                 AND spe.measure = i.measure
                 AND spe.type_cl = 'ST_POINT_TYPE_04'
                 AND length = {REGULAR_INTERVALS_DISTANCE}
                 AND s.route_id = v_route_id
                 AND EXISTS (SELECT 1
                 FROM pods.sto_ili_inspection_calc ic
                 WHERE ic.event_id = er.event_id
                 AND ic.ili_inspection_id = {INSPECTION_ID});
                 END IF;

                 /* Получена точка на трубе, создана или найдена, не важно, необходимо получить значение одометра в этом месте*/
                 BEGIN
                 SELECT absolute_odometer,measure
                 INTO v_odometer1,v_measure1 
                 FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure DESC,d.absolute_odometer ASC) RWN /* mssql compatibility*/
                 ,d.absolute_odometer
                 ,sp1.measure
                 FROM pods.station_point sp1
                 JOIN pods.station_point spb
                 USING (series_id)
                 JOIN pods.event_range er
                 ON sp1.station_id = er.station_id_begin
                 JOIN pods.ili_data d
                 USING (event_id)
                 WHERE spb.station_id = v_station_id_end
                 AND sp1.measure&lt;=spb.measure
                 AND er.current_indicator_lf = 'Y'
                 AND d.ili_inspection_id = {INSPECTION_ID}) d
                 WHERE rwn = 1;
                 EXCEPTION WHEN NO_DATA_FOUND
                 THEN /* не нашлось ничего вокруг, попробую экстраполировать */
                 v_odometer1 := -1e6;
                 v_measure1 := -1e6; 
                 END; 
    
                 BEGIN 
                 SELECT absolute_odometer,measure
                 INTO v_odometer2,v_measure2 
                 FROM (SELECT ROW_NUMBER() OVER (ORDER BY sp1.measure ASC,d.absolute_odometer DESC) RWN /* mssql compatibility*/
                 ,d.absolute_odometer
                 ,sp1.measure
                 FROM pods.station_point sp1
                 JOIN pods.station_point spb
                 USING (series_id)
                 JOIN pods.event_range er
                 ON sp1.station_id = er.station_id_begin
                 JOIN pods.ili_data d
                 USING (event_id)
                 WHERE spb.station_id = v_station_id_end
                 AND sp1.measure&gt;= spb.measure
                 AND er.current_indicator_lf = 'Y'
                 AND d.ili_inspection_id = {INSPECTION_ID}) d
                 WHERE rwn = 1;
                 EXCEPTION WHEN NO_DATA_FOUND
                 THEN /* не нашлось ничего вокруг, попробую экстраполировать */
                 v_odometer2 := 1e6;
                 v_measure2 := 1e6; 
                 END; 
     
                 IF v_measure2 != v_measure1
                 THEN 
                 v_end_odometer := v_odometer1+(i.measure-v_measure1)*(v_odometer2-v_odometer1)/(v_measure2-v_measure1);
                 ELSE
                 v_end_odometer := v_odometer1;
                 END IF; 
    
                 /* Если первый проход то пропускаем итерацию цикла */
                 IF v_station_id_begin IS NOT NULL
                 THEN
                 INSERT INTO pods.event_range(feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf,positioning_type_cl,length)
                 VALUES ('INTERVAL_REGULAR',v_station_id_begin,v_station_id_end,'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN',{REGULAR_INTERVALS_DISTANCE})
                 RETURNING event_id INTO v_event_id;
                 INSERT INTO pods.sto_ili_inspection_calc (EVENT_ID,ILI_INSPECTION_ID,TYPE_CL,BEGIN_ODOMETER,END_ODOMETER)
                 VALUES (v_event_id,{INSPECTION_ID},'Оценка состояния по регулярным участкам ({REGULAR_INTERVALS_DISTANCE}m)',v_begin_odometer,v_end_odometer);
    
                 END IF;
    
                 END LOOP;
                 EXCEPTION WHEN OTHERS
	 THEN RAISE EXCEPTION ' произошла ошибка: % код %',SQLERRM, SQLSTATE ; 
                 END $$;
			</query>
		</dbCommand>
	</update>
</data> 
 
<data id="CALC_LINK_REPERS_1" comment="CALC_LINK_REPERS_1" schema="UTE" table="CALC_LINK_REPERS">
	<select>
		<dbQuery>
		<var name="P_REPORT_ID"/>
			<query>
			SELECT ili_data_id "OBJ_ID", absolute_odometer "LINE_COORD",
 			CASE WHEN d.anomaly_type_cl IN (1003,1007,1008) THEN '1' WHEN d.anomaly_type_cl=1004 THEN '2' END "OBJ_CLS_ID"
 			FROM pods.ili_data d
 			WHERE d.ili_inspection_id = {P_REPORT_ID} AND d.anomaly_type_cl IN (1003,1004,1007,1008)
			ORDER BY absolute_odometer 
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_LINK_REPERS_2" comment="CALC_LINK_REPERS_2" schema="UTE" table="CALC_LINK_REPERS">
	<select>
		<dbQuery>
		<var name="P_ROUTE_ID"/>
			<query>
			SELECT event_id "OBJ_ID", measure "LINE_COORD", obj_cls_id "OBJ_CLS_ID"
 			FROM (SELECT sp.route_id, e.event_id, sp.measure,
 			'1' obj_cls_id
 			FROM pods.station_point sp JOIN pods.event_range e
 			ON e.station_id_begin = sp.station_id
 			JOIN pods.valve v ON v.event_id = e.event_id
 			UNION ALL
 			SELECT sp.route_id, e.event_id, sp.measure, '2'
 			FROM pods.station_point sp JOIN pods.event_range e
 			ON e.station_id_begin = sp.station_id
 			JOIN pods.marker m ON m.event_id = e.event_id AND m.marker_type_gcl IN ('MARKER_TYPE_01','MARKER_TYPE_02')
 			) t
 			WHERE route_id = {P_ROUTE_ID}
			ORDER BY "LINE_COORD"
			</query>
		</dbQuery>
	</select>
</data> 

<data id="CALC_LINK_REPERS_3" comment="CALC_LINK_REPERS_3" schema="UTE" table="CALC_LINK_REPERS">
	<insert>
		<dbCommand>
		<var name="COEFF" type="Decimal"/>	
		<var name="FACILITY_ID" type="Decimal"/>	
		<var name="REPER_ID" type="Decimal"/>			
			<query>
			UPDATE pods.ili_data 
 			SET (ref_event_id, ref_event_guid, control_point_lf, calibrated_measure, certainty_interval) = (
 			SELECT e.event_id, e.event_guid, 'Y', sp.measure, {COEFF}
 			FROM pods.event_range e 
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin 
 			WHERE e.event_id = {FACILITY_ID}) 
 			WHERE ili_data_id = {REPER_ID} 
			</query>
		</dbCommand>
	</insert>
</data> 

<data id="CALC_LINK_REPERS_4" comment="CALC_LINK_REPERS_4" schema="UTE" table="CALC_LINK_REPERS">
	<update>
		<dbCommand>
		<var name="P_REPORT_ID"/>
			<query>
			UPDATE pods.ili_data SET 
 			ref_event_id = null, ref_event_guid = null, control_point_lf = 'N', 
 			calibrated_measure = null, certainty_interval = null
 			WHERE ili_inspection_id = {P_REPORT_ID}
			</query>
		</dbCommand>
	</update>
</data>

<data id="CP_CP_ZIP_IMP_C_1" comment="CP_CP_ZIP_IMP_C_1" schema="UTE" table="CP_CP_ZIP_IMP_C">
	<select>
		<dbQuery>
		<var name="call_method.FILE_NAME"/>
			<query>
			SELECT * FROM [{call_method.FILE_NAME}]
			</query>
		</dbQuery>
	</select>
</data>

<data id="CP_CP_ZIP_IMP_C_2" comment="CP_CP_ZIP_IMP_C_2" schema="UTE" table="CP_CP_ZIP_IMP_C">
	<insert>
		<dbCommand>
		<var name="config.main.PODS_USER"/>
		<var name="xpath_view.REPORT_VIEW.date:dd.MM.yyyy"/>
		<var name="db_command.CMD.EVENT_ID"/>
		<var name="xpath_view.REPORT_VIEW.source"/>
		<var name="EVENT_ID" type="Decimal" default="SELECT max(EVENT_ID) id FROM PODS.EVENT_RANGE"/>	
		<var name="U_вкл" type="Decimal"/>	
		<var name="U_откл" type="Decimal"/>
		<var name="min_пот" type="Decimal"/>	
		<var name="G_вкл" type="Decimal"/>	
		<var name="G_откл" type="Decimal"/>
		<var name="dG" type="Decimal"/>	
		<var name="ddG" type="Decimal"/>	
		<var name="COMM" type="String"/>	
		<var name="DESCR" type="String"/>		
		<var name="COORD_B" type="String"/>	
		<var name="COORD_L" type="String"/>	
		<var name="R/1000" type="Decimal"/>		
		<var name="REF_EVENT_ID" type="Decimal"/>
			<query>
			DO $$
			DECLARE
			RETURNid integer;
			BEGIN
 			INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,VALIDITY_TOLERANCE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL) 
 			VALUES ('PI_CIS_READING', 0, 0, '{config.main.PODS_USER}', current_timestamp, 0, current_timestamp, 'Y', 'UNKNOWN') RETURNING EVENT_ID INTO RETURNid; 
 			INSERT INTO pods.pi_cis_reading(EVENT_ID, PS_ON, PS_OFF, DC_POTENTIAL_VOLTS, GRAD_ON, GRAD_OFF, D_GRAD, DD_GRAD, DESCRIPTION, INSPECTION_DATE, PI_CP_EVENT_ID, COMMENTS, SOURCE_GCL)
 			VALUES (RETURNid, {U_вкл}, {U_откл}, {min_пот}, {G_вкл}, {G_откл}, {dG}, {ddG}, SUBSTR('{COMM}',1,50), TO_DATE('{xpath_view.REPORT_VIEW.date:dd.MM.yyyy}','DD.MM.YYYY'), {db_command.CMD.EVENT_ID}, trim('{DESCR}')||';'||trim('{COORD_B}')||';'||trim('{COORD_L}', '{xpath_view.REPORT_VIEW.source}');
 			IF '{COMM}' LIKE 'КИП%' AND :DESCR IS NOT NULL THEN
 			INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,VALIDITY_TOLERANCE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL) 
 			VALUES ('PI_CP_READING', 0, 0, '{config.main.PODS_USER}', current_timestamp, 0, current_timestamp, 'Y', 'UNKNOWN') RETURNING EVENT_ID INTO RETURNid; 
 			INSERT INTO pods.pi_cp_reading(EVENT_ID, TYPE_CL, PS_ON, PS_OFF, RESISTANCE_READING, POTENTIAL_READING, GRAD_ON, GRAD_OFF, D_GRAD, DD_GRAD, DESCRIPTION, INSPECTION_DATE, PI_CP_EVENT_ID, REF_TEST_LEAD_EVENT_ID, COMMENTS, SOURCE_GCL)
 			VALUES (RETURNid, 'UNKNOWN', {U_вкл}, {U_откл}, {R/1000}, {min_пот}, {G_вкл}, {G_откл}, {dG}, {ddG}, SUBSTR('{COMM}',1,50), TO_DATE('{xpath_view.REPORT_VIEW.date:dd.MM.yyyy}','DD.MM.YYYY'), {db_command.CMD.EVENT_ID}, {REF_EVENT_ID}, trim('{DESCR}')||';'||trim('{COORD_B}')||';'||trim('{COORD_L}', '{xpath_view.REPORT_VIEW.source}');
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data> 
 
<data id="CP_CP_ZIP_IMP_C_3" comment="CP_CP_ZIP_IMP_C_3" schema="UTE" table="CP_CP_ZIP_IMP_C">
	<insert>
		<dbCommand>
		<var name="config.main.PODS_USER"/>
		<var name="xpath_view.REPORT_VIEW.date:dd.MM.yyyy"/>
		<var name="db_command.CMD.EVENT_ID"/>
		<var name="xpath_view.REPORT_VIEW.source"/>
		<var name="DESCR" type="String"/>			
		<var name="EVENT_ID" type="Decimal" default="SELECT max(EVENT_ID) id FROM PODS.EVENT_RANGE"/>		
		<var name="U_вкл" type="Decimal"/>	
		<var name="U_откл" type="Decimal"/>		
		<var name="R/1000" type="Decimal"/>	
		<var name="min_пот" type="Decimal"/>	
		<var name="G_вкл" type="Decimal"/>	
		<var name="G_откл" type="Decimal"/>
		<var name="dG" type="Decimal"/>	
		<var name="ddG" type="Decimal"/>	
		<var name="NUMKIP" type="String"/>
		<var name="COMM" type="String"/>	
		<var name="REF_EVENT_ID" type="Decimal"/>		
		<var name="COORD_B" type="String"/>	
		<var name="COORD_L" type="String"/>	
			<query>
			DO $$
			DECLARE RETURNid integer;
			BEGIN
 			IF '{DESCR}' IS NOT NULL THEN
 			INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,VALIDITY_TOLERANCE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL) 
 			VALUES ('PI_CP_READING', 0, 0, '{config.main.PODS_USER}', current_timestamp, 0, current_timestamp, 'Y', 'UNKNOWN') RETURNING EVENT_ID INTO RETURNid; 
 			INSERT INTO pods.pi_cp_reading(EVENT_ID, TYPE_CL, PS_ON, PS_OFF, RESISTANCE_READING, POTENTIAL_READING, GRAD_ON, GRAD_OFF, D_GRAD, DD_GRAD, DESCRIPTION, INSPECTION_DATE, PI_CP_EVENT_ID, REF_TEST_LEAD_EVENT_ID, COMMENTS, SOURCE_GCL)
 			VALUES (RETURNid, 'UNKNOWN', {U_вкл}, {U_откл}, {R/1000}, {min_пот}, {G_вкл}, {G_откл}, {dG}, {ddG}, SUBSTR(coalesce2('{NUMKIP}','КИП '||'{NUMKIP}'||';','')||'{COMM}',1,50), TO_DATE('{xpath_view.REPORT_VIEW.date:dd.MM.yyyy}','DD.MM.YYYY'), {db_command.CMD.EVENT_ID}, {REF_EVENT_ID}, trim('{DESCR}')||';'||trim('{COORD_B}')||';'||trim('{COORD_L}'), '{xpath_view.REPORT_VIEW.source}');
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data> 

<data id="CP_CP_ZIP_IMP_C_4" comment="CP_CP_ZIP_IMP_C_4" schema="UTE" table="CP_CP_ZIP_IMP_C">
	<insert>
		<dbCommand>
		<var name="config.main.PODS_USER"/>
		<var name="xpath_view.REPORT_VIEW.type"/>
		<var name="xpath_view.REPORT_VIEW.descr"/>
		<var name="xpath_view.REPORT_VIEW.km_start"/>
		<var name="xpath_view.REPORT_VIEW.km_end"/>		
		<var name="xpath_view.REPORT_VIEW.date:dd.MM.yyyy"/>
		<var name="xpath_view.REPORT_VIEW.criteria"/>		
		<var name="xpath_view.REPORT_VIEW.result"/>		
		<var name="xpath_view.REPORT_VIEW.tool"/>	
		<var name="xpath_view.REPORT_VIEW.source"/>		
		<var name="xpath_view.REPORT_VIEW.nominal_spacing"/>
		<var name="EVENT_ID" type="Decimal"  default="SELECT max(EVENT_ID) id FROM PODS.EVENT_RANGE"/>	
			<query>
			DO $$
			DECLARE
			RETURNid integer;
			BEGIN 
			INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,VALIDITY_TOLERANCE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL) 
 			VALUES ('PI_CP_INSPECTION', 0, 0, '{config.main.PODS_USER}', current_timestamp, 0, current_timestamp, 'Y', 'UNKNOWN') RETURNING EVENT_ID INTO RETURNid;
 			INSERT INTO pods.pi_cp_inspection(EVENT_ID, TYPE_CL, DESCRIPTION, COMMENTS, INSPECTION_DATE, CRITERIA_CL, RESULT_CL, TOOL_CL, SOURCE_GCL, NOMINAL_SPACING, PI_EVENT_ID) 
 			VALUES ({EVENT_ID}, '{xpath_view.REPORT_VIEW.type}', '{xpath_view.REPORT_VIEW.descr}', '{xpath_view.REPORT_VIEW.km_start}-{xpath_view.REPORT_VIEW.km_end}', TO_DATE('{xpath_view.REPORT_VIEW.date:dd.MM.yyyy}','DD.MM.YYYY'), '{xpath_view.REPORT_VIEW.criteria}', '{xpath_view.REPORT_VIEW.result}', '{xpath_view.REPORT_VIEW.tool}', '{xpath_view.REPORT_VIEW.source}', '{xpath_view.REPORT_VIEW.nominal_spacing}', -90) ; 
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="DISTR_DISTR_LINE_IDX_C_1" comment="DISTR_DISTR_LINE_IDX_C_1" schema="UTE" table="DISTR_DISTR_LINE_IDX_C">
	<update>
		<dbCommand>
		<var name="P_LINE_ID"/>
			<query>
			DO $$
			
			BEGIN
 			DELETE FROM pods.srv_district_boundary 
 			WHERE event_id IN (SELECT e.event_id FROM pods.event_range e 
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin 
 			WHERE sp.line_id = {P_LINE_ID} AND e.feature_id = 'SRV_DISTR_BND');
 			UPDATE pods.event_range e SET CURRENT_INDICATOR_LF = 'N'
 			WHERE e.feature_id = 'SRV_DISTR_BND'
 			AND EXISTS (SELECT 1 FROM pods.station_point sp 
 			WHERE sp.station_id = e.station_id_begin 
 			AND sp.line_id = {P_LINE_ID});
 			END $$;
			</query>
		</dbCommand>
	</update>
</data>
 
<data id="DISTR_DISTR_LINE_IDX_C_2" comment="DISTR_DISTR_LINE_IDX_C_2" schema="UTE" table="DISTR_DISTR_LINE_IDX_C">
	<update>
		<dbCommand>
		<var name="P_LINE_ID"/>
		<var name="config.main.PODS_USER"/>		
			<query>
			DO $$
			
			BEGIN
 			INSERT INTO pods.event_range (feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf)
 			SELECT DISTINCT 'SRV_DISTR_BND'
 			,FIRST_VALUE (sp.station_id) OVER (PARTITION BY l.srv_district_gcl ORDER BY r.sequence,sp.measure) station_id_begin
 			,FIRST_VALUE (sp.station_id) OVER (PARTITION BY l.srv_district_gcl ORDER BY r.sequence DESC,sp.measure DESC) station_id_end
 			,'{config.main.PODS_USER}',current_timestamp,current_timestamp,'Y'
 			FROM pods.line ll 
 			JOIN pods.route r ON r.line_id = ll.line_id
 			JOIN pods.station_point sp ON sp.route_id = r.route_id
 			JOIN pods.location l ON l.location_id = sp.location_id 
			WHERE ll.line_id = {P_LINE_ID}
 			AND ((r.type_cl = 'ROUTE_TYPE_04' AND ll.type_cl = 'LINE_TYPE_04') OR 
 			(r.type_cl = 'ROUTE_TYPE_12' AND ll.type_cl = 'LINE_TYPE_03') OR
 			(r.type_cl = 'ROUTE_TYPE_10' AND ll.type_cl = 'LINE_TYPE_01'))
 			AND l.srv_district_gcl is not null
 			AND sp.type_cl IN ('ST_POINT_TYPE_01', 'ST_POINT_TYPE_02', 'ST_POINT_TYPE_03')
 			AND r.route_id != 0
 			AND l.location_id != 0;
 
 			INSERT INTO pods.srv_district_boundary (event_id,srv_district_id,description,source_gcl)
 			SELECT e.event_id,l.srv_district_gcl,ln.description||' ('||spb.station ||'-' || spe.station ||')' description,'NGG'
 			FROM pods.event_range e
 			JOIN pods.station_point spb ON spb.station_id = e.station_id_begin
 			JOIN pods.station_point spe ON spe.station_id = e.station_id_end
 			JOIN pods.location l ON l.location_id = spb.location_id
 			JOIN pods.line ln ON ln.line_id = spb.line_id
 			WHERE e.feature_id = 'SRV_DISTR_BND' and e.current_indicator_lf = 'Y'
 			AND spb.line_id = {P_LINE_ID};
 			END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="GROUP_GROUP_IDX_C_1" comment="GROUP_GROUP_IDX_C_1" schema="UTE" table="GROUP_GROUP_IDX_C">
	<select>
		<dbQuery>
		<var name="EVENT_ID"/>
			<query>
			SELECT e.event_id "ID", c.X_COORD "X", c.Y_COORD "Y"
 			FROM pods.event_range e
 			JOIN pods.station_point spb ON spb.station_id = e.station_id_begin
 			JOIN pods.station_point spe ON spe.station_id = e.station_id_end
 			JOIN pods.route rb ON rb.route_id = spb.route_id
 			JOIN pods.route re ON re.route_id = spe.route_id
 			JOIN pods.route r ON r.line_id = rb.line_id AND r.sequence BETWEEN rb.sequence AND re.sequence
 			JOIN pods.station_point sp ON sp.route_id = r.route_id 
 			AND (r.sequence!=rb.sequence OR sp.measure&gt;=spb.measure)
 			AND (r.sequence!=re.sequence OR sp.measure&lt;=spe.measure)
 			JOIN pods.coordinate c ON c.location_id = sp.location_id
 			WHERE e.event_id IN({EVENT_ID})
 			AND e.current_indicator_lf = 'Y'
 			AND spb.line_id != 0
 			AND c.x_coord != -1
 			ORDER BY e.event_id, sp.measure 
			</query>
		</dbQuery>
	</select>
</data>

<data id="GROUP_GROUP_IDX_C_2" comment="GROUP_GROUP_IDX_C_2" schema="UTE" table="GROUP_GROUP_IDX_C">
	<select>
		<dbQuery>
		<var name="ROUTE_ID"/>
		<var name="call_method.RES_OBJ_FEATURE_ID"/>		
			<query>
			SELECT e.event_id "ID", c.X_COORD "X", c.Y_COORD "Y"
 			FROM pods.event_range e
 			JOIN pods.station_point spb ON spb.station_id = e.station_id_begin
 			JOIN pods.station_point spe ON spe.station_id = e.station_id_end
 			JOIN pods.route rb ON rb.route_id = spb.route_id
 			JOIN pods.route re ON re.route_id = spe.route_id
 			JOIN pods.route r ON r.line_id = rb.line_id AND r.sequence BETWEEN rb.sequence AND re.sequence
 			JOIN pods.station_point sp ON sp.route_id = r.route_id 
 			AND (r.sequence!=rb.sequence OR sp.measure&gt;=spb.measure)
 			AND (r.sequence!=re.sequence OR sp.measure&lt;=spe.measure)
 			JOIN pods.coordinate c ON c.location_id = sp.location_id
 			WHERE r.route_id IN({ROUTE_ID})
 			AND e.feature_id IN ('{call_method.RES_OBJ_FEATURE_ID}')
 			AND e.current_indicator_lf = 'Y'
 			AND spb.line_id != 0
 			AND c.x_coord != -1
 			ORDER BY e.event_id, sp.measure 
			</query>
		</dbQuery>
	</select>
</data>

<data id="GROUP_GROUP_IDX_C_3" comment="GROUP_GROUP_IDX_C_3" schema="UTE" table="GROUP_GROUP_IDX_C">
	<insert>
		<dbCommand>
		<var name="GROUP_NAME"/>
		<var name="EVENT_ID" type="Decimal"/>	
		<var name="ID" type="Decimal"/>		
			<query>
			DO $$
			
			DECLARE
 			group_id NUMERIC(16,0);
 			exists_id NUMERIC(16,0);
 			BEGIN
 			IF {EVENT_ID} IS NULL THEN
 			return;
 			END IF;

			 SELECT MIN(event_group_id)
 			INTO group_id
 			FROM pods.event_group_cross_ref WHERE event_id = {EVENT_ID} AND description = '1';
 
 			IF group_id IS NULL THEN
 			INSERT INTO pods.event_group(GROUP_NAME) VALUES('{GROUP_NAME}') RETURNING event_group_id INTO group_id;
 			INSERT INTO pods.event_group_cross_ref(EVENT_ID, EVENT_GROUP_ID, DESCRIPTION) VALUES({EVENT_ID}, group_id, '1');
 			END IF;
 
 			SELECT MIN(event_group_id)
 			INTO exists_id
 			FROM pods.event_group_cross_ref 
 			WHERE event_group_id = group_id AND event_id = {ID} AND description = '0';
 
 			IF exists_id IS NULL THEN
 			INSERT INTO pods.event_group_cross_ref(EVENT_ID, EVENT_GROUP_ID, DESCRIPTION) 
 			VALUES({ID}, group_id, '0');
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="GROUP_GROUP_IDX_C_4" comment="GROUP_GROUP_IDX_C_4" schema="UTE" table="GROUP_GROUP_IDX_C">
	<select>
		<dbQuery>	
			<query>
			select e.EVENT_ID"EVENT_ID", p.PART_ID "P_ID", c.X_COORD "X", c.Y_COORD "Y"
 			FROM pods.OFFLINE_EVENT oe
 			JOIN pods.offline_cross_ref cr ON cr.offline_id = oe.offline_id
 			JOIN pods.event_range e ON e.event_id = cr.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			JOIN pods.PART p ON p.SHAPE_ID = oe.SHAPE_ID
 			JOIN pods.VERTEX v ON v.PART_ID = p.PART_ID
 			JOIN pods.COORDINATE c ON c.LOCATION_ID = v.LOCATION_ID
 			WHERE oe.feature_id IN ('STRUCTURE')
					 AND e.current_indicator_lf = 'Y'
 			ORDER BY e.EVENT_ID, p.HOLE_FL, p.PART_ID, v.SEQUENCE_NO 
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="GROUP_GROUP_IDX_C_ALL_1" comment="GROUP_GROUP_IDX_C_ALL_1" schema="UTE" table="GROUP_GROUP_IDX_C_ALL">
	<select>
		<dbQuery>	
		<var name="EVENT_ID"/>		
			<query>
			SELECT e.event_id "ID", c.X_COORD "X", c.Y_COORD "Y"
 			FROM pods.event_range e
 			JOIN pods.station_point spb ON spb.station_id = e.station_id_begin
 			JOIN pods.station_point spe ON spe.station_id = e.station_id_end
 			JOIN pods.route rb ON rb.route_id = spb.route_id
 			JOIN pods.route re ON re.route_id = spe.route_id
 			JOIN pods.route r ON r.line_id = rb.line_id AND r.sequence BETWEEN rb.sequence AND re.sequence
 			JOIN pods.station_point sp ON sp.route_id = r.route_id 
 			AND (r.sequence!=rb.sequence OR sp.measure&gt;=spb.measure)
 			AND (r.sequence!=re.sequence OR sp.measure&lt;=spe.measure)
 			JOIN pods.coordinate c ON c.location_id = sp.location_id
 			WHERE e.event_id IN({EVENT_ID})
 			AND e.current_indicator_lf = 'Y'
 			AND spb.line_id != 0
 			AND c.x_coord != -1
 			ORDER BY e.event_id, sp.measure
			</query>
		</dbQuery>
	</select>
</data> 

<data id="GROUP_GROUP_IDX_C_ALL_2" comment="GROUP_GROUP_IDX_C_ALL_2" schema="UTE" table="GROUP_GROUP_IDX_C_ALL">
	<select>
		<dbQuery>	
		<var name="ROUTE_ID"/>
		<var name="call_method.RES_OBJ_FEATURE_ID"/>		
			<query>
			SELECT e.event_id "ID", c.X_COORD "X", c.Y_COORD "Y"
 			FROM pods.event_range e
 			JOIN pods.station_point spb ON spb.station_id = e.station_id_begin
 			JOIN pods.station_point spe ON spe.station_id = e.station_id_end
 			JOIN pods.route rb ON rb.route_id = spb.route_id
 			JOIN pods.route re ON re.route_id = spe.route_id
 			JOIN pods.route r ON r.line_id = rb.line_id AND r.sequence BETWEEN rb.sequence AND re.sequence
 			JOIN pods.station_point sp ON sp.route_id = r.route_id 
 			AND (r.sequence!=rb.sequence OR sp.measure&gt;=spb.measure)
 			AND (r.sequence!=re.sequence OR sp.measure&lt;=spe.measure)
 			JOIN pods.coordinate c ON c.location_id = sp.location_id
 			WHERE r.route_id IN({ROUTE_ID})
 			AND e.feature_id IN ('{call_method.RES_OBJ_FEATURE_ID}')
 			AND e.current_indicator_lf = 'Y'
 			AND spb.line_id != 0
 			AND c.x_coord != -1
 			ORDER BY e.event_id, sp.measure 
			</query>
		</dbQuery>
	</select>
</data> 

<data id="GROUP_GROUP_IDX_C_ALL_3" comment="GROUP_GROUP_IDX_C_ALL_3" schema="UTE" table="GROUP_GROUP_IDX_C_ALL">
	<insert>
		<dbCommand>
		<var name="GROUP_NAME"/>
		<var name="EVENT_ID" type="Decimal"/>	
		<var name="ID" type="Decimal"/>		
			<query>
			DO $$
			
			DECLARE
 			group_id NUMERIC(16,0);
 			exists_id NUMERIC(16,0);
 			BEGIN
 			IF {EVENT_ID} IS NULL THEN
 			return;
 			END IF;

 			SELECT MIN(event_group_id)
 			INTO group_id
 			FROM pods.event_group_cross_ref WHERE event_id = {EVENT_ID} AND description = '1';
 
 			IF group_id IS NULL THEN
 			INSERT INTO pods.event_group(GROUP_NAME) VALUES('{GROUP_NAME}') RETURNING event_group_id INTO group_id;
 			INSERT INTO pods.event_group_cross_ref(EVENT_ID, EVENT_GROUP_ID, DESCRIPTION) VALUES({EVENT_ID}, group_id, '1');
 			END IF;
 
 			SELECT MIN(event_group_id)
 			INTO exists_id
 			FROM pods.event_group_cross_ref 
 			WHERE event_group_id = group_id AND event_id = {EVENT_ID} AND description = '0';
 
 			IF exists_id IS NULL THEN
 			INSERT INTO pods.event_group_cross_ref(EVENT_ID, EVENT_GROUP_ID, DESCRIPTION) 
 			VALUES({ID}, group_id, '0');
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="GROUP_GROUP_IDX_C_ALL_4" comment="GROUP_GROUP_IDX_C_ALL_4" schema="UTE" table="GROUP_GROUP_IDX_C_ALL">
	<select>
		<dbQuery>	
			<query>
			select e.EVENT_ID "EVENT_ID", p.PART_ID "P_ID", c.X_COORD "X", c.Y_COORD "Y"
 			FROM pods.OFFLINE_EVENT oe
 			JOIN pods.offline_cross_ref cr ON cr.offline_id = oe.offline_id
 			JOIN pods.event_range e ON e.event_id = cr.event_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
 			JOIN pods.PART p ON p.SHAPE_ID = oe.SHAPE_ID
 			JOIN pods.VERTEX v ON v.PART_ID = p.PART_ID
 			JOIN pods.COORDINATE c ON c.LOCATION_ID = v.LOCATION_ID
 			WHERE oe.feature_id IN ('STRUCTURE')
		 			AND e.current_indicator_lf = 'Y'
 			ORDER BY e.EVENT_ID, p.HOLE_FL, p.PART_ID, v.SEQUENCE_NO
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="ILI_ILI_BAT_CLUSTER_C_1" comment="ILI_ILI_BAT_CLUSTER_C_1" schema="UTE" table="ILI_ILI_BAT_CLUSTER_C">
	<select>
		<dbQuery>	
			<query>
SELECT ir.ILI_INSPECTION_ID "ILI_INSPECTION_ID",coalesce(MIN(spb.route_id),-1) "ROUTE_ID",coalesce(ps.NOMINAL_DIAMETER_GCL,1420) "NOMINAL_DIAMETER_GCL"
 			FROM pods.ili_inspection_range ir
 			JOIN pods.event_range er 
 			ON er.event_id = ir.event_id and ir.ili_inspection_id not in (select cc.ili_inspection_id from pods.ili_cluster cc)
 			JOIN pods.station_point spb 
 			ON er.station_id_begin = spb.station_id
 			JOIN pods.station_point spbps
 			ON spbps.series_id = spb.series_id
 			JOIN pods.event_range erPS
 			ON erps.station_id_Begin = spbps.station_id 
 			JOIN pods.pipe_segment PS 
 			ON PS.event_id = erPS.event_id
            Join pods.ili_inspection i
            on ir.ili_inspection_id=i.ili_inspection_id
 			WHERE erPS.feature_id = 'PIPE_SEGMENT'
 			AND erPS.CURRENT_INDICATOR_LF = 'Y'
             		and i.ili_inspection_id in (select g.key_values::numeric ILI_INSPECTION_ID from gis_integration50.gate g where g.owner='CALC' and g.table_name like 'ILI_Cluster.xml')
 			GROUP BY ir.ILI_INSPECTION_ID,ER.CREATE_DATE ,ps.nominal_diameter_gcl 
 			ORDER BY "ROUTE_ID",ER.CREATE_DATE DESC 
			</query>
		</dbQuery>
	</select>
</data> 

<data id="ILI_ILI_BAT_PROC_C_ALL_1" comment="ILI_ILI_BAT_PROC_C_ALL_1" schema="UTE" table="ILI_ILI_BAT_PROC_C_ALL">
	<select>
		<dbQuery>	
			<query>
			SELECT DISTINCT i.ILI_INSPECTION_ID "ILI_INSPECTION_ID", sp.ROUTE_ID "ROUTE_ID"
 			FROM pods.ili_inspection i 
 			JOIN pods.ili_inspection_range r on r.ili_inspection_id = i.ili_inspection_id
 			JOIN pods.event_range e on r.event_id = e.event_id
 			JOIN pods.station_point sp on sp.station_id = e.station_id_begin where not exists (select 1 from pods.sto_ili_data_calc c where c.ili_inspection_id=i.ili_inspection_id) order by i.ili_inspection_id
			</query>
		</dbQuery>
	</select>
</data>

<data id="INTERVALS_INTERVAL_DIVINING_UTE_JUNCTIONS_C_1" comment="INTERVALS_INTERVAL_DIVINING_UTE_JUNCTIONS_C_1" schema="UTE" table="INTERVALS_INTERVAL_DIVINING_UTE_JUNCTIONS_C">
	<update>
		<dbCommand>
		<var name="CONSTRUCTION_ELEMENT_QUERY"/>
		<var name="ROUTE_ID"/>	
		<var name="config.main.PODS_USER"/>		
			<query>
	DO $$
            
                DECLARE
                i RECORD;
                 v_station_id_begin NUMERIC;
                 v_station_id_end NUMERIC;
                 v_station_measure_begin NUMERIC;
                 v_station_measure_end NUMERIC;
                BEGIN
                 FOR i IN (WITH structural_elements
                 AS (SELECT er.station_id_begin station_id,spb.measure 
                 FROM pods.event_range er
                 JOIN pods.station_point spb
                 ON spb.station_id = er.station_id_begin 
                 JOIN pods.series s
                 ON s.series_id = spb.series_id
                 WHERE er.event_id in ({CONSTRUCTION_ELEMENT_QUERY})
                 AND s.route_id = {ROUTE_ID}
                 UNION ALL 
                 SELECT DISTINCT FIRST_VALUE(spx.station_id) OVER (PARTITION BY er.event_id ORDER BY ABS(spx.measure - (spb.measure + (spe.measure - spb.measure)/2 ))) station_id
                 ,FIRST_VALUE(spx.measure) OVER (PARTITION BY er.event_id ORDER BY ABS(spx.measure - (spb.measure + (spe.measure - spb.measure)/2 ))) measure
                 FROM pods.event_range er
                 JOIN pods.station_point spb
                 ON spb.station_id = er.station_id_begin 
                 JOIN pods.series s
                 ON s.series_id = spb.series_id
                 JOIN pods.station_point spe
                 ON spe.station_id = er.station_id_end
                 JOIN pods.station_point spX
                 ON s.series_id = spX.series_id
                 AND spX.measure BETWEEN spb.measure AND spe.measure 
                 WHERE er.event_id in ({CONSTRUCTION_ELEMENT_QUERY})
                 AND s.route_id = {ROUTE_ID}
                 AND er.station_id_begin != er.station_id_end),
                 limits_station
                AS (
	SELECT MIN(measure)  first_measure
                 ,MAX(measure)  last_measure
                 ,(select station_id from pods.station_point ss where ss.route_id= {ROUTE_ID}  and ss.measure=(select min(measure) from pods.station_point sss where sss.route_id= {ROUTE_ID}) limit 1) first_station_id
                ,(select station_id from pods.station_point ss where ss.route_id= {ROUTE_ID}  and ss.measure=(select max(measure) from pods.station_point sss where sss.route_id= {ROUTE_ID}) limit 1)  last_station_id
                 FROM pods.station_point sp
                 JOIN pods.series s
                 ON s.series_id = sp.series_id
                 WHERE s.route_id = {ROUTE_ID}),
                 combained_junctions
                 AS (SELECT first_station_id station_id,first_measure measure
                 FROM limits_station ls1
                 WHERE NOT EXISTS (SELECT 1 FROM structural_elements se WHERE ls1.first_measure = se.measure)
                 UNION ALL
                 SELECT station_id,measure 
                 FROM structural_elements 
                 UNION ALL
                 SELECT last_station_id station_id,last_measure
                 FROM limits_station ls2
                 WHERE NOT EXISTS (SELECT 1 FROM structural_elements se WHERE ls2.last_measure = se.measure))
                 SELECT station_id,measure
                 FROM combained_junctions
                 ORDER BY measure)
                 LOOP
                 v_station_id_end := i.station_id;
                 v_station_measure_end := i.measure;
     
                 IF v_station_id_end IS NOT NULL
                 AND v_station_id_begin IS NOT NULL
                 THEN 
                 INSERT INTO pods.event_range(feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf,positioning_type_cl,length) 
                 VALUES ('INTERVAL_PER_OBJ',v_station_id_begin,v_station_id_end,'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN',ABS(v_station_measure_end-v_station_measure_begin));
                 END IF;
                 v_station_id_begin := v_station_id_end;
                 v_station_measure_begin := v_station_measure_end;
     
                 END LOOP; 
                END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="INTERVALS_INTERVAL_DIVINING_UTE_JUNCTIONS_C_2" comment="INTERVALS_INTERVAL_DIVINING_UTE_JUNCTIONS_C_2" schema="UTE" table="INTERVALS_INTERVAL_DIVINING_UTE_JUNCTIONS_C">
	<update>
		<dbCommand>
		<var name="ROUTE_ID"/>			
			<query>
			
			UPDATE pods.event_range er
	 			SET CURRENT_INDICATOR_LF = 'N'
	 			WHERE er.feature_id = 'INTERVAL_PER_OBJ'
	 			AND EXISTS (SELECT 1
	 			FROM pods.station_point sp
	 			JOIN pods.series s
	 			ON sp.series_id = s.series_id
	 			WHERE s.route_id = {ROUTE_ID}
	 			AND sp.station_id in (er.station_id_begin,er.station_id_end))

			</query>
		</dbCommand>
	</update>
</data>

<data id="INTERVALS_INTERVAL_DIVINING_UTE_REGULAR_C_1" comment="INTERVALS_INTERVAL_DIVINING_UTE_REGULAR_C_1" schema="UTE" table="INTERVALS_INTERVAL_DIVINING_UTE_REGULAR_C">
	<update>
		<dbCommand>
		<var name="ROUTE_ID"/>
		<var name="REGULAR_INTERVALS_DISTANCE"/>
		<var name="config.main.PODS_USER"/>		
			<query>
	DO $$
                 
                 DECLARE
                 i RECORD;
                  v_station_id_begin NUMERIC;
                  v_station_id_end NUMERIC;
                  v_location_id NUMERIC;
                  v_srv_district_gcl NUMERIC;
                  v_depth_of_cover NUMERIC;
                  v_X NUMERIC;
                  v_Y NUMERIC;
                  v_Z NUMERIC;
     
                  v_depth_of_cover1 NUMERIC;
                  v_X1 NUMERIC;
                  v_Y1 NUMERIC;
                  v_Z1 NUMERIC;
                  v_measure1 NUMERIC;
		  v_station_id1 NUMERIC;
     
                  v_depth_of_cover2 NUMERIC;
                  v_X2 NUMERIC;
                  v_Y2 NUMERIC;
                  v_Z2 NUMERIC;
                  v_measure2 NUMERIC;
                  v_min_measure NUMERIC;
                  v_max_measure NUMERIC;
		  v_station_id2 NUMERIC;

                 BEGIN

                  SELECT MIN(sp.measure) min_measure
                  ,MAX(sp.measure) max_measure
  		  into v_min_measure,v_max_measure
                  FROM pods.series s
                  JOIN pods.station_point sp 
                  ON sp.series_id = s.series_id
                  WHERE s.route_id = {ROUTE_ID};
      
                  FOR i IN (WITH 
                  row_generator
                  AS (
                  SELECT v_min_measure+(series.a-1) * {REGULAR_INTERVALS_DISTANCE} measure FROM generate_series 
                   (1, ((SELECT MAX(sp.measure) - MIN(sp.measure)
                  FROM pods.series s
                  JOIN pods.station_point sp 
                  ON sp.series_id = s.series_id
                  WHERE s.route_id = {ROUTE_ID}))/{REGULAR_INTERVALS_DISTANCE} + 1) as series(a)),
                  base_sp
                  AS (SELECT measure
                  ,station_id
                  ,LEAD(measure) OVER(ORDER BY measure) n_measure
                  ,LEAD(station_id) OVER (ORDER BY measure) n_station_id 
                  FROM pods.station_point sp
                  JOIN pods.series s
                  ON s.series_id = sp.series_id
                  WHERE s.route_id = {ROUTE_ID}
                  AND type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03'))
                  (SELECT sp1.line_id, sp1.route_id, sp1.series_id, sp1.series, sp1.station, s.measure
                  FROM row_generator s
                  JOIN base_sp sp 
                  ON s.measure&gt;=sp.measure 
                  AND s.measure&lt;sp.n_measure
                  JOIN PODS.STATION_POINT sp1 
                  ON sp1.station_id = sp.station_id
                  JOIN pods.coordinate c1 
                  ON c1.location_id = sp1.location_id
                  JOIN PODS.STATION_POINT sp2 
                  ON sp2.station_id = sp.n_station_id
                  JOIN pods.coordinate c2 
                  ON c2.location_id = sp2.location_id
                  UNION ALL
                  SELECT s.line_id, s.route_id, s.series_id, sp.series, MAX(sp.station) station, MAX(sp.measure) measure
                  FROM pods.series s
                  JOIN pods.station_point sp
                  ON sp.series_id = s.series_id
                  WHERE s.route_id = {ROUTE_ID}
                  GROUP BY s.line_id, s.route_id, s.series_id, sp.series)
                  ORDER BY MEASURE)
                  LOOP
      
                  v_station_id_begin := v_station_id_end;
      
   			/* необходимо интерполировать значения с соседних пикетов*/
      
                 SELECT l.srv_district_gcl
 			,l.depth_of_cover
 			,c.x_coord
 			,c.y_coord
 			,c.z_coord
 			,sp.measure
			,sp.station_id
 			INTO v_srv_district_gcl
 			,v_depth_of_cover1 
 			,v_X1 
 			,v_Y1 
 			,v_Z1 
 			,v_measure1
			,v_station_id1			 
 			FROM pods.station_point sp
 			JOIN pods.location l
 			ON l.location_id = sp.location_id
 			JOIN pods.coordinate c 
 			ON c.location_id = sp.location_id 
 			WHERE sp.route_id={ROUTE_ID}
                         and sp.measure = (SELECT max(sp2.measure) 
                        FROM pods.station_point sp2
                        WHERE sp2.route_id={ROUTE_ID}
                        AND sp2.measure &lt;=i.measure)
                        limit 1;
 
 			SELECT l.depth_of_cover
 			,c.x_coord
 			,c.y_coord
 			,c.z_coord
 			,sp.measure
			,sp.station_id
 			INTO v_depth_of_cover2 
 			,v_X2 
 			,v_Y2 
 			,v_Z2 
 			,v_measure2 
			,v_station_id2
 			FROM pods.station_point sp
 			JOIN pods.location l
 			ON l.location_id = sp.location_id
 			JOIN pods.coordinate c 
 			ON c.location_id = sp.location_id 
 			WHERE sp.route_id={ROUTE_ID}
                         and sp.measure = (SELECT min(sp2.measure) 
                        FROM pods.station_point sp2
                        WHERE sp2.route_id={ROUTE_ID}
                        AND sp2.measure &gt;=i.measure)
                        limit 1; 
      
                  IF abs(v_measure2 - v_measure1)>{REGULAR_INTERVALS_DISTANCE}*0.1
                  THEN 
                  v_depth_of_cover := v_depth_of_cover1+(i.measure-v_measure1)*(v_depth_of_cover2-v_depth_of_cover1)/(v_measure2-v_measure1);
                  v_X := v_X1+(i.measure-v_measure1)*(v_X2-v_X1)/(v_measure2-v_measure1); 
                  v_Y := v_Y1+(i.measure-v_measure1)*(v_Y2-v_Y1)/(v_measure2-v_measure1); 
                  v_Z := v_Z1+(i.measure-v_measure1)*(v_Z2-v_Z1)/(v_measure2-v_measure1);
                  INSERT INTO pods.location (srv_district_gcl,depth_of_cover) VALUES (v_srv_district_gcl,v_depth_of_cover)
                  RETURNING location_id INTO v_location_id;
      
                  INSERT INTO pods.station_point (line_id,route_id,series_id,series,location_id,station,measure,type_cl)
                  VALUES (i.line_id,i.route_id,i.series_id,i.series,v_location_id,i.station,i.measure,'ST_POINT_TYPE_04')
                  RETURNING station_id INTO v_station_id_end; 
      
                  INSERT INTO pods.coordinate(coordinate_source_id, location_id, x_coord, y_coord, z_coord
                  ,type_cl, horiz_indicator_lf, vert_indicator_lf, current_indicator_lf
                  ,effective_from_date, accuracy_cl, create_date, pods_user)
                  VALUES (9,v_location_id,v_X,v_Y,v_Z,'ASG','Y', 'Y', 'Y',current_timestamp, 'MEDIUM', current_timestamp, '{config.main.PODS_USER}');
                  ELSE
                  v_station_id_end:=v_station_id1;
                  END IF; 
      
 
     
     
 		 /* Если первый проход то пропускаем итерацию цикла */
                  IF v_station_id_begin IS NOT NULL
                  THEN
                  INSERT INTO pods.event_range(feature_id,station_id_begin,station_id_end,pods_user,create_date,effective_from_date,current_indicator_lf,positioning_type_cl,length) 
                  VALUES ('INTERVAL_REGULAR',v_station_id_begin,v_station_id_end,'{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN',{REGULAR_INTERVALS_DISTANCE});
     
                  END IF;
      
                  END LOOP; 
                 END $$;
			</query>
		</dbCommand>
	</update>
</data> 

<data id="INTERVALS_INTERVAL_DIVINING_UTE_REGULAR_C_2" comment="INTERVALS_INTERVAL_DIVINING_UTE_REGULAR_C_2" schema="UTE" table="INTERVALS_INTERVAL_DIVINING_UTE_REGULAR_C">
	<update>
		<dbCommand>
		<var name="ROUTE_ID"/>
		<var name="REGULAR_INTERVALS_DISTANCE"/>
			<query>
			UPDATE pods.event_range er
 			SET CURRENT_INDICATOR_LF = 'N'
 			WHERE er.feature_id = 'INTERVAL_REGULAR'
 			AND length = {REGULAR_INTERVALS_DISTANCE}
 			AND EXISTS (SELECT 1
 			FROM pods.station_point sp
 			JOIN pods.series s
 			ON sp.series_id = s.series_id
 			WHERE s.route_id = {ROUTE_ID}
 			AND sp.station_id in (er.station_id_begin,er.station_id_end))
			</query>
		</dbCommand>
	</update>
</data> 

<data id="LINE_LINE_EVENT_IDX_C_1" comment="LINE_LINE_EVENT_IDX_C_1" schema="UTE" table="LINE_LINE_EVENT_IDX_C">
	<select>
		<dbQuery>	
		<var name="EVENT_ID"/>		
			<query>
			SELECT sp.STATION_ID "STATION_ID", e.EVENT_ID "EVENT_ID", c.X_COORD "X", c.Y_COORD "Y"
 			FROM pods.event_range e 
 			JOIN pods.station_point sp on sp.station_id IN (e.station_id_begin, e.station_id_end)
 			JOIN pods.coordinate c ON c.location_id = sp.location_id
 			WHERE event_id in ({EVENT_ID})
 			AND (sp.type_cl = 'ST_POINT_TYPE_05' OR sp.series_id = 0)
			</query>
		</dbQuery>
	</select>
</data> 

<data id="LINE_LINE_EVENT_IDX_C_2" comment="LINE_LINE_EVENT_IDX_C_2" schema="UTE" table="LINE_LINE_EVENT_IDX_C">
	<insert>
		<dbCommand>
		<var name="MEASURE_START" type="Decimal"/>	
		<var name="STATION_START" type="Decimal"/>		
		<var name="SERIES_ID_START" type="Decimal"/>	
		<var name="ROUTE_ID_START" type="Decimal"/>	
		<var name="LINE_ID_START" type="Decimal"/>	
		<var name="STATION_ID" type="Decimal"/>		
		<var name="DISTANCE" type="Decimal"/>	
		<var name="EVENT_ID" type="Decimal"/>		
			<query>
			DO $$
			
			BEGIN
 			IF {MEASURE_START} IS NOT NULL THEN
 			UPDATE pods.station_point 
 			SET MEASURE = {MEASURE_START}, STATION = {STATION_START}, SERIES_ID = {SERIES_ID_START}, TYPE_CL = 'ST_POINT_TYPE_05',
 			ROUTE_ID = {ROUTE_ID_START}, LINE_ID = {LINE_ID_START}
 			WHERE station_id = {STATION_ID};
 
 			UPDATE pods.event_range 
 			SET validity_tolerance = {DISTANCE}
 			WHERE event_id = {EVENT_ID};
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="LINE_LINE_EVENT_IDX_C_3" comment="LINE_LINE_EVENT_IDX_C_3" schema="UTE" table="LINE_LINE_EVENT_IDX_C">
	<select>
		<dbQuery>	
		<var name="xpath_expr.ROUTE_ID"/>
		<var name="xpath_expr.START_SP"/>		
		<var name="xpath_expr.END_SP"/>		
			<query>
			SELECT sp.ROUTE_ID "ID",r.LINE_ID "LINE_ID",sp.ROUTE_ID "ROUTE_ID",sp.SERIES "SERIES",sp.SERIES_ID "SERIES_ID",sp.STATION "STATION",sp.MEASURE "MEASURE",sp.MEASURE "N_MEASURE",
 			c.X_COORD "X",c.Y_COORD "Y",c.Z_COORD "Z",sp.STATION_ID "STATION_ID", l.SRV_DISTRICT_GCL "SRV_DISTRICT_GCL", l.DEPTH_OF_COVER "DEPTH_OF_COVER", r.SEQUENCE "SEQUENCE"
 			FROM pods.route r
 			JOIN pods.station_point spb ON spb.route_id = r.route_id
 			JOIN pods.station_point spe ON spe.route_id = r.route_id
 			JOIN pods.station_point sp ON sp.route_id = r.route_id AND sp.measure BETWEEN spb.measure AND spe.measure
 			JOIN pods.coordinate c ON c.location_id= sp.location_id
 			JOIN pods.location l ON l.location_id = sp.location_id
 			WHERE r.route_id = {xpath_expr.ROUTE_ID} 
 			AND spb.station_id = {xpath_expr.START_SP}
 			AND spe.station_id = {xpath_expr.END_SP}
 			ORDER BY r.sequence, sp.measure
			</query>
		</dbQuery>
	</select>
</data>

<data id="LINE_LINE_ROUTE_IDX_C_1" comment="LINE_LINE_ROUTE_IDX_C_1" schema="UTE" table="LINE_LINE_ROUTE_IDX_C">
	<select>
		<dbQuery>	
		<var name="ROUTE_ID"/>		
			<query>
			SELECT r.LINE_ID "LINE_ID", r.ROUTE_ID "ROUTE_ID", s.SERIES_ID "SERIES_ID", r.DESCRIPTION "DESCRIPTION", r.TYPE_CL "TYPE_CL", MIN(s.station_begin) "KM_START", MAX(s.station_end) "KM_END"
 			FROM pods.route r
 			JOIN pods.series s ON s.route_id = r.route_id
			WHERE r.route_id IN ({ROUTE_ID})
			GROUP BY r.line_id, r.route_id, s.series_id, r.description, r.type_cl
			ORDER BY "KM_START", "KM_END"
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="LINE_LINE_ROUTE_IDX_C_2" comment="LINE_LINE_ROUTE_IDX_C_2" schema="UTE" table="LINE_LINE_ROUTE_IDX_C">
	<select>
		<dbQuery>	
		<var name="call_method.RES_FEATURE_ID"/>		
			<query>
			select e.EVENT_ID "EVENT_ID", sp.STATION_ID "STATION_ID", sp.SERIES_ID "AXE_ID", CASE WHEN sp.series_id = 0 THEN NULL ELSE e.VALIDITY_TOLERANCE END "VALIDITY_TOLERANCE", c.X_COORD "X", c.Y_COORD "Y"
			from pods.event_range e 
			join pods.station_point sp on sp.station_id = e.station_id_begin
			join pods.coordinate c ON c.location_id = sp.location_id
			where sp.station_id!=0 AND (sp.type_cl = 'ST_POINT_TYPE_05' OR sp.series_id = 0) AND e.feature_id IN ('{call_method.RES_FEATURE_ID}')
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="LINE_LINE_ROUTE_IDX_C_3" comment="LINE_LINE_ROUTE_IDX_C_3" schema="UTE" table="LINE_LINE_ROUTE_IDX_C">
	<insert>
		<dbCommand>
		<var name="LINE_COORD_START" type="Decimal"/>	
		<var name="KM_START" type="Decimal"/>		
		<var name="AXE_ID" type="Decimal"/>
		<var name="STATION_ID" type="Decimal"/>		
		<var name="DISTANCE" type="Decimal"/>	
		<var name="EVENT_ID" type="Decimal"/>		
			<query>
			DO $$
			
			BEGIN
 			IF {LINE_COORD_START} IS NOT NULL THEN
 			UPDATE pods.station_point 
 			SET MEASURE = {LINE_COORD_START}, STATION = {KM_START}, SERIES_ID = {AXE_ID}, TYPE_CL = 'ST_POINT_TYPE_05',
 			ROUTE_ID = (SELECT ROUTE_ID FROM PODS.SERIES s WHERE s.SERIES_ID = {AXE_ID}),
 			LINE_ID = (SELECT LINE_ID FROM PODS.SERIES s WHERE s.SERIES_ID = {AXE_ID})
 			WHERE station_id = {STATION_ID};
 
 			UPDATE pods.event_range 
 			SET validity_tolerance = {DISTANCE}
 			WHERE event_id = {EVENT_ID};
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="LINE_LINE_ROUTE_IDX_C_4" comment="LINE_LINE_ROUTE_IDX_C_4" schema="UTE" table="LINE_LINE_ROUTE_IDX_C">
	<select>
		<dbQuery>	
		<var name="xpath_view.SEL_ROUTE.SERIES_ID"/>		
			<query>
			SELECT sp.ROUTE_ID "ROUTE_ID",sp.LINE_ID "LINE_ID",sp.SERIES_ID "SERIES_ID",sp.STATION "STATION",sp.MEASURE "MEASURE",
 			c.X_COORD "X_COORD",c.Y_COORD "Y_COORD",sp.STATION_ID "STATION_ID"
 			FROM pods.station_point sp
 			JOIN pods.coordinate c ON c.location_id= sp.location_id
 			WHERE sp.series_id = {xpath_view.SEL_ROUTE.SERIES_ID} AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03')
 			ORDER BY sp.measure
			</query>
		</dbQuery>
	</select>
</data> 

<data id="LINE_LINE_ROUTE_IDX_C_ALL_1" comment="LINE_LINE_ROUTE_IDX_C_ALL_1" schema="UTE" table="LINE_LINE_ROUTE_IDX_C_ALL">
	<select>
		<dbQuery>	
		<var name="ROUTE_ID"/>		
			<query>
			SELECT r.LINE_ID "LINE_ID", r.ROUTE_ID "ROUTE_ID", s.SERIES_ID "SERIES_ID", r.DESCRIPTION "DESCRIPTION", r.TYPE_CL "TYPE_CL", MIN(s.station_begin) "KM_START", MAX(s.station_end) "KM_END"
			 FROM pods.route r
 			JOIN pods.series s ON s.route_id = r.route_id
			WHERE r.route_id IN ({ROUTE_ID})
			GROUP BY r.line_id, r.route_id, s.series_id, r.description, r.type_cl
			ORDER BY "KM_START","KM_END"
			</query>
		</dbQuery>
	</select>
</data>

<data id="LINE_LINE_ROUTE_IDX_C_ALL_2" comment="LINE_LINE_ROUTE_IDX_C_ALL_2" schema="UTE" table="LINE_LINE_ROUTE_IDX_C_ALL">
	<select>
		<dbQuery>	
		<var name="call_method.RES_FEATURE_ID"/>		
			<query>
			select e.EVENT_ID "EVENT_ID", sp.STATION_ID "STATION_ID", sp.SERIES_ID "AXE_ID", CASE WHEN sp.series_id = 0 THEN NULL ELSE e.VALIDITY_TOLERANCE END "VALIDITY_TOLERANCE", c.X_COORD "X", c.Y_COORD "Y"
			from pods.event_range e 
			join pods.station_point sp on sp.station_id = e.station_id_begin
			join pods.coordinate c ON c.location_id = sp.location_id
			where sp.station_id!=0 AND (sp.type_cl = 'ST_POINT_TYPE_05' OR sp.series_id = 0) AND e.feature_id IN ('{call_method.RES_FEATURE_ID}')
			</query>
		</dbQuery>
	</select>
</data>

<data id="LINE_LINE_ROUTE_IDX_C_ALL_3" comment="LINE_LINE_ROUTE_IDX_C_ALL_3" schema="UTE" table="LINE_LINE_ROUTE_IDX_C_ALL">
	<insert>
		<dbCommand>
		<var name="LINE_COORD_START" type="Decimal"/>	
		<var name="KM_START" type="Decimal"/>		
		<var name="AXE_ID" type="Decimal"/>
		<var name="STATION_ID" type="Decimal"/>		
		<var name="DISTANCE" type="Decimal"/>	
		<var name="EVENT_ID" type="Decimal"/>		
			<query>
			DO $$
			
			BEGIN
 			IF {LINE_COORD_START} IS NOT NULL THEN
 			UPDATE pods.station_point 
 			SET MEASURE = {LINE_COORD_START}, STATION = {KM_START}, SERIES_ID = {AXE_ID}, TYPE_CL = 'ST_POINT_TYPE_05',
 			ROUTE_ID = (SELECT ROUTE_ID FROM PODS.SERIES s WHERE s.SERIES_ID = {AXE_ID}),
 			LINE_ID = (SELECT LINE_ID FROM PODS.SERIES s WHERE s.SERIES_ID = {AXE_ID})
 			WHERE station_id = {STATION_ID};
 
 			UPDATE pods.event_range 
 			SET validity_tolerance = {DISTANCE}
 			WHERE event_id = {EVENT_ID};
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>

<data id="LINE_LINE_ROUTE_IDX_C_ALL_4" comment="LINE_LINE_ROUTE_IDX_C_ALL_4" schema="UTE" table="LINE_LINE_ROUTE_IDX_C_ALL">
	<select>
		<dbQuery>	
		<var name="xpath_view.SEL_ROUTE.SERIES_ID"/>		
			<query>
			SELECT sp.ROUTE_ID "ROUTE_ID",sp.LINE_ID "LINE_ID",sp.SERIES_ID "SERIES_ID",sp.STATION "STATION",sp.MEASURE "MEASURE",
 			c.X_COORD "X_COORD",c.Y_COORD "Y_COORD",sp.STATION_ID "STATION_ID"
 			FROM pods.station_point sp
 			JOIN pods.coordinate c ON c.location_id= sp.location_id
 			WHERE sp.series_id = {xpath_view.SEL_ROUTE.SERIES_ID} AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03')
 			ORDER BY sp.measure 
			</query>
		</dbQuery>
	</select>
</data> 

<data id="OFFLINE_OFFLINE_LINE_IDX_C_1" comment="OFFLINE_OFFLINE_LINE_IDX_C_1" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C">
	<select>
		<dbQuery>	
		<var name="LINE_ID"/>		
			<query>
			SELECT l.LINE_ID "LINE_ID", l.DESCRIPTION "DESCRIPTION", l.TYPE_CL "TYPE_CL" FROM pods.line l WHERE l.LINE_ID IN ({LINE_ID})
			</query>
		</dbQuery>
	</select>
</data>

<data id="OFFLINE_OFFLINE_LINE_IDX_C_2" comment="OFFLINE_OFFLINE_LINE_IDX_C_2" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C">
	<update>
		<dbCommand>
		<var name="xpath_view.SEL_LINE.LINE_ID"/>
		<var name="call_method.RES_FEATURE_ID"/>
			<query>
			DO $$
			
			BEGIN
 			UPDATE pods.event_range SET CURRENT_INDICATOR_LF = 'N'
 			WHERE event_id IN
 			(SELECT c.event_id
 			FROM pods.offline_cross_ref c
 			JOIN pods.event_range e ON e.event_id = c.event_id
 			JOIN pods.offline_event oe ON oe.offline_id = c.offline_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin AND sp.line_id = {xpath_view.SEL_LINE.LINE_ID}
 			WHERE oe.feature_id IN ('{call_method.RES_FEATURE_ID}')
 			AND e.feature_id = 'OFF_CRSS_REF');

 			delete from pods.offline_cross_ref c 
 			WHERE event_id IN
 			(SELECT c.event_id
 			FROM pods.offline_cross_ref c
 			JOIN pods.event_range e ON e.event_id = c.event_id
 			JOIN pods.offline_event oe ON oe.offline_id = c.offline_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin AND sp.line_id = {xpath_view.SEL_LINE.LINE_ID}
 			WHERE oe.feature_id IN ('{call_method.RES_FEATURE_ID}')
 			AND e.feature_id = 'OFF_CRSS_REF');
			
			END $$;
			</query>
		</dbCommand>
	</update>
</data> 

<data id="OFFLINE_OFFLINE_LINE_IDX_C_3" comment="OFFLINE_OFFLINE_LINE_IDX_C_3" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C">
	<select>
		<dbQuery>	
		<var name="call_method.RES_FEATURE_ID"/>		
			<query>
			select e.OFFLINE_ID "ID", p.PART_ID "P_ID", c.X_COORD "X", c.Y_COORD "Y"
 			from pods.OFFLINE_EVENT e
 			JOIN pods.PART p on p.SHAPE_ID = e.SHAPE_ID
 			join pods.VERTEX v on v.PART_ID = p.PART_ID
 			join pods.COORDINATE c on c.LOCATION_ID = v.LOCATION_ID
 			where e.feature_id IN ('{call_method.RES_FEATURE_ID}')
 			order by e.OFFLINE_ID, p.HOLE_FL, p.PART_ID, v.SEQUENCE_NO
			</query>
		</dbQuery>
	</select>
</data>

<data id="OFFLINE_OFFLINE_LINE_IDX_C_4" comment="OFFLINE_OFFLINE_LINE_IDX_C_4" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C">
	<insert>
		<dbCommand>
		<var name="LINK_RADIUS"/>
		<var name="config.main.PODS_USER"/>
		<var name="OFFLINE_EVENT_TYPE_CL"/>		
		<var name="MEASURE_START" type="Decimal"/>	
		<var name="N_MEASURE_START" type="Decimal"/>		
		<var name="STATION_ID_START" type="Decimal"/>
		<var name="SRV_DISTRICT_GCL_START" type="Decimal"/>		
		<var name="DEPTH_OF_COVER_START" type="Decimal"/>	
		<var name="X_START" type="Decimal"/>
		<var name="Y_START" type="Decimal"/>	
		<var name="Z_START" type="Decimal"/>		
		<var name="LINE_ID_START" type="Decimal"/>
		<var name="SERIES_START" type="Decimal"/>		
		<var name="STATION_START" type="Decimal"/>	
		<var name="SERIES_ID_START" type="Decimal"/>	
		<var name="ROUTE_ID_START" type="Decimal"/>		
		<var name="N_MEASURE_END" type="Decimal"/>
		<var name="MEASURE_END" type="Decimal"/>		
		<var name="STATION_ID_END" type="Decimal"/>	
		<var name="SRV_DISTRICT_GCL_END" type="Decimal"/>
		<var name="DEPTH_OF_COVER_END" type="Decimal"/>	
		<var name="X_END" type="Decimal"/>		
		<var name="Y_END" type="Decimal"/>
		<var name="Z_END" type="Decimal"/>		
		<var name="LINE_ID_END" type="Decimal"/>	
		<var name="SERIES_END" type="Decimal"/>	
		<var name="STATION_END" type="Decimal"/>		
		<var name="SERIES_ID_END" type="Decimal"/>
		<var name="ROUTE_ID_END" type="Decimal"/>		
		<var name="ID" type="Decimal"/>	
		<var name="DISTANCE" type="Decimal"/>		
			<query>
			DO $$

			DECLARE
 			loc_id_start numeric;
 			loc_id_end numeric;
 			sp_id_start numeric;
 			sp_id_end numeric;
 			e_id numeric;
 			BEGIN
 			IF {MEASURE_START} IS NOT NULL THEN
 			IF ABS({N_MEASURE_START}-{MEASURE_START})&lt;{LINK_RADIUS} THEN
 			sp_id_start := {STATION_ID_START};
 			ELSE
 			INSERT INTO pods.location(SRV_DISTRICT_GCL, DEPTH_OF_COVER)
 			VALUES({SRV_DISTRICT_GCL_START}, {DEPTH_OF_COVER_START})
 			RETURNING LOCATION_ID INTO loc_id_start;

 			INSERT INTO pods.coordinate
 			(coordinate_source_id, type_cl, location_id, x_coord, y_coord, z_coord, horiz_indicator_lf, vert_indicator_lf,current_indicator_lf, effective_from_date, create_date, pods_user, accuracy_cl, validity_tolerance )
 			VALUES (9, 'ASG', loc_id_start, round({X_START},6), round({Y_START},6), round({Z_START},2), 'Y', (CASE WHEN {Z_START} is not null THEN 'Y' ELSE 'N' END), 'Y', current_timestamp, current_timestamp, '{config.main.PODS_USER}', 'MEDIUM', 0 );

 			INSERT INTO pods.station_point
			 				 (type_cl, location_id, line_id, series, station, series_id, route_id, measure, create_date, pods_user )
 			 			VALUES ('ST_POINT_TYPE_05', loc_id_start, {LINE_ID_START}, {SERIES_START}, {STATION_START}, {SERIES_ID_START}, {ROUTE_ID_START}, {MEASURE_START}, current_timestamp, '{config.main.PODS_USER}' )
 			RETURNING STATION_ID INTO sp_id_start;
 			END IF;
 
 			IF ABS({N_MEASURE_END}-{MEASURE_END})&lt;{LINK_RADIUS} THEN
 			sp_id_end := {STATION_ID_END};
 			ELSE
 			INSERT INTO pods.location(SRV_DISTRICT_GCL, DEPTH_OF_COVER)
 			VALUES({SRV_DISTRICT_GCL_END}, {DEPTH_OF_COVER_END})
 			RETURNING LOCATION_ID INTO loc_id_end;

 			INSERT INTO pods.coordinate
 			(coordinate_source_id, type_cl, location_id, x_coord, y_coord, z_coord, horiz_indicator_lf, vert_indicator_lf,current_indicator_lf, effective_from_date, create_date, pods_user, accuracy_cl, validity_tolerance )
 			VALUES (9, 'ASG', loc_id_end, round({X_END},6), round({Y_END},6), round({Z_END},2), 'Y', (CASE WHEN {Z_START} is not null THEN 'Y' ELSE 'N' END), 'Y', current_timestamp, current_timestamp, '{config.main.PODS_USER}', 'MEDIUM', 0 );

 			INSERT INTO pods.station_point
 				 			(type_cl, location_id, line_id, series, station, series_id, route_id, measure, create_date, pods_user )
 			 			VALUES ('ST_POINT_TYPE_05', loc_id_end, {LINE_ID_END}, {SERIES_END}, {STATION_END}, {SERIES_ID_END}, {ROUTE_ID_END}, {MEASURE_END}, current_timestamp, '{config.main.PODS_USER}' )
 			RETURNING STATION_ID INTO sp_id_end;
 			END IF;

 			INSERT INTO PODS.EVENT_RANGE (FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL)
 			VALUES('OFF_CRSS_REF',sp_id_start,sp_id_end,'{config.main.PODS_USER}',current_timestamp,current_timestamp, 'Y','UNKNOWN')
 			RETURNING event_id INTO e_id;
 
 			INSERT INTO PODS.OFFLINE_CROSS_REF(EVENT_ID, OFFLINE_ID, "OFFSET", TYPE_CL, DESCRIPTION, DIRECTION_GCL, SOURCE_GCL)
 			VALUES (e_id, {ID}, {DISTANCE}, '{OFFLINE_EVENT_TYPE_CL}','{OFFLINE_EVENT_TYPE_CL}', 'UNKNOWN', 'NGG');
 			END IF;
 			END $$; 
			</query>
		</dbCommand>
	</insert>
</data>

<data id="OFFLINE_OFFLINE_LINE_IDX_C_5" comment="OFFLINE_OFFLINE_LINE_IDX_C_5" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C">
	<select>
		<dbQuery>	
		<var name="xpath_view.SEL_LINE.TYPE_CL"/>
		<var name="xpath_view.SEL_LINE.LINE_ID"/>
			<query>
			SELECT sp.ROUTE_ID "ID",ln.LINE_ID "LINE_ID",sp.ROUTE_ID "ROUTE_ID",sp.SERIES "SERIES",sp.SERIES_ID "SERIES_ID",sp.STATION "STATION",sp.MEASURE "MEASURE",sp.MEASURE "N_MEASURE",
 			c.X_COORD "X",c.Y_COORD "Y",c.Z_COORD "Z",sp.STATION_ID "STATION_ID", l.SRV_DISTRICT_GCL "SRV_DISTRICT_GCL", l.DEPTH_OF_COVER "DEPTH_OF_COVER", coalesce(r."sequence",1::numeric) "SEQUENCE"
 			FROM pods.line ln
 			JOIN pods.route r ON r.line_id = ln.line_id AND r.type_cl = case ln.type_cl when 'LINE_TYPE_04' then 'ROUTE_TYPE_04' 
             when 'LINE_TYPE_01' then 'ROUTE_TYPE_10'
             when 'LINE_TYPE_03' then 'ROUTE_TYPE_11'
             when 'LINE_TYPE_02' then 'ROUTE_TYPE_12'
             end
 			JOIN pods.station_point sp ON sp.route_id = r.route_id
 			JOIN pods.coordinate c ON c.location_id= sp.location_id
 			JOIN pods.location l ON l.location_id = sp.location_id
 			WHERE ln.line_id = {xpath_view.SEL_LINE.LINE_ID} /*AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03')*/
 			ORDER BY r."sequence", sp.measure 
			</query>
		</dbQuery>
	</select>
</data> 

<data id="OFFLINE_OFFLINE_LINE_IDX_C_ALL_1" comment="OFFLINE_OFFLINE_LINE_IDX_C_ALL_1" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C">
	<select>
		<dbQuery>	
		<var name="LINE_ID"/>
			<query>
			SELECT r.ROUTE_ID "LINE_ID"
 			,r.DESCRIPTION "DESCRIPTION"
 			FROM pods.route r 
 			WHERE r.ROUTE_ID IN ({LINE_ID})
 			AND r.type_cl IN ('ROUTE_TYPE_04','ROUTE_TYPE_10','ROUTE_TYPE_12') 
			</query>
		</dbQuery>
	</select>
</data> 
 
<data id="OFFLINE_OFFLINE_LINE_IDX_C_ALL_2" comment="OFFLINE_OFFLINE_LINE_IDX_C_ALL_2" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C_ALL">
	<update>
		<dbCommand>
		<var name="xpath_view.SEL_ROUTE.LINE_ID"/>
		<var name="call_method.RES_FEATURE_ID"/>
			<query>
			DO $$
			
			BEGIN
 			UPDATE pods.event_range SET CURRENT_INDICATOR_LF = 'N'
 			WHERE event_id IN
 			(SELECT c.event_id
 			FROM pods.offline_cross_ref c
 			JOIN pods.event_range e ON e.event_id = c.event_id
 			JOIN pods.offline_event oe ON oe.offline_id = c.offline_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin AND sp.route_id = {xpath_view.SEL_ROUTE.LINE_ID}
 			WHERE oe.feature_id IN ('{call_method.RES_FEATURE_ID}')
 			AND e.feature_id = 'OFF_CRSS_REF');

 			delete from pods.offline_cross_ref
 			WHERE event_id IN
 			(SELECT c.event_id
 			FROM pods.offline_cross_ref c
 			JOIN pods.event_range e ON e.event_id = c.event_id
 			JOIN pods.offline_event oe ON oe.offline_id = c.offline_id
 			JOIN pods.station_point sp ON sp.station_id = e.station_id_begin AND sp.route_id = {xpath_view.SEL_ROUTE.LINE_ID}
 			WHERE oe.feature_id IN ('{call_method.RES_FEATURE_ID}')
 			AND e.feature_id = 'OFF_CRSS_REF');
 			END $$;
			</query>
		</dbCommand>
	</update>
</data> 

<data id="OFFLINE_OFFLINE_LINE_IDX_C_ALL_3" comment="OFFLINE_OFFLINE_LINE_IDX_C_ALL_3" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C_ALL">
	<select>
		<dbQuery>	
		<var name="call_method.RES_FEATURE_ID"/>		
			<query>
			select e.OFFLINE_ID "ID", p.PART_ID "P_ID", c.X_COORD "X", c.Y_COORD "Y"
 			from pods.OFFLINE_EVENT e
 			JOIN pods.PART p on p.SHAPE_ID = e.SHAPE_ID
 			join pods.VERTEX v on v.PART_ID = p.PART_ID
 			join pods.COORDINATE c on c.LOCATION_ID = v.LOCATION_ID
 			where e.feature_id IN ('{call_method.RES_FEATURE_ID}')
 			order by e.OFFLINE_ID, p.HOLE_FL, p.PART_ID, v.SEQUENCE_NO
			</query>
		</dbQuery>
	</select>
</data> 

<data id="OFFLINE_OFFLINE_LINE_IDX_C_ALL_4" comment="OFFLINE_OFFLINE_LINE_IDX_C_ALL_4" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C_ALL">
	<insert>
		<dbCommand>
		<var name="LINK_RADIUS"/>
		<var name="config.main.PODS_USER"/>
		<var name="OFFLINE_EVENT_TYPE_CL"/>		
		<var name="MEASURE_START" type="Decimal"/>	
		<var name="N_MEASURE_START" type="Decimal"/>		
		<var name="STATION_ID_START" type="Decimal"/>
		<var name="SRV_DISTRICT_GCL_START" type="Decimal"/>		
		<var name="DEPTH_OF_COVER_START" type="Decimal"/>	
		<var name="X_START" type="Decimal"/>
		<var name="Y_START" type="Decimal"/>	
		<var name="Z_START" type="Decimal"/>		
		<var name="LINE_ID_START" type="Decimal"/>
		<var name="SERIES_START" type="Decimal"/>		
		<var name="STATION_START" type="Decimal"/>	
		<var name="SERIES_ID_START" type="Decimal"/>	
		<var name="ROUTE_ID_START" type="Decimal"/>	
		<var name="N_MEASURE_END" type="Decimal"/>
		<var name="MEASURE_END" type="Decimal"/>		
		<var name="STATION_ID_END" type="Decimal"/>	
		<var name="SRV_DISTRICT_GCL_END" type="Decimal"/>
		<var name="DEPTH_OF_COVER_END" type="Decimal"/>	
		<var name="X_END" type="Decimal"/>		
		<var name="Y_END" type="Decimal"/>
		<var name="Z_END" type="Decimal"/>		
		<var name="LINE_ID_END" type="Decimal"/>	
		<var name="SERIES_END" type="Decimal"/>	
		<var name="STATION_END" type="Decimal"/>		
		<var name="SERIES_ID_END" type="Decimal"/>
		<var name="ROUTE_ID_END" type="Decimal"/>		
		<var name="ID" type="Decimal"/>	
		<var name="DISTANCE" type="Decimal"/>		
			<query>
			DO $$
			
			DECLARE
 			loc_id_start NUMERIC;
 			loc_id_end NUMERIC;
 			sp_id_start NUMERIC;
 			sp_id_end NUMERIC;
 			e_id NUMERIC;
 			BEGIN
 			IF {MEASURE_START} IS NOT NULL THEN
 			IF ABS({N_MEASURE_START}-{MEASURE_START})&lt;{LINK_RADIUS} THEN
 			sp_id_start := {STATION_ID_START};
 			ELSE
 			INSERT INTO pods.location(SRV_DISTRICT_GCL, DEPTH_OF_COVER)
 			VALUES({SRV_DISTRICT_GCL_START}, {DEPTH_OF_COVER_START})
 			RETURNING LOCATION_ID INTO loc_id_start;

 			INSERT INTO pods.coordinate
 			(coordinate_source_id, type_cl, location_id, x_coord, y_coord, z_coord, horiz_indicator_lf, vert_indicator_lf,current_indicator_lf, effective_from_date, create_date, pods_user, accuracy_cl, validity_tolerance )
 			VALUES (9, 'ASG', loc_id_start, round({X_START},6), round({Y_START},6), round({Z_START},2), 'Y', coalesce2({Z_START},'Y','N'), 'Y', current_timestamp, current_timestamp, '{config.main.PODS_USER}', 'MEDIUM', 0 );

 			INSERT INTO pods.station_point
 				 			(type_cl, location_id, line_id, series, station, series_id, route_id, measure, create_date, pods_user )
 			 			VALUES ('ST_POINT_TYPE_05', loc_id_start, (select line_id from pods.route where route_id={LINE_ID_START}), {SERIES_START}, {STATION_START}, {SERIES_ID_START}, {ROUTE_ID_START}, {MEASURE_START}, current_timestamp, '{config.main.PODS_USER}' )
 			RETURNING STATION_ID INTO sp_id_start;
 			END IF;
 
 			IF ABS({N_MEASURE_END}-{MEASURE_END})&lt;{LINK_RADIUS} THEN
 			sp_id_end := {STATION_ID_END};
 			ELSE
 			INSERT INTO pods.location(SRV_DISTRICT_GCL, DEPTH_OF_COVER)
 			VALUES({SRV_DISTRICT_GCL_END}, {DEPTH_OF_COVER_END})
 			RETURNING LOCATION_ID INTO loc_id_end;

 			INSERT INTO pods.coordinate
 			(coordinate_source_id, type_cl, location_id, x_coord, y_coord, z_coord, horiz_indicator_lf, vert_indicator_lf,current_indicator_lf, effective_from_date, create_date, pods_user, accuracy_cl, validity_tolerance )
 			VALUES (9, 'ASG', loc_id_end, round({X_END},6), round({Y_END},6), round({Z_END},2), 'Y', coalesce2({Z_END},'Y','N'), 'Y', current_timestamp, current_timestamp, '{config.main.PODS_USER}', 'MEDIUM', 0 );

 			INSERT INTO pods.station_point
 				 			(type_cl, location_id, line_id, series, station, series_id, route_id, measure, create_date, pods_user )
 			 			VALUES ('ST_POINT_TYPE_05', loc_id_end, (select line_id from pods.route where route_id={LINE_ID_END}), {SERIES_END}, {STATION_END}, {SERIES_ID_END}, {ROUTE_ID_END}, {MEASURE_END}, current_timestamp, '{config.main.PODS_USER}' )
 			RETURNING STATION_ID INTO sp_id_end;
 			END IF;

			 INSERT INTO PODS.EVENT_RANGE (FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL)
 			VALUES('OFF_CRSS_REF',sp_id_start,sp_id_end,'{config.main.PODS_USER}',current_timestamp,current_timestamp, 'Y','UNKNOWN')
 			RETURNING event_id INTO e_id;
 
 			INSERT INTO PODS.OFFLINE_CROSS_REF(EVENT_ID, OFFLINE_ID, "OFFSET", TYPE_CL, DESCRIPTION, DIRECTION_GCL, SOURCE_GCL)
 			VALUES (e_id, {ID}, {DISTANCE}, '{OFFLINE_EVENT_TYPE_CL}','{OFFLINE_EVENT_TYPE_CL}', 'UNKNOWN', 'NGG');
 			END IF;
 			END $$; 
			</query>
		</dbCommand>
	</insert>
</data>

<data id="OFFLINE_OFFLINE_LINE_IDX_C_ALL_5" comment="OFFLINE_OFFLINE_LINE_IDX_C_ALL_5" schema="UTE" table="OFFLINE_OFFLINE_LINE_IDX_C_ALL">
	<select>
		<dbQuery>	
		<var name="xpath_view.SEL_ROUTE.LINE_ID"/>
			<query>
			SELECT sp.ROUTE_ID "ID",/*r.LINE_ID*/ r.ROUTE_ID "LINE_ID",r.ROUTE_ID "ROUTE_ID",sp.SERIES "SERIES",sp.SERIES_ID "SERIES_ID",sp.STATION "STATION",sp.MEASURE "MEASURE",sp.MEASURE "N_MEASURE",
 			c.X_COORD "X",c.Y_COORD "Y",c.Z_COORD "Z",sp.STATION_ID "STATION_ID", l.SRV_DISTRICT_GCL "SRV_DISTRICT_GCL", l.DEPTH_OF_COVER "DEPTH_OF_COVER", r.SEQUENCE "SEQUENCE"
 			FROM pods.route r 
 			JOIN pods.station_point sp 
 			ON sp.route_id = r.route_id
 			JOIN pods.coordinate c 
 			ON c.location_id= sp.location_id
 			JOIN pods.location l 
 			ON l.location_id = sp.location_id
 			WHERE r.route_id = {xpath_view.SEL_ROUTE.LINE_ID} 
 			ORDER BY r.sequence, sp.measure 
			</query>
		</dbQuery>
	</select>
</data>

<data id="OFFLINE_OFFLINE_OFFLINE_IDX_C_1" comment="OFFLINE_OFFLINE_OFFLINE_IDX_C_1" schema="UTE" table="OFFLINE_OFFLINE_OFFLINE_IDX_C">
	<update>
		<dbCommand>
		<var name="OFFLINE_ID"/>
			<query>
			DO $$
			
			BEGIN
 			UPDATE pods.event_range SET CURRENT_INDICATOR_LF = 'N'
 			WHERE event_id IN
 			(SELECT c.event_id
 			FROM pods.offline_cross_ref c
 			WHERE c.offline_id IN ({OFFLINE_ID}));

 			DELETE FROM pods.offline_cross_ref
 			WHERE offline_id IN ({OFFLINE_ID});
 			END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="OFFLINE_OFFLINE_OFFLINE_IDX_C_2" comment="OFFLINE_OFFLINE_OFFLINE_IDX_C_2" schema="UTE" table="OFFLINE_OFFLINE_OFFLINE_IDX_C">
	<select>
		<dbQuery>	
		<var name="OFFLINE_ID"/>
			<query>
			select e.OFFLINE_ID "ID", p.PART_ID "P_ID", c.X_COORD "X", c.Y_COORD "Y"
 			from pods.OFFLINE_EVENT e
 			JOIN pods.PART p on p.SHAPE_ID = e.SHAPE_ID
 			join pods.VERTEX v on v.PART_ID = p.PART_ID
 			join pods.COORDINATE c on c.LOCATION_ID = v.LOCATION_ID
 			where e.OFFLINE_ID IN ({OFFLINE_ID})
 			order by e.OFFLINE_ID, p.HOLE_FL, p.PART_ID, v.SEQUENCE_NO 
			</query>
		</dbQuery>
	</select>
</data> 
 
<data id="OFFLINE_OFFLINE_OFFLINE_IDX_C_3" comment="OFFLINE_OFFLINE_OFFLINE_IDX_C_3" schema="UTE" table="OFFLINE_OFFLINE_OFFLINE_IDX_C">
	<insert>
		<dbCommand>
		<var name="LINK_RADIUS"/>
		<var name="config.main.PODS_USER"/>
		<var name="OFFLINE_EVENT_TYPE"/>		
		<var name="MEASURE_START" type="Decimal"/>	
		<var name="N_MEASURE_START" type="Decimal"/>		
		<var name="STATION_ID_START" type="Decimal"/>
		<var name="SRV_DISTRICT_GCL_START" type="Decimal"/>		
		<var name="DEPTH_OF_COVER_START" type="Decimal"/>	
		<var name="X_START" type="Decimal"/>
		<var name="Y_START" type="Decimal"/>	
		<var name="Z_START" type="Decimal"/>		
		<var name="LINE_ID_START" type="Decimal"/>
		<var name="SERIES_START" type="Decimal"/>		
		<var name="STATION_START" type="Decimal"/>	
		<var name="SERIES_ID_START" type="Decimal"/>	
		<var name="ROUTE_ID_START" type="Decimal"/>	
		<var name="N_MEASURE_END" type="Decimal"/>
		<var name="MEASURE_END" type="Decimal"/>		
		<var name="STATION_ID_END" type="Decimal"/>	
		<var name="SRV_DISTRICT_GCL_END" type="Decimal"/>
		<var name="DEPTH_OF_COVER_END" type="Decimal"/>	
		<var name="X_END" type="Decimal"/>		
		<var name="Y_END" type="Decimal"/>
		<var name="Z_END" type="Decimal"/>		
		<var name="LINE_ID_END" type="Decimal"/>	
		<var name="SERIES_END" type="Decimal"/>	
		<var name="STATION_END" type="Decimal"/>		
		<var name="SERIES_ID_END" type="Decimal"/>
		<var name="ROUTE_ID_END" type="Decimal"/>		
		<var name="ID" type="Decimal"/>	
		<var name="DISTANCE" type="Decimal"/>		
			<query>
			DO $$
			
			DECLARE
 			loc_id_start NUMERIC(16,0);
 			loc_id_end NUMERIC(16,0);
 			sp_id_start NUMERIC(16,0);
 			sp_id_end NUMERIC(16,0);
 			e_id NUMERIC(16,0);
 			BEGIN
 			IF {MEASURE_START} IS NOT NULL THEN
 			IF ABS({N_MEASURE_START}-{MEASURE_START})&lt;{LINK_RADIUS} THEN
 			sp_id_start := {STATION_ID_START};
 			ELSE
 			INSERT INTO pods.location(SRV_DISTRICT_GCL, DEPTH_OF_COVER)
 			VALUES({SRV_DISTRICT_GCL_START}, {DEPTH_OF_COVER_START})
 			RETURNING LOCATION_ID INTO loc_id_start;

 			INSERT INTO pods.coordinate
 			(coordinate_source_id, type_cl, location_id, x_coord, y_coord, z_coord, horiz_indicator_lf, vert_indicator_lf,current_indicator_lf, effective_from_date, create_date, pods_user, accuracy_cl, validity_tolerance )
 			VALUES (9, 'ASG', loc_id_start, round({X_START},6), round({Y_START},6), round({Z_START},2), 'Y', CASE WHEN {Z_START} IS NOT NULL THEN 'Y' ELSE 'N' END, 'Y', current_timestamp, current_timestamp, '{config.main.PODS_USER}', 'MEDIUM', 0 );

 			INSERT INTO pods.station_point
 				 			(type_cl, location_id, line_id, series, station, series_id, route_id, measure, create_date, pods_user )
 			 			VALUES ('ST_POINT_TYPE_05', loc_id_start, {LINE_ID_START}, {SERIES_START}, {STATION_START}, {SERIES_ID_START}, {ROUTE_ID_START}, {MEASURE_START}, current_timestamp, '{config.main.PODS_USER}' )
 			RETURNING STATION_ID INTO sp_id_start;
 			END IF;
 
 			IF ABS({N_MEASURE_END}-{MEASURE_END})&lt;{LINK_RADIUS} THEN
 			sp_id_end := {STATION_ID_END};
 			ELSE
 			INSERT INTO pods.location(SRV_DISTRICT_GCL, DEPTH_OF_COVER)
 			VALUES({SRV_DISTRICT_GCL_END}, {DEPTH_OF_COVER_END})
 			RETURNING LOCATION_ID INTO loc_id_end;

 			INSERT INTO pods.coordinate
 			(coordinate_source_id, type_cl, location_id, x_coord, y_coord, z_coord, horiz_indicator_lf, vert_indicator_lf,current_indicator_lf, effective_from_date, create_date, pods_user, accuracy_cl, validity_tolerance )
 			VALUES (9, 'ASG', loc_id_end, round({X_END},6), round({Y_END},6), round({Z_END},2), 'Y', CASE WHEN {Z_END} IS NOT NULL THEN 'Y' ELSE 'N' END, 'Y', current_timestamp, current_timestamp, '{config.main.PODS_USER}', 'MEDIUM', 0 );

 			INSERT INTO pods.station_point
 				 			(type_cl, location_id, line_id, series, station, series_id, route_id, measure, create_date, pods_user )
 			 			VALUES ('ST_POINT_TYPE_05', loc_id_end, {LINE_ID_END}, {SERIES_END}, {STATION_END}, {SERIES_ID_END}, {ROUTE_ID_END}, {MEASURE_END}, current_timestamp, '{config.main.PODS_USER}' )
 			RETURNING STATION_ID INTO sp_id_end;
 			END IF;

 			INSERT INTO PODS.EVENT_RANGE (FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL)
 			VALUES('OFF_CRSS_REF',sp_id_start,sp_id_end,'{config.main.PODS_USER}',current_timestamp,current_timestamp, 'Y','UNKNOWN')
 			RETURNING EVENT_ID INTO e_id;
 
 			INSERT INTO PODS.OFFLINE_CROSS_REF(EVENT_ID, OFFLINE_ID, "OFFSET", TYPE_CL, DIRECTION_GCL, SOURCE_GCL)
 			VALUES (e_id, {ID}, {DISTANCE}, '{OFFLINE_EVENT_TYPE}', 'UNKNOWN', 'NGG');
 			END IF;
 			END $$;
			</query>
		</dbCommand>
	</insert>
</data>
 
<data id="OFFLINE_OFFLINE_OFFLINE_IDX_C_4" comment="OFFLINE_OFFLINE_OFFLINE_IDX_C_4" schema="UTE" table="OFFLINE_OFFLINE_OFFLINE_IDX_C">
	<select>
		<dbQuery>	
		<var name="xpath_expr.ROUTE_ID"/>
		<var name="xpath_expr.START_SP"/>
		<var name="xpath_expr.END_SP"/>
			<query>
			SELECT sp.ROUTE_ID "ID",r.LINE_ID "LINE_ID",sp.ROUTE_ID "ROUTE_ID",sp.SERIES "SERIES",sp.SERIES_ID "SERIES_ID",sp.STATION "STATION",sp.MEASURE "MEASURE",sp.MEASURE "N_MEASURE",
 			c.X_COORD "X",c.Y_COORD "Y",c.Z_COORD "Z",sp.STATION_ID "STATION_ID", l.SRV_DISTRICT_GCL "SRV_DISTRICT_GCL", l.DEPTH_OF_COVER "DEPTH_OF_COVER", r.SEQUENCE "SEQUENCE"
 			FROM pods.route r
 			JOIN pods.station_point spb ON spb.route_id = r.route_id
 			JOIN pods.station_point spe ON spe.route_id = r.route_id
 			JOIN pods.station_point sp ON sp.route_id = r.route_id AND sp.measure BETWEEN spb.measure AND spe.measure
 			JOIN pods.coordinate c ON c.location_id= sp.location_id
 			JOIN pods.location l ON l.location_id = sp.location_id
 			WHERE r.route_id = {xpath_expr.ROUTE_ID} 
 			AND spb.station_id = {xpath_expr.START_SP}
 			AND spe.station_id = {xpath_expr.END_SP}
 			ORDER BY r.sequence, sp.measure 
			</query>
		</dbQuery>
	</select>
</data>

<data id="POI_POI_PNT_IMP_C_1" comment="POI_POI_PNT_IMP_C_1" schema="UTE" table="POI_POI_PNT_IMP_C">
	<insert>
		<dbCommand>
		<var name="USER_ID"/>
		<var name="X" type="Decimal"/>	
		<var name="Y" type="Decimal"/>		
		<var name="Z" type="Decimal"/>
		<var name="COORD_ID" type="Decimal" default="SELECT max(COORD_ID) id FROM WEB50.POI_COORD" />
			<query>
			INSERT INTO WEB50.POI_COORD(COORD_TYPE_ID, X, Y, Z, CUSER_ID, CTIME) 
 			VALUES ('2', {X}, {Y}, {Z}, {USER_ID}, current_timestamp)
			</query>
		</dbCommand>
	</insert>
</data>

<data id="POI_POI_PNT_IMP_C_2" comment="POI_POI_PNT_IMP_C_2" schema="UTE" table="POI_POI_PNT_IMP_C">
	<insert>
		<dbCommand>
		<var name="USER_ID"/>
		<var name="STATUS_ID"/>		
		<var name="COORD_ID" type="Decimal"/>	
		<var name="NAME" type="String"/>		
		<var name="DESCR" type="String"/>
		<var name="TIME" type="DateTime"/>
		<var name="CMT" type="String"/>
		<var name="SYM" type="String"/>		
			<query>
				INSERT INTO WEB50.POI_POINT(COORD_ID, NAME, DESCR, TIME_STAMP, COMMENTS, SYMBOL, CUSER_ID, STATUS_ID, CTIME)
				VALUES({COORD_ID}, '{NAME}', '{DESCR}', TO_DATE('{TIME}', 'DD.MM.YYYY HH24:MI:SS'), '{CMT}', '{SYM}', {USER_ID}, {STATUS_ID}, current_timestamp)
			</query>
		</dbCommand>
	</insert>
</data>

<data id="POI_POI_TRK_IMP_C_1" comment="POI_POI_TRK_IMP_C_1" schema="UTE" table="POI_POI_TRK_IMP_C">
	<update>
		<dbCommand>
		<var name="xpath_expr.track_name"/>
		<var name="xpath_expr.track_desc"/>
		<var name="USER_ID"/>
		<var name="STATUS_ID"/>	
		<var name="TRACK_ID" type="Decimal" default="SELECT max(TRACK_ID) id FROM web50.poi_track" />		
			<query>
			INSERT INTO web50.poi_track(name, descr, cuser_id, status_id, ctime) 
 			VALUES('{xpath_expr.track_name}', '{xpath_expr.track_desc}', {USER_ID}, {STATUS_ID}, current_timestamp) 
			</query>
		</dbCommand>
	</update>
</data> 

<data id="POI_POI_TRK_IMP_C_2" comment="POI_POI_TRK_IMP_C_2" schema="UTE" table="POI_POI_PNT_IMP_C">
	<insert>
		<dbCommand>
		<var name="USER_ID"/>	
		<var name="X" type="Decimal"/>	
		<var name="Y" type="Decimal"/>		
		<var name="Z" type="Decimal"/>
		<var name="COORD_ID" type="Decimal" default="SELECT max(COORD_ID) id FROM WEB50.POI_COORD" />
			<query>
			INSERT INTO WEB50.POI_COORD(COORD_TYPE_ID, X, Y, Z, CUSER_ID, CTIME) 
 			VALUES ('1', {X}, {Y}, {Z}, {USER_ID}, current_timestamp) 
			</query>
		</dbCommand>
	</insert>
 </data> 

<data id="POI_POI_TRK_IMP_C_3" comment="POI_POI_TRK_IMP_C_3" schema="UTE" table="POI_POI_PNT_IMP_C">
	<insert>
		<dbCommand>
		<var name="db_command.CMD.TRACK_ID"/>
		<var name="USER_ID"/>		
		<var name="COORD_ID" type="Decimal"/>	
		<var name="COORD_SEQ" type="Decimal"/>		
		<var name="TIME" type="DateTime"/>
			<query>
				INSERT INTO WEB50.POI_TRACK_TO_POI_COORD(TRACK_ID, COORD_ID, COORD_SEQ, TIME_STAMP, CUSER_ID, CTIME)
				VALUES({db_command.CMD.TRACK_ID}, {COORD_ID}, {COORD_SEQ}, TO_TIMESTAMP('{TIME}', 'DD.MM.YYYY HH24:MI:SS'), {USER_ID}, current_timestamp)
			</query>
		</dbCommand>
	</insert>
</data> 

<data id="PS_PS_LAY_IDX_C_1" comment="PS_PS_LAY_IDX_C_1" schema="UTE" table="PS_PS_LAY_IDX_C">
	<update>
		<dbCommand>
		<var name="xpath_iterator.CUR_OBJ.@ID"/>
		<var name="xpath.CUR_PS.@s_fract"/>
		<var name="xpath.CUR_PS.@ss_id"/>
		<var name="xpath.CUR_PS.@se_id"/>	
		<var name="xpath.CUR_PS.@e_fract"/>
		<var name="xpath.CUR_PS.@es_id"/>
		<var name="xpath.CUR_PS.@ee_id"/>
		<var name="xpath.CUR_PS.@id"/>
		<var name="xpath.CUR_PS.@dist"/>	
			<query>
			DO $$
			
			DECLARE
 			km_start NUMERIC(10,2);
 			km_end NUMERIC(10,2);
 			lc_start NUMERIC(10,2);
 			lc_end NUMERIC(10,2);
 			BEGIN
 			DELETE FROM WEB50.PS_INDEX_OBJ WHERE KEY_VALUES = '{xpath_iterator.CUR_OBJ.@ID}';
 
 			SELECT sp1.measure+{xpath.CUR_PS.@s_fract}*(sp2.measure-sp1.measure)
 			,sp1.station+{xpath.CUR_PS.@s_fract}*(sp2.station-sp1.station)
 			INTO lc_start,km_start
 			FROM pods.station_point sp1, pods.station_point sp2
 			WHERE sp1.station_id = {xpath.CUR_PS.@ss_id} AND sp2.station_id = {xpath.CUR_PS.@se_id};
 
			 SELECT sp1.measure+{xpath.CUR_PS.@e_fract}*(sp2.measure-sp1.measure)
 			,sp1.station+{xpath.CUR_PS.@e_fract}*(sp2.station-sp1.station)
 			INTO lc_end,km_end
 			FROM pods.station_point sp1, pods.station_point sp2
 			WHERE sp1.station_id = {xpath.CUR_PS.@es_id} AND sp2.station_id = {xpath.CUR_PS.@ee_id};

 			INSERT INTO WEB50.PS_INDEX_OBJ(TEMPLATE_ID, PIPE_SYSTEM_ID, STATE_ID, KEY_FIELDS, KEY_VALUES, KM_START, KM_END, LINE_COORD_START, LINE_COORD_END, DISTANCE, GID, CUSER_ID) 
 			VALUES(1, {xpath.CUR_PS.@id}, 0, '', '{xpath_iterator.CUR_OBJ.@ID}', km_start, km_end, lc_start, lc_end, {xpath.CUR_PS.@dist}, NULL, 0);
 			END $$;
			</query>
		</dbCommand>
	</update>
</data> 

<data id="PS_PS_TEMPLATE_IDX_C_1" comment="PS_PS_TEMPLATE_IDX_C_1" schema="UTE" table="PS_PS_TEMPLATE_IDX_C">
	<select>
		<dbQuery>	
		<var name="PIPE_SYSTEM_ID"/>
			<query> 
			SELECT PIPE_SYSTEM_ID "PIPE_SYSTEM_ID", DESCRIPTION "DESCRIPTION"
 			FROM pods.pipe_system_cl
 			WHERE pipe_system_id != 0
 			AND pipe_system_id IN ({PIPE_SYSTEM_ID})
 			ORDER BY description 
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_TEMPLATE_IDX_C_2" comment="PS_PS_TEMPLATE_IDX_C_2" schema="UTE" table="PS_PS_TEMPLATE_IDX_C">
	<select>
		<dbQuery>	
		<var name="TEMPLATE_ID"/>
			<query>
			SELECT TEMPLATE_ID "TEMPLATE_ID", DESCRIPTION "DESCRIPTION", SCHEMA "SCH", OBJECT_NAME "OBJECT_NAME", WHERE_CLAUSE "WHERE_CLAUSE", GID_FIELD "GID_FIELD", BUFFER_WIDTH "BUFFER_WIDTH", QUERY "QUERY"
 			FROM web50.ps_index_obj_template
 			where template_id IN ({TEMPLATE_ID})
 			ORDER BY DESCRIPTION DESC 
			</query>
		</dbQuery>
	</select>
</data>

<data id="TAB_TAB_BLOB_IMP_C_1" comment="TAB_TAB_BLOB_IMP_C_1" schema="UTE" table="TAB_TAB_BLOB_IMP_C">
	<select>
		<dbQuery>	
		<var name="TABLE_NAME"/>
		<var name="FILE_NAME_FIELD"/>
		<var name="xpath_expr.file_name"/>		
			<query>
			SELECT COUNT(*) "COUNT" FROM {TABLE_NAME} WHERE UPPER({FILE_NAME_FIELD}) = UPPER('{xpath_expr.file_name}')
			</query>
		</dbQuery>
	</select>
</data>

<data id="TAB_TAB_BLOB_IMP_C_2" comment="TAB_TAB_BLOB_IMP_C_2" schema="UTE" table="TAB_TAB_BLOB_IMP_C">
	<update>
		<dbCommand>
		<var name="TABLE_NAME"/>
		<var name="BLOB_FIELD"/>
		<var name="FILE_NAME_FIELD"/>
		<var name="xpath_expr.file_name"/>	
		<var name="BODY" type="String"/>		
			<query>
			UPDATE {TABLE_NAME} SET {BLOB_FIELD} = '{BODY}' WHERE UPPER({FILE_NAME_FIELD}) = UPPER('{xpath_expr.file_name}')
			</query>
		</dbCommand>
	</update>
</data>

<data id="HODO_INSP_PROC_1" comment="HODO_INSP_PROC_1" schema="UTE" table="HODO_INSP_PROC">
	<select>
		<dbQuery>	
		<var name="P_REPORT_ID"/>		
			<query>
			SELECT coalesce(MIN(spb.route_id),-1) "MINR"
 			FROM pods.ili_inspection_range ir
 			JOIN pods.event_range er ON er.event_id = ir.event_id
 			JOIN pods.station_point spb ON er.station_id_begin = spb.station_id
 			WHERE ir.ili_inspection_id = {P_REPORT_ID}
			</query>
		</dbQuery>
	</select>
</data>

<data id="HODO_INSP_PROC_ALL_1" comment="HODO_INSP_PROC_ALL_1" schema="UTE" table="HODO_INSP_PROC_ALL">
	<select>
		<dbQuery>		
			<query>
			SELECT ir.ILI_INSPECTION_ID "ILI_INSPECTION_ID",coalesce(MIN(spb.route_id),-1) "ROUTE_ID"
 			FROM pods.ili_inspection_range ir
 			JOIN pods.event_range er 
 			ON er.event_id = ir.event_id
 			JOIN pods.station_point spb 
 			ON er.station_id_begin = spb.station_id
 			WHERE ir.event_id > 0 
 			GROUP BY ir.ILI_INSPECTION_ID,ER.CREATE_DATE 
 			ORDER BY ROUTE_ID,ER.CREATE_DATE DESC
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_CLUSTER_1" comment="ILI_CLUSTER_1" schema="UTE" table="ILI_CLUSTER">
	<select>
		<dbQuery>	
		<var name="INSPECTION_ID"/>		
			<query>
			SELECT spb.ROUTE_ID "ROUTE_ID"
 			FROM pods.ili_inspection_range i
 			JOIN pods.event_range er ON er.event_id = i.event_id
 			JOIN pods.station_point spb ON er.station_id_begin = spb.station_id WHERE ILI_INSPECTION_ID = {INSPECTION_ID}
			</query>
		</dbQuery>
	</select>
</data> 

<data id="ILI_CLUSTER_2" comment="ILI_CLUSTER_2" schema="UTE" table="ILI_CLUSTER">
	<select>
		<dbQuery>	
		<var name="INSPECTION_ID"/>		
			<query>
			SELECT ps.nominal_diameter_gcl "NOMINAL_DIAMETER_GCL"
 			FROM pods.ili_inspection_range ir
 			JOIN pods.event_range err
 			ON ir.event_id = err.event_id
 			JOIN pods.station_point spbr
 			ON err.station_id_begin = spbr.station_id
 			JOIN pods.station_point spbps
 			ON spbps.series_id = spbr.series_id
 			JOIN pods.event_range erPS
 			ON erps.station_id_Begin = spbps.station_id 
 			JOIN pods.pipe_segment PS 
 			ON PS.event_id = erPS.event_id
 			WHERE err.feature_id = 'ILI_INSP_RNG'
 			AND err.CURRENT_INDICATOR_LF = 'Y'
 			AND erPS.feature_id = 'PIPE_SEGMENT'
 			AND erPS.CURRENT_INDICATOR_LF = 'Y'
 			AND ir.ili_inspection_id = {INSPECTION_ID}
			AND ps.nominal_diameter_gcl>0
			</query>
		</dbQuery>
	</select>
</data>

<data id="CALC_CALC_HIERARCHY_1" comment="CALC_CALC_HIERARCHY_1" schema="UTE" table="CALC_CALC_HIERARCHY">
	<update>
		<dbCommand>
		<var name="text.HIERARCHY_SCRIPT"/>	
			<query>
			{text.HIERARCHY_SCRIPT}
			</query>
		</dbCommand>
	</update>
</data>

<data id="CALC_FILL_NETWORK_1" comment="CALC_FILL_NETWORK_1" schema="UTE" table="CALC_FILL_NETWORK">
	<update>
		<dbCommand>
		<var name="text.HIERARCHY_SCRIPT"/>	
			<query>
			{text.NETWORK_SCRIPT}
			</query>
		</dbCommand>
	</update>
</data>

<data id="CP_CP_BAT_PROC_C_1" comment="CP_CP_BAT_PROC_C_1" schema="UTE" table="CP_CP_BAT_PROC_C">
	<select>
		<dbQuery>
			<query>
			select DISTINCT i.event_id "REPORT_ID"
 			from pods.pi_cp_inspection i
 			join pods.event_range e on e.event_id = i.event_id
 			join pods.comments c ON c.id::integer = i.event_id AND 
 			c.table_id = 'PI_CP_INSPECTION' AND 
 			c.comment_by = 'IS_DIRTY' AND 
 			c.comments = '1'
			</query>
		</dbQuery>
	</select>
</data>

<data id="CP_CP_BAT_PROC_C_ALL_1" comment="CP_CP_BAT_PROC_C_ALL_1" schema="UTE" table="CP_CP_BAT_PROC_C_ALL">
	<select>
		<dbQuery>
			<query>
			select DISTINCT i.event_id "REPORT_ID"
 			from pods.pi_cp_inspection i
 			join pods.event_range e on e.event_id = i.event_id
 			WHERE i.event_id > 0
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_BAT_STO_EHZ_INSP_PROC_C_ALL_1" comment="ILI_BAT_STO_EHZ_INSP_PROC_C_ALL_1" schema="UTE" table="ILI_BAT_STO_EHZ_INSP_PROC_C_ALL">
	<select>
		<dbQuery>
			<query>
SELECT DISTINCT i.ILI_INSPECTION_ID "ILI_INSPECTION_ID"
 			FROM pods.ili_inspection i 
 			JOIN pods.ili_inspection_range r on r.ili_inspection_id = i.ili_inspection_id
 			JOIN pods.event_range e on r.event_id = e.event_id
 			JOIN pods.station_point sp on sp.station_id = e.station_id_begin  where not exists (select 1 from pods.sto_ehz_calc c where c.ili_inspection_id=i.ili_inspection_id) and i.ili_inspection_id in 
(select g.key_values::numeric ILI_INSPECTION_ID from gis_integration50.gate g where g.owner='CALC' and g.table_name like 'STO_EHZ_INSP_Proc.xml')
 			ORDER BY i.ILI_INSPECTION_ID
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_ILI_BAT_PRESSURE_C_1" comment="ILI_ILI_BAT_PRESSURE_C_1" schema="UTE" table="ILI_ILI_BAT_PRESSURE_C">
	<select>
		<dbQuery>
			<query>
SELECT DISTINCT i.ILI_INSPECTION_ID "ILI_INSPECTION_ID"
            FROM pods.ili_inspection i where not exists (select 1 from pods.sto_ili_data_calc c where c.ili_inspection_id=i.ili_inspection_id) 
and i.ili_inspection_id in (select g.key_values::numeric ILI_INSPECTION_ID from gis_integration50.gate g where g.owner='CALC' and g.table_name like 'ILI_Pressure.xml')
 order by i.ili_inspection_id 
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_ILI_BAT_PROC_C_1" comment="ILI_ILI_BAT_PROC_C_1" schema="UTE" table="ILI_ILI_BAT_PROC_C">
	<select>
		<dbQuery>
			<query>
				SELECT DISTINCT i.ILI_INSPECTION_ID "ILI_INSPECTION_ID", sp.ROUTE_ID "ROUTE_ID"
				FROM pods.ili_inspection i
				JOIN pods.ili_inspection_range r on r.ili_inspection_id = i.ili_inspection_id
				JOIN pods.event_range e on r.event_id = e.event_id
				JOIN pods.station_point sp on sp.station_id = e.station_id_begin
				WHERE not exists (select 1 from pods.sto_ili_inspection_calc c where c.ili_inspection_id = i.ili_inspection_id) and to_char(i.begin_date,'YYYY')::integer&gt;=2018 order by i.ili_inspection_id
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_ILI_BAT_STO_INSP_PROC_C_ALL_1" comment="ILI_ILI_BAT_STO_INSP_PROC_C_ALL_1" schema="UTE" table="ILI_ILI_BAT_STO_INSP_PROC_C_ALL">
	<select>
		<dbQuery>
			<query>
				SELECT DISTINCT i.ILI_INSPECTION_ID "ILI_INSPECTION_ID", sp.ROUTE_ID "ROUTE_ID"
				FROM pods.ili_inspection i
				JOIN pods.ili_inspection_range r on r.ili_inspection_id = i.ili_inspection_id
				JOIN pods.event_range e on r.event_id = e.event_id
				JOIN pods.station_point sp on sp.station_id = e.station_id_begin
				WHERE not exists (select 1 from pods.sto_ili_inspection_calc c where c.ili_inspection_id = i.ili_inspection_id) and i.ili_inspection_id in 
(select g.key_values::numeric ILI_INSPECTION_ID from gis_integration50.gate g where g.owner='CALC' and g.table_name like 'STO_ILI_INSP_Proc.xml') 
order by i.ili_inspection_id
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_ILI_INSP_PROC_C_1" comment="ILI_ILI_INSP_PROC_C_1" schema="UTE" table="ILI_ILI_INSP_PROC_C">
	<select>
		<dbQuery>
		<var name="INSPECTION_ID"/>			
			<query>
			SELECT spb.ROUTE_ID "ROUTE_ID"
 			FROM pods.ili_inspection_range i
 			JOIN pods.event_range er ON er.event_id = i.event_id
 			JOIN pods.station_point spb ON er.station_id_begin = spb.station_id WHERE ILI_INSPECTION_ID = {INSPECTION_ID}
			</query>
		</dbQuery>
	</select>
</data>
<data id="ILI_ILI_ZIP_IMP_C_55_0" comment="ILI_ILI_ZIP_IMP_C_55_0" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<select>
		<dbQuery>
			<var name="db_command.CMD.ILI_INSPECTION_ID"/>
			<query>
				SELECT spb.ROUTE_ID "ROUTE_ID"
				FROM pods.ili_inspection_range i
				JOIN pods.event_range er ON er.event_id = i.event_id
				JOIN pods.station_point spb ON er.station_id_begin = spb.station_id WHERE ILI_INSPECTION_ID = {db_command.CMD.ILI_INSPECTION_ID}
			</query>
		</dbQuery>
	</select>
</data>
<data id="ILI_ILI_ZIP_IMP_C_55_1" comment="ILI_ILI_ZIP_IMP_C_55_1" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<update>
		<dbCommand>
		<var name="db_command.CMD.ILI_INSPECTION_ID"/>	
			<query>
			UPDATE pods.ili_data dst
 			SET anomaly_extension_cl = coalesce((SELECT a.code
 			FROM pods.anomaly_extension_cl a
 			JOIN pods.ili_anomaly_type_cl b
 			ON a.code = b.index_description
 			WHERE b.code = dst.anomaly_type_cl),'UNKNOWN')
 			WHERE dst.EVENT_ID IS NULL
 			AND dst.ili_inspection_id = {db_command.CMD.ILI_INSPECTION_ID}
			</query>
		</dbCommand>
	</update>
</data>

<data id="ILI_ILI_ZIP_IMP_C_55_2" comment="ILI_ILI_ZIP_IMP_C_55_2" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<update>
		<dbCommand>
		<var name="db_command.CMD.ILI_INSPECTION_ID"/>	
			<query>

			</query>
		</dbCommand>
	</update>
</data>

<data id="ILI_ILI_ZIP_IMP_C_55_3" comment="ILI_ILI_ZIP_IMP_C_55_3" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<update>
		<dbCommand>
		<var name="db_command.CMD.ILI_INSPECTION_ID"/>	
			<query>
		
			</query>
		</dbCommand>
	</update>
</data>

<data id="ILI_ILI_ZIP_IMP_C_55_4" comment="ILI_ILI_ZIP_IMP_C_55_4" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<update>
		<dbCommand>
		<var name="db_command.CMD.ILI_INSPECTION_ID"/>	
			<query>
				DO $$ 
				BEGIN
                 update pods.ili_data set weld_number=null where weld_number like ''  and ili_inspection_id = {db_command.CMD.ILI_INSPECTION_ID};
                
                update pods.ili_data d set 
                us_weld_distance=d.absolute_odometer-d.us_weld_odometer
                ,ds_weld_distance=d.ds_weld_odometer -  d.absolute_odometer
                where EXISTS (select 1 from pods.ili_data ddd
                 JOIN pods.ili_data ww 
                 ON ww.ili_inspection_id = ddd.ili_inspection_id
                 AND ddd.absolute_odometer&gt;=ww.absolute_odometer 
                             AND ww.absolute_odometer&gt;=ddd.absolute_odometer-100
                 WHERE ww.ili_inspection_id = {db_command.CMD.ILI_INSPECTION_ID}
                 AND ww.anomaly_type_cl = 5001
                 AND ddd.ili_data_id = d.ili_data_id);
                 
                 END $$;
			</query>
		</dbCommand>
	</update>
</data>
	<data id="ILI_ILI_ZIP_IMP_C_55_4_2" comment="ILI_ILI_ZIP_IMP_C_55_4" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
		<update>
			<dbCommand>
				<var name="db_command_err.CMD.ILI_INSPECTION_ID"/>
				<query>
					DO $$
					BEGIN

					update pods.ili_data set weld_number=null where weld_number like '' and ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID};
					

					update pods.ili_data d set
					us_weld_distance=d.absolute_odometer-d.us_weld_odometer
					,ds_weld_distance=d.ds_weld_odometer - d.us_weld_odometer + d.absolute_odometer - d.us_weld_odometer
					where EXISTS (select 1 from pods.ili_data ddd
					JOIN pods.ili_data ww
					ON ww.ili_inspection_id = ddd.ili_inspection_id
					AND ddd.absolute_odometer&gt;=ww.absolute_odometer
					AND ww.absolute_odometer&gt;=ddd.absolute_odometer-100
					WHERE ww.ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID}
					AND ddd.weld_number is null
					AND ww.anomaly_type_cl = 5001
					AND ddd.ili_data_id = d.ili_data_id);


					END $$;
				</query>
			</dbCommand>
		</update>
	</data>

<data id="ILI_ILI_ZIP_IMP_C_55_5" comment="ILI_ILI_ZIP_IMP_C_55_5" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<update>
		<dbCommand>
		<var name="db_command.CMD.ILI_INSPECTION_ID"/>	
			<query>
			insert into pods.ili_pipe_length(ili_inspection_id, weld_number, sequence_number, start_odometer, end_odometer, measured_wall_thickness, nominal_wall_thickness, source_gcl)
			 select ili_inspection_id, weld_number, row_number() over(order by absolute_odometer), 
 			absolute_odometer, lead(absolute_odometer) over(order by absolute_odometer),
 			measured_wall_thickness, nominal_wall_thickness, source_gcl
 			from pods.ili_data d
 			where ili_inspection_id = {db_command.CMD.ILI_INSPECTION_ID} and anomaly_type_cl = 5001
			</query>
		</dbCommand>
	</update>
</data>
	<data id="ILI_ILI_ZIP_IMP_C_55_5_2" comment="ILI_ILI_ZIP_IMP_C_55_5" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
		<update>
			<dbCommand>
				<var name="db_command_err.CMD.ILI_INSPECTION_ID"/>
				<query>
					insert into pods.ili_pipe_length(ili_inspection_id, weld_number, sequence_number, start_odometer, end_odometer, measured_wall_thickness, nominal_wall_thickness, source_gcl)
					select ili_inspection_id, weld_number, row_number() over(order by absolute_odometer),
					absolute_odometer, lead(absolute_odometer) over(order by absolute_odometer),
					measured_wall_thickness, nominal_wall_thickness, source_gcl
					from pods.ili_data d
					where ili_inspection_id = {db_command_err.CMD.ILI_INSPECTION_ID} and anomaly_type_cl = 5001
				</query>
			</dbCommand>
		</update>
	</data>


	<data id="ILI_ILI_ZIP_IMP_C_55_6" comment="ILI_ILI_ZIP_IMP_C_55_6" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<select>
		<dbQuery>
		<var name="PIPE"/>		
		<var name="KM_START"/>	
		<var name="KM_END"/>		
			<query>
			SELECT coalesce(MIN(route_id),0) "ROUTE_ID"
 			FROM 
 			(SELECT s.route_id, min(s.station_begin) min_km, max(s.station_end) max_km
 			FROM pods.line l
 			JOIN pods.series s 
 			ON s.line_id = l.line_id
 			WHERE UPPER(REGEXP_REPLACE(REPLACE(REPLACE(REPLACE(l.description,'III','3'),'II','2'),'I','1'),'\s|-|\(|\)','')) 
 			LIKE TRIM(UPPER(REGEXP_REPLACE(REPLACE(REPLACE(REPLACE('{PIPE}','III','3'),'II','2'),'I','1'),'\s|-|\(|\)','')))
 			GROUP BY s.route_id) dd 
 			WHERE ABS(min_km-{KM_START})&lt;15 
 			AND ABS(max_km-{KM_END})&lt;15
			</query>
		</dbQuery>
	</select>
</data>

<data id="ILI_ILI_ZIP_IMP_C_55_7" comment="ILI_ILI_ZIP_IMP_C_55_7" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<update>
		<dbCommand>
		<var name="DATE"/>	
		<var name="MODEL"/>
		<var name="FORMAT"/>
		<var name="COMPANY"/>
		<var name="config.main.PODS_USER"/>
		<var name="KM_START"/>
		<var name="KM_END"/>
		<var name="call_complex_method.FIRST_WELD_NUMBER"/>	
		<var name="ROUTE_ID" type="Decimal"/>		
		<var name="EVENT_ID" type="Decimal" default="select * from (select -50 id where coalesce('','0')='0' 
																	union all
																	select max(e.event_id) id from pods.event_range e where coalesce('','0')&lt;&gt;'0') dd limit 1" />	
		<var name="ILI_INSPECTION_ID" type="Decimal" default="SELECT max(ili_inspection_id) id FROM PODS.ILI_INSPECTION" />			
			<query>
			DO $$
                DECLARE
                RETURNiliid integer;
                RETURNeventid integer;
                v_pipe varchar(50) default 'Объект лежит не на оси трубопровода';
                BEGIN 
                select l.description from pods.line l, pods.route r where r.route_id = {ROUTE_ID} and l.line_id = r.line_id into v_pipe;
                 INSERT INTO PODS.ILI_INSPECTION(BEGIN_DATE, END_DATE, START_ODOMETER, END_ODOMETER, TOOL_TYPE_CL, MODEL, SENSOR_GCL,
                 SENSOR_SPACING_MIN, SENSOR_SPACING_MAX, MIN_TEMP, MAX_TEMP, AVG_TEMP, MIN_VELOCITY, MAX_VELOCITY, AVG_VELOCITY, SAMPLING_FREQUENCY, 
                 RESOLUTION, RATED_MAX_VELOCITY, RATED_MAX_WT, CLUSTER_RULE_CL, SOURCE_GCL, COMMENTS, TOOL_VENDOR_CL) VALUES
                 (TO_DATE('{DATE}','DD.MM.YYYY'), TO_DATE('{DATE}','DD.MM.YYYY'), 
                 null::numeric, null::numeric, 'UNKNOWN', '{MODEL}', 'UNKNOWN', null::numeric,
                 null::numeric, null::numeric, null::numeric, null::numeric, null::numeric, null::numeric, null::numeric, 
                 null::numeric, null::numeric, null::numeric, null::numeric, 'UNKNOWN', 'UNKNOWN', '{FORMAT}',
                 '{COMPANY}') RETURNING ili_inspection_id INTO RETURNiliid; 

 
    
                         IF {ROUTE_ID} IS NOT NULL or {ROUTE_ID}>0 THEN
                 INSERT INTO pods.event_range(FEATURE_ID,STATION_ID_BEGIN,STATION_ID_END,PODS_USER,CREATE_DATE,EFFECTIVE_FROM_DATE,CURRENT_INDICATOR_LF,POSITIONING_TYPE_CL) 
                 VALUES ('ILI_INSP_RNG',
                 (SELECT MIN(station_id) FROM pods.station_point sp 
                 WHERE sp.route_id = {ROUTE_ID} AND sp.measure = (SELECT MIN(spp.measure) FROM pods.station_point spp WHERE spp.route_id = {ROUTE_ID})),
                 (SELECT MAX(station_id) FROM pods.station_point sp 
                 WHERE sp.route_id = {ROUTE_ID} AND sp.measure = (SELECT MAX(spp.measure) FROM pods.station_point spp WHERE spp.route_id = {ROUTE_ID})),
                 '{config.main.PODS_USER}', current_timestamp, current_timestamp, 'Y', 'UNKNOWN') RETURNING EVENT_ID INTO RETURNeventid;
                 END IF;
                 INSERT INTO PODS.ILI_INSPECTION_RANGE(EVENT_ID,sequence,ascending,ILI_INSPECTION_ID,DESCRIPTION,COMMENTS,WELD_INCREMENT,SOURCE_GCL,START_ODOMETER, END_ODOMETER, LAUNCHER_EVENT_ID, RECEIVER_EVENT_ID,&quot;weld_start_number&quot;) 

                 VALUES(RETURNeventid,1,1,RETURNiliid,v_pipe,'{KM_START}-{KM_END}',null::numeric,'UNKNOWN',null::numeric, null::numeric,
                 (SELECT MIN(lr.event_id) FROM pods.launcher_receiver lr
                 JOIN pods.event_range e ON e.event_id = lr.event_id
                 JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
                 WHERE sp.route_id = {ROUTE_ID} AND lr.type_cl = 'LAUNCH_R_TYPE_06'),
                 (SELECT MAX(lr.event_id) from pods.launcher_receiver lr
                 JOIN pods.event_range e ON e.event_id = lr.event_id
                 JOIN pods.station_point sp ON sp.station_id = e.station_id_begin
                 WHERE sp.route_id = {ROUTE_ID} AND lr.type_cl = 'LAUNCH_R_TYPE_07'),
                 '{call_complex_method.FIRST_WELD_NUMBER}');
     
                 END $$;
			</query>
		</dbCommand>
	</update>
</data>

<data id="ILI_ILI_ZIP_IMP_C_55_8" comment="ILI_ILI_ZIP_IMP_C_55_8" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<insert>
		<dbCommand>
		<var name="SOURCE_GCL"/>
		<var name="DATE"/>		
		<var name="X" type="Decimal"/>	
		<var name="Y" type="Decimal"/>		
		<var name="ILI_INSPECTION_ID" type="Decimal"/>
		<var name="SRV_DISTRICT_GCL" type="Decimal"/>	
		<var name="Z" type="Decimal"/>		
		<var name="WELD_NUMBER" type="String"/>	
		<var name="ABSOLUTE_ODOMETER" type="Decimal"/>	
		<var name="AVERAGE_DEPTH" type="String"/>		
		<var name="LENGTH" type="String"/>
		<var name="WIDTH" type="String"/>	
		<var name="BPR_PIG" type="String"/>		
		<var name="ORIENTATION_DEG" type="String"/>	
		<var name="SOURCE" type="String"/>	
		<var name="ANOMALY_TYPE_CL" type="String"/>		
		<var name="FEATURE_DESCRIPTION" type="String"/>
		<var name="DESCRIPTION" type="String"/>	
		<var name="MILEPOST" type="String"/>		
		<var name="NOMINAL_WALL_THICKNESS" type="String"/>	
		<var name="DL_TUBE" type="Decimal"/>	
		<var name="COMMENTS" type="String"/>
		<var name="US_WELD_ODOMETER" type="Decimal"/>
		<var name="DS_WELD_ODOMETER" type="Decimal"/>
		<var name="US_WELD_NUMBER" type="String"/>
			<query>
				DO $$

				DECLARE
				v_coordinate_id NUMERIC(16);
				v_report_vendor VARCHAR(254);
				v_coordinate_source_operator VARCHAR(16);
				v_coordinate_source_id NUMERIC(16);
				v_year VARCHAR(4);
				v_location_id NUMERIC(16);

				BEGIN

				IF {X} IS NOT NULL AND {Y} IS NOT NULL
				THEN

				SELECT vc.description,EXTRACT(YEAR FROM ii.begin_date)::text
				INTO v_report_vendor,v_year
				FROM pods.ili_inspection ii
				JOIN pods.ili_tool_vendor_cl vc
				ON ii.tool_vendor_cl = vc.code
				WHERE ili_inspection_id = {ILI_INSPECTION_ID};

				SELECT MIN(code)
				INTO v_coordinate_source_operator
				FROM pods.coordinate_source_operator_cl
				WHERE description = v_report_vendor;

				/* Если не нашелся подходящий, то создам нового*/
				IF v_coordinate_source_operator IS NULL
				THEN
				SELECT 'OPERATOR_'||(MAX((substring(code,'\d.'))::numeric) + 1)::text
				INTO v_coordinate_source_operator
				FROM pods.coordinate_source_operator_cl
				WHERE code like 'OPERATOR%'
				AND substring(code,'\d.') IS NOT NULL;

				INSERT INTO pods.coordinate_source_operator_cl (code,description,active_indicator_lf,source_gcl)
				VALUES (v_coordinate_source_operator,v_report_vendor,'Y','NGG');

				END IF;

				SELECT MIN(coordinate_source_id)
				INTO v_coordinate_source_id
				FROM pods.coordinate_source
				WHERE operator_cl = v_coordinate_source_operator
				AND source_name = v_report_vendor||' ('||v_year||')';

				IF v_coordinate_source_id IS NULL
				THEN
				INSERT INTO pods.coordinate_source (source_name,source_type_cl
				,create_date,method_cl,operator_cl,accuracy_cl,coordinate_sys_id)
				VALUES (v_report_vendor||' ('||v_year||')','COORD_S_TYPE_06'
				,current_timestamp,'INSTRUMENT',v_coordinate_source_operator,'UNKNOWN',4284)
				RETURNING coordinate_source_id INTO v_coordinate_source_id;

				END IF;

				INSERT INTO pods.location (srv_district_gcl)
				VALUES ({SRV_DISTRICT_GCL})
				RETURNING location_id INTO v_location_id;

				INSERT INTO pods.coordinate (coordinate_source_id,type_cl,location_id,x_coord,y_coord,z_coord
				,horiz_indicator_lf,vert_indicator_lf,current_indicator_lf,effective_from_date
				,accuracy_cl,validity_tolerance,create_date,pods_user)
				VALUES (v_coordinate_source_id,'PIG',v_location_id,{X},{Y},{Z}
				,'Y',CASE WHEN {Z} IS NOT NULL THEN 'Y' ELSE 'N' END,'Y',current_timestamp
				,'UNKNOWN',0,current_timestamp,'ADMIN')
				RETURNING coordinate_id INTO v_coordinate_id;

				END IF;

				INSERT INTO
				PODS.ILI_DATA(ILI_INSPECTION_ID,WELD_NUMBER,ABSOLUTE_ODOMETER,AVERAGE_DEPTH,LENGTH,WIDTH,BPR_PIG,INTERNAL_EXTERNAL_CL,SOURCE_GCL,DATE_COLLECTED,ORIENTATION_DEG,ANOMALY_TYPE_CL,ANOMALY_EXTENSION_CL,MEASURED_WALL_THICKNESS,FEATURE_DESCRIPTION,DESCRIPTION,MILEPOST,NOMINAL_WALL_THICKNESS,DS_WELD_DISTANCE,COORDINATE_ID,COMMENTS,US_WELD_ODOMETER,DS_WELD_ODOMETER,US_WELD_NUMBER)
				VALUES({ILI_INSPECTION_ID},'{WELD_NUMBER}',{ABSOLUTE_ODOMETER},NULLIF('{AVERAGE_DEPTH}','')::numeric,NULLIF('{LENGTH}','')::numeric,NULLIF('{WIDTH}','')::numeric,NULLIF('{BPR_PIG}','')::numeric,'UNKNOWN','{SOURCE_GCL}',TO_DATE('{DATE}','DD.MM.YYYY'),ROUND(NULLIF('{ORIENTATION_DEG}','')::numeric)
				,CASE WHEN '{SOURCE}'='WLD'
				THEN 5001
				ELSE (SELECT MIN(CODE)
				FROM pods.ili_anomaly_type_cl t
				WHERE upper(','||coalesce(t.description,'')::text || ',' || coalesce(t.anomaly_references,'')::text) LIKE '%'||REGEXP_REPLACE (UPPER (TRIM ('{ANOMALY_TYPE_CL}')),'\(.*\)|[*.?]|\s+','%')|| '%')
				END
				,'UNKNOWN',NULL,'{FEATURE_DESCRIPTION}','{DESCRIPTION}','{MILEPOST}',NULLIF('{NOMINAL_WALL_THICKNESS}','')::numeric,{DL_TUBE},v_coordinate_id,'{COMMENTS}',{US_WELD_ODOMETER},{DS_WELD_ODOMETER},'{US_WELD_NUMBER}'); 			
				END $$;
			</query>
		</dbCommand>
	</insert>
</data> 

<data id="ILI_ILI_ZIP_IMP_C_55_9" comment="ILI_ILI_ZIP_IMP_C_55_9" schema="UTE" table="ILI_ILI_ZIP_IMP_C_55">
	<select>
		<dbQuery>	
			<query>
			SELECT CODE "CODE"
	 			,UPPER(description)
	 			||CASE WHEN ANOMALY_REFERENCES IS NOT NULL
	 			THEN ','|| UPPER(ANOMALY_REFERENCES)
	 			ELSE ''
	 			END "EXTENDED_DESCRIPTION"
	 			FROM pods.ili_anomaly_type_cl
			</query>
		</dbQuery>
	</select>
</data>

<data id="LINE_LINE_WKT_IDX_C_1" comment="LINE_LINE_WKT_IDX_C_1" schema="UTE" table="LINE_LINE_WKT_IDX_C">
	<select>
		<dbQuery>	
			<query>
			SELECT r.ROUTE_ID "ID", c.X_COORD "X",c.Y_COORD "Y", sp.STATION_ID "S_ID"
 			FROM pods.route r 
 			JOIN pods.station_point sp ON sp.route_id = r.route_id AND sp.type_cl IN ('ST_POINT_TYPE_01','ST_POINT_TYPE_02','ST_POINT_TYPE_03')
 			JOIN pods.coordinate c ON c.location_id= sp.location_id AND (c.x_coord::integer&lt;&gt;-1 OR c.y_coord::integer&lt;&gt;-1)
 			JOIN pods.location l ON l.location_id = sp.location_id
 			WHERE r.ROUTE_ID!=0 AND r.type_cl IN ('ROUTE_TYPE_04', 'ROUTE_TYPE_12', 'ROUTE_TYPE_10')
 			ORDER BY r.route_id, r.sequence, sp.measure
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_BAT_IDX_C_1" comment="PS_PS_BAT_IDX_C_1" schema="UTE" table="PS_PS_BAT_IDX_C">
	<select>
		<dbQuery>	
			<query>
			SELECT PIPE_SYSTEM_ID "PIPE_SYSTEM_ID", DESCRIPTION "DESCRIPTION"
 			FROM pods.pipe_system_cl
 			WHERE pipe_system_id != 0
 			AND pipe_system_id IN (SELECT c.id::integer FROM pods.comments c 
 			WHERE c.table_id = 'PIPE_SYSTEM_CL'
 			AND c.comment_by = 'IS_DIRTY'
 			AND c.comments = '1')
 			ORDER BY description
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_BAT_IDX_C_2" comment="PS_PS_BAT_IDX_C_2" schema="UTE" table="PS_PS_BAT_IDX_C">
	<select>
		<dbQuery>	
			<query>
			SELECT TEMPLATE_ID "TEMPLATE_ID", DESCRIPTION "DESCRIPTION", SCHEMA "SCH", OBJECT_NAME "OBJECT_NAME", WHERE_CLAUSE "WHERE_CLAUSE", GID_FIELD "GID_FIELD", BUFFER_WIDTH "BUFFER_WIDTH", QUERY "QUERY"
 			FROM web50.ps_index_obj_template
 			where pipe_system_id = 0
 			ORDER BY DESCRIPTION DESC
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_BAT_IDX_C_ALL_1" comment="PS_PS_BAT_IDX_C_ALL_1" schema="UTE" table="PS_PS_BAT_IDX_C_ALL">
	<select>
		<dbQuery>	
			<query>
			SELECT PIPE_SYSTEM_ID "PIPE_SYSTEM_ID", DESCRIPTION "DESCRIPTION"
 			FROM pods.pipe_system_cl
 			WHERE pipe_system_id != 0
 			ORDER BY description
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_BAT_IDX_C_ALL_2" comment="PS_PS_BAT_IDX_C_ALL_2" schema="UTE" table="PS_PS_BAT_IDX_C_ALL">
	<select>
		<dbQuery>	
			<query>
			SELECT TEMPLATE_ID "TEMPLATE_ID", DESCRIPTION "DESCRIPTION", SCHEMA "SCH", OBJECT_NAME "OBJECT_NAME", WHERE_CLAUSE "WHERE_CLAUSE", GID_FIELD "GID_FIELD", BUFFER_WIDTH "BUFFER_WIDTH", QUERY "QUERY"
 			FROM web50.ps_index_obj_template 
 			where pipe_system_id = 0
 			ORDER BY DESCRIPTION DESC
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_WKT_IDX_C_1" comment="PS_PS_WKT_IDX_C_1" schema="UTE" table="PS_PS_WKT_IDX_C">
	<select>
		<dbQuery>	
			<query>
			SELECT * FROM pods.pipe_system_buffer_g
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_WKT_IDX_C_2" comment="PS_PS_WKT_IDX_C_2" schema="UTE" table="PS_PS_WKT_IDX_C">
	<select>
		<dbQuery>	
			<query>
			WITH 
 			ps_info AS (SELECT PIPE_SYSTEM_ID
 			,MIN(KM_BEGIN) KM_BEGIN
 			,MAX(KM_END) KM_END
 			FROM PODS.PIPE_SYSTEM_BOUNDARY 
 			WHERE TITLE_EVENT_INDICATOR_LF = 'Y'
 			GROUP BY PIPE_SYSTEM_ID),
 			my_routes AS (SELECT psb.PIPE_SYSTEM_ID
 			,r.LINE_ID
 			,r.ROUTE_ID
 			,r.SEQUENCE
 			,CASE r.TYPE_CL
 			WHEN 'ROUTE_TYPE_10' THEN 'G0000001'
 			WHEN 'ROUTE_TYPE_11' THEN 'G0000002'
 			WHEN 'ROUTE_TYPE_12' THEN 'G0000002'
 			WHEN 'ROUTE_TYPE_04' THEN 'G0000003'
 			END OBJ_CLS_GROUP_ID 
 			,s.STATION_BEGIN KM_START
 			,s.STATION_END KM_END
 			,CASE WHEN SIGN(S.STATION_END-S.STATION_BEGIN) = 0 THEN 1
 			ELSE SIGN(S.STATION_END-S.STATION_BEGIN)
 			END M_SIGN 
 			FROM ps_info ps
 			JOIN PODS.PIPE_SYSTEM_BOUNDARY psb 
 			ON ps.PIPE_SYSTEM_ID = psb.PIPE_SYSTEM_ID 
 			JOIN PODS.ROUTE r
 			ON r.LINE_ID = psb.LINE_ID 
 			JOIN PODS.SERIES s
 			ON r.ROUTE_ID = s.ROUTE_ID 
 			WHERE psb.TITLE_EVENT_INDICATOR_LF = 'Y' 
 			AND r.TYPE_CL IN ('ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12','ROUTE_TYPE_04')
 			AND r.CURRENT_INDICATOR_LF = 'Y'
 			AND ((SELECT MAX(MEASURE)-MIN(MEASURE) PIPE_LENGTH
 			FROM PODS.SERIES s
 			JOIN PODS.STATION_POINT sp
 			ON sp.SERIES_ID = s.SERIES_ID
 			WHERE s.ROUTE_ID = r.ROUTE_ID
 			AND s.CURRENT_INDICATOR_LF = 'Y') &gt; 900
 			OR r.TYPE_CL != 'ROUTE_TYPE_04'))
 			SELECT ps_info.PIPE_SYSTEM_ID "ID"
 			,mr.LINE_ID "LINE_ID"
 			,mr.ROUTE_ID "ROUTE_ID"
 			,c.X_COORD "X"
 			,c.Y_COORD "Y"
 			,sp.STATION_ID "S_ID"
 			FROM my_routes mr
 			JOIN PODS.SERIES s
 			ON s.ROUTE_ID = mr.ROUTE_ID
 			JOIN PODS.STATION_POINT sp
 			ON sp.SERIES_ID = s.SERIES_ID 
 			JOIN PODS.COORDINATE c
 			ON c.LOCATION_ID = sp.LOCATION_ID 
 			JOIN ps_info
 			ON ps_info.PIPE_SYSTEM_ID = mr.PIPE_SYSTEM_ID
 			WHERE s.CURRENT_INDICATOR_LF = 'Y'
 			AND c.CURRENT_INDICATOR_LF = 'Y'
 			AND s.station_begin &lt;= ps_info.KM_END
 			AND s.station_end &gt;= ps_info.KM_BEGIN
 			AND sp.station &lt;= ps_info.KM_END
 			AND sp.station &gt;= ps_info.KM_BEGIN
 			AND sp.type_cl IN ('ST_POINT_TYPE_02', 'ST_POINT_TYPE_03')
 			AND ((OBJ_CLS_GROUP_ID = 'G0000003' 
 			AND NOT EXISTS (SELECT 'x' 
 			FROM my_routes 
 			WHERE OBJ_CLS_GROUP_ID in ('G0000001','G0000002')))
 			OR (OBJ_CLS_GROUP_ID = 'G0000002' 
 			AND NOT EXISTS (SELECT 'x' 
 			FROM my_routes 
 			WHERE OBJ_CLS_GROUP_ID = 'G0000001'))
 			OR OBJ_CLS_GROUP_ID = 'G0000001') 
 			ORDER BY mr.LINE_ID, mr.SEQUENCE, s.SERIES_ID, sp.MEASURE*mr.m_sign
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_XY_IDX_C_1" comment="PS_PS_XY_IDX_C_1" schema="UTE" table="PS_PS_XY_IDX_C">
	<select>
		<dbQuery>	
			<query>
			SELECT * FROM pods.pipe_system_buffer_g
			</query>
		</dbQuery>
	</select>
</data>

<data id="PS_PS_XY_IDX_C_1" comment="PS_PS_XY_IDX_C_1" schema="UTE" table="PS_PS_XY_IDX_C">
	<select>
		<dbQuery>	
			<query>
			WITH 
 			ps_info AS (SELECT PIPE_SYSTEM_ID
 			,MIN(KM_BEGIN) KM_BEGIN
 			,MAX(KM_END) KM_END
 			FROM PODS.PIPE_SYSTEM_BOUNDARY 
 			WHERE TITLE_EVENT_INDICATOR_LF = 'Y'
 			GROUP BY PIPE_SYSTEM_ID),
 			my_routes AS (SELECT psb.PIPE_SYSTEM_ID
 			,r.LINE_ID
 			,r.ROUTE_ID
 			,r.SEQUENCE
 			,CASE r.TYPE_CL
 			WHEN 'ROUTE_TYPE_10' THEN 'G0000001'
 			WHEN 'ROUTE_TYPE_11' THEN 'G0000002'
 			WHEN 'ROUTE_TYPE_12' THEN 'G0000002'
 			WHEN 'ROUTE_TYPE_04' THEN 'G0000003'
 			END OBJ_CLS_GROUP_ID 
 			,s.STATION_BEGIN KM_START
 			,s.STATION_END KM_END
 			,CASE WHEN SIGN(S.STATION_END-S.STATION_BEGIN) = 0 THEN 1
 			ELSE SIGN(S.STATION_END-S.STATION_BEGIN)
 			END M_SIGN 
 			FROM ps_info ps
 			JOIN PODS.PIPE_SYSTEM_BOUNDARY psb 
 			ON ps.PIPE_SYSTEM_ID = psb.PIPE_SYSTEM_ID 
 			JOIN PODS.ROUTE r
 			ON r.LINE_ID = psb.LINE_ID 
 			JOIN PODS.SERIES s
 			ON r.ROUTE_ID = s.ROUTE_ID 
 			WHERE psb.TITLE_EVENT_INDICATOR_LF = 'Y' 
 			AND r.TYPE_CL IN ('ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12','ROUTE_TYPE_04')
 			AND r.CURRENT_INDICATOR_LF = 'Y'
 			AND ((SELECT MAX(MEASURE)-MIN(MEASURE) PIPE_LENGTH
 			FROM PODS.SERIES s
 			JOIN PODS.STATION_POINT sp
 			ON sp.SERIES_ID = s.SERIES_ID
 			WHERE s.ROUTE_ID = r.ROUTE_ID
 			AND s.CURRENT_INDICATOR_LF = 'Y') &gt; 900
 			OR r.TYPE_CL != 'ROUTE_TYPE_04'))
 			SELECT ps_info.PIPE_SYSTEM_ID "ID"
 			,mr.LINE_ID "LINE_ID"
 			,mr.ROUTE_ID "ROUTE_ID"
 			,c.X_COORD "X"
 			,c.Y_COORD "Y"
 			,sp.STATION_ID "S_ID"
 			FROM my_routes mr
 			JOIN PODS.SERIES s
 			ON s.ROUTE_ID = mr.ROUTE_ID
 			JOIN PODS.STATION_POINT sp
 			ON sp.SERIES_ID = s.SERIES_ID 
 			JOIN PODS.COORDINATE c
 			ON c.LOCATION_ID = sp.LOCATION_ID 
 			JOIN ps_info
 			ON ps_info.PIPE_SYSTEM_ID = mr.PIPE_SYSTEM_ID
 			WHERE s.CURRENT_INDICATOR_LF = 'Y'
 			AND c.CURRENT_INDICATOR_LF = 'Y'
 			AND s.station_begin &lt;= ps_info.KM_END
 			AND s.station_end &gt;= ps_info.KM_BEGIN
 			AND sp.station &lt;= ps_info.KM_END
 			AND sp.station &gt;= ps_info.KM_BEGIN
 			AND sp.type_cl IN ('ST_POINT_TYPE_02', 'ST_POINT_TYPE_03')
 			AND ((OBJ_CLS_GROUP_ID = 'G0000003' 
 			AND NOT EXISTS (SELECT 'x' 
 			FROM my_routes 
 			WHERE OBJ_CLS_GROUP_ID in ('G0000001','G0000002')))
 			OR (OBJ_CLS_GROUP_ID = 'G0000002' 
 			AND NOT EXISTS (SELECT 'x' 
 			FROM my_routes 
 			WHERE OBJ_CLS_GROUP_ID = 'G0000001'))
 			OR OBJ_CLS_GROUP_ID = 'G0000001') 
 			ORDER BY mr.LINE_ID, mr.SEQUENCE, s.SERIES_ID, sp.MEASURE*mr.m_sign
			</query>
		</dbQuery>
	</select>
</data>

<data id="TAB_TAB_BLOB_EXP_C_1" comment="TAB_TAB_BLOB_EXP_C_1" schema="UTE" table="TAB_TAB_BLOB_EXP_C">
	<select>
		<dbQuery>	
		<var name="FILE_NAME_FIELD"/>			
		<var name="BLOB_FIELD"/>			
		<var name="TABLE_NAME"/>	
		<var name="ID_FIELD"/>			
		<var name="FILE_ID"/>		
			<query>
			SELECT {FILE_NAME_FIELD} "FILE_NAME", {BLOB_FIELD} "BODY" FROM {TABLE_NAME} WHERE {ID_FIELD} IN ({FILE_ID})
			</query>
		</dbQuery>
	</select>
</data>

<data id="GROUP_ROUTE_IDX_ALL_1" comment="GROUP_ROUTE_IDX_ALL_1" schema="UTE" table="GROUP_ROUTE_IDX_ALL">
	<select>
		<dbQuery>		
			<query>
			SELECT ROUTE_ID "ROUTE_ID"
 			FROM pods.route
 			WHERE type_cl IN ('ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12','ROUTE_TYPE_04')
			</query>
		</dbQuery>
	</select>
</data>

<data id="INTERVAL_BAT_DIVINING_UTE_1" comment="INTERVAL_BAT_DIVINING_UTE_1" schema="UTE" table="INTERVAL_BAT_DIVINING_UTE">
	<select>
		<dbQuery>		
			<query>
			SELECT ROUTE_ID "ROUTE_ID"
			FROM pods.route
			WHERE line_id = 1300013
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="KM_ROUTE_CALC_ALL_1" comment="KM_ROUTE_CALC_ALL_1" schema="UTE" table="KM_ROUTE_CALC_ALL">
	<select>
		<dbQuery>		
			<query>
			SELECT ROUTE_ID "ROUTE_ID"
			FROM pods.route
			WHERE line_id != 0
			</query>
		</dbQuery>
	</select>
</data>
 
<data id="LINE_ROUTE_IDX_ALL_1" comment="LINE_ROUTE_IDX_ALL_1" schema="UTE" table="LINE_ROUTE_IDX_ALL">
	<select>
		<dbQuery>		
			<query>
			SELECT ROUTE_ID "ROUTE_ID"
			FROM pods.route
			WHERE type_cl IN ('ROUTE_TYPE_10','ROUTE_TYPE_11','ROUTE_TYPE_12','ROUTE_TYPE_04')
			</query>
		</dbQuery>
	</select>
</data>

<data id="LRS_ROUTE_CALC_ALL_1" comment="LRS_ROUTE_CALC_ALL_1" schema="UTE" table="LRS_ROUTE_CALC_ALL">
	<select>
		<dbQuery>		
			<query>
			SELECT ROUTE_ID "ROUTE_ID"
			FROM pods.route
			WHERE line_id != 0 
			</query>
		</dbQuery>
	</select>
</data>

<data id="OFFLINE_LINE_IDX_ALL_1" comment="OFFLINE_LINE_IDX_ALL_1" schema="UTE" table="OFFLINE_LINE_IDX_ALL">
	<select>
		<dbQuery>		
			<query>
			SELECT r.ROUTE_ID "LINE_ID"
			FROM pods.route r
			WHERE r.line_id != 0
			AND r.type_cl IN ('ROUTE_TYPE_04','ROUTE_TYPE_10','ROUTE_TYPE_12')
			</query>
		</dbQuery>
	</select>
</data>

<data id="KPG_INTEGR_1" comment="KPG_INTEGR_1" schema="UTE" table="KPG_INTEGR">
	<select>
		<dbQuery>		
			<query>
			truncate table FLOW_CHART.KAP_REMONT_PLAN cascade
			</query>
		</dbQuery>
	</select>
</data>

<data id="KPG_INTEGR_2" comment="вставка данных КПГ в БД postgresql" schema="UTE" table="KPG_INTEGR">
 <insert>
      <dbCommand>
        <var name="ID" type="Decimal"/>
        <var name="LINE_DESCRIPTION" default="" type="String" />
        <var name="OBJECT_NAME" default="" type="String" />
        <var name="STATION_BEGIN" default="" type="Decimal" />
        <var name="STATION_END" default="" type="Decimal" />
        <var name="OBJECT_PLAN_DESCRIPTION" default="" type="String" />
        <var name="TYPE_ID" default="" type="String" />
        <var name="CATEGORY_ID" default="" type="String" />
        <var name="METHOD_ID" default="" type="String" />
        <var name="EFFECT_ID" default="" type="String" />
        <var name="INVENT_NUMBER" default="" type="String" />
        <var name="OBJECT_CODE_XYZ" default="" type="String" />
        <var name="PLAN_STRING_ID" default="" type="String" />
        <var name="OBJECT_OZP" default="" type="String" />
        <var name="ROUTE_CONDITION_ID" default="" type="String" />
        <var name="PERIOD_MTR" default="" type="String" />
        <var name="WORK_DESCRIPTION" default="" type="String" />
        <var name="COMMENTS" default="" type="String" />
        <var name="DATE_BEGIN" default="" type="DateTime" />
        <var name="DATE_END" default="" type="DateTime" />
        <var name="WORK_PERIOD_HOUR" default="" type="Decimal" />
        <var name="PIT_GAS" default="" type="Decimal" />
        <var name="STORE_GAS" default="" type="Decimal" />
        <var name="DISCHARGE_GAS" default="" type="Decimal" />
        <var name="ALLOW_PAPER_NUMBER" default="" type="String" />
        <var name="TRANSPORT_GAS_VAL_WINTER" default="" type="Decimal" />
        <var name="TRANSPORT_GAS_VAL_SUMMER" default="" type="Decimal" />
        <var name="TRANSPORT_GAS_VAL_OTH_SEASON" default="" type="Decimal" />
        <var name="CALC_GAS_VAL_WINTER" default="" type="Decimal" />
        <var name="CALC_GAS_VAL_SUMMER" default="" type="Decimal" />
        <var name="CALC_GAS_VAL_OTH_SEASON" default="" type="Decimal" />
        <var name="CALC_GAS_VAL_WORK" default="" type="Int64" />
        <var name="SRV_DISTRICT_LIST" default="" type="String" />
        <var name="ORDER_ID" default="" type="Decimal" />        
       <query>
          INSERT INTO FLOW_CHART.KAP_REMONT_PLAN(line_description, object_name, station_begin, station_end, object_plan_description, type_id, category_id, method_id, effect_id, invent_number, object_code_xyz, plan_string_id, object_ozp, route_condition_id, period_mtr, work_description, "comments", date_begin, date_end, work_period_hour, pit_gas, store_gas, discharge_gas, allow_paper_number, transport_gas_val_winter, transport_gas_val_summer, transport_gas_val_oth_season, calc_gas_val_winter, calc_gas_val_summer, calc_gas_val_oth_season, calc_gas_val_work, srv_district_list, order_id)
VALUES( '{LINE_DESCRIPTION}', '{OBJECT_NAME}', {STATION_BEGIN}, {STATION_END}, '{OBJECT_PLAN_DESCRIPTION}', '{TYPE_ID}', '{CATEGORY_ID}', '{METHOD_ID}', '{EFFECT_ID}', '{INVENT_NUMBER}', '{OBJECT_CODE_XYZ}', '{PLAN_STRING_ID}', '{OBJECT_OZP}', '{ROUTE_CONDITION_ID}', '{PERIOD_MTR}', '{WORK_DESCRIPTION}', '{COMMENTS}', '{DATE_BEGIN}', '{DATE_END}', {WORK_PERIOD_HOUR}, {PIT_GAS}, {STORE_GAS}, {DISCHARGE_GAS}, '{ALLOW_PAPER_NUMBER}', {TRANSPORT_GAS_VAL_WINTER}, {TRANSPORT_GAS_VAL_SUMMER}, {TRANSPORT_GAS_VAL_OTH_SEASON}, {CALC_GAS_VAL_WINTER}, {CALC_GAS_VAL_SUMMER}, {CALC_GAS_VAL_OTH_SEASON}, {CALC_GAS_VAL_WORK}, '{SRV_DISTRICT_LIST}', {ORDER_ID}) 
        </query>
      </dbCommand>
    </insert>
</data>


<data id="SUTSTPA_INTEGR_BEFORE" comment="чимстка sutstpa.mismatch_inf_data" schema="sutstpa" table="mismatch_inf_data">
	<insert>
            <dbCommand>
                <query>
				delete from SUTSTPA.MISMATCH_INF_DATA
                </query>
            </dbCommand>
	</insert>
</data>  
<data id="SUTSTPA_INTEGR_AFTER" comment="сверка sutstpa.mismatch_inf_data и таблицы sutstpa.valve" schema="sutstpa" table="mismatch_inf_data">
	<insert>
            <dbCommand>
                <query>
DO $$
begin
   update sutstpa.mismatch_inf_data s set valve_id=null;
      update sutstpa.mismatch_inf_data s set valve_id=(select id from sutstpa.valve v,sutstpa.mismatch_inf_pipe_gcl g where ltrim(v.pipe)=ltrim(g.pipe) 
and ltrim(g.inf_pipe)=ltrim(s.pipe) and s.station=v.station and v.nom_diam_id=s.nom_diam_id ) where exists (select 1 from sutstpa.valve v,sutstpa.mismatch_inf_pipe_gcl g where ltrim(v.pipe)=ltrim(g.pipe) 
and ltrim(g.inf_pipe)=ltrim(s.pipe) and s.station=v.station and v.nom_diam_id=s.nom_diam_id  group by id having count(*)=1);

      update sutstpa.mismatch_inf_data s set valve_id=(select id from sutstpa.valve v,sutstpa.mismatch_inf_pipe_gcl g where ltrim(v.pipe)=ltrim(g.pipe) 
and ltrim(g.inf_pipe)=ltrim(s.pipe) and s.station=v.station and v.nom_diam_id=s.nom_diam_id and s.serial_num=v.serial_num) where exists (select id from sutstpa.valve v,sutstpa.mismatch_inf_pipe_gcl g where ltrim(v.pipe)=ltrim(g.pipe) 
and ltrim(g.inf_pipe)=ltrim(s.pipe) and s.station=v.station and v.nom_diam_id=s.nom_diam_id and s.name_id=v.name_id  group by id having count(*)=1);

      update sutstpa.mismatch_inf_data s set valve_id=(select id from sutstpa.valve v,sutstpa.mismatch_inf_pipe_gcl g where ltrim(v.pipe)=ltrim(g.pipe) 
and ltrim(g.inf_pipe)=ltrim(s.pipe) and s.station=v.station and v.nom_diam_id=s.nom_diam_id and s.name_id=v.name_id) where exists (select id from sutstpa.valve v,sutstpa.mismatch_inf_pipe_gcl g where ltrim(v.pipe)=ltrim(g.pipe) 
and ltrim(g.inf_pipe)=ltrim(s.pipe) and s.station=v.station and v.nom_diam_id=s.nom_diam_id and s.name_id=v.name_id  group by id having count(*)=1);


delete from sutstpa.mismatch_infoteh;

insert into sutstpa.mismatch_infoteh (valve_id, column_name, column_value, action_id, person_id)
					 select s.VALVE_ID::numeric,'CLIMATIC_TYPE_ID' colummn_name, s.CLIMATIC_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and upper(coalesce(s.CLIMATIC_TYPE_ID::text,''))=coalesce(upper(v.CLIMATIC_TYPE_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'DATE_INSTALL' colummn_name, s.DATE_INSTALL::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.DATE_INSTALL::text,'')=coalesce(to_char(v.DATE_INSTALL,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'DATE_MANUF' colummn_name, s.DATE_MANUF::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.DATE_MANUF::text,'')=coalesce(to_char(v.DATE_MANUF,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null union all
				/*	 select s.VALVE_ID::numeric,'ELECTRIC_DRIVE_DESCR' colummn_name, s.ELECTRIC_DRIVE_READY_DESCR::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.ELECTRIC_DRIVE_READY_DESCR::text),'')=coalesce(upper(v.ELECTRIC_DRIVE_DESCR::text),''))  and s.VALVE_ID is not null union all*/
					 select s.VALVE_ID::numeric,'DATE_WORK_BEGIN' colummn_name, s.DATE_WORK_BEGIN::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.DATE_WORK_BEGIN::text,'')=coalesce(to_char(v.DATE_WORK_BEGIN,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'INSTALL_TYPE_ID' colummn_name, s.INSTALL_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.INSTALL_TYPE_ID::text),'')=coalesce(upper(v.INSTALL_TYPE_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'INVENT_NUMBER' colummn_name, s.INVENT_NUMBER::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.INVENT_NUMBER::text),'')=coalesce(upper(v.INVENT_NUMBER::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'JOINT_ID' colummn_name, s.JOINT_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.JOINT_ID::text),'')=coalesce(upper(v.JOINT_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'LIFETIME' colummn_name, s.LIFETIME::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.LIFETIME::text),'')=coalesce(upper(v.LIFETIME::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'MANUF_ID' colummn_name, s.MANUF_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.MANUF_ID::text),'')=coalesce(upper(v.MANUF_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'NAME_ID' colummn_name, s.NAME_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.NAME_ID::text),'')=coalesce(upper(v.NAME_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'NOM_DIAM_ID' colummn_name, s.NOM_DIAM_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.NOM_DIAM_ID::text),'')=coalesce(upper(v.NOM_DIAM_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'NOM_PRESS_ID' colummn_name, s.NOM_PRESS_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.NOM_PRESS_ID::text),'')=coalesce(upper(v.NOM_PRESS_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'OPER_DATE_WORK_BEGIN' colummn_name, s.OPER_DATE_WORK_BEGIN::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.OPER_DATE_WORK_BEGIN::text,'')=coalesce(to_char(v.OPER_DATE_WORK_BEGIN,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'OPER_MANUF_ID' colummn_name, s.OPER_MANUF_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.OPER_MANUF_ID::text),'')=coalesce(upper(v.OPER_MANUF_ID::text),''))  and s.VALVE_ID is not null union all
				/*	 select s.VALVE_ID::numeric,'PASSPORT_DOCUMENT_DESCR' colummn_name, s.PASSPORT_DOCUMENT_DESCR::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.PASSPORT_DOCUMENT_DESCR::text),'')=coalesce(upper(v.PASSPORT_DOCUMENT_DESCR::text),''))  and s.VALVE_ID is not null union all*/
					 select s.VALVE_ID::numeric,'SERIAL_NUM' colummn_name, s.SERIAL_NUM::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.SERIAL_NUM::text),'')=coalesce(upper(v.SERIAL_NUM::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'TECH_NUM' colummn_name, s.TECH_NUM::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.TECH_NUM::text),'')=coalesce(upper(v.TECH_NUM::text),''))  and s.VALVE_ID is not null union all
				/*	 select s.VALVE_ID::numeric,'WORK_PRESSURE_FACT' colummn_name, s.WORK_PRESSURE_FACT::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.WORK_PRESSURE_FACT::text),'')=coalesce(upper(v.WORK_PRESSURE_FACT::text),''))  and s.VALVE_ID is not null union all*/
				/*	 select s.VALVE_ID::numeric,'WORK_TEMP_FACT' colummn_name, s.WORK_TEMP_FACT::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.WORK_TEMP_FACT::text),'')=coalesce(upper(v.WORK_TEMP_FACT::text),''))  and s.VALVE_ID is not null union all*/
				/*	 select s.VALVE_ID::numeric,'WORK_TEMP_PROJECT' colummn_name, s.WORK_TEMP_PROJECT::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.WORK_TEMP_PROJECT::text),'')=coalesce(upper(v.WORK_TEMP_PROJECT::text),''))  and s.VALVE_ID is not null union all*/
					 select s.VALVE_ID::numeric,'TYPE_ID' colummn_name, s.TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.TYPE_ID::text),'')=coalesce(upper(v.TYPE_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'OPER_TYPE_ID' colummn_name, s.OPER_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.OPER_TYPE_ID::text),'')=coalesce(upper(v.OPER_TYPE_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'MATERIAL_ID' colummn_name, s.VALVE_MATERIAL_TYPE_CL::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.VALVE_MATERIAL_TYPE_CL::text),'')=coalesce(upper(v.MATERIAL_ID::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'tpa_constr_type_id' colummn_name, s.tpa_constr_type_id::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.tpa_constr_type_id::text),'')=coalesce(upper(v.tpa_constr_type_id::text),''))  and s.VALVE_ID is not null union all
					 select s.VALVE_ID::numeric,'DATE_EXP' colummn_name, s.DATE_EXP::text column_value, 'исправить', null::numeric from sutstpa.mismatch_inf_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.DATE_EXP::text,'')=coalesce(to_char(v.DATE_EXP,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null;
END$$; 
             </query>
            </dbCommand>
	</insert>
</data>

<data id="SUTSTPA_INTEGR" comment="вставка данных ТПА в таблицу sutstpa.mismatch_inf_data" schema="sutstpa" table="mismatch_inf_data">
	<update>
            <dbCommand>
                <query>
				INSERT INTO SUTSTPA.MISMATCH_INF_DATA
(INF_ID, VALVE_ID, LPU, PIPE, STATION, TYPE_ID, OPER_TYPE_ID, NAME_ID, MEST, TECH_NUM, JOINT_ID, NOM_DIAM_ID, NOM_PRESS_ID, SERIAL_NUM, MANUF_ID, DATE_MANUF, VALVE_MATERIAL_TYPE_CL, INSTALL_TYPE_ID, TPA_CONSTR_TYPE_ID, 
				   DATE_INSTALL, CLIMATIC_TYPE_ID, LIFETIME, OPER_MANUF_ID, OPER_DATE_WORK_BEGIN, DATE_WORK_BEGIN, INVENT_NUMBER, DATE_EXP, PRIM)
VALUES(:INF_ID, null, :LPU, :PIPE, :STATION, :TYPE_ID, :OPER_TYPE_ID, :NAME_ID, :MEST, :TECH_NUM, :JOINT_ID, :NOM_DIAM_ID, :NOM_PRESS_ID, :SERIAL_NUM, :MANUF_ID,TO_DATE(substring(:DATE_MANUF,1,4),'YYYY'), 
:VALVE_MATERIAL_TYPE_CL, :INSTALL_TYPE_ID, :TPA_CONSTR_TYPE_ID, TO_DATE(substring(:DATE_INSTALL,1,10),'DD.MM.YYYY'), :CLIMATIC_TYPE_ID, :LIFETIME, :OPER_MANUF_ID, 
TO_DATE(substring(:OPER_DATE_WORK_BEGIN,1,4),'YYYY'), TO_DATE(substring(:DATE_WORK_BEGIN,1,4),'YYYY'), :INVENT_NUMBER, TO_DATE(substring(:DATE_EXP,1,10),'DD.MM.YYYY'), :PRIM)
                </query>
            </dbCommand>
	</update>
</data>  

<data id="SUTSTPA_EXEC_DOC_AFTER" comment="сверка sutstpa.mismatch_inf_data и таблицы sutstpa.valve" schema="sutstpa" table="mismatch_inf_data">
	<insert>
            <dbCommand>
                <query>
DO $$
begin
update sutstpa.mismatch_exec_data s set valve_id=null;
update sutstpa.mismatch_exec_data s set valve_id=(select id from sutstpa.valve v where ltrim(v.pipe)=ltrim(s.pipe) and s.station=v.station and v.nom_diam_id=s.nom_diam_id limit 1) where 
exists (select 1 from sutstpa.valve v where ltrim(v.pipe)=ltrim(s.pipe) and s.station=v.station and v.nom_diam_id=s.nom_diam_id);


INSERT INTO sutstpa.mismatch_exec_doc
(valve_id, column_name, column_value, action_id, person_id)
select s.VALVE_ID::numeric,'CLIMATIC_TYPE_ID' colummn_name, s.CLIMATIC_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.CLIMATIC_TYPE_ID::text),'')=coalesce(upper(v.CLIMATIC_TYPE_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'DATE_INSTALL' colummn_name, s.DATE_INSTALL::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.DATE_INSTALL::text,'')=coalesce(to_char(v.DATE_INSTALL,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'DATE_MANUF' colummn_name, s.DATE_MANUF::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.DATE_MANUF::text,'')=coalesce(to_char(v.DATE_MANUF,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'INSTALL_TYPE_ID' colummn_name, s.INSTALL_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.INSTALL_TYPE_ID::text),'')=coalesce(upper(v.INSTALL_TYPE_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'JOINT_ID' colummn_name, s.JOINT_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.JOINT_ID::text),'')=coalesce(upper(v.JOINT_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'LIFETIME' colummn_name, s.LIFETIME::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.LIFETIME::text),'')=coalesce(upper(v.LIFETIME::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'MANUF_ID' colummn_name, s.MANUF_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.MANUF_ID::text),'')=coalesce(upper(v.MANUF_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'NOM_DIAM_ID' colummn_name, s.NOM_DIAM_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.NOM_DIAM_ID::text),'')=coalesce(upper(v.NOM_DIAM_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'NOM_PRESS_ID' colummn_name, s.NOM_PRESS_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.NOM_PRESS_ID::text),'')=coalesce(upper(v.NOM_PRESS_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'OPER_DATE_WORK_BEGIN' colummn_name, s.OPER_DATE_WORK_BEGIN::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.OPER_DATE_WORK_BEGIN::text,'')=coalesce(to_char(v.OPER_DATE_WORK_BEGIN,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'OPER_LABEL_TYPE_ID' colummn_name, s.OPER_LABEL_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.OPER_LABEL_TYPE_ID::text),'')=coalesce(upper(v.OPER_LABEL_TYPE_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'OPER_MANUF_ID' colummn_name, s.OPER_MANUF_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.OPER_MANUF_ID::text),'')=coalesce(upper(v.OPER_MANUF_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'SERIAL_NUM' colummn_name, s.SERIAL_NUM::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.SERIAL_NUM::text),'')=coalesce(upper(v.SERIAL_NUM::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'TECH_NUM' colummn_name, s.TECH_NUM::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.TECH_NUM::text),'')=coalesce(upper(v.TECH_NUM::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'TYPE_ID' colummn_name, s.TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.TYPE_ID::text),'')=coalesce(upper(v.TYPE_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'OPER_TYPE_ID' colummn_name, s.OPER_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.OPER_TYPE_ID::text),'')=coalesce(upper(v.OPER_TYPE_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'MATERIAL_ID' colummn_name, s.VALVE_MATERIAL_TYPE_CL::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.VALVE_MATERIAL_TYPE_CL::text),'')=coalesce(upper(v.MATERIAL_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'TPA_FIGURE_TYPE_ID' colummn_name, s.TPA_FIGURE_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.TPA_FIGURE_TYPE_ID::text),'')=coalesce(upper(v.TPA_FIGURE_TYPE_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'TPA_CONSTR_TYPE_ID' colummn_name, s.TPA_CONSTR_TYPE_ID::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.TPA_CONSTR_TYPE_ID::text),'')=coalesce(upper(v.TPA_CONSTR_TYPE_ID::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'OPER_DATE_MANUF' colummn_name, s.OPER_DATE_MANUF::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(s.OPER_DATE_MANUF::text,'')=coalesce(to_char(v.OPER_DATE_MANUF,'DD.MM.YYYY'),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id) union all
select s.VALVE_ID::numeric,'OPER_SERIAL_NUMBER' colummn_name, s.OPER_SERIAL_NUMBER::text column_value, 'исправить', null::numeric from sutstpa.mismatch_exec_data s where not exists (select 1 from sutstpa.valve v where v.id::text=s.VALVE_ID::text and coalesce(upper(s.OPER_SERIAL_NUMBER::text),'')=coalesce(upper(v.OPER_SERIAL_NUMBER::text),''))  and s.VALVE_ID is not null and not exists (select 1 from sutstpa.mismatch_exec_doc e where e.valve_id=s.valve_id);
END$$; 
                </query>
            </dbCommand>
	</insert>
</data>
</root>
